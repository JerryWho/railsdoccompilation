  <div id="fileHeader">
    <h1>multipart_params_parsing_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/test/controller/request/multipart_params_parsing_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'abstract_unit'

class MultipartParamsParsingTest &lt; ActionController::IntegrationTest
  class TestController &lt; ActionController::Base
    class &lt;&lt; self
      attr_accessor :last_request_parameters
    end

    def parse
      self.class.last_request_parameters = request.request_parameters
      head :ok
    end

    def read
      render :text =&gt; &quot;File: #{params[:uploaded_data].read}&quot;
    end
  end

  FIXTURE_PATH = File.dirname(__FILE__) + '/../../fixtures/multipart'

  def teardown
    TestController.last_request_parameters = nil
  end

  test &quot;parses single parameter&quot; do
    assert_equal({ 'foo' =&gt; 'bar' }, parse_multipart('single_parameter'))
  end

  test &quot;parses bracketed parameters&quot; do
    assert_equal({ 'foo' =&gt; { 'baz' =&gt; 'bar'}}, parse_multipart('bracketed_param'))
  end

  test &quot;parses text file&quot; do
    params = parse_multipart('text_file')
    assert_equal %w(file foo), params.keys.sort
    assert_equal 'bar', params['foo']

    file = params['file']
    assert_kind_of Tempfile, file
    assert_equal 'file.txt', file.original_filename
    assert_equal &quot;text/plain&quot;, file.content_type
    assert_equal 'contents', file.read
  end

  test &quot;parses boundary problem file&quot; do
    params = parse_multipart('boundary_problem_file')
    assert_equal %w(file foo), params.keys.sort

    file = params['file']
    foo  = params['foo']

    assert_kind_of Tempfile, file

    assert_equal 'file.txt', file.original_filename
    assert_equal &quot;text/plain&quot;, file.content_type

    assert_equal 'bar', foo
  end

  test &quot;parses large text file&quot; do
    params = parse_multipart('large_text_file')
    assert_equal %w(file foo), params.keys.sort
    assert_equal 'bar', params['foo']

    file = params['file']

    assert_kind_of Tempfile, file

    assert_equal 'file.txt', file.original_filename
    assert_equal &quot;text/plain&quot;, file.content_type
    assert ('a' * 20480) == file.read
  end

  test &quot;parses binary file&quot; do
    params = parse_multipart('binary_file')
    assert_equal %w(file flowers foo), params.keys.sort
    assert_equal 'bar', params['foo']

    file = params['file']
    assert_kind_of Tempfile, file
    assert_equal 'file.csv', file.original_filename
    assert_nil file.content_type
    assert_equal 'contents', file.read

    file = params['flowers']
    assert_kind_of Tempfile, file
    assert_equal 'flowers.jpg', file.original_filename
    assert_equal &quot;image/jpeg&quot;, file.content_type
    assert_equal 19512, file.size
  end

  test &quot;parses mixed files&quot; do
    params = parse_multipart('mixed_files')
    assert_equal %w(files foo), params.keys.sort
    assert_equal 'bar', params['foo']

    # Ruby CGI doesn't handle multipart/mixed for us.
    files = params['files']
    assert_kind_of Tempfile, files
    files.force_encoding('ASCII-8BIT') if files.respond_to?(:force_encoding)
    assert_equal 19756, files.size
  end

  test &quot;does not create tempfile if no file has been selected&quot; do
    params = parse_multipart('none')
    assert_equal %w(submit-name), params.keys.sort
    assert_equal 'Larry', params['submit-name']
    assert_equal nil, params['files']
  end

  test &quot;parses empty upload file&quot; do
    params = parse_multipart('empty')
    assert_equal %w(files submit-name), params.keys.sort
    assert_equal 'Larry', params['submit-name']
    assert params['files']
    assert_equal &quot;&quot;, params['files'].read
  end

  test &quot;uploads and reads binary file&quot; do
    with_test_routing do
      fixture = FIXTURE_PATH + &quot;/mona_lisa.jpg&quot;
      params = { :uploaded_data =&gt; fixture_file_upload(fixture, &quot;image/jpg&quot;) }
      post '/read', params
      expected_length = 'File: '.length + File.size(fixture)
      assert_equal expected_length, response.content_length
    end
  end

  test &quot;uploads and reads file&quot; do
    with_test_routing do
      post '/read', :uploaded_data =&gt; fixture_file_upload(FIXTURE_PATH + &quot;/hello.txt&quot;, &quot;text/plain&quot;)
      assert_equal &quot;File: Hello&quot;, response.body
    end
  end

  private
    def fixture(name)
      File.open(File.join(FIXTURE_PATH, name), 'rb') do |file|
        { &quot;rack.input&quot; =&gt; file.read,
          &quot;CONTENT_TYPE&quot; =&gt; &quot;multipart/form-data; boundary=AaB03x&quot;,
          &quot;CONTENT_LENGTH&quot; =&gt; file.stat.size.to_s }
      end
    end

    def parse_multipart(name)
      with_test_routing do
        headers = fixture(name)
        post &quot;/parse&quot;, headers.delete(&quot;rack.input&quot;), headers
        assert_response :ok
        TestController.last_request_parameters
      end
    end

    def with_test_routing
      with_routing do |set|
        set.draw do |map|
          map.connect ':action', :controller =&gt; &quot;multipart_params_parsing_test/test&quot;
        end
        yield
      end
    end
end
</pre>
    </div>