  <div id="fileHeader">
    <h1>routing_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/test/controller/routing_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Nov 27 16:38:15 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'abstract_unit'
require 'controller/fake_controllers'
require 'action_controller/routing/route_set'

class MilestonesController &lt; ActionController::Base
  def index() head :ok end
  alias_method :show, :index
  def rescue_action(e) raise e end
end

RunTimeTests = ARGV.include? 'time'
ROUTING = ActionController::Routing

class ROUTING::RouteBuilder
  attr_reader :warn_output

  def warn(msg)
    (@warn_output ||= []) &lt;&lt; msg
  end
end

# See RFC 3986, section 3.3 for allowed path characters.
class UriReservedCharactersRoutingTest &lt; Test::Unit::TestCase
  def setup
    ActionController::Routing.use_controllers! ['controller']
    @set = ActionController::Routing::RouteSet.new
    @set.draw do |map|
      map.connect ':controller/:action/:variable/*additional'
    end

    safe, unsafe = %w(: @ &amp; = + $ , ;), %w(^ / ? # [ ])
    hex = unsafe.map { |char| '%' + char.unpack('H2').first.upcase }

    @segment = &quot;#{safe.join}#{unsafe.join}&quot;.freeze
    @escaped = &quot;#{safe.join}#{hex.join}&quot;.freeze
  end

  def test_route_generation_escapes_unsafe_path_characters
    assert_equal &quot;/contr#{@segment}oller/act#{@escaped}ion/var#{@escaped}iable/add#{@escaped}itional-1/add#{@escaped}itional-2&quot;,
      @set.generate(:controller =&gt; &quot;contr#{@segment}oller&quot;,
                    :action =&gt; &quot;act#{@segment}ion&quot;,
                    :variable =&gt; &quot;var#{@segment}iable&quot;,
                    :additional =&gt; [&quot;add#{@segment}itional-1&quot;, &quot;add#{@segment}itional-2&quot;])
  end

  def test_route_recognition_unescapes_path_components
    options = { :controller =&gt; &quot;controller&quot;,
                :action =&gt; &quot;act#{@segment}ion&quot;,
                :variable =&gt; &quot;var#{@segment}iable&quot;,
                :additional =&gt; [&quot;add#{@segment}itional-1&quot;, &quot;add#{@segment}itional-2&quot;] }
    assert_equal options, @set.recognize_path(&quot;/controller/act#{@escaped}ion/var#{@escaped}iable/add#{@escaped}itional-1/add#{@escaped}itional-2&quot;)
  end

  def test_route_generation_allows_passing_non_string_values_to_generated_helper
    assert_equal &quot;/controller/action/variable/1/2&quot;, @set.generate(:controller =&gt; &quot;controller&quot;,
                                                                  :action =&gt; &quot;action&quot;,
                                                                  :variable =&gt; &quot;variable&quot;,
                                                                  :additional =&gt; [1, 2])
  end
end

class SegmentTest &lt; Test::Unit::TestCase
  def test_first_segment_should_interpolate_for_structure
    s = ROUTING::Segment.new
    def s.interpolation_statement(array) 'hello' end
    assert_equal 'hello', s.continue_string_structure([])
  end

  def test_interpolation_statement
    s = ROUTING::StaticSegment.new(&quot;Hello&quot;)
    assert_equal &quot;Hello&quot;, eval(s.interpolation_statement([]))
    assert_equal &quot;HelloHello&quot;, eval(s.interpolation_statement([s]))

    s2 = ROUTING::StaticSegment.new(&quot;-&quot;)
    assert_equal &quot;Hello-Hello&quot;, eval(s.interpolation_statement([s, s2]))

    s3 = ROUTING::StaticSegment.new(&quot;World&quot;)
    assert_equal &quot;Hello-World&quot;, eval(s3.interpolation_statement([s, s2]))
  end
end

class StaticSegmentTest &lt; Test::Unit::TestCase
  def test_interpolation_chunk_should_respect_raw
    s = ROUTING::StaticSegment.new('Hello World')
    assert !s.raw?
    assert_equal 'Hello%20World', s.interpolation_chunk

    s = ROUTING::StaticSegment.new('Hello World', :raw =&gt; true)
    assert s.raw?
    assert_equal 'Hello World', s.interpolation_chunk
  end

  def test_regexp_chunk_should_escape_specials
    s = ROUTING::StaticSegment.new('Hello*World')
    assert_equal 'Hello\*World', s.regexp_chunk

    s = ROUTING::StaticSegment.new('HelloWorld')
    assert_equal 'HelloWorld', s.regexp_chunk
  end

  def test_regexp_chunk_should_add_question_mark_for_optionals
    s = ROUTING::StaticSegment.new(&quot;/&quot;, :optional =&gt; true)
    assert_equal &quot;/?&quot;, s.regexp_chunk

    s = ROUTING::StaticSegment.new(&quot;hello&quot;, :optional =&gt; true)
    assert_equal &quot;(?:hello)?&quot;, s.regexp_chunk
  end
end

class DynamicSegmentTest &lt; ActiveSupport::TestCase
  def setup
    @segment = nil
  end

  def segment(options = {})
    unless @segment
      @segment = ROUTING::DynamicSegment.new(:a, options)
    end
    @segment
  end

  def test_extract_value
    s = ROUTING::DynamicSegment.new(:a)

    hash = {:a =&gt; '10', :b =&gt; '20'}
    assert_equal '10', eval(s.extract_value)

    hash = {:b =&gt; '20'}
    assert_equal nil, eval(s.extract_value)

    s.default = '20'
    assert_equal '20', eval(s.extract_value)
  end

  def test_default_local_name
    assert_equal 'a_value', segment.local_name,
      &quot;Unexpected name -- all value_check tests will fail!&quot;
  end

  def test_presence_value_check
    a_value = 10
    assert eval(segment.value_check)
  end

  def test_regexp_value_check_rejects_nil
    segment = segment(:regexp =&gt; /\d+/)

    a_value = nil
    assert !eval(segment.value_check)
  end

  def test_optional_regexp_value_check_should_accept_nil
    segment = segment(:regexp =&gt; /\d+/, :optional =&gt; true)

    a_value = nil
    assert eval(segment.value_check)
  end

  def test_regexp_value_check_rejects_no_match
    segment = segment(:regexp =&gt; /\d+/)

    a_value = &quot;Hello20World&quot;
    assert !eval(segment.value_check)

    a_value = &quot;20Hi&quot;
    assert !eval(segment.value_check)
  end

  def test_regexp_value_check_accepts_match
    segment = segment(:regexp =&gt; /\d+/)
    a_value = &quot;30&quot;
    assert eval(segment.value_check)
  end

  def test_value_check_fails_on_nil
    a_value = nil
    assert ! eval(segment.value_check)
  end

  def test_optional_value_needs_no_check
    segment = segment(:optional =&gt; true)

    a_value = nil
    assert_equal nil, segment.value_check
  end

  def test_regexp_value_check_should_accept_match_with_default
    segment = segment(:regexp =&gt; /\d+/, :default =&gt; '200')

    a_value = '100'
    assert eval(segment.value_check)
  end

  def test_expiry_should_not_trigger_once_expired
    expired = true
    hash = merged = {:a =&gt; 2, :b =&gt; 3}
    options = {:b =&gt; 3}
    expire_on = Hash.new { raise 'No!!!' }

    eval(segment.expiry_statement)
  rescue RuntimeError
    flunk &quot;Expiry check should not have occurred!&quot;
  end

  def test_expiry_should_occur_according_to_expire_on
    expired = false
    hash = merged = {:a =&gt; 2, :b =&gt; 3}
    options = {:b =&gt; 3}

    expire_on = {:b =&gt; true, :a =&gt; false}
    eval(segment.expiry_statement)
    assert !expired
    assert_equal({:a =&gt; 2, :b =&gt; 3}, hash)

    expire_on = {:b =&gt; true, :a =&gt; true}
    eval(segment.expiry_statement)
    assert expired
    assert_equal({:b =&gt; 3}, hash)
  end

  def test_extraction_code_should_return_on_nil
    hash = merged = {:b =&gt; 3}
    options = {:b =&gt; 3}
    a_value = nil

    # Local jump because of return inside eval.
    assert_raise(LocalJumpError) { eval(segment.extraction_code) }
  end

  def test_extraction_code_should_return_on_mismatch
    segment = segment(:regexp =&gt; /\d+/)
    hash = merged = {:a =&gt; 'Hi', :b =&gt; '3'}
    options = {:b =&gt; '3'}
    a_value = nil

    # Local jump because of return inside eval.
    assert_raise(LocalJumpError) { eval(segment.extraction_code) }
  end

  def test_extraction_code_should_accept_value_and_set_local
    hash = merged = {:a =&gt; 'Hi', :b =&gt; '3'}
    options = {:b =&gt; '3'}
    a_value = nil
    expired = true

    eval(segment.extraction_code)
    assert_equal 'Hi', a_value
  end

  def test_extraction_should_work_without_value_check
    segment.default = 'hi'
    hash = merged = {:b =&gt; '3'}
    options = {:b =&gt; '3'}
    a_value = nil
    expired = true

    eval(segment.extraction_code)
    assert_equal 'hi', a_value
  end

  def test_extraction_code_should_perform_expiry
    expired = false
    hash = merged = {:a =&gt; 'Hi', :b =&gt; '3'}
    options = {:b =&gt; '3'}
    expire_on = {:a =&gt; true}
    a_value = nil

    eval(segment.extraction_code)
    assert_equal 'Hi', a_value
    assert expired
    assert_equal options, hash
  end

  def test_interpolation_chunk_should_replace_value
    a_value = 'Hi'
    assert_equal a_value, eval(%(&quot;#{segment.interpolation_chunk}&quot;))
  end

  def test_interpolation_chunk_should_accept_nil
    a_value = nil
    assert_equal '', eval(%(&quot;#{segment.interpolation_chunk('a_value')}&quot;))
  end

  def test_value_regexp_should_be_nil_without_regexp
    assert_equal nil, segment.value_regexp
  end

  def test_value_regexp_should_match_exacly
    segment = segment(:regexp =&gt; /\d+/)
    assert_no_match segment.value_regexp, &quot;Hello 10 World&quot;
    assert_no_match segment.value_regexp, &quot;Hello 10&quot;
    assert_no_match segment.value_regexp, &quot;10 World&quot;
    assert_match segment.value_regexp, &quot;10&quot;
  end

  def test_regexp_chunk_should_return_string
    segment = segment(:regexp =&gt; /\d+/)
    assert_kind_of String, segment.regexp_chunk
  end

  def test_build_pattern_non_optional_with_no_captures
    # Non optional
    a_segment = ROUTING::DynamicSegment.new(nil, :regexp =&gt; /\d+/)
    assert_equal &quot;(\\d+)stuff&quot;, a_segment.build_pattern('stuff')
  end

  def test_build_pattern_non_optional_with_captures
    # Non optional
    a_segment = ROUTING::DynamicSegment.new(nil, :regexp =&gt; /(\d+)(.*?)/)
    assert_equal &quot;((\\d+)(.*?))stuff&quot;, a_segment.build_pattern('stuff')
  end

  def test_optionality_implied
    a_segment = ROUTING::DynamicSegment.new(:id)
    assert a_segment.optionality_implied?

    a_segment = ROUTING::DynamicSegment.new(:action)
    assert a_segment.optionality_implied?
  end

  def test_modifiers_must_be_handled_sensibly
    a_segment = ROUTING::DynamicSegment.new(nil, :regexp =&gt; /david|jamis/i)
    assert_equal &quot;((?i-mx:david|jamis))stuff&quot;, a_segment.build_pattern('stuff')
    a_segment = ROUTING::DynamicSegment.new(nil, :regexp =&gt;  /david|jamis/x)
    assert_equal &quot;((?x-mi:david|jamis))stuff&quot;, a_segment.build_pattern('stuff')
    a_segment = ROUTING::DynamicSegment.new(nil, :regexp =&gt; /david|jamis/)
    assert_equal &quot;(david|jamis)stuff&quot;, a_segment.build_pattern('stuff')
  end
end

class ControllerSegmentTest &lt; Test::Unit::TestCase
  def test_regexp_should_only_match_possible_controllers
    ActionController::Routing.with_controllers %w(admin/accounts admin/users account pages) do
      cs = ROUTING::ControllerSegment.new :controller
      regexp = %r{\A#{cs.regexp_chunk}\Z}

      ActionController::Routing.possible_controllers.each do |name|
        assert_match regexp, name
        assert_no_match regexp, &quot;#{name}_fake&quot;

        match = regexp.match name
        assert_equal name, match[1]
      end
    end
  end
end

class PathSegmentTest &lt; ActiveSupport::TestCase
  def setup
    @segment = nil
  end

  def segment(options = {})
    unless @segment
      @segment = ROUTING::PathSegment.new(:path, options)
    end
    @segment
  end

  def test_regexp_chunk_should_return_string
    segment = segment(:regexp =&gt; /[a-z]+/)
    assert_kind_of String, segment.regexp_chunk
  end

  def test_regexp_chunk_should_be_wrapped_with_parenthesis
    segment = segment(:regexp =&gt; /[a-z]+/)
    assert_equal &quot;([a-z]+)&quot;, segment.regexp_chunk
  end

  def test_regexp_chunk_should_respect_options
    segment = segment(:regexp =&gt; /[a-z]+/i)
    assert_equal &quot;((?i-mx:[a-z]+))&quot;, segment.regexp_chunk
  end
end

class RouteBuilderTest &lt; Test::Unit::TestCase
  def builder
    @builder ||= ROUTING::RouteBuilder.new
  end

  def build(path, options)
    builder.build(path, options)
  end

  def test_options_should_not_be_modified
    requirements1 = { :id =&gt; /\w+/, :controller =&gt; /(?:[a-z](?:-?[a-z]+)*)/ }
    requirements2 = requirements1.dup

    assert_equal requirements1, requirements2

    with_options(:controller =&gt; 'folder',
                 :requirements =&gt; requirements2) do |m|
      m.build 'folders/new', :action =&gt; 'new'
    end

    assert_equal requirements1, requirements2
  end

  def test_segment_for_static
    segment, rest = builder.segment_for 'ulysses'
    assert_equal '', rest
    assert_kind_of ROUTING::StaticSegment, segment
    assert_equal 'ulysses', segment.value
  end

  def test_segment_for_action
    segment, rest = builder.segment_for ':action'
    assert_equal '', rest
    assert_kind_of ROUTING::DynamicSegment, segment
    assert_equal :action, segment.key
    assert_equal 'index', segment.default
  end

  def test_segment_for_dynamic
    segment, rest = builder.segment_for ':login'
    assert_equal '', rest
    assert_kind_of ROUTING::DynamicSegment, segment
    assert_equal :login, segment.key
    assert_equal nil, segment.default
    assert ! segment.optional?
  end

  def test_segment_for_with_rest
    segment, rest = builder.segment_for ':login/:action'
    assert_equal :login, segment.key
    assert_equal '/:action', rest
    segment, rest = builder.segment_for rest
    assert_equal '/', segment.value
    assert_equal ':action', rest
    segment, rest = builder.segment_for rest
    assert_equal :action, segment.key
    assert_equal '', rest
  end

  def test_segments_for
    segments = builder.segments_for_route_path '/:controller/:action/:id'

    assert_kind_of ROUTING::DividerSegment, segments[0]
    assert_equal '/', segments[2].value

    assert_kind_of ROUTING::DynamicSegment, segments[1]
    assert_equal :controller, segments[1].key

    assert_kind_of ROUTING::DividerSegment, segments[2]
    assert_equal '/', segments[2].value

    assert_kind_of ROUTING::DynamicSegment, segments[3]
    assert_equal :action, segments[3].key

    assert_kind_of ROUTING::DividerSegment, segments[4]
    assert_equal '/', segments[4].value

    assert_kind_of ROUTING::DynamicSegment, segments[5]
    assert_equal :id, segments[5].key
  end

  def test_segment_for_action
    s, r = builder.segment_for(':action/something/else')
    assert_equal '/something/else', r
    assert_equal :action, s.key
  end

  def test_action_default_should_not_trigger_on_prefix
    s, r = builder.segment_for ':action_name/something/else'
    assert_equal '/something/else', r
    assert_equal :action_name, s.key
    assert_equal nil, s.default
  end

  def test_divide_route_options
    segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
    defaults, requirements = builder.divide_route_options(segments,
      :action =&gt; 'buy', :person =&gt; /\w+/, :car =&gt; /\w+/,
      :defaults =&gt; {:person =&gt; nil, :car =&gt; nil}
    )

    assert_equal({:action =&gt; 'buy', :person =&gt; nil, :car =&gt; nil}, defaults)
    assert_equal({:person =&gt; /\w+/, :car =&gt; /\w+/}, requirements)
  end

  def test_assign_route_options
    segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
    defaults = {:action =&gt; 'buy', :person =&gt; nil, :car =&gt; nil}
    requirements = {:person =&gt; /\w+/, :car =&gt; /\w+/}

    route_requirements = builder.assign_route_options(segments, defaults, requirements)
    assert_equal({}, route_requirements)

    assert_equal :action, segments[3].key
    assert_equal 'buy', segments[3].default

    assert_equal :person, segments[5].key
    assert_equal %r/\w+/, segments[5].regexp
    assert segments[5].optional?

    assert_equal :car, segments[7].key
    assert_equal %r/\w+/, segments[7].regexp
    assert segments[7].optional?
  end

  def test_assign_route_options_with_anchor_chars
    segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
    defaults = {:action =&gt; 'buy', :person =&gt; nil, :car =&gt; nil}
    requirements = {:person =&gt; /\w+/, :car =&gt; /^\w+$/}

    assert_raise ArgumentError do
      route_requirements = builder.assign_route_options(segments, defaults, requirements)
    end

    requirements[:car] = /[^\/]+/
    route_requirements = builder.assign_route_options(segments, defaults, requirements)
  end

  def test_optional_segments_preceding_required_segments
    segments = builder.segments_for_route_path '/cars/:action/:person/:car/'
    defaults = {:action =&gt; 'buy', :person =&gt; nil, :car =&gt; &quot;model-t&quot;}
    assert builder.assign_route_options(segments, defaults, {}).empty?

    0.upto(1) { |i| assert !segments[i].optional?, &quot;segment #{i} is optional and it shouldn't be&quot; }
    assert segments[2].optional?

    assert_equal nil, builder.warn_output # should only warn on the :person segment
  end

  def test_segmentation_of_dot_path
    segments = builder.segments_for_route_path '/books/:action.rss'
    assert builder.assign_route_options(segments, {}, {}).empty?
    assert_equal 6, segments.length # &quot;/&quot;, &quot;books&quot;, &quot;/&quot;, &quot;:action&quot;, &quot;.&quot;, &quot;rss&quot;
    assert !segments.any? { |seg| seg.optional? }
  end

  def test_segmentation_of_dynamic_dot_path
    segments = builder.segments_for_route_path '/books/:action.:format'
    assert builder.assign_route_options(segments, {}, {}).empty?
    assert_equal 6, segments.length # &quot;/&quot;, &quot;books&quot;, &quot;/&quot;, &quot;:action&quot;, &quot;.&quot;, &quot;:format&quot;
    assert !segments.any? { |seg| seg.optional? }
    assert_kind_of ROUTING::DynamicSegment, segments.last
  end

  def test_assignment_of_default_options
    segments = builder.segments_for_route_path '/:controller/:action/:id/'
    action, id = segments[-4], segments[-2]

    assert_equal :action, action.key
    assert_equal :id, id.key
    assert ! action.optional?
    assert ! id.optional?

    builder.assign_default_route_options(segments)

    assert_equal 'index', action.default
    assert action.optional?
    assert id.optional?
  end

  def test_assignment_of_default_options_respects_existing_defaults
    segments = builder.segments_for_route_path '/:controller/:action/:id/'
    action, id = segments[-4], segments[-2]

    assert_equal :action, action.key
    assert_equal :id, id.key
    action.default = 'show'
    action.is_optional = true

    id.default = 'Welcome'
    id.is_optional = true

    builder.assign_default_route_options(segments)

    assert_equal 'show', action.default
    assert action.optional?
    assert_equal 'Welcome', id.default
    assert id.optional?
  end

  def test_assignment_of_default_options_respects_regexps
    segments = builder.segments_for_route_path '/:controller/:action/:id/'
    action = segments[-4]

    assert_equal :action, action.key
    segments[-4] = ROUTING::DynamicSegment.new(:action, :regexp =&gt; /show|in/)

    builder.assign_default_route_options(segments)

    assert_equal nil, action.default
    assert ! action.optional?
  end

  def test_assignment_of_is_optional_when_default
    segments = builder.segments_for_route_path '/books/:action.rss'
    assert_equal segments[3].key, :action
    segments[3].default = 'changes'
    builder.ensure_required_segments(segments)
    assert ! segments[3].optional?
  end

  def test_is_optional_is_assigned_to_default_segments
    segments = builder.segments_for_route_path '/books/:action'
    builder.assign_route_options(segments, {:action =&gt; 'index'}, {})

    assert_equal segments[3].key, :action
    assert segments[3].optional?
    assert_kind_of ROUTING::DividerSegment, segments[2]
    assert segments[2].optional?
  end

  # XXX is optional not being set right?
  # /blah/:defaulted_segment &lt;-- is the second slash optional? it should be.

  def test_route_build
    ActionController::Routing.with_controllers %w(users pages) do
      r = builder.build '/:controller/:action/:id/', :action =&gt; nil

      [0, 2, 4].each do |i|
        assert_kind_of ROUTING::DividerSegment, r.segments[i]
        assert_equal '/', r.segments[i].value
        assert r.segments[i].optional? if i &gt; 1
      end

      assert_kind_of ROUTING::DynamicSegment, r.segments[1]
      assert_equal :controller, r.segments[1].key
      assert_equal nil, r.segments[1].default

      assert_kind_of ROUTING::DynamicSegment, r.segments[3]
      assert_equal :action, r.segments[3].key
      assert_equal 'index', r.segments[3].default

      assert_kind_of ROUTING::DynamicSegment, r.segments[5]
      assert_equal :id, r.segments[5].key
      assert r.segments[5].optional?
    end
  end

  def test_slashes_are_implied
    routes = [
      builder.build('/:controller/:action/:id/', :action =&gt; nil),
      builder.build('/:controller/:action/:id', :action =&gt; nil),
      builder.build(':controller/:action/:id', :action =&gt; nil),
      builder.build('/:controller/:action/:id/', :action =&gt; nil)
    ]
    expected = routes.first.segments.length
    routes.each_with_index do |route, i|
      found = route.segments.length
      assert_equal expected, found, &quot;Route #{i + 1} has #{found} segments, expected #{expected}&quot;
    end
  end
end

class RoutingTest &lt; Test::Unit::TestCase
  def test_possible_controllers
    true_controller_paths = ActionController::Routing.controller_paths

    ActionController::Routing.use_controllers! nil

    silence_warnings do
      Object.send(:const_set, :RAILS_ROOT, File.dirname(__FILE__) + '/controller_fixtures')
    end

    ActionController::Routing.controller_paths = [
      RAILS_ROOT, RAILS_ROOT + '/app/controllers', RAILS_ROOT + '/vendor/plugins/bad_plugin/lib'
    ]

    assert_equal [&quot;admin/user&quot;, &quot;plugin&quot;, &quot;user&quot;], ActionController::Routing.possible_controllers.sort
  ensure
    if true_controller_paths
      ActionController::Routing.controller_paths = true_controller_paths
    end
    ActionController::Routing.use_controllers! nil
    Object.send(:remove_const, :RAILS_ROOT) rescue nil
  end

  def test_possible_controllers_are_reset_on_each_load
    true_possible_controllers = ActionController::Routing.possible_controllers
    true_controller_paths = ActionController::Routing.controller_paths

    ActionController::Routing.use_controllers! nil
    root = File.dirname(__FILE__) + '/controller_fixtures'

    ActionController::Routing.controller_paths = []
    assert_equal [], ActionController::Routing.possible_controllers

    ActionController::Routing.controller_paths = [
      root, root + '/app/controllers', root + '/vendor/plugins/bad_plugin/lib'
    ]
    ActionController::Routing::Routes.load!

    assert_equal [&quot;admin/user&quot;, &quot;plugin&quot;, &quot;user&quot;], ActionController::Routing.possible_controllers.sort
  ensure
    ActionController::Routing.controller_paths = true_controller_paths
    ActionController::Routing.use_controllers! true_possible_controllers
    Object.send(:remove_const, :RAILS_ROOT) rescue nil

    ActionController::Routing::Routes.clear!
    ActionController::Routing::Routes.load_routes!
  end

  def test_with_controllers
    c = %w(admin/accounts admin/users account pages)
    ActionController::Routing.with_controllers c do
      assert_equal c, ActionController::Routing.possible_controllers
    end
  end

  def test_normalize_unix_paths
    load_paths = %w(. config/../app/controllers config/../app//helpers script/../config/../vendor/rails/actionpack/lib vendor/rails/railties/builtin/rails_info app/models lib script/../config/../foo/bar/../../app/models .foo/../.bar foo.bar/../config)
    paths = ActionController::Routing.normalize_paths(load_paths)
    assert_equal %w(vendor/rails/railties/builtin/rails_info vendor/rails/actionpack/lib app/controllers app/helpers app/models config .bar lib .), paths
  end

  def test_normalize_windows_paths
    load_paths = %w(. config\\..\\app\\controllers config\\..\\app\\\\helpers script\\..\\config\\..\\vendor\\rails\\actionpack\\lib vendor\\rails\\railties\\builtin\\rails_info app\\models lib script\\..\\config\\..\\foo\\bar\\..\\..\\app\\models .foo\\..\\.bar foo.bar\\..\\config)
    paths = ActionController::Routing.normalize_paths(load_paths)
    assert_equal %w(vendor\\rails\\railties\\builtin\\rails_info vendor\\rails\\actionpack\\lib app\\controllers app\\helpers app\\models config .bar lib .), paths
  end

  def test_routing_helper_module
    assert_kind_of Module, ActionController::Routing::Helpers

    h = ActionController::Routing::Helpers
    c = Class.new
    assert ! c.ancestors.include?(h)
    ActionController::Routing::Routes.install_helpers c
    assert c.ancestors.include?(h)
  end
end

class MockController
  attr_accessor :routes

  def initialize(routes)
    self.routes = routes
  end

  def url_for(options)
    only_path = options.delete(:only_path)

    port        = options.delete(:port) || 80
    port_string = port == 80 ? '' : &quot;:#{port}&quot;

    protocol = options.delete(:protocol) || &quot;http&quot;
    host     = options.delete(:host) || &quot;test.host&quot;
    anchor   = &quot;##{options.delete(:anchor)}&quot; if options.key?(:anchor)

    path = routes.generate(options)

    only_path ? &quot;#{path}#{anchor}&quot; : &quot;#{protocol}://#{host}#{port_string}#{path}#{anchor}&quot;
  end

  def request
    @request ||= ActionController::TestRequest.new
  end
end

class LegacyRouteSetTests &lt; ActiveSupport::TestCase
  attr_reader :rs

  def setup
    # These tests assume optimisation is on, so re-enable it.
    ActionController::Base.optimise_named_routes = true

    @rs = ::ActionController::Routing::RouteSet.new

    ActionController::Routing.use_controllers! %w(content admin/user admin/news_feed)
  end

  def teardown
    @rs.clear!
  end

  def test_routes_for_controller_and_action_deprecated
    assert_deprecated { @rs.routes_for_controller_and_action(&quot;controller&quot;, &quot;action&quot;) }
  end

  def test_default_setup
    @rs.draw {|m| m.connect ':controller/:action/:id' }
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'index'}, rs.recognize_path(&quot;/content&quot;))
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'list'}, rs.recognize_path(&quot;/content/list&quot;))
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'show', :id =&gt; '10'}, rs.recognize_path(&quot;/content/show/10&quot;))

    assert_equal({:controller =&gt; &quot;admin/user&quot;, :action =&gt; 'show', :id =&gt; '10'}, rs.recognize_path(&quot;/admin/user/show/10&quot;))

    assert_equal '/admin/user/show/10', rs.generate(:controller =&gt; 'admin/user', :action =&gt; 'show', :id =&gt; 10)

    assert_equal '/admin/user/show', rs.generate({:action =&gt; 'show'}, {:controller =&gt; 'admin/user', :action =&gt; 'list', :id =&gt; '10'})
    assert_equal '/admin/user/list/10', rs.generate({}, {:controller =&gt; 'admin/user', :action =&gt; 'list', :id =&gt; '10'})

    assert_equal '/admin/stuff', rs.generate({:controller =&gt; 'stuff'}, {:controller =&gt; 'admin/user', :action =&gt; 'list', :id =&gt; '10'})
    assert_equal '/stuff', rs.generate({:controller =&gt; '/stuff'}, {:controller =&gt; 'admin/user', :action =&gt; 'list', :id =&gt; '10'})
  end

  def test_ignores_leading_slash
    @rs.clear!
    @rs.draw {|m| m.connect '/:controller/:action/:id'}
    test_default_setup
  end

  def test_time_recognition
    # We create many routes to make situation more realistic
    @rs = ::ActionController::Routing::RouteSet.new
    @rs.draw { |map|
      map.frontpage '', :controller =&gt; 'search', :action =&gt; 'new'
      map.resources :videos do |video|
        video.resources :comments
        video.resource  :file,      :controller =&gt; 'video_file'
        video.resource  :share,     :controller =&gt; 'video_shares'
        video.resource  :abuse,     :controller =&gt; 'video_abuses'
      end
      map.resources :abuses, :controller =&gt; 'video_abuses'
      map.resources :video_uploads
      map.resources :video_visits

      map.resources :users do |user|
        user.resource  :settings
        user.resources :videos
      end
      map.resources :channels do |channel|
        channel.resources :videos, :controller =&gt; 'channel_videos'
      end
      map.resource  :session
      map.resource  :lost_password
      map.search    'search', :controller =&gt; 'search'
      map.resources :pages
      map.connect ':controller/:action/:id'
    }
    n = 1000
    if RunTimeTests
      GC.start
      rectime = Benchmark.realtime do
        n.times do
          rs.recognize_path(&quot;/videos/1234567&quot;, {:method =&gt; :get})
          rs.recognize_path(&quot;/videos/1234567/abuse&quot;, {:method =&gt; :get})
          rs.recognize_path(&quot;/users/1234567/settings&quot;, {:method =&gt; :get})
          rs.recognize_path(&quot;/channels/1234567&quot;, {:method =&gt; :get})
          rs.recognize_path(&quot;/session/new&quot;, {:method =&gt; :get})
          rs.recognize_path(&quot;/admin/user/show/10&quot;, {:method =&gt; :get})
        end
      end
      puts &quot;\n\nRecognition (#{rs.routes.size} routes):&quot;
      per_url = rectime / (n * 6)
      puts &quot;#{per_url * 1000} ms/url&quot;
      puts &quot;#{1 / per_url} url/s\n\n&quot;
    end
  end

  def test_time_generation
    n = 5000
    if RunTimeTests
      GC.start
      pairs = [
        [{:controller =&gt; 'content', :action =&gt; 'index'}, {:controller =&gt; 'content', :action =&gt; 'show'}],
        [{:controller =&gt; 'content'}, {:controller =&gt; 'content', :action =&gt; 'index'}],
        [{:controller =&gt; 'content', :action =&gt; 'list'}, {:controller =&gt; 'content', :action =&gt; 'index'}],
        [{:controller =&gt; 'content', :action =&gt; 'show', :id =&gt; '10'}, {:controller =&gt; 'content', :action =&gt; 'list'}],
        [{:controller =&gt; 'admin/user', :action =&gt; 'index'}, {:controller =&gt; 'admin/user', :action =&gt; 'show'}],
        [{:controller =&gt; 'admin/user'}, {:controller =&gt; 'admin/user', :action =&gt; 'index'}],
        [{:controller =&gt; 'admin/user', :action =&gt; 'list'}, {:controller =&gt; 'admin/user', :action =&gt; 'index'}],
        [{:controller =&gt; 'admin/user', :action =&gt; 'show', :id =&gt; '10'}, {:controller =&gt; 'admin/user', :action =&gt; 'list'}],
      ]
      p = nil
      gentime = Benchmark.realtime do
        n.times do
        pairs.each {|(a, b)| rs.generate(a, b)}
        end
      end

      puts &quot;\n\nGeneration (RouteSet): (#{(n * 8)} urls)&quot;
      per_url = gentime / (n * 8)
      puts &quot;#{per_url * 1000} ms/url&quot;
      puts &quot;#{1 / per_url} url/s\n\n&quot;
    end
  end

  def test_route_with_colon_first
    rs.draw do |map|
      map.connect '/:controller/:action/:id', :action =&gt; 'index', :id =&gt; nil
      map.connect ':url', :controller =&gt; 'tiny_url', :action =&gt; 'translate'
    end
  end

  def test_route_with_regexp_for_controller
    rs.draw do |map|
      map.connect ':controller/:admintoken/:action/:id', :controller =&gt; /admin\/.+/
      map.connect ':controller/:action/:id'
    end
    assert_equal({:controller =&gt; &quot;admin/user&quot;, :admintoken =&gt; &quot;foo&quot;, :action =&gt; &quot;index&quot;},
        rs.recognize_path(&quot;/admin/user/foo&quot;))
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; &quot;foo&quot;}, rs.recognize_path(&quot;/content/foo&quot;))
    assert_equal '/admin/user/foo', rs.generate(:controller =&gt; &quot;admin/user&quot;, :admintoken =&gt; &quot;foo&quot;, :action =&gt; &quot;index&quot;)
    assert_equal '/content/foo', rs.generate(:controller =&gt; &quot;content&quot;, :action =&gt; &quot;foo&quot;)
  end

  def test_route_with_regexp_and_captures_for_controller
    rs.draw do |map|
      map.connect ':controller/:action/:id', :controller =&gt; /admin\/(accounts|users)/
    end
    assert_equal({:controller =&gt; &quot;admin/accounts&quot;, :action =&gt; &quot;index&quot;}, rs.recognize_path(&quot;/admin/accounts&quot;))
    assert_equal({:controller =&gt; &quot;admin/users&quot;, :action =&gt; &quot;index&quot;}, rs.recognize_path(&quot;/admin/users&quot;))
    assert_raise(ActionController::RoutingError) { rs.recognize_path(&quot;/admin/products&quot;) }
  end

  def test_route_with_regexp_and_dot
    rs.draw do |map|
      map.connect ':controller/:action/:file',
                        :controller =&gt; /admin|user/,
                        :action =&gt; /upload|download/,
                        :defaults =&gt; {:file =&gt; nil},
                        :requirements =&gt; {:file =&gt; %r{[^/]+(\.[^/]+)?}}
    end
    # Without a file extension
    assert_equal '/user/download/file',
      rs.generate(:controller =&gt; &quot;user&quot;, :action =&gt; &quot;download&quot;, :file =&gt; &quot;file&quot;)
    assert_equal(
      {:controller =&gt; &quot;user&quot;, :action =&gt; &quot;download&quot;, :file =&gt; &quot;file&quot;},
      rs.recognize_path(&quot;/user/download/file&quot;))

    # Now, let's try a file with an extension, really a dot (.)
    assert_equal '/user/download/file.jpg',
      rs.generate(
        :controller =&gt; &quot;user&quot;, :action =&gt; &quot;download&quot;, :file =&gt; &quot;file.jpg&quot;)
    assert_equal(
      {:controller =&gt; &quot;user&quot;, :action =&gt; &quot;download&quot;, :file =&gt; &quot;file.jpg&quot;},
      rs.recognize_path(&quot;/user/download/file.jpg&quot;))
  end

  def test_basic_named_route
    rs.add_named_route :home, '', :controller =&gt; 'content', :action =&gt; 'list'
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/&quot;,
                 x.send(:home_url))
  end

  def test_basic_named_route_with_relative_url_root
    rs.add_named_route :home, '', :controller =&gt; 'content', :action =&gt; 'list'
    x = setup_for_named_route
    ActionController::Base.relative_url_root = &quot;/foo&quot;
    assert_equal(&quot;http://test.host/foo/&quot;,
                 x.send(:home_url))
    assert_equal &quot;/foo/&quot;, x.send(:home_path)
    ActionController::Base.relative_url_root = nil
  end

  def test_named_route_with_option
    rs.add_named_route :page, 'page/:title', :controller =&gt; 'content', :action =&gt; 'show_page'
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/page/new%20stuff&quot;,
                 x.send(:page_url, :title =&gt; 'new stuff'))
  end

  def test_named_route_with_default
    rs.add_named_route :page, 'page/:title', :controller =&gt; 'content', :action =&gt; 'show_page', :title =&gt; 'AboutPage'
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/page/AboutRails&quot;,
                 x.send(:page_url, :title =&gt; &quot;AboutRails&quot;))

  end

  def test_named_route_with_name_prefix
    rs.add_named_route :page, 'page', :controller =&gt; 'content', :action =&gt; 'show_page', :name_prefix =&gt; 'my_'
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/page&quot;,
                 x.send(:my_page_url))
  end

  def test_named_route_with_path_prefix
    rs.add_named_route :page, 'page', :controller =&gt; 'content', :action =&gt; 'show_page', :path_prefix =&gt; 'my'
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/my/page&quot;,
                 x.send(:page_url))
  end

  def test_named_route_with_blank_path_prefix
    rs.add_named_route :page, 'page', :controller =&gt; 'content', :action =&gt; 'show_page', :path_prefix =&gt; ''
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/page&quot;,
                 x.send(:page_url))
  end

  def test_named_route_with_nested_controller
    rs.add_named_route :users, 'admin/user', :controller =&gt; 'admin/user', :action =&gt; 'index'
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/admin/user&quot;,
                 x.send(:users_url))
  end

  def test_optimised_named_route_call_never_uses_url_for
    rs.add_named_route :users, 'admin/user', :controller =&gt; '/admin/user', :action =&gt; 'index'
    rs.add_named_route :user, 'admin/user/:id', :controller=&gt;'/admin/user', :action=&gt;'show'
    x = setup_for_named_route
    x.expects(:url_for).never
    x.send(:users_url)
    x.send(:users_path)
    x.send(:user_url, 2, :foo=&gt;&quot;bar&quot;)
    x.send(:user_path, 3, :bar=&gt;&quot;foo&quot;)
  end

  def test_optimised_named_route_with_host
    rs.add_named_route :pages, 'pages', :controller =&gt; 'content', :action =&gt; 'show_page', :host =&gt; 'foo.com'
    x = setup_for_named_route
    x.expects(:url_for).with(:host =&gt; 'foo.com', :only_path =&gt; false, :controller =&gt; 'content', :action =&gt; 'show_page', :use_route =&gt; :pages).once
    x.send(:pages_url)
  end

  def setup_for_named_route
    klass = Class.new(MockController)
    rs.install_helpers(klass)
    klass.new(rs)
  end

  def test_named_route_without_hash
    rs.draw do |map|
      map.normal ':controller/:action/:id'
    end
  end

  def test_named_route_root
    rs.draw do |map|
      map.root :controller =&gt; &quot;hello&quot;
    end
    x = setup_for_named_route
    assert_equal(&quot;http://test.host/&quot;, x.send(:root_url))
    assert_equal(&quot;/&quot;, x.send(:root_path))
  end

  def test_named_route_with_regexps
    rs.draw do |map|
      map.article 'page/:year/:month/:day/:title', :controller =&gt; 'page', :action =&gt; 'show',
        :year =&gt; /\d+/, :month =&gt; /\d+/, :day =&gt; /\d+/
      map.connect ':controller/:action/:id'
    end
    x = setup_for_named_route
    # assert_equal(
    #   {:controller =&gt; 'page', :action =&gt; 'show', :title =&gt; 'hi', :use_route =&gt; :article, :only_path =&gt; false},
    #   x.send(:article_url, :title =&gt; 'hi')
    # )
    assert_equal(
      &quot;http://test.host/page/2005/6/10/hi&quot;,
      x.send(:article_url, :title =&gt; 'hi', :day =&gt; 10, :year =&gt; 2005, :month =&gt; 6)
    )
  end

  def test_changing_controller
    @rs.draw {|m| m.connect ':controller/:action/:id' }

    assert_equal '/admin/stuff/show/10', rs.generate(
      {:controller =&gt; 'stuff', :action =&gt; 'show', :id =&gt; 10},
      {:controller =&gt; 'admin/user', :action =&gt; 'index'}
    )
  end

  def test_paths_escaped
    rs.draw do |map|
      map.path 'file/*path', :controller =&gt; 'content', :action =&gt; 'show_file'
      map.connect ':controller/:action/:id'
    end

    # No + to space in URI escaping, only for query params.
    results = rs.recognize_path &quot;/file/hello+world/how+are+you%3F&quot;
    assert results, &quot;Recognition should have succeeded&quot;
    assert_equal ['hello+world', 'how+are+you?'], results[:path]

    # Use %20 for space instead.
    results = rs.recognize_path &quot;/file/hello%20world/how%20are%20you%3F&quot;
    assert results, &quot;Recognition should have succeeded&quot;
    assert_equal ['hello world', 'how are you?'], results[:path]

    results = rs.recognize_path &quot;/file&quot;
    assert results, &quot;Recognition should have succeeded&quot;
    assert_equal [], results[:path]
  end

  def test_paths_slashes_unescaped_with_ordered_parameters
    rs.add_named_route :path, '/file/*path', :controller =&gt; 'content'

    # No / to %2F in URI, only for query params.
    x = setup_for_named_route
    assert_equal(&quot;/file/hello/world&quot;, x.send(:path_path, 'hello/world'))
  end

  def test_non_controllers_cannot_be_matched
    rs.draw do |map|
      map.connect ':controller/:action/:id'
    end
    assert_raise(ActionController::RoutingError) { rs.recognize_path(&quot;/not_a/show/10&quot;) }
  end

  def test_paths_do_not_accept_defaults
    assert_raise(ActionController::RoutingError) do
      rs.draw do |map|
        map.path 'file/*path', :controller =&gt; 'content', :action =&gt; 'show_file', :path =&gt; %w(fake default)
        map.connect ':controller/:action/:id'
      end
    end

    rs.draw do |map|
      map.path 'file/*path', :controller =&gt; 'content', :action =&gt; 'show_file', :path =&gt; []
      map.connect ':controller/:action/:id'
    end
  end

  def test_should_list_options_diff_when_routing_requirements_dont_match
    rs.draw do |map|
      map.post 'post/:id', :controller=&gt; 'post', :action=&gt; 'show', :requirements =&gt; {:id =&gt; /\d+/}
    end
    exception = assert_raise(ActionController::RoutingError) { rs.generate(:controller =&gt; 'post', :action =&gt; 'show', :bad_param =&gt; &quot;foo&quot;, :use_route =&gt; &quot;post&quot;) }
    assert_match(/^post_url failed to generate/, exception.message)
    from_match = exception.message.match(/from \{[^\}]+\}/).to_s
    assert_match(/:bad_param=&gt;&quot;foo&quot;/,   from_match)
    assert_match(/:action=&gt;&quot;show&quot;/,     from_match)
    assert_match(/:controller=&gt;&quot;post&quot;/, from_match)

    expected_match = exception.message.match(/expected: \{[^\}]+\}/).to_s
    assert_no_match(/:bad_param=&gt;&quot;foo&quot;/,   expected_match)
    assert_match(   /:action=&gt;&quot;show&quot;/,     expected_match)
    assert_match(   /:controller=&gt;&quot;post&quot;/, expected_match)

    diff_match = exception.message.match(/diff: \{[^\}]+\}/).to_s
    assert_match(   /:bad_param=&gt;&quot;foo&quot;/,   diff_match)
    assert_no_match(/:action=&gt;&quot;show&quot;/,     diff_match)
    assert_no_match(/:controller=&gt;&quot;post&quot;/, diff_match)
  end

  # this specifies the case where your formerly would get a very confusing error message with an empty diff
  def test_should_have_better_error_message_when_options_diff_is_empty
    rs.draw do |map|
      map.content '/content/:query', :controller =&gt; 'content', :action =&gt; 'show'
    end

    exception = assert_raise(ActionController::RoutingError) { rs.generate(:controller =&gt; 'content', :action =&gt; 'show', :use_route =&gt; &quot;content&quot;) }
    assert_match %r[:action=&gt;&quot;show&quot;], exception.message
    assert_match %r[:controller=&gt;&quot;content&quot;], exception.message
    assert_match %r[you may have ambiguous routes, or you may need to supply additional parameters for this route], exception.message
    assert_match %r[content_url has the following required parameters: \[&quot;content&quot;, :query\] - are they all satisfied?], exception.message
  end

  def test_dynamic_path_allowed
    rs.draw do |map|
      map.connect '*path', :controller =&gt; 'content', :action =&gt; 'show_file'
    end

    assert_equal '/pages/boo', rs.generate(:controller =&gt; 'content', :action =&gt; 'show_file', :path =&gt; %w(pages boo))
  end

  def test_dynamic_recall_paths_allowed
    rs.draw do |map|
      map.connect '*path', :controller =&gt; 'content', :action =&gt; 'show_file'
    end

    recall_path = ActionController::Routing::PathSegment::Result.new(%w(pages boo))
    assert_equal '/pages/boo', rs.generate({}, :controller =&gt; 'content', :action =&gt; 'show_file', :path =&gt; recall_path)
  end

  def test_backwards
    rs.draw do |map|
      map.connect 'page/:id/:action', :controller =&gt; 'pages', :action =&gt; 'show'
      map.connect ':controller/:action/:id'
    end

    assert_equal '/page/20', rs.generate({:id =&gt; 20}, {:controller =&gt; 'pages', :action =&gt; 'show'})
    assert_equal '/page/20', rs.generate(:controller =&gt; 'pages', :id =&gt; 20, :action =&gt; 'show')
    assert_equal '/pages/boo', rs.generate(:controller =&gt; 'pages', :action =&gt; 'boo')
  end

  def test_route_with_fixnum_default
    rs.draw do |map|
      map.connect 'page/:id', :controller =&gt; 'content', :action =&gt; 'show_page', :id =&gt; 1
      map.connect ':controller/:action/:id'
    end

    assert_equal '/page', rs.generate(:controller =&gt; 'content', :action =&gt; 'show_page')
    assert_equal '/page', rs.generate(:controller =&gt; 'content', :action =&gt; 'show_page', :id =&gt; 1)
    assert_equal '/page', rs.generate(:controller =&gt; 'content', :action =&gt; 'show_page', :id =&gt; '1')
    assert_equal '/page/10', rs.generate(:controller =&gt; 'content', :action =&gt; 'show_page', :id =&gt; 10)

    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'show_page', :id =&gt; '1'}, rs.recognize_path(&quot;/page&quot;))
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'show_page', :id =&gt; '1'}, rs.recognize_path(&quot;/page/1&quot;))
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'show_page', :id =&gt; '10'}, rs.recognize_path(&quot;/page/10&quot;))
  end

  # For newer revision
  def test_route_with_text_default
    rs.draw do |map|
      map.connect 'page/:id', :controller =&gt; 'content', :action =&gt; 'show_page', :id =&gt; 1
      map.connect ':controller/:action/:id'
    end

    assert_equal '/page/foo', rs.generate(:controller =&gt; 'content', :action =&gt; 'show_page', :id =&gt; 'foo')
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'show_page', :id =&gt; 'foo'}, rs.recognize_path(&quot;/page/foo&quot;))

    token = &quot;\321\202\320\265\320\272\321\201\321\202&quot; # 'text' in russian
    token.force_encoding(&quot;UTF-8&quot;) if token.respond_to?(:force_encoding)
    escaped_token = CGI::escape(token)

    assert_equal '/page/' + escaped_token, rs.generate(:controller =&gt; 'content', :action =&gt; 'show_page', :id =&gt; token)
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'show_page', :id =&gt; token}, rs.recognize_path(&quot;/page/#{escaped_token}&quot;))
  end

  def test_action_expiry
    @rs.draw {|m| m.connect ':controller/:action/:id' }
    assert_equal '/content', rs.generate({:controller =&gt; 'content'}, {:controller =&gt; 'content', :action =&gt; 'show'})
  end

  def test_recognition_with_uppercase_controller_name
    @rs.draw {|m| m.connect ':controller/:action/:id' }
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'index'}, rs.recognize_path(&quot;/Content&quot;))
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'list'}, rs.recognize_path(&quot;/ConTent/list&quot;))
    assert_equal({:controller =&gt; &quot;content&quot;, :action =&gt; 'show', :id =&gt; '10'}, rs.recognize_path(&quot;/CONTENT/show/10&quot;))

    # these used to work, before the routes rewrite, but support for this was pulled in the new version...
    #assert_equal({'controller' =&gt; &quot;admin/news_feed&quot;, 'action' =&gt; 'index'}, rs.recognize_path(&quot;Admin/NewsFeed&quot;))
    #assert_equal({'controller' =&gt; &quot;admin/news_feed&quot;, 'action' =&gt; 'index'}, rs.recognize_path(&quot;Admin/News_Feed&quot;))
  end

  def test_requirement_should_prevent_optional_id
    rs.draw do |map|
      map.post 'post/:id', :controller=&gt; 'post', :action=&gt; 'show', :requirements =&gt; {:id =&gt; /\d+/}
    end

    assert_equal '/post/10', rs.generate(:controller =&gt; 'post', :action =&gt; 'show', :id =&gt; 10)

    assert_raise ActionController::RoutingError do
      rs.generate(:controller =&gt; 'post', :action =&gt; 'show')
    end
  end

  def test_both_requirement_and_optional
    rs.draw do |map|
      map.blog('test/:year', :controller =&gt; 'post', :action =&gt; 'show',
        :defaults =&gt; { :year =&gt; nil },
        :requirements =&gt; { :year =&gt; /\d{4}/ }
      )
      map.connect ':controller/:action/:id'
    end

    assert_equal '/test', rs.generate(:controller =&gt; 'post', :action =&gt; 'show')
    assert_equal '/test', rs.generate(:controller =&gt; 'post', :action =&gt; 'show', :year =&gt; nil)

    x = setup_for_named_route
    assert_equal(&quot;http://test.host/test&quot;,
                 x.send(:blog_url))
  end

  def test_set_to_nil_forgets
    rs.draw do |map|
      map.connect 'pages/:year/:month/:day', :controller =&gt; 'content', :action =&gt; 'list_pages', :month =&gt; nil, :day =&gt; nil
      map.connect ':controller/:action/:id'
    end

    assert_equal '/pages/2005',
      rs.generate(:controller =&gt; 'content', :action =&gt; 'list_pages', :year =&gt; 2005)
    assert_equal '/pages/2005/6',
      rs.generate(:controller =&gt; 'content', :action =&gt; 'list_pages', :year =&gt; 2005, :month =&gt; 6)
    assert_equal '/pages/2005/6/12',
      rs.generate(:controller =&gt; 'content', :action =&gt; 'list_pages', :year =&gt; 2005, :month =&gt; 6, :day =&gt; 12)

    assert_equal '/pages/2005/6/4',
      rs.generate({:day =&gt; 4}, {:controller =&gt; 'content', :action =&gt; 'list_pages', :year =&gt; '2005', :month =&gt; '6', :day =&gt; '12'})

    assert_equal '/pages/2005/6',
      rs.generate({:day =&gt; nil}, {:controller =&gt; 'content', :action =&gt; 'list_pages', :year =&gt; '2005', :month =&gt; '6', :day =&gt; '12'})

    assert_equal '/pages/2005',
      rs.generate({:day =&gt; nil, :month =&gt; nil}, {:controller =&gt; 'content', :action =&gt; 'list_pages', :year =&gt; '2005', :month =&gt; '6', :day =&gt; '12'})
  end

  def test_url_with_no_action_specified
    rs.draw do |map|
      map.connect '', :controller =&gt; 'content'
      map.connect ':controller/:action/:id'
    end

    assert_equal '/', rs.generate(:controller =&gt; 'content', :action =&gt; 'index')
    assert_equal '/', rs.generate(:controller =&gt; 'content')
  end

  def test_named_url_with_no_action_specified
    rs.draw do |map|
      map.home '', :controller =&gt; 'content'
      map.connect ':controller/:action/:id'
    end

    assert_equal '/', rs.generate(:controller =&gt; 'content', :action =&gt; 'index')
    assert_equal '/', rs.generate(:controller =&gt; 'content')

    x = setup_for_named_route
    assert_equal(&quot;http://test.host/&quot;,
                 x.send(:home_url))
  end

  def test_url_generated_when_forgetting_action
    [{:controller =&gt; 'content', :action =&gt; 'index'}, {:controller =&gt; 'content'}].each do |hash|
      rs.draw do |map|
        map.home '', hash
        map.connect ':controller/:action/:id'
      end
      assert_equal '/', rs.generate({:action =&gt; nil}, {:controller =&gt; 'content', :action =&gt; 'hello'})
      assert_equal '/', rs.generate({:controller =&gt; 'content'})
      assert_equal '/content/hi', rs.generate({:controller =&gt; 'content', :action =&gt; 'hi'})
    end
  end

  def test_named_route_method
    rs.draw do |map|
      map.categories 'categories', :controller =&gt; 'content', :action =&gt; 'categories'
      map.connect ':controller/:action/:id'
    end

    assert_equal '/categories', rs.generate(:controller =&gt; 'content', :action =&gt; 'categories')
    assert_equal '/content/hi', rs.generate({:controller =&gt; 'content', :action =&gt; 'hi'})
  end

  def test_named_routes_array
    test_named_route_method
    assert_equal [:categories], rs.named_routes.names
  end

  def test_nil_defaults
    rs.draw do |map|
      map.connect 'journal',
        :controller =&gt; 'content',
        :action =&gt; 'list_journal',
        :date =&gt; nil, :user_id =&gt; nil
      map.connect ':controller/:action/:id'
    end

    assert_equal '/journal', rs.generate(:controller =&gt; 'content', :action =&gt; 'list_journal', :date =&gt; nil, :user_id =&gt; nil)
  end

  def setup_request_method_routes_for(method)
    @request = ActionController::TestRequest.new
    @request.env[&quot;REQUEST_METHOD&quot;] = method
    @request.request_uri = &quot;/match&quot;

    rs.draw do |r|
      r.connect '/match', :controller =&gt; 'books', :action =&gt; 'get', :conditions =&gt; { :method =&gt; :get }
      r.connect '/match', :controller =&gt; 'books', :action =&gt; 'post', :conditions =&gt; { :method =&gt; :post }
      r.connect '/match', :controller =&gt; 'books', :action =&gt; 'put', :conditions =&gt; { :method =&gt; :put }
      r.connect '/match', :controller =&gt; 'books', :action =&gt; 'delete', :conditions =&gt; { :method =&gt; :delete }
    end
  end

  %w(GET POST PUT DELETE).each do |request_method|
    define_method(&quot;test_request_method_recognized_with_#{request_method}&quot;) do
      begin
        Object.const_set(:BooksController, Class.new(ActionController::Base))

        setup_request_method_routes_for(request_method)

        assert_nothing_raised { rs.recognize(@request) }
        assert_equal request_method.downcase, @request.path_parameters[:action]
      ensure
        Object.send(:remove_const, :BooksController) rescue nil
      end
    end
  end

  def test_recognize_array_of_methods
    Object.const_set(:BooksController, Class.new(ActionController::Base))
    rs.draw do |r|
      r.connect '/match', :controller =&gt; 'books', :action =&gt; 'get_or_post', :conditions =&gt; { :method =&gt; [:get, :post] }
      r.connect '/match', :controller =&gt; 'books', :action =&gt; 'not_get_or_post'
    end

    @request = ActionController::TestRequest.new
    @request.env[&quot;REQUEST_METHOD&quot;] = 'POST'
    @request.request_uri = &quot;/match&quot;
    assert_nothing_raised { rs.recognize(@request) }
    assert_equal 'get_or_post', @request.path_parameters[:action]

    # have to recreate or else the RouteSet uses a cached version:
    @request = ActionController::TestRequest.new
    @request.env[&quot;REQUEST_METHOD&quot;] = 'PUT'
    @request.request_uri = &quot;/match&quot;
    assert_nothing_raised { rs.recognize(@request) }
    assert_equal 'not_get_or_post', @request.path_parameters[:action]
  ensure
    Object.send(:remove_const, :BooksController) rescue nil
  end

  def test_subpath_recognized
    Object.const_set(:SubpathBooksController, Class.new(ActionController::Base))

    rs.draw do |r|
      r.connect '/books/:id/edit', :controller =&gt; 'subpath_books', :action =&gt; 'edit'
      r.connect '/items/:id/:action', :controller =&gt; 'subpath_books'
      r.connect '/posts/new/:action', :controller =&gt; 'subpath_books'
      r.connect '/posts/:id', :controller =&gt; 'subpath_books', :action =&gt; &quot;show&quot;
    end

    hash = rs.recognize_path &quot;/books/17/edit&quot;
    assert_not_nil hash
    assert_equal %w(subpath_books 17 edit), [hash[:controller], hash[:id], hash[:action]]

    hash = rs.recognize_path &quot;/items/3/complete&quot;
    assert_not_nil hash
    assert_equal %w(subpath_books 3 complete), [hash[:controller], hash[:id], hash[:action]]

    hash = rs.recognize_path &quot;/posts/new/preview&quot;
    assert_not_nil hash
    assert_equal %w(subpath_books preview), [hash[:controller], hash[:action]]

    hash = rs.recognize_path &quot;/posts/7&quot;
    assert_not_nil hash
    assert_equal %w(subpath_books show 7), [hash[:controller], hash[:action], hash[:id]]
  ensure
    Object.send(:remove_const, :SubpathBooksController) rescue nil
  end

  def test_subpath_generated
    Object.const_set(:SubpathBooksController, Class.new(ActionController::Base))

    rs.draw do |r|
      r.connect '/books/:id/edit', :controller =&gt; 'subpath_books', :action =&gt; 'edit'
      r.connect '/items/:id/:action', :controller =&gt; 'subpath_books'
      r.connect '/posts/new/:action', :controller =&gt; 'subpath_books'
    end

    assert_equal &quot;/books/7/edit&quot;, rs.generate(:controller =&gt; &quot;subpath_books&quot;, :id =&gt; 7, :action =&gt; &quot;edit&quot;)
    assert_equal &quot;/items/15/complete&quot;, rs.generate(:controller =&gt; &quot;subpath_books&quot;, :id =&gt; 15, :action =&gt; &quot;complete&quot;)
    assert_equal &quot;/posts/new/preview&quot;, rs.generate(:controller =&gt; &quot;subpath_books&quot;, :action =&gt; &quot;preview&quot;)
  ensure
    Object.send(:remove_const, :SubpathBooksController) rescue nil
  end

  def test_failed_requirements_raises_exception_with_violated_requirements
    rs.draw do |r|
      r.foo_with_requirement 'foos/:id', :controller=&gt;'foos', :requirements=&gt;{:id=&gt;/\d+/}
    end

    x = setup_for_named_route
    assert_raise(ActionController::RoutingError) do
      x.send(:foo_with_requirement_url, &quot;I am Against the requirements&quot;)
    end
  end

  def test_routes_changed_correctly_after_clear
    ActionController::Base.optimise_named_routes = true
    rs = ::ActionController::Routing::RouteSet.new
    rs.draw do |r|
      r.connect 'ca', :controller =&gt; 'ca', :action =&gt; &quot;aa&quot;
      r.connect 'cb', :controller =&gt; 'cb', :action =&gt; &quot;ab&quot;
      r.connect 'cc', :controller =&gt; 'cc', :action =&gt; &quot;ac&quot;
      r.connect ':controller/:action/:id'
      r.connect ':controller/:action/:id.:format'
    end

    hash = rs.recognize_path &quot;/cc&quot;

    assert_not_nil hash
    assert_equal %w(cc ac), [hash[:controller], hash[:action]]

    rs.draw do |r|
      r.connect 'cb', :controller =&gt; 'cb', :action =&gt; &quot;ab&quot;
      r.connect 'cc', :controller =&gt; 'cc', :action =&gt; &quot;ac&quot;
      r.connect ':controller/:action/:id'
      r.connect ':controller/:action/:id.:format'
    end

    hash = rs.recognize_path &quot;/cc&quot;

    assert_not_nil hash
    assert_equal %w(cc ac), [hash[:controller], hash[:action]]

  end
end

class RouteTest &lt; Test::Unit::TestCase
  def setup
    @route = ROUTING::Route.new
  end

  def slash_segment(is_optional = false)
    ROUTING::DividerSegment.new('/', :optional =&gt; is_optional)
  end

  def default_route
    unless defined?(@default_route)
      segments = []
      segments &lt;&lt; ROUTING::StaticSegment.new('/', :raw =&gt; true)
      segments &lt;&lt; ROUTING::DynamicSegment.new(:controller)
      segments &lt;&lt; slash_segment(:optional)
      segments &lt;&lt; ROUTING::DynamicSegment.new(:action, :default =&gt; 'index', :optional =&gt; true)
      segments &lt;&lt; slash_segment(:optional)
      segments &lt;&lt; ROUTING::DynamicSegment.new(:id, :optional =&gt; true)
      segments &lt;&lt; slash_segment(:optional)
      @default_route = ROUTING::Route.new(segments).freeze
    end
    @default_route
  end

  def test_default_route_recognition
    expected = {:controller =&gt; 'accounts', :action =&gt; 'show', :id =&gt; '10'}
    assert_equal expected, default_route.recognize('/accounts/show/10')
    assert_equal expected, default_route.recognize('/accounts/show/10/')

    expected[:id] = 'jamis'
    assert_equal expected, default_route.recognize('/accounts/show/jamis/')

    expected.delete :id
    assert_equal expected, default_route.recognize('/accounts/show')
    assert_equal expected, default_route.recognize('/accounts/show/')

    expected[:action] = 'index'
    assert_equal expected, default_route.recognize('/accounts/')
    assert_equal expected, default_route.recognize('/accounts')

    assert_equal nil, default_route.recognize('/')
    assert_equal nil, default_route.recognize('/accounts/how/goood/it/is/to/be/free')
  end

  def test_default_route_should_omit_default_action
    o = {:controller =&gt; 'accounts', :action =&gt; 'index'}
    assert_equal '/accounts', default_route.generate(o, o, {})
  end

  def test_default_route_should_include_default_action_when_id_present
    o = {:controller =&gt; 'accounts', :action =&gt; 'index', :id =&gt; '20'}
    assert_equal '/accounts/index/20', default_route.generate(o, o, {})
  end

  def test_default_route_should_work_with_action_but_no_id
    o = {:controller =&gt; 'accounts', :action =&gt; 'list_all'}
    assert_equal '/accounts/list_all', default_route.generate(o, o, {})
  end

  def test_default_route_should_uri_escape_pluses
    expected = { :controller =&gt; 'accounts', :action =&gt; 'show', :id =&gt; 'hello world' }
    assert_equal expected, default_route.recognize('/accounts/show/hello world')
    assert_equal expected, default_route.recognize('/accounts/show/hello%20world')
    assert_equal '/accounts/show/hello%20world', default_route.generate(expected, expected, {})

    expected[:id] = 'hello+world'
    assert_equal expected, default_route.recognize('/accounts/show/hello+world')
    assert_equal expected, default_route.recognize('/accounts/show/hello%2Bworld')
    assert_equal '/accounts/show/hello+world', default_route.generate(expected, expected, {})
  end

  def test_matches_controller_and_action
    # requirement_for should only be called for the action and controller _once_
    @route.expects(:requirement_for).with(:controller).times(1).returns('pages')
    @route.expects(:requirement_for).with(:action).times(1).returns('show')

    @route.requirements = {:controller =&gt; 'pages', :action =&gt; 'show'}
    assert @route.matches_controller_and_action?('pages', 'show')
    assert !@route.matches_controller_and_action?('not_pages', 'show')
    assert !@route.matches_controller_and_action?('pages', 'not_show')
  end

  def test_parameter_shell
    page_url = ROUTING::Route.new
    page_url.requirements = {:controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /\d+/}
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show'}, page_url.parameter_shell)
  end

  def test_defaults
    route = ROUTING::RouteBuilder.new.build '/users/:id.:format', :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot;, :format =&gt; &quot;html&quot;
    assert_equal(
      { :controller =&gt; &quot;users&quot;, :action =&gt; &quot;show&quot;, :format =&gt; &quot;html&quot; },
      route.defaults)
  end

  def test_builder_complains_without_controller
    assert_raise(ArgumentError) do
      ROUTING::RouteBuilder.new.build '/contact', :contoller =&gt; &quot;contact&quot;, :action =&gt; &quot;index&quot;
    end
  end

  def test_significant_keys_for_default_route
    keys = default_route.significant_keys.sort_by {|k| k.to_s }
    assert_equal [:action, :controller, :id], keys
  end

  def test_significant_keys
    segments = []
    segments &lt;&lt; ROUTING::StaticSegment.new('/', :raw =&gt; true)
    segments &lt;&lt; ROUTING::StaticSegment.new('user')
    segments &lt;&lt; ROUTING::StaticSegment.new('/', :raw =&gt; true, :optional =&gt; true)
    segments &lt;&lt; ROUTING::DynamicSegment.new(:user)
    segments &lt;&lt; ROUTING::StaticSegment.new('/', :raw =&gt; true, :optional =&gt; true)

    requirements = {:controller =&gt; 'users', :action =&gt; 'show'}

    user_url = ROUTING::Route.new(segments, requirements)
    keys = user_url.significant_keys.sort_by { |k| k.to_s }
    assert_equal [:action, :controller, :user], keys
  end

  def test_build_empty_query_string
    assert_equal '', @route.build_query_string({})
  end

  def test_build_query_string_with_nil_value
    assert_equal '', @route.build_query_string({:x =&gt; nil})
  end

  def test_simple_build_query_string
    assert_equal '?x=1&amp;y=2', order_query_string(@route.build_query_string(:x =&gt; '1', :y =&gt; '2'))
  end

  def test_convert_ints_build_query_string
    assert_equal '?x=1&amp;y=2', order_query_string(@route.build_query_string(:x =&gt; 1, :y =&gt; 2))
  end

  def test_escape_spaces_build_query_string
    assert_equal '?x=hello+world&amp;y=goodbye+world', order_query_string(@route.build_query_string(:x =&gt; 'hello world', :y =&gt; 'goodbye world'))
  end

  def test_expand_array_build_query_string
    assert_equal '?x%5B%5D=1&amp;x%5B%5D=2', order_query_string(@route.build_query_string(:x =&gt; [1, 2]))
  end

  def test_escape_spaces_build_query_string_selected_keys
    assert_equal '?x=hello+world', order_query_string(@route.build_query_string({:x =&gt; 'hello world', :y =&gt; 'goodbye world'}, [:x]))
  end

  private
    def order_query_string(qs)
      '?' + qs[1..-1].split('&amp;').sort.join('&amp;')
    end
end

class RouteSetTest &lt; ActiveSupport::TestCase
  def set
    @set ||= ROUTING::RouteSet.new
  end

  def request
    @request ||= ActionController::TestRequest.new
  end

  def test_generate_extras
    set.draw { |m| m.connect ':controller/:action/:id' }
    path, extras = set.generate_extras(:controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; 15, :this =&gt; &quot;hello&quot;, :that =&gt; &quot;world&quot;)
    assert_equal &quot;/foo/bar/15&quot;, path
    assert_equal %w(that this), extras.map(&amp;:to_s).sort
  end

  def test_extra_keys
    set.draw { |m| m.connect ':controller/:action/:id' }
    extras = set.extra_keys(:controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; 15, :this =&gt; &quot;hello&quot;, :that =&gt; &quot;world&quot;)
    assert_equal %w(that this), extras.map(&amp;:to_s).sort
  end

  def test_generate_extras_not_first
    set.draw do |map|
      map.connect ':controller/:action/:id.:format'
      map.connect ':controller/:action/:id'
    end
    path, extras = set.generate_extras(:controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; 15, :this =&gt; &quot;hello&quot;, :that =&gt; &quot;world&quot;)
    assert_equal &quot;/foo/bar/15&quot;, path
    assert_equal %w(that this), extras.map(&amp;:to_s).sort
  end

  def test_generate_not_first
    set.draw do |map|
      map.connect ':controller/:action/:id.:format'
      map.connect ':controller/:action/:id'
    end
    assert_equal &quot;/foo/bar/15?this=hello&quot;, set.generate(:controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; 15, :this =&gt; &quot;hello&quot;)
  end

  def test_extra_keys_not_first
    set.draw do |map|
      map.connect ':controller/:action/:id.:format'
      map.connect ':controller/:action/:id'
    end
    extras = set.extra_keys(:controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; 15, :this =&gt; &quot;hello&quot;, :that =&gt; &quot;world&quot;)
    assert_equal %w(that this), extras.map(&amp;:to_s).sort
  end

  def test_draw
    assert_equal 0, set.routes.size
    set.draw do |map|
      map.connect '/hello/world', :controller =&gt; 'a', :action =&gt; 'b'
    end
    assert_equal 1, set.routes.size
  end

  def test_draw_symbol_controller_name
    assert_equal 0, set.routes.size
    set.draw do |map|
      map.connect '/users/index', :controller =&gt; :users, :action =&gt; :index
    end
    @request = ActionController::TestRequest.new
    @request.request_uri = '/users/index'
    assert_nothing_raised { set.recognize(@request) }
    assert_equal 1, set.routes.size
  end

  def test_named_draw
    assert_equal 0, set.routes.size
    set.draw do |map|
      map.hello '/hello/world', :controller =&gt; 'a', :action =&gt; 'b'
    end
    assert_equal 1, set.routes.size
    assert_equal set.routes.first, set.named_routes[:hello]
  end

  def test_later_named_routes_take_precedence
    set.draw do |map|
      map.hello '/hello/world', :controller =&gt; 'a', :action =&gt; 'b'
      map.hello '/hello', :controller =&gt; 'a', :action =&gt; 'b'
    end
    assert_equal set.routes.last, set.named_routes[:hello]
  end

  def setup_named_route_test
    set.draw do |map|
      map.show '/people/:id', :controller =&gt; 'people', :action =&gt; 'show'
      map.index '/people', :controller =&gt; 'people', :action =&gt; 'index'
      map.multi '/people/go/:foo/:bar/joe/:id', :controller =&gt; 'people', :action =&gt; 'multi'
      map.users '/admin/users', :controller =&gt; 'admin/users', :action =&gt; 'index'
    end

    klass = Class.new(MockController)
    set.install_helpers(klass)
    klass.new(set)
  end

  def test_named_route_hash_access_method
    controller = setup_named_route_test

    assert_equal(
      { :controller =&gt; 'people', :action =&gt; 'show', :id =&gt; 5, :use_route =&gt; :show, :only_path =&gt; false },
      controller.send(:hash_for_show_url, :id =&gt; 5))

    assert_equal(
      { :controller =&gt; 'people', :action =&gt; 'index', :use_route =&gt; :index, :only_path =&gt; false },
      controller.send(:hash_for_index_url))

    assert_equal(
      { :controller =&gt; 'people', :action =&gt; 'show', :id =&gt; 5, :use_route =&gt; :show, :only_path =&gt; true },
      controller.send(:hash_for_show_path, :id =&gt; 5)
    )
  end

  def test_named_route_url_method
    controller = setup_named_route_test

    assert_equal &quot;http://test.host/people/5&quot;, controller.send(:show_url, :id =&gt; 5)
    assert_equal &quot;/people/5&quot;, controller.send(:show_path, :id =&gt; 5)

    assert_equal &quot;http://test.host/people&quot;, controller.send(:index_url)
    assert_equal &quot;/people&quot;, controller.send(:index_path)

    assert_equal &quot;http://test.host/admin/users&quot;, controller.send(:users_url)
    assert_equal '/admin/users', controller.send(:users_path)
    assert_equal '/admin/users', set.generate(controller.send(:hash_for_users_url), {:controller =&gt; 'users', :action =&gt; 'index'})
  end

  def test_named_route_url_method_with_anchor
    controller = setup_named_route_test

    assert_equal &quot;http://test.host/people/5#location&quot;, controller.send(:show_url, :id =&gt; 5, :anchor =&gt; 'location')
    assert_equal &quot;/people/5#location&quot;, controller.send(:show_path, :id =&gt; 5, :anchor =&gt; 'location')

    assert_equal &quot;http://test.host/people#location&quot;, controller.send(:index_url, :anchor =&gt; 'location')
    assert_equal &quot;/people#location&quot;, controller.send(:index_path, :anchor =&gt; 'location')

    assert_equal &quot;http://test.host/admin/users#location&quot;, controller.send(:users_url, :anchor =&gt; 'location')
    assert_equal '/admin/users#location', controller.send(:users_path, :anchor =&gt; 'location')

    assert_equal &quot;http://test.host/people/go/7/hello/joe/5#location&quot;,
      controller.send(:multi_url, 7, &quot;hello&quot;, 5, :anchor =&gt; 'location')

    assert_equal &quot;http://test.host/people/go/7/hello/joe/5?baz=bar#location&quot;,
      controller.send(:multi_url, 7, &quot;hello&quot;, 5, :baz =&gt; &quot;bar&quot;, :anchor =&gt; 'location')

    assert_equal &quot;http://test.host/people?baz=bar#location&quot;,
      controller.send(:index_url, :baz =&gt; &quot;bar&quot;, :anchor =&gt; 'location')
  end

  def test_named_route_url_method_with_port
    controller = setup_named_route_test
    assert_equal &quot;http://test.host:8080/people/5&quot;, controller.send(:show_url, 5, :port=&gt;8080)
  end

  def test_named_route_url_method_with_host
    controller = setup_named_route_test
    assert_equal &quot;http://some.example.com/people/5&quot;, controller.send(:show_url, 5, :host=&gt;&quot;some.example.com&quot;)
  end

  def test_named_route_url_method_with_protocol
    controller = setup_named_route_test
    assert_equal &quot;https://test.host/people/5&quot;, controller.send(:show_url, 5, :protocol =&gt; &quot;https&quot;)
  end

  def test_named_route_url_method_with_ordered_parameters
    controller = setup_named_route_test
    assert_equal &quot;http://test.host/people/go/7/hello/joe/5&quot;,
      controller.send(:multi_url, 7, &quot;hello&quot;, 5)
  end

  def test_named_route_url_method_with_ordered_parameters_and_hash
    controller = setup_named_route_test
    assert_equal &quot;http://test.host/people/go/7/hello/joe/5?baz=bar&quot;,
      controller.send(:multi_url, 7, &quot;hello&quot;, 5, :baz =&gt; &quot;bar&quot;)
  end

  def test_named_route_url_method_with_ordered_parameters_and_empty_hash
    controller = setup_named_route_test
    assert_equal &quot;http://test.host/people/go/7/hello/joe/5&quot;,
      controller.send(:multi_url, 7, &quot;hello&quot;, 5, {})
  end

  def test_named_route_url_method_with_no_positional_arguments
    controller = setup_named_route_test
    assert_equal &quot;http://test.host/people?baz=bar&quot;,
      controller.send(:index_url, :baz =&gt; &quot;bar&quot;)
  end

  def test_draw_default_route
    ActionController::Routing.with_controllers(['users']) do
      set.draw do |map|
        map.connect '/:controller/:action/:id'
      end

      assert_equal 1, set.routes.size
      route = set.routes.first

      assert route.segments.last.optional?

      assert_equal '/users/show/10', set.generate(:controller =&gt; 'users', :action =&gt; 'show', :id =&gt; 10)
      assert_equal '/users/index/10', set.generate(:controller =&gt; 'users', :id =&gt; 10)

      assert_equal({:controller =&gt; 'users', :action =&gt; 'index', :id =&gt; '10'}, set.recognize_path('/users/index/10'))
      assert_equal({:controller =&gt; 'users', :action =&gt; 'index', :id =&gt; '10'}, set.recognize_path('/users/index/10/'))
    end
  end

  def test_draw_default_route_with_default_controller
    ActionController::Routing.with_controllers(['users']) do
      set.draw do |map|
        map.connect '/:controller/:action/:id', :controller =&gt; 'users'
      end
      assert_equal({:controller =&gt; 'users', :action =&gt; 'index'}, set.recognize_path('/'))
    end
  end

  def test_route_with_parameter_shell
    ActionController::Routing.with_controllers(['users', 'pages']) do
      set.draw do |map|
        map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /\d+/
        map.connect '/:controller/:action/:id'
      end

      assert_equal({:controller =&gt; 'pages', :action =&gt; 'index'}, set.recognize_path('/pages'))
      assert_equal({:controller =&gt; 'pages', :action =&gt; 'index'}, set.recognize_path('/pages/index'))
      assert_equal({:controller =&gt; 'pages', :action =&gt; 'list'}, set.recognize_path('/pages/list'))

      assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; '10'}, set.recognize_path('/pages/show/10'))
      assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; '10'}, set.recognize_path('/page/10'))
    end
  end

  def test_route_requirements_with_anchor_chars_are_invalid
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /^\d+/
      end
    end
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /\A\d+/
      end
    end
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /\d+$/
      end
    end
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /\d+\Z/
      end
    end
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /\d+\z/
      end
    end
    assert_nothing_raised do
      set.draw do |map|
        map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /\d+/, :name =&gt; /^(david|jamis)/
      end
      assert_raise ActionController::RoutingError do
        set.generate :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; 10
      end
    end
  end

  def test_route_requirements_with_invalid_http_method_is_invalid
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'valid/route', :controller =&gt; 'pages', :action =&gt; 'show', :conditions =&gt; {:method =&gt; :invalid}
      end
    end
  end

  def test_route_requirements_with_options_method_condition_is_valid
    assert_nothing_raised do
      set.draw do |map|
        map.connect 'valid/route', :controller =&gt; 'pages', :action =&gt; 'show', :conditions =&gt; {:method =&gt; :options}
      end
    end
  end

  def test_route_requirements_with_head_method_condition_is_invalid
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'valid/route', :controller =&gt; 'pages', :action =&gt; 'show', :conditions =&gt; {:method =&gt; :head}
      end
    end
  end

  def test_non_path_route_requirements_match_all
    set.draw do |map|
      map.connect 'page/37s', :controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; /(jamis|david)/
    end
    assert_equal '/page/37s', set.generate(:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'jamis')
    assert_raise ActionController::RoutingError do
      set.generate(:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'not_jamis')
    end
    assert_raise ActionController::RoutingError do
      set.generate(:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'nor_jamis_and_david')
    end
  end

  def test_recognize_with_encoded_id_and_regex
    set.draw do |map|
      map.connect 'page/:id', :controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; /[a-zA-Z0-9\+]+/
    end

    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; '10'}, set.recognize_path('/page/10'))
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :id =&gt; 'hello+world'}, set.recognize_path('/page/hello+world'))
  end

  def test_recognize_with_conditions
    Object.const_set(:PeopleController, Class.new)

    set.draw do |map|
      map.with_options(:controller =&gt; &quot;people&quot;) do |people|
        people.people  &quot;/people&quot;,     :action =&gt; &quot;index&quot;,   :conditions =&gt; { :method =&gt; :get }
        people.connect &quot;/people&quot;,     :action =&gt; &quot;create&quot;,  :conditions =&gt; { :method =&gt; :post }
        people.person  &quot;/people/:id&quot;, :action =&gt; &quot;show&quot;,    :conditions =&gt; { :method =&gt; :get }
        people.connect &quot;/people/:id&quot;, :action =&gt; &quot;update&quot;,  :conditions =&gt; { :method =&gt; :put }
        people.connect &quot;/people/:id&quot;, :action =&gt; &quot;destroy&quot;, :conditions =&gt; { :method =&gt; :delete }
      end
    end

    request.path = &quot;/people&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;index&quot;, request.path_parameters[:action])
    request.recycle!

    request.env[&quot;REQUEST_METHOD&quot;] = &quot;POST&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;create&quot;, request.path_parameters[:action])
    request.recycle!

    request.env[&quot;REQUEST_METHOD&quot;] = &quot;PUT&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;update&quot;, request.path_parameters[:action])
    request.recycle!

    assert_raise(ActionController::UnknownHttpMethod) {
      request.env[&quot;REQUEST_METHOD&quot;] = &quot;BACON&quot;
      set.recognize(request)
    }
    request.recycle!

    request.path = &quot;/people/5&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;show&quot;, request.path_parameters[:action])
    assert_equal(&quot;5&quot;, request.path_parameters[:id])
    request.recycle!

    request.env[&quot;REQUEST_METHOD&quot;] = &quot;PUT&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;update&quot;, request.path_parameters[:action])
    assert_equal(&quot;5&quot;, request.path_parameters[:id])
    request.recycle!

    request.env[&quot;REQUEST_METHOD&quot;] = &quot;DELETE&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;destroy&quot;, request.path_parameters[:action])
    assert_equal(&quot;5&quot;, request.path_parameters[:id])
    request.recycle!

    begin
      request.env[&quot;REQUEST_METHOD&quot;] = &quot;POST&quot;
      set.recognize(request)
      flunk 'Should have raised MethodNotAllowed'
    rescue ActionController::MethodNotAllowed =&gt; e
      assert_equal [:get, :put, :delete], e.allowed_methods
    end
    request.recycle!

  ensure
    Object.send(:remove_const, :PeopleController)
  end

  def test_recognize_with_alias_in_conditions
    Object.const_set(:PeopleController, Class.new)

    set.draw do |map|
      map.people &quot;/people&quot;, :controller =&gt; 'people', :action =&gt; &quot;index&quot;,
        :conditions =&gt; { :method =&gt; :get }
      map.root   :people
    end

    request.path = &quot;/people&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;people&quot;, request.path_parameters[:controller])
    assert_equal(&quot;index&quot;, request.path_parameters[:action])

    request.path = &quot;/&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;people&quot;, request.path_parameters[:controller])
    assert_equal(&quot;index&quot;, request.path_parameters[:action])
  ensure
    Object.send(:remove_const, :PeopleController)
  end

  def test_typo_recognition
    Object.const_set(:ArticlesController, Class.new)

    set.draw do |map|
      map.connect 'articles/:year/:month/:day/:title',
             :controller =&gt; 'articles', :action =&gt; 'permalink',
             :year =&gt; /\d{4}/, :day =&gt; /\d{1,2}/, :month =&gt; /\d{1,2}/
    end

    request.path = &quot;/articles/2005/11/05/a-very-interesting-article&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;permalink&quot;, request.path_parameters[:action])
    assert_equal(&quot;2005&quot;, request.path_parameters[:year])
    assert_equal(&quot;11&quot;, request.path_parameters[:month])
    assert_equal(&quot;05&quot;, request.path_parameters[:day])
    assert_equal(&quot;a-very-interesting-article&quot;, request.path_parameters[:title])

  ensure
    Object.send(:remove_const, :ArticlesController)
  end

  def test_routing_traversal_does_not_load_extra_classes
    assert !Object.const_defined?(&quot;Profiler__&quot;), &quot;Profiler should not be loaded&quot;
    set.draw do |map|
      map.connect '/profile', :controller =&gt; 'profile'
    end

    request.path = '/profile'

    set.recognize(request) rescue nil

    assert !Object.const_defined?(&quot;Profiler__&quot;), &quot;Profiler should not be loaded&quot;
  end

  def test_recognize_with_conditions_and_format
    Object.const_set(:PeopleController, Class.new)

    set.draw do |map|
      map.with_options(:controller =&gt; &quot;people&quot;) do |people|
        people.person  &quot;/people/:id&quot;, :action =&gt; &quot;show&quot;,    :conditions =&gt; { :method =&gt; :get }
        people.connect &quot;/people/:id&quot;, :action =&gt; &quot;update&quot;,  :conditions =&gt; { :method =&gt; :put }
        people.connect &quot;/people/:id.:_format&quot;, :action =&gt; &quot;show&quot;, :conditions =&gt; { :method =&gt; :get }
      end
    end

    request.path = &quot;/people/5&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;show&quot;, request.path_parameters[:action])
    assert_equal(&quot;5&quot;, request.path_parameters[:id])
    request.recycle!

    request.env[&quot;REQUEST_METHOD&quot;] = &quot;PUT&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;update&quot;, request.path_parameters[:action])
    request.recycle!

    request.path = &quot;/people/5.png&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;show&quot;, request.path_parameters[:action])
    assert_equal(&quot;5&quot;, request.path_parameters[:id])
    assert_equal(&quot;png&quot;, request.path_parameters[:_format])
  ensure
    Object.send(:remove_const, :PeopleController)
  end

  def test_generate_with_default_action
    set.draw do |map|
      map.connect &quot;/people&quot;, :controller =&gt; &quot;people&quot;
      map.connect &quot;/people/list&quot;, :controller =&gt; &quot;people&quot;, :action =&gt; &quot;list&quot;
    end

    url = set.generate(:controller =&gt; &quot;people&quot;, :action =&gt; &quot;list&quot;)
    assert_equal &quot;/people/list&quot;, url
  end

  def test_root_map
    Object.const_set(:PeopleController, Class.new)

    set.draw { |map| map.root :controller =&gt; &quot;people&quot; }

    request.path = &quot;&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;people&quot;, request.path_parameters[:controller])
    assert_equal(&quot;index&quot;, request.path_parameters[:action])
  ensure
    Object.send(:remove_const, :PeopleController)
  end

  def test_namespace
    Object.const_set(:Api, Module.new { |m| m.const_set(:ProductsController, Class.new) })

    set.draw do |map|

      map.namespace 'api' do |api|
        api.route 'inventory', :controller =&gt; &quot;products&quot;, :action =&gt; 'inventory'
      end

    end

    request.path = &quot;/api/inventory&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;api/products&quot;, request.path_parameters[:controller])
    assert_equal(&quot;inventory&quot;, request.path_parameters[:action])
  ensure
    Object.send(:remove_const, :Api)
  end

  def test_namespaced_root_map
    Object.const_set(:Api, Module.new { |m| m.const_set(:ProductsController, Class.new) })

    set.draw do |map|

      map.namespace 'api' do |api|
        api.root :controller =&gt; &quot;products&quot;
      end

    end

    request.path = &quot;/api&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;api/products&quot;, request.path_parameters[:controller])
    assert_equal(&quot;index&quot;, request.path_parameters[:action])
  ensure
    Object.send(:remove_const, :Api)
  end

  def test_namespace_with_path_prefix
    Object.const_set(:Api, Module.new { |m| m.const_set(:ProductsController, Class.new) })

    set.draw do |map|
      map.namespace 'api', :path_prefix =&gt; 'prefix' do |api|
        api.route 'inventory', :controller =&gt; &quot;products&quot;, :action =&gt; 'inventory'
      end
    end

    request.path = &quot;/prefix/inventory&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;api/products&quot;, request.path_parameters[:controller])
    assert_equal(&quot;inventory&quot;, request.path_parameters[:action])
  ensure
    Object.send(:remove_const, :Api)
  end

  def test_namespace_with_blank_path_prefix
    Object.const_set(:Api, Module.new { |m| m.const_set(:ProductsController, Class.new) })

    set.draw do |map|
      map.namespace 'api', :path_prefix =&gt; '' do |api|
        api.route 'inventory', :controller =&gt; &quot;products&quot;, :action =&gt; 'inventory'
      end
    end

    request.path = &quot;/inventory&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;api/products&quot;, request.path_parameters[:controller])
    assert_equal(&quot;inventory&quot;, request.path_parameters[:action])
  ensure
    Object.send(:remove_const, :Api)
  end

  def test_generate_finds_best_fit
    set.draw do |map|
      map.connect &quot;/people&quot;, :controller =&gt; &quot;people&quot;, :action =&gt; &quot;index&quot;
      map.connect &quot;/ws/people&quot;, :controller =&gt; &quot;people&quot;, :action =&gt; &quot;index&quot;, :ws =&gt; true
    end

    url = set.generate(:controller =&gt; &quot;people&quot;, :action =&gt; &quot;index&quot;, :ws =&gt; true)
    assert_equal &quot;/ws/people&quot;, url
  end

  def test_generate_changes_controller_module
    set.draw { |map| map.connect ':controller/:action/:id' }
    current = { :controller =&gt; &quot;bling/bloop&quot;, :action =&gt; &quot;bap&quot;, :id =&gt; 9 }
    url = set.generate({:controller =&gt; &quot;foo/bar&quot;, :action =&gt; &quot;baz&quot;, :id =&gt; 7}, current)
    assert_equal &quot;/foo/bar/baz/7&quot;, url
  end

  def test_id_is_not_impossibly_sticky
    set.draw do |map|
      map.connect 'foo/:number', :controller =&gt; &quot;people&quot;, :action =&gt; &quot;index&quot;
      map.connect ':controller/:action/:id'
    end

    url = set.generate({:controller =&gt; &quot;people&quot;, :action =&gt; &quot;index&quot;, :number =&gt; 3},
      {:controller =&gt; &quot;people&quot;, :action =&gt; &quot;index&quot;, :id =&gt; &quot;21&quot;})
    assert_equal &quot;/foo/3&quot;, url
  end

  def test_id_is_sticky_when_it_ought_to_be
    set.draw do |map|
      map.connect ':controller/:id/:action'
    end

    url = set.generate({:action =&gt; &quot;destroy&quot;}, {:controller =&gt; &quot;people&quot;, :action =&gt; &quot;show&quot;, :id =&gt; &quot;7&quot;})
    assert_equal &quot;/people/7/destroy&quot;, url
  end

  def test_use_static_path_when_possible
    set.draw do |map|
      map.connect 'about', :controller =&gt; &quot;welcome&quot;, :action =&gt; &quot;about&quot;
      map.connect ':controller/:action/:id'
    end

    url = set.generate({:controller =&gt; &quot;welcome&quot;, :action =&gt; &quot;about&quot;},
      {:controller =&gt; &quot;welcome&quot;, :action =&gt; &quot;get&quot;, :id =&gt; &quot;7&quot;})
    assert_equal &quot;/about&quot;, url
  end

  def test_generate
    set.draw { |map| map.connect ':controller/:action/:id' }

    args = { :controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; &quot;7&quot;, :x =&gt; &quot;y&quot; }
    assert_equal &quot;/foo/bar/7?x=y&quot;, set.generate(args)
    assert_equal [&quot;/foo/bar/7&quot;, [:x]], set.generate_extras(args)
    assert_equal [:x], set.extra_keys(args)
  end

  def test_generate_with_path_prefix
    set.draw { |map| map.connect ':controller/:action/:id', :path_prefix =&gt; 'my' }

    args = { :controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; &quot;7&quot;, :x =&gt; &quot;y&quot; }
    assert_equal &quot;/my/foo/bar/7?x=y&quot;, set.generate(args)
  end

  def test_generate_with_blank_path_prefix
    set.draw { |map| map.connect ':controller/:action/:id', :path_prefix =&gt; '' }

    args = { :controller =&gt; &quot;foo&quot;, :action =&gt; &quot;bar&quot;, :id =&gt; &quot;7&quot;, :x =&gt; &quot;y&quot; }
    assert_equal &quot;/foo/bar/7?x=y&quot;, set.generate(args)
  end

  def test_named_routes_are_never_relative_to_modules
    set.draw do |map|
      map.connect &quot;/connection/manage/:action&quot;, :controller =&gt; 'connection/manage'
      map.connect &quot;/connection/connection&quot;, :controller =&gt; &quot;connection/connection&quot;
      map.family_connection &quot;/connection&quot;, :controller =&gt; &quot;connection&quot;
    end

    url = set.generate({:controller =&gt; &quot;connection&quot;}, {:controller =&gt; 'connection/manage'})
    assert_equal &quot;/connection/connection&quot;, url

    url = set.generate({:use_route =&gt; :family_connection, :controller =&gt; &quot;connection&quot;}, {:controller =&gt; 'connection/manage'})
    assert_equal &quot;/connection&quot;, url
  end

  def test_action_left_off_when_id_is_recalled
    set.draw do |map|
      map.connect ':controller/:action/:id'
    end
    assert_equal '/post', set.generate(
      {:controller =&gt; 'post', :action =&gt; 'index'},
      {:controller =&gt; 'post', :action =&gt; 'show', :id =&gt; '10'}
    )
  end

  def test_query_params_will_be_shown_when_recalled
    set.draw do |map|
      map.connect 'show_post/:parameter', :controller =&gt; 'post', :action =&gt; 'show'
      map.connect ':controller/:action/:id'
    end
    assert_equal '/post/edit?parameter=1', set.generate(
      {:action =&gt; 'edit', :parameter =&gt; 1},
      {:controller =&gt; 'post', :action =&gt; 'show', :parameter =&gt; 1}
    )
  end

  def test_format_is_not_inherit
    set.draw do |map|
      map.connect '/posts.:format', :controller =&gt; 'posts'
    end

    assert_equal '/posts', set.generate(
      {:controller =&gt; 'posts'},
      {:controller =&gt; 'posts', :action =&gt; 'index', :format =&gt; 'xml'}
    )

    assert_equal '/posts.xml', set.generate(
      {:controller =&gt; 'posts', :format =&gt; 'xml'},
      {:controller =&gt; 'posts', :action =&gt; 'index', :format =&gt; 'xml'}
    )
  end

  def test_expiry_determination_should_consider_values_with_to_param
    set.draw { |map| map.connect 'projects/:project_id/:controller/:action' }
    assert_equal '/projects/1/post/show', set.generate(
      {:action =&gt; 'show', :project_id =&gt; 1},
      {:controller =&gt; 'post', :action =&gt; 'show', :project_id =&gt; '1'})
  end

  def test_generate_all
    set.draw do |map|
      map.connect 'show_post/:id', :controller =&gt; 'post', :action =&gt; 'show'
      map.connect ':controller/:action/:id'
    end
    all = set.generate(
      {:action =&gt; 'show', :id =&gt; 10, :generate_all =&gt; true},
      {:controller =&gt; 'post', :action =&gt; 'show'}
    )
    assert_equal 2, all.length
    assert_equal '/show_post/10', all.first
    assert_equal '/post/show/10', all.last
  end

  def test_named_route_in_nested_resource
    set.draw do |map|
      map.resources :projects do |project|
        project.milestones 'milestones', :controller =&gt; 'milestones', :action =&gt; 'index'
      end
    end

    request.path = &quot;/projects/1/milestones&quot;
    request.env[&quot;REQUEST_METHOD&quot;] = &quot;GET&quot;
    assert_nothing_raised { set.recognize(request) }
    assert_equal(&quot;milestones&quot;, request.path_parameters[:controller])
    assert_equal(&quot;index&quot;, request.path_parameters[:action])
  end

  def test_setting_root_in_namespace_using_symbol
    assert_nothing_raised do
      set.draw do |map|
        map.namespace :admin do |admin|
          admin.root :controller =&gt; 'home'
        end
      end
    end
  end

  def test_setting_root_in_namespace_using_string
    assert_nothing_raised do
      set.draw do |map|
        map.namespace 'admin' do |admin|
          admin.root :controller =&gt; 'home'
        end
      end
    end
  end

  def test_route_requirements_with_unsupported_regexp_options_must_error
    assert_raise ArgumentError do
      set.draw do |map|
        map.connect 'page/:name', :controller =&gt; 'pages',
          :action =&gt; 'show',
          :requirements =&gt; {:name =&gt; /(david|jamis)/m}
      end
    end
  end

  def test_route_requirements_with_supported_options_must_not_error
    assert_nothing_raised do
      set.draw do |map|
        map.connect 'page/:name', :controller =&gt; 'pages',
          :action =&gt; 'show',
          :requirements =&gt; {:name =&gt; /(david|jamis)/i}
      end
    end
    assert_nothing_raised do
      set.draw do |map|
        map.connect 'page/:name', :controller =&gt; 'pages',
          :action =&gt; 'show',
          :requirements =&gt; {:name =&gt; / # Desperately overcommented regexp
                                      ( #Either
                                       david #The Creator
                                      | #Or
                                        jamis #The Deployer
                                      )/x}
      end
    end
  end

  def test_route_requirement_recognize_with_ignore_case
    set.draw do |map|
      map.connect 'page/:name', :controller =&gt; 'pages',
        :action =&gt; 'show',
        :requirements =&gt; {:name =&gt; /(david|jamis)/i}
    end
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'jamis'}, set.recognize_path('/page/jamis'))
    assert_raise ActionController::RoutingError do
      set.recognize_path('/page/davidjamis')
    end
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'DAVID'}, set.recognize_path('/page/DAVID'))
  end

  def test_route_requirement_generate_with_ignore_case
    set.draw do |map|
      map.connect 'page/:name', :controller =&gt; 'pages',
        :action =&gt; 'show',
        :requirements =&gt; {:name =&gt; /(david|jamis)/i}
    end
    url = set.generate({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'david'})
    assert_equal &quot;/page/david&quot;, url
    assert_raise ActionController::RoutingError do
      url = set.generate({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'davidjamis'})
    end
    url = set.generate({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'JAMIS'})
    assert_equal &quot;/page/JAMIS&quot;, url
  end

  def test_route_requirement_recognize_with_extended_syntax
    set.draw do |map|
      map.connect 'page/:name', :controller =&gt; 'pages',
        :action =&gt; 'show',
        :requirements =&gt; {:name =&gt; / # Desperately overcommented regexp
                                    ( #Either
                                     david #The Creator
                                    | #Or
                                      jamis #The Deployer
                                    )/x}
    end
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'jamis'}, set.recognize_path('/page/jamis'))
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'david'}, set.recognize_path('/page/david'))
    assert_raise ActionController::RoutingError do
      set.recognize_path('/page/david #The Creator')
    end
    assert_raise ActionController::RoutingError do
      set.recognize_path('/page/David')
    end
  end

  def test_route_requirement_generate_with_extended_syntax
    set.draw do |map|
      map.connect 'page/:name', :controller =&gt; 'pages',
        :action =&gt; 'show',
        :requirements =&gt; {:name =&gt; / # Desperately overcommented regexp
                                    ( #Either
                                     david #The Creator
                                    | #Or
                                      jamis #The Deployer
                                    )/x}
    end
    url = set.generate({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'david'})
    assert_equal &quot;/page/david&quot;, url
    assert_raise ActionController::RoutingError do
      url = set.generate({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'davidjamis'})
    end
    assert_raise ActionController::RoutingError do
      url = set.generate({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'JAMIS'})
    end
  end

  def test_route_requirement_generate_with_xi_modifiers
    set.draw do |map|
      map.connect 'page/:name', :controller =&gt; 'pages',
        :action =&gt; 'show',
        :requirements =&gt; {:name =&gt; / # Desperately overcommented regexp
                                    ( #Either
                                     david #The Creator
                                    | #Or
                                      jamis #The Deployer
                                    )/xi}
    end
    url = set.generate({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'JAMIS'})
    assert_equal &quot;/page/JAMIS&quot;, url
  end

  def test_route_requirement_recognize_with_xi_modifiers
    set.draw do |map|
      map.connect 'page/:name', :controller =&gt; 'pages',
        :action =&gt; 'show',
        :requirements =&gt; {:name =&gt; / # Desperately overcommented regexp
                                    ( #Either
                                     david #The Creator
                                    | #Or
                                      jamis #The Deployer
                                    )/xi}
    end
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; 'JAMIS'}, set.recognize_path('/page/JAMIS'))
  end

  def test_routes_with_symbols
    set.draw do |map|
      map.connect 'unnamed', :controller =&gt; :pages, :action =&gt; :show, :name =&gt; :as_symbol
      map.named   'named',   :controller =&gt; :pages, :action =&gt; :show, :name =&gt; :as_symbol
    end
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; :as_symbol}, set.recognize_path('/unnamed'))
    assert_equal({:controller =&gt; 'pages', :action =&gt; 'show', :name =&gt; :as_symbol}, set.recognize_path('/named'))
  end

end

class RouteLoadingTest &lt; Test::Unit::TestCase
  def setup
    routes.instance_variable_set '@routes_last_modified', nil
    silence_warnings { Object.const_set :RAILS_ROOT, '.' }
    routes.add_configuration_file(File.join(RAILS_ROOT, 'config', 'routes.rb'))

    @stat = stub_everything
  end

  def teardown
    ActionController::Routing::Routes.configuration_files.clear
    Object.send :remove_const, :RAILS_ROOT
  end

  def test_load
    File.expects(:stat).returns(@stat)
    routes.expects(:load).with(regexp_matches(/routes\.rb$/))

    routes.reload
  end

  def test_no_reload_when_not_modified
    @stat.expects(:mtime).times(2).returns(1)
    File.expects(:stat).times(2).returns(@stat)
    routes.expects(:load).with(regexp_matches(/routes\.rb$/)).at_most_once

    2.times { routes.reload }
  end

  def test_reload_when_modified
    @stat.expects(:mtime).at_least(2).returns(1, 2)
    File.expects(:stat).at_least(2).returns(@stat)
    routes.expects(:load).with(regexp_matches(/routes\.rb$/)).times(2)

    2.times { routes.reload }
  end

  def test_bang_forces_reload
    @stat.expects(:mtime).at_least(2).returns(1)
    File.expects(:stat).at_least(2).returns(@stat)
    routes.expects(:load).with(regexp_matches(/routes\.rb$/)).times(2)

    2.times { routes.reload! }
  end

  def test_adding_inflections_forces_reload
    ActiveSupport::Inflector::Inflections.instance.expects(:uncountable).with('equipment')
    routes.expects(:reload!)

    ActiveSupport::Inflector.inflections { |inflect| inflect.uncountable('equipment') }
  end

  def test_load_with_configuration
    routes.configuration_files.clear
    routes.add_configuration_file(&quot;foobarbaz&quot;)
    File.expects(:stat).returns(@stat)
    routes.expects(:load).with(&quot;foobarbaz&quot;)

    routes.reload
  end

  def test_load_multiple_configurations
    routes.add_configuration_file(&quot;engines.rb&quot;)

    File.expects(:stat).at_least_once.returns(@stat)

    routes.expects(:load).with('./config/routes.rb')
    routes.expects(:load).with('engines.rb')

    routes.reload
  end

  private
    def routes
      ActionController::Routing::Routes
    end
end
</pre>
    </div>