  <div id="fileHeader">
    <h1>http_digest_authentication_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/test/controller/http_digest_authentication_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'abstract_unit'

class HttpDigestAuthenticationTest &lt; ActionController::TestCase
  class DummyDigestController &lt; ActionController::Base
    before_filter :authenticate, :only =&gt; :index
    before_filter :authenticate_with_request, :only =&gt; :display

    USERS = { 'lifo' =&gt; 'world', 'pretty' =&gt; 'please',
              'dhh' =&gt; ::Digest::MD5::hexdigest([&quot;dhh&quot;,&quot;SuperSecret&quot;,&quot;secret&quot;].join(&quot;:&quot;))}

    def index
      render :text =&gt; &quot;Hello Secret&quot;
    end

    def display
      render :text =&gt; 'Definitely Maybe'
    end

    private

    def authenticate
      authenticate_or_request_with_http_digest(&quot;SuperSecret&quot;) do |username|
        # Return the password
        USERS[username]
      end
    end

    def authenticate_with_request
      if authenticate_with_http_digest(&quot;SuperSecret&quot;)  { |username| USERS[username] }
        @logged_in = true
      else
        request_http_digest_authentication(&quot;SuperSecret&quot;, &quot;Authentication Failed&quot;)
      end
    end
  end

  AUTH_HEADERS = ['HTTP_AUTHORIZATION', 'X-HTTP_AUTHORIZATION', 'X_HTTP_AUTHORIZATION', 'REDIRECT_X_HTTP_AUTHORIZATION']

  tests DummyDigestController

  AUTH_HEADERS.each do |header|
    test &quot;successful authentication with #{header.downcase}&quot; do
      @request.env[header] = encode_credentials(:username =&gt; 'lifo', :password =&gt; 'world')
      get :index

      assert_response :success
      assert_equal 'Hello Secret', @response.body, &quot;Authentication failed for request header #{header}&quot;
    end
  end

  AUTH_HEADERS.each do |header|
    test &quot;unsuccessful authentication with #{header.downcase}&quot; do
      @request.env[header] = encode_credentials(:username =&gt; 'h4x0r', :password =&gt; 'world')
      get :index

      assert_response :unauthorized
      assert_equal &quot;HTTP Digest: Access denied.\n&quot;, @response.body, &quot;Authentication didn't fail for request header #{header}&quot;
    end
  end

  test &quot;authentication request without credential&quot; do
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
    credentials = decode_credentials(@response.headers['WWW-Authenticate'])
    assert_equal 'SuperSecret', credentials[:realm]
  end

  test &quot;authentication request with nil credentials&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; nil, :password =&gt; nil)
    get :index

    assert_response :unauthorized
    assert_equal &quot;HTTP Digest: Access denied.\n&quot;, @response.body, &quot;Authentication didn't fail for request&quot;
    assert_not_equal 'Hello Secret', @response.body, &quot;Authentication didn't fail for request&quot;
  end

  test &quot;authentication request with invalid password&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'foo')
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
  end

  test &quot;authentication request with invalid nonce&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'please', :nonce =&gt; &quot;xxyyzz&quot;)
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
  end

  test &quot;authentication request with missing nonce should return 401&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'please', :remove_nonce =&gt; true)
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
  end

  test &quot;authentication request with Basic auth credentials should return 401&quot; do
    ActionController::Base.session_options[:secret] = &quot;session_options_secret&quot;
    @request.env['HTTP_AUTHORIZATION'] = ActionController::HttpAuthentication::Basic.encode_credentials('pretty', 'please')
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
  end

  test &quot;authentication request with invalid opaque&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'foo', :opaque =&gt; &quot;xxyyzz&quot;)
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
  end

  test &quot;authentication request with invalid realm&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'foo', :realm =&gt; &quot;NotSecret&quot;)
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
  end

  test &quot;authentication request with valid credential&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'please')
    get :display

    assert_response :success
    assert assigns(:logged_in)
    assert_equal 'Definitely Maybe', @response.body
  end

  test &quot;authentication request with valid credential and nil session&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'please')

    # session_id = &quot;&quot; in functional test, but is +nil+ in real life
    @request.session.session_id = nil
    get :display

    assert_response :success
    assert assigns(:logged_in)
    assert_equal 'Definitely Maybe', @response.body
  end

  test &quot;authentication request with request-uri that doesn't match credentials digest-uri&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'please')
    @request.env['REQUEST_URI'] = &quot;/http_digest_authentication_test/dummy_digest/altered/uri&quot;
    get :display

    assert_response :unauthorized
    assert_equal &quot;Authentication Failed&quot;, @response.body
  end

  test &quot;authentication request with absolute request uri (as in webrick)&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'please')
    @request.env['REQUEST_URI'] = &quot;http://test.host/http_digest_authentication_test/dummy_digest&quot;

    get :display

    assert_response :success
    assert assigns(:logged_in)
    assert_equal 'Definitely Maybe', @response.body
  end

  test &quot;authentication request with absolute uri in credentials (as in IE)&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:url =&gt; &quot;http://test.host/http_digest_authentication_test/dummy_digest&quot;,
                                                            :username =&gt; 'pretty', :password =&gt; 'please')

    get :display

    assert_response :success
    assert assigns(:logged_in)
    assert_equal 'Definitely Maybe', @response.body
  end

  test &quot;authentication request with absolute uri in both request and credentials (as in Webrick with IE)&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:url =&gt; &quot;http://test.host/http_digest_authentication_test/dummy_digest&quot;,
                                                            :username =&gt; 'pretty', :password =&gt; 'please')
    @request.env['REQUEST_URI'] = &quot;http://test.host/http_digest_authentication_test/dummy_digest&quot;

    get :display

    assert_response :success
    assert assigns(:logged_in)
    assert_equal 'Definitely Maybe', @response.body
  end

  test &quot;authentication request with password stored as ha1 digest hash&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'dhh',
                                           :password =&gt; ::Digest::MD5::hexdigest([&quot;dhh&quot;,&quot;SuperSecret&quot;,&quot;secret&quot;].join(&quot;:&quot;)),
                                           :password_is_ha1 =&gt; true)
    get :display

    assert_response :success
    assert assigns(:logged_in)
    assert_equal 'Definitely Maybe', @response.body
  end

  test &quot;authentication request with _method&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; 'pretty', :password =&gt; 'please', :method =&gt; :post)
    @request.env['rack.methodoverride.original_method'] = 'POST'
    put :display

    assert_response :success
    assert assigns(:logged_in)
    assert_equal 'Definitely Maybe', @response.body
  end

  test &quot;validate_digest_response should fail with nil returning password_procedure&quot; do
    @request.env['HTTP_AUTHORIZATION'] = encode_credentials(:username =&gt; nil, :password =&gt; nil)
    assert !ActionController::HttpAuthentication::Digest.validate_digest_response(@request, &quot;SuperSecret&quot;){nil}
  end

  private

  def encode_credentials(options)
    options.reverse_merge!(:nc =&gt; &quot;00000001&quot;, :cnonce =&gt; &quot;0a4f113b&quot;, :password_is_ha1 =&gt; false)
    password = options.delete(:password)

    # Set in /initializers/session_store.rb. Used as secret in generating nonce
    # to prevent tampering of timestamp
    ActionController::Base.session_options[:secret] = &quot;session_options_secret&quot;

    # Perform unauthenticated request to retrieve digest parameters to use on subsequent request
    method = options.delete(:method) || 'GET'

    case method.to_s.upcase
    when 'GET'
      get :index
    when 'POST'
      post :index
    end

    assert_response :unauthorized

    remove_nonce = options.delete(:remove_nonce)

    credentials = decode_credentials(@response.headers['WWW-Authenticate'])
    credentials.merge!(options)
    credentials.merge!(:uri =&gt; @request.env['REQUEST_URI'].to_s)

    credentials.delete(:nonce) if remove_nonce

    ActionController::HttpAuthentication::Digest.encode_credentials(method, credentials, password, options[:password_is_ha1])
  end

  def decode_credentials(header)
    ActionController::HttpAuthentication::Digest.decode_credentials(@response.headers['WWW-Authenticate'])
  end
end
</pre>
    </div>