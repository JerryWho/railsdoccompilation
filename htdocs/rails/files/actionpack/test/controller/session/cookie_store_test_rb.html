  <div id="fileHeader">
    <h1>cookie_store_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/test/controller/session/cookie_store_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'abstract_unit'
require 'stringio'

class CookieStoreTest &lt; ActionController::IntegrationTest
  SessionKey = '_myapp_session'
  SessionSecret = 'b3c631c314c0bbca50c1b2843150fe33'

  DispatcherApp = ActionController::Dispatcher.new
  CookieStoreApp = ActionController::Session::CookieStore.new(DispatcherApp, :key =&gt; SessionKey, :secret =&gt; SessionSecret)

  Verifier = ActiveSupport::MessageVerifier.new(SessionSecret, 'SHA1')

  SignedBar = &quot;BAh7BjoIZm9vIghiYXI%3D--fef868465920f415f2c0652d6910d3af288a0367&quot;

  class TestController &lt; ActionController::Base
    def no_session_access
      head :ok
    end

    def persistent_session_id
      render :text =&gt; session[:session_id]
    end

    def set_session_value
      session[:foo] = &quot;bar&quot;
      render :text =&gt; Rack::Utils.escape(Verifier.generate(session.to_hash))
    end

    def get_session_value
      render :text =&gt; &quot;foo: #{session[:foo].inspect}&quot;
    end

    def get_session_id
      render :text =&gt; &quot;foo: #{session[:foo].inspect}; id: #{request.session_options[:id]}&quot;
    end

    def call_reset_session
      reset_session
      head :ok
    end

    def raise_data_overflow
      session[:foo] = 'bye!' * 1024
      head :ok
    end

    def rescue_action(e) raise end
  end

  def setup
    @integration_session = open_session(CookieStoreApp)
  end

  def test_raises_argument_error_if_missing_session_key
    assert_raise(ArgumentError, nil.inspect) {
      ActionController::Session::CookieStore.new(nil,
        :key =&gt; nil, :secret =&gt; SessionSecret)
    }

    assert_raise(ArgumentError, ''.inspect) {
      ActionController::Session::CookieStore.new(nil,
        :key =&gt; '', :secret =&gt; SessionSecret)
    }
  end

  def test_raises_argument_error_if_missing_secret
    assert_raise(ArgumentError, nil.inspect) {
      ActionController::Session::CookieStore.new(nil,
       :key =&gt; SessionKey, :secret =&gt; nil)
    }

    assert_raise(ArgumentError, ''.inspect) {
      ActionController::Session::CookieStore.new(nil,
       :key =&gt; SessionKey, :secret =&gt; '')
    }
  end

  def test_raises_argument_error_if_secret_is_probably_insecure
    assert_raise(ArgumentError, &quot;password&quot;.inspect) {
      ActionController::Session::CookieStore.new(nil,
       :key =&gt; SessionKey, :secret =&gt; &quot;password&quot;)
    }

    assert_raise(ArgumentError, &quot;secret&quot;.inspect) {
      ActionController::Session::CookieStore.new(nil,
       :key =&gt; SessionKey, :secret =&gt; &quot;secret&quot;)
    }

    assert_raise(ArgumentError, &quot;12345678901234567890123456789&quot;.inspect) {
      ActionController::Session::CookieStore.new(nil,
       :key =&gt; SessionKey, :secret =&gt; &quot;12345678901234567890123456789&quot;)
    }
  end

  def test_setting_session_value
    with_test_route_set do
      get '/set_session_value'
      assert_response :success
      assert_equal &quot;_myapp_session=#{response.body}; path=/; HttpOnly&quot;,
        headers['Set-Cookie']
   end
  end

  def test_getting_session_value
    with_test_route_set do
      cookies[SessionKey] = SignedBar
      get '/get_session_value'
      assert_response :success
      assert_equal 'foo: &quot;bar&quot;', response.body
   end
  end

  def test_getting_session_id
    with_test_route_set do
      cookies[SessionKey] = SignedBar
      get '/persistent_session_id'
      assert_response :success
      assert_equal response.body.size, 32
      session_id = response.body

      get '/get_session_id'
      assert_response :success
      assert_equal &quot;foo: \&quot;bar\&quot;; id: #{session_id}&quot;, response.body
    end
  end

  def test_disregards_tampered_sessions
    with_test_route_set do
      cookies[SessionKey] = &quot;BAh7BjoIZm9vIghiYXI%3D--123456780&quot;
      get '/get_session_value'
      assert_response :success
      assert_equal 'foo: nil', response.body
    end
  end

  def test_close_raises_when_data_overflows
    with_test_route_set do
      assert_raise(ActionController::Session::CookieStore::CookieOverflow) {
        get '/raise_data_overflow'
      }
    end
  end

  def test_doesnt_write_session_cookie_if_session_is_not_accessed
    with_test_route_set do
      get '/no_session_access'
      assert_response :success
      assert_equal nil, headers['Set-Cookie']
    end
  end

  def test_doesnt_write_session_cookie_if_session_is_unchanged
    with_test_route_set do
      cookies[SessionKey] = &quot;BAh7BjoIZm9vIghiYXI%3D--&quot; +
        &quot;fef868465920f415f2c0652d6910d3af288a0367&quot;
      get '/no_session_access'
      assert_response :success
      assert_equal nil, headers['Set-Cookie']
    end
  end

  def test_setting_session_value_after_session_reset
    with_test_route_set do
      get '/set_session_value'
      assert_response :success
      session_payload = response.body
      assert_equal &quot;_myapp_session=#{response.body}; path=/; HttpOnly&quot;,
        headers['Set-Cookie']

      get '/call_reset_session'
      assert_response :success
      assert_not_equal [], headers['Set-Cookie']
      assert_not_equal session_payload, cookies[SessionKey]

      get '/get_session_value'
      assert_response :success
      assert_equal 'foo: nil', response.body
    end
  end

  def test_persistent_session_id
    with_test_route_set do
      cookies[SessionKey] = SignedBar
      get '/persistent_session_id'
      assert_response :success
      assert_equal response.body.size, 32
      session_id = response.body
      get '/persistent_session_id'
      assert_equal session_id, response.body
      reset!
      get '/persistent_session_id'
      assert_not_equal session_id, response.body
    end
  end

  private
    def with_test_route_set
      with_routing do |set|
        set.draw do |map|
          map.with_options :controller =&gt; &quot;cookie_store_test/test&quot; do |c|
            c.connect &quot;/:action&quot;
          end
        end
        yield
      end
    end

    def unmarshal_session(cookie_string)
      session = Rack::Utils.parse_query(cookie_string, ';,').inject({}) {|h,(k,v)|
        h[k] = Array === v ? v.first : v
        h
      }[SessionKey]
      verifier = ActiveSupport::MessageVerifier.new(SessionSecret, 'SHA1')
      verifier.verify(session)
    end
end
</pre>
    </div>