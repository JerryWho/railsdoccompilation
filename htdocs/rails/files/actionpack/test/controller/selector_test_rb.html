  <div id="fileHeader">
    <h1>selector_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/test/controller/selector_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#--
# Copyright (c) 2006 Assaf Arkin (http://labnotes.org)
# Under MIT and/or CC By license.
#++

require 'abstract_unit'
require 'controller/fake_controllers'

class SelectorTest &lt; Test::Unit::TestCase
  #
  # Basic selector: element, id, class, attributes.
  #

  def test_element
    parse(%Q{&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;})
    # Match element by name.
    select(&quot;div&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[1].attributes[&quot;id&quot;]
    # Not case sensitive.
    select(&quot;DIV&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[1].attributes[&quot;id&quot;]
    # Universal match (all elements).
    select(&quot;*&quot;)
    assert_equal 3, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal nil, @matches[1].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[2].attributes[&quot;id&quot;]
  end


  def test_identifier
    parse(%Q{&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;})
    # Match element by ID.
    select(&quot;div#1&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match element by ID, substitute value.
    select(&quot;div#?&quot;, 2)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Element name does not match ID.
    select(&quot;p#?&quot;, 2)
    assert_equal 0, @matches.size
    # Use regular expression.
    select(&quot;#?&quot;, /\d/)
    assert_equal 2, @matches.size
  end


  def test_class_name
    parse(%Q{&lt;div id=&quot;1&quot; class=&quot; foo &quot;&gt;&lt;/div&gt;&lt;p id=&quot;2&quot; class=&quot; foo bar &quot;&gt;&lt;/p&gt;&lt;div id=&quot;3&quot; class=&quot;bar&quot;&gt;&lt;/div&gt;})
    # Match element with specified class.
    select(&quot;div.foo&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match any element with specified class.
    select(&quot;*.foo&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[1].attributes[&quot;id&quot;]
    # Match elements with other class.
    select(&quot;*.bar&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    # Match only element with both class names.
    select(&quot;*.bar.foo&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  def test_attribute
    parse(%Q{&lt;div id=&quot;1&quot;&gt;&lt;/div&gt;&lt;p id=&quot;2&quot; title=&quot;&quot; bar=&quot;foo&quot;&gt;&lt;/p&gt;&lt;div id=&quot;3&quot; title=&quot;foo&quot;&gt;&lt;/div&gt;})
    # Match element with attribute.
    select(&quot;div[title]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match any element with attribute.
    select(&quot;*[title]&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    # Match element with attribute value.
    select(&quot;*[title=foo]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match element with attribute and attribute value.
    select(&quot;[bar=foo][title]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Not case sensitive.
    select(&quot;[BAR=foo][TiTle]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  def test_attribute_quoted
    parse(%Q{&lt;div id=&quot;1&quot; title=&quot;foo&quot;&gt;&lt;/div&gt;&lt;div id=&quot;2&quot; title=&quot;bar&quot;&gt;&lt;/div&gt;&lt;div id=&quot;3&quot; title=&quot;  bar  &quot;&gt;&lt;/div&gt;})
    # Match without quotes.
    select(&quot;[title = bar]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match with single quotes.
    select(&quot;[title = 'bar' ]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match with double quotes.
    select(&quot;[title = \&quot;bar\&quot; ]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match with spaces.
    select(&quot;[title = \&quot;  bar  \&quot; ]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  def test_attribute_equality
    parse(%Q{&lt;div id=&quot;1&quot; title=&quot;foo bar&quot;&gt;&lt;/div&gt;&lt;div id=&quot;2&quot; title=&quot;barbaz&quot;&gt;&lt;/div&gt;})
    # Match (fail) complete value.
    select(&quot;[title=bar]&quot;)
    assert_equal 0, @matches.size
    # Match space-separate word.
    select(&quot;[title~=foo]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;[title~=bar]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match beginning of value.
    select(&quot;[title^=ba]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match end of value.
    select(&quot;[title$=ar]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    # Match text in value.
    select(&quot;[title*=bar]&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[1].attributes[&quot;id&quot;]
    # Match first space separated word.
    select(&quot;[title|=foo]&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;[title|=bar]&quot;)
    assert_equal 0, @matches.size
  end


  #
  # Selector composition: groups, sibling, children
  #


  def test_selector_group
    parse(%Q{&lt;h1 id=&quot;1&quot;&gt;&lt;/h1&gt;&lt;h2 id=&quot;2&quot;&gt;&lt;/h2&gt;&lt;h3 id=&quot;3&quot;&gt;&lt;/h3&gt;})
    # Simple group selector.
    select(&quot;h1,h3&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    select(&quot;h1 , h3&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    # Complex group selector.
    parse(%Q{&lt;h1 id=&quot;1&quot;&gt;&lt;a href=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;2&quot;&gt;&lt;a href=&quot;bar&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;2&quot;&gt;&lt;a href=&quot;baz&quot;&gt;&lt;/a&gt;&lt;/h3&gt;})
    select(&quot;h1 a, h3 a&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;foo&quot;, @matches[0].attributes[&quot;href&quot;]
    assert_equal &quot;baz&quot;, @matches[1].attributes[&quot;href&quot;]
    # And now for the three selector challenge.
    parse(%Q{&lt;h1 id=&quot;1&quot;&gt;&lt;a href=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;2&quot;&gt;&lt;a href=&quot;bar&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;2&quot;&gt;&lt;a href=&quot;baz&quot;&gt;&lt;/a&gt;&lt;/h3&gt;})
    select(&quot;h1 a, h2 a, h3 a&quot;)
    assert_equal 3, @matches.size
    assert_equal &quot;foo&quot;, @matches[0].attributes[&quot;href&quot;]
    assert_equal &quot;bar&quot;, @matches[1].attributes[&quot;href&quot;]
    assert_equal &quot;baz&quot;, @matches[2].attributes[&quot;href&quot;]
  end


  def test_sibling_selector
    parse(%Q{&lt;h1 id=&quot;1&quot;&gt;&lt;/h1&gt;&lt;h2 id=&quot;2&quot;&gt;&lt;/h2&gt;&lt;h3 id=&quot;3&quot;&gt;&lt;/h3&gt;})
    # Test next sibling.
    select(&quot;h1+*&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;h1+h2&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;h1+h3&quot;)
    assert_equal 0, @matches.size
    select(&quot;*+h3&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    # Test any sibling.
    select(&quot;h1~*&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    select(&quot;h2~*&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  def test_children_selector
    parse(%Q{&lt;div&gt;&lt;p id=&quot;1&quot;&gt;&lt;span id=&quot;2&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p id=&quot;3&quot;&gt;&lt;span id=&quot;4&quot; class=&quot;foo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;})
    # Test child selector.
    select(&quot;div&gt;p&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    select(&quot;div&gt;span&quot;)
    assert_equal 0, @matches.size
    select(&quot;div&gt;p#3&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;div&gt;p&gt;span&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
    # Test descendant selector.
    select(&quot;div p&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    select(&quot;div span&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
    select(&quot;div *#3&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;div *#4&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;4&quot;, @matches[0].attributes[&quot;id&quot;]
    # This is here because it failed before when whitespaces
    # were not properly stripped.
    select(&quot;div .foo&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;4&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  #
  # Pseudo selectors: root, nth-child, empty, content, etc
  #


  def test_root_selector
    parse(%Q{&lt;div id=&quot;1&quot;&gt;&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;&lt;/div&gt;})
    # Can only find element if it's root.
    select(&quot;:root&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;#1:root&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;#2:root&quot;)
    assert_equal 0, @matches.size
    # Opposite for nth-child.
    select(&quot;#1:nth-child(1)&quot;)
    assert_equal 0, @matches.size
  end


  def test_nth_child_odd_even
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # Test odd nth children.
    select(&quot;tr:nth-child(odd)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    # Test even nth children.
    select(&quot;tr:nth-child(even)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
  end


  def test_nth_child_a_is_zero
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # Test the third child.
    select(&quot;tr:nth-child(0n+3)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    # Same but an can be omitted when zero.
    select(&quot;tr:nth-child(3)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    # Second element (but not every second element).
    select(&quot;tr:nth-child(0n+2)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Before first and past last returns nothing.:
    assert_raise(ArgumentError) { select(&quot;tr:nth-child(-1)&quot;) }
    select(&quot;tr:nth-child(0)&quot;)
    assert_equal 0, @matches.size
    select(&quot;tr:nth-child(5)&quot;)
    assert_equal 0, @matches.size
  end


  def test_nth_child_a_is_one
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # a is group of one, pick every element in group.
    select(&quot;tr:nth-child(1n+0)&quot;)
    assert_equal 4, @matches.size
    # Same but a can be omitted when one.
    select(&quot;tr:nth-child(n+0)&quot;)
    assert_equal 4, @matches.size
    # Same but b can be omitted when zero.
    select(&quot;tr:nth-child(n)&quot;)
    assert_equal 4, @matches.size
  end


  def test_nth_child_b_is_zero
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # If b is zero, pick the n-th element (here each one).
    select(&quot;tr:nth-child(n+0)&quot;)
    assert_equal 4, @matches.size
    # If b is zero, pick the n-th element (here every second).
    select(&quot;tr:nth-child(2n+0)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    # If a and b are both zero, no element selected.
    select(&quot;tr:nth-child(0n+0)&quot;)
    assert_equal 0, @matches.size
    select(&quot;tr:nth-child(0)&quot;)
    assert_equal 0, @matches.size
  end


  def test_nth_child_a_is_negative
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # Since a is -1, picks the first three elements.
    select(&quot;tr:nth-child(-n+3)&quot;)
    assert_equal 3, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[1].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[2].attributes[&quot;id&quot;]
    # Since a is -2, picks the first in every second of first four elements.
    select(&quot;tr:nth-child(-2n+3)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    # Since a is -2, picks the first in every second of first three elements.
    select(&quot;tr:nth-child(-2n+2)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  def test_nth_child_b_is_negative
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # Select last of four.
    select(&quot;tr:nth-child(4n-1)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;4&quot;, @matches[0].attributes[&quot;id&quot;]
    # Select first of four.
    select(&quot;tr:nth-child(4n-4)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    # Select last of every second.
    select(&quot;tr:nth-child(2n-1)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
    # Select nothing since an+b always &lt; 0
    select(&quot;tr:nth-child(-1n-1)&quot;)
    assert_equal 0, @matches.size
  end


  def test_nth_child_substitution_values
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # Test with ?n?.
    select(&quot;tr:nth-child(?n?)&quot;, 2, 1)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;3&quot;, @matches[1].attributes[&quot;id&quot;]
    select(&quot;tr:nth-child(?n?)&quot;, 2, 2)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
    select(&quot;tr:nth-child(?n?)&quot;, 4, 2)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    # Test with ? (b only).
    select(&quot;tr:nth-child(?)&quot;, 3)
    assert_equal 1, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;tr:nth-child(?)&quot;, 5)
    assert_equal 0, @matches.size
  end


  def test_nth_last_child
    parse(%Q{&lt;table&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # Last two elements.
    select(&quot;tr:nth-last-child(-n+2)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;3&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
    # All old elements counting from last one.
    select(&quot;tr:nth-last-child(odd)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
  end


  def test_nth_of_type
    parse(%Q{&lt;table&gt;&lt;thead&gt;&lt;/thead&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # First two elements.
    select(&quot;tr:nth-of-type(-n+2)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[1].attributes[&quot;id&quot;]
    # All old elements counting from last one.
    select(&quot;tr:nth-last-of-type(odd)&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;4&quot;, @matches[1].attributes[&quot;id&quot;]
  end

  
  def test_first_and_last
    parse(%Q{&lt;table&gt;&lt;thead&gt;&lt;/thead&gt;&lt;tr id=&quot;1&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;2&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;3&quot;&gt;&lt;/tr&gt;&lt;tr id=&quot;4&quot;&gt;&lt;/tr&gt;&lt;/table&gt;})
    # First child.
    select(&quot;tr:first-child&quot;)
    assert_equal 0, @matches.size
    select(&quot;:first-child&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;thead&quot;, @matches[0].name
    # First of type.
    select(&quot;tr:first-of-type&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;thead:first-of-type&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;thead&quot;, @matches[0].name
    select(&quot;div:first-of-type&quot;)
    assert_equal 0, @matches.size
    # Last child.
    select(&quot;tr:last-child&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;4&quot;, @matches[0].attributes[&quot;id&quot;]
    # Last of type.
    select(&quot;tr:last-of-type&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;4&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;thead:last-of-type&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;thead&quot;, @matches[0].name
    select(&quot;div:last-of-type&quot;)
    assert_equal 0, @matches.size
  end


  def test_first_and_last
    # Only child.
    parse(%Q{&lt;table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/table&gt;})
    select(&quot;table:only-child&quot;)
    assert_equal 0, @matches.size
    select(&quot;tr:only-child&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;tr&quot;, @matches[0].name
    parse(%Q{&lt;table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/table&gt;})
    select(&quot;tr:only-child&quot;)
    assert_equal 0, @matches.size
    # Only of type.
    parse(%Q{&lt;table&gt;&lt;thead&gt;&lt;/thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/table&gt;})
    select(&quot;thead:only-of-type&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;thead&quot;, @matches[0].name
    select(&quot;td:only-of-type&quot;)
    assert_equal 0, @matches.size
  end


  def test_empty
    parse(%Q{&lt;table&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/table&gt;})
    select(&quot;table:empty&quot;)
    assert_equal 0, @matches.size
    select(&quot;tr:empty&quot;)
    assert_equal 1, @matches.size
    parse(%Q{&lt;div&gt; &lt;/div&gt;})
    select(&quot;div:empty&quot;)
    assert_equal 1, @matches.size
  end

  
  def test_content
    parse(%Q{&lt;div&gt; &lt;/div&gt;})
    select(&quot;div:content()&quot;)
    assert_equal 1, @matches.size
    parse(%Q{&lt;div&gt;something &lt;/div&gt;})
    select(&quot;div:content()&quot;)
    assert_equal 0, @matches.size
    select(&quot;div:content(something)&quot;)
    assert_equal 1, @matches.size
    select(&quot;div:content( 'something' )&quot;)
    assert_equal 1, @matches.size
    select(&quot;div:content( \&quot;something\&quot; )&quot;)
    assert_equal 1, @matches.size
    select(&quot;div:content(?)&quot;, &quot;something&quot;)
    assert_equal 1, @matches.size
    select(&quot;div:content(?)&quot;, /something/)
    assert_equal 1, @matches.size
  end


  #
  # Test negation.
  #


  def test_element_negation
    parse(%Q{&lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;/div&gt;})
    select(&quot;*&quot;)
    assert_equal 2, @matches.size
    select(&quot;*:not(p)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;div&quot;, @matches[0].name
    select(&quot;*:not(div)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;p&quot;, @matches[0].name
    select(&quot;*:not(span)&quot;)
    assert_equal 2, @matches.size
  end


  def test_id_negation
    parse(%Q{&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;})
    select(&quot;p&quot;)
    assert_equal 2, @matches.size
    select(&quot;:not(#1)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;:not(#2)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  def test_class_name_negation
    parse(%Q{&lt;p class=&quot;foo&quot;&gt;&lt;/p&gt;&lt;p class=&quot;bar&quot;&gt;&lt;/p&gt;})
    select(&quot;p&quot;)
    assert_equal 2, @matches.size
    select(&quot;:not(.foo)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;bar&quot;, @matches[0].attributes[&quot;class&quot;]
    select(&quot;:not(.bar)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;foo&quot;, @matches[0].attributes[&quot;class&quot;]
  end


  def test_attribute_negation
    parse(%Q{&lt;p title=&quot;foo&quot;&gt;&lt;/p&gt;&lt;p title=&quot;bar&quot;&gt;&lt;/p&gt;})
    select(&quot;p&quot;)
    assert_equal 2, @matches.size
    select(&quot;:not([title=foo])&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;bar&quot;, @matches[0].attributes[&quot;title&quot;]
    select(&quot;:not([title=bar])&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;foo&quot;, @matches[0].attributes[&quot;title&quot;]
  end

  
  def test_pseudo_class_negation
    parse(%Q{&lt;div&gt;&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;&lt;/div&gt;})
    select(&quot;p&quot;)
    assert_equal 2, @matches.size
    select(&quot;p:not(:first-child)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
    select(&quot;p:not(:nth-child(2))&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
  end
  

  def test_negation_details
    parse(%Q{&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;&lt;p id=&quot;3&quot;&gt;&lt;/p&gt;})
    assert_raise(ArgumentError) { select(&quot;:not(&quot;) }
    assert_raise(ArgumentError) { select(&quot;:not(:not())&quot;) }
    select(&quot;p:not(#1):not(#3)&quot;)
    assert_equal 1, @matches.size
    assert_equal &quot;2&quot;, @matches[0].attributes[&quot;id&quot;]
  end


  def test_select_from_element
    parse(%Q{&lt;div&gt;&lt;p id=&quot;1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;2&quot;&gt;&lt;/p&gt;&lt;/div&gt;})
    select(&quot;div&quot;)
    @matches = @matches[0].select(&quot;p&quot;)
    assert_equal 2, @matches.size
    assert_equal &quot;1&quot;, @matches[0].attributes[&quot;id&quot;]
    assert_equal &quot;2&quot;, @matches[1].attributes[&quot;id&quot;]
  end


protected

  def parse(html)
    @html = HTML::Document.new(html).root
  end

  def select(*selector)
    @matches = HTML.selector(*selector).select(@html)
  end

end
</pre>
    </div>