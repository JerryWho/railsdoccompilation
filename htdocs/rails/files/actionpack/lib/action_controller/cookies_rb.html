  <div id="fileHeader">
    <h1>cookies.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/lib/action_controller/cookies.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:52 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActionController #:nodoc:
  # Cookies are read and written through ActionController#cookies.
  #
  # The cookies being read are the ones received along with the request, the cookies
  # being written will be sent out with the response. Reading a cookie does not get
  # the cookie object itself back, just the value it holds.
  #
  # Examples for writing:
  #
  #   # Sets a simple session cookie.
  #   cookies[:user_name] = &quot;david&quot;
  #
  #   # Sets a cookie that expires in 1 hour.
  #   cookies[:login] = { :value =&gt; &quot;XJ-122&quot;, :expires =&gt; 1.hour.from_now }
  #
  # Examples for reading:
  #
  #   cookies[:user_name] # =&gt; &quot;david&quot;
  #   cookies.size        # =&gt; 2
  #
  # Example for deleting:
  #
  #   cookies.delete :user_name
  #
  # Please note that if you specify a :domain when setting a cookie, you must also specify the domain when deleting the cookie:
  #
  #  cookies[:key] = {
  #    :value =&gt; 'a yummy cookie',
  #    :expires =&gt; 1.year.from_now,
  #    :domain =&gt; 'domain.com'
  #  }
  #
  #  cookies.delete(:key, :domain =&gt; 'domain.com')
  #
  # The option symbols for setting cookies are:
  #
  # * &lt;tt&gt;:value&lt;/tt&gt; - The cookie's value or list of values (as an array).
  # * &lt;tt&gt;:path&lt;/tt&gt; - The path for which this cookie applies.  Defaults to the root
  #   of the application.
  # * &lt;tt&gt;:domain&lt;/tt&gt; - The domain for which this cookie applies.
  # * &lt;tt&gt;:expires&lt;/tt&gt; - The time at which this cookie expires, as a Time object.
  # * &lt;tt&gt;:secure&lt;/tt&gt; - Whether this cookie is a only transmitted to HTTPS servers.
  #   Default is +false+.
  # * &lt;tt&gt;:httponly&lt;/tt&gt; - Whether this cookie is accessible via scripting or
  #   only HTTP. Defaults to +false+.
  module Cookies
    def self.included(base)
      base.helper_method :cookies
      base.cattr_accessor :cookie_verifier_secret
    end

    protected
      # Returns the cookie container, which operates as described above.
      def cookies
        @cookies ||= CookieJar.new(self)
      end
  end

  class CookieJar &lt; Hash #:nodoc:
    attr_reader :controller
    
    def initialize(controller)
      @controller, @cookies = controller, controller.request.cookies
      super()
      update(@cookies)
    end

    # Returns the value of the cookie by +name+, or +nil+ if no such cookie exists.
    def [](name)
      super(name.to_s)
    end

    # Sets the cookie named +name+. The second argument may be the very cookie
    # value, or a hash of options as documented above.
    def []=(key, options)
      if options.is_a?(Hash)
        options.symbolize_keys!
      else
        options = { :value =&gt; options }
      end

      options[:path] = &quot;/&quot; unless options.has_key?(:path)
      super(key.to_s, options[:value])
      @controller.response.set_cookie(key, options)
    end

    # Removes the cookie on the client machine by setting the value to an empty string
    # and setting its expiration date into the past. Like &lt;tt&gt;[]=&lt;/tt&gt;, you can pass in
    # an options hash to delete cookies with extra data such as a &lt;tt&gt;:path&lt;/tt&gt;.
    def delete(key, options = {})
      options.symbolize_keys!
      options[:path] = &quot;/&quot; unless options.has_key?(:path)
      value = super(key.to_s)
      @controller.response.delete_cookie(key, options)
      value
    end

    # Returns a jar that'll automatically set the assigned cookies to have an expiration date 20 years from now. Example:
    #
    #   cookies.permanent[:prefers_open_id] = true
    #   # =&gt; Set-Cookie: prefers_open_id=true; path=/; expires=Sun, 16-Dec-2029 03:24:16 GMT
    #
    # This jar is only meant for writing. You'll read permanent cookies through the regular accessor.
    #
    # This jar allows chaining with the signed jar as well, so you can set permanent, signed cookies. Examples:
    #
    #   cookies.permanent.signed[:remember_me] = current_user.id
    #   # =&gt; Set-Cookie: discount=BAhU--848956038e692d7046deab32b7131856ab20e14e; path=/; expires=Sun, 16-Dec-2029 03:24:16 GMT
    def permanent
      @permanent ||= PermanentCookieJar.new(self)
    end
    
    # Returns a jar that'll automatically generate a signed representation of cookie value and verify it when reading from
    # the cookie again. This is useful for creating cookies with values that the user is not supposed to change. If a signed
    # cookie was tampered with by the user (or a 3rd party), an ActiveSupport::MessageVerifier::InvalidSignature exception will
    # be raised.
    #
    # This jar requires that you set a suitable secret for the verification on ActionController::Base.cookie_verifier_secret.
    #
    # Example:
    #
    #   cookies.signed[:discount] = 45
    #   # =&gt; Set-Cookie: discount=BAhpMg==--2c1c6906c90a3bc4fd54a51ffb41dffa4bf6b5f7; path=/
    #
    #   cookies.signed[:discount] # =&gt; 45
    def signed
      @signed ||= SignedCookieJar.new(self)
    end
  end
  
  class PermanentCookieJar &lt; CookieJar #:nodoc:
    def initialize(parent_jar)
      @parent_jar = parent_jar
    end

    def []=(key, options)
      if options.is_a?(Hash)
        options.symbolize_keys!
      else
        options = { :value =&gt; options }
      end
      
      options[:expires] = 20.years.from_now
      @parent_jar[key] = options
    end

    def signed
      @signed ||= SignedCookieJar.new(self)
    end

    def controller
      @parent_jar.controller
    end

    def method_missing(method, *arguments, &amp;block)
      @parent_jar.send(method, *arguments, &amp;block)
    end
  end
  
  class SignedCookieJar &lt; CookieJar #:nodoc:
    def initialize(parent_jar)
      unless parent_jar.controller.class.cookie_verifier_secret
        raise &quot;You must set ActionController::Base.cookie_verifier_secret to use signed cookies&quot;
      end

      @parent_jar = parent_jar
      @verifier = ActiveSupport::MessageVerifier.new(@parent_jar.controller.class.cookie_verifier_secret)
    end
    
    def [](name)
      if value = @parent_jar[name]
        @verifier.verify(value)
      end
    end
    
    def []=(key, options)
      if options.is_a?(Hash)
        options.symbolize_keys!
        options[:value] = @verifier.generate(options[:value])
      else
        options = { :value =&gt; @verifier.generate(options) }
      end
      
      @parent_jar[key] = options
    end
    
    def method_missing(method, *arguments, &amp;block)
      @parent_jar.send(method, *arguments, &amp;block)
    end
  end
end
</pre>
    </div>