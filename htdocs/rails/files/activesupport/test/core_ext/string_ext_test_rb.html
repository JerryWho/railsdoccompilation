  <div id="fileHeader">
    <h1>string_ext_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/test/core_ext/string_ext_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:54 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># encoding: utf-8
require 'date'
require 'abstract_unit'
require 'inflector_test_cases'

class StringInflectionsTest &lt; Test::Unit::TestCase
  include InflectorTestCases

  def test_pluralize
    SingularToPlural.each do |singular, plural|
      assert_equal(plural, singular.pluralize)
    end

    assert_equal(&quot;plurals&quot;, &quot;plurals&quot;.pluralize)
  end

  def test_singularize
    SingularToPlural.each do |singular, plural|
      assert_equal(singular, plural.singularize)
    end
  end

  def test_titleize
    MixtureToTitleCase.each do |before, titleized|
      assert_equal(titleized, before.titleize)
    end
  end

  def test_camelize
    CamelToUnderscore.each do |camel, underscore|
      assert_equal(camel, underscore.camelize)
    end
  end

  def test_camelize_lower
    assert_equal('capital', 'Capital'.camelize(:lower))
  end

  def test_underscore
    CamelToUnderscore.each do |camel, underscore|
      assert_equal(underscore, camel.underscore)
    end

    assert_equal &quot;html_tidy&quot;, &quot;HTMLTidy&quot;.underscore
    assert_equal &quot;html_tidy_generator&quot;, &quot;HTMLTidyGenerator&quot;.underscore
  end

  def test_underscore_to_lower_camel
    UnderscoreToLowerCamel.each do |underscored, lower_camel|
      assert_equal(lower_camel, underscored.camelize(:lower))
    end
  end

  def test_demodulize
    assert_equal &quot;Account&quot;, &quot;MyApplication::Billing::Account&quot;.demodulize
  end

  def test_foreign_key
    ClassNameToForeignKeyWithUnderscore.each do |klass, foreign_key|
      assert_equal(foreign_key, klass.foreign_key)
    end

    ClassNameToForeignKeyWithoutUnderscore.each do |klass, foreign_key|
      assert_equal(foreign_key, klass.foreign_key(false))
    end
  end

  def test_tableize
    ClassNameToTableName.each do |class_name, table_name|
      assert_equal(table_name, class_name.tableize)
    end
  end

  def test_classify
    ClassNameToTableName.each do |class_name, table_name|
      assert_equal(class_name, table_name.classify)
    end
  end

  def test_string_parameterized_normal
    StringToParameterized.each do |normal, slugged|
      assert_equal(normal.parameterize, slugged)
    end
  end

  def test_string_parameterized_no_separator
    StringToParameterizeWithNoSeparator.each do |normal, slugged|
      assert_equal(normal.parameterize(''), slugged)
    end
  end

  def test_string_parameterized_underscore
    StringToParameterizeWithUnderscore.each do |normal, slugged|
      assert_equal(normal.parameterize('_'), slugged)
    end
  end

  def test_humanize
    UnderscoreToHuman.each do |underscore, human|
      assert_equal(human, underscore.humanize)
    end
  end

  def test_ord
    assert_equal 97, 'a'.ord
    assert_equal 97, 'abc'.ord
  end

  def test_string_to_time
    assert_equal Time.utc(2005, 2, 27, 23, 50), &quot;2005-02-27 23:50&quot;.to_time
    assert_equal Time.local(2005, 2, 27, 23, 50), &quot;2005-02-27 23:50&quot;.to_time(:local)
    assert_equal DateTime.civil(2039, 2, 27, 23, 50), &quot;2039-02-27 23:50&quot;.to_time
    assert_equal Time.local_time(2039, 2, 27, 23, 50), &quot;2039-02-27 23:50&quot;.to_time(:local)
  end
  
  def test_string_to_datetime
    assert_equal DateTime.civil(2039, 2, 27, 23, 50), &quot;2039-02-27 23:50&quot;.to_datetime
    assert_equal 0, &quot;2039-02-27 23:50&quot;.to_datetime.offset # use UTC offset
    assert_equal ::Date::ITALY, &quot;2039-02-27 23:50&quot;.to_datetime.start # use Ruby's default start value
  end
  
  def test_string_to_date
    assert_equal Date.new(2005, 2, 27), &quot;2005-02-27&quot;.to_date
  end

  def test_access
    s = &quot;hello&quot;
    assert_equal &quot;h&quot;, s.at(0)

    assert_equal &quot;llo&quot;, s.from(2)
    assert_equal &quot;hel&quot;, s.to(2)

    assert_equal &quot;h&quot;, s.first
    assert_equal &quot;he&quot;, s.first(2)
    assert_equal &quot;&quot;, s.first(0)

    assert_equal &quot;o&quot;, s.last
    assert_equal &quot;llo&quot;, s.last(3)
    assert_equal &quot;hello&quot;, s.last(10)
    assert_equal &quot;&quot;, s.last(0)

    assert_equal 'x', 'x'.first
    assert_equal 'x', 'x'.first(4)

    assert_equal 'x', 'x'.last
    assert_equal 'x', 'x'.last(4)
  end

  def test_access_returns_a_real_string
    hash = {}
    hash[&quot;h&quot;] = true
    hash[&quot;hello123&quot;.at(0)] = true
    assert_equal %w(h), hash.keys

    hash = {}
    hash[&quot;llo&quot;] = true
    hash[&quot;hello&quot;.from(2)] = true
    assert_equal %w(llo), hash.keys

    hash = {}
    hash[&quot;hel&quot;] = true
    hash[&quot;hello&quot;.to(2)] = true
    assert_equal %w(hel), hash.keys

    hash = {}
    hash[&quot;hello&quot;] = true
    hash[&quot;123hello&quot;.last(5)] = true
    assert_equal %w(hello), hash.keys

    hash = {}
    hash[&quot;hello&quot;] = true
    hash[&quot;hello123&quot;.first(5)] = true
    assert_equal %w(hello), hash.keys
  end

  def test_starts_ends_with_alias
    s = &quot;hello&quot;
    assert s.starts_with?('h')
    assert s.starts_with?('hel')
    assert !s.starts_with?(:hel)
    assert !s.starts_with?('el')

    assert s.start_with?('h')
    assert s.start_with?('hel')
    assert !s.start_with?('el')

    assert s.ends_with?('o')
    assert s.ends_with?('lo')
    assert !s.ends_with?(:lo)
    assert !s.ends_with?('el')

    assert s.end_with?('o')
    assert s.end_with?('lo')
    assert !s.end_with?('el')
  end

  def test_string_squish
    original = %{ A string with tabs(\t\t), newlines(\n\n), and
                  many spaces(  ). }

    expected = &quot;A string with tabs( ), newlines( ), and many spaces( ).&quot;

    # Make sure squish returns what we expect:
    assert_equal original.squish,  expected
    # But doesn't modify the original string:
    assert_not_equal original, expected

    # Make sure squish! returns what we expect:
    assert_equal original.squish!, expected
    # And changes the original string:
    assert_equal original, expected
  end

  if RUBY_VERSION &lt; '1.9'
    def test_each_char_with_utf8_string_when_kcode_is_utf8
      with_kcode('UTF8') do
        '€2.99'.each_char do |char|
          assert_not_equal 1, char.length
          break
        end
      end
    end
  end
end

class StringBehaviourTest &lt; Test::Unit::TestCase
  def test_acts_like_string
    assert 'Bambi'.acts_like_string?
  end
end

class CoreExtStringMultibyteTest &lt; ActiveSupport::TestCase
  UNICODE_STRING = 'こにちわ'
  ASCII_STRING = 'ohayo'
  BYTE_STRING = &quot;\270\236\010\210\245&quot;

  def test_core_ext_adds_mb_chars
    assert UNICODE_STRING.respond_to?(:mb_chars)
  end

  def test_string_should_recognize_utf8_strings
    assert UNICODE_STRING.is_utf8?
    assert ASCII_STRING.is_utf8?
    assert !BYTE_STRING.is_utf8?
  end

  if RUBY_VERSION &lt; '1.8.7'
    def test_core_ext_adds_chars
      assert UNICODE_STRING.respond_to?(:chars)
    end

    def test_chars_warns_about_deprecation
      assert_deprecated(&quot;String#chars&quot;) do
        ''.chars
      end
    end
  end

  if RUBY_VERSION &lt; '1.9'
    def test_mb_chars_returns_self_when_kcode_not_set
      with_kcode('none') do
        assert UNICODE_STRING.mb_chars.kind_of?(String)
      end
    end

    def test_mb_chars_returns_an_instance_of_the_chars_proxy_when_kcode_utf8
      with_kcode('UTF8') do
        assert UNICODE_STRING.mb_chars.kind_of?(ActiveSupport::Multibyte.proxy_class)
      end
    end
  end

  if RUBY_VERSION &gt;= '1.9'
    def test_mb_chars_returns_string
      assert UNICODE_STRING.mb_chars.kind_of?(String)
    end
  end
end

class StringBytesizeTest &lt; Test::Unit::TestCase
  def test_bytesize
    assert_respond_to 'foo', :bytesize
    assert_equal 3, 'foo'.bytesize
  end
end

class OutputSafetyTest &lt; ActiveSupport::TestCase
  def setup
    @string = &quot;hello&quot;
    @object = Class.new(Object) do
      def to_s
        &quot;other&quot;
      end
    end.new
  end

  test &quot;A string is unsafe by default&quot; do
    assert !@string.html_safe?
  end

  test &quot;Marking a string html_safe! doesn't work unless rails_xss is installed&quot; do
    assert_raise(NoMethodError) { @string.html_safe! }
  end

  test &quot;A string can be marked safe&quot; do
    string = @string.html_safe
    assert string.html_safe?
  end

  test &quot;Marking a string safe returns the string&quot; do
    assert_equal @string, @string.html_safe
  end

  test &quot;A fixnum is safe by default&quot; do
    assert 5.html_safe?
  end

  test &quot;An object is unsafe by default&quot; do
    assert !@object.html_safe?
  end

  test &quot;Adding an object to a safe string returns a safe string&quot; do
    string = @string.html_safe
    string &lt;&lt; @object

    assert_equal &quot;helloother&quot;, string
    assert string.html_safe?
  end

  test &quot;Adding a safe string to another safe string returns a safe string&quot; do
    @other_string = &quot;other&quot;.html_safe
    string = @string.html_safe
    @combination = @other_string + string

    assert_equal &quot;otherhello&quot;, @combination
    assert @combination.html_safe?
  end

  test &quot;Adding an unsafe string to a safe string escapes it and returns a safe string&quot; do
    @other_string = &quot;other&quot;.html_safe
    @combination = @other_string + &quot;&lt;foo&gt;&quot;
    @other_combination = @string + &quot;&lt;foo&gt;&quot;

    assert_equal &quot;other&amp;lt;foo&amp;gt;&quot;, @combination
    assert_equal &quot;hello&lt;foo&gt;&quot;, @other_combination

    assert @combination.html_safe?
    assert !@other_combination.html_safe?
  end

  test &quot;Concatting safe onto unsafe yields unsafe&quot; do
    @other_string = &quot;other&quot;
    string = @string.html_safe

    @other_string.concat(string)
    assert !@other_string.html_safe?
  end

  test &quot;Concatting unsafe onto safe yields escaped safe&quot; do
    @other_string = &quot;other&quot;.html_safe
    string = @other_string.concat(&quot;&lt;foo&gt;&quot;)
    assert_equal &quot;other&amp;lt;foo&amp;gt;&quot;, string
    assert string.html_safe?
  end

  test &quot;Concatting safe onto safe yields safe&quot; do
    @other_string = &quot;other&quot;.html_safe
    string = @string.html_safe

    @other_string.concat(string)
    assert @other_string.html_safe?
  end

  test &quot;Concatting safe onto unsafe with &lt;&lt; yields unsafe&quot; do
    @other_string = &quot;other&quot;
    string = @string.html_safe

    @other_string &lt;&lt; string
    assert !@other_string.html_safe?
  end

  test &quot;Concatting unsafe onto safe with &lt;&lt; yields escaped safe&quot; do
    @other_string = &quot;other&quot;.html_safe
    string = @other_string &lt;&lt; &quot;&lt;foo&gt;&quot;
    assert_equal &quot;other&amp;lt;foo&amp;gt;&quot;, string
    assert string.html_safe?
  end

  test &quot;Concatting safe onto safe with &lt;&lt; yields safe&quot; do
    @other_string = &quot;other&quot;.html_safe
    @string.html_safe

    @other_string &lt;&lt; @string
    assert @other_string.html_safe?
  end

  test &quot;Concatting a fixnum to safe always yields safe&quot; do
    string = @string.html_safe
    string = string.concat(13)
    assert_equal &quot;hello&quot;.concat(13), string
    assert string.html_safe?
  end

  test 'emits normal string yaml' do
    assert_equal 'foo'.to_yaml, 'foo'.html_safe.to_yaml(:foo =&gt; 1)
  end

  test 'yaml output using +' do
    assert_equal &quot;--- foobar\n&quot;, ('foo' + 'bar').to_yaml
  end

  test 'yaml output using &lt;&lt;' do
    assert_equal &quot;--- foobar\n&quot;, ('foo' &lt;&lt; 'bar').to_yaml
  end
end
</pre>
    </div>