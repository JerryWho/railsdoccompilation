  <div id="fileHeader">
    <h1>hash_ext_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/test/core_ext/hash_ext_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:54 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'abstract_unit'
require 'builder'

class HashExtTest &lt; Test::Unit::TestCase
  def setup
    @strings = { 'a' =&gt; 1, 'b' =&gt; 2 }
    @symbols = { :a  =&gt; 1, :b  =&gt; 2 }
    @mixed   = { :a  =&gt; 1, 'b' =&gt; 2 }
    @fixnums = {  0  =&gt; 1,  1  =&gt; 2 }
    if RUBY_VERSION &lt; '1.9.0'
      @illegal_symbols = { &quot;\0&quot; =&gt; 1, &quot;&quot; =&gt; 2, [] =&gt; 3 }
    else
      @illegal_symbols = { [] =&gt; 3 }
    end
  end

  def test_methods
    h = {}
    assert_respond_to h, :symbolize_keys
    assert_respond_to h, :symbolize_keys!
    assert_respond_to h, :stringify_keys
    assert_respond_to h, :stringify_keys!
    assert_respond_to h, :to_options
    assert_respond_to h, :to_options!
  end

  def test_symbolize_keys
    assert_equal @symbols, @symbols.symbolize_keys
    assert_equal @symbols, @strings.symbolize_keys
    assert_equal @symbols, @mixed.symbolize_keys
  end

  def test_symbolize_keys!
    assert_equal @symbols, @symbols.dup.symbolize_keys!
    assert_equal @symbols, @strings.dup.symbolize_keys!
    assert_equal @symbols, @mixed.dup.symbolize_keys!
  end

  def test_symbolize_keys_preserves_keys_that_cant_be_symbolized
    assert_equal @illegal_symbols, @illegal_symbols.symbolize_keys
    assert_equal @illegal_symbols, @illegal_symbols.dup.symbolize_keys!
  end

  def test_symbolize_keys_preserves_fixnum_keys
    assert_equal @fixnums, @fixnums.symbolize_keys
    assert_equal @fixnums, @fixnums.dup.symbolize_keys!
  end

  def test_stringify_keys
    assert_equal @strings, @symbols.stringify_keys
    assert_equal @strings, @strings.stringify_keys
    assert_equal @strings, @mixed.stringify_keys
  end

  def test_stringify_keys!
    assert_equal @strings, @symbols.dup.stringify_keys!
    assert_equal @strings, @strings.dup.stringify_keys!
    assert_equal @strings, @mixed.dup.stringify_keys!
  end

  def test_indifferent_assorted
    @strings = @strings.with_indifferent_access
    @symbols = @symbols.with_indifferent_access
    @mixed   = @mixed.with_indifferent_access

    assert_equal 'a', @strings.__send__(:convert_key, :a)

    assert_equal 1, @strings.fetch('a')
    assert_equal 1, @strings.fetch(:a.to_s)
    assert_equal 1, @strings.fetch(:a)

    hashes = { :@strings =&gt; @strings, :@symbols =&gt; @symbols, :@mixed =&gt; @mixed }
    method_map = { :'[]' =&gt; 1, :fetch =&gt; 1, :values_at =&gt; [1],
      :has_key? =&gt; true, :include? =&gt; true, :key? =&gt; true,
      :member? =&gt; true }

    hashes.each do |name, hash|
      method_map.sort_by { |m| m.to_s }.each do |meth, expected|
        assert_equal(expected, hash.__send__(meth, 'a'),
                     &quot;Calling #{name}.#{meth} 'a'&quot;)
        assert_equal(expected, hash.__send__(meth, :a),
                     &quot;Calling #{name}.#{meth} :a&quot;)
      end
    end

    assert_equal [1, 2], @strings.values_at('a', 'b')
    assert_equal [1, 2], @strings.values_at(:a, :b)
    assert_equal [1, 2], @symbols.values_at('a', 'b')
    assert_equal [1, 2], @symbols.values_at(:a, :b)
    assert_equal [1, 2], @mixed.values_at('a', 'b')
    assert_equal [1, 2], @mixed.values_at(:a, :b)
  end

  def test_indifferent_reading
    hash = HashWithIndifferentAccess.new
    hash[&quot;a&quot;] = 1
    hash[&quot;b&quot;] = true
    hash[&quot;c&quot;] = false
    hash[&quot;d&quot;] = nil

    assert_equal 1, hash[:a]
    assert_equal true, hash[:b]
    assert_equal false, hash[:c]
    assert_equal nil, hash[:d]
    assert_equal nil, hash[:e]
  end

  def test_indifferent_reading_with_nonnil_default
    hash = HashWithIndifferentAccess.new(1)
    hash[&quot;a&quot;] = 1
    hash[&quot;b&quot;] = true
    hash[&quot;c&quot;] = false
    hash[&quot;d&quot;] = nil

    assert_equal 1, hash[:a]
    assert_equal true, hash[:b]
    assert_equal false, hash[:c]
    assert_equal nil, hash[:d]
    assert_equal 1, hash[:e]
  end

  def test_indifferent_writing
    hash = HashWithIndifferentAccess.new
    hash[:a] = 1
    hash['b'] = 2
    hash[3] = 3

    assert_equal hash['a'], 1
    assert_equal hash['b'], 2
    assert_equal hash[:a], 1
    assert_equal hash[:b], 2
    assert_equal hash[3], 3
  end

  def test_indifferent_update
    hash = HashWithIndifferentAccess.new
    hash[:a] = 'a'
    hash['b'] = 'b'

    updated_with_strings = hash.update(@strings)
    updated_with_symbols = hash.update(@symbols)
    updated_with_mixed = hash.update(@mixed)

    assert_equal updated_with_strings[:a], 1
    assert_equal updated_with_strings['a'], 1
    assert_equal updated_with_strings['b'], 2

    assert_equal updated_with_symbols[:a], 1
    assert_equal updated_with_symbols['b'], 2
    assert_equal updated_with_symbols[:b], 2

    assert_equal updated_with_mixed[:a], 1
    assert_equal updated_with_mixed['b'], 2

    assert [updated_with_strings, updated_with_symbols, updated_with_mixed].all? { |h| h.keys.size == 2 }
  end

  def test_indifferent_merging
    hash = HashWithIndifferentAccess.new
    hash[:a] = 'failure'
    hash['b'] = 'failure'

    other = { 'a' =&gt; 1, :b =&gt; 2 }

    merged = hash.merge(other)

    assert_equal HashWithIndifferentAccess, merged.class
    assert_equal 1, merged[:a]
    assert_equal 2, merged['b']

    hash.update(other)

    assert_equal 1, hash[:a]
    assert_equal 2, hash['b']
  end

  def test_indifferent_reverse_merging
    hash = HashWithIndifferentAccess.new('some' =&gt; 'value', 'other' =&gt; 'value')
    hash.reverse_merge!(:some =&gt; 'noclobber', :another =&gt; 'clobber')
    assert_equal 'value', hash[:some]
    assert_equal 'clobber', hash[:another]
  end

  def test_indifferent_deleting
    get_hash = proc{ { :a =&gt; 'foo' }.with_indifferent_access }
    hash = get_hash.call
    assert_equal hash.delete(:a), 'foo'
    assert_equal hash.delete(:a), nil
    hash = get_hash.call
    assert_equal hash.delete('a'), 'foo'
    assert_equal hash.delete('a'), nil
  end

  def test_indifferent_to_hash
    # Should convert to a Hash with String keys.
    assert_equal @strings, @mixed.with_indifferent_access.to_hash

    # Should preserve the default value.
    mixed_with_default = @mixed.dup
    mixed_with_default.default = '1234'
    roundtrip = mixed_with_default.with_indifferent_access.to_hash
    assert_equal @strings, roundtrip
    assert_equal '1234', roundtrip.default
  end

  def test_indifferent_hash_with_array_of_hashes
    hash = { &quot;urls&quot; =&gt; { &quot;url&quot; =&gt; [ { &quot;address&quot; =&gt; &quot;1&quot; }, { &quot;address&quot; =&gt; &quot;2&quot; } ] }}.with_indifferent_access
    assert_equal &quot;1&quot;, hash[:urls][:url].first[:address]
  end

  def test_stringify_and_symbolize_keys_on_indifferent_preserves_hash
    h = HashWithIndifferentAccess.new
    h[:first] = 1
    h.stringify_keys!
    assert_equal 1, h['first']
    h = HashWithIndifferentAccess.new
    h['first'] = 1
    h.symbolize_keys!
    assert_equal 1, h[:first]
  end

  def test_to_options_on_indifferent_preserves_hash
    h = HashWithIndifferentAccess.new
    h['first'] = 1
    h.to_options!
    assert_equal 1, h['first']
  end


  def test_indifferent_subhashes
    h = {'user' =&gt; {'id' =&gt; 5}}.with_indifferent_access
    ['user', :user].each {|user| [:id, 'id'].each {|id| assert_equal 5, h[user][id], &quot;h[#{user.inspect}][#{id.inspect}] should be 5&quot;}}

    h = {:user =&gt; {:id =&gt; 5}}.with_indifferent_access
    ['user', :user].each {|user| [:id, 'id'].each {|id| assert_equal 5, h[user][id], &quot;h[#{user.inspect}][#{id.inspect}] should be 5&quot;}}
  end

  def test_assert_valid_keys
    assert_nothing_raised do
      { :failure =&gt; &quot;stuff&quot;, :funny =&gt; &quot;business&quot; }.assert_valid_keys([ :failure, :funny ])
      { :failure =&gt; &quot;stuff&quot;, :funny =&gt; &quot;business&quot; }.assert_valid_keys(:failure, :funny)
    end

    assert_raise(ArgumentError, &quot;Unknown key(s): failore&quot;) do
      { :failore =&gt; &quot;stuff&quot;, :funny =&gt; &quot;business&quot; }.assert_valid_keys([ :failure, :funny ])
      { :failore =&gt; &quot;stuff&quot;, :funny =&gt; &quot;business&quot; }.assert_valid_keys(:failure, :funny)
    end
  end

  def test_assorted_keys_not_stringified
    original = {Object.new =&gt; 2, 1 =&gt; 2, [] =&gt; true}
    indiff = original.with_indifferent_access
    assert(!indiff.keys.any? {|k| k.kind_of? String}, &quot;A key was converted to a string!&quot;)
  end

  def test_deep_merge
    hash_1 = { :a =&gt; &quot;a&quot;, :b =&gt; &quot;b&quot;, :c =&gt; { :c1 =&gt; &quot;c1&quot;, :c2 =&gt; &quot;c2&quot;, :c3 =&gt; { :d1 =&gt; &quot;d1&quot; } } }
    hash_2 = { :a =&gt; 1, :c =&gt; { :c1 =&gt; 2, :c3 =&gt; { :d2 =&gt; &quot;d2&quot; } } }
    expected = { :a =&gt; 1, :b =&gt; &quot;b&quot;, :c =&gt; { :c1 =&gt; 2, :c2 =&gt; &quot;c2&quot;, :c3 =&gt; { :d1 =&gt; &quot;d1&quot;, :d2 =&gt; &quot;d2&quot; } } }
    assert_equal expected, hash_1.deep_merge(hash_2)

    hash_1.deep_merge!(hash_2)
    assert_equal expected, hash_1
  end

  def test_reverse_merge
    defaults = { :a =&gt; &quot;x&quot;, :b =&gt; &quot;y&quot;, :c =&gt; 10 }.freeze
    options  = { :a =&gt; 1, :b =&gt; 2 }
    expected = { :a =&gt; 1, :b =&gt; 2, :c =&gt; 10 }

    # Should merge defaults into options, creating a new hash.
    assert_equal expected, options.reverse_merge(defaults)
    assert_not_equal expected, options

    # Should merge! defaults into options, replacing options.
    merged = options.dup
    assert_equal expected, merged.reverse_merge!(defaults)
    assert_equal expected, merged

    # Should be an alias for reverse_merge!
    merged = options.dup
    assert_equal expected, merged.reverse_update(defaults)
    assert_equal expected, merged
  end

  def test_diff
    assert_equal({ :a =&gt; 2 }, { :a =&gt; 2, :b =&gt; 5 }.diff({ :a =&gt; 1, :b =&gt; 5 }))
  end

  def test_slice
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10 }
    expected = { :a =&gt; 'x', :b =&gt; 'y' }

    # Should return a new hash with only the given keys.
    assert_equal expected, original.slice(:a, :b)
    assert_not_equal expected, original
  end

  def test_slice_inplace
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10 }
    expected = { :c =&gt; 10 }

    # Should replace the hash with only the given keys.
    assert_equal expected, original.slice!(:a, :b)
  end

  def test_slice_with_an_array_key
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10, [:a, :b] =&gt; &quot;an array key&quot; }
    expected = { [:a, :b] =&gt; &quot;an array key&quot;, :c =&gt; 10 }

    # Should return a new hash with only the given keys when given an array key.
    assert_equal expected, original.slice([:a, :b], :c)
    assert_not_equal expected, original
  end

  def test_slice_inplace_with_an_array_key
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10, [:a, :b] =&gt; &quot;an array key&quot; }
    expected = { :a =&gt; 'x', :b =&gt; 'y' }

    # Should replace the hash with only the given keys when given an array key.
    assert_equal expected, original.slice!([:a, :b], :c)
  end

  def test_slice_with_splatted_keys
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10, [:a, :b] =&gt; &quot;an array key&quot; }
    expected = { :a =&gt; 'x', :b =&gt; &quot;y&quot; }

    # Should grab each of the splatted keys.
    assert_equal expected, original.slice(*[:a, :b])
  end

  def test_indifferent_slice
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10 }.with_indifferent_access
    expected = { :a =&gt; 'x', :b =&gt; 'y' }.with_indifferent_access

    [['a', 'b'], [:a, :b]].each do |keys|
      # Should return a new hash with only the given keys.
      assert_equal expected, original.slice(*keys), keys.inspect
      assert_not_equal expected, original
    end
  end

  def test_indifferent_slice_inplace
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10 }.with_indifferent_access
    expected = { :c =&gt; 10 }.with_indifferent_access

    [['a', 'b'], [:a, :b]].each do |keys|
      # Should replace the hash with only the given keys.
      copy = original.dup
      assert_equal expected, copy.slice!(*keys)
    end
  end

  def test_indifferent_slice_access_with_symbols
    original = {'login' =&gt; 'bender', 'password' =&gt; 'shiny', 'stuff' =&gt; 'foo'}
    original = original.with_indifferent_access

    slice = original.slice(:login, :password)

    assert_equal 'bender', slice[:login]
    assert_equal 'bender', slice['login']
  end

  def test_except
    original = { :a =&gt; 'x', :b =&gt; 'y', :c =&gt; 10 }
    expected = { :a =&gt; 'x', :b =&gt; 'y' }

    # Should return a new hash with only the given keys.
    assert_equal expected, original.except(:c)
    assert_not_equal expected, original

    # Should replace the hash with only the given keys.
    assert_equal expected, original.except!(:c)
    assert_equal expected, original
  end

  def test_except_with_original_frozen
    original = { :a =&gt; 'x', :b =&gt; 'y' }
    original.freeze
    assert_nothing_raised { original.except(:a) }
  end

  def test_except_with_mocha_expectation_on_original
    original = { :a =&gt; 'x', :b =&gt; 'y' }
    original.expects(:delete).never
    original.except(:a)
  end
end

class IWriteMyOwnXML
  def to_xml(options = {})
    options[:indent] ||= 2
    xml = options[:builder] ||= Builder::XmlMarkup.new(:indent =&gt; options[:indent])
    xml.instruct! unless options[:skip_instruct]
    xml.level_one do
      xml.tag!(:second_level, 'content')
    end
  end
end

class HashToXmlTest &lt; Test::Unit::TestCase
  def setup
    @xml_options = { :root =&gt; :person, :skip_instruct =&gt; true, :indent =&gt; 0 }
  end

 def test_default_values_for_rename_keys
   assert_equal true,ActiveSupport.dasherize_xml
   assert_equal false,ActiveSupport.camelize_xml
  end

  def test_one_level
    xml = { :name =&gt; &quot;David&quot;, :street =&gt; &quot;Paulina&quot; }.to_xml(@xml_options)
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street&gt;Paulina&lt;/street&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
  end
  # we add :camelize =&gt; false because otherwise we'd be accidentally testing the default value for :camelize
  def test_one_level_dasherize_false
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:dasherize =&gt; false,:camelize=&gt;false))
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street_name&gt;Paulina&lt;/street_name&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
  end

  def test_one_level_dasherize_true
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:dasherize =&gt; true,:camelize=&gt;false))
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street-name&gt;Paulina&lt;/street-name&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
  end

  def test_one_level_dasherize_default_false
    current_default = ActiveSupport.dasherize_xml
    ActiveSupport.dasherize_xml = false
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:camelize=&gt;false))
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street_name&gt;Paulina&lt;/street_name&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    ensure
    ActiveSupport.dasherize_xml = current_default
  end

  def test_one_level_dasherize_default_true
    current_default = ActiveSupport.dasherize_xml
    ActiveSupport.dasherize_xml = true
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:camelize=&gt;false))
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street-name&gt;Paulina&lt;/street-name&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    ensure
    ActiveSupport.dasherize_xml = current_default
  end

  def test_one_level_camelize_true
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:camelize =&gt; true,:dasherize =&gt; false))
    assert_equal &quot;&lt;Person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;StreetName&gt;Paulina&lt;/StreetName&gt;))
    assert xml.include?(%(&lt;Name&gt;David&lt;/Name&gt;))
  end

  #camelize=&gt;false is already tested above

  def test_one_level_camelize_default_false
    current_default = ActiveSupport.camelize_xml
    ActiveSupport.camelize_xml = false
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:dasherize =&gt; false))
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street_name&gt;Paulina&lt;/street_name&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    ensure
    ActiveSupport.camelize_xml = current_default
  end

  def test_one_level_camelize_default_true
    current_default = ActiveSupport.camelize_xml
    ActiveSupport.camelize_xml = true
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:dasherize =&gt; false))
    assert_equal &quot;&lt;Person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;StreetName&gt;Paulina&lt;/StreetName&gt;))
    assert xml.include?(%(&lt;Name&gt;David&lt;/Name&gt;))
    ensure
    ActiveSupport.camelize_xml = current_default
  end

  def test_one_level_camelize_true_dasherize_true
    xml = { :name =&gt; &quot;David&quot;, :street_name =&gt; &quot;Paulina&quot; }.to_xml(@xml_options.merge(:dasherize =&gt; true,:camelize=&gt;true))
    assert_equal &quot;&lt;Person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;StreetName&gt;Paulina&lt;/StreetName&gt;))
    assert xml.include?(%(&lt;Name&gt;David&lt;/Name&gt;))
  end

  def test_one_level_with_types
    xml = { :name =&gt; &quot;David&quot;, :street =&gt; &quot;Paulina&quot;, :age =&gt; 26, :age_in_millis =&gt; 820497600000, :moved_on =&gt; Date.new(2005, 11, 15), :resident =&gt; :yes }.to_xml(@xml_options)
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street&gt;Paulina&lt;/street&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    assert xml.include?(%(&lt;age type=&quot;integer&quot;&gt;26&lt;/age&gt;))
    assert xml.include?(%(&lt;age-in-millis type=&quot;integer&quot;&gt;820497600000&lt;/age-in-millis&gt;))
    assert xml.include?(%(&lt;moved-on type=&quot;date&quot;&gt;2005-11-15&lt;/moved-on&gt;))
    assert xml.include?(%(&lt;resident type=&quot;symbol&quot;&gt;yes&lt;/resident&gt;))
  end

  def test_one_level_with_nils
    xml = { :name =&gt; &quot;David&quot;, :street =&gt; &quot;Paulina&quot;, :age =&gt; nil }.to_xml(@xml_options)
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street&gt;Paulina&lt;/street&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    assert xml.include?(%(&lt;age nil=&quot;true&quot;&gt;&lt;/age&gt;))
  end

  def test_one_level_with_skipping_types
    xml = { :name =&gt; &quot;David&quot;, :street =&gt; &quot;Paulina&quot;, :age =&gt; nil }.to_xml(@xml_options.merge(:skip_types =&gt; true))
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street&gt;Paulina&lt;/street&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    assert xml.include?(%(&lt;age nil=&quot;true&quot;&gt;&lt;/age&gt;))
  end

  def test_one_level_with_yielding
    xml = { :name =&gt; &quot;David&quot;, :street =&gt; &quot;Paulina&quot; }.to_xml(@xml_options) do |x|
      x.creator(&quot;Rails&quot;)
    end

    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;street&gt;Paulina&lt;/street&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    assert xml.include?(%(&lt;creator&gt;Rails&lt;/creator&gt;))
  end

  def test_two_levels
    xml = { :name =&gt; &quot;David&quot;, :address =&gt; { :street =&gt; &quot;Paulina&quot; } }.to_xml(@xml_options)
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;address&gt;&lt;street&gt;Paulina&lt;/street&gt;&lt;/address&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
  end

  def test_two_levels_with_second_level_overriding_to_xml
    xml = { :name =&gt; &quot;David&quot;, :address =&gt; { :street =&gt; &quot;Paulina&quot; }, :child =&gt; IWriteMyOwnXML.new }.to_xml(@xml_options)
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;address&gt;&lt;street&gt;Paulina&lt;/street&gt;&lt;/address&gt;))
    assert xml.include?(%(&lt;level_one&gt;&lt;second_level&gt;content&lt;/second_level&gt;&lt;/level_one&gt;))
  end

  def test_two_levels_with_array
    xml = { :name =&gt; &quot;David&quot;, :addresses =&gt; [{ :street =&gt; &quot;Paulina&quot; }, { :street =&gt; &quot;Evergreen&quot; }] }.to_xml(@xml_options)
    assert_equal &quot;&lt;person&gt;&quot;, xml.first(8)
    assert xml.include?(%(&lt;addresses type=&quot;array&quot;&gt;&lt;address&gt;))
    assert xml.include?(%(&lt;address&gt;&lt;street&gt;Paulina&lt;/street&gt;&lt;/address&gt;))
    assert xml.include?(%(&lt;address&gt;&lt;street&gt;Evergreen&lt;/street&gt;&lt;/address&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
  end

  def test_three_levels_with_array
    xml = { :name =&gt; &quot;David&quot;, :addresses =&gt; [{ :streets =&gt; [ { :name =&gt; &quot;Paulina&quot; }, { :name =&gt; &quot;Paulina&quot; } ] } ] }.to_xml(@xml_options)
    assert xml.include?(%(&lt;addresses type=&quot;array&quot;&gt;&lt;address&gt;&lt;streets type=&quot;array&quot;&gt;&lt;street&gt;&lt;name&gt;))
  end

  def test_timezoned_attributes
    xml = {
      :created_at =&gt; Time.utc(1999,2,2),
      :local_created_at =&gt; Time.utc(1999,2,2).in_time_zone('Eastern Time (US &amp; Canada)')
    }.to_xml(@xml_options)
    assert_match %r{&lt;created-at type=\&quot;datetime\&quot;&gt;1999-02-02T00:00:00Z&lt;/created-at&gt;}, xml
    assert_match %r{&lt;local-created-at type=\&quot;datetime\&quot;&gt;1999-02-01T19:00:00-05:00&lt;/local-created-at&gt;}, xml
  end

  def test_single_record_from_xml
    topic_xml = &lt;&lt;-EOT
      &lt;topic&gt;
        &lt;title&gt;The First Topic&lt;/title&gt;
        &lt;author-name&gt;David&lt;/author-name&gt;
        &lt;id type=&quot;integer&quot;&gt;1&lt;/id&gt;
        &lt;approved type=&quot;boolean&quot;&gt; true &lt;/approved&gt;
        &lt;replies-count type=&quot;integer&quot;&gt;0&lt;/replies-count&gt;
        &lt;replies-close-in type=&quot;integer&quot;&gt;2592000000&lt;/replies-close-in&gt;
        &lt;written-on type=&quot;date&quot;&gt;2003-07-16&lt;/written-on&gt;
        &lt;viewed-at type=&quot;datetime&quot;&gt;2003-07-16T09:28:00+0000&lt;/viewed-at&gt;
        &lt;content type=&quot;yaml&quot;&gt;--- \n1: should be an integer\n:message: Have a nice day\narray: \n- should-have-dashes: true\n  should_have_underscores: true\n&lt;/content&gt;
        &lt;author-email-address&gt;david@loudthinking.com&lt;/author-email-address&gt;
        &lt;parent-id&gt;&lt;/parent-id&gt;
        &lt;ad-revenue type=&quot;decimal&quot;&gt;1.5&lt;/ad-revenue&gt;
        &lt;optimum-viewing-angle type=&quot;float&quot;&gt;135&lt;/optimum-viewing-angle&gt;
        &lt;resident type=&quot;symbol&quot;&gt;yes&lt;/resident&gt;
      &lt;/topic&gt;
    EOT

    expected_topic_hash = {
      :title =&gt; &quot;The First Topic&quot;,
      :author_name =&gt; &quot;David&quot;,
      :id =&gt; 1,
      :approved =&gt; true,
      :replies_count =&gt; 0,
      :replies_close_in =&gt; 2592000000,
      :written_on =&gt; Date.new(2003, 7, 16),
      :viewed_at =&gt; Time.utc(2003, 7, 16, 9, 28),
      :content =&gt; { :message =&gt; &quot;Have a nice day&quot;, 1 =&gt; &quot;should be an integer&quot;, &quot;array&quot; =&gt; [{ &quot;should-have-dashes&quot; =&gt; true, &quot;should_have_underscores&quot; =&gt; true }] },
      :author_email_address =&gt; &quot;david@loudthinking.com&quot;,
      :parent_id =&gt; nil,
      :ad_revenue =&gt; BigDecimal(&quot;1.50&quot;),
      :optimum_viewing_angle =&gt; 135.0,
      :resident =&gt; :yes
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topic_xml)[&quot;topic&quot;]
  end

  def test_single_record_from_xml_with_nil_values
    topic_xml = &lt;&lt;-EOT
      &lt;topic&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;id type=&quot;integer&quot;&gt;&lt;/id&gt;
        &lt;approved type=&quot;boolean&quot;&gt;&lt;/approved&gt;
        &lt;written-on type=&quot;date&quot;&gt;&lt;/written-on&gt;
        &lt;viewed-at type=&quot;datetime&quot;&gt;&lt;/viewed-at&gt;
        &lt;content type=&quot;yaml&quot;&gt;&lt;/content&gt;
        &lt;parent-id&gt;&lt;/parent-id&gt;
      &lt;/topic&gt;
    EOT

    expected_topic_hash = {
      :title      =&gt; nil, 
      :id         =&gt; nil,
      :approved   =&gt; nil,
      :written_on =&gt; nil,
      :viewed_at  =&gt; nil,
      :content    =&gt; nil, 
      :parent_id  =&gt; nil
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topic_xml)[&quot;topic&quot;]
  end

  def test_multiple_records_from_xml
    topics_xml = &lt;&lt;-EOT
      &lt;topics type=&quot;array&quot;&gt;
        &lt;topic&gt;
          &lt;title&gt;The First Topic&lt;/title&gt;
          &lt;author-name&gt;David&lt;/author-name&gt;
          &lt;id type=&quot;integer&quot;&gt;1&lt;/id&gt;
          &lt;approved type=&quot;boolean&quot;&gt;false&lt;/approved&gt;
          &lt;replies-count type=&quot;integer&quot;&gt;0&lt;/replies-count&gt;
          &lt;replies-close-in type=&quot;integer&quot;&gt;2592000000&lt;/replies-close-in&gt;
          &lt;written-on type=&quot;date&quot;&gt;2003-07-16&lt;/written-on&gt;
          &lt;viewed-at type=&quot;datetime&quot;&gt;2003-07-16T09:28:00+0000&lt;/viewed-at&gt;
          &lt;content&gt;Have a nice day&lt;/content&gt;
          &lt;author-email-address&gt;david@loudthinking.com&lt;/author-email-address&gt;
          &lt;parent-id nil=&quot;true&quot;&gt;&lt;/parent-id&gt;
        &lt;/topic&gt;
        &lt;topic&gt;
          &lt;title&gt;The Second Topic&lt;/title&gt;
          &lt;author-name&gt;Jason&lt;/author-name&gt;
          &lt;id type=&quot;integer&quot;&gt;1&lt;/id&gt;
          &lt;approved type=&quot;boolean&quot;&gt;false&lt;/approved&gt;
          &lt;replies-count type=&quot;integer&quot;&gt;0&lt;/replies-count&gt;
          &lt;replies-close-in type=&quot;integer&quot;&gt;2592000000&lt;/replies-close-in&gt;
          &lt;written-on type=&quot;date&quot;&gt;2003-07-16&lt;/written-on&gt;
          &lt;viewed-at type=&quot;datetime&quot;&gt;2003-07-16T09:28:00+0000&lt;/viewed-at&gt;
          &lt;content&gt;Have a nice day&lt;/content&gt;
          &lt;author-email-address&gt;david@loudthinking.com&lt;/author-email-address&gt;
          &lt;parent-id&gt;&lt;/parent-id&gt;
        &lt;/topic&gt;
      &lt;/topics&gt;
    EOT

    expected_topic_hash = {
      :title =&gt; &quot;The First Topic&quot;,
      :author_name =&gt; &quot;David&quot;,
      :id =&gt; 1,
      :approved =&gt; false,
      :replies_count =&gt; 0,
      :replies_close_in =&gt; 2592000000,
      :written_on =&gt; Date.new(2003, 7, 16),
      :viewed_at =&gt; Time.utc(2003, 7, 16, 9, 28),
      :content =&gt; &quot;Have a nice day&quot;,
      :author_email_address =&gt; &quot;david@loudthinking.com&quot;,
      :parent_id =&gt; nil
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topics_xml)[&quot;topics&quot;].first
  end

  def test_single_record_from_xml_with_attributes_other_than_type
    topic_xml = &lt;&lt;-EOT
    &lt;rsp stat=&quot;ok&quot;&gt;
      &lt;photos page=&quot;1&quot; pages=&quot;1&quot; perpage=&quot;100&quot; total=&quot;16&quot;&gt;
        &lt;photo id=&quot;175756086&quot; owner=&quot;55569174@N00&quot; secret=&quot;0279bf37a1&quot; server=&quot;76&quot; title=&quot;Colored Pencil PhotoBooth Fun&quot; ispublic=&quot;1&quot; isfriend=&quot;0&quot; isfamily=&quot;0&quot;/&gt;
      &lt;/photos&gt;
    &lt;/rsp&gt;
    EOT

    expected_topic_hash = {
      :id =&gt; &quot;175756086&quot;,
      :owner =&gt; &quot;55569174@N00&quot;,
      :secret =&gt; &quot;0279bf37a1&quot;,
      :server =&gt; &quot;76&quot;,
      :title =&gt; &quot;Colored Pencil PhotoBooth Fun&quot;,
      :ispublic =&gt; &quot;1&quot;,
      :isfriend =&gt; &quot;0&quot;,
      :isfamily =&gt; &quot;0&quot;,
    }.stringify_keys

    assert_equal expected_topic_hash, Hash.from_xml(topic_xml)[&quot;rsp&quot;][&quot;photos&quot;][&quot;photo&quot;]
  end
  
  def test_empty_array_from_xml
    blog_xml = &lt;&lt;-XML
      &lt;blog&gt;
        &lt;posts type=&quot;array&quot;&gt;&lt;/posts&gt;
      &lt;/blog&gt;
    XML
    expected_blog_hash = {&quot;blog&quot; =&gt; {&quot;posts&quot; =&gt; []}}
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_all_caps_key_from_xml
    test_xml = &lt;&lt;-EOT
      &lt;ABC3XYZ&gt;
        &lt;TEST&gt;Lorem Ipsum&lt;/TEST&gt;
      &lt;/ABC3XYZ&gt;
    EOT

    expected_hash = {
      &quot;ABC3XYZ&quot; =&gt; {
        &quot;TEST&quot; =&gt; &quot;Lorem Ipsum&quot;
      }
    }

    assert_equal expected_hash, Hash.from_xml(test_xml)
  end

  def test_empty_array_with_whitespace_from_xml
    blog_xml = &lt;&lt;-XML
      &lt;blog&gt;
        &lt;posts type=&quot;array&quot;&gt;
        &lt;/posts&gt;
      &lt;/blog&gt;
    XML
    expected_blog_hash = {&quot;blog&quot; =&gt; {&quot;posts&quot; =&gt; []}}
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_array_with_one_entry_from_xml
    blog_xml = &lt;&lt;-XML
      &lt;blog&gt;
        &lt;posts type=&quot;array&quot;&gt;
          &lt;post&gt;a post&lt;/post&gt;
        &lt;/posts&gt;
      &lt;/blog&gt;
    XML
    expected_blog_hash = {&quot;blog&quot; =&gt; {&quot;posts&quot; =&gt; [&quot;a post&quot;]}}
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_array_with_multiple_entries_from_xml
    blog_xml = &lt;&lt;-XML
      &lt;blog&gt;
        &lt;posts type=&quot;array&quot;&gt;
          &lt;post&gt;a post&lt;/post&gt;
          &lt;post&gt;another post&lt;/post&gt;
        &lt;/posts&gt;
      &lt;/blog&gt;
    XML
    expected_blog_hash = {&quot;blog&quot; =&gt; {&quot;posts&quot; =&gt; [&quot;a post&quot;, &quot;another post&quot;]}}
    assert_equal expected_blog_hash, Hash.from_xml(blog_xml)
  end

  def test_file_from_xml
    blog_xml = &lt;&lt;-XML
      &lt;blog&gt;
        &lt;logo type=&quot;file&quot; name=&quot;logo.png&quot; content_type=&quot;image/png&quot;&gt;
        &lt;/logo&gt;
      &lt;/blog&gt;
    XML
    hash = Hash.from_xml(blog_xml)
    assert hash.has_key?('blog')
    assert hash['blog'].has_key?('logo')

    file = hash['blog']['logo']
    assert_equal 'logo.png', file.original_filename
    assert_equal 'image/png', file.content_type
  end

  def test_file_from_xml_with_defaults
    blog_xml = &lt;&lt;-XML
      &lt;blog&gt;
        &lt;logo type=&quot;file&quot;&gt;
        &lt;/logo&gt;
      &lt;/blog&gt;
    XML
    file = Hash.from_xml(blog_xml)['blog']['logo']
    assert_equal 'untitled', file.original_filename
    assert_equal 'application/octet-stream', file.content_type
  end

  def test_xsd_like_types_from_xml
    bacon_xml = &lt;&lt;-EOT
    &lt;bacon&gt;
      &lt;weight type=&quot;double&quot;&gt;0.5&lt;/weight&gt;
      &lt;price type=&quot;decimal&quot;&gt;12.50&lt;/price&gt;
      &lt;chunky type=&quot;boolean&quot;&gt; 1 &lt;/chunky&gt;
      &lt;expires-at type=&quot;dateTime&quot;&gt;2007-12-25T12:34:56+0000&lt;/expires-at&gt;
      &lt;notes type=&quot;string&quot;&gt;&lt;/notes&gt;
      &lt;illustration type=&quot;base64Binary&quot;&gt;YmFiZS5wbmc=&lt;/illustration&gt;
    &lt;/bacon&gt;
    EOT

    expected_bacon_hash = {
      :weight =&gt; 0.5,
      :chunky =&gt; true,
      :price =&gt; BigDecimal(&quot;12.50&quot;),
      :expires_at =&gt; Time.utc(2007,12,25,12,34,56),
      :notes =&gt; &quot;&quot;,
      :illustration =&gt; &quot;babe.png&quot;
    }.stringify_keys

    assert_equal expected_bacon_hash, Hash.from_xml(bacon_xml)[&quot;bacon&quot;]
  end
  
  def test_type_trickles_through_when_unknown
    product_xml = &lt;&lt;-EOT
    &lt;product&gt;
      &lt;weight type=&quot;double&quot;&gt;0.5&lt;/weight&gt;
      &lt;image type=&quot;ProductImage&quot;&gt;&lt;filename&gt;image.gif&lt;/filename&gt;&lt;/image&gt;
      
    &lt;/product&gt;
    EOT

    expected_product_hash = {
      :weight =&gt; 0.5,
      :image =&gt; {'type' =&gt; 'ProductImage', 'filename' =&gt; 'image.gif' },
    }.stringify_keys

    assert_equal expected_product_hash, Hash.from_xml(product_xml)[&quot;product&quot;]    
  end

  def test_should_use_default_value_for_unknown_key
    hash_wia = HashWithIndifferentAccess.new(3)
    assert_equal 3, hash_wia[:new_key]
  end

  def test_should_use_default_value_if_no_key_is_supplied
    hash_wia = HashWithIndifferentAccess.new(3)
    assert_equal 3, hash_wia.default
  end

  def test_should_nil_if_no_default_value_is_supplied
    hash_wia = HashWithIndifferentAccess.new
    assert_nil hash_wia.default
  end

  def test_should_copy_the_default_value_when_converting_to_hash_with_indifferent_access
    hash = Hash.new(3)
    hash_wia = hash.with_indifferent_access
    assert_equal 3, hash_wia.default
  end

  # The XML builder seems to fail miserably when trying to tag something
  # with the same name as a Kernel method (throw, test, loop, select ...)
  def test_kernel_method_names_to_xml
    hash     = { :throw =&gt; { :ball =&gt; 'red' } }
    expected = '&lt;person&gt;&lt;throw&gt;&lt;ball&gt;red&lt;/ball&gt;&lt;/throw&gt;&lt;/person&gt;'

    assert_nothing_raised do
      assert_equal expected, hash.to_xml(@xml_options)
    end
  end
  
  def test_empty_string_works_for_typecast_xml_value    
    assert_nothing_raised do
      Hash.__send__(:typecast_xml_value, &quot;&quot;)
    end
  end
  
  def test_escaping_to_xml
    hash = { 
      :bare_string        =&gt; 'First &amp; Last Name', 
      :pre_escaped_string =&gt; 'First &amp;amp; Last Name'
    }.stringify_keys
    
    expected_xml = '&lt;person&gt;&lt;bare-string&gt;First &amp;amp; Last Name&lt;/bare-string&gt;&lt;pre-escaped-string&gt;First &amp;amp;amp; Last Name&lt;/pre-escaped-string&gt;&lt;/person&gt;'
    assert_equal expected_xml, hash.to_xml(@xml_options)
  end
  
  def test_unescaping_from_xml
    xml_string = '&lt;person&gt;&lt;bare-string&gt;First &amp;amp; Last Name&lt;/bare-string&gt;&lt;pre-escaped-string&gt;First &amp;amp;amp; Last Name&lt;/pre-escaped-string&gt;&lt;/person&gt;'
    expected_hash = { 
      :bare_string        =&gt; 'First &amp; Last Name', 
      :pre_escaped_string =&gt; 'First &amp;amp; Last Name'
    }.stringify_keys
    assert_equal expected_hash, Hash.from_xml(xml_string)['person']
  end
  
  def test_roundtrip_to_xml_from_xml
    hash = { 
      :bare_string        =&gt; 'First &amp; Last Name', 
      :pre_escaped_string =&gt; 'First &amp;amp; Last Name'
    }.stringify_keys

    assert_equal hash, Hash.from_xml(hash.to_xml(@xml_options))['person']
  end
  
  def test_to_xml_dups_options
    options = {:skip_instruct =&gt; true}
    {}.to_xml(options)
    # :builder, etc, shouldn't be added to options
    assert_equal({:skip_instruct =&gt; true}, options)
  end

  def test_datetime_xml_type_with_utc_time
    alert_xml = &lt;&lt;-XML
      &lt;alert&gt;
        &lt;alert_at type=&quot;datetime&quot;&gt;2008-02-10T15:30:45Z&lt;/alert_at&gt;
      &lt;/alert&gt;
    XML
    alert_at = Hash.from_xml(alert_xml)['alert']['alert_at']
    assert alert_at.utc?
    assert_equal Time.utc(2008, 2, 10, 15, 30, 45), alert_at
  end
  
  def test_datetime_xml_type_with_non_utc_time
    alert_xml = &lt;&lt;-XML
      &lt;alert&gt;
        &lt;alert_at type=&quot;datetime&quot;&gt;2008-02-10T10:30:45-05:00&lt;/alert_at&gt;
      &lt;/alert&gt;
    XML
    alert_at = Hash.from_xml(alert_xml)['alert']['alert_at']
    assert alert_at.utc?
    assert_equal Time.utc(2008, 2, 10, 15, 30, 45), alert_at
  end
  
  def test_datetime_xml_type_with_far_future_date
    alert_xml = &lt;&lt;-XML
      &lt;alert&gt;
        &lt;alert_at type=&quot;datetime&quot;&gt;2050-02-10T15:30:45Z&lt;/alert_at&gt;
      &lt;/alert&gt;
    XML
    alert_at = Hash.from_xml(alert_xml)['alert']['alert_at']
    assert alert_at.utc?
    assert_equal 2050,  alert_at.year
    assert_equal 2,     alert_at.month
    assert_equal 10,    alert_at.day
    assert_equal 15,    alert_at.hour
    assert_equal 30,    alert_at.min
    assert_equal 45,    alert_at.sec
  end
end

class QueryTest &lt; Test::Unit::TestCase
  def test_simple_conversion
    assert_query_equal 'a=10', :a =&gt; 10
  end

  def test_cgi_escaping
    assert_query_equal 'a%3Ab=c+d', 'a:b' =&gt; 'c d'
  end

  def test_nil_parameter_value
    empty = Object.new
    def empty.to_param; nil end
    assert_query_equal 'a=', 'a' =&gt; empty
  end

  def test_nested_conversion
    assert_query_equal 'person%5Blogin%5D=seckar&amp;person%5Bname%5D=Nicholas',
      :person =&gt; {:name =&gt; 'Nicholas', :login =&gt; 'seckar'}
  end

  def test_multiple_nested
    assert_query_equal 'account%5Bperson%5D%5Bid%5D=20&amp;person%5Bid%5D=10',
      :person =&gt; {:id =&gt; 10}, :account =&gt; {:person =&gt; {:id =&gt; 20}}
  end

  def test_array_values
    assert_query_equal 'person%5Bid%5D%5B%5D=10&amp;person%5Bid%5D%5B%5D=20',
      :person =&gt; {:id =&gt; [10, 20]}
  end

  def test_array_values_are_not_sorted
    assert_query_equal 'person%5Bid%5D%5B%5D=20&amp;person%5Bid%5D%5B%5D=10',
      :person =&gt; {:id =&gt; [20, 10]}
  end

  def test_expansion_count_is_limited
    expected = {
      'ActiveSupport::XmlMini_REXML'       =&gt; 'RuntimeError',
      'ActiveSupport::XmlMini_Nokogiri'    =&gt; 'Nokogiri::XML::SyntaxError',
      'ActiveSupport::XmlMini_NokogiriSAX' =&gt; 'RuntimeError',
      'ActiveSupport::XmlMini_LibXML'      =&gt; 'LibXML::XML::Error',
      'ActiveSupport::XmlMini_LibXMLSAX'   =&gt; 'LibXML::XML::Error',
    }[ActiveSupport::XmlMini.backend.name].constantize

    assert_raise expected do
      attack_xml = &lt;&lt;-EOT
      &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
      &lt;!DOCTYPE member [
        &lt;!ENTITY a &quot;&amp;b;&amp;b;&amp;b;&amp;b;&amp;b;&amp;b;&amp;b;&amp;b;&amp;b;&amp;b;&quot;&gt;
        &lt;!ENTITY b &quot;&amp;c;&amp;c;&amp;c;&amp;c;&amp;c;&amp;c;&amp;c;&amp;c;&amp;c;&amp;c;&quot;&gt;
        &lt;!ENTITY c &quot;&amp;d;&amp;d;&amp;d;&amp;d;&amp;d;&amp;d;&amp;d;&amp;d;&amp;d;&amp;d;&quot;&gt;
        &lt;!ENTITY d &quot;&amp;e;&amp;e;&amp;e;&amp;e;&amp;e;&amp;e;&amp;e;&amp;e;&amp;e;&amp;e;&quot;&gt;
        &lt;!ENTITY e &quot;&amp;f;&amp;f;&amp;f;&amp;f;&amp;f;&amp;f;&amp;f;&amp;f;&amp;f;&amp;f;&quot;&gt;
        &lt;!ENTITY f &quot;&amp;g;&amp;g;&amp;g;&amp;g;&amp;g;&amp;g;&amp;g;&amp;g;&amp;g;&amp;g;&quot;&gt;
        &lt;!ENTITY g &quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;&gt;
      ]&gt;
      &lt;member&gt;
      &amp;a;
      &lt;/member&gt;
      EOT
      Hash.from_xml(attack_xml)
    end
  end

  private
    def assert_query_equal(expected, actual, message = nil)
      assert_equal expected.split('&amp;'), actual.to_query.split('&amp;')
    end
end
</pre>
    </div>