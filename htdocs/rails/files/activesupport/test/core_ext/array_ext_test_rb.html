  <div id="fileHeader">
    <h1>array_ext_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/test/core_ext/array_ext_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:54 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'abstract_unit'
require 'bigdecimal'

class ArrayExtAccessTests &lt; Test::Unit::TestCase
  def test_from
    assert_equal %w( a b c d ), %w( a b c d ).from(0)
    assert_equal %w( c d ), %w( a b c d ).from(2)
    assert_nil %w( a b c d ).from(10)
  end

  def test_to
    assert_equal %w( a ), %w( a b c d ).to(0)
    assert_equal %w( a b c ), %w( a b c d ).to(2)
    assert_equal %w( a b c d ), %w( a b c d ).to(10)
  end
  
  def test_second_through_tenth
    array = (1..42).to_a
    
    assert_equal array[1], array.second
    assert_equal array[2], array.third
    assert_equal array[3], array.fourth
    assert_equal array[4], array.fifth
    assert_equal array[41], array.forty_two
  end
end

class ArrayExtToParamTests &lt; Test::Unit::TestCase
  class ToParam &lt; String
    def to_param
      &quot;#{self}1&quot;
    end
  end

  def test_string_array
    assert_equal '', %w().to_param
    assert_equal 'hello/world', %w(hello world).to_param
    assert_equal 'hello/10', %w(hello 10).to_param
  end

  def test_number_array
    assert_equal '10/20', [10, 20].to_param
  end

  def test_to_param_array
    assert_equal 'custom1/param1', [ToParam.new('custom'), ToParam.new('param')].to_param
  end
end

class ArrayExtToSentenceTests &lt; Test::Unit::TestCase
  include ActiveSupport::Testing::Deprecation
  
  def test_plain_array_to_sentence
    assert_equal &quot;&quot;, [].to_sentence
    assert_equal &quot;one&quot;, ['one'].to_sentence
    assert_equal &quot;one and two&quot;, ['one', 'two'].to_sentence
    assert_equal &quot;one, two, and three&quot;, ['one', 'two', 'three'].to_sentence
  end

  def test_to_sentence_with_words_connector
    assert_deprecated(&quot;:connector has been deprecated. Use :words_connector instead&quot;) do
      assert_equal &quot;one, two, three&quot;, ['one', 'two', 'three'].to_sentence(:connector =&gt; '')
    end
    
    assert_deprecated(&quot;:connector has been deprecated. Use :words_connector instead&quot;) do
      assert_equal &quot;one, two, and three&quot;, ['one', 'two', 'three'].to_sentence(:connector =&gt; 'and ')
    end
    
    assert_equal &quot;one two, and three&quot;, ['one', 'two', 'three'].to_sentence(:words_connector =&gt; ' ')
    assert_equal &quot;one &amp; two, and three&quot;, ['one', 'two', 'three'].to_sentence(:words_connector =&gt; ' &amp; ')
    assert_equal &quot;onetwo, and three&quot;, ['one', 'two', 'three'].to_sentence(:words_connector =&gt; nil)
  end

  def test_to_sentence_with_last_word_connector
    assert_deprecated(&quot;:skip_last_comma has been deprecated. Use :last_word_connector instead&quot;) do
      assert_equal &quot;one, two and three&quot;, ['one', 'two', 'three'].to_sentence(:skip_last_comma =&gt; true)
    end
    
    assert_deprecated(&quot;:skip_last_comma has been deprecated. Use :last_word_connector instead&quot;) do
      assert_equal &quot;one, two, and three&quot;, ['one', 'two', 'three'].to_sentence(:skip_last_comma =&gt; false)
    end
    
    assert_equal &quot;one, two, and also three&quot;, ['one', 'two', 'three'].to_sentence(:last_word_connector =&gt; ', and also ')
    assert_equal &quot;one, twothree&quot;, ['one', 'two', 'three'].to_sentence(:last_word_connector =&gt; nil)
    assert_equal &quot;one, two three&quot;, ['one', 'two', 'three'].to_sentence(:last_word_connector =&gt; ' ')
    assert_equal &quot;one, two and three&quot;, ['one', 'two', 'three'].to_sentence(:last_word_connector =&gt; ' and ')
  end

  def test_two_elements
    assert_equal &quot;one and two&quot;, ['one', 'two'].to_sentence
    assert_equal &quot;one two&quot;, ['one', 'two'].to_sentence(:two_words_connector =&gt; ' ')
  end

  def test_one_element
    assert_equal &quot;one&quot;, ['one'].to_sentence
  end

  def test_one_non_string_element
    assert_equal '1', [1].to_sentence
  end
end

class ArrayExtToSTests &lt; Test::Unit::TestCase
  def test_to_s_db
    collection = [
      Class.new { def id() 1 end }.new,
      Class.new { def id() 2 end }.new,
      Class.new { def id() 3 end }.new
    ]

    assert_equal &quot;null&quot;, [].to_s(:db)
    assert_equal &quot;1,2,3&quot;, collection.to_s(:db)
  end
end

class ArrayExtGroupingTests &lt; Test::Unit::TestCase
  def test_in_groups_of_with_perfect_fit
    groups = []
    ('a'..'i').to_a.in_groups_of(3) do |group|
      groups &lt;&lt; group
    end

    assert_equal [%w(a b c), %w(d e f), %w(g h i)], groups
    assert_equal [%w(a b c), %w(d e f), %w(g h i)], ('a'..'i').to_a.in_groups_of(3)
  end

  def test_in_groups_of_with_padding
    groups = []
    ('a'..'g').to_a.in_groups_of(3) do |group|
      groups &lt;&lt; group
    end

    assert_equal [%w(a b c), %w(d e f), ['g', nil, nil]], groups
  end

  def test_in_groups_of_pads_with_specified_values
    groups = []

    ('a'..'g').to_a.in_groups_of(3, 'foo') do |group|
      groups &lt;&lt; group
    end

    assert_equal [%w(a b c), %w(d e f), ['g', 'foo', 'foo']], groups
  end

  def test_in_groups_of_without_padding
    groups = []

    ('a'..'g').to_a.in_groups_of(3, false) do |group|
      groups &lt;&lt; group
    end

    assert_equal [%w(a b c), %w(d e f), ['g']], groups
  end

  def test_in_groups_returned_array_size
    array = (1..7).to_a

    1.upto(array.size + 1) do |number|
      assert_equal number, array.in_groups(number).size
    end
  end

  def test_in_groups_with_empty_array
    assert_equal [[], [], []], [].in_groups(3)
  end

  def test_in_groups_with_block
    array = (1..9).to_a
    groups = []

    array.in_groups(3) do |group|
      groups &lt;&lt; group
    end

    assert_equal array.in_groups(3), groups
  end

  def test_in_groups_with_perfect_fit
    assert_equal [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
      (1..9).to_a.in_groups(3)
  end

  def test_in_groups_with_padding
    array = (1..7).to_a

    assert_equal [[1, 2, 3], [4, 5, nil], [6, 7, nil]],
      array.in_groups(3)
    assert_equal [[1, 2, 3], [4, 5, 'foo'], [6, 7, 'foo']],
      array.in_groups(3, 'foo')
  end

  def test_in_groups_without_padding
    assert_equal [[1, 2, 3], [4, 5], [6, 7]],
      (1..7).to_a.in_groups(3, false)
  end
end

class ArraySplitTests &lt; Test::Unit::TestCase
  def test_split_with_empty_array
    assert_equal [[]], [].split(0)
  end

  def test_split_with_argument
    assert_equal [[1, 2], [4, 5]],  [1, 2, 3, 4, 5].split(3)
    assert_equal [[1, 2, 3, 4, 5]], [1, 2, 3, 4, 5].split(0)
  end

  def test_split_with_block
    assert_equal [[1, 2], [4, 5], [7, 8], [10]], (1..10).to_a.split { |i| i % 3 == 0 }
  end

  def test_split_with_edge_values
    assert_equal [[], [2, 3, 4, 5]],  [1, 2, 3, 4, 5].split(1)
    assert_equal [[1, 2, 3, 4], []],  [1, 2, 3, 4, 5].split(5)
    assert_equal [[], [2, 3, 4], []], [1, 2, 3, 4, 5].split { |i| i == 1 || i == 5 }
  end
end

class ArrayToXmlTests &lt; Test::Unit::TestCase
  def test_to_xml
    xml = [
      { :name =&gt; &quot;David&quot;, :age =&gt; 26, :age_in_millis =&gt; 820497600000 },
      { :name =&gt; &quot;Jason&quot;, :age =&gt; 31, :age_in_millis =&gt; BigDecimal.new('1.0') }
    ].to_xml(:skip_instruct =&gt; true, :indent =&gt; 0)

    assert_equal '&lt;records type=&quot;array&quot;&gt;&lt;record&gt;', xml.first(30)
    assert xml.include?(%(&lt;age type=&quot;integer&quot;&gt;26&lt;/age&gt;)), xml
    assert xml.include?(%(&lt;age-in-millis type=&quot;integer&quot;&gt;820497600000&lt;/age-in-millis&gt;)), xml
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;)), xml
    assert xml.include?(%(&lt;age type=&quot;integer&quot;&gt;31&lt;/age&gt;)), xml
    assert xml.include?(%(&lt;age-in-millis type=&quot;decimal&quot;&gt;1.0&lt;/age-in-millis&gt;)), xml
    assert xml.include?(%(&lt;name&gt;Jason&lt;/name&gt;)), xml
  end

  def test_to_xml_dups_options
    options = {:skip_instruct =&gt; true}
    [].to_xml(options)
    # :builder, etc, shouldn't be added to options
    assert_equal({:skip_instruct =&gt; true}, options)
  end

  def test_to_xml_with_dedicated_name
    xml = [
      { :name =&gt; &quot;David&quot;, :age =&gt; 26, :age_in_millis =&gt; 820497600000 }, { :name =&gt; &quot;Jason&quot;, :age =&gt; 31 }
    ].to_xml(:skip_instruct =&gt; true, :indent =&gt; 0, :root =&gt; &quot;people&quot;)

    assert_equal '&lt;people type=&quot;array&quot;&gt;&lt;person&gt;', xml.first(29)
  end

  def test_to_xml_with_options
    xml = [
      { :name =&gt; &quot;David&quot;, :street_address =&gt; &quot;Paulina&quot; }, { :name =&gt; &quot;Jason&quot;, :street_address =&gt; &quot;Evergreen&quot; }
    ].to_xml(:skip_instruct =&gt; true, :skip_types =&gt; true, :indent =&gt; 0)

    assert_equal &quot;&lt;records&gt;&lt;record&gt;&quot;, xml.first(17)
    assert xml.include?(%(&lt;street-address&gt;Paulina&lt;/street-address&gt;))
    assert xml.include?(%(&lt;name&gt;David&lt;/name&gt;))
    assert xml.include?(%(&lt;street-address&gt;Evergreen&lt;/street-address&gt;))
    assert xml.include?(%(&lt;name&gt;Jason&lt;/name&gt;))
  end

  def test_to_xml_with_dasherize_false
    xml = [
      { :name =&gt; &quot;David&quot;, :street_address =&gt; &quot;Paulina&quot; }, { :name =&gt; &quot;Jason&quot;, :street_address =&gt; &quot;Evergreen&quot; }
    ].to_xml(:skip_instruct =&gt; true, :skip_types =&gt; true, :indent =&gt; 0, :dasherize =&gt; false)

    assert_equal &quot;&lt;records&gt;&lt;record&gt;&quot;, xml.first(17)
    assert xml.include?(%(&lt;street_address&gt;Paulina&lt;/street_address&gt;))
    assert xml.include?(%(&lt;street_address&gt;Evergreen&lt;/street_address&gt;))
  end

  def test_to_xml_with_dasherize_true
    xml = [
      { :name =&gt; &quot;David&quot;, :street_address =&gt; &quot;Paulina&quot; }, { :name =&gt; &quot;Jason&quot;, :street_address =&gt; &quot;Evergreen&quot; }
    ].to_xml(:skip_instruct =&gt; true, :skip_types =&gt; true, :indent =&gt; 0, :dasherize =&gt; true)

    assert_equal &quot;&lt;records&gt;&lt;record&gt;&quot;, xml.first(17)
    assert xml.include?(%(&lt;street-address&gt;Paulina&lt;/street-address&gt;))
    assert xml.include?(%(&lt;street-address&gt;Evergreen&lt;/street-address&gt;))
  end

  def test_to_with_instruct
    xml = [
      { :name =&gt; &quot;David&quot;, :age =&gt; 26, :age_in_millis =&gt; 820497600000 },
      { :name =&gt; &quot;Jason&quot;, :age =&gt; 31, :age_in_millis =&gt; BigDecimal.new('1.0') }
    ].to_xml(:skip_instruct =&gt; false, :indent =&gt; 0)

    assert_match(/^&lt;\?xml [^&gt;]*/, xml)
    assert_equal 0, xml.rindex(/&lt;\?xml /)
  end

  def test_to_xml_with_block
    xml = [
      { :name =&gt; &quot;David&quot;, :age =&gt; 26, :age_in_millis =&gt; 820497600000 },
      { :name =&gt; &quot;Jason&quot;, :age =&gt; 31, :age_in_millis =&gt; BigDecimal.new('1.0') }
    ].to_xml(:skip_instruct =&gt; true, :indent =&gt; 0) do |builder|
      builder.count 2
    end

    assert xml.include?(%(&lt;count&gt;2&lt;/count&gt;)), xml
  end
  
  class Namespaced &lt; Hash
  end
  def test_to_xml_with_namespaced_classes
    xml = [Namespaced.new(:name =&gt; &quot;David&quot;)].to_xml
    assert_match(/&lt;array\-to\-xml\-tests\-namespaceds/, xml)
  end

  def test_to_xml_with_empty
    xml = [].to_xml
    assert_match(/type=&quot;array&quot;\/&gt;/, xml)
  end
end

class ArrayExtractOptionsTests &lt; Test::Unit::TestCase
  def test_extract_options
    assert_equal({}, [].extract_options!)
    assert_equal({}, [1].extract_options!)
    assert_equal({:a=&gt;:b}, [{:a=&gt;:b}].extract_options!)
    assert_equal({:a=&gt;:b}, [1, {:a=&gt;:b}].extract_options!)
  end
end

class ArrayExtRandomTests &lt; ActiveSupport::TestCase
  def test_random_element_from_array
    assert_nil [].random_element

    Kernel.expects(:rand).with(1).returns(0)
    assert_equal 'x', ['x'].random_element

    Kernel.expects(:rand).with(3).returns(1)
    assert_equal 2, [1, 2, 3].random_element
  end

  def test_deprecated_rand_on_array
    assert_deprecated { [].rand }
  end
end

class ArrayWrapperTests &lt; Test::Unit::TestCase
  class FakeCollection
    def to_ary
      [&quot;foo&quot;, &quot;bar&quot;]
    end
  end

  def test_array
    ary = %w(foo bar)
    assert_same ary, Array.wrap(ary)
  end

  def test_nil
    assert_equal [], Array.wrap(nil)
  end

  def test_object
    o = Object.new
    assert_equal [o], Array.wrap(o)
  end

  def test_string
    assert_equal [&quot;foo&quot;], Array.wrap(&quot;foo&quot;)
  end

  def test_string_with_newline
    assert_equal [&quot;foo\nbar&quot;], Array.wrap(&quot;foo\nbar&quot;)
  end

  def test_object_with_to_ary
    assert_equal [&quot;foo&quot;, &quot;bar&quot;], Array.wrap(FakeCollection.new)
  end
end
</pre>
    </div>