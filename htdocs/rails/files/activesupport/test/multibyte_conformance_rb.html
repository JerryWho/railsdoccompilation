  <div id="fileHeader">
    <h1>multibyte_conformance.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/test/multibyte_conformance.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:54 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># encoding: utf-8

require 'abstract_unit'
require 'multibyte_test_helpers'

require 'fileutils'
require 'open-uri'
require 'tmpdir'

class Downloader
  def self.download(from, to)
    unless File.exist?(to)
      $stderr.puts &quot;Downloading #{from} to #{to}&quot;
      unless File.exist?(File.dirname(to))
        system &quot;mkdir -p #{File.dirname(to)}&quot;
      end
      open(from) do |source|
        File.open(to, 'w') do |target|
          source.each_line do |l|
            target.write l
          end
        end
       end
     end
  end
end

class MultibyteConformanceTest &lt; Test::Unit::TestCase
  include MultibyteTestHelpers
  
  UNIDATA_URL = &quot;http://www.unicode.org/Public/#{ActiveSupport::Multibyte::UNICODE_VERSION}/ucd&quot;
  UNIDATA_FILE = '/NormalizationTest.txt'
  CACHE_DIR = File.join(Dir.tmpdir, 'cache')
  
  def setup
    FileUtils.mkdir_p(CACHE_DIR)
    Downloader.download(UNIDATA_URL + UNIDATA_FILE, CACHE_DIR + UNIDATA_FILE)
    @proxy = ActiveSupport::Multibyte::Chars
  end
  
  def test_normalizations_C
    each_line_of_norm_tests do |*cols|
      col1, col2, col3, col4, col5, comment = *cols
      
      # CONFORMANCE:
      # 1. The following invariants must be true for all conformant implementations
      #
      #    NFC
      #      c2 ==  NFC(c1) ==  NFC(c2) ==  NFC(c3)
      assert_equal_codepoints col2, @proxy.new(col1).normalize(:c), &quot;Form C - Col 2 has to be NFC(1) - #{comment}&quot;
      assert_equal_codepoints col2, @proxy.new(col2).normalize(:c), &quot;Form C - Col 2 has to be NFC(2) - #{comment}&quot;
      assert_equal_codepoints col2, @proxy.new(col3).normalize(:c), &quot;Form C - Col 2 has to be NFC(3) - #{comment}&quot;
      #
      #      c4 ==  NFC(c4) ==  NFC(c5)
      assert_equal_codepoints col4, @proxy.new(col4).normalize(:c), &quot;Form C - Col 4 has to be C(4) - #{comment}&quot;
      assert_equal_codepoints col4, @proxy.new(col5).normalize(:c), &quot;Form C - Col 4 has to be C(5) - #{comment}&quot;
    end
  end
  
  def test_normalizations_D
    each_line_of_norm_tests do |*cols|
      col1, col2, col3, col4, col5, comment = *cols
      #
      #    NFD
      #      c3 ==  NFD(c1) ==  NFD(c2) ==  NFD(c3)
      assert_equal_codepoints col3, @proxy.new(col1).normalize(:d), &quot;Form D - Col 3 has to be NFD(1) - #{comment}&quot;
      assert_equal_codepoints col3, @proxy.new(col2).normalize(:d), &quot;Form D - Col 3 has to be NFD(2) - #{comment}&quot;
      assert_equal_codepoints col3, @proxy.new(col3).normalize(:d), &quot;Form D - Col 3 has to be NFD(3) - #{comment}&quot;
      #      c5 ==  NFD(c4) ==  NFD(c5)
      assert_equal_codepoints col5, @proxy.new(col4).normalize(:d), &quot;Form D - Col 5 has to be NFD(4) - #{comment}&quot;
      assert_equal_codepoints col5, @proxy.new(col5).normalize(:d), &quot;Form D - Col 5 has to be NFD(5) - #{comment}&quot;
    end
  end
  
  def test_normalizations_KC
    each_line_of_norm_tests do | *cols |
      col1, col2, col3, col4, col5, comment = *cols  
      #
      #    NFKC
      #      c4 == NFKC(c1) == NFKC(c2) == NFKC(c3) == NFKC(c4) == NFKC(c5)
      assert_equal_codepoints col4, @proxy.new(col1).normalize(:kc), &quot;Form D - Col 4 has to be NFKC(1) - #{comment}&quot;
      assert_equal_codepoints col4, @proxy.new(col2).normalize(:kc), &quot;Form D - Col 4 has to be NFKC(2) - #{comment}&quot;
      assert_equal_codepoints col4, @proxy.new(col3).normalize(:kc), &quot;Form D - Col 4 has to be NFKC(3) - #{comment}&quot;
      assert_equal_codepoints col4, @proxy.new(col4).normalize(:kc), &quot;Form D - Col 4 has to be NFKC(4) - #{comment}&quot;
      assert_equal_codepoints col4, @proxy.new(col5).normalize(:kc), &quot;Form D - Col 4 has to be NFKC(5) - #{comment}&quot;
    end
  end
  
  def test_normalizations_KD
    each_line_of_norm_tests do | *cols |
      col1, col2, col3, col4, col5, comment = *cols  
      #
      #    NFKD
      #      c5 == NFKD(c1) == NFKD(c2) == NFKD(c3) == NFKD(c4) == NFKD(c5)
      assert_equal_codepoints col5, @proxy.new(col1).normalize(:kd), &quot;Form KD - Col 5 has to be NFKD(1) - #{comment}&quot;
      assert_equal_codepoints col5, @proxy.new(col2).normalize(:kd), &quot;Form KD - Col 5 has to be NFKD(2) - #{comment}&quot;
      assert_equal_codepoints col5, @proxy.new(col3).normalize(:kd), &quot;Form KD - Col 5 has to be NFKD(3) - #{comment}&quot;
      assert_equal_codepoints col5, @proxy.new(col4).normalize(:kd), &quot;Form KD - Col 5 has to be NFKD(4) - #{comment}&quot;
      assert_equal_codepoints col5, @proxy.new(col5).normalize(:kd), &quot;Form KD - Col 5 has to be NFKD(5) - #{comment}&quot;
    end
  end
  
  protected
    def each_line_of_norm_tests(&amp;block)
      lines = 0
      max_test_lines = 0 # Don't limit below 38, because that's the header of the testfile
      File.open(File.join(CACHE_DIR, UNIDATA_FILE), 'r') do | f |
        until f.eof? || (max_test_lines &gt; 38 and lines &gt; max_test_lines)
          lines += 1
          line = f.gets.chomp!
          next if (line.empty? || line =~ /^\#/)      
          
          cols, comment = line.split(&quot;#&quot;)
          cols = cols.split(&quot;;&quot;).map{|e| e.strip}.reject{|e| e.empty? }
          next unless cols.length == 5
          
          # codepoints are in hex in the test suite, pack wants them as integers
          cols.map!{|c| c.split.map{|codepoint| codepoint.to_i(16)}.pack(&quot;U*&quot;) }
          cols &lt;&lt; comment
          
          yield(*cols)
        end
      end
    end
    
    def inspect_codepoints(str)
      str.to_s.unpack(&quot;U*&quot;).map{|cp| cp.to_s(16) }.join(' ')
    end
end</pre>
    </div>