  <div id="fileHeader">
    <h1>buffered_logger_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/test/buffered_logger_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:54 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'abstract_unit'
require 'stringio'
require 'fileutils'

class BufferedLoggerTest &lt; Test::Unit::TestCase
  def setup
    @message = &quot;A debug message&quot;
    @integer_message = 12345
    @output  = StringIO.new
    @logger  = ActiveSupport::BufferedLogger.new(@output)
  end

  def test_should_log_debugging_message_when_debugging
    @logger.level = Logger::DEBUG
    @logger.add(Logger::DEBUG, @message)
    assert @output.string.include?(@message)
  end

  def test_should_not_log_debug_messages_when_log_level_is_info
    @logger.level = Logger::INFO
    @logger.add(Logger::DEBUG, @message)
    assert ! @output.string.include?(@message)
  end

  def test_should_add_message_passed_as_block_when_using_add
    @logger.level = Logger::INFO
    @logger.add(Logger::INFO) {@message}
    assert @output.string.include?(@message)
  end

  def test_should_add_message_passed_as_block_when_using_shortcut
    @logger.level = Logger::INFO
    @logger.info {@message}
    assert @output.string.include?(@message)
  end

  def test_should_convert_message_to_string
    @logger.level = Logger::INFO
    @logger.info @integer_message
    assert @output.string.include?(@integer_message.to_s)
  end

  def test_should_convert_message_to_string_when_passed_in_block
    @logger.level = Logger::INFO
    @logger.info {@integer_message}
    assert @output.string.include?(@integer_message.to_s)
  end

  def test_should_not_evaluate_block_if_message_wont_be_logged
    @logger.level = Logger::INFO
    evaluated = false
    @logger.add(Logger::DEBUG) {evaluated = true}
    assert evaluated == false
  end

  def test_should_not_mutate_message
    message_copy = @message.dup
    @logger.info @message
    assert_equal message_copy, @message
  end


  [false, nil, 0].each do |disable|
    define_method &quot;test_disabling_auto_flush_with_#{disable.inspect}_should_buffer_until_explicit_flush&quot; do
      @logger.auto_flushing = disable

      4.times do
        @logger.info 'wait for it..'
        assert @output.string.empty?, &quot;@output.string should be empty but it is #{@output.string}&quot;
      end

      @logger.flush
      assert !@output.string.empty?, &quot;@logger.send(:buffer).size.to_s should not be empty but it is empty&quot;
    end

    define_method &quot;test_disabling_auto_flush_with_#{disable.inspect}_should_flush_at_max_buffer_size_as_failsafe&quot; do
      @logger.auto_flushing = disable
      assert_equal ActiveSupport::BufferedLogger::MAX_BUFFER_SIZE, @logger.auto_flushing

      (ActiveSupport::BufferedLogger::MAX_BUFFER_SIZE - 1).times do
        @logger.info 'wait for it..'
        assert @output.string.empty?, &quot;@output.string should be empty but is #{@output.string}&quot;
      end

      @logger.info 'there it is.'
      assert !@output.string.empty?, &quot;@logger.send(:buffer).size.to_s should not be empty but it is empty&quot;
    end
  end

  def test_should_know_if_its_loglevel_is_below_a_given_level
    ActiveSupport::BufferedLogger::Severity.constants.each do |level|
      @logger.level = ActiveSupport::BufferedLogger::Severity.const_get(level) - 1
      assert @logger.send(&quot;#{level.downcase}?&quot;), &quot;didn't know if it was #{level.downcase}? or below&quot;
    end
  end

  def test_should_auto_flush_every_n_messages
    @logger.auto_flushing = 5

    4.times do
      @logger.info 'wait for it..'
      assert @output.string.empty?, &quot;@output.string should be empty but it is #{@output.string}&quot;
    end

    @logger.info 'there it is.'
    assert !@output.string.empty?, &quot;@output.string should not be empty but it is empty&quot;
  end

  def test_should_create_the_log_directory_if_it_doesnt_exist
    tmp_directory = File.join(File.dirname(__FILE__), &quot;tmp&quot;)
    log_file = File.join(tmp_directory, &quot;development.log&quot;)
    assert !File.exist?(tmp_directory)
    @logger  = ActiveSupport::BufferedLogger.new(log_file)
    assert File.exist?(tmp_directory)
  ensure
    FileUtils.rm_rf(tmp_directory)
  end

  def test_logger_should_maintain_separate_buffers_for_each_thread
    @logger.auto_flushing = false

    a = Thread.new do
      @logger.info(&quot;a&quot;); Thread.pass;
      @logger.info(&quot;b&quot;); Thread.pass;
      @logger.info(&quot;c&quot;); @logger.flush
    end

    b = Thread.new do
      @logger.info(&quot;x&quot;); Thread.pass;
      @logger.info(&quot;y&quot;); Thread.pass;
      @logger.info(&quot;z&quot;); @logger.flush
    end

    a.join
    b.join

    assert @output.string.include?(&quot;a\nb\nc\n&quot;)
    assert @output.string.include?(&quot;x\ny\nz\n&quot;)
  end

  def test_flush_should_remove_empty_buffers
    @logger.send :buffer
    @logger.expects :clear_buffer
    @logger.flush
  end
end
</pre>
    </div>