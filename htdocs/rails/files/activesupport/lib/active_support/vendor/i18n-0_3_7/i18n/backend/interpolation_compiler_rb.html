  <div id="fileHeader">
    <h1>interpolation_compiler.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/lib/active_support/vendor/i18n-0.3.7/i18n/backend/interpolation_compiler.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># encoding: utf-8

# The InterpolationCompiler module contains optimizations that can tremendously
# speed up the interpolation process on the Simple backend.
#
# It works by defining a pre-compiled method on stored translation Strings that
# already bring all the knowledge about contained interpolation variables etc.
# so that the actual recurring interpolation will be very fast.
#
# To enable pre-compiled interpolations you can simply include the
# InterpolationCompiler module to the Simple backend:
#
#   I18n::Backend::Simple.send(:include, I18n::Backend::InterpolationCompiler)
module I18n
  module Backend
    module InterpolationCompiler
      module Compiler
        extend self

        TOKENIZER                    = /(\\\{\{[^\}]+\}\}|\{\{[^\}]+\}\})/
        INTERPOLATION_SYNTAX_PATTERN = /(\\)?(\{\{([^\}]+)\}\})/

        def compile_if_an_interpolation(string)
          if interpolated_str?(string)
            string.instance_eval &lt;&lt;-RUBY_EVAL, __FILE__, __LINE__
              def i18n_interpolate(v = {})
                &quot;#{compiled_interpolation_body(string)}&quot;
              end
            RUBY_EVAL
          end

          string
        end

        def interpolated_str?(str)
          str.kind_of?(::String) &amp;&amp; str =~ INTERPOLATION_SYNTAX_PATTERN
        end

        protected
        # tokenize(&quot;foo {{bar}} baz \\{{buz}}&quot;) # =&gt; [&quot;foo &quot;, &quot;{{bar}}&quot;, &quot; baz &quot;, &quot;\\{{buz}}&quot;]
        def tokenize(str)
          str.split(TOKENIZER)
        end

        def compiled_interpolation_body(str)
          tokenize(str).map do |token|
            (matchdata = token.match(INTERPOLATION_SYNTAX_PATTERN)) ? handle_interpolation_token(token, matchdata) : escape_plain_str(token)
          end.join
        end

        def handle_interpolation_token(interpolation, matchdata)
          escaped, pattern, key = matchdata.values_at(1, 2, 3)
          escaped ? pattern : compile_interpolation_token(key.to_sym)
        end

        def compile_interpolation_token(key)
          &quot;\#{#{interpolate_or_raise_missing(key)}}&quot;
        end

        def interpolate_or_raise_missing(key)
          escaped_key = escape_key_sym(key)
          Base::RESERVED_KEYS.include?(key) ? reserved_key(escaped_key) : interpolate_key(escaped_key)
        end

        def interpolate_key(key)
          [direct_key(key), nil_key(key), missing_key(key)].join('||')
        end

        def direct_key(key)
          &quot;((t = v[#{key}]) &amp;&amp; t.respond_to?(:call) ? t.call : t)&quot;
        end

        def nil_key(key)
          &quot;(v.has_key?(#{key}) &amp;&amp; '')&quot;
        end

        def missing_key(key)
          &quot;raise(MissingInterpolationArgument.new(#{key}, self))&quot;
        end

        def reserved_key(key)
          &quot;raise(ReservedInterpolationKey.new(#{key}, self))&quot;
        end

        def escape_plain_str(str)
          str.gsub(/&quot;|\\|#/) {|x| &quot;\\#{x}&quot;}
        end

        def escape_key_sym(key)
          # rely on Ruby to do all the hard work :)
          key.to_sym.inspect
        end
      end

      def interpolate(locale, string, values)
        if string.respond_to?(:i18n_interpolate)
          string.i18n_interpolate(values)
        elsif values
          super
        else
          string
        end
      end

      def merge_translations(locale, data, options = {})
        compile_all_strings_in(data)
        super
      end

      protected
      def compile_all_strings_in(data)
        data.each_value do |value|
          Compiler.compile_if_an_interpolation(value)
          compile_all_strings_in(value) if value.kind_of?(Hash)
        end
      end
    end
  end
end</pre>
    </div>