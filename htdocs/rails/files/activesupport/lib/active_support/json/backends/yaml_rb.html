  <div id="fileHeader">
    <h1>yaml.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/lib/active_support/json/backends/yaml.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:55:10 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'active_support/core_ext/string/starts_ends_with'

module ActiveSupport
  module JSON
    unless const_defined?(:ParseError)
      class ParseError &lt; StandardError
      end
    end

    module Backends
      module Yaml
        extend self

        # Converts a JSON string into a Ruby object.
        def decode(json)
          YAML.load(convert_json_to_yaml(json))
        rescue ArgumentError =&gt; e
          raise ParseError, &quot;Invalid JSON string&quot;
        end

        protected
          # Ensure that &quot;:&quot; and &quot;,&quot; are always followed by a space
          def convert_json_to_yaml(json) #:nodoc:
            require 'strscan' unless defined? ::StringScanner
            scanner, quoting, marks, pos, times = ::StringScanner.new(json), false, [], nil, []
            while scanner.scan_until(/(\\['&quot;]|['&quot;:,\\]|\\.)/)
              case char = scanner[1]
              when '&quot;', &quot;'&quot;
                if !quoting
                  quoting = char
                  pos = scanner.pos
                elsif quoting == char
                  if json[pos..scanner.pos-2] =~ DATE_REGEX
                    # found a date, track the exact positions of the quotes so we can remove them later.
                    # oh, and increment them for each current mark, each one is an extra padded space that bumps
                    # the position in the final YAML output
                    total_marks = marks.size
                    times &lt;&lt; pos+total_marks &lt;&lt; scanner.pos+total_marks
                  end
                  quoting = false
                end
              when &quot;:&quot;,&quot;,&quot;
                marks &lt;&lt; scanner.pos - 1 unless quoting
              when &quot;\\&quot;
                scanner.skip(/\\/)
              end
            end

            if marks.empty?
              json.gsub(/\\([\\\/]|u[[:xdigit:]]{4})/) do
                ustr = $1
                if ustr.start_with?('u')
                  [ustr[1..-1].to_i(16)].pack(&quot;U&quot;)
                elsif ustr == '\\'
                  '\\\\'
                else
                  ustr
                end
              end
            else
              left_pos  = [-1].push(*marks)
              right_pos = marks &lt;&lt; scanner.pos + scanner.rest_size
              output    = []
              left_pos.each_with_index do |left, i|
                scanner.pos = left.succ
                output &lt;&lt; scanner.peek(right_pos[i] - scanner.pos + 1).gsub(/\\([\\\/]|u[[:xdigit:]]{4})/) do
                  ustr = $1
                  if ustr.start_with?('u')
                    [ustr[1..-1].to_i(16)].pack(&quot;U&quot;)
                  elsif ustr == '\\'
                    '\\\\'
                  else
                    ustr
                  end
                end
              end
              output = output * &quot; &quot;

              times.each { |i| output[i-1] = ' ' }
              output.gsub!(/\\\//, '/')
              output
            end
          end
      end
    end
  end
end

</pre>
    </div>