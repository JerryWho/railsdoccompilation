  <div id="fileHeader">
    <h1>validations_i18n_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/validations_i18n_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'models/topic'
require 'models/reply'
require 'models/person'

module ActiveRecordValidationsI18nTestHelper
  def store_translations(*args)
    data = args.extract_options!
    locale = args.shift || 'en'
    I18n.backend.send(:init_translations)
    I18n.backend.store_translations(locale, :activerecord =&gt; data)
  end

  def delete_translation(key)
    I18n.backend.instance_eval do
      keys = I18n.send(:normalize_translation_keys, 'en', key, nil)
      keys.inject(translations) { |result, k| keys.last == k ? result.delete(k.to_sym) : result[k.to_sym] }
    end
  end

  def reset_callbacks(*models)
    models.each do |model|
      model.instance_variable_set(&quot;@validate_callbacks&quot;, ActiveSupport::Callbacks::CallbackChain.new)
      model.instance_variable_set(&quot;@validate_on_create_callbacks&quot;, ActiveSupport::Callbacks::CallbackChain.new)
      model.instance_variable_set(&quot;@validate_on_update_callbacks&quot;, ActiveSupport::Callbacks::CallbackChain.new)
    end
  end
end


# ACTIVERECORD VALIDATIONS
#
# For each validation:
#
# * test expect that it adds an error with the appropriate arguments
# * test that it looks up the correct default message

class ActiveRecordValidationsI18nTests &lt; ActiveSupport::TestCase
  include ActiveRecordValidationsI18nTestHelper

  def setup
    reset_callbacks(Topic)
    @topic = Topic.new
    @reply = Reply.new
    @old_load_path, @old_backend = I18n.load_path, I18n.backend
    I18n.load_path.clear
    I18n.backend = I18n::Backend::Simple.new
    I18n.backend.store_translations('en', :activerecord =&gt; {:errors =&gt; {:messages =&gt; {:custom =&gt; nil}}})
  end

  def teardown
    reset_callbacks(Topic)
    I18n.load_path.replace(@old_load_path)
    I18n.backend = @old_backend
  end

  def expect_error_added(model, attribute, type, options)
    model.errors.expects(:add).with(attribute, type, options)
    yield
    model.valid?
  end

  def assert_message_translations(model, attribute, type, &amp;block)
    assert_default_message_translation(model, attribute, type, &amp;block)
    reset_callbacks(model.class)
    model.errors.clear
    assert_custom_message_translation(model, attribute, type, &amp;block)
  end

  def assert_custom_message_translation(model, attribute, type)
    store_translations(:errors =&gt; { :models =&gt; { model.class.name.underscore =&gt; { :attributes =&gt; { attribute =&gt; { type =&gt; 'custom message' } } } } })
    yield
    model.valid?
    assert_equal 'custom message', model.errors.on(attribute)
  end

  def assert_default_message_translation(model, attribute, type)
    store_translations(:errors =&gt; { :messages =&gt; { type =&gt; 'default message' } })
    yield
    model.valid?
    assert_equal 'default message', model.errors.on(attribute)
  end

  def unique_topic
    @unique ||= Topic.create(:title =&gt; 'unique!')
  end

  def replied_topic
    @replied_topic ||= begin
      topic = Topic.create(:title =&gt; &quot;topic&quot;)
      topic.replies &lt;&lt; Reply.new
      topic
    end
  end

  # validates_confirmation_of

  test &quot;#validates_confirmation_of given no custom message&quot; do
    expect_error_added(@topic, :title, :confirmation, :default =&gt; nil) do
      Topic.validates_confirmation_of :title
      @topic.title = 'title'
      @topic.title_confirmation = 'foo'
    end
  end

  test &quot;#validates_confirmation_of given a custom message&quot; do
    expect_error_added(@topic, :title, :confirmation, :default =&gt; 'custom') do
      Topic.validates_confirmation_of :title, :message =&gt; 'custom'
      @topic.title_confirmation = 'foo'
    end
  end

  test &quot;#validates_confirmation_of finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :confirmation) do
      Topic.validates_confirmation_of :title
      @topic.title_confirmation = 'foo'
    end
  end

  # validates_acceptance_of

  test &quot;#validates_acceptance_of given no custom message&quot; do
    expect_error_added(@topic, :title, :accepted, :default =&gt; nil) do
      Topic.validates_acceptance_of :title, :allow_nil =&gt; false
    end
  end

  test &quot;#validates_acceptance_of given a custom message&quot; do
    expect_error_added(@topic, :title, :accepted, :default =&gt; 'custom') do
      Topic.validates_acceptance_of :title, :message =&gt; 'custom', :allow_nil =&gt; false
    end
  end

  test &quot;#validates_acceptance_of finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :accepted) do
      Topic.validates_acceptance_of :title, :allow_nil =&gt; false
    end
  end

  # validates_presence_of

  test &quot;#validates_presence_of given no custom message&quot; do
    expect_error_added(@topic, :title, :blank, :default =&gt; nil) do
      Topic.validates_presence_of :title
    end
  end

  test &quot;#validates_presence_of given a custom message&quot; do
    expect_error_added(@topic, :title, :blank, :default =&gt; 'custom') do
      Topic.validates_presence_of :title, :message =&gt; 'custom'
    end
  end

  test &quot;#validates_presence_of finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :blank) do
      Topic.validates_presence_of :title
    end
  end

  # validates_length_of :too_short

  test &quot;#validates_length_of (:too_short) and no custom message&quot; do
    expect_error_added(@topic, :title, :too_short, :default =&gt; nil, :count =&gt; 3) do
      Topic.validates_length_of :title, :within =&gt; 3..5
    end
  end

  test &quot;#validates_length_of (:too_short) and a custom message&quot; do
    expect_error_added(@topic, :title, :too_short, :default =&gt; 'custom', :count =&gt; 3) do
      Topic.validates_length_of :title, :within =&gt; 3..5, :too_short =&gt; 'custom'
    end
  end

  test &quot;#validates_length_of (:too_short) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :too_short) do
      Topic.validates_length_of :title, :within =&gt; 3..5
    end
  end

  # validates_length_of :too_long

  test &quot;#validates_length_of (:too_long) and no custom message&quot; do
    expect_error_added(@topic, :title, :too_long, :default =&gt; nil, :count =&gt; 5) do
      Topic.validates_length_of :title, :within =&gt; 3..5
      @topic.title = 'this title is too long'
    end
  end

  test &quot;#validates_length_of (:too_long) and a custom message&quot; do
    expect_error_added(@topic, :title, :too_long, :default =&gt; 'custom', :count =&gt; 5) do
      Topic.validates_length_of :title, :within =&gt; 3..5, :too_long =&gt; 'custom'
      @topic.title = 'this title is too long'
    end
  end

  test &quot;#validates_length_of (:too_long) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :too_long) do
      Topic.validates_length_of :title, :within =&gt; 3..5
      @topic.title = 'this title is too long'
    end
  end

  # validates_length_of :is

  test &quot;#validates_length_of (:is) and no custom message&quot; do
    expect_error_added(@topic, :title, :wrong_length, :default =&gt; nil, :count =&gt; 5) do
      Topic.validates_length_of :title, :is =&gt; 5
      @topic.title = 'this title has the wrong length'
    end
  end

  test &quot;#validates_length_of (:is) and a custom message&quot; do
    expect_error_added(@topic, :title, :wrong_length, :default =&gt; 'custom', :count =&gt; 5) do
      Topic.validates_length_of :title, :is =&gt; 5, :wrong_length =&gt; 'custom'
      @topic.title = 'this title has the wrong length'
    end
  end

  test &quot;#validates_length_of (:is) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :wrong_length) do
      Topic.validates_length_of :title, :is =&gt; 5
      @topic.title = 'this title has the wrong length'
    end
  end

  # validates_uniqueness_of

  test &quot;#validates_uniqueness_of and no custom message&quot; do
    expect_error_added(@topic, :title, :taken, :default =&gt; nil, :value =&gt; 'unique!') do
      Topic.validates_uniqueness_of :title
      @topic.title = unique_topic.title
    end
  end

  test &quot;#validates_uniqueness_of and a custom message&quot; do
    expect_error_added(@topic, :title, :taken, :default =&gt; 'custom', :value =&gt; 'unique!') do
      Topic.validates_uniqueness_of :title, :message =&gt; 'custom'
      @topic.title = unique_topic.title
    end
  end

  test &quot;#validates_uniqueness_of finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :taken) do
      Topic.validates_uniqueness_of :title
      @topic.title = unique_topic.title
    end
  end

  # validates_format_of

  test &quot;#validates_format_of and no custom message&quot; do
    expect_error_added(@topic, :title, :invalid, :default =&gt; nil, :value =&gt; '72x') do
      Topic.validates_format_of :title, :with =&gt; /^[1-9][0-9]*$/
      @topic.title = '72x'
    end
  end

  test &quot;#validates_format_of and a custom message&quot; do
    expect_error_added(@topic, :title, :invalid, :default =&gt; 'custom', :value =&gt; '72x') do
      Topic.validates_format_of :title, :with =&gt; /^[1-9][0-9]*$/, :message =&gt; 'custom'
      @topic.title = '72x'
    end
  end

  test &quot;#validates_format_of finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :invalid) do
      Topic.validates_format_of :title, :with =&gt; /^[1-9][0-9]*$/
      @topic.title = '72x'
    end
  end

  # validates_inclusion_of

  test &quot;#validates_inclusion_of and no custom message&quot; do
    list = %w(a b c)
    expect_error_added(@topic, :title, :inclusion, :default =&gt; nil, :value =&gt; 'z') do
      Topic.validates_inclusion_of :title, :in =&gt; list
      @topic.title = 'z'
    end
  end

  test &quot;#validates_inclusion_of and a custom message&quot; do
    list = %w(a b c)
    expect_error_added(@topic, :title, :inclusion, :default =&gt; 'custom', :value =&gt; 'z') do
      Topic.validates_inclusion_of :title, :in =&gt; list, :message =&gt; 'custom'
      @topic.title = 'z'
    end
  end

  test &quot;#validates_inclusion_of finds the correct message translations&quot; do
    list = %w(a b c)
    assert_message_translations(@topic, :title, :inclusion) do
      Topic.validates_inclusion_of :title, :in =&gt; list
      @topic.title = 'z'
    end
  end

  # validates_exclusion_of

  test &quot;#validates_exclusion_of and no custom message&quot; do
    list = %w(a b c)
    expect_error_added(@topic, :title, :exclusion, :default =&gt; nil, :value =&gt; 'a') do
      Topic.validates_exclusion_of :title, :in =&gt; list
      @topic.title = 'a'
    end
  end

  test &quot;#validates_exclusion_of and a custom message&quot; do
    list = %w(a b c)
    expect_error_added(@topic, :title, :exclusion, :default =&gt; 'custom', :value =&gt; 'a') do
      Topic.validates_exclusion_of :title, :in =&gt; list, :message =&gt; 'custom'
      @topic.title = 'a'
    end
  end

  test &quot;#validates_exclusion_of finds the correct message translations&quot; do
    list = %w(a b c)
    assert_message_translations(@topic, :title, :exclusion) do
      Topic.validates_exclusion_of :title, :in =&gt; list
      @topic.title = 'a'
    end
  end

  # validates_numericality_of :not_a_number, without :only_integer

  test &quot;#validates_numericality_of (:not_a_number, w/o :only_integer) no custom message&quot; do
    expect_error_added(@topic, :title, :not_a_number, :default =&gt; nil, :value =&gt; 'a') do
      Topic.validates_numericality_of :title
      @topic.title = 'a'
    end
  end

  test &quot;#validates_numericality_of (:not_a_number, w/o :only_integer) and a custom message&quot; do
    expect_error_added(@topic, :title, :not_a_number, :default =&gt; 'custom', :value =&gt; 'a') do
      Topic.validates_numericality_of :title, :message =&gt; 'custom'
      @topic.title = 'a'
    end
  end

  test &quot;#validates_numericality_of (:not_a_number, w/o :only_integer) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :not_a_number) do
      Topic.validates_numericality_of :title
      @topic.title = 'a'
    end
  end

  # validates_numericality_of :not_a_number, with :only_integer

  test &quot;#validates_numericality_of (:not_a_number, with :only_integer) no custom message&quot; do
    expect_error_added(@topic, :title, :not_a_number, :default =&gt; nil, :value =&gt; 'a') do
      Topic.validates_numericality_of :title, :only_integer =&gt; true
      @topic.title = 'a'
    end
  end

  test &quot;#validates_numericality_of (:not_a_number, with :only_integer) and a custom message&quot; do
    expect_error_added(@topic, :title, :not_a_number, :default =&gt; 'custom', :value =&gt; 'a') do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :message =&gt; 'custom'
      @topic.title = 'a'
    end
  end

  test &quot;#validates_numericality_of (:not_a_number, with :only_integer) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :not_a_number) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true
      @topic.title = 'a'
    end
  end

  # validates_numericality_of :odd

  test &quot;#validates_numericality_of (:odd) no custom message&quot; do
    expect_error_added(@topic, :title, :odd, :default =&gt; nil, :value =&gt; 0) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :odd =&gt; true
      @topic.title = 0
    end
  end

  test &quot;#validates_numericality_of (:odd) and a custom message&quot; do
    expect_error_added(@topic, :title, :odd, :default =&gt; 'custom', :value =&gt; 0) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :odd =&gt; true, :message =&gt; 'custom'
      @topic.title = 0
    end
  end

  test &quot;#validates_numericality_of (:odd) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :odd) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :odd =&gt; true
      @topic.title = 0
    end
  end

  # validates_numericality_of :even

  test &quot;#validates_numericality_of (:even) no custom message&quot; do
    expect_error_added(@topic, :title, :even, :default =&gt; nil, :value =&gt; 1) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :even =&gt; true
      @topic.title = 1
    end
  end

  test &quot;#validates_numericality_of (:even) and a custom message&quot; do
    expect_error_added(@topic, :title, :even, :default =&gt; 'custom', :value =&gt; 1) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :even =&gt; true, :message =&gt; 'custom'
      @topic.title = 1
    end
  end

  test &quot;#validates_numericality_of (:even) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :even) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :even =&gt; true
      @topic.title = 1
    end
  end

  # validates_numericality_of :less_than

  test &quot;#validates_numericality_of (:less_than) no custom message&quot; do
    expect_error_added(@topic, :title, :less_than, :default =&gt; nil, :value =&gt; 1, :count =&gt; 0) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :less_than =&gt; 0
      @topic.title = 1
    end
  end

  test &quot;#validates_numericality_of (:less_than) and a custom message&quot; do
    expect_error_added(@topic, :title, :less_than, :default =&gt; 'custom', :value =&gt; 1, :count =&gt; 0) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :less_than =&gt; 0, :message =&gt; 'custom'
      @topic.title = 1
    end
  end

  test &quot;#validates_numericality_of (:less_than) finds the correct message translations&quot; do
    assert_message_translations(@topic, :title, :less_than) do
      Topic.validates_numericality_of :title, :only_integer =&gt; true, :less_than =&gt; 0
      @topic.title = 1
    end
  end

  # validates_associated

  test &quot;#validates_associated no custom message&quot; do
    expect_error_added(replied_topic, :replies, :invalid, :default =&gt; nil, :value =&gt; replied_topic.replies) do
      Topic.validates_associated :replies
    end
  end

  test &quot;#validates_associated and a custom message&quot; do
    expect_error_added(replied_topic, :replies, :invalid, :default =&gt; 'custom', :value =&gt; replied_topic.replies) do
      Topic.validates_associated :replies, :message =&gt; 'custom'
    end
  end

  test &quot;#validates_associated finds the correct message translations&quot; do
    assert_message_translations(replied_topic, :replies, :invalid) do
      Topic.validates_associated :replies
    end
  end
end


# ACTIVERECORD ERROR
#
# * test that it passes given interpolation arguments, the human model name and human attribute name
# * test that it looks messages up with the the correct keys
# * test that it looks up the correct default messages

class ActiveRecordErrorI18nTests &lt; ActiveSupport::TestCase
  include ActiveRecordValidationsI18nTestHelper

  def setup
    @reply = Reply.new
    @old_backend, I18n.backend = I18n.backend, I18n::Backend::Simple.new
  end

  def teardown
    I18n.backend = @old_backend
    I18n.locale = nil
  end

  def assert_error_message(message, *args)
    assert_equal message, ActiveRecord::Error.new(@reply, *args).message
  end

  def assert_full_message(message, *args)
    assert_equal message, ActiveRecord::Error.new(@reply, *args).full_message
  end

  test &quot;:default is only given to message if a symbol is supplied&quot; do
    store_translations(:errors =&gt; { :messages =&gt; { :&quot;foo bar&quot; =&gt; &quot;You fooed: {{value}}.&quot; } })
    @reply.errors.add(:title, :inexistent, :default =&gt; &quot;foo bar&quot;)
    assert_equal &quot;foo bar&quot;, @reply.errors[:title]
  end

  test &quot;#generate_message passes the model attribute value for interpolation&quot; do
    store_translations(:errors =&gt; { :messages =&gt; { :foo =&gt; &quot;You fooed: {{value}}.&quot; } })
    @reply.title = &quot;da title&quot;
    assert_error_message 'You fooed: da title.', :title, :foo
  end

  test &quot;#generate_message passes the human_name of the model for interpolation&quot; do
    store_translations(
      :errors =&gt; { :messages =&gt; { :foo =&gt; &quot;You fooed: {{model}}.&quot; } },
      :models =&gt; { :topic =&gt; 'da topic' }
    )
    assert_error_message 'You fooed: da topic.', :title, :foo
  end

  test &quot;#generate_message passes the human_name of the attribute for interpolation&quot; do
    store_translations(
      :errors =&gt; { :messages =&gt; { :foo =&gt; &quot;You fooed: {{attribute}}.&quot; } },
      :attributes =&gt; { :topic =&gt; { :title =&gt; 'da topic title' } }
    )
    assert_error_message 'You fooed: da topic title.', :title, :foo
  end

  # generate_message will look up the key for the error message (e.g. :blank) in these namespaces:
  #
  #   activerecord.errors.models.reply.attributes.title
  #   activerecord.errors.models.reply
  #   activerecord.errors.models.topic.attributes.title
  #   activerecord.errors.models.topic
  #   [default from class level :validates_foo statement if this is a String]
  #   activerecord.errors.messages

  test &quot;#generate_message key fallbacks (given a String as key)&quot; do
    store_translations(
      :errors =&gt; {
        :models =&gt; {
          :reply =&gt; {
            :attributes =&gt; { :title =&gt; { :custom =&gt; 'activerecord.errors.models.reply.attributes.title.custom' } },
            :custom =&gt; 'activerecord.errors.models.reply.custom'
          },
          :topic =&gt; {
            :attributes =&gt; { :title =&gt; { :custom =&gt; 'activerecord.errors.models.topic.attributes.title.custom' } },
            :custom =&gt; 'activerecord.errors.models.topic.custom'
          }
        },
        :messages =&gt; {
          :custom =&gt; 'activerecord.errors.messages.custom',
          :kaputt =&gt; 'activerecord.errors.messages.kaputt'
        }
      }
    )

    assert_error_message 'activerecord.errors.models.reply.attributes.title.custom', :title, :kaputt, :message =&gt; 'custom'
    delete_translation  :'activerecord.errors.models.reply.attributes.title.custom'

    assert_error_message 'activerecord.errors.models.reply.custom', :title, :kaputt, :message =&gt; 'custom'
    delete_translation  :'activerecord.errors.models.reply.custom'

    assert_error_message 'activerecord.errors.models.topic.attributes.title.custom', :title, :kaputt, :message =&gt; 'custom'
    delete_translation  :'activerecord.errors.models.topic.attributes.title.custom'

    assert_error_message 'activerecord.errors.models.topic.custom', :title, :kaputt, :message =&gt; 'custom'
    delete_translation  :'activerecord.errors.models.topic.custom'

    assert_error_message 'activerecord.errors.messages.custom', :title, :kaputt, :message =&gt; 'custom'
    delete_translation  :'activerecord.errors.messages.custom'

    # Implementing this would clash with the AR default behaviour of using validates_foo :message =&gt; 'foo'
    # as an untranslated string. I.e. at this point we can either fall back to the given string from the
    # class-level macro (validates_*) or fall back to the default message for this validation type.
    # assert_error_message 'activerecord.errors.messages.kaputt', :title, :kaputt, :message =&gt; 'custom'

    assert_error_message 'custom', :title, :kaputt, :message =&gt; 'custom'
  end

  test &quot;#generate_message key fallbacks (given a Symbol as key)&quot; do
    store_translations(
      :errors =&gt; {
        :models =&gt; {
          :reply =&gt; {
            :attributes =&gt; { :title =&gt; { :kaputt =&gt; 'activerecord.errors.models.reply.attributes.title.kaputt' } },
            :kaputt =&gt; 'activerecord.errors.models.reply.kaputt'
          },
          :topic =&gt; {
            :attributes =&gt; { :title =&gt; { :kaputt =&gt; 'activerecord.errors.models.topic.attributes.title.kaputt' } },
            :kaputt =&gt; 'activerecord.errors.models.topic.kaputt'
          }
        },
        :messages =&gt; {
          :kaputt =&gt; 'activerecord.errors.messages.kaputt'
        }
      }
    )

    assert_error_message 'activerecord.errors.models.reply.attributes.title.kaputt', :title, :kaputt
    delete_translation  :'activerecord.errors.models.reply.attributes.title.kaputt'

    assert_error_message 'activerecord.errors.models.reply.kaputt', :title, :kaputt
    delete_translation  :'activerecord.errors.models.reply.kaputt'

    assert_error_message 'activerecord.errors.models.topic.attributes.title.kaputt', :title, :kaputt
    delete_translation  :'activerecord.errors.models.topic.attributes.title.kaputt'

    assert_error_message 'activerecord.errors.models.topic.kaputt', :title, :kaputt
    delete_translation  :'activerecord.errors.models.topic.kaputt'

    assert_error_message 'activerecord.errors.messages.kaputt', :title, :kaputt
  end

  # full_messages

  test &quot;#full_message with no format present&quot; do
    store_translations(:errors =&gt; { :messages =&gt; { :kaputt =&gt; 'is kaputt' } })
    assert_full_message 'Title is kaputt', :title, :kaputt
  end

  test &quot;#full_message with a format present&quot; do
    store_translations(:errors =&gt; { :messages =&gt; { :kaputt =&gt; 'is kaputt' }, :full_messages =&gt; { :format =&gt; '{{attribute}}: {{message}}' } })
    assert_full_message 'Title: is kaputt', :title, :kaputt
  end

  test &quot;#full_message with a type specific format present&quot; do
    store_translations(:errors =&gt; { :messages =&gt; { :kaputt =&gt; 'is kaputt' }, :full_messages =&gt; { :kaputt =&gt; '{{attribute}} {{message}}!' } })
    assert_full_message 'Title is kaputt!', :title, :kaputt
  end

  test &quot;#full_message with class-level specified custom message&quot; do
    store_translations(:errors =&gt; { :messages =&gt; { :broken =&gt; 'is kaputt' }, :full_messages =&gt; { :broken =&gt; '{{attribute}} {{message}}?!' } })
    assert_full_message 'Title is kaputt?!', :title, :kaputt, :message =&gt; :broken
  end

  test &quot;#full_message with different scope&quot; do
    store_translations(:my_errors =&gt; { :messages =&gt; { :kaputt =&gt; 'is kaputt' } })
    assert_full_message 'Title is kaputt', :title, :kaputt, :scope =&gt; [:activerecord, :my_errors]

    store_translations(:my_errors =&gt; { :full_messages =&gt; { :kaputt =&gt; '{{attribute}} {{message}}!' } })
    assert_full_message 'Title is kaputt!', :title, :kaputt, :scope =&gt; [:activerecord, :my_errors]
  end

  # switch locales

  test &quot;#message allows to switch locales&quot; do
    store_translations(:en, :errors =&gt; { :messages =&gt; { :kaputt =&gt; 'is kaputt' } })
    store_translations(:de, :errors =&gt; { :messages =&gt; { :kaputt =&gt; 'ist kaputt' } })

    assert_error_message 'is kaputt', :title, :kaputt
    I18n.locale = :de
    assert_error_message 'ist kaputt', :title, :kaputt
    I18n.locale = :en
    assert_error_message 'is kaputt', :title, :kaputt
  end

  test &quot;#full_message allows to switch locales&quot; do
    store_translations(:en, :errors =&gt; { :messages =&gt; { :kaputt =&gt; 'is kaputt' } }, :attributes =&gt; { :topic =&gt; { :title =&gt; 'The title' } })
    store_translations(:de, :errors =&gt; { :messages =&gt; { :kaputt =&gt; 'ist kaputt' } }, :attributes =&gt; { :topic =&gt; { :title =&gt; 'Der Titel' } })

    assert_full_message 'The title is kaputt', :title, :kaputt
    I18n.locale = :de
    assert_full_message 'Der Titel ist kaputt', :title, :kaputt
    I18n.locale = :en
    assert_full_message 'The title is kaputt', :title, :kaputt
  end
end

# ACTIVERECORD DEFAULT ERROR MESSAGES
#
# * test that Error generates the default error messages

class ActiveRecordDefaultErrorMessagesI18nTests &lt; ActiveSupport::TestCase
  def assert_default_error_message(message, *args)
    assert_equal message, error_message(*args)
  end

  def error_message(*args)
    ActiveRecord::Error.new(Topic.new, :title, *args).message
  end

  # used by: validates_inclusion_of
  test &quot;default error message: inclusion&quot; do
    assert_default_error_message 'is not included in the list', :inclusion, :value =&gt; 'title'
  end

  # used by: validates_exclusion_of
  test &quot;default error message: exclusion&quot; do
    assert_default_error_message 'is reserved', :exclusion, :value =&gt; 'title'
  end

  # used by: validates_associated and validates_format_of
  test &quot;default error message: invalid&quot; do
    assert_default_error_message 'is invalid', :invalid, :value =&gt; 'title'
  end

  # used by: validates_confirmation_of
  test &quot;default error message: confirmation&quot; do
    assert_default_error_message &quot;doesn't match confirmation&quot;, :confirmation, :default =&gt; nil
  end

  # used by: validates_acceptance_of
  test &quot;default error message: accepted&quot; do
    assert_default_error_message &quot;must be accepted&quot;, :accepted
  end

  # used by: add_on_empty
  test &quot;default error message: empty&quot; do
    assert_default_error_message &quot;can't be empty&quot;, :empty
  end

  # used by: add_on_blank
  test &quot;default error message: blank&quot; do
    assert_default_error_message &quot;can't be blank&quot;, :blank
  end

  # used by: validates_length_of
  test &quot;default error message: too_long&quot; do
    assert_default_error_message &quot;is too long (maximum is 10 characters)&quot;, :too_long, :count =&gt; 10
  end

  # used by: validates_length_of
  test &quot;default error message: too_short&quot; do
    assert_default_error_message &quot;is too short (minimum is 10 characters)&quot;, :too_short, :count =&gt; 10
  end

  # used by: validates_length_of
  test &quot;default error message: wrong_length&quot; do
    assert_default_error_message &quot;is the wrong length (should be 10 characters)&quot;, :wrong_length, :count =&gt; 10
  end

  # used by: validates_uniqueness_of
  test &quot;default error message: taken&quot; do
    assert_default_error_message &quot;has already been taken&quot;, :taken, :value =&gt; 'title'
  end

  # used by: validates_numericality_of
  test &quot;default error message: not_a_number&quot; do
    assert_default_error_message &quot;is not a number&quot;, :not_a_number, :value =&gt; 'title'
  end

  # used by: validates_numericality_of
  test &quot;default error message: greater_than&quot; do
    assert_default_error_message &quot;must be greater than 10&quot;, :greater_than, :value =&gt; 'title', :count =&gt; 10
  end

  # used by: validates_numericality_of
  test &quot;default error message: greater_than_or_equal_to&quot; do
    assert_default_error_message &quot;must be greater than or equal to 10&quot;, :greater_than_or_equal_to, :value =&gt; 'title', :count =&gt; 10
  end

  # used by: validates_numericality_of
  test &quot;default error message: equal_to&quot; do
    assert_default_error_message &quot;must be equal to 10&quot;, :equal_to, :value =&gt; 'title', :count =&gt; 10
  end

  # used by: validates_numericality_of
  test &quot;default error message: less_than&quot; do
    assert_default_error_message &quot;must be less than 10&quot;, :less_than, :value =&gt; 'title', :count =&gt; 10
  end

  # used by: validates_numericality_of
  test &quot;default error message: less_than_or_equal_to&quot; do
    assert_default_error_message &quot;must be less than or equal to 10&quot;, :less_than_or_equal_to, :value =&gt; 'title', :count =&gt; 10
  end

  # used by: validates_numericality_of
  test &quot;default error message: odd&quot; do
    assert_default_error_message &quot;must be odd&quot;, :odd, :value =&gt; 'title', :count =&gt; 10
  end

  # used by: validates_numericality_of
  test &quot;default error message: even&quot; do
    assert_default_error_message &quot;must be even&quot;, :even, :value =&gt; 'title', :count =&gt; 10
  end

  test &quot;custom message string interpolation&quot; do
    assert_equal 'custom message title', error_message(:invalid, :default =&gt; 'custom message {{value}}', :value =&gt; 'title')
  end
end

# ACTIVERECORD VALIDATION ERROR MESSAGES - FULL STACK
#
# * test a few combinations full stack to ensure the tests above are correct

class I18nPerson &lt; Person
end

class ActiveRecordValidationsI18nFullStackTests &lt; ActiveSupport::TestCase
  include ActiveRecordValidationsI18nTestHelper

  def setup
    reset_callbacks(I18nPerson)
    @old_backend, I18n.backend = I18n.backend, I18n::Backend::Simple.new
    @person = I18nPerson.new
  end

  def teardown
    reset_callbacks(I18nPerson)
    I18n.backend = @old_backend
  end

  def assert_name_invalid(message)
    yield
    @person.valid?
    assert_equal message, @person.errors.on(:name)
  end

  # Symbols as class-level validation messages

  test &quot;Symbol as class level validation message translated per attribute (translation on child class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:i18n_person =&gt; {:attributes =&gt; {:name =&gt; {:broken =&gt; &quot;is broken&quot;}}}}}
      I18nPerson.validates_presence_of :name, :message =&gt; :broken
    end
  end

  test &quot;Symbol as class level validation message translated per attribute (translation on base class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:person =&gt; {:attributes =&gt; {:name =&gt; {:broken =&gt; &quot;is broken&quot;}}}}}
      I18nPerson.validates_presence_of :name, :message =&gt; :broken
    end
  end

  test &quot;Symbol as class level validation message translated per model (translation on child class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:i18n_person =&gt; {:broken =&gt; &quot;is broken&quot;}}}
      I18nPerson.validates_presence_of :name, :message =&gt; :broken
    end
  end

  test &quot;Symbol as class level validation message translated per model (translation on base class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:person =&gt; {:broken =&gt; &quot;is broken&quot;}}}
      I18nPerson.validates_presence_of :name, :message =&gt; :broken
    end
  end

  test &quot;Symbol as class level validation message translated as error message&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:messages =&gt; {:broken =&gt; &quot;is broken&quot;}}
      I18nPerson.validates_presence_of :name, :message =&gt; :broken
    end
  end

  # Strings as class-level validation messages

  test &quot;String as class level validation message translated per attribute (translation on child class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:i18n_person =&gt; {:attributes =&gt; {:name =&gt; {&quot;is broken&quot; =&gt; &quot;is broken&quot;}}}}}
      I18nPerson.validates_presence_of :name, :message =&gt; &quot;is broken&quot;
    end
  end

  test &quot;String as class level validation message translated per attribute (translation on base class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:person =&gt; {:attributes =&gt; {:name =&gt; {&quot;is broken&quot; =&gt; &quot;is broken&quot;}}}}}
      I18nPerson.validates_presence_of :name, :message =&gt; &quot;is broken&quot;
    end
  end

  test &quot;String as class level validation message translated per model (translation on child class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:i18n_person =&gt; {&quot;is broken&quot; =&gt; &quot;is broken&quot;}}}
      I18nPerson.validates_presence_of :name, :message =&gt; &quot;is broken&quot;
    end
  end

  test &quot;String as class level validation message translated per model (translation on base class)&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:models =&gt; {:person =&gt; {&quot;is broken&quot; =&gt; &quot;is broken&quot;}}}
      I18nPerson.validates_presence_of :name, :message =&gt; &quot;is broken&quot;
    end
  end

  test &quot;String as class level validation message translated as error message&quot; do
    assert_name_invalid(&quot;is broken&quot;) do
      store_translations :errors =&gt; {:messages =&gt; {&quot;is broken&quot; =&gt; &quot;is broken&quot;}}
      I18nPerson.validates_presence_of :name, :message =&gt; &quot;is broken&quot;
    end
  end

  test &quot;String as class level validation message not translated (uses message as default)&quot; do
    assert_name_invalid(&quot;is broken!&quot;) do
      I18nPerson.validates_presence_of :name, :message =&gt; &quot;is broken!&quot;
    end
  end
end

class ActiveRecordValidationsI18nFullMessagesFullStackTests &lt; ActiveSupport::TestCase
  include ActiveRecordValidationsI18nTestHelper

  def setup
    reset_callbacks(I18nPerson)
    @old_backend, I18n.backend = I18n.backend, I18n::Backend::Simple.new
    @person = I18nPerson.new
  end

  def teardown
    reset_callbacks(I18nPerson)
    I18n.backend = @old_backend
  end

  def assert_full_message(message)
    yield
    @person.valid?
    assert_equal message, @person.errors.full_messages.join
  end

  test &quot;full_message format stored per custom error message key&quot; do
    assert_full_message(&quot;Name is broken!&quot;) do
      store_translations :errors =&gt; { :messages =&gt; { :broken =&gt; 'is broken' }, :full_messages =&gt; { :broken =&gt; '{{attribute}} {{message}}!' } }
      I18nPerson.validates_presence_of :name, :message =&gt; :broken
    end
  end

  test &quot;full_message format stored per error type&quot; do
    assert_full_message(&quot;Name can't be blank!&quot;) do
      store_translations :errors =&gt; { :full_messages =&gt; { :blank =&gt; '{{attribute}} {{message}}!' } }
      I18nPerson.validates_presence_of :name
    end
  end
  # ActiveRecord#RecordInvalid exception

  test &quot;full_message format stored as default&quot; do
    assert_full_message(&quot;Name: can't be blank&quot;) do
      store_translations :errors =&gt; { :full_messages =&gt; { :format =&gt; '{{attribute}}: {{message}}' } }
      I18nPerson.validates_presence_of :name
    end
  end
  test &quot;RecordInvalid exception can be localized&quot; do
    topic = Topic.new
    topic.errors.add(:title, :invalid)
    topic.errors.add(:title, :blank)
    assert_equal &quot;Validation failed: Title is invalid, Title can't be blank&quot;, ActiveRecord::RecordInvalid.new(topic).message
  end
end
</pre>
    </div>