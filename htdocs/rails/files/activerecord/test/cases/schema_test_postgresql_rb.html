  <div id="fileHeader">
    <h1>schema_test_postgresql.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/schema_test_postgresql.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;

class SchemaTest &lt; ActiveRecord::TestCase
  self.use_transactional_fixtures = false

  SCHEMA_NAME = 'test_schema'
  SCHEMA2_NAME = 'test_schema2'
  TABLE_NAME = 'things'
  CAPITALIZED_TABLE_NAME = 'Things'
  INDEX_A_NAME = 'a_index_things_on_name'
  INDEX_B_NAME = 'b_index_things_on_different_columns_in_each_schema'
  INDEX_A_COLUMN = 'name'
  INDEX_B_COLUMN_S1 = 'email'
  INDEX_B_COLUMN_S2 = 'moment'
  COLUMNS = [
    'id integer',
    'name character varying(50)',
    'email character varying(50)',
    'moment timestamp without time zone default now()'
  ]

  class Thing1 &lt; ActiveRecord::Base
    set_table_name &quot;test_schema.things&quot;
  end

  class Thing2 &lt; ActiveRecord::Base
    set_table_name &quot;test_schema2.things&quot;
  end

  class Thing3 &lt; ActiveRecord::Base
    set_table_name 'test_schema.&quot;things.table&quot;'
  end

  class Thing4 &lt; ActiveRecord::Base
    set_table_name 'test_schema.&quot;Things&quot;'
  end

  def setup
    @connection = ActiveRecord::Base.connection
    @connection.execute &quot;CREATE SCHEMA #{SCHEMA_NAME} CREATE TABLE #{TABLE_NAME} (#{COLUMNS.join(',')})&quot;
    @connection.execute &quot;CREATE TABLE #{SCHEMA_NAME}.\&quot;#{TABLE_NAME}.table\&quot; (#{COLUMNS.join(',')})&quot;
    @connection.execute &quot;CREATE TABLE #{SCHEMA_NAME}.\&quot;#{CAPITALIZED_TABLE_NAME}\&quot; (#{COLUMNS.join(',')})&quot;
    @connection.execute &quot;CREATE SCHEMA #{SCHEMA2_NAME} CREATE TABLE #{TABLE_NAME} (#{COLUMNS.join(',')})&quot;
    @connection.execute &quot;CREATE INDEX #{INDEX_A_NAME} ON #{SCHEMA_NAME}.#{TABLE_NAME}  USING btree (#{INDEX_A_COLUMN});&quot;
    @connection.execute &quot;CREATE INDEX #{INDEX_A_NAME} ON #{SCHEMA2_NAME}.#{TABLE_NAME}  USING btree (#{INDEX_A_COLUMN});&quot;
    @connection.execute &quot;CREATE INDEX #{INDEX_B_NAME} ON #{SCHEMA_NAME}.#{TABLE_NAME}  USING btree (#{INDEX_B_COLUMN_S1});&quot;
    @connection.execute &quot;CREATE INDEX #{INDEX_B_NAME} ON #{SCHEMA2_NAME}.#{TABLE_NAME}  USING btree (#{INDEX_B_COLUMN_S2});&quot;
  end

  def teardown
    @connection.execute &quot;DROP SCHEMA #{SCHEMA2_NAME} CASCADE&quot;
    @connection.execute &quot;DROP SCHEMA #{SCHEMA_NAME} CASCADE&quot;
  end

  def test_with_schema_prefixed_table_name
    assert_nothing_raised do
      assert_equal COLUMNS, columns(&quot;#{SCHEMA_NAME}.#{TABLE_NAME}&quot;)
    end
  end

  def test_with_schema_prefixed_capitalized_table_name
    assert_nothing_raised do
      assert_equal COLUMNS, columns(&quot;#{SCHEMA_NAME}.#{CAPITALIZED_TABLE_NAME}&quot;)
    end
  end

  def test_with_schema_search_path
    assert_nothing_raised do
      with_schema_search_path(SCHEMA_NAME) do
        assert_equal COLUMNS, columns(TABLE_NAME)
      end
    end
  end


  def test_proper_encoding_of_table_name
    assert_equal '&quot;table_name&quot;', @connection.quote_table_name('table_name')
    assert_equal '&quot;table.name&quot;', @connection.quote_table_name('&quot;table.name&quot;')
    assert_equal '&quot;schema_name&quot;.&quot;table_name&quot;', @connection.quote_table_name('schema_name.table_name')
    assert_equal '&quot;schema_name&quot;.&quot;table.name&quot;', @connection.quote_table_name('schema_name.&quot;table.name&quot;')
    assert_equal '&quot;schema.name&quot;.&quot;table_name&quot;', @connection.quote_table_name('&quot;schema.name&quot;.table_name')
    assert_equal '&quot;schema.name&quot;.&quot;table.name&quot;', @connection.quote_table_name('&quot;schema.name&quot;.&quot;table.name&quot;')
  end

  def test_classes_with_qualified_schema_name
    assert_equal 0, Thing1.count
    assert_equal 0, Thing2.count
    assert_equal 0, Thing3.count
    assert_equal 0, Thing4.count

    Thing1.create(:id =&gt; 1, :name =&gt; &quot;thing1&quot;, :email =&gt; &quot;thing1@localhost&quot;, :moment =&gt; Time.now)
    assert_equal 1, Thing1.count
    assert_equal 0, Thing2.count
    assert_equal 0, Thing3.count
    assert_equal 0, Thing4.count

    Thing2.create(:id =&gt; 1, :name =&gt; &quot;thing1&quot;, :email =&gt; &quot;thing1@localhost&quot;, :moment =&gt; Time.now)
    assert_equal 1, Thing1.count
    assert_equal 1, Thing2.count
    assert_equal 0, Thing3.count
    assert_equal 0, Thing4.count

    Thing3.create(:id =&gt; 1, :name =&gt; &quot;thing1&quot;, :email =&gt; &quot;thing1@localhost&quot;, :moment =&gt; Time.now)
    assert_equal 1, Thing1.count
    assert_equal 1, Thing2.count
    assert_equal 1, Thing3.count
    assert_equal 0, Thing4.count

    Thing4.create(:id =&gt; 1, :name =&gt; &quot;thing1&quot;, :email =&gt; &quot;thing1@localhost&quot;, :moment =&gt; Time.now)
    assert_equal 1, Thing1.count
    assert_equal 1, Thing2.count
    assert_equal 1, Thing3.count
    assert_equal 1, Thing4.count
  end

  def test_raise_on_unquoted_schema_name
    assert_raise(ActiveRecord::StatementInvalid) do
      with_schema_search_path '$user,public'
    end
  end

  def test_without_schema_search_path
    assert_raise(ActiveRecord::StatementInvalid) { columns(TABLE_NAME) }
  end

  def test_ignore_nil_schema_search_path
    assert_nothing_raised { with_schema_search_path nil }
  end

  def test_dump_indexes_for_schema_one
    do_dump_index_tests_for_schema(SCHEMA_NAME, INDEX_A_COLUMN, INDEX_B_COLUMN_S1)
  end

  def test_dump_indexes_for_schema_two
    do_dump_index_tests_for_schema(SCHEMA2_NAME, INDEX_A_COLUMN, INDEX_B_COLUMN_S2)
  end

  def test_with_uppercase_index_name
    ActiveRecord::Base.connection.execute &quot;CREATE INDEX \&quot;things_Index\&quot; ON #{SCHEMA_NAME}.things (name)&quot;
    assert_nothing_raised { ActiveRecord::Base.connection.remove_index! &quot;things&quot;, &quot;#{SCHEMA_NAME}.things_Index&quot;}

    ActiveRecord::Base.connection.execute &quot;CREATE INDEX \&quot;things_Index\&quot; ON #{SCHEMA_NAME}.things (name)&quot;
    ActiveRecord::Base.connection.schema_search_path = SCHEMA_NAME
    assert_nothing_raised { ActiveRecord::Base.connection.remove_index! &quot;things&quot;, &quot;things_Index&quot;}
    ActiveRecord::Base.connection.schema_search_path = &quot;public&quot;
  end

  private
    def columns(table_name)
      @connection.send(:column_definitions, table_name).map do |name, type, default|
        &quot;#{name} #{type}&quot; + (default ? &quot; default #{default}&quot; : '')
      end
    end

    def with_schema_search_path(schema_search_path)
      @connection.schema_search_path = schema_search_path
      yield if block_given?
    ensure
      @connection.schema_search_path = &quot;'$user', public&quot;
    end

    def do_dump_index_tests_for_schema(this_schema_name, first_index_column_name, second_index_column_name)
      with_schema_search_path(this_schema_name) do
        indexes = @connection.indexes(TABLE_NAME).sort_by {|i| i.name}
        assert_equal 2,indexes.size

        do_dump_index_assertions_for_one_index(indexes[0], INDEX_A_NAME, first_index_column_name)
        do_dump_index_assertions_for_one_index(indexes[1], INDEX_B_NAME, second_index_column_name)
      end
    end

    def do_dump_index_assertions_for_one_index(this_index, this_index_name, this_index_column)
      assert_equal TABLE_NAME, this_index.table
      assert_equal 1, this_index.columns.size
      assert_equal this_index_column, this_index.columns[0]
      assert_equal this_index_name, this_index.name
    end
end
</pre>
    </div>