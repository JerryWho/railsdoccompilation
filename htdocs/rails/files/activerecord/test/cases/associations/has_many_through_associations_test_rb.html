  <div id="fileHeader">
    <h1>has_many_through_associations_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/associations/has_many_through_associations_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:55:10 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'models/post'
require 'models/person'
require 'models/reference'
require 'models/job'
require 'models/reader'
require 'models/comment'
require 'models/tag'
require 'models/tagging'
require 'models/author'
require 'models/owner'
require 'models/pet'
require 'models/toy'
require 'models/contract'
require 'models/company'
require 'models/developer'

class HasManyThroughAssociationsTest &lt; ActiveRecord::TestCase
  fixtures :posts, :readers, :people, :comments, :authors, :owners, :pets, :toys,
           :companies

  def test_associate_existing
    assert_queries(2) { posts(:thinking);people(:david) }

    posts(:thinking).people

    assert_queries(1) do
      posts(:thinking).people &lt;&lt; people(:david)
    end
    
    assert_queries(1) do
      assert posts(:thinking).people.include?(people(:david))
    end
    
    assert posts(:thinking).reload.people(true).include?(people(:david))
  end

  def test_associating_new
    assert_queries(1) { posts(:thinking) }
    new_person = nil # so block binding catches it
    
    assert_queries(0) do
      new_person = Person.new :first_name =&gt; 'bob'
    end
    
    # Associating new records always saves them
    # Thus, 1 query for the new person record, 1 query for the new join table record
    assert_queries(2) do
      posts(:thinking).people &lt;&lt; new_person
    end
    
    assert_queries(1) do
      assert posts(:thinking).people.include?(new_person)
    end
    
    assert posts(:thinking).reload.people(true).include?(new_person)
  end

  def test_associate_new_by_building
    assert_queries(1) { posts(:thinking) }
    
    assert_queries(0) do
      posts(:thinking).people.build(:first_name=&gt;&quot;Bob&quot;)
      posts(:thinking).people.new(:first_name=&gt;&quot;Ted&quot;)
    end
    
    # Should only need to load the association once
    assert_queries(1) do
      assert posts(:thinking).people.collect(&amp;:first_name).include?(&quot;Bob&quot;)
      assert posts(:thinking).people.collect(&amp;:first_name).include?(&quot;Ted&quot;)
    end
    
    # 2 queries for each new record (1 to save the record itself, 1 for the join model)
    #    * 2 new records = 4
    # + 1 query to save the actual post = 5
    assert_queries(5) do
      posts(:thinking).body += '-changed'
      posts(:thinking).save
    end
    
    assert posts(:thinking).reload.people(true).collect(&amp;:first_name).include?(&quot;Bob&quot;)
    assert posts(:thinking).reload.people(true).collect(&amp;:first_name).include?(&quot;Ted&quot;)
  end

  def test_delete_association
    assert_queries(2){posts(:welcome);people(:michael); }
    
    assert_queries(1) do
      posts(:welcome).people.delete(people(:michael))
    end
    
    assert_queries(1) do
      assert posts(:welcome).people.empty?
    end
    
    assert posts(:welcome).reload.people(true).empty?
  end

  def test_destroy_association
    assert_difference &quot;Person.count&quot;, -1 do
      posts(:welcome).people.destroy(people(:michael))
    end

    assert posts(:welcome).reload.people.empty?
    assert posts(:welcome).people(true).empty?
  end

  def test_destroy_all
    assert_difference &quot;Person.count&quot;, -1 do
      posts(:welcome).people.destroy_all
    end

    assert posts(:welcome).reload.people.empty?
    assert posts(:welcome).people(true).empty?
  end

  def test_replace_association
    assert_queries(4){posts(:welcome);people(:david);people(:michael); posts(:welcome).people(true)}
    
    # 1 query to delete the existing reader (michael)
    # 1 query to associate the new reader (david)
    assert_queries(2) do
      posts(:welcome).people = [people(:david)]
    end
    
    assert_queries(0){
      assert posts(:welcome).people.include?(people(:david))
      assert !posts(:welcome).people.include?(people(:michael))
    }
    
    assert posts(:welcome).reload.people(true).include?(people(:david))
    assert !posts(:welcome).reload.people(true).include?(people(:michael))
  end

  def test_associate_with_create
    assert_queries(1) { posts(:thinking) }
    
    # 1 query for the new record, 1 for the join table record
    # No need to update the actual collection yet!
    assert_queries(2) do
      posts(:thinking).people.create(:first_name=&gt;&quot;Jeb&quot;)
    end
    
    # *Now* we actually need the collection so it's loaded
    assert_queries(1) do
      assert posts(:thinking).people.collect(&amp;:first_name).include?(&quot;Jeb&quot;)
    end
    
    assert posts(:thinking).reload.people(true).collect(&amp;:first_name).include?(&quot;Jeb&quot;)
  end

  def test_associate_with_create_and_no_options
    peeps = posts(:thinking).people.count
    posts(:thinking).people.create(:first_name =&gt; 'foo')
    assert_equal peeps + 1, posts(:thinking).people.count
  end

  def test_associate_with_create_exclamation_and_no_options
    peeps = posts(:thinking).people.count
    posts(:thinking).people.create!(:first_name =&gt; 'foo')
    assert_equal peeps + 1, posts(:thinking).people.count
  end

  def test_associate_with_create_and_invalid_options
    peeps = companies(:first_firm).developers.count
    assert_nothing_raised { companies(:first_firm).developers.create(:name =&gt; '0') }
    assert_equal peeps, companies(:first_firm).developers.count
  end

  def test_associate_with_create_and_valid_options
    peeps = companies(:first_firm).developers.count
    assert_nothing_raised { companies(:first_firm).developers.create(:name =&gt; 'developer') }
    assert_equal peeps + 1, companies(:first_firm).developers.count
  end

  def test_associate_with_create_bang_and_invalid_options
    peeps = companies(:first_firm).developers.count
    assert_raises(ActiveRecord::RecordInvalid) { companies(:first_firm).developers.create!(:name =&gt; '0') }
    assert_equal peeps, companies(:first_firm).developers.count
  end

  def test_associate_with_create_bang_and_valid_options
    peeps = companies(:first_firm).developers.count
    assert_nothing_raised { companies(:first_firm).developers.create!(:name =&gt; 'developer') }
    assert_equal peeps + 1, companies(:first_firm).developers.count
  end

  def test_clear_associations
    assert_queries(2) { posts(:welcome);posts(:welcome).people(true) }
    
    assert_queries(1) do
      posts(:welcome).people.clear
    end
    
    assert_queries(0) do
      assert posts(:welcome).people.empty?
    end
    
    assert posts(:welcome).reload.people(true).empty?
  end

  def test_association_callback_ordering
    Post.reset_log
    log = Post.log
    post = posts(:thinking)

    post.people_with_callbacks &lt;&lt; people(:michael)
    assert_equal [
      [:added, :before, &quot;Michael&quot;],
      [:added, :after, &quot;Michael&quot;]
    ], log.last(2)

    post.people_with_callbacks.push(people(:david), Person.create!(:first_name =&gt; &quot;Bob&quot;), Person.new(:first_name =&gt; &quot;Lary&quot;))
    assert_equal [
      [:added, :before, &quot;David&quot;],
      [:added, :after, &quot;David&quot;],
      [:added, :before, &quot;Bob&quot;],
      [:added, :after, &quot;Bob&quot;],
      [:added, :before, &quot;Lary&quot;],
      [:added, :after, &quot;Lary&quot;]
    ],log.last(6)

    post.people_with_callbacks.build(:first_name =&gt; &quot;Ted&quot;)
    assert_equal [
      [:added, :before, &quot;Ted&quot;],
      [:added, :after, &quot;Ted&quot;]
    ], log.last(2)

    post.people_with_callbacks.create(:first_name =&gt; &quot;Sam&quot;)
    assert_equal [
      [:added, :before, &quot;Sam&quot;],
      [:added, :after, &quot;Sam&quot;]
    ], log.last(2)

    post.people_with_callbacks = [people(:michael),people(:david), Person.new(:first_name =&gt; &quot;Julian&quot;), Person.create!(:first_name =&gt; &quot;Roger&quot;)]
    assert_equal (%w(Ted Bob Sam Lary) * 2).sort, log[-12..-5].collect(&amp;:last).sort
    assert_equal [
      [:added, :before, &quot;Julian&quot;],
      [:added, :after, &quot;Julian&quot;],
      [:added, :before, &quot;Roger&quot;],
      [:added, :after, &quot;Roger&quot;]
    ], log.last(4)

    post.people_with_callbacks.clear
    assert_equal (%w(Michael David Julian Roger) * 2).sort, log.last(8).collect(&amp;:last).sort
  end

  def test_dynamic_find_should_respect_association_include
    # SQL error in sort clause if :include is not included
    # due to Unknown column 'comments.id'
    assert Person.find(1).posts_with_comments_sorted_by_comment_id.find_by_title('Welcome to the weblog')
  end

  def test_count_with_include_should_alias_join_table
    assert_equal 2, people(:michael).posts.count(:include =&gt; :readers)
  end

  def test_inner_join_with_quoted_table_name
    assert_equal 2, people(:michael).jobs.size
  end

  def test_get_ids
    assert_equal [posts(:welcome).id, posts(:authorless).id].sort, people(:michael).post_ids.sort
  end

  def test_get_ids_for_loaded_associations
    person = people(:michael)
    person.posts(true)
    assert_queries(0) do
      person.post_ids
      person.post_ids
    end
  end

  def test_get_ids_for_unloaded_associations_does_not_load_them
    person = people(:michael)
    assert !person.posts.loaded?
    assert_equal [posts(:welcome).id, posts(:authorless).id].sort, person.post_ids.sort
    assert !person.posts.loaded?
  end

  def test_association_proxy_transaction_method_starts_transaction_in_association_class
    Tag.expects(:transaction)
    Post.find(:first).tags.transaction do
      # nothing
    end
  end

  def test_has_many_association_through_a_belongs_to_association_where_the_association_doesnt_exist
    author = authors(:mary)
    post = Post.create!(:title =&gt; &quot;TITLE&quot;, :body =&gt; &quot;BODY&quot;)
    assert_equal [], post.author_favorites
  end

  def test_has_many_association_through_a_belongs_to_association
    author = authors(:mary)
    post = Post.create!(:author =&gt; author, :title =&gt; &quot;TITLE&quot;, :body =&gt; &quot;BODY&quot;)
    author.author_favorites.create(:favorite_author_id =&gt; 1)
    author.author_favorites.create(:favorite_author_id =&gt; 2)
    author.author_favorites.create(:favorite_author_id =&gt; 3)
    assert_equal post.author.author_favorites, post.author_favorites
  end

  def test_has_many_association_through_a_has_many_association_with_nonstandard_primary_keys
    assert_equal 1, owners(:blackbeard).toys.count
  end

  def test_find_on_has_many_association_collection_with_include_and_conditions
    post_with_no_comments = people(:michael).posts_with_no_comments.first
    assert_equal post_with_no_comments, posts(:authorless)
  end

  def test_has_many_through_has_one_reflection
    assert_equal [comments(:eager_sti_on_associations_vs_comment)], authors(:david).very_special_comments
  end

  def test_modifying_has_many_through_has_one_reflection_should_raise
    [
      lambda { authors(:david).very_special_comments = [VerySpecialComment.create!(:body =&gt; &quot;Gorp!&quot;, :post_id =&gt; 1011), VerySpecialComment.create!(:body =&gt; &quot;Eep!&quot;, :post_id =&gt; 1012)] },
      lambda { authors(:david).very_special_comments &lt;&lt; VerySpecialComment.create!(:body =&gt; &quot;Hoohah!&quot;, :post_id =&gt; 1013) },
      lambda { authors(:david).very_special_comments.delete(authors(:david).very_special_comments.first) },
    ].each {|block| assert_raise(ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection, &amp;block) }
  end
end
</pre>
    </div>