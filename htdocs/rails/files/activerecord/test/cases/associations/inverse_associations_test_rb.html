  <div id="fileHeader">
    <h1>inverse_associations_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/associations/inverse_associations_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'models/man'
require 'models/face'
require 'models/interest'
require 'models/zine'
require 'models/club'
require 'models/sponsor'

class InverseAssociationTests &lt; ActiveRecord::TestCase
  def test_should_allow_for_inverse_of_options_in_associations
    assert_nothing_raised(ArgumentError, 'ActiveRecord should allow the inverse_of options on has_many') do
      Class.new(ActiveRecord::Base).has_many(:wheels, :inverse_of =&gt; :car)
    end

    assert_nothing_raised(ArgumentError, 'ActiveRecord should allow the inverse_of options on has_one') do
      Class.new(ActiveRecord::Base).has_one(:engine, :inverse_of =&gt; :car)
    end

    assert_nothing_raised(ArgumentError, 'ActiveRecord should allow the inverse_of options on belongs_to') do
      Class.new(ActiveRecord::Base).belongs_to(:car, :inverse_of =&gt; :driver)
    end
  end

  def test_should_be_able_to_ask_a_reflection_if_it_has_an_inverse
    has_one_with_inverse_ref = Man.reflect_on_association(:face)
    assert has_one_with_inverse_ref.respond_to?(:has_inverse?)
    assert has_one_with_inverse_ref.has_inverse?

    has_many_with_inverse_ref = Man.reflect_on_association(:interests)
    assert has_many_with_inverse_ref.respond_to?(:has_inverse?)
    assert has_many_with_inverse_ref.has_inverse?

    belongs_to_with_inverse_ref = Face.reflect_on_association(:man)
    assert belongs_to_with_inverse_ref.respond_to?(:has_inverse?)
    assert belongs_to_with_inverse_ref.has_inverse?

    has_one_without_inverse_ref = Club.reflect_on_association(:sponsor)
    assert has_one_without_inverse_ref.respond_to?(:has_inverse?)
    assert !has_one_without_inverse_ref.has_inverse?

    has_many_without_inverse_ref = Club.reflect_on_association(:memberships)
    assert has_many_without_inverse_ref.respond_to?(:has_inverse?)
    assert !has_many_without_inverse_ref.has_inverse?

    belongs_to_without_inverse_ref = Sponsor.reflect_on_association(:sponsor_club)
    assert belongs_to_without_inverse_ref.respond_to?(:has_inverse?)
    assert !belongs_to_without_inverse_ref.has_inverse?
  end

  def test_should_be_able_to_ask_a_reflection_what_it_is_the_inverse_of
    has_one_ref = Man.reflect_on_association(:face)
    assert has_one_ref.respond_to?(:inverse_of)

    has_many_ref = Man.reflect_on_association(:interests)
    assert has_many_ref.respond_to?(:inverse_of)

    belongs_to_ref = Face.reflect_on_association(:man)
    assert belongs_to_ref.respond_to?(:inverse_of)
  end

  def test_inverse_of_method_should_supply_the_actual_reflection_instance_it_is_the_inverse_of
    has_one_ref = Man.reflect_on_association(:face)
    assert_equal Face.reflect_on_association(:man), has_one_ref.inverse_of

    has_many_ref = Man.reflect_on_association(:interests)
    assert_equal Interest.reflect_on_association(:man), has_many_ref.inverse_of

    belongs_to_ref = Face.reflect_on_association(:man)
    assert_equal Man.reflect_on_association(:face), belongs_to_ref.inverse_of
  end

  def test_associations_with_no_inverse_of_should_return_nil
    has_one_ref = Club.reflect_on_association(:sponsor)
    assert_nil has_one_ref.inverse_of

    has_many_ref = Club.reflect_on_association(:memberships)
    assert_nil has_many_ref.inverse_of

    belongs_to_ref = Sponsor.reflect_on_association(:sponsor_club)
    assert_nil belongs_to_ref.inverse_of
  end
end

class InverseHasOneTests &lt; ActiveRecord::TestCase
  fixtures :men, :faces

  def test_parent_instance_should_be_shared_with_child_on_find
    m = men(:gordon)
    f = m.face
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_eager_loaded_child_on_find
    m = Man.find(:first, :conditions =&gt; {:name =&gt; 'Gordon'}, :include =&gt; :face)
    f = m.face
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to child-owned instance&quot;

    m = Man.find(:first, :conditions =&gt; {:name =&gt; 'Gordon'}, :include =&gt; :face, :order =&gt; 'faces.id')
    f = m.face
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_built_child
    m = men(:gordon)
    f = m.build_face(:description =&gt; 'haunted')
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to just-built-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_created_child
    m = men(:gordon)
    f = m.create_face(:description =&gt; 'haunted')
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_created_child_via_bang_method
    m = Man.find(:first)
    f = m.face.create!(:description =&gt; 'haunted')
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_built_child_when_we_dont_replace_existing
    m = Man.find(:first)
    f = m.build_face({:description =&gt; 'haunted'}, false)
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to just-built-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_created_child_when_we_dont_replace_existing
    m = Man.find(:first)
    f = m.create_face({:description =&gt; 'haunted'}, false)
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_created_child_via_bang_method_when_we_dont_replace_existing
    m = Man.find(:first)
    f = m.face.create!({:description =&gt; 'haunted'}, false)
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_replaced_via_accessor_child
    m = Man.find(:first)
    f = Face.new(:description =&gt; 'haunted')
    m.face = f
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to replaced-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_replaced_via_method_child
    m = Man.find(:first)
    f = Face.new(:description =&gt; 'haunted')
    m.face.replace(f)
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to replaced-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_replaced_via_method_child_when_we_dont_replace_existing
    m = Man.find(:first)
    f = Face.new(:description =&gt; 'haunted')
    m.face.replace(f, false)
    assert_not_nil f.man
    assert_equal m.name, f.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    f.man.name = 'Mungo'
    assert_equal m.name, f.man.name, &quot;Name of man should be the same after changes to replaced-child-owned instance&quot;
  end

  def test_trying_to_use_inverses_that_dont_exist_should_raise_an_error
    assert_raise(ActiveRecord::InverseOfAssociationNotFoundError) { Man.find(:first).dirty_face }
  end
end

class InverseHasManyTests &lt; ActiveRecord::TestCase
  fixtures :men, :interests

  def test_parent_instance_should_be_shared_with_every_child_on_find
    m = men(:gordon)
    is = m.interests
    is.each do |i|
      assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
      m.name = 'Bongo'
      assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
      i.man.name = 'Mungo'
      assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to child-owned instance&quot;
    end
  end

  def test_parent_instance_should_be_shared_with_eager_loaded_children
    m = Man.find(:first, :conditions =&gt; {:name =&gt; 'Gordon'}, :include =&gt; :interests)
    is = m.interests
    is.each do |i|
      assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
      m.name = 'Bongo'
      assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
      i.man.name = 'Mungo'
      assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to child-owned instance&quot;
    end

    m = Man.find(:first, :conditions =&gt; {:name =&gt; 'Gordon'}, :include =&gt; :interests, :order =&gt; 'interests.id')
    is = m.interests
    is.each do |i|
      assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
      m.name = 'Bongo'
      assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
      i.man.name = 'Mungo'
      assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to child-owned instance&quot;
    end
  end

  def test_parent_instance_should_be_shared_with_newly_built_child
    m = men(:gordon)
    i = m.interests.build(:topic =&gt; 'Industrial Revolution Re-enactment')
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to just-built-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_block_style_built_child
    m = Man.find(:first)
    i = m.interests.build {|ii| ii.topic = 'Industrial Revolution Re-enactment'}
    assert_not_nil i.topic, &quot;Child attributes supplied to build via blocks should be populated&quot;
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to just-built-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_created_child
    m = men(:gordon)
    i = m.interests.create(:topic =&gt; 'Industrial Revolution Re-enactment')
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_created_via_bang_method_child
    m = Man.find(:first)
    i = m.interests.create!(:topic =&gt; 'Industrial Revolution Re-enactment')
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_newly_block_style_created_child
    m = Man.find(:first)
    i = m.interests.create {|ii| ii.topic = 'Industrial Revolution Re-enactment'}
    assert_not_nil i.topic, &quot;Child attributes supplied to create via blocks should be populated&quot;
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_poked_in_child
    m = men(:gordon)
    i = Interest.create(:topic =&gt; 'Industrial Revolution Re-enactment')
    m.interests &lt;&lt; i
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to newly-created-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_replaced_via_accessor_children
    m = Man.find(:first)
    i = Interest.new(:topic =&gt; 'Industrial Revolution Re-enactment')
    m.interests = [i]
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to replaced-child-owned instance&quot;
  end

  def test_parent_instance_should_be_shared_with_replaced_via_method_children
    m = Man.find(:first)
    i = Interest.new(:topic =&gt; 'Industrial Revolution Re-enactment')
    m.interests.replace([i])
    assert_not_nil i.man
    assert_equal m.name, i.man.name, &quot;Name of man should be the same before changes to parent instance&quot;
    m.name = 'Bongo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to parent instance&quot;
    i.man.name = 'Mungo'
    assert_equal m.name, i.man.name, &quot;Name of man should be the same after changes to replaced-child-owned instance&quot;
  end

  def test_trying_to_use_inverses_that_dont_exist_should_raise_an_error
    assert_raise(ActiveRecord::InverseOfAssociationNotFoundError) { Man.find(:first).secret_interests }
  end
end

class InverseBelongsToTests &lt; ActiveRecord::TestCase
  fixtures :men, :faces, :interests

  def test_child_instance_should_be_shared_with_parent_on_find
    f = faces(:trusting)
    m = f.man
    assert_equal f.description, m.face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.face.description = 'pleasing'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to parent-owned instance&quot;
  end

  def test_eager_loaded_child_instance_should_be_shared_with_parent_on_find
    f = Face.find(:first, :include =&gt; :man, :conditions =&gt; {:description =&gt; 'trusting'})
    m = f.man
    assert_equal f.description, m.face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.face.description = 'pleasing'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to parent-owned instance&quot;

    f = Face.find(:first, :include =&gt; :man, :order =&gt; 'men.id', :conditions =&gt; {:description =&gt; 'trusting'})
    m = f.man
    assert_equal f.description, m.face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.face.description = 'pleasing'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to parent-owned instance&quot;
  end

  def test_child_instance_should_be_shared_with_newly_built_parent
    f = faces(:trusting)
    m = f.build_man(:name =&gt; 'Charles')
    assert_not_nil m.face
    assert_equal f.description, m.face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.face.description = 'pleasing'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to just-built-parent-owned instance&quot;
  end

  def test_child_instance_should_be_shared_with_newly_created_parent
    f = faces(:trusting)
    m = f.create_man(:name =&gt; 'Charles')
    assert_not_nil m.face
    assert_equal f.description, m.face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.face.description = 'pleasing'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to newly-created-parent-owned instance&quot;
  end

  def test_should_not_try_to_set_inverse_instances_when_the_inverse_is_a_has_many
    i = interests(:trainspotting)
    m = i.man
    assert_not_nil m.interests
    iz = m.interests.detect {|iz| iz.id == i.id}
    assert_not_nil iz
    assert_equal i.topic, iz.topic, &quot;Interest topics should be the same before changes to child&quot;
    i.topic = 'Eating cheese with a spoon'
    assert_not_equal i.topic, iz.topic, &quot;Interest topics should not be the same after changes to child&quot;
    iz.topic = 'Cow tipping'
    assert_not_equal i.topic, iz.topic, &quot;Interest topics should not be the same after changes to parent-owned instance&quot;
  end

  def test_child_instance_should_be_shared_with_replaced_via_accessor_parent
    f = Face.find(:first)
    m = Man.new(:name =&gt; 'Charles')
    f.man = m
    assert_not_nil m.face
    assert_equal f.description, m.face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.face.description = 'pleasing'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to replaced-parent-owned instance&quot;
  end

  def test_child_instance_should_be_shared_with_replaced_via_method_parent
    f = faces(:trusting)
    assert_not_nil f.man
    m = Man.new(:name =&gt; 'Charles')
    f.man.replace(m)
    assert_not_nil m.face
    assert_equal f.description, m.face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.face.description = 'pleasing'
    assert_equal f.description, m.face.description, &quot;Description of face should be the same after changes to replaced-parent-owned instance&quot;
  end

  def test_trying_to_use_inverses_that_dont_exist_should_raise_an_error
    assert_raise(ActiveRecord::InverseOfAssociationNotFoundError) { Face.find(:first).horrible_man }
  end
end

class InversePolymorphicBelongsToTests &lt; ActiveRecord::TestCase
  fixtures :men, :faces, :interests

  def test_child_instance_should_be_shared_with_parent_on_find
    f = Face.find(:first, :conditions =&gt; {:description =&gt; 'confused'})
    m = f.polymorphic_man
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.polymorphic_face.description = 'pleasing'
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same after changes to parent-owned instance&quot;
  end

  def test_eager_loaded_child_instance_should_be_shared_with_parent_on_find
    f = Face.find(:first, :conditions =&gt; {:description =&gt; 'confused'}, :include =&gt; :man)
    m = f.polymorphic_man
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.polymorphic_face.description = 'pleasing'
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same after changes to parent-owned instance&quot;

    f = Face.find(:first, :conditions =&gt; {:description =&gt; 'confused'}, :include =&gt; :man, :order =&gt; 'men.id')
    m = f.polymorphic_man
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same before changes to child instance&quot;
    f.description = 'gormless'
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same after changes to child instance&quot;
    m.polymorphic_face.description = 'pleasing'
    assert_equal f.description, m.polymorphic_face.description, &quot;Description of face should be the same after changes to parent-owned instance&quot;
  end

  def test_child_instance_should_be_shared_with_replaced_via_accessor_parent
    face = faces(:confused)
    old_man = face.polymorphic_man
    new_man = Man.new

    assert_not_nil face.polymorphic_man
    face.polymorphic_man = new_man

    assert_equal face.description, new_man.polymorphic_face.description, &quot;Description of face should be the same before changes to parent instance&quot;
    face.description = 'Bongo'
    assert_equal face.description, new_man.polymorphic_face.description, &quot;Description of face should be the same after changes to parent instance&quot;
    new_man.polymorphic_face.description = 'Mungo'
    assert_equal face.description, new_man.polymorphic_face.description, &quot;Description of face should be the same after changes to replaced-parent-owned instance&quot;
  end

  def test_child_instance_should_be_shared_with_replaced_via_method_parent
    face = faces(:confused)
    old_man = face.polymorphic_man
    new_man = Man.new

    assert_not_nil face.polymorphic_man
    face.polymorphic_man.replace(new_man)

    assert_equal face.description, new_man.polymorphic_face.description, &quot;Description of face should be the same before changes to parent instance&quot;
    face.description = 'Bongo'
    assert_equal face.description, new_man.polymorphic_face.description, &quot;Description of face should be the same after changes to parent instance&quot;
    new_man.polymorphic_face.description = 'Mungo'
    assert_equal face.description, new_man.polymorphic_face.description, &quot;Description of face should be the same after changes to replaced-parent-owned instance&quot;
  end

  def test_should_not_try_to_set_inverse_instances_when_the_inverse_is_a_has_many
    i = interests(:llama_wrangling)
    m = i.polymorphic_man
    assert_not_nil m.polymorphic_interests
    iz = m.polymorphic_interests.detect {|iz| iz.id == i.id}
    assert_not_nil iz
    assert_equal i.topic, iz.topic, &quot;Interest topics should be the same before changes to child&quot;
    i.topic = 'Eating cheese with a spoon'
    assert_not_equal i.topic, iz.topic, &quot;Interest topics should not be the same after changes to child&quot;
    iz.topic = 'Cow tipping'
    assert_not_equal i.topic, iz.topic, &quot;Interest topics should not be the same after changes to parent-owned instance&quot;
  end

  def test_trying_to_access_inverses_that_dont_exist_shouldnt_raise_an_error
    # Ideally this would, if only for symmetry's sake with other association types
    assert_nothing_raised(ActiveRecord::InverseOfAssociationNotFoundError) { Face.find(:first).horrible_polymorphic_man }
  end

  def test_trying_to_set_polymorphic_inverses_that_dont_exist_at_all_should_raise_an_error
    # fails because no class has the correct inverse_of for horrible_polymorphic_man
    assert_raise(ActiveRecord::InverseOfAssociationNotFoundError) { Face.find(:first).horrible_polymorphic_man = Man.first }
  end

  def test_trying_to_set_polymorphic_inverses_that_dont_exist_on_the_instance_being_set_should_raise_an_error
    # passes because Man does have the correct inverse_of
    assert_nothing_raised(ActiveRecord::InverseOfAssociationNotFoundError) { Face.find(:first).polymorphic_man = Man.first }
    # fails because Interest does have the correct inverse_of
    assert_raise(ActiveRecord::InverseOfAssociationNotFoundError) { Face.find(:first).polymorphic_man = Interest.first }
  end
end

# NOTE - these tests might not be meaningful, ripped as they were from the parental_control plugin
# which would guess the inverse rather than look for an explicit configuration option.
class InverseMultipleHasManyInversesForSameModel &lt; ActiveRecord::TestCase
  fixtures :men, :interests, :zines

  def test_that_we_can_load_associations_that_have_the_same_reciprocal_name_from_different_models
    assert_nothing_raised(ActiveRecord::AssociationTypeMismatch) do
      i = Interest.find(:first)
      z = i.zine
      m = i.man
    end
  end

  def test_that_we_can_create_associations_that_have_the_same_reciprocal_name_from_different_models
    assert_nothing_raised(ActiveRecord::AssociationTypeMismatch) do
      i = Interest.find(:first)
      i.build_zine(:title =&gt; 'Get Some in Winter! 2008')
      i.build_man(:name =&gt; 'Gordon')
      i.save!
    end
  end
end
</pre>
    </div>