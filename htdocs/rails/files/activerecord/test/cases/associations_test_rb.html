  <div id="fileHeader">
    <h1>associations_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/associations_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:59:08 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'models/developer'
require 'models/project'
require 'models/company'
require 'models/topic'
require 'models/reply'
require 'models/computer'
require 'models/customer'
require 'models/order'
require 'models/categorization'
require 'models/category'
require 'models/post'
require 'models/author'
require 'models/comment'
require 'models/tag'
require 'models/tagging'
require 'models/person'
require 'models/reader'
require 'models/parrot'
require 'models/pirate'
require 'models/treasure'
require 'models/price_estimate'
require 'models/club'
require 'models/member'
require 'models/membership'
require 'models/sponsor'

class AssociationsTest &lt; ActiveRecord::TestCase
  fixtures :accounts, :companies, :developers, :projects, :developers_projects,
           :computers, :people, :readers

  def test_include_with_order_works
    assert_nothing_raised {Account.find(:first, :order =&gt; 'id', :include =&gt; :firm)}
    assert_nothing_raised {Account.find(:first, :order =&gt; :id, :include =&gt; :firm)}
  end

  def test_bad_collection_keys
    assert_raise(ArgumentError, 'ActiveRecord should have barked on bad collection keys') do
      Class.new(ActiveRecord::Base).has_many(:wheels, :name =&gt; 'wheels')
    end
  end

  def test_should_construct_new_finder_sql_after_create
    person = Person.new :first_name =&gt; 'clark'
    assert_equal [], person.readers.find(:all)
    person.save!
    reader = Reader.create! :person =&gt; person, :post =&gt; Post.new(:title =&gt; &quot;foo&quot;, :body =&gt; &quot;bar&quot;)
    assert person.readers.find(reader.id)
  end

  def test_force_reload
    firm = Firm.new(&quot;name&quot; =&gt; &quot;A New Firm, Inc&quot;)
    firm.save
    firm.clients.each {|c|} # forcing to load all clients
    assert firm.clients.empty?, &quot;New firm shouldn't have client objects&quot;
    assert_equal 0, firm.clients.size, &quot;New firm should have 0 clients&quot;

    client = Client.new(&quot;name&quot; =&gt; &quot;TheClient.com&quot;, &quot;firm_id&quot; =&gt; firm.id)
    client.save

    assert firm.clients.empty?, &quot;New firm should have cached no client objects&quot;
    assert_equal 0, firm.clients.size, &quot;New firm should have cached 0 clients count&quot;

    assert !firm.clients(true).empty?, &quot;New firm should have reloaded client objects&quot;
    assert_equal 1, firm.clients(true).size, &quot;New firm should have reloaded clients count&quot;
  end

  def test_storing_in_pstore
    require &quot;tmpdir&quot;
    store_filename = File.join(Dir.tmpdir, &quot;ar-pstore-association-test&quot;)
    File.delete(store_filename) if File.exist?(store_filename)
    require &quot;pstore&quot;
    apple = Firm.create(&quot;name&quot; =&gt; &quot;Apple&quot;)
    natural = Client.new(&quot;name&quot; =&gt; &quot;Natural Company&quot;)
    apple.clients &lt;&lt; natural

    db = PStore.new(store_filename)
    db.transaction do
      db[&quot;apple&quot;] = apple
    end

    db = PStore.new(store_filename)
    db.transaction do
      assert_equal &quot;Natural Company&quot;, db[&quot;apple&quot;].clients.first.name
    end
  end
end

class AssociationProxyTest &lt; ActiveRecord::TestCase
  fixtures :authors, :posts, :categorizations, :categories, :developers, :projects, :developers_projects

  def test_proxy_accessors
    welcome = posts(:welcome)
    assert_equal  welcome, welcome.author.proxy_owner
    assert_equal  welcome.class.reflect_on_association(:author), welcome.author.proxy_reflection
    welcome.author.class  # force load target
    assert_equal  welcome.author, welcome.author.proxy_target

    david = authors(:david)
    assert_equal  david, david.posts.proxy_owner
    assert_equal  david.class.reflect_on_association(:posts), david.posts.proxy_reflection
    david.posts.class   # force load target
    assert_equal  david.posts, david.posts.proxy_target

    assert_equal  david, david.posts_with_extension.testing_proxy_owner
    assert_equal  david.class.reflect_on_association(:posts_with_extension), david.posts_with_extension.testing_proxy_reflection
    david.posts_with_extension.class   # force load target
    assert_equal  david.posts_with_extension, david.posts_with_extension.testing_proxy_target
  end

  def test_push_does_not_load_target
    david = authors(:david)

    david.posts &lt;&lt; (post = Post.new(:title =&gt; &quot;New on Edge&quot;, :body =&gt; &quot;More cool stuff!&quot;))
    assert !david.posts.loaded?
    assert david.posts.include?(post)
  end

  def test_push_has_many_through_does_not_load_target
    david = authors(:david)

    david.categories &lt;&lt; categories(:technology)
    assert !david.categories.loaded?
    assert david.categories.include?(categories(:technology))
  end

  def test_push_followed_by_save_does_not_load_target
    david = authors(:david)

    david.posts &lt;&lt; (post = Post.new(:title =&gt; &quot;New on Edge&quot;, :body =&gt; &quot;More cool stuff!&quot;))
    assert !david.posts.loaded?
    david.save
    assert !david.posts.loaded?
    assert david.posts.include?(post)
  end

  def test_push_does_not_lose_additions_to_new_record
    josh = Author.new(:name =&gt; &quot;Josh&quot;)
    josh.posts &lt;&lt; Post.new(:title =&gt; &quot;New on Edge&quot;, :body =&gt; &quot;More cool stuff!&quot;)
    assert josh.posts.loaded?
    assert_equal 1, josh.posts.size
  end

  def test_save_on_parent_does_not_load_target
    david = developers(:david)

    assert !david.projects.loaded?
    david.update_attribute(:created_at, Time.now)
    assert !david.projects.loaded?
  end

  def test_inspect_does_not_reload_a_not_yet_loaded_target
    andreas = Developer.new :name =&gt; 'Andreas', :log =&gt; 'new developer added'
    assert !andreas.audit_logs.loaded?
    assert_match(/message: &quot;new developer added&quot;/, andreas.audit_logs.inspect)
  end

  def test_save_on_parent_saves_children
    developer = Developer.create :name =&gt; &quot;Bryan&quot;, :salary =&gt; 50_000
    assert_equal 1, developer.reload.audit_logs.size
  end

  def test_create_via_association_with_block
    post = authors(:david).posts.create(:title =&gt; &quot;New on Edge&quot;) {|p| p.body = &quot;More cool stuff!&quot;}
    assert_equal post.title, &quot;New on Edge&quot;
    assert_equal post.body, &quot;More cool stuff!&quot;
  end

  def test_create_with_bang_via_association_with_block
    post = authors(:david).posts.create!(:title =&gt; &quot;New on Edge&quot;) {|p| p.body = &quot;More cool stuff!&quot;}
    assert_equal post.title, &quot;New on Edge&quot;
    assert_equal post.body, &quot;More cool stuff!&quot;
  end

  def test_failed_reload_returns_nil
    p = setup_dangling_association
    assert_nil p.author.reload
  end

  def test_failed_reset_returns_nil
    p = setup_dangling_association
    assert_nil p.author.reset
  end

  def test_reload_returns_assocition
    david = developers(:david)
    assert_nothing_raised do
      assert_equal david.projects, david.projects.reload.reload
    end
  end

  def setup_dangling_association
    josh = Author.create(:name =&gt; &quot;Josh&quot;)
    p = Post.create(:title =&gt; &quot;New on Edge&quot;, :body =&gt; &quot;More cool stuff!&quot;, :author =&gt; josh)
    josh.destroy
    p
  end
end

class OverridingAssociationsTest &lt; ActiveRecord::TestCase
  class Person &lt; ActiveRecord::Base; end
  class DifferentPerson &lt; ActiveRecord::Base; end

  class PeopleList &lt; ActiveRecord::Base
    has_and_belongs_to_many :has_and_belongs_to_many, :before_add =&gt; :enlist
    has_many :has_many, :before_add =&gt; :enlist
    belongs_to :belongs_to
    has_one :has_one
  end

  class DifferentPeopleList &lt; PeopleList
    # Different association with the same name, callbacks should be omitted here.
    has_and_belongs_to_many :has_and_belongs_to_many, :class_name =&gt; 'DifferentPerson'
    has_many :has_many, :class_name =&gt; 'DifferentPerson'
    belongs_to :belongs_to, :class_name =&gt; 'DifferentPerson'
    has_one :has_one, :class_name =&gt; 'DifferentPerson'
  end

  def test_habtm_association_redefinition_callbacks_should_differ_and_not_inherited
    # redeclared association on AR descendant should not inherit callbacks from superclass
    callbacks = PeopleList.read_inheritable_attribute(:before_add_for_has_and_belongs_to_many)
    assert_equal([:enlist], callbacks)
    callbacks = DifferentPeopleList.read_inheritable_attribute(:before_add_for_has_and_belongs_to_many)
    assert_equal([], callbacks)
  end

  def test_has_many_association_redefinition_callbacks_should_differ_and_not_inherited
    # redeclared association on AR descendant should not inherit callbacks from superclass
    callbacks = PeopleList.read_inheritable_attribute(:before_add_for_has_many)
    assert_equal([:enlist], callbacks)
    callbacks = DifferentPeopleList.read_inheritable_attribute(:before_add_for_has_many)
    assert_equal([], callbacks)
  end

  def test_habtm_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:has_and_belongs_to_many),
      DifferentPeopleList.reflect_on_association(:has_and_belongs_to_many)
    )
  end

  def test_has_many_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:has_many),
      DifferentPeopleList.reflect_on_association(:has_many)
    )
  end

  def test_belongs_to_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:belongs_to),
      DifferentPeopleList.reflect_on_association(:belongs_to)
    )
  end

  def test_has_one_association_redefinition_reflections_should_differ_and_not_inherited
    assert_not_equal(
      PeopleList.reflect_on_association(:has_one),
      DifferentPeopleList.reflect_on_association(:has_one)
    )
  end
end
</pre>
    </div>