  <div id="fileHeader">
    <h1>base_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/base_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Nov 27 16:38:16 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'models/post'
require 'models/author'
require 'models/topic'
require 'models/reply'
require 'models/category'
require 'models/company'
require 'models/customer'
require 'models/developer'
require 'models/project'
require 'models/default'
require 'models/auto_id'
require 'models/column_name'
require 'models/subscriber'
require 'models/keyboard'
require 'models/comment'
require 'models/minimalistic'
require 'models/warehouse_thing'
require 'models/parrot'
require 'rexml/document'

class Category &lt; ActiveRecord::Base; end
class Categorization &lt; ActiveRecord::Base; end
class Smarts &lt; ActiveRecord::Base; end
class CreditCard &lt; ActiveRecord::Base
  class PinNumber &lt; ActiveRecord::Base
    class CvvCode &lt; ActiveRecord::Base; end
    class SubCvvCode &lt; CvvCode; end
  end
  class SubPinNumber &lt; PinNumber; end
  class Brand &lt; Category; end
end
class MasterCreditCard &lt; ActiveRecord::Base; end
class Post &lt; ActiveRecord::Base; end
class Computer &lt; ActiveRecord::Base; end
class NonExistentTable &lt; ActiveRecord::Base; end
class TestOracleDefault &lt; ActiveRecord::Base; end

class LoosePerson &lt; ActiveRecord::Base
  self.table_name = 'people'
  self.abstract_class = true
  attr_protected :credit_rating, :administrator
end

class LooseDescendant &lt; LoosePerson
  attr_protected :phone_number
end

class LooseDescendantSecond&lt; LoosePerson
  attr_protected :phone_number
  attr_protected :name
end

class TightPerson &lt; ActiveRecord::Base
  self.table_name = 'people'
  attr_accessible :name, :address
end

class TightDescendant &lt; TightPerson
  attr_accessible :phone_number
end

class ReadonlyTitlePost &lt; Post
  attr_readonly :title
end

class Booleantest &lt; ActiveRecord::Base; end

class Task &lt; ActiveRecord::Base
  attr_protected :starting
end

class TopicWithProtectedContentAndAccessibleAuthorName &lt; ActiveRecord::Base
  self.table_name = 'topics'
  attr_accessible :author_name
  attr_protected  :content
end

class BasicsTest &lt; ActiveRecord::TestCase
  fixtures :topics, :companies, :developers, :projects, :computers, :accounts, :minimalistics, 'warehouse-things', :authors, :categorizations, :categories, :posts

  def test_table_exists
    assert !NonExistentTable.table_exists?
    assert Topic.table_exists?
  end

  def test_set_attributes
    topic = Topic.find(1)
    topic.attributes = { &quot;title&quot; =&gt; &quot;Budget&quot;, &quot;author_name&quot; =&gt; &quot;Jason&quot; }
    topic.save
    assert_equal(&quot;Budget&quot;, topic.title)
    assert_equal(&quot;Jason&quot;, topic.author_name)
    assert_equal(topics(:first).author_email_address, Topic.find(1).author_email_address)
  end

  def test_integers_as_nil
    test = AutoId.create('value' =&gt; '')
    assert_nil AutoId.find(test.id).value
  end

  def test_set_attributes_with_block
    topic = Topic.new do |t|
      t.title       = &quot;Budget&quot;
      t.author_name = &quot;Jason&quot;
    end

    assert_equal(&quot;Budget&quot;, topic.title)
    assert_equal(&quot;Jason&quot;, topic.author_name)
  end

  def test_respond_to?
    topic = Topic.find(1)
    assert topic.respond_to?(&quot;title&quot;)
    assert topic.respond_to?(&quot;title?&quot;)
    assert topic.respond_to?(&quot;title=&quot;)
    assert topic.respond_to?(:title)
    assert topic.respond_to?(:title?)
    assert topic.respond_to?(:title=)
    assert topic.respond_to?(&quot;author_name&quot;)
    assert topic.respond_to?(&quot;attribute_names&quot;)
    assert !topic.respond_to?(&quot;nothingness&quot;)
    assert !topic.respond_to?(:nothingness)
  end

  def test_array_content
    topic = Topic.new
    topic.content = %w( one two three )
    topic.save

    assert_equal(%w( one two three ), Topic.find(topic.id).content)
  end

  def test_read_attributes_before_type_cast
    category = Category.new({:name=&gt;&quot;Test categoty&quot;, :type =&gt; nil})
    category_attrs = {&quot;name&quot;=&gt;&quot;Test categoty&quot;, &quot;type&quot; =&gt; nil, &quot;categorizations_count&quot; =&gt; nil}
    assert_equal category_attrs , category.attributes_before_type_cast
  end

  if current_adapter?(:MysqlAdapter)
    def test_read_attributes_before_type_cast_on_boolean
      bool = Booleantest.create({ &quot;value&quot; =&gt; false })
      assert_equal &quot;0&quot;, bool.reload.attributes_before_type_cast[&quot;value&quot;]
    end
  end

  def test_read_attributes_before_type_cast_on_datetime
    developer = Developer.find(:first)
    assert_equal developer.created_at.to_s(:db) , developer.attributes_before_type_cast[&quot;created_at&quot;]
  end

  def test_hash_content
    topic = Topic.new
    topic.content = { &quot;one&quot; =&gt; 1, &quot;two&quot; =&gt; 2 }
    topic.save

    assert_equal 2, Topic.find(topic.id).content[&quot;two&quot;]

    topic.content_will_change!
    topic.content[&quot;three&quot;] = 3
    topic.save

    assert_equal 3, Topic.find(topic.id).content[&quot;three&quot;]
  end

  def test_update_array_content
    topic = Topic.new
    topic.content = %w( one two three )

    topic.content.push &quot;four&quot;
    assert_equal(%w( one two three four ), topic.content)

    topic.save

    topic = Topic.find(topic.id)
    topic.content &lt;&lt; &quot;five&quot;
    assert_equal(%w( one two three four five ), topic.content)
  end

  def test_case_sensitive_attributes_hash
    # DB2 is not case-sensitive
    return true if current_adapter?(:DB2Adapter)

    assert_equal @loaded_fixtures['computers']['workstation'].to_hash, Computer.find(:first).attributes
  end

  def test_create
    topic = Topic.new
    topic.title = &quot;New Topic&quot;
    topic.save
    topic_reloaded = Topic.find(topic.id)
    assert_equal(&quot;New Topic&quot;, topic_reloaded.title)
  end

  def test_save!
    topic = Topic.new(:title =&gt; &quot;New Topic&quot;)
    assert topic.save!

    reply = Reply.new
    assert_raise(ActiveRecord::RecordInvalid) { reply.save! }
  end

  def test_save_null_string_attributes
    topic = Topic.find(1)
    topic.attributes = { &quot;title&quot; =&gt; &quot;null&quot;, &quot;author_name&quot; =&gt; &quot;null&quot; }
    topic.save!
    topic.reload
    assert_equal(&quot;null&quot;, topic.title)
    assert_equal(&quot;null&quot;, topic.author_name)
  end

  def test_save_nil_string_attributes
    topic = Topic.find(1)
    topic.title = nil
    topic.save!
    topic.reload
    assert_nil topic.title
  end

  def test_save_for_record_with_only_primary_key
    minimalistic = Minimalistic.new
    assert_nothing_raised { minimalistic.save }
  end

  def test_save_for_record_with_only_primary_key_that_is_provided
    assert_nothing_raised { Minimalistic.create!(:id =&gt; 2) }
  end

  def test_hashes_not_mangled
    new_topic = { :title =&gt; &quot;New Topic&quot; }
    new_topic_values = { :title =&gt; &quot;AnotherTopic&quot; }

    topic = Topic.new(new_topic)
    assert_equal new_topic[:title], topic.title

    topic.attributes= new_topic_values
    assert_equal new_topic_values[:title], topic.title
  end

  def test_create_many
    topics = Topic.create([ { &quot;title&quot; =&gt; &quot;first&quot; }, { &quot;title&quot; =&gt; &quot;second&quot; }])
    assert_equal 2, topics.size
    assert_equal &quot;first&quot;, topics.first.title
  end

  def test_create_columns_not_equal_attributes
    topic = Topic.new
    topic.title = 'Another New Topic'
    topic.send :write_attribute, 'does_not_exist', 'test'
    assert_nothing_raised { topic.save }
  end

  def test_create_through_factory
    topic = Topic.create(&quot;title&quot; =&gt; &quot;New Topic&quot;)
    topicReloaded = Topic.find(topic.id)
    assert_equal(topic, topicReloaded)
  end

  def test_create_through_factory_with_block
    topic = Topic.create(&quot;title&quot; =&gt; &quot;New Topic&quot;) do |t|
      t.author_name = &quot;David&quot;
    end
    topicReloaded = Topic.find(topic.id)
    assert_equal(&quot;New Topic&quot;, topic.title)
    assert_equal(&quot;David&quot;, topic.author_name)
  end

  def test_create_many_through_factory_with_block
    topics = Topic.create([ { &quot;title&quot; =&gt; &quot;first&quot; }, { &quot;title&quot; =&gt; &quot;second&quot; }]) do |t|
      t.author_name = &quot;David&quot;
    end
    assert_equal 2, topics.size
    topic1, topic2 = Topic.find(topics[0].id), Topic.find(topics[1].id)
    assert_equal &quot;first&quot;, topic1.title
    assert_equal &quot;David&quot;, topic1.author_name
    assert_equal &quot;second&quot;, topic2.title
    assert_equal &quot;David&quot;, topic2.author_name
  end

  def test_update
    topic = Topic.new
    topic.title = &quot;Another New Topic&quot;
    topic.written_on = &quot;2003-12-12 23:23:00&quot;
    topic.save
    topicReloaded = Topic.find(topic.id)
    assert_equal(&quot;Another New Topic&quot;, topicReloaded.title)

    topicReloaded.title = &quot;Updated topic&quot;
    topicReloaded.save

    topicReloadedAgain = Topic.find(topic.id)

    assert_equal(&quot;Updated topic&quot;, topicReloadedAgain.title)
  end

  def test_update_columns_not_equal_attributes
    topic = Topic.new
    topic.title = &quot;Still another topic&quot;
    topic.save

    topicReloaded = Topic.find(topic.id)
    topicReloaded.title = &quot;A New Topic&quot;
    topicReloaded.send :write_attribute, 'does_not_exist', 'test'
    assert_nothing_raised { topicReloaded.save }
  end

  def test_update_for_record_with_only_primary_key
    minimalistic = minimalistics(:first)
    assert_nothing_raised { minimalistic.save }
  end

  def test_write_attribute
    topic = Topic.new
    topic.send(:write_attribute, :title, &quot;Still another topic&quot;)
    assert_equal &quot;Still another topic&quot;, topic.title

    topic.send(:write_attribute, &quot;title&quot;, &quot;Still another topic: part 2&quot;)
    assert_equal &quot;Still another topic: part 2&quot;, topic.title
  end

  def test_read_attribute
    topic = Topic.new
    topic.title = &quot;Don't change the topic&quot;
    assert_equal &quot;Don't change the topic&quot;, topic.send(:read_attribute, &quot;title&quot;)
    assert_equal &quot;Don't change the topic&quot;, topic[&quot;title&quot;]

    assert_equal &quot;Don't change the topic&quot;, topic.send(:read_attribute, :title)
    assert_equal &quot;Don't change the topic&quot;, topic[:title]
  end

  def test_read_attribute_when_false
    topic = topics(:first)
    topic.approved = false
    assert !topic.approved?, &quot;approved should be false&quot;
    topic.approved = &quot;false&quot;
    assert !topic.approved?, &quot;approved should be false&quot;
  end

  def test_read_attribute_when_true
    topic = topics(:first)
    topic.approved = true
    assert topic.approved?, &quot;approved should be true&quot;
    topic.approved = &quot;true&quot;
    assert topic.approved?, &quot;approved should be true&quot;
  end

  def test_read_write_boolean_attribute
    topic = Topic.new
    # puts &quot;&quot;
    # puts &quot;New Topic&quot;
    # puts topic.inspect
    topic.approved = &quot;false&quot;
    # puts &quot;Expecting false&quot;
    # puts topic.inspect
    assert !topic.approved?, &quot;approved should be false&quot;
    topic.approved = &quot;false&quot;
    # puts &quot;Expecting false&quot;
    # puts topic.inspect
    assert !topic.approved?, &quot;approved should be false&quot;
    topic.approved = &quot;true&quot;
    # puts &quot;Expecting true&quot;
    # puts topic.inspect
    assert topic.approved?, &quot;approved should be true&quot;
    topic.approved = &quot;true&quot;
    # puts &quot;Expecting true&quot;
    # puts topic.inspect
    assert topic.approved?, &quot;approved should be true&quot;
    # puts &quot;&quot;
  end

  def test_query_attribute_string
    [nil, &quot;&quot;, &quot; &quot;].each do |value|
      assert_equal false, Topic.new(:author_name =&gt; value).author_name?
    end

    assert_equal true, Topic.new(:author_name =&gt; &quot;Name&quot;).author_name?
  end

  def test_query_attribute_number
    [nil, 0, &quot;0&quot;].each do |value|
      assert_equal false, Developer.new(:salary =&gt; value).salary?
    end

    assert_equal true, Developer.new(:salary =&gt; 1).salary?
    assert_equal true, Developer.new(:salary =&gt; &quot;1&quot;).salary?
  end

  def test_query_attribute_boolean
    [nil, &quot;&quot;, false, &quot;false&quot;, &quot;f&quot;, 0].each do |value|
      assert_equal false, Topic.new(:approved =&gt; value).approved?
    end

    [true, &quot;true&quot;, &quot;1&quot;, 1].each do |value|
      assert_equal true, Topic.new(:approved =&gt; value).approved?
    end
  end

  def test_query_attribute_with_custom_fields
    object = Company.find_by_sql(&lt;&lt;-SQL).first
      SELECT c1.*, c2.ruby_type as string_value, c2.rating as int_value
        FROM companies c1, companies c2
       WHERE c1.firm_id = c2.id
         AND c1.id = 2
    SQL

    assert_equal &quot;Firm&quot;, object.string_value
    assert object.string_value?

    object.string_value = &quot;  &quot;
    assert !object.string_value?

    assert_equal 1, object.int_value.to_i
    assert object.int_value?

    object.int_value = &quot;0&quot;
    assert !object.int_value?
  end


  def test_reader_for_invalid_column_names
    Topic.send(:define_read_method, &quot;mumub-jumbo&quot;.to_sym, &quot;mumub-jumbo&quot;, nil)
    assert !Topic.generated_methods.include?(&quot;mumub-jumbo&quot;)
  end

  def test_non_attribute_access_and_assignment
    topic = Topic.new
    assert !topic.respond_to?(&quot;mumbo&quot;)
    assert_raise(NoMethodError) { topic.mumbo }
    assert_raise(NoMethodError) { topic.mumbo = 5 }
  end

  def test_preserving_date_objects
    if current_adapter?(:SybaseAdapter, :OracleAdapter)
      # Sybase ctlib does not (yet?) support the date type; use datetime instead.
      # Oracle treats all dates/times as Time.
      assert_kind_of(
        Time, Topic.find(1).last_read,
        &quot;The last_read attribute should be of the Time class&quot;
      )
    else
      assert_kind_of(
        Date, Topic.find(1).last_read,
        &quot;The last_read attribute should be of the Date class&quot;
      )
    end
  end

  def test_preserving_time_objects
    assert_kind_of(
      Time, Topic.find(1).bonus_time,
      &quot;The bonus_time attribute should be of the Time class&quot;
    )

    assert_kind_of(
      Time, Topic.find(1).written_on,
      &quot;The written_on attribute should be of the Time class&quot;
    )

    # For adapters which support microsecond resolution.
    if current_adapter?(:PostgreSQLAdapter)
      assert_equal 11, Topic.find(1).written_on.sec
      assert_equal 223300, Topic.find(1).written_on.usec
      assert_equal 9900, Topic.find(2).written_on.usec
    end
  end

  def test_custom_mutator
    topic = Topic.find(1)
    # This mutator is protected in the class definition
    topic.send(:approved=, true)
    assert topic.instance_variable_get(&quot;@custom_approved&quot;)
  end

  def test_delete
    topic = Topic.find(1)
    assert_equal topic, topic.delete, 'topic.delete did not return self'
    assert topic.frozen?, 'topic not frozen after delete'
    assert topic.destroyed?, 'topic not marked as being destroyed'
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(topic.id) }
  end

  def test_delete_doesnt_run_callbacks
    Topic.find(1).delete
    assert_not_nil Topic.find(2)
  end

  def test_destroy
    topic = Topic.find(1)
    assert_equal topic, topic.destroy, 'topic.destroy did not return self'
    assert topic.frozen?, 'topic not frozen after destroy'
    assert topic.destroyed?, 'topic not marked as being destroyed'
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(topic.id) }
  end

  def test_record_not_found_exception
    assert_raise(ActiveRecord::RecordNotFound) { topicReloaded = Topic.find(99999) }
  end

  def test_initialize_with_attributes
    topic = Topic.new({
      &quot;title&quot; =&gt; &quot;initialized from attributes&quot;, &quot;written_on&quot; =&gt; &quot;2003-12-12 23:23&quot;
    })

    assert_equal(&quot;initialized from attributes&quot;, topic.title)
  end

  def test_initialize_with_invalid_attribute
    begin
      topic = Topic.new({ &quot;title&quot; =&gt; &quot;test&quot;,
        &quot;last_read(1i)&quot; =&gt; &quot;2005&quot;, &quot;last_read(2i)&quot; =&gt; &quot;2&quot;, &quot;last_read(3i)&quot; =&gt; &quot;31&quot;})
    rescue ActiveRecord::MultiparameterAssignmentErrors =&gt; ex
      assert_equal(1, ex.errors.size)
      assert_equal(&quot;last_read&quot;, ex.errors[0].attribute)
    end
  end

  def test_load
    topics = Topic.find(:all, :order =&gt; 'id')
    assert_equal(4, topics.size)
    assert_equal(topics(:first).title, topics.first.title)
  end

  def test_load_with_condition
    topics = Topic.find(:all, :conditions =&gt; &quot;author_name = 'Mary'&quot;)

    assert_equal(1, topics.size)
    assert_equal(topics(:second).title, topics.first.title)
  end

  def test_table_name_guesses
    classes = [Category, Smarts, CreditCard, CreditCard::PinNumber, CreditCard::PinNumber::CvvCode, CreditCard::SubPinNumber, CreditCard::Brand, MasterCreditCard]

    assert_equal &quot;topics&quot;, Topic.table_name

    assert_equal &quot;categories&quot;, Category.table_name
    assert_equal &quot;smarts&quot;, Smarts.table_name
    assert_equal &quot;credit_cards&quot;, CreditCard.table_name
    assert_equal &quot;credit_card_pin_numbers&quot;, CreditCard::PinNumber.table_name
    assert_equal &quot;credit_card_pin_number_cvv_codes&quot;, CreditCard::PinNumber::CvvCode.table_name
    assert_equal &quot;credit_card_pin_numbers&quot;, CreditCard::SubPinNumber.table_name
    assert_equal &quot;categories&quot;, CreditCard::Brand.table_name
    assert_equal &quot;master_credit_cards&quot;, MasterCreditCard.table_name

    ActiveRecord::Base.pluralize_table_names = false
    classes.each(&amp;:reset_table_name)

    assert_equal &quot;category&quot;, Category.table_name
    assert_equal &quot;smarts&quot;, Smarts.table_name
    assert_equal &quot;credit_card&quot;, CreditCard.table_name
    assert_equal &quot;credit_card_pin_number&quot;, CreditCard::PinNumber.table_name
    assert_equal &quot;credit_card_pin_number_cvv_code&quot;, CreditCard::PinNumber::CvvCode.table_name
    assert_equal &quot;credit_card_pin_number&quot;, CreditCard::SubPinNumber.table_name
    assert_equal &quot;category&quot;, CreditCard::Brand.table_name
    assert_equal &quot;master_credit_card&quot;, MasterCreditCard.table_name

    ActiveRecord::Base.pluralize_table_names = true
    classes.each(&amp;:reset_table_name)

    ActiveRecord::Base.table_name_prefix = &quot;test_&quot;
    Category.reset_table_name
    assert_equal &quot;test_categories&quot;, Category.table_name
    ActiveRecord::Base.table_name_suffix = &quot;_test&quot;
    Category.reset_table_name
    assert_equal &quot;test_categories_test&quot;, Category.table_name
    ActiveRecord::Base.table_name_prefix = &quot;&quot;
    Category.reset_table_name
    assert_equal &quot;categories_test&quot;, Category.table_name
    ActiveRecord::Base.table_name_suffix = &quot;&quot;
    Category.reset_table_name
    assert_equal &quot;categories&quot;, Category.table_name

    ActiveRecord::Base.pluralize_table_names = false
    ActiveRecord::Base.table_name_prefix = &quot;test_&quot;
    Category.reset_table_name
    assert_equal &quot;test_category&quot;, Category.table_name
    ActiveRecord::Base.table_name_suffix = &quot;_test&quot;
    Category.reset_table_name
    assert_equal &quot;test_category_test&quot;, Category.table_name
    ActiveRecord::Base.table_name_prefix = &quot;&quot;
    Category.reset_table_name
    assert_equal &quot;category_test&quot;, Category.table_name
    ActiveRecord::Base.table_name_suffix = &quot;&quot;
    Category.reset_table_name
    assert_equal &quot;category&quot;, Category.table_name

    ActiveRecord::Base.pluralize_table_names = true
    classes.each(&amp;:reset_table_name)
  end

  def test_destroy_all
    original_count = Topic.count
    topics_by_mary = Topic.count(:conditions =&gt; mary = &quot;author_name = 'Mary'&quot;)

    Topic.destroy_all mary
    assert_equal original_count - topics_by_mary, Topic.count
  end

  def test_destroy_many
    assert_equal 3, Client.count
    Client.destroy([2, 3])
    assert_equal 1, Client.count
  end

  def test_delete_many
    original_count = Topic.count
    Topic.delete(deleting = [1, 2])
    assert_equal original_count - deleting.size, Topic.count
  end

  def test_boolean_attributes
    assert ! Topic.find(1).approved?
    assert Topic.find(2).approved?
  end

  def test_increment_counter
    Topic.increment_counter(&quot;replies_count&quot;, 1)
    assert_equal 2, Topic.find(1).replies_count

    Topic.increment_counter(&quot;replies_count&quot;, 1)
    assert_equal 3, Topic.find(1).replies_count
  end

  def test_decrement_counter
    Topic.decrement_counter(&quot;replies_count&quot;, 2)
    assert_equal -1, Topic.find(2).replies_count

    Topic.decrement_counter(&quot;replies_count&quot;, 2)
    assert_equal -2, Topic.find(2).replies_count
  end

  def test_update_counter
    category = categories(:general)
    assert_nil category.categorizations_count
    assert_equal 2, category.categorizations.count

    Category.update_counters(category.id, &quot;categorizations_count&quot; =&gt; category.categorizations.count)
    category.reload
    assert_not_nil category.categorizations_count
    assert_equal 2, category.categorizations_count

    Category.update_counters(category.id, &quot;categorizations_count&quot; =&gt; category.categorizations.count)
    category.reload
    assert_not_nil category.categorizations_count
    assert_equal 4, category.categorizations_count

    category_2 = categories(:technology)
    count_1, count_2 = (category.categorizations_count || 0), (category_2.categorizations_count || 0)
    Category.update_counters([category.id, category_2.id], &quot;categorizations_count&quot; =&gt; 2)
    category.reload; category_2.reload
    assert_equal count_1 + 2, category.categorizations_count
    assert_equal count_2 + 2, category_2.categorizations_count
  end

  def test_update_all
    assert_equal Topic.count, Topic.update_all(&quot;content = 'bulk updated!'&quot;)
    assert_equal &quot;bulk updated!&quot;, Topic.find(1).content
    assert_equal &quot;bulk updated!&quot;, Topic.find(2).content

    assert_equal Topic.count, Topic.update_all(['content = ?', 'bulk updated again!'])
    assert_equal &quot;bulk updated again!&quot;, Topic.find(1).content
    assert_equal &quot;bulk updated again!&quot;, Topic.find(2).content

    assert_equal Topic.count, Topic.update_all(['content = ?', nil])
    assert_nil Topic.find(1).content
  end

  def test_update_all_with_hash
    assert_not_nil Topic.find(1).last_read
    assert_equal Topic.count, Topic.update_all(:content =&gt; 'bulk updated with hash!', :last_read =&gt; nil)
    assert_equal &quot;bulk updated with hash!&quot;, Topic.find(1).content
    assert_equal &quot;bulk updated with hash!&quot;, Topic.find(2).content
    assert_nil Topic.find(1).last_read
    assert_nil Topic.find(2).last_read
  end

  def test_update_all_with_non_standard_table_name
    assert_equal 1, WarehouseThing.update_all(['value = ?', 0], ['id = ?', 1])
    assert_equal 0, WarehouseThing.find(1).value
  end

  if current_adapter?(:MysqlAdapter)
    def test_update_all_with_order_and_limit
      assert_equal 1, Topic.update_all(&quot;content = 'bulk updated!'&quot;, nil, :limit =&gt; 1, :order =&gt; 'id DESC')
    end
  end

  def test_update_all_ignores_order_without_limit_from_association
    author = authors(:david)
    assert_nothing_raised do
      assert_equal author.posts_with_comments_and_categories.length, author.posts_with_comments_and_categories.update_all([ &quot;body = ?&quot;, &quot;bulk update!&quot; ])
    end
  end

  def test_update_all_with_order_and_limit_updates_subset_only
    author = authors(:david)
    assert_nothing_raised do
      assert_equal 1, author.posts_sorted_by_id_limited.size
      assert_equal 2, author.posts_sorted_by_id_limited.find(:all, :limit =&gt; 2).size
      assert_equal 1, author.posts_sorted_by_id_limited.update_all([ &quot;body = ?&quot;, &quot;bulk update!&quot; ])
      assert_equal &quot;bulk update!&quot;, posts(:welcome).body
      assert_not_equal &quot;bulk update!&quot;, posts(:thinking).body
    end
  end

  def test_update_many
    topic_data = { 1 =&gt; { &quot;content&quot; =&gt; &quot;1 updated&quot; }, 2 =&gt; { &quot;content&quot; =&gt; &quot;2 updated&quot; } }
    updated = Topic.update(topic_data.keys, topic_data.values)

    assert_equal 2, updated.size
    assert_equal &quot;1 updated&quot;, Topic.find(1).content
    assert_equal &quot;2 updated&quot;, Topic.find(2).content
  end

  def test_delete_all
    assert Topic.count &gt; 0

    assert_equal Topic.count, Topic.delete_all
  end

  def test_update_by_condition
    Topic.update_all &quot;content = 'bulk updated!'&quot;, [&quot;approved = ?&quot;, true]
    assert_equal &quot;Have a nice day&quot;, Topic.find(1).content
    assert_equal &quot;bulk updated!&quot;, Topic.find(2).content
  end

  def test_attribute_present
    t = Topic.new
    t.title = &quot;hello there!&quot;
    t.written_on = Time.now
    assert t.attribute_present?(&quot;title&quot;)
    assert t.attribute_present?(&quot;written_on&quot;)
    assert !t.attribute_present?(&quot;content&quot;)
  end

  def test_attribute_keys_on_new_instance
    t = Topic.new
    assert_equal nil, t.title, &quot;The topics table has a title column, so it should be nil&quot;
    assert_raise(NoMethodError) { t.title2 }
  end

  def test_class_name
    assert_equal &quot;Firm&quot;, ActiveRecord::Base.class_name(&quot;firms&quot;)
    assert_equal &quot;Category&quot;, ActiveRecord::Base.class_name(&quot;categories&quot;)
    assert_equal &quot;AccountHolder&quot;, ActiveRecord::Base.class_name(&quot;account_holder&quot;)

    ActiveRecord::Base.pluralize_table_names = false
    assert_equal &quot;Firms&quot;, ActiveRecord::Base.class_name( &quot;firms&quot; )
    ActiveRecord::Base.pluralize_table_names = true

    ActiveRecord::Base.table_name_prefix = &quot;test_&quot;
    assert_equal &quot;Firm&quot;, ActiveRecord::Base.class_name( &quot;test_firms&quot; )
    ActiveRecord::Base.table_name_suffix = &quot;_tests&quot;
    assert_equal &quot;Firm&quot;, ActiveRecord::Base.class_name( &quot;test_firms_tests&quot; )
    ActiveRecord::Base.table_name_prefix = &quot;&quot;
    assert_equal &quot;Firm&quot;, ActiveRecord::Base.class_name( &quot;firms_tests&quot; )
    ActiveRecord::Base.table_name_suffix = &quot;&quot;
    assert_equal &quot;Firm&quot;, ActiveRecord::Base.class_name( &quot;firms&quot; )
  end

  def test_null_fields
    assert_nil Topic.find(1).parent_id
    assert_nil Topic.create(&quot;title&quot; =&gt; &quot;Hey you&quot;).parent_id
  end

  def test_default_values
    topic = Topic.new
    assert topic.approved?
    assert_nil topic.written_on
    assert_nil topic.bonus_time
    assert_nil topic.last_read

    topic.save

    topic = Topic.find(topic.id)
    assert topic.approved?
    assert_nil topic.last_read

    # Oracle has some funky default handling, so it requires a bit of
    # extra testing. See ticket #2788.
    if current_adapter?(:OracleAdapter)
      test = TestOracleDefault.new
      assert_equal &quot;X&quot;, test.test_char
      assert_equal &quot;hello&quot;, test.test_string
      assert_equal 3, test.test_int
    end
  end

  # Oracle, and Sybase do not have a TIME datatype.
  unless current_adapter?(:OracleAdapter, :SybaseAdapter)
    def test_utc_as_time_zone
      Topic.default_timezone = :utc
      attributes = { &quot;bonus_time&quot; =&gt; &quot;5:42:00AM&quot; }
      topic = Topic.find(1)
      topic.attributes = attributes
      assert_equal Time.utc(2000, 1, 1, 5, 42, 0), topic.bonus_time
      Topic.default_timezone = :local
    end

    def test_utc_as_time_zone_and_new
      Topic.default_timezone = :utc
      attributes = { &quot;bonus_time(1i)&quot;=&gt;&quot;2000&quot;,
                     &quot;bonus_time(2i)&quot;=&gt;&quot;1&quot;,
                     &quot;bonus_time(3i)&quot;=&gt;&quot;1&quot;,
                     &quot;bonus_time(4i)&quot;=&gt;&quot;10&quot;,
                     &quot;bonus_time(5i)&quot;=&gt;&quot;35&quot;,
                     &quot;bonus_time(6i)&quot;=&gt;&quot;50&quot; }
      topic = Topic.new(attributes)
      assert_equal Time.utc(2000, 1, 1, 10, 35, 50), topic.bonus_time
      Topic.default_timezone = :local
    end
  end

  def test_default_values_on_empty_strings
    topic = Topic.new
    topic.approved  = nil
    topic.last_read = nil

    topic.save

    topic = Topic.find(topic.id)
    assert_nil topic.last_read

    # Sybase adapter does not allow nulls in boolean columns
    if current_adapter?(:SybaseAdapter)
      assert topic.approved == false
    else
      assert_nil topic.approved
    end
  end

  def test_equality
    assert_equal Topic.find(1), Topic.find(2).topic
  end

  def test_equality_of_new_records
    assert_not_equal Topic.new, Topic.new
  end

  def test_hashing
    assert_equal [ Topic.find(1) ], [ Topic.find(2).topic ] &amp; [ Topic.find(1) ]
  end

  def test_delete_new_record
    client = Client.new
    client.delete
    assert client.frozen?
  end

  def test_delete_record_with_associations
    client = Client.find(3)
    client.delete
    assert client.frozen?
    assert_kind_of Firm, client.firm
    assert_raise(ActiveSupport::FrozenObjectError) { client.name = &quot;something else&quot; }
  end

  def test_destroy_new_record
    client = Client.new
    client.destroy
    assert client.frozen?
  end

  def test_destroy_record_with_associations
    client = Client.find(3)
    client.destroy
    assert client.frozen?
    assert_kind_of Firm, client.firm
    assert_raise(ActiveSupport::FrozenObjectError) { client.name = &quot;something else&quot; }
  end

  def test_update_attribute
    assert !Topic.find(1).approved?
    Topic.find(1).update_attribute(&quot;approved&quot;, true)
    assert Topic.find(1).approved?

    Topic.find(1).update_attribute(:approved, false)
    assert !Topic.find(1).approved?
  end

  def test_update_attributes
    topic = Topic.find(1)
    assert !topic.approved?
    assert_equal &quot;The First Topic&quot;, topic.title

    topic.update_attributes(&quot;approved&quot; =&gt; true, &quot;title&quot; =&gt; &quot;The First Topic Updated&quot;)
    topic.reload
    assert topic.approved?
    assert_equal &quot;The First Topic Updated&quot;, topic.title

    topic.update_attributes(:approved =&gt; false, :title =&gt; &quot;The First Topic&quot;)
    topic.reload
    assert !topic.approved?
    assert_equal &quot;The First Topic&quot;, topic.title
  end

  def test_update_attributes!
    reply = Reply.find(2)
    assert_equal &quot;The Second Topic of the day&quot;, reply.title
    assert_equal &quot;Have a nice day&quot;, reply.content

    reply.update_attributes!(&quot;title&quot; =&gt; &quot;The Second Topic of the day updated&quot;, &quot;content&quot; =&gt; &quot;Have a nice evening&quot;)
    reply.reload
    assert_equal &quot;The Second Topic of the day updated&quot;, reply.title
    assert_equal &quot;Have a nice evening&quot;, reply.content

    reply.update_attributes!(:title =&gt; &quot;The Second Topic of the day&quot;, :content =&gt; &quot;Have a nice day&quot;)
    reply.reload
    assert_equal &quot;The Second Topic of the day&quot;, reply.title
    assert_equal &quot;Have a nice day&quot;, reply.content

    assert_raise(ActiveRecord::RecordInvalid) { reply.update_attributes!(:title =&gt; nil, :content =&gt; &quot;Have a nice evening&quot;) }
  end

  def test_mass_assignment_should_raise_exception_if_accessible_and_protected_attribute_writers_are_both_used
    topic = TopicWithProtectedContentAndAccessibleAuthorName.new
    assert_raise(RuntimeError) { topic.attributes = { &quot;author_name&quot; =&gt; &quot;me&quot; } }
    assert_raise(RuntimeError) { topic.attributes = { &quot;content&quot; =&gt; &quot;stuff&quot; } }
  end

  def test_mass_assignment_protection
    firm = Firm.new
    firm.attributes = { &quot;name&quot; =&gt; &quot;Next Angle&quot;, &quot;rating&quot; =&gt; 5 }
    assert_equal 1, firm.rating
  end

  def test_mass_assignment_protection_against_class_attribute_writers
    [:logger, :configurations, :primary_key_prefix_type, :table_name_prefix, :table_name_suffix, :pluralize_table_names, :colorize_logging,
      :default_timezone, :schema_format, :lock_optimistically, :record_timestamps].each do |method|
      assert  Task.respond_to?(method)
      assert  Task.respond_to?(&quot;#{method}=&quot;)
      assert  Task.new.respond_to?(method)
      assert !Task.new.respond_to?(&quot;#{method}=&quot;)
    end
  end

  def test_customized_primary_key_remains_protected
    subscriber = Subscriber.new(:nick =&gt; 'webster123', :name =&gt; 'nice try')
    assert_nil subscriber.id

    keyboard = Keyboard.new(:key_number =&gt; 9, :name =&gt; 'nice try')
    assert_nil keyboard.id
  end

  def test_customized_primary_key_remains_protected_when_referred_to_as_id
    subscriber = Subscriber.new(:id =&gt; 'webster123', :name =&gt; 'nice try')
    assert_nil subscriber.id

    keyboard = Keyboard.new(:id =&gt; 9, :name =&gt; 'nice try')
    assert_nil keyboard.id
  end

  def test_mass_assigning_invalid_attribute
    firm = Firm.new

    assert_raise(ActiveRecord::UnknownAttributeError) do
      firm.attributes = { &quot;id&quot; =&gt; 5, &quot;type&quot; =&gt; &quot;Client&quot;, &quot;i_dont_even_exist&quot; =&gt; 20 }
    end
  end

  def test_mass_assignment_protection_on_defaults
    firm = Firm.new
    firm.attributes = { &quot;id&quot; =&gt; 5, &quot;type&quot; =&gt; &quot;Client&quot; }
    assert_nil firm.id
    assert_equal &quot;Firm&quot;, firm[:type]
  end

  def test_mass_assignment_accessible
    reply = Reply.new(&quot;title&quot; =&gt; &quot;hello&quot;, &quot;content&quot; =&gt; &quot;world&quot;, &quot;approved&quot; =&gt; true)
    reply.save

    assert reply.approved?

    reply.approved = false
    reply.save

    assert !reply.approved?
  end

  def test_mass_assignment_protection_inheritance
    assert_nil LoosePerson.accessible_attributes
    assert_equal Set.new([ 'credit_rating', 'administrator' ]), LoosePerson.protected_attributes

    assert_nil LooseDescendant.accessible_attributes
    assert_equal Set.new([ 'credit_rating', 'administrator', 'phone_number' ]), LooseDescendant.protected_attributes

    assert_nil LooseDescendantSecond.accessible_attributes
    assert_equal Set.new([ 'credit_rating', 'administrator', 'phone_number', 'name' ]), LooseDescendantSecond.protected_attributes, 'Running attr_protected twice in one class should merge the protections'

    assert_nil TightPerson.protected_attributes
    assert_equal Set.new([ 'name', 'address' ]), TightPerson.accessible_attributes

    assert_nil TightDescendant.protected_attributes
    assert_equal Set.new([ 'name', 'address', 'phone_number' ]), TightDescendant.accessible_attributes
  end

  def test_readonly_attributes
    assert_equal Set.new([ 'title' , 'comments_count' ]), ReadonlyTitlePost.readonly_attributes

    post = ReadonlyTitlePost.create(:title =&gt; &quot;cannot change this&quot;, :body =&gt; &quot;changeable&quot;)
    post.reload
    assert_equal &quot;cannot change this&quot;, post.title

    post.update_attributes(:title =&gt; &quot;try to change&quot;, :body =&gt; &quot;changed&quot;)
    post.reload
    assert_equal &quot;cannot change this&quot;, post.title
    assert_equal &quot;changed&quot;, post.body
  end

  def test_multiparameter_attributes_on_date
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;2004&quot;, &quot;last_read(2i)&quot; =&gt; &quot;6&quot;, &quot;last_read(3i)&quot; =&gt; &quot;24&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    # note that extra #to_date call allows test to pass for Oracle, which
    # treats dates/times the same
    assert_date_from_db Date.new(2004, 6, 24), topic.last_read.to_date
  end

  def test_multiparameter_attributes_on_date_with_empty_year
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;&quot;, &quot;last_read(2i)&quot; =&gt; &quot;6&quot;, &quot;last_read(3i)&quot; =&gt; &quot;24&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    # note that extra #to_date call allows test to pass for Oracle, which
    # treats dates/times the same
    assert_date_from_db Date.new(1, 6, 24), topic.last_read.to_date
  end

  def test_multiparameter_attributes_on_date_with_empty_month
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;2004&quot;, &quot;last_read(2i)&quot; =&gt; &quot;&quot;, &quot;last_read(3i)&quot; =&gt; &quot;24&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    # note that extra #to_date call allows test to pass for Oracle, which
    # treats dates/times the same
    assert_date_from_db Date.new(2004, 1, 24), topic.last_read.to_date
  end

  def test_multiparameter_attributes_on_date_with_empty_day
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;2004&quot;, &quot;last_read(2i)&quot; =&gt; &quot;6&quot;, &quot;last_read(3i)&quot; =&gt; &quot;&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    # note that extra #to_date call allows test to pass for Oracle, which
    # treats dates/times the same
    assert_date_from_db Date.new(2004, 6, 1), topic.last_read.to_date
  end

  def test_multiparameter_attributes_on_date_with_empty_day_and_year
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;&quot;, &quot;last_read(2i)&quot; =&gt; &quot;6&quot;, &quot;last_read(3i)&quot; =&gt; &quot;&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    # note that extra #to_date call allows test to pass for Oracle, which
    # treats dates/times the same
    assert_date_from_db Date.new(1, 6, 1), topic.last_read.to_date
  end

  def test_multiparameter_attributes_on_date_with_empty_day_and_month
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;2004&quot;, &quot;last_read(2i)&quot; =&gt; &quot;&quot;, &quot;last_read(3i)&quot; =&gt; &quot;&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    # note that extra #to_date call allows test to pass for Oracle, which
    # treats dates/times the same
    assert_date_from_db Date.new(2004, 1, 1), topic.last_read.to_date
  end

  def test_multiparameter_attributes_on_date_with_empty_year_and_month
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;&quot;, &quot;last_read(2i)&quot; =&gt; &quot;&quot;, &quot;last_read(3i)&quot; =&gt; &quot;24&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    # note that extra #to_date call allows test to pass for Oracle, which
    # treats dates/times the same
    assert_date_from_db Date.new(1, 1, 24), topic.last_read.to_date
  end

  def test_multiparameter_attributes_on_date_with_all_empty
    attributes = { &quot;last_read(1i)&quot; =&gt; &quot;&quot;, &quot;last_read(2i)&quot; =&gt; &quot;&quot;, &quot;last_read(3i)&quot; =&gt; &quot;&quot; }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_nil topic.last_read
  end

  def test_multiparameter_attributes_on_time
    attributes = {
      &quot;written_on(1i)&quot; =&gt; &quot;2004&quot;, &quot;written_on(2i)&quot; =&gt; &quot;6&quot;, &quot;written_on(3i)&quot; =&gt; &quot;24&quot;,
      &quot;written_on(4i)&quot; =&gt; &quot;16&quot;, &quot;written_on(5i)&quot; =&gt; &quot;24&quot;, &quot;written_on(6i)&quot; =&gt; &quot;00&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on
  end

  def test_multiparameter_attributes_on_time_with_old_date
    attributes = {
      &quot;written_on(1i)&quot; =&gt; &quot;1850&quot;, &quot;written_on(2i)&quot; =&gt; &quot;6&quot;, &quot;written_on(3i)&quot; =&gt; &quot;24&quot;,
      &quot;written_on(4i)&quot; =&gt; &quot;16&quot;, &quot;written_on(5i)&quot; =&gt; &quot;24&quot;, &quot;written_on(6i)&quot; =&gt; &quot;00&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    # testing against to_s(:db) representation because either a Time or a DateTime might be returned, depending on platform
    assert_equal &quot;1850-06-24 16:24:00&quot;, topic.written_on.to_s(:db)
  end

  def test_multiparameter_attributes_on_time_with_utc
    ActiveRecord::Base.default_timezone = :utc
    attributes = {
      &quot;written_on(1i)&quot; =&gt; &quot;2004&quot;, &quot;written_on(2i)&quot; =&gt; &quot;6&quot;, &quot;written_on(3i)&quot; =&gt; &quot;24&quot;,
      &quot;written_on(4i)&quot; =&gt; &quot;16&quot;, &quot;written_on(5i)&quot; =&gt; &quot;24&quot;, &quot;written_on(6i)&quot; =&gt; &quot;00&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on
  ensure
    ActiveRecord::Base.default_timezone = :local
  end

  def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes
    ActiveRecord::Base.time_zone_aware_attributes = true
    ActiveRecord::Base.default_timezone = :utc
    Time.zone = ActiveSupport::TimeZone[-28800]
    attributes = {
      &quot;written_on(1i)&quot; =&gt; &quot;2004&quot;, &quot;written_on(2i)&quot; =&gt; &quot;6&quot;, &quot;written_on(3i)&quot; =&gt; &quot;24&quot;,
      &quot;written_on(4i)&quot; =&gt; &quot;16&quot;, &quot;written_on(5i)&quot; =&gt; &quot;24&quot;, &quot;written_on(6i)&quot; =&gt; &quot;00&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.utc(2004, 6, 24, 23, 24, 0), topic.written_on
    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on.time
    assert_equal Time.zone, topic.written_on.time_zone
  ensure
    ActiveRecord::Base.time_zone_aware_attributes = false
    ActiveRecord::Base.default_timezone = :local
    Time.zone = nil
  end

  def test_multiparameter_attributes_on_time_with_time_zone_aware_attributes_false
    ActiveRecord::Base.time_zone_aware_attributes = false
    Time.zone = ActiveSupport::TimeZone[-28800]
    attributes = {
      &quot;written_on(1i)&quot; =&gt; &quot;2004&quot;, &quot;written_on(2i)&quot; =&gt; &quot;6&quot;, &quot;written_on(3i)&quot; =&gt; &quot;24&quot;,
      &quot;written_on(4i)&quot; =&gt; &quot;16&quot;, &quot;written_on(5i)&quot; =&gt; &quot;24&quot;, &quot;written_on(6i)&quot; =&gt; &quot;00&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on
    assert_equal false, topic.written_on.respond_to?(:time_zone)
  ensure
    Time.zone = nil
  end

  def test_multiparameter_attributes_on_time_with_skip_time_zone_conversion_for_attributes
    ActiveRecord::Base.time_zone_aware_attributes = true
    ActiveRecord::Base.default_timezone = :utc
    Time.zone = ActiveSupport::TimeZone[-28800]
    Topic.skip_time_zone_conversion_for_attributes = [:written_on]
    attributes = {
      &quot;written_on(1i)&quot; =&gt; &quot;2004&quot;, &quot;written_on(2i)&quot; =&gt; &quot;6&quot;, &quot;written_on(3i)&quot; =&gt; &quot;24&quot;,
      &quot;written_on(4i)&quot; =&gt; &quot;16&quot;, &quot;written_on(5i)&quot; =&gt; &quot;24&quot;, &quot;written_on(6i)&quot; =&gt; &quot;00&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.utc(2004, 6, 24, 16, 24, 0), topic.written_on
    assert_equal false, topic.written_on.respond_to?(:time_zone)
  ensure
    ActiveRecord::Base.time_zone_aware_attributes = false
    ActiveRecord::Base.default_timezone = :local
    Time.zone = nil
    Topic.skip_time_zone_conversion_for_attributes = []
  end

  def test_multiparameter_attributes_on_time_only_column_with_time_zone_aware_attributes_does_not_do_time_zone_conversion
    ActiveRecord::Base.time_zone_aware_attributes = true
    ActiveRecord::Base.default_timezone = :utc
    Time.zone = ActiveSupport::TimeZone[-28800]
    attributes = {
      &quot;bonus_time(1i)&quot; =&gt; &quot;2000&quot;, &quot;bonus_time(2i)&quot; =&gt; &quot;1&quot;, &quot;bonus_time(3i)&quot; =&gt; &quot;1&quot;,
      &quot;bonus_time(4i)&quot; =&gt; &quot;16&quot;, &quot;bonus_time(5i)&quot; =&gt; &quot;24&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.utc(2000, 1, 1, 16, 24, 0), topic.bonus_time
    assert topic.bonus_time.utc?
  ensure
    ActiveRecord::Base.time_zone_aware_attributes = false
    ActiveRecord::Base.default_timezone = :local
    Time.zone = nil
  end

  def test_multiparameter_attributes_on_time_with_empty_seconds
    attributes = {
      &quot;written_on(1i)&quot; =&gt; &quot;2004&quot;, &quot;written_on(2i)&quot; =&gt; &quot;6&quot;, &quot;written_on(3i)&quot; =&gt; &quot;24&quot;,
      &quot;written_on(4i)&quot; =&gt; &quot;16&quot;, &quot;written_on(5i)&quot; =&gt; &quot;24&quot;, &quot;written_on(6i)&quot; =&gt; &quot;&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.local(2004, 6, 24, 16, 24, 0), topic.written_on
  end

  def test_multiparameter_mass_assignment_protector
    task = Task.new
    time = Time.mktime(2000, 1, 1, 1)
    task.starting = time
    attributes = { &quot;starting(1i)&quot; =&gt; &quot;2004&quot;, &quot;starting(2i)&quot; =&gt; &quot;6&quot;, &quot;starting(3i)&quot; =&gt; &quot;24&quot; }
    task.attributes = attributes
    assert_equal time, task.starting
  end

  def test_multiparameter_assignment_of_aggregation
    customer = Customer.new
    address = Address.new(&quot;The Street&quot;, &quot;The City&quot;, &quot;The Country&quot;)
    attributes = { &quot;address(1)&quot; =&gt; address.street, &quot;address(2)&quot; =&gt; address.city, &quot;address(3)&quot; =&gt; address.country }
    customer.attributes = attributes
    assert_equal address, customer.address
  end

  def test_attributes_on_dummy_time
    # Oracle, and Sybase do not have a TIME datatype.
    return true if current_adapter?(:OracleAdapter, :SybaseAdapter)

    attributes = {
      &quot;bonus_time&quot; =&gt; &quot;5:42:00AM&quot;
    }
    topic = Topic.find(1)
    topic.attributes = attributes
    assert_equal Time.local(2000, 1, 1, 5, 42, 0), topic.bonus_time
  end

  def test_boolean
    b_nil = Booleantest.create({ &quot;value&quot; =&gt; nil })
    nil_id = b_nil.id
    b_false = Booleantest.create({ &quot;value&quot; =&gt; false })
    false_id = b_false.id
    b_true = Booleantest.create({ &quot;value&quot; =&gt; true })
    true_id = b_true.id

    b_nil = Booleantest.find(nil_id)
    assert_nil b_nil.value
    b_false = Booleantest.find(false_id)
    assert !b_false.value?
    b_true = Booleantest.find(true_id)
    assert b_true.value?
  end

  def test_boolean_cast_from_string
    b_blank = Booleantest.create({ &quot;value&quot; =&gt; &quot;&quot; })
    blank_id = b_blank.id
    b_false = Booleantest.create({ &quot;value&quot; =&gt; &quot;0&quot; })
    false_id = b_false.id
    b_true = Booleantest.create({ &quot;value&quot; =&gt; &quot;1&quot; })
    true_id = b_true.id

    b_blank = Booleantest.find(blank_id)
    assert_nil b_blank.value
    b_false = Booleantest.find(false_id)
    assert !b_false.value?
    b_true = Booleantest.find(true_id)
    assert b_true.value?
  end

  def test_new_record_returns_boolean
    assert_equal Topic.new.new_record?, true
    assert_equal Topic.find(1).new_record?, false
  end

  def test_clone
    topic = Topic.find(1)
    cloned_topic = nil
    assert_nothing_raised { cloned_topic = topic.clone }
    assert_equal topic.title, cloned_topic.title
    assert cloned_topic.new_record?

    # test if the attributes have been cloned
    topic.title = &quot;a&quot;
    cloned_topic.title = &quot;b&quot;
    assert_equal &quot;a&quot;, topic.title
    assert_equal &quot;b&quot;, cloned_topic.title

    # test if the attribute values have been cloned
    topic.title = {&quot;a&quot; =&gt; &quot;b&quot;}
    cloned_topic = topic.clone
    cloned_topic.title[&quot;a&quot;] = &quot;c&quot;
    assert_equal &quot;b&quot;, topic.title[&quot;a&quot;]

    #test if attributes set as part of after_initialize are cloned correctly
    assert_equal topic.author_email_address, cloned_topic.author_email_address

    # test if saved clone object differs from original
    cloned_topic.save
    assert !cloned_topic.new_record?
    assert cloned_topic.id != topic.id
  end

  def test_clone_with_aggregate_of_same_name_as_attribute
    dev = DeveloperWithAggregate.find(1)
    assert_kind_of DeveloperSalary, dev.salary

    clone = nil
    assert_nothing_raised { clone = dev.clone }
    assert_kind_of DeveloperSalary, clone.salary
    assert_equal dev.salary.amount, clone.salary.amount
    assert clone.new_record?

    # test if the attributes have been cloned
    original_amount = clone.salary.amount
    dev.salary.amount = 1
    assert_equal original_amount, clone.salary.amount

    assert clone.save
    assert !clone.new_record?
    assert clone.id != dev.id
  end

  def test_clone_preserves_subtype
    clone = nil
    assert_nothing_raised { clone = Company.find(3).clone }
    assert_kind_of Client, clone
  end

  def test_bignum
    company = Company.find(1)
    company.rating = 2147483647
    company.save
    company = Company.find(1)
    assert_equal 2147483647, company.rating
  end

  # TODO: extend defaults tests to other databases!
  if current_adapter?(:PostgreSQLAdapter)
    def test_default
      default = Default.new

      # fixed dates / times
      assert_equal Date.new(2004, 1, 1), default.fixed_date
      assert_equal Time.local(2004, 1,1,0,0,0,0), default.fixed_time

      # char types
      assert_equal 'Y', default.char1
      assert_equal 'a varchar field', default.char2
      assert_equal 'a text field', default.char3
    end

    class Geometric &lt; ActiveRecord::Base; end
    def test_geometric_content

      # accepted format notes:
      # ()'s aren't required
      # values can be a mix of float or integer

      g = Geometric.new(
        :a_point        =&gt; '(5.0, 6.1)',
        #:a_line         =&gt; '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql
        :a_line_segment =&gt; '(2.0, 3), (5.5, 7.0)',
        :a_box          =&gt; '2.0, 3, 5.5, 7.0',
        :a_path         =&gt; '[(2.0, 3), (5.5, 7.0), (8.5, 11.0)]',  # [ ] is an open path
        :a_polygon      =&gt; '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',
        :a_circle       =&gt; '&lt;(5.3, 10.4), 2&gt;'
      )

      assert g.save

      # Reload and check that we have all the geometric attributes.
      h = Geometric.find(g.id)

      assert_equal '(5,6.1)', h.a_point
      assert_equal '[(2,3),(5.5,7)]', h.a_line_segment
      assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner
      assert_equal '[(2,3),(5.5,7),(8.5,11)]', h.a_path
      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon
      assert_equal '&lt;(5.3,10.4),2&gt;', h.a_circle

      # use a geometric function to test for an open path
      objs = Geometric.find_by_sql [&quot;select isopen(a_path) from geometrics where id = ?&quot;, g.id]
      assert_equal objs[0].isopen, 't'

      # test alternate formats when defining the geometric types

      g = Geometric.new(
        :a_point        =&gt; '5.0, 6.1',
        #:a_line         =&gt; '((2.0, 3), (5.5, 7.0))' # line type is currently unsupported in postgresql
        :a_line_segment =&gt; '((2.0, 3), (5.5, 7.0))',
        :a_box          =&gt; '(2.0, 3), (5.5, 7.0)',
        :a_path         =&gt; '((2.0, 3), (5.5, 7.0), (8.5, 11.0))',  # ( ) is a closed path
        :a_polygon      =&gt; '2.0, 3, 5.5, 7.0, 8.5, 11.0',
        :a_circle       =&gt; '((5.3, 10.4), 2)'
      )

      assert g.save

      # Reload and check that we have all the geometric attributes.
      h = Geometric.find(g.id)

      assert_equal '(5,6.1)', h.a_point
      assert_equal '[(2,3),(5.5,7)]', h.a_line_segment
      assert_equal '(5.5,7),(2,3)', h.a_box   # reordered to store upper right corner then bottom left corner
      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_path
      assert_equal '((2,3),(5.5,7),(8.5,11))', h.a_polygon
      assert_equal '&lt;(5.3,10.4),2&gt;', h.a_circle

      # use a geometric function to test for an closed path
      objs = Geometric.find_by_sql [&quot;select isclosed(a_path) from geometrics where id = ?&quot;, g.id]
      assert_equal objs[0].isclosed, 't'
    end
  end

  class NumericData &lt; ActiveRecord::Base
    self.table_name = 'numeric_data'
  end

  def test_numeric_fields
    m = NumericData.new(
      :bank_balance =&gt; 1586.43,
      :big_bank_balance =&gt; BigDecimal(&quot;1000234000567.95&quot;),
      :world_population =&gt; 6000000000,
      :my_house_population =&gt; 3
    )
    assert m.save

    m1 = NumericData.find(m.id)
    assert_not_nil m1

    # As with migration_test.rb, we should make world_population &gt;= 2**62
    # to cover 64-bit platforms and test it is a Bignum, but the main thing
    # is that it's an Integer.
    assert_kind_of Integer, m1.world_population
    assert_equal 6000000000, m1.world_population

    assert_kind_of Fixnum, m1.my_house_population
    assert_equal 3, m1.my_house_population

    assert_kind_of BigDecimal, m1.bank_balance
    assert_equal BigDecimal(&quot;1586.43&quot;), m1.bank_balance

    assert_kind_of BigDecimal, m1.big_bank_balance
    assert_equal BigDecimal(&quot;1000234000567.95&quot;), m1.big_bank_balance
  end

  def test_auto_id
    auto = AutoId.new
    auto.save
    assert (auto.id &gt; 0)
  end

  def quote_column_name(name)
    &quot;&lt;#{name}&gt;&quot;
  end

  def test_quote_keys
    ar = AutoId.new
    source = {&quot;foo&quot; =&gt; &quot;bar&quot;, &quot;baz&quot; =&gt; &quot;quux&quot;}
    actual = ar.send(:quote_columns, self, source)
    inverted = actual.invert
    assert_equal(&quot;&lt;foo&gt;&quot;, inverted[&quot;bar&quot;])
    assert_equal(&quot;&lt;baz&gt;&quot;, inverted[&quot;quux&quot;])
  end

  def test_sql_injection_via_find
    assert_raise(ActiveRecord::RecordNotFound, ActiveRecord::StatementInvalid) do
      Topic.find(&quot;123456 OR id &gt; 0&quot;)
    end
  end

  def test_column_name_properly_quoted
    col_record = ColumnName.new
    col_record.references = 40
    assert col_record.save
    col_record.references = 41
    assert col_record.save
    assert_not_nil c2 = ColumnName.find(col_record.id)
    assert_equal(41, c2.references)
  end

  def test_quoting_arrays
    replies = Reply.find(:all, :conditions =&gt; [ &quot;id IN (?)&quot;, topics(:first).replies.collect(&amp;:id) ])
    assert_equal topics(:first).replies.size, replies.size

    replies = Reply.find(:all, :conditions =&gt; [ &quot;id IN (?)&quot;, [] ])
    assert_equal 0, replies.size
  end

  MyObject = Struct.new :attribute1, :attribute2

  def test_serialized_attribute
    myobj = MyObject.new('value1', 'value2')
    topic = Topic.create(&quot;content&quot; =&gt; myobj)
    Topic.serialize(&quot;content&quot;, MyObject)
    assert_equal(myobj, topic.content)
  end

  def test_serialized_time_attribute
    myobj = Time.local(2008,1,1,1,0)
    topic = Topic.create(&quot;content&quot; =&gt; myobj).reload
    assert_equal(myobj, topic.content)
  end

  def test_serialized_string_attribute
    myobj = &quot;Yes&quot;
    topic = Topic.create(&quot;content&quot; =&gt; myobj).reload
    assert_equal(myobj, topic.content)
  end

  def test_nil_serialized_attribute_with_class_constraint
    myobj = MyObject.new('value1', 'value2')
    topic = Topic.new
    assert_nil topic.content
  end

  def test_should_raise_exception_on_serialized_attribute_with_type_mismatch
    myobj = MyObject.new('value1', 'value2')
    topic = Topic.new(:content =&gt; myobj)
    assert topic.save
    Topic.serialize(:content, Hash)
    assert_raise(ActiveRecord::SerializationTypeMismatch) { Topic.find(topic.id).content }
  ensure
    Topic.serialize(:content)
  end

  def test_serialized_attribute_with_class_constraint
    settings = { &quot;color&quot; =&gt; &quot;blue&quot; }
    Topic.serialize(:content, Hash)
    topic = Topic.new(:content =&gt; settings)
    assert topic.save
    assert_equal(settings, Topic.find(topic.id).content)
  ensure
    Topic.serialize(:content)
  end

  def test_quote
    author_name = &quot;\\ \001 ' \n \\n \&quot;&quot;
    topic = Topic.create('author_name' =&gt; author_name)
    assert_equal author_name, Topic.find(topic.id).author_name
  end

  if RUBY_VERSION &lt; '1.9'
    def test_quote_chars
      with_kcode('UTF8') do
        str = 'The Narrator'
        topic = Topic.create(:author_name =&gt; str)
        assert_equal str, topic.author_name

        assert_kind_of ActiveSupport::Multibyte.proxy_class, str.mb_chars
        topic = Topic.find_by_author_name(str.mb_chars)

        assert_kind_of Topic, topic
        assert_equal str, topic.author_name, &quot;The right topic should have been found by name even with name passed as Chars&quot;
      end
    end
  end

  def test_class_level_destroy
    should_be_destroyed_reply = Reply.create(&quot;title&quot; =&gt; &quot;hello&quot;, &quot;content&quot; =&gt; &quot;world&quot;)
    Topic.find(1).replies &lt;&lt; should_be_destroyed_reply

    Topic.destroy(1)
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1) }
    assert_raise(ActiveRecord::RecordNotFound) { Reply.find(should_be_destroyed_reply.id) }
  end

  def test_class_level_delete
    should_be_destroyed_reply = Reply.create(&quot;title&quot; =&gt; &quot;hello&quot;, &quot;content&quot; =&gt; &quot;world&quot;)
    Topic.find(1).replies &lt;&lt; should_be_destroyed_reply

    Topic.delete(1)
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1) }
    assert_nothing_raised { Reply.find(should_be_destroyed_reply.id) }
  end

  def test_increment_attribute
    assert_equal 50, accounts(:signals37).credit_limit
    accounts(:signals37).increment! :credit_limit
    assert_equal 51, accounts(:signals37, :reload).credit_limit

    accounts(:signals37).increment(:credit_limit).increment!(:credit_limit)
    assert_equal 53, accounts(:signals37, :reload).credit_limit
  end

  def test_increment_nil_attribute
    assert_nil topics(:first).parent_id
    topics(:first).increment! :parent_id
    assert_equal 1, topics(:first).parent_id
  end

  def test_increment_attribute_by
    assert_equal 50, accounts(:signals37).credit_limit
    accounts(:signals37).increment! :credit_limit, 5
    assert_equal 55, accounts(:signals37, :reload).credit_limit

    accounts(:signals37).increment(:credit_limit, 1).increment!(:credit_limit, 3)
    assert_equal 59, accounts(:signals37, :reload).credit_limit
  end

  def test_decrement_attribute
    assert_equal 50, accounts(:signals37).credit_limit

    accounts(:signals37).decrement!(:credit_limit)
    assert_equal 49, accounts(:signals37, :reload).credit_limit

    accounts(:signals37).decrement(:credit_limit).decrement!(:credit_limit)
    assert_equal 47, accounts(:signals37, :reload).credit_limit
  end

  def test_decrement_attribute_by
    assert_equal 50, accounts(:signals37).credit_limit
    accounts(:signals37).decrement! :credit_limit, 5
    assert_equal 45, accounts(:signals37, :reload).credit_limit

    accounts(:signals37).decrement(:credit_limit, 1).decrement!(:credit_limit, 3)
    assert_equal 41, accounts(:signals37, :reload).credit_limit
  end

  def test_toggle_attribute
    assert !topics(:first).approved?
    topics(:first).toggle!(:approved)
    assert topics(:first).approved?
    topic = topics(:first)
    topic.toggle(:approved)
    assert !topic.approved?
    topic.reload
    assert topic.approved?
  end

  def test_reload
    t1 = Topic.find(1)
    t2 = Topic.find(1)
    t1.title = &quot;something else&quot;
    t1.save
    t2.reload
    assert_equal t1.title, t2.title
  end

  def test_define_attr_method_with_value
    k = Class.new( ActiveRecord::Base )
    k.send(:define_attr_method, :table_name, &quot;foo&quot;)
    assert_equal &quot;foo&quot;, k.table_name
  end

  def test_define_attr_method_with_block
    k = Class.new( ActiveRecord::Base )
    k.send(:define_attr_method, :primary_key) { &quot;sys_&quot; + original_primary_key }
    assert_equal &quot;sys_id&quot;, k.primary_key
  end

  def test_set_table_name_with_value
    k = Class.new( ActiveRecord::Base )
    k.table_name = &quot;foo&quot;
    assert_equal &quot;foo&quot;, k.table_name
    k.set_table_name &quot;bar&quot;
    assert_equal &quot;bar&quot;, k.table_name
  end

  def test_set_table_name_with_block
    k = Class.new( ActiveRecord::Base )
    k.set_table_name { &quot;ks&quot; }
    assert_equal &quot;ks&quot;, k.table_name
  end

  def test_set_primary_key_with_value
    k = Class.new( ActiveRecord::Base )
    k.primary_key = &quot;foo&quot;
    assert_equal &quot;foo&quot;, k.primary_key
    k.set_primary_key &quot;bar&quot;
    assert_equal &quot;bar&quot;, k.primary_key
  end

  def test_set_primary_key_with_block
    k = Class.new( ActiveRecord::Base )
    k.set_primary_key { &quot;sys_&quot; + original_primary_key }
    assert_equal &quot;sys_id&quot;, k.primary_key
  end

  def test_set_inheritance_column_with_value
    k = Class.new( ActiveRecord::Base )
    k.inheritance_column = &quot;foo&quot;
    assert_equal &quot;foo&quot;, k.inheritance_column
    k.set_inheritance_column &quot;bar&quot;
    assert_equal &quot;bar&quot;, k.inheritance_column
  end

  def test_set_inheritance_column_with_block
    k = Class.new( ActiveRecord::Base )
    k.set_inheritance_column { original_inheritance_column + &quot;_id&quot; }
    assert_equal &quot;type_id&quot;, k.inheritance_column
  end

  def test_count_with_join
    res = Post.count_by_sql &quot;SELECT COUNT(*) FROM posts LEFT JOIN comments ON posts.id=comments.post_id WHERE posts.#{QUOTED_TYPE} = 'Post'&quot;

    res2 = Post.count(:conditions =&gt; &quot;posts.#{QUOTED_TYPE} = 'Post'&quot;, :joins =&gt; &quot;LEFT JOIN comments ON posts.id=comments.post_id&quot;)
    assert_equal res, res2

    res3 = nil
    assert_nothing_raised do
      res3 = Post.count(:conditions =&gt; &quot;posts.#{QUOTED_TYPE} = 'Post'&quot;,
                        :joins =&gt; &quot;LEFT JOIN comments ON posts.id=comments.post_id&quot;)
    end
    assert_equal res, res3

    res4 = Post.count_by_sql &quot;SELECT COUNT(p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id&quot;
    res5 = nil
    assert_nothing_raised do
      res5 = Post.count(:conditions =&gt; &quot;p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id&quot;,
                        :joins =&gt; &quot;p, comments co&quot;,
                        :select =&gt; &quot;p.id&quot;)
    end

    assert_equal res4, res5

    unless current_adapter?(:SQLite2Adapter, :DeprecatedSQLiteAdapter)
      res6 = Post.count_by_sql &quot;SELECT COUNT(DISTINCT p.id) FROM posts p, comments co WHERE p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id&quot;
      res7 = nil
      assert_nothing_raised do
        res7 = Post.count(:conditions =&gt; &quot;p.#{QUOTED_TYPE} = 'Post' AND p.id=co.post_id&quot;,
                          :joins =&gt; &quot;p, comments co&quot;,
                          :select =&gt; &quot;p.id&quot;,
                          :distinct =&gt; true)
      end
      assert_equal res6, res7
    end
  end

  def test_clear_association_cache_stored
    firm = Firm.find(1)
    assert_kind_of Firm, firm

    firm.clear_association_cache
    assert_equal Firm.find(1).clients.collect{ |x| x.name }.sort, firm.clients.collect{ |x| x.name }.sort
  end

  def test_clear_association_cache_new_record
     firm            = Firm.new
     client_stored   = Client.find(3)
     client_new      = Client.new
     client_new.name = &quot;The Joneses&quot;
     clients         = [ client_stored, client_new ]

     firm.clients    &lt;&lt; clients
     assert_equal clients.map(&amp;:name).to_set, firm.clients.map(&amp;:name).to_set

     firm.clear_association_cache
     assert_equal clients.map(&amp;:name).to_set, firm.clients.map(&amp;:name).to_set
  end

  def test_interpolate_sql
    assert_nothing_raised { Category.new.send(:interpolate_sql, 'foo@bar') }
    assert_nothing_raised { Category.new.send(:interpolate_sql, 'foo bar) baz') }
    assert_nothing_raised { Category.new.send(:interpolate_sql, 'foo bar} baz') }
  end

  def test_scoped_find_conditions
    scoped_developers = Developer.with_scope(:find =&gt; { :conditions =&gt; 'salary &gt; 90000' }) do
      Developer.find(:all, :conditions =&gt; 'id &lt; 5')
    end
    assert !scoped_developers.include?(developers(:david)) # David's salary is less than 90,000
    assert_equal 3, scoped_developers.size
  end

  def test_scoped_find_limit_offset
    scoped_developers = Developer.with_scope(:find =&gt; { :limit =&gt; 3, :offset =&gt; 2 }) do
      Developer.find(:all, :order =&gt; 'id')
    end
    assert !scoped_developers.include?(developers(:david))
    assert !scoped_developers.include?(developers(:jamis))
    assert_equal 3, scoped_developers.size

    # Test without scoped find conditions to ensure we get the whole thing
    developers = Developer.find(:all, :order =&gt; 'id')
    assert_equal Developer.count, developers.size
  end

  def test_scoped_find_order
    # Test order in scope
    scoped_developers = Developer.with_scope(:find =&gt; { :limit =&gt; 1, :order =&gt; 'salary DESC' }) do
      Developer.find(:all)
    end
    assert_equal 'Jamis', scoped_developers.first.name
    assert scoped_developers.include?(developers(:jamis))
    # Test scope without order and order in find
    scoped_developers = Developer.with_scope(:find =&gt; { :limit =&gt; 1 }) do
      Developer.find(:all, :order =&gt; 'salary DESC')
    end
    # Test scope order + find order, find has priority
    scoped_developers = Developer.with_scope(:find =&gt; { :limit =&gt; 3, :order =&gt; 'id DESC' }) do
      Developer.find(:all, :order =&gt; 'salary ASC')
    end
    assert scoped_developers.include?(developers(:poor_jamis))
    assert scoped_developers.include?(developers(:david))
    assert scoped_developers.include?(developers(:dev_10))
    # Test without scoped find conditions to ensure we get the right thing
    developers = Developer.find(:all, :order =&gt; 'id', :limit =&gt; 1)
    assert scoped_developers.include?(developers(:david))
  end

  def test_scoped_find_limit_offset_including_has_many_association
    topics = Topic.with_scope(:find =&gt; {:limit =&gt; 1, :offset =&gt; 1, :include =&gt; :replies}) do
      Topic.find(:all, :order =&gt; &quot;topics.id&quot;)
    end
    assert_equal 1, topics.size
    assert_equal 2, topics.first.id
  end

  def test_scoped_find_order_including_has_many_association
    developers = Developer.with_scope(:find =&gt; { :order =&gt; 'developers.salary DESC', :include =&gt; :projects }) do
      Developer.find(:all)
    end
    assert developers.size &gt;= 2
    for i in 1...developers.size
      assert developers[i-1].salary &gt;= developers[i].salary
    end
  end

  def test_scoped_find_with_group_and_having
    developers = Developer.with_scope(:find =&gt; { :group =&gt; 'developers.salary', :having =&gt; &quot;SUM(salary) &gt; 10000&quot;, :select =&gt; &quot;SUM(salary) as salary&quot; }) do
      Developer.find(:all)
    end
    assert_equal 3, developers.size
  end

  def test_find_last
    last  = Developer.find :last
    assert_equal last, Developer.find(:first, :order =&gt; 'id desc')
  end

  def test_last
    assert_equal Developer.find(:first, :order =&gt; 'id desc'), Developer.last
  end

  def test_all_with_conditions
    assert_equal Developer.find(:all, :order =&gt; 'id desc'), Developer.all(:order =&gt; 'id desc')
  end

  def test_find_ordered_last
    last  = Developer.find :last, :order =&gt; 'developers.salary ASC'
    assert_equal last, Developer.find(:all, :order =&gt; 'developers.salary ASC').last
  end

  def test_find_reverse_ordered_last
    last  = Developer.find :last, :order =&gt; 'developers.salary DESC'
    assert_equal last, Developer.find(:all, :order =&gt; 'developers.salary DESC').last
  end

  def test_find_multiple_ordered_last
    last  = Developer.find :last, :order =&gt; 'developers.name, developers.salary DESC'
    assert_equal last, Developer.find(:all, :order =&gt; 'developers.name, developers.salary DESC').last
  end

  def test_find_symbol_ordered_last
    last  = Developer.find :last, :order =&gt; :salary
    assert_equal last, Developer.find(:all, :order =&gt; :salary).last
  end

  def test_find_scoped_ordered_last
    last_developer = Developer.with_scope(:find =&gt; { :order =&gt; 'developers.salary ASC' }) do
      Developer.find(:last)
    end
    assert_equal last_developer, Developer.find(:all, :order =&gt; 'developers.salary ASC').last
  end

  def test_abstract_class
    assert !ActiveRecord::Base.abstract_class?
    assert LoosePerson.abstract_class?
    assert !LooseDescendant.abstract_class?
  end

  def test_base_class
    assert_equal LoosePerson,     LoosePerson.base_class
    assert_equal LooseDescendant, LooseDescendant.base_class
    assert_equal TightPerson,     TightPerson.base_class
    assert_equal TightPerson,     TightDescendant.base_class

    assert_equal Post, Post.base_class
    assert_equal Post, SpecialPost.base_class
    assert_equal Post, StiPost.base_class
    assert_equal SubStiPost, SubStiPost.base_class
  end

  def test_descends_from_active_record
    # Tries to call Object.abstract_class?
    assert_raise(NoMethodError) do
      ActiveRecord::Base.descends_from_active_record?
    end

    # Abstract subclass of AR::Base.
    assert LoosePerson.descends_from_active_record?

    # Concrete subclass of an abstract class.
    assert LooseDescendant.descends_from_active_record?

    # Concrete subclass of AR::Base.
    assert TightPerson.descends_from_active_record?

    # Concrete subclass of a concrete class but has no type column.
    assert TightDescendant.descends_from_active_record?

    # Concrete subclass of AR::Base.
    assert Post.descends_from_active_record?

    # Abstract subclass of a concrete class which has a type column.
    # This is pathological, as you'll never have Sub &lt; Abstract &lt; Concrete.
    assert !StiPost.descends_from_active_record?

    # Concrete subclasses an abstract class which has a type column.
    assert !SubStiPost.descends_from_active_record?
  end

  def test_find_on_abstract_base_class_doesnt_use_type_condition
    old_class = LooseDescendant
    Object.send :remove_const, :LooseDescendant

    descendant = old_class.create! :first_name =&gt; 'bob'
    assert_not_nil LoosePerson.find(descendant.id), &quot;Should have found instance of LooseDescendant when finding abstract LoosePerson: #{descendant.inspect}&quot;
  ensure
    unless Object.const_defined?(:LooseDescendant)
      Object.const_set :LooseDescendant, old_class
    end
  end

  def test_assert_queries
    query = lambda { ActiveRecord::Base.connection.execute 'select count(*) from developers' }
    assert_queries(2) { 2.times { query.call } }
    assert_queries 1, &amp;query
    assert_no_queries { assert true }
  end

  def test_to_xml
    xml = REXML::Document.new(topics(:first).to_xml(:indent =&gt; 0))
    bonus_time_in_current_timezone = topics(:first).bonus_time.xmlschema
    written_on_in_current_timezone = topics(:first).written_on.xmlschema
    last_read_in_current_timezone = topics(:first).last_read.xmlschema

    assert_equal &quot;topic&quot;, xml.root.name
    assert_equal &quot;The First Topic&quot; , xml.elements[&quot;//title&quot;].text
    assert_equal &quot;David&quot; , xml.elements[&quot;//author-name&quot;].text

    assert_equal &quot;1&quot;, xml.elements[&quot;//id&quot;].text
    assert_equal &quot;integer&quot; , xml.elements[&quot;//id&quot;].attributes['type']

    assert_equal &quot;1&quot;, xml.elements[&quot;//replies-count&quot;].text
    assert_equal &quot;integer&quot; , xml.elements[&quot;//replies-count&quot;].attributes['type']

    assert_equal written_on_in_current_timezone, xml.elements[&quot;//written-on&quot;].text
    assert_equal &quot;datetime&quot; , xml.elements[&quot;//written-on&quot;].attributes['type']

    assert_equal &quot;--- Have a nice day\n&quot; , xml.elements[&quot;//content&quot;].text
    assert_equal &quot;yaml&quot; , xml.elements[&quot;//content&quot;].attributes['type']

    assert_equal &quot;david@loudthinking.com&quot;, xml.elements[&quot;//author-email-address&quot;].text

    assert_equal nil, xml.elements[&quot;//parent-id&quot;].text
    assert_equal &quot;integer&quot;, xml.elements[&quot;//parent-id&quot;].attributes['type']
    assert_equal &quot;true&quot;, xml.elements[&quot;//parent-id&quot;].attributes['nil']

    if current_adapter?(:SybaseAdapter, :OracleAdapter)
      assert_equal last_read_in_current_timezone, xml.elements[&quot;//last-read&quot;].text
      assert_equal &quot;datetime&quot; , xml.elements[&quot;//last-read&quot;].attributes['type']
    else
      assert_equal &quot;2004-04-15&quot;, xml.elements[&quot;//last-read&quot;].text
      assert_equal &quot;date&quot; , xml.elements[&quot;//last-read&quot;].attributes['type']
    end

    # Oracle and DB2 don't have true boolean or time-only fields
    unless current_adapter?(:OracleAdapter, :DB2Adapter)
      assert_equal &quot;false&quot;, xml.elements[&quot;//approved&quot;].text
      assert_equal &quot;boolean&quot; , xml.elements[&quot;//approved&quot;].attributes['type']

      assert_equal bonus_time_in_current_timezone, xml.elements[&quot;//bonus-time&quot;].text
      assert_equal &quot;datetime&quot; , xml.elements[&quot;//bonus-time&quot;].attributes['type']
    end
  end

  def test_to_xml_skipping_attributes
    xml = topics(:first).to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :except =&gt; [:title, :replies_count])
    assert_equal &quot;&lt;topic&gt;&quot;, xml.first(7)
    assert !xml.include?(%(&lt;title&gt;The First Topic&lt;/title&gt;))
    assert xml.include?(%(&lt;author-name&gt;David&lt;/author-name&gt;))

    xml = topics(:first).to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :except =&gt; [:title, :author_name, :replies_count])
    assert !xml.include?(%(&lt;title&gt;The First Topic&lt;/title&gt;))
    assert !xml.include?(%(&lt;author-name&gt;David&lt;/author-name&gt;))
  end

  def test_to_xml_including_has_many_association
    xml = topics(:first).to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :include =&gt; :replies, :except =&gt; :replies_count)
    assert_equal &quot;&lt;topic&gt;&quot;, xml.first(7)
    assert xml.include?(%(&lt;replies type=&quot;array&quot;&gt;&lt;reply&gt;))
    assert xml.include?(%(&lt;title&gt;The Second Topic of the day&lt;/title&gt;))
  end

  def test_array_to_xml_including_has_many_association
    xml = [ topics(:first), topics(:second) ].to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :include =&gt; :replies)
    assert xml.include?(%(&lt;replies type=&quot;array&quot;&gt;&lt;reply&gt;))
  end

  def test_array_to_xml_including_methods
    xml = [ topics(:first), topics(:second) ].to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :methods =&gt; [ :topic_id ])
    assert xml.include?(%(&lt;topic-id type=&quot;integer&quot;&gt;#{topics(:first).topic_id}&lt;/topic-id&gt;)), xml
    assert xml.include?(%(&lt;topic-id type=&quot;integer&quot;&gt;#{topics(:second).topic_id}&lt;/topic-id&gt;)), xml
  end

  def test_array_to_xml_including_has_one_association
    xml = [ companies(:first_firm), companies(:rails_core) ].to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :include =&gt; :account)
    assert xml.include?(companies(:first_firm).account.to_xml(:indent =&gt; 0, :skip_instruct =&gt; true))
    assert xml.include?(companies(:rails_core).account.to_xml(:indent =&gt; 0, :skip_instruct =&gt; true))
  end

  def test_array_to_xml_including_belongs_to_association
    xml = [ companies(:first_client), companies(:second_client), companies(:another_client) ].to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :include =&gt; :firm)
    assert xml.include?(companies(:first_client).to_xml(:indent =&gt; 0, :skip_instruct =&gt; true))
    assert xml.include?(companies(:second_client).firm.to_xml(:indent =&gt; 0, :skip_instruct =&gt; true))
    assert xml.include?(companies(:another_client).firm.to_xml(:indent =&gt; 0, :skip_instruct =&gt; true))
  end

  def test_to_xml_including_belongs_to_association
    xml = companies(:first_client).to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :include =&gt; :firm)
    assert !xml.include?(&quot;&lt;firm&gt;&quot;)

    xml = companies(:second_client).to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :include =&gt; :firm)
    assert xml.include?(&quot;&lt;firm&gt;&quot;)
  end

  def test_to_xml_including_multiple_associations
    xml = companies(:first_firm).to_xml(:indent =&gt; 0, :skip_instruct =&gt; true, :include =&gt; [ :clients, :account ])
    assert_equal &quot;&lt;firm&gt;&quot;, xml.first(6)
    assert xml.include?(%(&lt;account&gt;))
    assert xml.include?(%(&lt;clients type=&quot;array&quot;&gt;&lt;client&gt;))
  end

  def test_to_xml_including_multiple_associations_with_options
    xml = companies(:first_firm).to_xml(
      :indent  =&gt; 0, :skip_instruct =&gt; true,
      :include =&gt; { :clients =&gt; { :only =&gt; :name } }
    )

    assert_equal &quot;&lt;firm&gt;&quot;, xml.first(6)
    assert xml.include?(%(&lt;client&gt;&lt;name&gt;Summit&lt;/name&gt;&lt;/client&gt;))
    assert xml.include?(%(&lt;clients type=&quot;array&quot;&gt;&lt;client&gt;))
  end

  def test_to_xml_including_methods
    xml = Company.new.to_xml(:methods =&gt; :arbitrary_method, :skip_instruct =&gt; true)
    assert_equal &quot;&lt;company&gt;&quot;, xml.first(9)
    assert xml.include?(%(&lt;arbitrary-method&gt;I am Jack's profound disappointment&lt;/arbitrary-method&gt;))
  end

  def test_to_xml_with_block
    value = &quot;Rockin' the block&quot;
    xml = Company.new.to_xml(:skip_instruct =&gt; true) do |xml|
      xml.tag! &quot;arbitrary-element&quot;, value
    end
    assert_equal &quot;&lt;company&gt;&quot;, xml.first(9)
    assert xml.include?(%(&lt;arbitrary-element&gt;#{value}&lt;/arbitrary-element&gt;))
  end

  def test_type_name_with_module_should_handle_beginning
    assert_equal 'ActiveRecord::Person', ActiveRecord::Base.send(:type_name_with_module, 'Person')
    assert_equal '::Person', ActiveRecord::Base.send(:type_name_with_module, '::Person')
  end

  def test_to_param_should_return_string
    assert_kind_of String, Client.find(:first).to_param
  end

  def test_inspect_class
    assert_equal 'ActiveRecord::Base', ActiveRecord::Base.inspect
    assert_equal 'LoosePerson(abstract)', LoosePerson.inspect
    assert_match(/^Topic\(id: integer, title: string/, Topic.inspect)
  end

  def test_inspect_instance
    topic = topics(:first)
    assert_equal %(#&lt;Topic id: 1, title: &quot;The First Topic&quot;, author_name: &quot;David&quot;, author_email_address: &quot;david@loudthinking.com&quot;, written_on: &quot;#{topic.written_on.to_s(:db)}&quot;, bonus_time: &quot;#{topic.bonus_time.to_s(:db)}&quot;, last_read: &quot;#{topic.last_read.to_s(:db)}&quot;, content: &quot;Have a nice day&quot;, approved: false, replies_count: 1, parent_id: nil, parent_title: nil, type: nil&gt;), topic.inspect
  end

  def test_inspect_new_instance
    assert_match /Topic id: nil/, Topic.new.inspect
  end

  def test_inspect_limited_select_instance
    assert_equal %(#&lt;Topic id: 1&gt;), Topic.find(:first, :select =&gt; 'id', :conditions =&gt; 'id = 1').inspect
    assert_equal %(#&lt;Topic id: 1, title: &quot;The First Topic&quot;&gt;), Topic.find(:first, :select =&gt; 'id, title', :conditions =&gt; 'id = 1').inspect
  end

  def test_inspect_class_without_table
    assert_equal &quot;NonExistentTable(Table doesn't exist)&quot;, NonExistentTable.inspect
  end

  def test_attribute_for_inspect
    t = topics(:first)
    t.title = &quot;The First Topic Now Has A Title With\nNewlines And More Than 50 Characters&quot;

    assert_equal %(&quot;#{t.written_on.to_s(:db)}&quot;), t.attribute_for_inspect(:written_on)
    assert_equal '&quot;The First Topic Now Has A Title With\nNewlines And M...&quot;', t.attribute_for_inspect(:title)
  end

  def test_becomes
    assert_kind_of Reply, topics(:first).becomes(Reply)
    assert_equal &quot;The First Topic&quot;, topics(:first).becomes(Reply).title
  end

  def test_silence_sets_log_level_to_error_in_block
    original_logger = ActiveRecord::Base.logger
    log = StringIO.new
    ActiveRecord::Base.logger = Logger.new(log)
    ActiveRecord::Base.logger.level = Logger::DEBUG
    ActiveRecord::Base.silence do
      ActiveRecord::Base.logger.warn &quot;warn&quot;
      ActiveRecord::Base.logger.error &quot;error&quot;
    end
    assert_equal &quot;error\n&quot;, log.string
  ensure
    ActiveRecord::Base.logger = original_logger
  end

  def test_silence_sets_log_level_back_to_level_before_yield
    original_logger = ActiveRecord::Base.logger
    log = StringIO.new
    ActiveRecord::Base.logger = Logger.new(log)
    ActiveRecord::Base.logger.level = Logger::WARN
    ActiveRecord::Base.silence do
    end
    assert_equal Logger::WARN, ActiveRecord::Base.logger.level
  ensure
    ActiveRecord::Base.logger = original_logger
  end

  def test_benchmark_with_log_level
    original_logger = ActiveRecord::Base.logger
    log = StringIO.new
    ActiveRecord::Base.logger = Logger.new(log)
    ActiveRecord::Base.logger.level = Logger::WARN
    ActiveRecord::Base.benchmark(&quot;Debug Topic Count&quot;, Logger::DEBUG) { Topic.count }
    ActiveRecord::Base.benchmark(&quot;Warn Topic Count&quot;,  Logger::WARN)  { Topic.count }
    ActiveRecord::Base.benchmark(&quot;Error Topic Count&quot;, Logger::ERROR) { Topic.count }
    assert_no_match /Debug Topic Count/, log.string
    assert_match /Warn Topic Count/, log.string
    assert_match /Error Topic Count/, log.string
  ensure
    ActiveRecord::Base.logger = original_logger
  end

  def test_benchmark_with_use_silence
    original_logger = ActiveRecord::Base.logger
    log = StringIO.new
    ActiveRecord::Base.logger = Logger.new(log)
    ActiveRecord::Base.benchmark(&quot;Logging&quot;, Logger::DEBUG, true) { ActiveRecord::Base.logger.debug &quot;Loud&quot; }
    ActiveRecord::Base.benchmark(&quot;Logging&quot;, Logger::DEBUG, false)  { ActiveRecord::Base.logger.debug &quot;Quiet&quot; }
    assert_no_match /Loud/, log.string
    assert_match /Quiet/, log.string
  ensure
    ActiveRecord::Base.logger = original_logger
  end

  def test_create_with_custom_timestamps
    custom_datetime = 1.hour.ago.beginning_of_day

    %w(created_at created_on updated_at updated_on).each do |attribute|
      parrot = LiveParrot.create(:name =&gt; &quot;colombian&quot;, attribute =&gt; custom_datetime)
      assert_equal custom_datetime, parrot[attribute]
    end
  end
end
</pre>
    </div>