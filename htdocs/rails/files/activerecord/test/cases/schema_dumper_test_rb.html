  <div id="fileHeader">
    <h1>schema_dumper_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/schema_dumper_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:55:10 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'stringio'


class SchemaDumperTest &lt; ActiveRecord::TestCase
  def standard_dump
    stream = StringIO.new
    ActiveRecord::SchemaDumper.ignore_tables = []
    ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, stream)
    stream.string
  end

  def test_schema_dump
    output = standard_dump
    assert_match %r{create_table &quot;accounts&quot;}, output
    assert_match %r{create_table &quot;authors&quot;}, output
    assert_no_match %r{create_table &quot;schema_migrations&quot;}, output
  end

  def test_schema_dump_excludes_sqlite_sequence
    output = standard_dump
    assert_no_match %r{create_table &quot;sqlite_sequence&quot;}, output
  end

  def test_schema_dump_includes_camelcase_table_name
    output = standard_dump
    assert_match %r{create_table &quot;CamelCase&quot;}, output
  end

  def assert_line_up(lines, pattern, required = false)
    return assert(true) if lines.empty?
    matches = lines.map { |line| line.match(pattern) }
    assert matches.all? if required
    matches.compact!
    return assert(true) if matches.empty?
    assert_equal 1, matches.map{ |match| match.offset(0).first }.uniq.length
  end

  def column_definition_lines(output = standard_dump)
    output.scan(/^( *)create_table.*?\n(.*?)^\1end/m).map{ |m| m.last.split(/\n/) }
  end

  def test_types_line_up
    column_definition_lines.each do |column_set|
      next if column_set.empty?

      lengths = column_set.map do |column|
        if match = column.match(/t\.(?:integer|decimal|float|datetime|timestamp|time|date|text|binary|string|boolean)\s+&quot;/)
          match[0].length
        end
      end

      assert_equal 1, lengths.uniq.length
    end
  end

  def test_arguments_line_up
    column_definition_lines.each do |column_set|
      assert_line_up(column_set, /:default =&gt; /)
      assert_line_up(column_set, /:limit =&gt; /)
      assert_line_up(column_set, /:null =&gt; /)
    end
  end

  def test_no_dump_errors
    output = standard_dump
    assert_no_match %r{\# Could not dump table}, output
  end

  def test_schema_dump_includes_not_null_columns
    stream = StringIO.new

    ActiveRecord::SchemaDumper.ignore_tables = [/^[^r]/]
    ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, stream)
    output = stream.string
    assert_match %r{:null =&gt; false}, output
  end

  def test_schema_dump_includes_limit_constraint_for_integer_columns
    stream = StringIO.new

    ActiveRecord::SchemaDumper.ignore_tables = [/^(?!integer_limits)/]
    ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, stream)
    output = stream.string

    if current_adapter?(:PostgreSQLAdapter)
      assert_match %r{c_int_1.*:limit =&gt; 2}, output
      assert_match %r{c_int_2.*:limit =&gt; 2}, output

      # int 3 is 4 bytes in postgresql
      assert_match %r{c_int_3.*}, output
      assert_no_match %r{c_int_3.*:limit}, output

      assert_match %r{c_int_4.*}, output
      assert_no_match %r{c_int_4.*:limit}, output
    elsif current_adapter?(:MysqlAdapter)
      assert_match %r{c_int_1.*:limit =&gt; 1}, output
      assert_match %r{c_int_2.*:limit =&gt; 2}, output
      assert_match %r{c_int_3.*:limit =&gt; 3}, output

      assert_match %r{c_int_4.*}, output
      assert_no_match %r{c_int_4.*:limit}, output
    elsif current_adapter?(:SQLiteAdapter)
      assert_match %r{c_int_1.*:limit =&gt; 1}, output
      assert_match %r{c_int_2.*:limit =&gt; 2}, output
      assert_match %r{c_int_3.*:limit =&gt; 3}, output
      assert_match %r{c_int_4.*:limit =&gt; 4}, output
    end
    assert_match %r{c_int_without_limit.*}, output
    assert_no_match %r{c_int_without_limit.*:limit}, output

    if current_adapter?(:SQLiteAdapter)
      assert_match %r{c_int_5.*:limit =&gt; 5}, output
      assert_match %r{c_int_6.*:limit =&gt; 6}, output
      assert_match %r{c_int_7.*:limit =&gt; 7}, output
      assert_match %r{c_int_8.*:limit =&gt; 8}, output
    else
      assert_match %r{c_int_5.*:limit =&gt; 8}, output
      assert_match %r{c_int_6.*:limit =&gt; 8}, output
      assert_match %r{c_int_7.*:limit =&gt; 8}, output
      assert_match %r{c_int_8.*:limit =&gt; 8}, output
    end
  end

  def test_schema_dump_with_string_ignored_table
    stream = StringIO.new

    ActiveRecord::SchemaDumper.ignore_tables = ['accounts']
    ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, stream)
    output = stream.string
    assert_no_match %r{create_table &quot;accounts&quot;}, output
    assert_match %r{create_table &quot;authors&quot;}, output
    assert_no_match %r{create_table &quot;schema_migrations&quot;}, output
  end

  def test_schema_dump_with_regexp_ignored_table
    stream = StringIO.new

    ActiveRecord::SchemaDumper.ignore_tables = [/^account/]
    ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, stream)
    output = stream.string
    assert_no_match %r{create_table &quot;accounts&quot;}, output
    assert_match %r{create_table &quot;authors&quot;}, output
    assert_no_match %r{create_table &quot;schema_migrations&quot;}, output
  end

  def test_schema_dump_illegal_ignored_table_value
    stream = StringIO.new
    ActiveRecord::SchemaDumper.ignore_tables = [5]
    assert_raise(StandardError) do
      ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, stream)
    end
  end

  def test_schema_dumps_index_columns_in_right_order
    index_definition = standard_dump.split(/\n/).grep(/add_index.*companies/).first.strip
    assert_equal 'add_index &quot;companies&quot;, [&quot;firm_id&quot;, &quot;type&quot;, &quot;rating&quot;, &quot;ruby_type&quot;], :name =&gt; &quot;company_index&quot;', index_definition
  end

  def test_schema_dump_should_honor_nonstandard_primary_keys
    output = standard_dump
    match = output.match(%r{create_table &quot;movies&quot;(.*)do})
    assert_not_nil(match, &quot;nonstandardpk table not found&quot;)
    assert_match %r(:primary_key =&gt; &quot;movieid&quot;), match[1], &quot;non-standard primary key not preserved&quot;
  end

  if current_adapter?(:MysqlAdapter)
    def test_schema_dump_should_not_add_default_value_for_mysql_text_field
      output = standard_dump
      assert_match %r{t.text\s+&quot;body&quot;,\s+:null =&gt; false$}, output
    end

    def test_schema_dump_includes_length_for_mysql_blob_and_text_fields
      output = standard_dump
      assert_match %r{t.binary\s+&quot;tiny_blob&quot;,\s+:limit =&gt; 255$}, output
      assert_match %r{t.binary\s+&quot;normal_blob&quot;$}, output
      assert_match %r{t.binary\s+&quot;medium_blob&quot;,\s+:limit =&gt; 16777215$}, output
      assert_match %r{t.binary\s+&quot;long_blob&quot;,\s+:limit =&gt; 2147483647$}, output
      assert_match %r{t.text\s+&quot;tiny_text&quot;,\s+:limit =&gt; 255$}, output
      assert_match %r{t.text\s+&quot;normal_text&quot;$}, output
      assert_match %r{t.text\s+&quot;medium_text&quot;,\s+:limit =&gt; 16777215$}, output
      assert_match %r{t.text\s+&quot;long_text&quot;,\s+:limit =&gt; 2147483647$}, output
    end
  end

  def test_schema_dump_includes_decimal_options
    stream = StringIO.new
    ActiveRecord::SchemaDumper.ignore_tables = [/^[^n]/]
    ActiveRecord::SchemaDumper.dump(ActiveRecord::Base.connection, stream)
    output = stream.string
    assert_match %r{:precision =&gt; 3,[[:space:]]+:scale =&gt; 2,[[:space:]]+:default =&gt; 2.78}, output
  end

  if current_adapter?(:PostgreSQLAdapter)
    def test_schema_dump_includes_xml_shorthand_definition
      output = standard_dump
      if %r{create_table &quot;postgresql_xml_data_type&quot;} =~ output
        assert_match %r{t.xml &quot;data&quot;}, output
      end
    end
  end

  def test_schema_dump_keeps_id_column_when_id_is_false_and_id_column_added
    output = standard_dump
    match = output.match(%r{create_table &quot;goofy_string_id&quot;(.*)do.*\n(.*)\n})
    assert_not_nil(match, &quot;goofy_string_id table not found&quot;)
    assert_match %r(:id =&gt; false), match[1], &quot;no table id not preserved&quot;
    assert_match %r{t.string[[:space:]]+&quot;id&quot;,[[:space:]]+:null =&gt; false$}, match[2], &quot;non-primary key id column not preserved&quot;
  end
end

</pre>
    </div>