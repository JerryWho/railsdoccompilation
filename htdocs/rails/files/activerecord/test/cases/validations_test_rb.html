  <div id="fileHeader">
    <h1>validations_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/validations_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Nov 27 16:38:16 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># encoding: utf-8
require &quot;cases/helper&quot;
require 'models/topic'
require 'models/reply'
require 'models/person'
require 'models/developer'
require 'models/warehouse_thing'
require 'models/guid'
require 'models/owner'
require 'models/pet'
require 'models/event'

# The following methods in Topic are used in test_conditional_validation_*
class Topic
  has_many :unique_replies, :dependent =&gt; :destroy, :foreign_key =&gt; &quot;parent_id&quot;
  has_many :silly_unique_replies, :dependent =&gt; :destroy, :foreign_key =&gt; &quot;parent_id&quot;

  def condition_is_true
    true
  end

  def condition_is_true_but_its_not
    false
  end
end

class ProtectedPerson &lt; ActiveRecord::Base
  set_table_name 'people'
  attr_accessor :addon
  attr_protected :first_name

  def special_error
    this_method_does_not_exist!
  rescue
    errors.add(:special_error, &quot;This method does not exist&quot;)
  end
end

class UniqueReply &lt; Reply
  validates_uniqueness_of :content, :scope =&gt; 'parent_id'
end

class SillyUniqueReply &lt; UniqueReply
end

class Wizard &lt; ActiveRecord::Base
  self.abstract_class = true

  validates_uniqueness_of :name
end

class IneptWizard &lt; Wizard
  validates_uniqueness_of :city
end

class Conjurer &lt; IneptWizard
end

class Thaumaturgist &lt; IneptWizard
end


class ValidationsTest &lt; ActiveRecord::TestCase
  fixtures :topics, :developers, 'warehouse-things'

  # Most of the tests mess with the validations of Topic, so lets repair it all the time.
  # Other classes we mess with will be dealt with in the specific tests
  repair_validations(Topic)

  def test_single_field_validation
    r = Reply.new
    r.title = &quot;There's no content!&quot;
    assert !r.valid?, &quot;A reply without content shouldn't be saveable&quot;

    r.content = &quot;Messa content!&quot;
    assert r.valid?, &quot;A reply with content should be saveable&quot;
  end

  def test_single_attr_validation_and_error_msg
    r = Reply.new
    r.title = &quot;There's no content!&quot;
    assert !r.valid?
    assert r.errors.invalid?(&quot;content&quot;), &quot;A reply without content should mark that attribute as invalid&quot;
    assert_equal &quot;Empty&quot;, r.errors.on(&quot;content&quot;), &quot;A reply without content should contain an error&quot;
    assert_equal 1, r.errors.count
  end

  def test_double_attr_validation_and_error_msg
    r = Reply.new
    assert !r.valid?

    assert r.errors.invalid?(&quot;title&quot;), &quot;A reply without title should mark that attribute as invalid&quot;
    assert_equal &quot;Empty&quot;, r.errors.on(&quot;title&quot;), &quot;A reply without title should contain an error&quot;

    assert r.errors.invalid?(&quot;content&quot;), &quot;A reply without content should mark that attribute as invalid&quot;
    assert_equal &quot;Empty&quot;, r.errors.on(&quot;content&quot;), &quot;A reply without content should contain an error&quot;

    assert_equal 2, r.errors.count
  end

  def test_error_on_create
    r = Reply.new
    r.title = &quot;Wrong Create&quot;
    assert !r.valid?
    assert r.errors.invalid?(&quot;title&quot;), &quot;A reply with a bad title should mark that attribute as invalid&quot;
    assert_equal &quot;is Wrong Create&quot;, r.errors.on(&quot;title&quot;), &quot;A reply with a bad content should contain an error&quot;
  end

  def test_error_on_update
    r = Reply.new
    r.title = &quot;Bad&quot;
    r.content = &quot;Good&quot;
    assert r.save, &quot;First save should be successful&quot;

    r.title = &quot;Wrong Update&quot;
    assert !r.save, &quot;Second save should fail&quot;

    assert r.errors.invalid?(&quot;title&quot;), &quot;A reply with a bad title should mark that attribute as invalid&quot;
    assert_equal &quot;is Wrong Update&quot;, r.errors.on(&quot;title&quot;), &quot;A reply with a bad content should contain an error&quot;
  end

  def test_invalid_record_exception
    assert_raise(ActiveRecord::RecordInvalid) { Reply.create! }
    assert_raise(ActiveRecord::RecordInvalid) { Reply.new.save! }

    begin
      r = Reply.new
      r.save!
      flunk
    rescue ActiveRecord::RecordInvalid =&gt; invalid
      assert_equal r, invalid.record
    end
  end

  def test_exception_on_create_bang_many
    assert_raise(ActiveRecord::RecordInvalid) do
      Reply.create!([ { &quot;title&quot; =&gt; &quot;OK&quot; }, { &quot;title&quot; =&gt; &quot;Wrong Create&quot; }])
    end
  end

  def test_exception_on_create_bang_with_block
    assert_raise(ActiveRecord::RecordInvalid) do
      Reply.create!({ &quot;title&quot; =&gt; &quot;OK&quot; }) do |r|
        r.content = nil
      end
    end
  end

  def test_exception_on_create_bang_many_with_block
    assert_raise(ActiveRecord::RecordInvalid) do
      Reply.create!([{ &quot;title&quot; =&gt; &quot;OK&quot; }, { &quot;title&quot; =&gt; &quot;Wrong Create&quot; }]) do |r|
        r.content = nil
      end
    end
  end

  def test_scoped_create_without_attributes
    Reply.with_scope(:create =&gt; {}) do
      assert_raise(ActiveRecord::RecordInvalid) { Reply.create! }
    end
  end

  def test_create_with_exceptions_using_scope_for_protected_attributes
    assert_nothing_raised do
      ProtectedPerson.with_scope( :create =&gt; { :first_name =&gt; &quot;Mary&quot; } ) do
        person = ProtectedPerson.create! :addon =&gt; &quot;Addon&quot;
        assert_equal person.first_name, &quot;Mary&quot;, &quot;scope should ignore attr_protected&quot;
      end
    end
  end

  def test_create_with_exceptions_using_scope_and_empty_attributes
    assert_nothing_raised do
      ProtectedPerson.with_scope( :create =&gt; { :first_name =&gt; &quot;Mary&quot; } ) do
        person = ProtectedPerson.create!
        assert_equal person.first_name, &quot;Mary&quot;, &quot;should be ok when no attributes are passed to create!&quot;
      end
    end
  end

  def test_values_are_not_retrieved_unless_needed
    assert_nothing_raised do
      person = ProtectedPerson.new
      person.special_error
      assert_equal &quot;This method does not exist&quot;, person.errors[:special_error]
    end
  end

  def test_single_error_per_attr_iteration
    r = Reply.new
    r.save

    errors = []
    r.errors.each { |attr, msg| errors &lt;&lt; [attr, msg] }

    assert errors.include?([&quot;title&quot;, &quot;Empty&quot;])
    assert errors.include?([&quot;content&quot;, &quot;Empty&quot;])
  end

  def test_multiple_errors_per_attr_iteration_with_full_error_composition
    r = Reply.new
    r.title   = &quot;Wrong Create&quot;
    r.content = &quot;Mismatch&quot;
    r.save

    errors = []
    r.errors.each_full { |error| errors &lt;&lt; error }

    assert_equal &quot;Title is Wrong Create&quot;, errors[0]
    assert_equal &quot;Title is Content Mismatch&quot;, errors[1]
    assert_equal 2, r.errors.count
  end

  def test_errors_on_base
    r = Reply.new
    r.content = &quot;Mismatch&quot;
    r.save
    r.errors.add_to_base &quot;Reply is not dignifying&quot;

    errors = []
    r.errors.each_full { |error| errors &lt;&lt; error }

    assert_equal &quot;Reply is not dignifying&quot;, r.errors.on_base

    assert errors.include?(&quot;Title Empty&quot;)
    assert errors.include?(&quot;Reply is not dignifying&quot;)
    assert_equal 2, r.errors.count
  end

  def test_create_without_validation
    reply = Reply.new
    assert !reply.save
    assert reply.save(false)
  end

  def test_create_without_validation_bang
    count = Reply.count
    assert_nothing_raised { Reply.new.save_without_validation! }
    assert count+1, Reply.count
  end

  def test_validates_each
    hits = 0
    Topic.validates_each(:title, :content, [:title, :content]) do |record, attr|
      record.errors.add attr, 'gotcha'
      hits += 1
    end
    t = Topic.new(&quot;title&quot; =&gt; &quot;valid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.save
    assert_equal 4, hits
    assert_equal %w(gotcha gotcha), t.errors.on(:title)
    assert_equal %w(gotcha gotcha), t.errors.on(:content)
  end

  def test_no_title_confirmation
    Topic.validates_confirmation_of(:title)

    t = Topic.new(:author_name =&gt; &quot;Plutarch&quot;)
    assert t.valid?

    t.title_confirmation = &quot;Parallel Lives&quot;
    assert !t.valid?

    t.title_confirmation = nil
    t.title = &quot;Parallel Lives&quot;
    assert t.valid?

    t.title_confirmation = &quot;Parallel Lives&quot;
    assert t.valid?
  end

  def test_title_confirmation
    Topic.validates_confirmation_of(:title)

    t = Topic.create(&quot;title&quot; =&gt; &quot;We should be confirmed&quot;,&quot;title_confirmation&quot; =&gt; &quot;&quot;)
    assert !t.save

    t.title_confirmation = &quot;We should be confirmed&quot;
    assert t.save
  end

  def test_terms_of_service_agreement_no_acceptance
    Topic.validates_acceptance_of(:terms_of_service, :on =&gt; :create)

    t = Topic.create(&quot;title&quot; =&gt; &quot;We should not be confirmed&quot;)
    assert t.save
  end

  def test_terms_of_service_agreement
    Topic.validates_acceptance_of(:terms_of_service, :on =&gt; :create)

    t = Topic.create(&quot;title&quot; =&gt; &quot;We should be confirmed&quot;,&quot;terms_of_service&quot; =&gt; &quot;&quot;)
    assert !t.save
    assert_equal &quot;must be accepted&quot;, t.errors.on(:terms_of_service)

    t.terms_of_service = &quot;1&quot;
    assert t.save
  end


  def test_eula
    Topic.validates_acceptance_of(:eula, :message =&gt; &quot;must be abided&quot;, :on =&gt; :create)

    t = Topic.create(&quot;title&quot; =&gt; &quot;We should be confirmed&quot;,&quot;eula&quot; =&gt; &quot;&quot;)
    assert !t.save
    assert_equal &quot;must be abided&quot;, t.errors.on(:eula)

    t.eula = &quot;1&quot;
    assert t.save
  end

  def test_terms_of_service_agreement_with_accept_value
    Topic.validates_acceptance_of(:terms_of_service, :on =&gt; :create, :accept =&gt; &quot;I agree.&quot;)

    t = Topic.create(&quot;title&quot; =&gt; &quot;We should be confirmed&quot;, &quot;terms_of_service&quot; =&gt; &quot;&quot;)
    assert !t.save
    assert_equal &quot;must be accepted&quot;, t.errors.on(:terms_of_service)

    t.terms_of_service = &quot;I agree.&quot;
    assert t.save
  end

  def test_validates_acceptance_of_as_database_column
    repair_validations(Reply) do
      Reply.validates_acceptance_of(:author_name)

      reply = Reply.create(&quot;author_name&quot; =&gt; &quot;Dan Brown&quot;)
      assert_equal &quot;Dan Brown&quot;, reply[&quot;author_name&quot;]
    end
  end

  def test_validates_acceptance_of_with_non_existant_table
    Object.const_set :IncorporealModel, Class.new(ActiveRecord::Base)

    assert_nothing_raised ActiveRecord::StatementInvalid do
      IncorporealModel.validates_acceptance_of(:incorporeal_column)
    end
  end

  def test_validate_presences
    Topic.validates_presence_of(:title, :content)

    t = Topic.create
    assert !t.save
    assert_equal &quot;can't be blank&quot;, t.errors.on(:title)
    assert_equal &quot;can't be blank&quot;, t.errors.on(:content)

    t.title = &quot;something&quot;
    t.content  = &quot;   &quot;

    assert !t.save
    assert_equal &quot;can't be blank&quot;, t.errors.on(:content)

    t.content = &quot;like stuff&quot;

    assert t.save
  end

  def test_validate_uniqueness
    Topic.validates_uniqueness_of(:title)

    t = Topic.new(&quot;title&quot; =&gt; &quot;I'm uniqué!&quot;)
    assert t.save, &quot;Should save t as unique&quot;

    t.content = &quot;Remaining unique&quot;
    assert t.save, &quot;Should still save t as unique&quot;

    t2 = Topic.new(&quot;title&quot; =&gt; &quot;I'm uniqué!&quot;)
    assert !t2.valid?, &quot;Shouldn't be valid&quot;
    assert !t2.save, &quot;Shouldn't save t2 as unique&quot;
    assert_equal &quot;has already been taken&quot;, t2.errors.on(:title)

    t2.title = &quot;Now Im really also unique&quot;
    assert t2.save, &quot;Should now save t2 as unique&quot;
  end

  def test_validates_uniquness_with_newline_chars
    Topic.validates_uniqueness_of(:title, :case_sensitive =&gt; false)

    t = Topic.new(&quot;title&quot; =&gt; &quot;new\nline&quot;)
    assert t.save, &quot;Should save t as unique&quot;
  end

  def test_validate_uniqueness_with_scope
    repair_validations(Reply) do
      Reply.validates_uniqueness_of(:content, :scope =&gt; &quot;parent_id&quot;)

      t = Topic.create(&quot;title&quot; =&gt; &quot;I'm unique!&quot;)

      r1 = t.replies.create &quot;title&quot; =&gt; &quot;r1&quot;, &quot;content&quot; =&gt; &quot;hello world&quot;
      assert r1.valid?, &quot;Saving r1&quot;

      r2 = t.replies.create &quot;title&quot; =&gt; &quot;r2&quot;, &quot;content&quot; =&gt; &quot;hello world&quot;
      assert !r2.valid?, &quot;Saving r2 first time&quot;

      r2.content = &quot;something else&quot;
      assert r2.save, &quot;Saving r2 second time&quot;

      t2 = Topic.create(&quot;title&quot; =&gt; &quot;I'm unique too!&quot;)
      r3 = t2.replies.create &quot;title&quot; =&gt; &quot;r3&quot;, &quot;content&quot; =&gt; &quot;hello world&quot;
      assert r3.valid?, &quot;Saving r3&quot;
    end
  end

  def test_validate_uniqueness_scoped_to_defining_class
    t = Topic.create(&quot;title&quot; =&gt; &quot;What, me worry?&quot;)

    r1 = t.unique_replies.create &quot;title&quot; =&gt; &quot;r1&quot;, &quot;content&quot; =&gt; &quot;a barrel of fun&quot;
    assert r1.valid?, &quot;Saving r1&quot;

    r2 = t.silly_unique_replies.create &quot;title&quot; =&gt; &quot;r2&quot;, &quot;content&quot; =&gt; &quot;a barrel of fun&quot;
    assert !r2.valid?, &quot;Saving r2&quot;

    # Should succeed as validates_uniqueness_of only applies to
    # UniqueReply and its subclasses
    r3 = t.replies.create &quot;title&quot; =&gt; &quot;r2&quot;, &quot;content&quot; =&gt; &quot;a barrel of fun&quot;
    assert r3.valid?, &quot;Saving r3&quot;
  end

  def test_validate_uniqueness_with_scope_array
    repair_validations(Reply) do
      Reply.validates_uniqueness_of(:author_name, :scope =&gt; [:author_email_address, :parent_id])

      t = Topic.create(&quot;title&quot; =&gt; &quot;The earth is actually flat!&quot;)

      r1 = t.replies.create &quot;author_name&quot; =&gt; &quot;jeremy&quot;, &quot;author_email_address&quot; =&gt; &quot;jeremy@rubyonrails.com&quot;, &quot;title&quot; =&gt; &quot;You're crazy!&quot;, &quot;content&quot; =&gt; &quot;Crazy reply&quot;
      assert r1.valid?, &quot;Saving r1&quot;

      r2 = t.replies.create &quot;author_name&quot; =&gt; &quot;jeremy&quot;, &quot;author_email_address&quot; =&gt; &quot;jeremy@rubyonrails.com&quot;, &quot;title&quot; =&gt; &quot;You're crazy!&quot;, &quot;content&quot; =&gt; &quot;Crazy reply again...&quot;
      assert !r2.valid?, &quot;Saving r2. Double reply by same author.&quot;

      r2.author_email_address = &quot;jeremy_alt_email@rubyonrails.com&quot;
      assert r2.save, &quot;Saving r2 the second time.&quot;

      r3 = t.replies.create &quot;author_name&quot; =&gt; &quot;jeremy&quot;, &quot;author_email_address&quot; =&gt; &quot;jeremy_alt_email@rubyonrails.com&quot;, &quot;title&quot; =&gt; &quot;You're wrong&quot;, &quot;content&quot; =&gt; &quot;It's cubic&quot;
      assert !r3.valid?, &quot;Saving r3&quot;

      r3.author_name = &quot;jj&quot;
      assert r3.save, &quot;Saving r3 the second time.&quot;

      r3.author_name = &quot;jeremy&quot;
      assert !r3.save, &quot;Saving r3 the third time.&quot;
    end
  end

  def test_validate_case_insensitive_uniqueness
    Topic.validates_uniqueness_of(:title, :parent_id, :case_sensitive =&gt; false, :allow_nil =&gt; true)

    t = Topic.new(&quot;title&quot; =&gt; &quot;I'm unique!&quot;, :parent_id =&gt; 2)
    assert t.save, &quot;Should save t as unique&quot;

    t.content = &quot;Remaining unique&quot;
    assert t.save, &quot;Should still save t as unique&quot;

    t2 = Topic.new(&quot;title&quot; =&gt; &quot;I'm UNIQUE!&quot;, :parent_id =&gt; 1)
    assert !t2.valid?, &quot;Shouldn't be valid&quot;
    assert !t2.save, &quot;Shouldn't save t2 as unique&quot;
    assert t2.errors.on(:title)
    assert t2.errors.on(:parent_id)
    assert_equal &quot;has already been taken&quot;, t2.errors.on(:title)

    t2.title = &quot;I'm truly UNIQUE!&quot;
    assert !t2.valid?, &quot;Shouldn't be valid&quot;
    assert !t2.save, &quot;Shouldn't save t2 as unique&quot;
    assert_nil t2.errors.on(:title)
    assert t2.errors.on(:parent_id)

    t2.parent_id = 4
    assert t2.save, &quot;Should now save t2 as unique&quot;

    t2.parent_id = nil
    t2.title = nil
    assert t2.valid?, &quot;should validate with nil&quot;
    assert t2.save, &quot;should save with nil&quot;

    with_kcode('UTF8') do
      t_utf8 = Topic.new(&quot;title&quot; =&gt; &quot;Я тоже уникальный!&quot;)
      assert t_utf8.save, &quot;Should save t_utf8 as unique&quot;

      # If database hasn't UTF-8 character set, this test fails
      if Topic.find(t_utf8, :select =&gt; 'LOWER(title) AS title').title == &quot;я тоже уникальный!&quot;
        t2_utf8 = Topic.new(&quot;title&quot; =&gt; &quot;я тоже УНИКАЛЬНЫЙ!&quot;)
        assert !t2_utf8.valid?, &quot;Shouldn't be valid&quot;
        assert !t2_utf8.save, &quot;Shouldn't save t2_utf8 as unique&quot;
      end
    end
  end

  def test_validate_case_sensitive_uniqueness
    Topic.validates_uniqueness_of(:title, :case_sensitive =&gt; true, :allow_nil =&gt; true)

    t = Topic.new(&quot;title&quot; =&gt; &quot;I'm unique!&quot;)
    assert t.save, &quot;Should save t as unique&quot;

    t.content = &quot;Remaining unique&quot;
    assert t.save, &quot;Should still save t as unique&quot;

    t2 = Topic.new(&quot;title&quot; =&gt; &quot;I'M UNIQUE!&quot;)
    assert t2.valid?, &quot;Should be valid&quot;
    assert t2.save, &quot;Should save t2 as unique&quot;
    assert !t2.errors.on(:title)
    assert !t2.errors.on(:parent_id)
    assert_not_equal &quot;has already been taken&quot;, t2.errors.on(:title)

    t3 = Topic.new(&quot;title&quot; =&gt; &quot;I'M uNiQUe!&quot;)
    assert t3.valid?, &quot;Should be valid&quot;
    assert t3.save, &quot;Should save t2 as unique&quot;
    assert !t3.errors.on(:title)
    assert !t3.errors.on(:parent_id)
    assert_not_equal &quot;has already been taken&quot;, t3.errors.on(:title)
  end

  def test_validate_case_sensitive_uniqueness_with_attribute_passed_as_integer
    Topic.validates_uniqueness_of(:title, :case_sensitve =&gt; true)
    t = Topic.create!('title' =&gt; 101)

    t2 = Topic.new('title' =&gt; 101)
    assert !t2.valid?
    assert t2.errors.on(:title)
  end

  def test_validate_uniqueness_with_non_standard_table_names
    i1 = WarehouseThing.create(:value =&gt; 1000)
    assert !i1.valid?, &quot;i1 should not be valid&quot;
    assert i1.errors.on(:value), &quot;Should not be empty&quot;
  end

  def test_validates_uniqueness_inside_with_scope
    Topic.validates_uniqueness_of(:title)

    Topic.with_scope(:find =&gt; { :conditions =&gt; { :author_name =&gt; &quot;David&quot; } }) do
      t1 = Topic.new(&quot;title&quot; =&gt; &quot;I'm unique!&quot;, &quot;author_name&quot; =&gt; &quot;Mary&quot;)
      assert t1.save
      t2 = Topic.new(&quot;title&quot; =&gt; &quot;I'm unique!&quot;, &quot;author_name&quot; =&gt; &quot;David&quot;)
      assert !t2.valid?
    end
  end

  def test_validate_uniqueness_with_columns_which_are_sql_keywords
    repair_validations(Guid) do
      Guid.validates_uniqueness_of :key
      g = Guid.new
      g.key = &quot;foo&quot;
      assert_nothing_raised { !g.valid? }
    end
  end

  def test_validate_uniqueness_with_limit
    # Event.title is limited to 5 characters
    e1 = Event.create(:title =&gt; &quot;abcde&quot;)
    assert e1.valid?, &quot;Could not create an event with a unique, 5 character title&quot;
    e2 = Event.create(:title =&gt; &quot;abcdefgh&quot;)
    assert !e2.valid?, &quot;Created an event whose title, with limit taken into account, is not unique&quot;
  end

  def test_validate_uniqueness_with_limit_and_utf8
    with_kcode('UTF8') do
      # Event.title is limited to 5 characters
      e1 = Event.create(:title =&gt; &quot;一二三四五&quot;)
      assert e1.valid?, &quot;Could not create an event with a unique, 5 character title&quot;
      e2 = Event.create(:title =&gt; &quot;一二三四五六七八&quot;)
      assert !e2.valid?, &quot;Created an event whose title, with limit taken into account, is not unique&quot;
    end
  end

  def test_validate_straight_inheritance_uniqueness
    w1 = IneptWizard.create(:name =&gt; &quot;Rincewind&quot;, :city =&gt; &quot;Ankh-Morpork&quot;)
    assert w1.valid?, &quot;Saving w1&quot;

    # Should use validation from base class (which is abstract)
    w2 = IneptWizard.new(:name =&gt; &quot;Rincewind&quot;, :city =&gt; &quot;Quirm&quot;)
    assert !w2.valid?, &quot;w2 shouldn't be valid&quot;
    assert w2.errors.on(:name), &quot;Should have errors for name&quot;
    assert_equal &quot;has already been taken&quot;, w2.errors.on(:name), &quot;Should have uniqueness message for name&quot;

    w3 = Conjurer.new(:name =&gt; &quot;Rincewind&quot;, :city =&gt; &quot;Quirm&quot;)
    assert !w3.valid?, &quot;w3 shouldn't be valid&quot;
    assert w3.errors.on(:name), &quot;Should have errors for name&quot;
    assert_equal &quot;has already been taken&quot;, w3.errors.on(:name), &quot;Should have uniqueness message for name&quot;

    w4 = Conjurer.create(:name =&gt; &quot;The Amazing Bonko&quot;, :city =&gt; &quot;Quirm&quot;)
    assert w4.valid?, &quot;Saving w4&quot;

    w5 = Thaumaturgist.new(:name =&gt; &quot;The Amazing Bonko&quot;, :city =&gt; &quot;Lancre&quot;)
    assert !w5.valid?, &quot;w5 shouldn't be valid&quot;
    assert w5.errors.on(:name), &quot;Should have errors for name&quot;
    assert_equal &quot;has already been taken&quot;, w5.errors.on(:name), &quot;Should have uniqueness message for name&quot;

    w6 = Thaumaturgist.new(:name =&gt; &quot;Mustrum Ridcully&quot;, :city =&gt; &quot;Quirm&quot;)
    assert !w6.valid?, &quot;w6 shouldn't be valid&quot;
    assert w6.errors.on(:city), &quot;Should have errors for city&quot;
    assert_equal &quot;has already been taken&quot;, w6.errors.on(:city), &quot;Should have uniqueness message for city&quot;
  end

  def test_validate_format
    Topic.validates_format_of(:title, :content, :with =&gt; /^Validation\smacros \w+!$/, :message =&gt; &quot;is bad data&quot;)

    t = Topic.create(&quot;title&quot; =&gt; &quot;i'm incorrect&quot;, &quot;content&quot; =&gt; &quot;Validation macros rule!&quot;)
    assert !t.valid?, &quot;Shouldn't be valid&quot;
    assert !t.save, &quot;Shouldn't save because it's invalid&quot;
    assert_equal &quot;is bad data&quot;, t.errors.on(:title)
    assert_nil t.errors.on(:content)

    t.title = &quot;Validation macros rule!&quot;

    assert t.save
    assert_nil t.errors.on(:title)

    assert_raise(ArgumentError) { Topic.validates_format_of(:title, :content) }
  end

  def test_validate_format_with_allow_blank
    Topic.validates_format_of(:title, :with =&gt; /^Validation\smacros \w+!$/, :allow_blank=&gt;true)
    assert !Topic.create(&quot;title&quot; =&gt; &quot;Shouldn't be valid&quot;).valid?
    assert Topic.create(&quot;title&quot; =&gt; &quot;&quot;).valid?
    assert Topic.create(&quot;title&quot; =&gt; nil).valid?
    assert Topic.create(&quot;title&quot; =&gt; &quot;Validation macros rule!&quot;).valid?
  end

  # testing ticket #3142
  def test_validate_format_numeric
    Topic.validates_format_of(:title, :content, :with =&gt; /^[1-9][0-9]*$/, :message =&gt; &quot;is bad data&quot;)

    t = Topic.create(&quot;title&quot; =&gt; &quot;72x&quot;, &quot;content&quot; =&gt; &quot;6789&quot;)
    assert !t.valid?, &quot;Shouldn't be valid&quot;
    assert !t.save, &quot;Shouldn't save because it's invalid&quot;
    assert_equal &quot;is bad data&quot;, t.errors.on(:title)
    assert_nil t.errors.on(:content)

    t.title = &quot;-11&quot;
    assert !t.valid?, &quot;Shouldn't be valid&quot;

    t.title = &quot;03&quot;
    assert !t.valid?, &quot;Shouldn't be valid&quot;

    t.title = &quot;z44&quot;
    assert !t.valid?, &quot;Shouldn't be valid&quot;

    t.title = &quot;5v7&quot;
    assert !t.valid?, &quot;Shouldn't be valid&quot;

    t.title = &quot;1&quot;

    assert t.save
    assert_nil t.errors.on(:title)
  end

  def test_validate_format_with_formatted_message
    Topic.validates_format_of(:title, :with =&gt; /^Valid Title$/, :message =&gt; &quot;can't be {{value}}&quot;)
    t = Topic.create(:title =&gt; 'Invalid title')
    assert_equal &quot;can't be Invalid title&quot;, t.errors.on(:title)
  end

  def test_validates_inclusion_of
    Topic.validates_inclusion_of( :title, :in =&gt; %w( a b c d e f g ) )

    assert !Topic.create(&quot;title&quot; =&gt; &quot;a!&quot;, &quot;content&quot; =&gt; &quot;abc&quot;).valid?
    assert !Topic.create(&quot;title&quot; =&gt; &quot;a b&quot;, &quot;content&quot; =&gt; &quot;abc&quot;).valid?
    assert !Topic.create(&quot;title&quot; =&gt; nil, &quot;content&quot; =&gt; &quot;def&quot;).valid?

    t = Topic.create(&quot;title&quot; =&gt; &quot;a&quot;, &quot;content&quot; =&gt; &quot;I know you are but what am I?&quot;)
    assert t.valid?
    t.title = &quot;uhoh&quot;
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;is not included in the list&quot;, t.errors[&quot;title&quot;]

    assert_raise(ArgumentError) { Topic.validates_inclusion_of( :title, :in =&gt; nil ) }
    assert_raise(ArgumentError) { Topic.validates_inclusion_of( :title, :in =&gt; 0) }

    assert_nothing_raised(ArgumentError) { Topic.validates_inclusion_of( :title, :in =&gt; &quot;hi!&quot; ) }
    assert_nothing_raised(ArgumentError) { Topic.validates_inclusion_of( :title, :in =&gt; {} ) }
    assert_nothing_raised(ArgumentError) { Topic.validates_inclusion_of( :title, :in =&gt; [] ) }
  end

  def test_validates_inclusion_of_with_allow_nil
    Topic.validates_inclusion_of( :title, :in =&gt; %w( a b c d e f g ), :allow_nil=&gt;true )

    assert !Topic.create(&quot;title&quot; =&gt; &quot;a!&quot;, &quot;content&quot; =&gt; &quot;abc&quot;).valid?
    assert !Topic.create(&quot;title&quot; =&gt; &quot;&quot;, &quot;content&quot; =&gt; &quot;abc&quot;).valid?
    assert Topic.create(&quot;title&quot; =&gt; nil, &quot;content&quot; =&gt; &quot;abc&quot;).valid?
  end

  def test_numericality_with_getter_method
    repair_validations(Developer) do
      Developer.validates_numericality_of( :salary )
      developer = Developer.new(&quot;name&quot; =&gt; &quot;michael&quot;, &quot;salary&quot; =&gt; nil)
      developer.instance_eval(&quot;def salary; read_attribute('salary') ? read_attribute('salary') : 100000; end&quot;)
      assert developer.valid?
    end
  end

  def test_validates_length_of_with_allow_nil
    Topic.validates_length_of( :title, :is =&gt; 5, :allow_nil=&gt;true )

    assert !Topic.create(&quot;title&quot; =&gt; &quot;ab&quot;).valid?
    assert !Topic.create(&quot;title&quot; =&gt; &quot;&quot;).valid?
    assert Topic.create(&quot;title&quot; =&gt; nil).valid?
    assert Topic.create(&quot;title&quot; =&gt; &quot;abcde&quot;).valid?
  end

  def test_validates_length_of_with_allow_blank
    Topic.validates_length_of( :title, :is =&gt; 5, :allow_blank=&gt;true )

    assert !Topic.create(&quot;title&quot; =&gt; &quot;ab&quot;).valid?
    assert Topic.create(&quot;title&quot; =&gt; &quot;&quot;).valid?
    assert Topic.create(&quot;title&quot; =&gt; nil).valid?
    assert Topic.create(&quot;title&quot; =&gt; &quot;abcde&quot;).valid?
  end

  def test_validates_inclusion_of_with_formatted_message
    Topic.validates_inclusion_of( :title, :in =&gt; %w( a b c d e f g ), :message =&gt; &quot;option {{value}} is not in the list&quot; )

    assert Topic.create(&quot;title&quot; =&gt; &quot;a&quot;, &quot;content&quot; =&gt; &quot;abc&quot;).valid?

    t = Topic.create(&quot;title&quot; =&gt; &quot;uhoh&quot;, &quot;content&quot; =&gt; &quot;abc&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;option uhoh is not in the list&quot;, t.errors[&quot;title&quot;]
  end

  def test_numericality_with_allow_nil_and_getter_method
    repair_validations(Developer) do
      Developer.validates_numericality_of( :salary, :allow_nil =&gt; true)
      developer = Developer.new(&quot;name&quot; =&gt; &quot;michael&quot;, &quot;salary&quot; =&gt; nil)
      developer.instance_eval(&quot;def salary; read_attribute('salary') ? read_attribute('salary') : 100000; end&quot;)
      assert developer.valid?
    end
  end

  def test_validates_exclusion_of
    Topic.validates_exclusion_of( :title, :in =&gt; %w( abe monkey ) )

    assert Topic.create(&quot;title&quot; =&gt; &quot;something&quot;, &quot;content&quot; =&gt; &quot;abc&quot;).valid?
    assert !Topic.create(&quot;title&quot; =&gt; &quot;monkey&quot;, &quot;content&quot; =&gt; &quot;abc&quot;).valid?
  end

  def test_validates_exclusion_of_with_formatted_message
    Topic.validates_exclusion_of( :title, :in =&gt; %w( abe monkey ), :message =&gt; &quot;option {{value}} is restricted&quot; )

    assert Topic.create(&quot;title&quot; =&gt; &quot;something&quot;, &quot;content&quot; =&gt; &quot;abc&quot;)

    t = Topic.create(&quot;title&quot; =&gt; &quot;monkey&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;option monkey is restricted&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_using_minimum
    Topic.validates_length_of :title, :minimum =&gt; 5

    t = Topic.create(&quot;title&quot; =&gt; &quot;valid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?

    t.title = &quot;not&quot;
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;is too short (minimum is 5 characters)&quot;, t.errors[&quot;title&quot;]

    t.title = &quot;&quot;
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;is too short (minimum is 5 characters)&quot;, t.errors[&quot;title&quot;]

    t.title = nil
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;is too short (minimum is 5 characters)&quot;, t.errors[&quot;title&quot;]
  end

  def test_optionally_validates_length_of_using_minimum
    Topic.validates_length_of :title, :minimum =&gt; 5, :allow_nil =&gt; true

    t = Topic.create(&quot;title&quot; =&gt; &quot;valid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?

    t.title = nil
    assert t.valid?
  end

  def test_validates_length_of_using_maximum
    Topic.validates_length_of :title, :maximum =&gt; 5

    t = Topic.create(&quot;title&quot; =&gt; &quot;valid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?

    t.title = &quot;notvalid&quot;
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;is too long (maximum is 5 characters)&quot;, t.errors[&quot;title&quot;]

    t.title = &quot;&quot;
    assert t.valid?

    t.title = nil
    assert !t.valid?
  end

  def test_optionally_validates_length_of_using_maximum
    Topic.validates_length_of :title, :maximum =&gt; 5, :allow_nil =&gt; true

    t = Topic.create(&quot;title&quot; =&gt; &quot;valid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?

    t.title = nil
    assert t.valid?
  end

  def test_validates_length_of_using_within
    Topic.validates_length_of(:title, :content, :within =&gt; 3..5)

    t = Topic.new(&quot;title&quot; =&gt; &quot;a!&quot;, &quot;content&quot; =&gt; &quot;I'm ooooooooh so very long&quot;)
    assert !t.valid?
    assert_equal &quot;is too short (minimum is 3 characters)&quot;, t.errors.on(:title)
    assert_equal &quot;is too long (maximum is 5 characters)&quot;, t.errors.on(:content)

    t.title = nil
    t.content = nil
    assert !t.valid?
    assert_equal &quot;is too short (minimum is 3 characters)&quot;, t.errors.on(:title)
    assert_equal &quot;is too short (minimum is 3 characters)&quot;, t.errors.on(:content)

    t.title = &quot;abe&quot;
    t.content  = &quot;mad&quot;
    assert t.valid?
  end

  def test_optionally_validates_length_of_using_within
    Topic.validates_length_of :title, :content, :within =&gt; 3..5, :allow_nil =&gt; true

    t = Topic.create('title' =&gt; 'abc', 'content' =&gt; 'abcd')
    assert t.valid?

    t.title = nil
    assert t.valid?
  end

  def test_optionally_validates_length_of_using_within_on_create
    Topic.validates_length_of :title, :content, :within =&gt; 5..10, :on =&gt; :create, :too_long =&gt; &quot;my string is too long: {{count}}&quot;

    t = Topic.create(&quot;title&quot; =&gt; &quot;thisisnotvalid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.save
    assert t.errors.on(:title)
    assert_equal &quot;my string is too long: 10&quot;, t.errors[:title]

    t.title = &quot;butthisis&quot;
    assert t.save

    t.title = &quot;few&quot;
    assert t.save

    t.content = &quot;andthisislong&quot;
    assert t.save

    t.content = t.title = &quot;iamfine&quot;
    assert t.save
  end

  def test_optionally_validates_length_of_using_within_on_update
    Topic.validates_length_of :title, :content, :within =&gt; 5..10, :on =&gt; :update, :too_short =&gt; &quot;my string is too short: {{count}}&quot;

    t = Topic.create(&quot;title&quot; =&gt; &quot;vali&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.save
    assert t.errors.on(:title)

    t.title = &quot;not&quot;
    assert !t.save
    assert t.errors.on(:title)
    assert_equal &quot;my string is too short: 5&quot;, t.errors[:title]

    t.title = &quot;valid&quot;
    t.content = &quot;andthisistoolong&quot;
    assert !t.save
    assert t.errors.on(:content)

    t.content = &quot;iamfine&quot;
    assert t.save
  end

  def test_validates_length_of_using_is
    Topic.validates_length_of :title, :is =&gt; 5

    t = Topic.create(&quot;title&quot; =&gt; &quot;valid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?

    t.title = &quot;notvalid&quot;
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;is the wrong length (should be 5 characters)&quot;, t.errors[&quot;title&quot;]

    t.title = &quot;&quot;
    assert !t.valid?

    t.title = nil
    assert !t.valid?
  end

  def test_optionally_validates_length_of_using_is
    Topic.validates_length_of :title, :is =&gt; 5, :allow_nil =&gt; true

    t = Topic.create(&quot;title&quot; =&gt; &quot;valid&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?

    t.title = nil
    assert t.valid?
  end

  def test_validates_length_of_using_bignum
    bigmin = 2 ** 30
    bigmax = 2 ** 32
    bigrange = bigmin...bigmax
    assert_nothing_raised do
      Topic.validates_length_of :title, :is =&gt; bigmin + 5
      Topic.validates_length_of :title, :within =&gt; bigrange
      Topic.validates_length_of :title, :in =&gt; bigrange
      Topic.validates_length_of :title, :minimum =&gt; bigmin
      Topic.validates_length_of :title, :maximum =&gt; bigmax
    end
  end

  def test_validates_length_with_globally_modified_error_message
    defaults = ActiveSupport::Deprecation.silence { ActiveRecord::Errors.default_error_messages }
    original_message = defaults[:too_short]
    defaults[:too_short] = 'tu est trops petit hombre {{count}}'

    Topic.validates_length_of :title, :minimum =&gt; 10
    t = Topic.create(:title =&gt; 'too short')
    assert !t.valid?

    assert_equal 'tu est trops petit hombre 10', t.errors['title']

  ensure
    defaults[:too_short] = original_message
  end

  def test_validates_size_of_association
    repair_validations(Owner) do
      assert_nothing_raised { Owner.validates_size_of :pets, :minimum =&gt; 1 }
      o = Owner.new('name' =&gt; 'nopets')
      assert !o.save
      assert o.errors.on(:pets)
      pet = o.pets.build('name' =&gt; 'apet')
      assert o.valid?
    end
  end

  def test_validates_size_of_association_using_within
    repair_validations(Owner) do
      assert_nothing_raised { Owner.validates_size_of :pets, :within =&gt; 1..2 }
      o = Owner.new('name' =&gt; 'nopets')
      assert !o.save
      assert o.errors.on(:pets)

      pet = o.pets.build('name' =&gt; 'apet')
      assert o.valid?

      2.times { o.pets.build('name' =&gt; 'apet') }
      assert !o.save
      assert o.errors.on(:pets)
    end
  end

  def test_validates_length_of_nasty_params
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :minimum=&gt;6, :maximum=&gt;9) }
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :within=&gt;6, :maximum=&gt;9) }
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :within=&gt;6, :minimum=&gt;9) }
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :within=&gt;6, :is=&gt;9) }
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :minimum=&gt;&quot;a&quot;) }
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :maximum=&gt;&quot;a&quot;) }
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :within=&gt;&quot;a&quot;) }
    assert_raise(ArgumentError) { Topic.validates_length_of(:title, :is=&gt;&quot;a&quot;) }
  end

  def test_validates_length_of_custom_errors_for_minimum_with_message
    Topic.validates_length_of( :title, :minimum=&gt;5, :message=&gt;&quot;boo {{count}}&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;boo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_custom_errors_for_minimum_with_too_short
    Topic.validates_length_of( :title, :minimum=&gt;5, :too_short=&gt;&quot;hoo {{count}}&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_custom_errors_for_maximum_with_message
    Topic.validates_length_of( :title, :maximum=&gt;5, :message=&gt;&quot;boo {{count}}&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;boo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_custom_errors_for_in
    Topic.validates_length_of(:title, :in =&gt; 10..20, :message =&gt; &quot;hoo {{count}}&quot;)
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 10&quot;, t.errors[&quot;title&quot;]

    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhohuhohuhohuhohuhohuhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 20&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_custom_errors_for_maximum_with_too_long
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_custom_errors_for_is_with_message
    Topic.validates_length_of( :title, :is=&gt;5, :message=&gt;&quot;boo {{count}}&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;boo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_custom_errors_for_is_with_wrong_length
    Topic.validates_length_of( :title, :is=&gt;5, :wrong_length=&gt;&quot;hoo {{count}}&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_length_of_using_minimum_utf8
    with_kcode('UTF8') do
      Topic.validates_length_of :title, :minimum =&gt; 5

      t = Topic.create(&quot;title&quot; =&gt; &quot;一二三四五&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
      assert t.valid?

      t.title = &quot;一二三四&quot;
      assert !t.valid?
      assert t.errors.on(:title)
      assert_equal &quot;is too short (minimum is 5 characters)&quot;, t.errors[&quot;title&quot;]
    end
  end

  def test_validates_length_of_using_maximum_utf8
    with_kcode('UTF8') do
      Topic.validates_length_of :title, :maximum =&gt; 5

      t = Topic.create(&quot;title&quot; =&gt; &quot;一二三四五&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
      assert t.valid?

      t.title = &quot;一二34五六&quot;
      assert !t.valid?
      assert t.errors.on(:title)
      assert_equal &quot;is too long (maximum is 5 characters)&quot;, t.errors[&quot;title&quot;]
    end
  end

  def test_validates_length_of_using_within_utf8
    with_kcode('UTF8') do
      Topic.validates_length_of(:title, :content, :within =&gt; 3..5)

      t = Topic.new(&quot;title&quot; =&gt; &quot;一二&quot;, &quot;content&quot; =&gt; &quot;12三四五六七&quot;)
      assert !t.valid?
      assert_equal &quot;is too short (minimum is 3 characters)&quot;, t.errors.on(:title)
      assert_equal &quot;is too long (maximum is 5 characters)&quot;, t.errors.on(:content)
      t.title = &quot;一二三&quot;
      t.content  = &quot;12三&quot;
      assert t.valid?
    end
  end

  def test_optionally_validates_length_of_using_within_utf8
    with_kcode('UTF8') do
      Topic.validates_length_of :title, :within =&gt; 3..5, :allow_nil =&gt; true

      t = Topic.create(:title =&gt; &quot;一二三四五&quot;)
      assert t.valid?, t.errors.inspect

      t = Topic.create(:title =&gt; &quot;一二三&quot;)
      assert t.valid?, t.errors.inspect

      t.title = nil
      assert t.valid?, t.errors.inspect
    end
  end

  def test_optionally_validates_length_of_using_within_on_create_utf8
    with_kcode('UTF8') do
      Topic.validates_length_of :title, :within =&gt; 5..10, :on =&gt; :create, :too_long =&gt; &quot;長すぎます: {{count}}&quot;

      t = Topic.create(&quot;title&quot; =&gt; &quot;一二三四五六七八九十A&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
      assert !t.save
      assert t.errors.on(:title)
      assert_equal &quot;長すぎます: 10&quot;, t.errors[:title]

      t.title = &quot;一二三四五六七八九&quot;
      assert t.save

      t.title = &quot;一二3&quot;
      assert t.save

      t.content = &quot;一二三四五六七八九十&quot;
      assert t.save

      t.content = t.title = &quot;一二三四五六&quot;
      assert t.save
    end
  end

  def test_optionally_validates_length_of_using_within_on_update_utf8
    with_kcode('UTF8') do
      Topic.validates_length_of :title, :within =&gt; 5..10, :on =&gt; :update, :too_short =&gt; &quot;短すぎます: {{count}}&quot;

      t = Topic.create(&quot;title&quot; =&gt; &quot;一二三4&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
      assert !t.save
      assert t.errors.on(:title)

      t.title = &quot;1二三4&quot;
      assert !t.save
      assert t.errors.on(:title)
      assert_equal &quot;短すぎます: 5&quot;, t.errors[:title]

      t.title = &quot;一二三四五六七八九十A&quot;
      assert !t.save
      assert t.errors.on(:title)

      t.title = &quot;一二345&quot;
      assert t.save
    end
  end

  def test_validates_length_of_using_is_utf8
    with_kcode('UTF8') do
      Topic.validates_length_of :title, :is =&gt; 5

      t = Topic.create(&quot;title&quot; =&gt; &quot;一二345&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
      assert t.valid?

      t.title = &quot;一二345六&quot;
      assert !t.valid?
      assert t.errors.on(:title)
      assert_equal &quot;is the wrong length (should be 5 characters)&quot;, t.errors[&quot;title&quot;]
    end
  end

  def test_validates_length_of_with_block
    Topic.validates_length_of :content, :minimum =&gt; 5, :too_short=&gt;&quot;Your essay must be at least {{count}} words.&quot;,
                                        :tokenizer =&gt; lambda {|str| str.scan(/\w+/) }
    t = Topic.create!(:content =&gt; &quot;this content should be long enough&quot;)
    assert t.valid?

    t.content = &quot;not long enough&quot;
    assert !t.valid?
    assert t.errors.on(:content)
    assert_equal &quot;Your essay must be at least 5 words.&quot;, t.errors[:content]
  end

  def test_validates_size_of_association_utf8
    repair_validations(Owner) do
      with_kcode('UTF8') do
        assert_nothing_raised { Owner.validates_size_of :pets, :minimum =&gt; 1 }
        o = Owner.new('name' =&gt; 'あいうえおかきくけこ')
        assert !o.save
        assert o.errors.on(:pets)
        o.pets.build('name' =&gt; 'あいうえおかきくけこ')
        assert o.valid?
      end
    end
  end

  def test_validates_associated_many
    Topic.validates_associated( :replies )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    t.replies &lt;&lt; [r = Reply.new(&quot;title&quot; =&gt; &quot;A reply&quot;), r2 = Reply.new(&quot;title&quot; =&gt; &quot;Another reply&quot;, &quot;content&quot; =&gt; &quot;non-empty&quot;), r3 = Reply.new(&quot;title&quot; =&gt; &quot;Yet another reply&quot;), r4 = Reply.new(&quot;title&quot; =&gt; &quot;The last reply&quot;, &quot;content&quot; =&gt; &quot;non-empty&quot;)]
    assert !t.valid?
    assert t.errors.on(:replies)
    assert_equal 1, r.errors.count  # make sure all associated objects have been validated
    assert_equal 0, r2.errors.count
    assert_equal 1, r3.errors.count
    assert_equal 0, r4.errors.count
    r.content = r3.content = &quot;non-empty&quot;
    assert t.valid?
  end

  def test_validates_associated_one
    repair_validations(Reply) do
      Reply.validates_associated( :topic )
      Topic.validates_presence_of( :content )
      r = Reply.new(&quot;title&quot; =&gt; &quot;A reply&quot;, &quot;content&quot; =&gt; &quot;with content!&quot;)
      r.topic = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;)
      assert !r.valid?
      assert r.errors.on(:topic)
      r.topic.content = &quot;non-empty&quot;
      assert r.valid?
    end
  end

  def test_validate_block
    Topic.validate { |topic| topic.errors.add(&quot;title&quot;, &quot;will never be valid&quot;) }
    t = Topic.create(&quot;title&quot; =&gt; &quot;Title&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;will never be valid&quot;, t.errors[&quot;title&quot;]
  end

  def test_invalid_validator
    Topic.validate 3
    assert_raise(ArgumentError) { t = Topic.create }
  end

  def test_throw_away_typing
    d = Developer.new(&quot;name&quot; =&gt; &quot;David&quot;, &quot;salary&quot; =&gt; &quot;100,000&quot;)
    assert !d.valid?
    assert_equal 100, d.salary
    assert_equal &quot;100,000&quot;, d.salary_before_type_cast
  end

  def test_validates_acceptance_of_with_custom_error_using_quotes
    repair_validations(Developer) do
      Developer.validates_acceptance_of :salary, :message=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.salary = &quot;0&quot;
      assert !d.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:salary).last
    end
  end

  def test_validates_confirmation_of_with_custom_error_using_quotes
    repair_validations(Developer) do
      Developer.validates_confirmation_of :name, :message=&gt; &quot;confirm 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.name = &quot;John&quot;
      d.name_confirmation = &quot;Johnny&quot;
      assert !d.valid?
      assert_equal &quot;confirm 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:name)
    end
  end

  def test_validates_format_of_with_custom_error_using_quotes
    repair_validations(Developer) do
      Developer.validates_format_of :name, :with =&gt; /^(A-Z*)$/, :message=&gt; &quot;format 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.name = d.name_confirmation = &quot;John 32&quot;
      assert !d.valid?
      assert_equal &quot;format 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:name)
    end
  end

  def test_validates_inclusion_of_with_custom_error_using_quotes
    repair_validations(Developer) do
      Developer.validates_inclusion_of :salary, :in =&gt; 1000..80000, :message=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.salary = &quot;90,000&quot;
      assert !d.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:salary).last
    end
  end

  def test_validates_length_of_with_custom_too_long_using_quotes
    repair_validations(Developer) do
      Developer.validates_length_of :name, :maximum =&gt; 4, :too_long=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.name = &quot;Jeffrey&quot;
      assert !d.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:name)
    end
  end

  def test_validates_length_of_with_custom_too_short_using_quotes
    repair_validations(Developer) do
      Developer.validates_length_of :name, :minimum =&gt; 4, :too_short=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.name = &quot;Joe&quot;
      assert !d.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:name)
    end
  end

  def test_validates_length_of_with_custom_message_using_quotes
    repair_validations(Developer) do
      Developer.validates_length_of :name, :minimum =&gt; 4, :message=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.name = &quot;Joe&quot;
      assert !d.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:name)
    end
  end

  def test_validates_presence_of_with_custom_message_using_quotes
    repair_validations(Developer) do
      Developer.validates_presence_of :non_existent, :message=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.name = &quot;Joe&quot;
      assert !d.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:non_existent)
    end
  end

  def test_validates_uniqueness_of_with_custom_message_using_quotes
    repair_validations(Developer) do
      Developer.validates_uniqueness_of :name, :message=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      d = Developer.new
      d.name = &quot;David&quot;
      assert !d.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, d.errors.on(:name)
    end
  end

  def test_validates_associated_with_custom_message_using_quotes
    repair_validations(Reply) do
      Reply.validates_associated :topic, :message=&gt; &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;
      Topic.validates_presence_of :content
      r = Reply.create(&quot;title&quot; =&gt; &quot;A reply&quot;, &quot;content&quot; =&gt; &quot;with content!&quot;)
      r.topic = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;)
      assert !r.valid?
      assert_equal &quot;This string contains 'single' and \&quot;double\&quot; quotes&quot;, r.errors.on(:topic)
    end
  end

  def test_if_validation_using_method_true
    # When the method returns true
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :if =&gt; :condition_is_true )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_unless_validation_using_method_true
    # When the method returns true
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :unless =&gt; :condition_is_true )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?
    assert !t.errors.on(:title)
  end

  def test_if_validation_using_method_false
    # When the method returns false
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :if =&gt; :condition_is_true_but_its_not )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?
    assert !t.errors.on(:title)
  end

  def test_unless_validation_using_method_false
    # When the method returns false
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :unless =&gt; :condition_is_true_but_its_not )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_if_validation_using_string_true
    # When the evaluated string returns true
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :if =&gt; &quot;a = 1; a == 1&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_unless_validation_using_string_true
    # When the evaluated string returns true
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :unless =&gt; &quot;a = 1; a == 1&quot; )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?
    assert !t.errors.on(:title)
  end

  def test_if_validation_using_string_false
    # When the evaluated string returns false
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :if =&gt; &quot;false&quot;)
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?
    assert !t.errors.on(:title)
  end

  def test_unless_validation_using_string_false
    # When the evaluated string returns false
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;, :unless =&gt; &quot;false&quot;)
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_if_validation_using_block_true
    # When the block returns true
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;,
      :if =&gt; Proc.new { |r| r.content.size &gt; 4 } )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_unless_validation_using_block_true
    # When the block returns true
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;,
      :unless =&gt; Proc.new { |r| r.content.size &gt; 4 } )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?
    assert !t.errors.on(:title)
  end

  def test_if_validation_using_block_false
    # When the block returns false
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;,
      :if =&gt; Proc.new { |r| r.title != &quot;uhohuhoh&quot;} )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert t.valid?
    assert !t.errors.on(:title)
  end

  def test_unless_validation_using_block_false
    # When the block returns false
    Topic.validates_length_of( :title, :maximum=&gt;5, :too_long=&gt;&quot;hoo {{count}}&quot;,
      :unless =&gt; Proc.new { |r| r.title != &quot;uhohuhoh&quot;} )
    t = Topic.create(&quot;title&quot; =&gt; &quot;uhohuhoh&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
    assert !t.valid?
    assert t.errors.on(:title)
    assert_equal &quot;hoo 5&quot;, t.errors[&quot;title&quot;]
  end

  def test_validates_associated_missing
    repair_validations(Reply) do
      Reply.validates_presence_of(:topic)
      r = Reply.create(&quot;title&quot; =&gt; &quot;A reply&quot;, &quot;content&quot; =&gt; &quot;with content!&quot;)
      assert !r.valid?
      assert r.errors.on(:topic)

      r.topic = Topic.find :first
      assert r.valid?
    end
  end

  def test_errors_to_xml
    r = Reply.new :title =&gt; &quot;Wrong Create&quot;
    assert !r.valid?
    xml = r.errors.to_xml(:skip_instruct =&gt; true)
    assert_equal &quot;&lt;errors&gt;&quot;, xml.first(8)
    assert xml.include?(&quot;&lt;error&gt;Title is Wrong Create&lt;/error&gt;&quot;)
    assert xml.include?(&quot;&lt;error&gt;Content Empty&lt;/error&gt;&quot;)
  end

  def test_validation_order
    Topic.validates_presence_of :title, :author_name
    Topic.validate {|topic| topic.errors.add('author_email_address', 'will never be valid')}
    Topic.validates_length_of :title, :content, :minimum =&gt; 2

    t = Topic.new :title =&gt; ''
    t.valid?
    e = t.errors.instance_variable_get '@errors'
    assert_equal 'title', key = e.keys.first
    assert_equal &quot;can't be blank&quot;, t.errors.on(key).first
    assert_equal 'is too short (minimum is 2 characters)', t.errors.on(key).second
    assert_equal 'author_name', key = e.keys.second
    assert_equal &quot;can't be blank&quot;, t.errors.on(key)
    assert_equal 'author_email_address', key = e.keys.third
    assert_equal 'will never be valid', t.errors.on(key)
    assert_equal 'content', key = e.keys.fourth
    assert_equal 'is too short (minimum is 2 characters)', t.errors.on(key)
  end

  def test_invalid_should_be_the_opposite_of_valid
    Topic.validates_presence_of :title

    t = Topic.new
    assert t.invalid?
    assert t.errors.invalid?(:title)

    t.title = 'Things are going to change'
    assert !t.invalid?
  end

  # previous implementation of validates_presence_of eval'd the
  # string with the wrong binding, this regression test is to
  # ensure that it works correctly
  def test_validation_with_if_as_string
    Topic.validates_presence_of(:title)
    Topic.validates_presence_of(:author_name, :if =&gt; &quot;title.to_s.match('important')&quot;)

    t = Topic.new
    assert !t.valid?, &quot;A topic without a title should not be valid&quot;
    assert !t.errors.invalid?(&quot;author_name&quot;), &quot;A topic without an 'important' title should not require an author&quot;

    t.title = &quot;Just a title&quot;
    assert t.valid?, &quot;A topic with a basic title should be valid&quot;

    t.title = &quot;A very important title&quot;
    assert !t.valid?, &quot;A topic with an important title, but without an author, should not be valid&quot;
    assert t.errors.invalid?(&quot;author_name&quot;), &quot;A topic with an 'important' title should require an author&quot;

    t.author_name = &quot;Hubert J. Farnsworth&quot;
    assert t.valid?, &quot;A topic with an important title and author should be valid&quot;
  end
end


class ValidatesNumericalityTest &lt; ActiveRecord::TestCase
  NIL = [nil]
  BLANK = [&quot;&quot;, &quot; &quot;, &quot; \t \r \n&quot;]
  BIGDECIMAL_STRINGS = %w(12345678901234567890.1234567890) # 30 significent digits
  FLOAT_STRINGS = %w(0.0 +0.0 -0.0 10.0 10.5 -10.5 -0.0001 -090.1 90.1e1 -90.1e5 -90.1e-5 90e-5)
  INTEGER_STRINGS = %w(0 +0 -0 10 +10 -10 0090 -090)
  FLOATS = [0.0, 10.0, 10.5, -10.5, -0.0001] + FLOAT_STRINGS
  INTEGERS = [0, 10, -10] + INTEGER_STRINGS
  BIGDECIMAL = BIGDECIMAL_STRINGS.collect! { |bd| BigDecimal.new(bd) }
  JUNK = [&quot;not a number&quot;, &quot;42 not a number&quot;, &quot;0xdeadbeef&quot;, &quot;00-1&quot;, &quot;--3&quot;, &quot;+-3&quot;, &quot;+3-1&quot;, &quot;-+019.0&quot;, &quot;12.12.13.12&quot;, &quot;123\nnot a number&quot;]
  INFINITY = [1.0/0.0]

  repair_validations(Topic)

  def test_default_validates_numericality_of
    Topic.validates_numericality_of :approved

    invalid!(NIL + BLANK + JUNK)
    valid!(FLOATS + INTEGERS + BIGDECIMAL + INFINITY)
  end

  def test_validates_numericality_of_with_nil_allowed
    Topic.validates_numericality_of :approved, :allow_nil =&gt; true

    invalid!(JUNK)
    valid!(NIL + BLANK + FLOATS + INTEGERS + BIGDECIMAL + INFINITY)
  end

  def test_validates_numericality_of_with_integer_only
    Topic.validates_numericality_of :approved, :only_integer =&gt; true

    invalid!(NIL + BLANK + JUNK + FLOATS + BIGDECIMAL + INFINITY)
    valid!(INTEGERS)
  end

  def test_validates_numericality_of_with_integer_only_and_nil_allowed
    Topic.validates_numericality_of :approved, :only_integer =&gt; true, :allow_nil =&gt; true

    invalid!(JUNK + FLOATS + BIGDECIMAL + INFINITY)
    valid!(NIL + BLANK + INTEGERS)
  end

  def test_validates_numericality_with_greater_than
    Topic.validates_numericality_of :approved, :greater_than =&gt; 10

    invalid!([-10, 10], 'must be greater than 10')
    valid!([11])
  end

  def test_validates_numericality_with_greater_than_or_equal
    Topic.validates_numericality_of :approved, :greater_than_or_equal_to =&gt; 10

    invalid!([-9, 9], 'must be greater than or equal to 10')
    valid!([10])
  end

  def test_validates_numericality_with_equal_to
    Topic.validates_numericality_of :approved, :equal_to =&gt; 10

    invalid!([-10, 11] + INFINITY, 'must be equal to 10')
    valid!([10])
  end

  def test_validates_numericality_with_less_than
    Topic.validates_numericality_of :approved, :less_than =&gt; 10

    invalid!([10], 'must be less than 10')
    valid!([-9, 9])
  end

  def test_validates_numericality_with_less_than_or_equal_to
    Topic.validates_numericality_of :approved, :less_than_or_equal_to =&gt; 10

    invalid!([11], 'must be less than or equal to 10')
    valid!([-10, 10])
  end

  def test_validates_numericality_with_odd
    Topic.validates_numericality_of :approved, :odd =&gt; true

    invalid!([-2, 2], 'must be odd')
    valid!([-1, 1])
  end

  def test_validates_numericality_with_even
    Topic.validates_numericality_of :approved, :even =&gt; true

    invalid!([-1, 1], 'must be even')
    valid!([-2, 2])
  end

  def test_validates_numericality_with_greater_than_less_than_and_even
    Topic.validates_numericality_of :approved, :greater_than =&gt; 1, :less_than =&gt; 4, :even =&gt; true

    invalid!([1, 3, 4])
    valid!([2])
  end

  def test_validates_numericality_with_numeric_message
    Topic.validates_numericality_of :approved, :less_than =&gt; 4, :message =&gt; &quot;smaller than {{count}}&quot;
    topic = Topic.new(&quot;title&quot; =&gt; &quot;numeric test&quot;, &quot;approved&quot; =&gt; 10)

    assert !topic.valid?
    assert_equal &quot;smaller than 4&quot;, topic.errors.on(:approved)

    Topic.validates_numericality_of :approved, :greater_than =&gt; 4, :message =&gt; &quot;greater than {{count}}&quot;
    topic = Topic.new(&quot;title&quot; =&gt; &quot;numeric test&quot;, &quot;approved&quot; =&gt; 1)

    assert !topic.valid?
    assert_equal &quot;greater than 4&quot;, topic.errors.on(:approved)
  end

  private
    def invalid!(values, error=nil)
      with_each_topic_approved_value(values) do |topic, value|
        assert !topic.valid?, &quot;#{value.inspect} not rejected as a number&quot;
        assert topic.errors.on(:approved)
        assert_equal error, topic.errors.on(:approved) if error
      end
    end

    def valid!(values)
      with_each_topic_approved_value(values) do |topic, value|
        assert topic.valid?, &quot;#{value.inspect} not accepted as a number&quot;
      end
    end

    def with_each_topic_approved_value(values)
      topic = Topic.new(&quot;title&quot; =&gt; &quot;numeric test&quot;, &quot;content&quot; =&gt; &quot;whatever&quot;)
      values.each do |value|
        topic.approved = value
        yield topic, value
      end
    end
end
</pre>
    </div>