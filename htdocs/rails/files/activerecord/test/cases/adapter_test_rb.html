  <div id="fileHeader">
    <h1>adapter_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/adapter_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Nov 27 16:38:16 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;

class AdapterTest &lt; ActiveRecord::TestCase
  def setup
    @connection = ActiveRecord::Base.connection
  end

  def test_tables
    tables = @connection.tables
    assert tables.include?(&quot;accounts&quot;)
    assert tables.include?(&quot;authors&quot;)
    assert tables.include?(&quot;tasks&quot;)
    assert tables.include?(&quot;topics&quot;)
  end

  def test_table_exists?
    assert @connection.table_exists?(&quot;accounts&quot;)
    assert !@connection.table_exists?(&quot;nonexistingtable&quot;)
  end

  def test_indexes
    idx_name = &quot;accounts_idx&quot;

    if @connection.respond_to?(:indexes)
      indexes = @connection.indexes(&quot;accounts&quot;)
      assert indexes.empty?

      @connection.add_index :accounts, :firm_id, :name =&gt; idx_name
      indexes = @connection.indexes(&quot;accounts&quot;)
      assert_equal &quot;accounts&quot;, indexes.first.table
      # OpenBase does not have the concept of a named index
      # Indexes are merely properties of columns.
      assert_equal idx_name, indexes.first.name unless current_adapter?(:OpenBaseAdapter)
      assert !indexes.first.unique
      assert_equal [&quot;firm_id&quot;], indexes.first.columns
    else
      warn &quot;#{@connection.class} does not respond to #indexes&quot;
    end

  ensure
    @connection.remove_index(:accounts, :name =&gt; idx_name) rescue nil
  end

  def test_current_database
    if @connection.respond_to?(:current_database)
      assert_equal ENV['ARUNIT_DB_NAME'] || &quot;activerecord_unittest&quot;, @connection.current_database
    end
  end

  if current_adapter?(:MysqlAdapter)
    def test_charset
      assert_not_nil @connection.charset
      assert_not_equal 'character_set_database', @connection.charset
      assert_equal @connection.show_variable('character_set_database'), @connection.charset
    end

    def test_collation
      assert_not_nil @connection.collation
      assert_not_equal 'collation_database', @connection.collation
      assert_equal @connection.show_variable('collation_database'), @connection.collation
    end

    def test_show_nonexistent_variable_returns_nil
      assert_nil @connection.show_variable('foo_bar_baz')
    end

    def test_not_specifying_database_name_for_cross_database_selects
      assert_nothing_raised do
        ActiveRecord::Base.establish_connection({
          :adapter  =&gt; 'mysql',
          :username =&gt; 'rails'
        })
        ActiveRecord::Base.connection.execute &quot;SELECT activerecord_unittest.pirates.*, activerecord_unittest2.courses.* FROM activerecord_unittest.pirates, activerecord_unittest2.courses&quot;
      end

      ActiveRecord::Base.establish_connection 'arunit'
    end
  end

  if current_adapter?(:PostgreSQLAdapter)
    def test_encoding
      assert_not_nil @connection.encoding
    end
  end

  def test_table_alias
    def @connection.test_table_alias_length() 10; end
    class &lt;&lt; @connection
      alias_method :old_table_alias_length, :table_alias_length
      alias_method :table_alias_length,     :test_table_alias_length
    end

    assert_equal 'posts',      @connection.table_alias_for('posts')
    assert_equal 'posts_comm', @connection.table_alias_for('posts_comments')
    assert_equal 'dbo_posts',  @connection.table_alias_for('dbo.posts')

    class &lt;&lt; @connection
      remove_method :table_alias_length
      alias_method :table_alias_length, :old_table_alias_length
    end
  end

  # test resetting sequences in odd tables in postgreSQL
  if ActiveRecord::Base.connection.respond_to?(:reset_pk_sequence!)
    require 'models/movie'
    require 'models/subscriber'

    def test_reset_empty_table_with_custom_pk
      Movie.delete_all
      Movie.connection.reset_pk_sequence! 'movies'
      assert_equal 1, Movie.create(:name =&gt; 'fight club').id
    end

    if ActiveRecord::Base.connection.adapter_name != &quot;FrontBase&quot;
      def test_reset_table_with_non_integer_pk
        Subscriber.delete_all
        Subscriber.connection.reset_pk_sequence! 'subscribers'
        sub = Subscriber.new(:name =&gt; 'robert drake')
        sub.id = 'bob drake'
        assert_nothing_raised { sub.save! }
      end
    end
  end

  def test_add_limit_offset_should_sanitize_sql_injection_for_limit_without_comas
    sql_inject = &quot;1 select * from schema&quot;
      assert_equal &quot; LIMIT 1&quot;, @connection.add_limit_offset!(&quot;&quot;, :limit=&gt;sql_inject)
    if current_adapter?(:MysqlAdapter)
      assert_equal &quot; LIMIT 7, 1&quot;, @connection.add_limit_offset!(&quot;&quot;, :limit=&gt;sql_inject, :offset=&gt;7)
    else
      assert_equal &quot; LIMIT 1 OFFSET 7&quot;, @connection.add_limit_offset!(&quot;&quot;, :limit=&gt;sql_inject, :offset=&gt;7)
    end
  end

  def test_add_limit_offset_should_sanitize_sql_injection_for_limit_with_comas
    sql_inject = &quot;1, 7 procedure help()&quot;
    if current_adapter?(:MysqlAdapter)
      assert_equal &quot; LIMIT 1,7&quot;, @connection.add_limit_offset!(&quot;&quot;, :limit=&gt;sql_inject)
      assert_equal &quot; LIMIT 7, 1&quot;, @connection.add_limit_offset!(&quot;&quot;, :limit=&gt; '1 ; DROP TABLE USERS', :offset=&gt;7)
    else
      assert_equal &quot; LIMIT 1,7&quot;, @connection.add_limit_offset!(&quot;&quot;, :limit=&gt;sql_inject)
      assert_equal &quot; LIMIT 1,7 OFFSET 7&quot;, @connection.add_limit_offset!(&quot;&quot;, :limit=&gt;sql_inject, :offset=&gt;7)
    end
  end
end
</pre>
    </div>