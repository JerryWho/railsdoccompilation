  <div id="fileHeader">
    <h1>reflection_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/reflection_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Nov 27 16:38:16 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'models/topic'
require 'models/customer'
require 'models/company'
require 'models/company_in_module'
require 'models/subscriber'
require 'models/pirate'

class ReflectionTest &lt; ActiveRecord::TestCase
  fixtures :topics, :customers, :companies, :subscribers

  def setup
    @first = Topic.find(1)
  end

  def test_column_null_not_null
    subscriber = Subscriber.find(:first)
    assert subscriber.column_for_attribute(&quot;name&quot;).null
    assert !subscriber.column_for_attribute(&quot;nick&quot;).null
  end

  def test_read_attribute_names
    assert_equal(
      %w( id title author_name author_email_address bonus_time written_on last_read content approved replies_count parent_id parent_title type ).sort,
      @first.attribute_names
    )
  end

  def test_columns
    assert_equal 13, Topic.columns.length
  end

  def test_columns_are_returned_in_the_order_they_were_declared
    column_names = Topic.columns.map { |column| column.name }
    assert_equal %w(id title author_name author_email_address written_on bonus_time last_read content approved replies_count parent_id parent_title type), column_names
  end

  def test_content_columns
    content_columns        = Topic.content_columns
    content_column_names   = content_columns.map {|column| column.name}
    assert_equal 9, content_columns.length
    assert_equal %w(title author_name author_email_address written_on bonus_time last_read content approved parent_title).sort, content_column_names.sort
  end

  def test_column_string_type_and_limit
    assert_equal :string, @first.column_for_attribute(&quot;title&quot;).type
    assert_equal 255, @first.column_for_attribute(&quot;title&quot;).limit
  end

  def test_column_null_not_null
    subscriber = Subscriber.find(:first)
    assert subscriber.column_for_attribute(&quot;name&quot;).null
    assert !subscriber.column_for_attribute(&quot;nick&quot;).null
  end

  def test_human_name_for_column
    assert_equal &quot;Author name&quot;, @first.column_for_attribute(&quot;author_name&quot;).human_name
  end

  def test_integer_columns
    assert_equal :integer, @first.column_for_attribute(&quot;id&quot;).type
  end

  def test_reflection_klass_for_nested_class_name
    reflection = ActiveRecord::Reflection::MacroReflection.new(nil, nil, { :class_name =&gt; 'MyApplication::Business::Company' }, nil)
    assert_nothing_raised do
      assert_equal MyApplication::Business::Company, reflection.klass
    end
  end

  def test_aggregation_reflection
    reflection_for_address = ActiveRecord::Reflection::AggregateReflection.new(
      :composed_of, :address, { :mapping =&gt; [ %w(address_street street), %w(address_city city), %w(address_country country) ] }, Customer
    )

    reflection_for_balance = ActiveRecord::Reflection::AggregateReflection.new(
      :composed_of, :balance, { :class_name =&gt; &quot;Money&quot;, :mapping =&gt; %w(balance amount) }, Customer
    )

    reflection_for_gps_location = ActiveRecord::Reflection::AggregateReflection.new(
      :composed_of, :gps_location, { }, Customer
    )

    assert Customer.reflect_on_all_aggregations.include?(reflection_for_gps_location)
    assert Customer.reflect_on_all_aggregations.include?(reflection_for_balance)
    assert Customer.reflect_on_all_aggregations.include?(reflection_for_address)

    assert_equal reflection_for_address, Customer.reflect_on_aggregation(:address)

    assert_equal Address, Customer.reflect_on_aggregation(:address).klass

    assert_equal Money, Customer.reflect_on_aggregation(:balance).klass
  end

  def test_reflect_on_all_autosave_associations
    expected = Pirate.reflect_on_all_associations.select { |r| r.options[:autosave] }
    received = Pirate.reflect_on_all_autosave_associations

    assert !received.empty?
    assert_not_equal Pirate.reflect_on_all_associations.length, received.length
    assert_equal expected, received
  end

  def test_has_many_reflection
    reflection_for_clients = ActiveRecord::Reflection::AssociationReflection.new(:has_many, :clients, { :order =&gt; &quot;id&quot;, :dependent =&gt; :destroy }, Firm)

    assert_equal reflection_for_clients, Firm.reflect_on_association(:clients)

    assert_equal Client, Firm.reflect_on_association(:clients).klass
    assert_equal 'companies', Firm.reflect_on_association(:clients).table_name

    assert_equal Client, Firm.reflect_on_association(:clients_of_firm).klass
    assert_equal 'companies', Firm.reflect_on_association(:clients_of_firm).table_name
  end

  def test_has_one_reflection
    reflection_for_account = ActiveRecord::Reflection::AssociationReflection.new(:has_one, :account, { :foreign_key =&gt; &quot;firm_id&quot;, :dependent =&gt; :destroy }, Firm)
    assert_equal reflection_for_account, Firm.reflect_on_association(:account)

    assert_equal Account, Firm.reflect_on_association(:account).klass
    assert_equal 'accounts', Firm.reflect_on_association(:account).table_name
  end

  def test_belongs_to_inferred_foreign_key_from_assoc_name
    Company.belongs_to :foo
    assert_equal &quot;foo_id&quot;, Company.reflect_on_association(:foo).primary_key_name
    Company.belongs_to :bar, :class_name =&gt; &quot;Xyzzy&quot;
    assert_equal &quot;bar_id&quot;, Company.reflect_on_association(:bar).primary_key_name
    Company.belongs_to :baz, :class_name =&gt; &quot;Xyzzy&quot;, :foreign_key =&gt; &quot;xyzzy_id&quot;
    assert_equal &quot;xyzzy_id&quot;, Company.reflect_on_association(:baz).primary_key_name
  end

  def test_association_reflection_in_modules
    assert_reflection MyApplication::Business::Firm,
      :clients_of_firm,
      :klass      =&gt; MyApplication::Business::Client,
      :class_name =&gt; 'Client',
      :table_name =&gt; 'companies'

    assert_reflection MyApplication::Billing::Account,
      :firm,
      :klass      =&gt; MyApplication::Business::Firm,
      :class_name =&gt; 'MyApplication::Business::Firm',
      :table_name =&gt; 'companies'

    assert_reflection MyApplication::Billing::Account,
      :qualified_billing_firm,
      :klass      =&gt; MyApplication::Billing::Firm,
      :class_name =&gt; 'MyApplication::Billing::Firm',
      :table_name =&gt; 'companies'

    assert_reflection MyApplication::Billing::Account,
      :unqualified_billing_firm,
      :klass      =&gt; MyApplication::Billing::Firm,
      :class_name =&gt; 'Firm',
      :table_name =&gt; 'companies'

    assert_reflection MyApplication::Billing::Account,
      :nested_qualified_billing_firm,
      :klass      =&gt; MyApplication::Billing::Nested::Firm,
      :class_name =&gt; 'MyApplication::Billing::Nested::Firm',
      :table_name =&gt; 'companies'

    assert_reflection MyApplication::Billing::Account,
      :nested_unqualified_billing_firm,
      :klass      =&gt; MyApplication::Billing::Nested::Firm,
      :class_name =&gt; 'Nested::Firm',
      :table_name =&gt; 'companies'
  end

  def test_reflection_of_all_associations
    # FIXME these assertions bust a lot
    assert_equal 36, Firm.reflect_on_all_associations.size
    assert_equal 26, Firm.reflect_on_all_associations(:has_many).size
    assert_equal 10, Firm.reflect_on_all_associations(:has_one).size
    assert_equal 0, Firm.reflect_on_all_associations(:belongs_to).size
  end

  def test_reflection_should_not_raise_error_when_compared_to_other_object
    assert_nothing_raised { Firm.reflections[:clients] == Object.new }
  end

  def test_has_many_through_reflection
    assert_kind_of ActiveRecord::Reflection::ThroughReflection, Subscriber.reflect_on_association(:books)
  end

  private
    def assert_reflection(klass, association, options)
      assert reflection = klass.reflect_on_association(association)
      options.each do |method, value|
        assert_equal(value, reflection.send(method))
      end
    end
end
</pre>
    </div>