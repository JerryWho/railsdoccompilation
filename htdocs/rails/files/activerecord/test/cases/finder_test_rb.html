  <div id="fileHeader">
    <h1>finder_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/test/cases/finder_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:53 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cases/helper&quot;
require 'models/post'
require 'models/author'
require 'models/categorization'
require 'models/comment'
require 'models/company'
require 'models/topic'
require 'models/reply'
require 'models/entrant'
require 'models/developer'
require 'models/customer'
require 'models/job'
require 'models/categorization'

class DynamicFinderMatchTest &lt; ActiveRecord::TestCase
  def test_find_no_match
    assert_nil ActiveRecord::DynamicFinderMatch.match(&quot;not_a_finder&quot;)
  end

  def test_find_by
    match = ActiveRecord::DynamicFinderMatch.match(&quot;find_by_age_and_sex_and_location&quot;)
    assert_not_nil match
    assert match.finder?
    assert_equal :first, match.finder
    assert_equal %w(age sex location), match.attribute_names
  end

  def find_by_bang
    match = ActiveRecord::DynamicFinderMatch.match(&quot;find_by_age_and_sex_and_location!&quot;)
    assert_not_nil match
    assert match.finder?
    assert match.bang?
    assert_equal :first, match.finder
    assert_equal %w(age sex location), match.attribute_names
  end

  def test_find_all_by
    match = ActiveRecord::DynamicFinderMatch.match(&quot;find_all_by_age_and_sex_and_location&quot;)
    assert_not_nil match
    assert match.finder?
    assert_equal :all, match.finder
    assert_equal %w(age sex location), match.attribute_names
  end

  def test_find_or_initialize_by
    match = ActiveRecord::DynamicFinderMatch.match(&quot;find_or_initialize_by_age_and_sex_and_location&quot;)
    assert_not_nil match
    assert !match.finder?
    assert match.instantiator?
    assert_equal :first, match.finder
    assert_equal :new, match.instantiator
    assert_equal %w(age sex location), match.attribute_names
  end

  def test_find_or_create_by
    match = ActiveRecord::DynamicFinderMatch.match(&quot;find_or_create_by_age_and_sex_and_location&quot;)
    assert_not_nil match
    assert !match.finder?
    assert match.instantiator?
    assert_equal :first, match.finder
    assert_equal :create, match.instantiator
    assert_equal %w(age sex location), match.attribute_names
  end
end

class FinderTest &lt; ActiveRecord::TestCase
  fixtures :companies, :topics, :entrants, :developers, :developers_projects, :posts, :comments, :accounts, :authors, :customers

  def test_find
    assert_equal(topics(:first).title, Topic.find(1).title)
  end

  # find should handle strings that come from URLs
  # (example: Category.find(params[:id]))
  def test_find_with_string
    assert_equal(Topic.find(1).title,Topic.find(&quot;1&quot;).title)
  end

  def test_exists
    assert Topic.exists?(1)
    assert Topic.exists?(&quot;1&quot;)
    assert Topic.exists?(:author_name =&gt; &quot;David&quot;)
    assert Topic.exists?(:author_name =&gt; &quot;Mary&quot;, :approved =&gt; true)
    assert Topic.exists?([&quot;parent_id = ?&quot;, 1])
    assert !Topic.exists?(45)

    begin
      assert !Topic.exists?(&quot;foo&quot;)
    rescue ActiveRecord::StatementInvalid
      # PostgreSQL complains about string comparison with integer field
    rescue Exception
      flunk
    end

    assert_raise(NoMethodError) { Topic.exists?([1,2]) }
  end

  def test_exists_returns_true_with_one_record_and_no_args
    assert Topic.exists?
  end

  def test_does_not_exist_with_empty_table_and_no_args_given
    Topic.delete_all
    assert !Topic.exists?
  end

  def test_exists_with_aggregate_having_three_mappings
    existing_address = customers(:david).address
    assert Customer.exists?(:address =&gt; existing_address)
  end

  def test_exists_with_aggregate_having_three_mappings_with_one_difference
    existing_address = customers(:david).address
    assert !Customer.exists?(:address =&gt;
      Address.new(existing_address.street, existing_address.city, existing_address.country + &quot;1&quot;))
    assert !Customer.exists?(:address =&gt;
      Address.new(existing_address.street, existing_address.city + &quot;1&quot;, existing_address.country))
    assert !Customer.exists?(:address =&gt;
      Address.new(existing_address.street + &quot;1&quot;, existing_address.city, existing_address.country))
  end

  def test_exists_with_scoped_include
    Developer.with_scope(:find =&gt; { :include =&gt; :projects, :order =&gt; &quot;projects.name&quot; }) do
      assert Developer.exists?
    end
  end

  def test_find_by_array_of_one_id
    assert_kind_of(Array, Topic.find([ 1 ]))
    assert_equal(1, Topic.find([ 1 ]).length)
  end

  def test_find_by_ids
    assert_equal 2, Topic.find(1, 2).size
    assert_equal topics(:second).title, Topic.find([2]).first.title
  end

  def test_find_by_ids_with_limit_and_offset
    assert_equal 2, Entrant.find([1,3,2], :limit =&gt; 2).size
    assert_equal 1, Entrant.find([1,3,2], :limit =&gt; 3, :offset =&gt; 2).size

    # Also test an edge case: If you have 11 results, and you set a
    #   limit of 3 and offset of 9, then you should find that there
    #   will be only 2 results, regardless of the limit.
    devs = Developer.find :all
    last_devs = Developer.find devs.map(&amp;:id), :limit =&gt; 3, :offset =&gt; 9
    assert_equal 2, last_devs.size
  end

  def test_find_an_empty_array
    assert_equal [], Topic.find([])
  end

  def test_find_by_ids_missing_one
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, 2, 45) }
  end

  def test_find_all_with_limit
    assert_equal(2, Entrant.find(:all, :limit =&gt; 2).size)
    assert_equal(0, Entrant.find(:all, :limit =&gt; 0).size)
  end

  def test_find_all_with_prepared_limit_and_offset
    entrants = Entrant.find(:all, :order =&gt; &quot;id ASC&quot;, :limit =&gt; 2, :offset =&gt; 1)

    assert_equal(2, entrants.size)
    assert_equal(entrants(:second).name, entrants.first.name)

    assert_equal 3, Entrant.count
    entrants = Entrant.find(:all, :order =&gt; &quot;id ASC&quot;, :limit =&gt; 2, :offset =&gt; 2)
    assert_equal(1, entrants.size)
    assert_equal(entrants(:third).name, entrants.first.name)
  end

  def test_find_all_with_limit_and_offset_and_multiple_order_clauses
    first_three_posts = Post.find :all, :order =&gt; 'author_id, id', :limit =&gt; 3, :offset =&gt; 0
    second_three_posts = Post.find :all, :order =&gt; ' author_id,id ', :limit =&gt; 3, :offset =&gt; 3
    last_posts = Post.find :all, :order =&gt; ' author_id, id  ', :limit =&gt; 3, :offset =&gt; 6

    assert_equal [[0,3],[1,1],[1,2]], first_three_posts.map { |p| [p.author_id, p.id] }
    assert_equal [[1,4],[1,5],[1,6]], second_three_posts.map { |p| [p.author_id, p.id] }
    assert_equal [[2,7]], last_posts.map { |p| [p.author_id, p.id] }
  end


  def test_find_with_group
    developers =  Developer.find(:all, :group =&gt; &quot;salary&quot;, :select =&gt; &quot;salary&quot;)
    assert_equal 4, developers.size
    assert_equal 4, developers.map(&amp;:salary).uniq.size
  end

  def test_find_with_group_and_having
    developers =  Developer.find(:all, :group =&gt; &quot;salary&quot;, :having =&gt; &quot;sum(salary) &gt;  10000&quot;, :select =&gt; &quot;salary&quot;)
    assert_equal 3, developers.size
    assert_equal 3, developers.map(&amp;:salary).uniq.size
    assert developers.all? { |developer|  developer.salary &gt; 10000 }
  end

  def test_find_with_group_and_sanitized_having
    developers =  Developer.find(:all, :group =&gt; &quot;salary&quot;, :having =&gt; [&quot;sum(salary) &gt; ?&quot;, 10000], :select =&gt; &quot;salary&quot;)
    assert_equal 3, developers.size
    assert_equal 3, developers.map(&amp;:salary).uniq.size
    assert developers.all? { |developer|  developer.salary &gt; 10000 }
  end

  def test_find_with_entire_select_statement
    topics = Topic.find_by_sql &quot;SELECT * FROM topics WHERE author_name = 'Mary'&quot;

    assert_equal(1, topics.size)
    assert_equal(topics(:second).title, topics.first.title)
  end

  def test_find_with_prepared_select_statement
    topics = Topic.find_by_sql [&quot;SELECT * FROM topics WHERE author_name = ?&quot;, &quot;Mary&quot;]

    assert_equal(1, topics.size)
    assert_equal(topics(:second).title, topics.first.title)
  end

  def test_find_by_sql_with_sti_on_joined_table
    accounts = Account.find_by_sql(&quot;SELECT * FROM accounts INNER JOIN companies ON companies.id = accounts.firm_id&quot;)
    assert_equal [Account], accounts.collect(&amp;:class).uniq
  end

  def test_find_first
    first = Topic.find(:first, :conditions =&gt; &quot;title = 'The First Topic'&quot;)
    assert_equal(topics(:first).title, first.title)
  end

  def test_find_first_failing
    first = Topic.find(:first, :conditions =&gt; &quot;title = 'The First Topic!'&quot;)
    assert_nil(first)
  end

  def test_first
    assert_equal topics(:second).title, Topic.first(:conditions =&gt; &quot;title = 'The Second Topic of the day'&quot;).title
  end

  def test_first_failing
    assert_nil Topic.first(:conditions =&gt; &quot;title = 'The Second Topic of the day!'&quot;)
  end

  def test_unexisting_record_exception_handling
    assert_raise(ActiveRecord::RecordNotFound) {
      Topic.find(1).parent
    }

    Topic.find(2).topic
  end

  def test_find_only_some_columns
    topic = Topic.find(1, :select =&gt; &quot;author_name&quot;)
    assert_raise(ActiveRecord::MissingAttributeError) {topic.title}
    assert_equal &quot;David&quot;, topic.author_name
    assert !topic.attribute_present?(&quot;title&quot;)
    #assert !topic.respond_to?(&quot;title&quot;)
    assert topic.attribute_present?(&quot;author_name&quot;)
    assert topic.respond_to?(&quot;author_name&quot;)
  end

  def test_find_on_blank_conditions
    [nil, &quot; &quot;, [], {}].each do |blank|
      assert_nothing_raised { Topic.find(:first, :conditions =&gt; blank) }
    end
  end

  def test_find_on_blank_bind_conditions
    [ [&quot;&quot;], [&quot;&quot;,{}] ].each do |blank|
      assert_nothing_raised { Topic.find(:first, :conditions =&gt; blank) }
    end
  end

  def test_find_on_array_conditions
    assert Topic.find(1, :conditions =&gt; [&quot;approved = ?&quot;, false])
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; [&quot;approved = ?&quot;, true]) }
  end

  def test_find_on_hash_conditions
    assert Topic.find(1, :conditions =&gt; { :approved =&gt; false })
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; { :approved =&gt; true }) }
  end

  def test_find_on_hash_conditions_with_explicit_table_name
    assert Topic.find(1, :conditions =&gt; { 'topics.approved' =&gt; false })
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; { 'topics.approved' =&gt; true }) }
  end

  def test_find_on_hash_conditions_with_hashed_table_name
    assert Topic.find(1, :conditions =&gt; {:topics =&gt; { :approved =&gt; false }})
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; {:topics =&gt; { :approved =&gt; true }}) }
  end

  def test_find_with_hash_conditions_on_joined_table
    firms = Firm.all :joins =&gt; :account, :conditions =&gt; {:accounts =&gt; { :credit_limit =&gt; 50 }}
    assert_equal 1, firms.size
    assert_equal companies(:first_firm), firms.first
  end

  def test_find_with_hash_conditions_on_joined_table_and_with_range
    firms = DependentFirm.all :joins =&gt; :account, :conditions =&gt; {:name =&gt; 'RailsCore', :accounts =&gt; { :credit_limit =&gt; 55..60 }}
    assert_equal 1, firms.size
    assert_equal companies(:rails_core), firms.first
  end

  def test_find_on_hash_conditions_with_explicit_table_name_and_aggregate
    david = customers(:david)
    assert Customer.find(david.id, :conditions =&gt; { 'customers.name' =&gt; david.name, :address =&gt; david.address })
    assert_raise(ActiveRecord::RecordNotFound) {
      Customer.find(david.id, :conditions =&gt; { 'customers.name' =&gt; david.name + &quot;1&quot;, :address =&gt; david.address })
    }
  end

  def test_find_on_association_proxy_conditions
    assert_equal [1, 2, 3, 5, 6, 7, 8, 9, 10], Comment.find_all_by_post_id(authors(:david).posts).map(&amp;:id).sort
  end

  def test_find_on_hash_conditions_with_range
    assert_equal [1,2], Topic.find(:all, :conditions =&gt; { :id =&gt; 1..2 }).map(&amp;:id).sort
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; { :id =&gt; 2..3 }) }
  end

  def test_find_on_hash_conditions_with_end_exclusive_range
    assert_equal [1,2,3], Topic.find(:all, :conditions =&gt; { :id =&gt; 1..3 }).map(&amp;:id).sort
    assert_equal [1,2], Topic.find(:all, :conditions =&gt; { :id =&gt; 1...3 }).map(&amp;:id).sort
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(3, :conditions =&gt; { :id =&gt; 2...3 }) }
  end

  def test_find_on_hash_conditions_with_multiple_ranges
    assert_equal [1,2,3], Comment.find(:all, :conditions =&gt; { :id =&gt; 1..3, :post_id =&gt; 1..2 }).map(&amp;:id).sort
    assert_equal [1], Comment.find(:all, :conditions =&gt; { :id =&gt; 1..1, :post_id =&gt; 1..10 }).map(&amp;:id).sort
  end

  def test_find_on_multiple_hash_conditions
    assert Topic.find(1, :conditions =&gt; { :author_name =&gt; &quot;David&quot;, :title =&gt; &quot;The First Topic&quot;, :replies_count =&gt; 1, :approved =&gt; false })
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; { :author_name =&gt; &quot;David&quot;, :title =&gt; &quot;The First Topic&quot;, :replies_count =&gt; 1, :approved =&gt; true }) }
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; { :author_name =&gt; &quot;David&quot;, :title =&gt; &quot;HHC&quot;, :replies_count =&gt; 1, :approved =&gt; false }) }
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find(1, :conditions =&gt; { :author_name =&gt; &quot;David&quot;, :title =&gt; &quot;The First Topic&quot;, :replies_count =&gt; 1, :approved =&gt; true }) }
  end

  def test_condition_interpolation
    assert_kind_of Firm, Company.find(:first, :conditions =&gt; [&quot;name = '%s'&quot;, &quot;37signals&quot;])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = '%s'&quot;, &quot;37signals!&quot;])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = '%s'&quot;, &quot;37signals!' OR 1=1&quot;])
    assert_kind_of Time, Topic.find(:first, :conditions =&gt; [&quot;id = %d&quot;, 1]).written_on
  end

  def test_condition_array_interpolation
    assert_kind_of Firm, Company.find(:first, :conditions =&gt; [&quot;name = '%s'&quot;, &quot;37signals&quot;])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = '%s'&quot;, &quot;37signals!&quot;])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = '%s'&quot;, &quot;37signals!' OR 1=1&quot;])
    assert_kind_of Time, Topic.find(:first, :conditions =&gt; [&quot;id = %d&quot;, 1]).written_on
  end

  def test_condition_hash_interpolation
    assert_kind_of Firm, Company.find(:first, :conditions =&gt; { :name =&gt; &quot;37signals&quot;})
    assert_nil Company.find(:first, :conditions =&gt; { :name =&gt; &quot;37signals!&quot;})
    assert_kind_of Time, Topic.find(:first, :conditions =&gt; {:id =&gt; 1}).written_on
  end

  def test_hash_condition_find_malformed
    assert_raise(ActiveRecord::StatementInvalid) {
      Company.find(:first, :conditions =&gt; { :id =&gt; 2, :dhh =&gt; true })
    }
  end

  def test_hash_condition_find_with_escaped_characters
    Company.create(&quot;name&quot; =&gt; &quot;Ain't noth'n like' \#stuff&quot;)
    assert Company.find(:first, :conditions =&gt; { :name =&gt; &quot;Ain't noth'n like' \#stuff&quot; })
  end

  def test_hash_condition_find_with_array
    p1, p2 = Post.find(:all, :limit =&gt; 2, :order =&gt; 'id asc')
    assert_equal [p1, p2], Post.find(:all, :conditions =&gt; { :id =&gt; [p1, p2] }, :order =&gt; 'id asc')
    assert_equal [p1, p2], Post.find(:all, :conditions =&gt; { :id =&gt; [p1, p2.id] }, :order =&gt; 'id asc')
  end

  def test_hash_condition_find_with_nil
    topic = Topic.find(:first, :conditions =&gt; { :last_read =&gt; nil } )
    assert_not_nil topic
    assert_nil topic.last_read
  end

  def test_hash_condition_find_with_aggregate_having_one_mapping
    balance = customers(:david).balance
    assert_kind_of Money, balance
    found_customer = Customer.find(:first, :conditions =&gt; {:balance =&gt; balance})
    assert_equal customers(:david), found_customer
  end

  def test_hash_condition_find_with_aggregate_attribute_having_same_name_as_field_and_key_value_being_aggregate
    gps_location = customers(:david).gps_location
    assert_kind_of GpsLocation, gps_location
    found_customer = Customer.find(:first, :conditions =&gt; {:gps_location =&gt; gps_location})
    assert_equal customers(:david), found_customer
  end

  def test_hash_condition_find_with_aggregate_having_one_mapping_and_key_value_being_attribute_value
    balance = customers(:david).balance
    assert_kind_of Money, balance
    found_customer = Customer.find(:first, :conditions =&gt; {:balance =&gt; balance.amount})
    assert_equal customers(:david), found_customer
  end

  def test_hash_condition_find_with_aggregate_attribute_having_same_name_as_field_and_key_value_being_attribute_value
    gps_location = customers(:david).gps_location
    assert_kind_of GpsLocation, gps_location
    found_customer = Customer.find(:first, :conditions =&gt; {:gps_location =&gt; gps_location.gps_location})
    assert_equal customers(:david), found_customer
  end

  def test_hash_condition_find_with_aggregate_having_three_mappings
    address = customers(:david).address
    assert_kind_of Address, address
    found_customer = Customer.find(:first, :conditions =&gt; {:address =&gt; address})
    assert_equal customers(:david), found_customer
  end

  def test_hash_condition_find_with_one_condition_being_aggregate_and_another_not
    address = customers(:david).address
    assert_kind_of Address, address
    found_customer = Customer.find(:first, :conditions =&gt; {:address =&gt; address, :name =&gt; customers(:david).name})
    assert_equal customers(:david), found_customer
  end

  def test_bind_variables
    assert_kind_of Firm, Company.find(:first, :conditions =&gt; [&quot;name = ?&quot;, &quot;37signals&quot;])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = ?&quot;, &quot;37signals!&quot;])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = ?&quot;, &quot;37signals!' OR 1=1&quot;])
    assert_kind_of Time, Topic.find(:first, :conditions =&gt; [&quot;id = ?&quot;, 1]).written_on
    assert_raise(ActiveRecord::PreparedStatementInvalid) {
      Company.find(:first, :conditions =&gt; [&quot;id=? AND name = ?&quot;, 2])
    }
    assert_raise(ActiveRecord::PreparedStatementInvalid) {
     Company.find(:first, :conditions =&gt; [&quot;id=?&quot;, 2, 3, 4])
    }
  end

  def test_bind_variables_with_quotes
    Company.create(&quot;name&quot; =&gt; &quot;37signals' go'es agains&quot;)
    assert Company.find(:first, :conditions =&gt; [&quot;name = ?&quot;, &quot;37signals' go'es agains&quot;])
  end

  def test_named_bind_variables_with_quotes
    Company.create(&quot;name&quot; =&gt; &quot;37signals' go'es agains&quot;)
    assert Company.find(:first, :conditions =&gt; [&quot;name = :name&quot;, {:name =&gt; &quot;37signals' go'es agains&quot;}])
  end

  def test_bind_arity
    assert_nothing_raised                                 { bind '' }
    assert_raise(ActiveRecord::PreparedStatementInvalid) { bind '', 1 }

    assert_raise(ActiveRecord::PreparedStatementInvalid) { bind '?' }
    assert_nothing_raised                                 { bind '?', 1 }
    assert_raise(ActiveRecord::PreparedStatementInvalid) { bind '?', 1, 1  }
  end

  def test_named_bind_variables
    assert_equal '1', bind(':a', :a =&gt; 1) # ' ruby-mode
    assert_equal '1 1', bind(':a :a', :a =&gt; 1)  # ' ruby-mode

    assert_nothing_raised { bind(&quot;'+00:00'&quot;, :foo =&gt; &quot;bar&quot;) }

    assert_kind_of Firm, Company.find(:first, :conditions =&gt; [&quot;name = :name&quot;, { :name =&gt; &quot;37signals&quot; }])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = :name&quot;, { :name =&gt; &quot;37signals!&quot; }])
    assert_nil Company.find(:first, :conditions =&gt; [&quot;name = :name&quot;, { :name =&gt; &quot;37signals!' OR 1=1&quot; }])
    assert_kind_of Time, Topic.find(:first, :conditions =&gt; [&quot;id = :id&quot;, { :id =&gt; 1 }]).written_on
  end

  def test_bind_enumerable
    quoted_abc = %(#{ActiveRecord::Base.connection.quote('a')},#{ActiveRecord::Base.connection.quote('b')},#{ActiveRecord::Base.connection.quote('c')})

    assert_equal '1,2,3', bind('?', [1, 2, 3])
    assert_equal quoted_abc, bind('?', %w(a b c))

    assert_equal '1,2,3', bind(':a', :a =&gt; [1, 2, 3])
    assert_equal quoted_abc, bind(':a', :a =&gt; %w(a b c)) # '

    require 'set'
    assert_equal '1,2,3', bind('?', Set.new([1, 2, 3]))
    assert_equal quoted_abc, bind('?', Set.new(%w(a b c)))

    assert_equal '1,2,3', bind(':a', :a =&gt; Set.new([1, 2, 3]))
    assert_equal quoted_abc, bind(':a', :a =&gt; Set.new(%w(a b c))) # '
  end

  def test_bind_empty_enumerable
    quoted_nil = ActiveRecord::Base.connection.quote(nil)
    assert_equal quoted_nil, bind('?', [])
    assert_equal &quot; in (#{quoted_nil})&quot;, bind(' in (?)', [])
    assert_equal &quot;foo in (#{quoted_nil})&quot;, bind('foo in (?)', [])
  end

  def test_bind_string
    assert_equal ActiveRecord::Base.connection.quote(''), bind('?', '')
  end

  def test_bind_chars
    quoted_bambi = ActiveRecord::Base.connection.quote(&quot;Bambi&quot;)
    quoted_bambi_and_thumper = ActiveRecord::Base.connection.quote(&quot;Bambi\nand\nThumper&quot;)
    assert_equal &quot;name=#{quoted_bambi}&quot;, bind('name=?', &quot;Bambi&quot;)
    assert_equal &quot;name=#{quoted_bambi_and_thumper}&quot;, bind('name=?', &quot;Bambi\nand\nThumper&quot;)
    assert_equal &quot;name=#{quoted_bambi}&quot;, bind('name=?', &quot;Bambi&quot;.mb_chars)
    assert_equal &quot;name=#{quoted_bambi_and_thumper}&quot;, bind('name=?', &quot;Bambi\nand\nThumper&quot;.mb_chars)
  end

  def test_bind_record
    o = Struct.new(:quoted_id).new(1)
    assert_equal '1', bind('?', o)

    os = [o] * 3
    assert_equal '1,1,1', bind('?', os)
  end

  def test_named_bind_with_postgresql_type_casts
    l = Proc.new { bind(&quot;:a::integer '2009-01-01'::date&quot;, :a =&gt; '10') }
    assert_nothing_raised(&amp;l)
    assert_equal &quot;#{ActiveRecord::Base.quote_value('10')}::integer '2009-01-01'::date&quot;, l.call
  end

  def test_string_sanitation
    assert_not_equal &quot;'something ' 1=1'&quot;, ActiveRecord::Base.sanitize(&quot;something ' 1=1&quot;)
    assert_equal &quot;'something; select table'&quot;, ActiveRecord::Base.sanitize(&quot;something; select table&quot;)
  end

  def test_count
    assert_equal(0, Entrant.count(:conditions =&gt; &quot;id &gt; 3&quot;))
    assert_equal(1, Entrant.count(:conditions =&gt; [&quot;id &gt; ?&quot;, 2]))
    assert_equal(2, Entrant.count(:conditions =&gt; [&quot;id &gt; ?&quot;, 1]))
  end

  def test_count_by_sql
    assert_equal(0, Entrant.count_by_sql(&quot;SELECT COUNT(*) FROM entrants WHERE id &gt; 3&quot;))
    assert_equal(1, Entrant.count_by_sql([&quot;SELECT COUNT(*) FROM entrants WHERE id &gt; ?&quot;, 2]))
    assert_equal(2, Entrant.count_by_sql([&quot;SELECT COUNT(*) FROM entrants WHERE id &gt; ?&quot;, 1]))
  end

  def test_dynamic_finders_should_go_through_the_find_class_method
    Topic.expects(:find).with(:first, :conditions =&gt; { :title =&gt; 'The First Topic!' })
    Topic.find_by_title(&quot;The First Topic!&quot;)

    Topic.expects(:find).with(:last, :conditions =&gt; { :title =&gt; 'The Last Topic!' })
    Topic.find_last_by_title(&quot;The Last Topic!&quot;)

    Topic.expects(:find).with(:all, :conditions =&gt; { :title =&gt; 'A Topic.' })
    Topic.find_all_by_title(&quot;A Topic.&quot;)

    Topic.expects(:find).with(:first, :conditions =&gt; { :title =&gt; 'Does not exist yet for sure!' }).times(2)
    Topic.find_or_initialize_by_title('Does not exist yet for sure!')
    Topic.find_or_create_by_title('Does not exist yet for sure!')
  end

  def test_find_by_one_attribute
    assert_equal topics(:first), Topic.find_by_title(&quot;The First Topic&quot;)
    assert_nil Topic.find_by_title(&quot;The First Topic!&quot;)
  end

  def test_find_by_one_attribute_bang
    assert_equal topics(:first), Topic.find_by_title!(&quot;The First Topic&quot;)
    assert_raise(ActiveRecord::RecordNotFound) { Topic.find_by_title!(&quot;The First Topic!&quot;) }
  end

  def test_find_by_one_attribute_caches_dynamic_finder
    # ensure this test can run independently of order
    class &lt;&lt; Topic; self; end.send(:remove_method, :find_by_title) if Topic.public_methods.any? { |m| m.to_s == 'find_by_title' }
    assert !Topic.public_methods.any? { |m| m.to_s == 'find_by_title' }
    t = Topic.find_by_title(&quot;The First Topic&quot;)
    assert Topic.public_methods.any? { |m| m.to_s == 'find_by_title' }
  end

  def test_dynamic_finder_returns_same_results_after_caching
    # ensure this test can run independently of order
    class &lt;&lt; Topic; self; end.send(:remove_method, :find_by_title) if Topic.public_method_defined?(:find_by_title)
    t = Topic.find_by_title(&quot;The First Topic&quot;)
    assert_equal t, Topic.find_by_title(&quot;The First Topic&quot;) # find_by_title has been cached
  end

  def test_find_by_one_attribute_with_order_option
    assert_equal accounts(:signals37), Account.find_by_credit_limit(50, :order =&gt; 'id')
    assert_equal accounts(:rails_core_account), Account.find_by_credit_limit(50, :order =&gt; 'id DESC')
  end

  def test_find_by_one_attribute_with_conditions
    assert_equal accounts(:rails_core_account), Account.find_by_credit_limit(50, :conditions =&gt; ['firm_id = ?', 6])
  end

  def test_find_by_one_attribute_that_is_an_aggregate
    address = customers(:david).address
    assert_kind_of Address, address
    found_customer = Customer.find_by_address(address)
    assert_equal customers(:david), found_customer
  end

  def test_find_by_one_attribute_that_is_an_aggregate_with_one_attribute_difference
    address = customers(:david).address
    assert_kind_of Address, address
    missing_address = Address.new(address.street, address.city, address.country + &quot;1&quot;)
    assert_nil Customer.find_by_address(missing_address)
    missing_address = Address.new(address.street, address.city + &quot;1&quot;, address.country)
    assert_nil Customer.find_by_address(missing_address)
    missing_address = Address.new(address.street + &quot;1&quot;, address.city, address.country)
    assert_nil Customer.find_by_address(missing_address)
  end

  def test_find_by_two_attributes_that_are_both_aggregates
    balance = customers(:david).balance
    address = customers(:david).address
    assert_kind_of Money, balance
    assert_kind_of Address, address
    found_customer = Customer.find_by_balance_and_address(balance, address)
    assert_equal customers(:david), found_customer
  end

  def test_find_by_two_attributes_with_one_being_an_aggregate
    balance = customers(:david).balance
    assert_kind_of Money, balance
    found_customer = Customer.find_by_balance_and_name(balance, customers(:david).name)
    assert_equal customers(:david), found_customer
  end

  def test_dynamic_finder_on_one_attribute_with_conditions_caches_method
    # ensure this test can run independently of order
    class &lt;&lt; Account; self; end.send(:remove_method, :find_by_credit_limit) if Account.public_methods.any? { |m| m.to_s == 'find_by_credit_limit' }
    assert !Account.public_methods.any? { |m| m.to_s == 'find_by_credit_limit' }
    a = Account.find_by_credit_limit(50, :conditions =&gt; ['firm_id = ?', 6])
    assert Account.public_methods.any? { |m| m.to_s == 'find_by_credit_limit' }
  end

  def test_dynamic_finder_on_one_attribute_with_conditions_returns_same_results_after_caching
    # ensure this test can run independently of order
    class &lt;&lt; Account; self; end.send(:remove_method, :find_by_credit_limit) if Account.public_methods.any? { |m| m.to_s == 'find_by_credit_limit' }
    a = Account.find_by_credit_limit(50, :conditions =&gt; ['firm_id = ?', 6])
    assert_equal a, Account.find_by_credit_limit(50, :conditions =&gt; ['firm_id = ?', 6]) # find_by_credit_limit has been cached
  end

  def test_find_by_one_attribute_with_several_options
    assert_equal accounts(:unknown), Account.find_by_credit_limit(50, :order =&gt; 'id DESC', :conditions =&gt; ['id != ?', 3])
  end

  def test_find_by_one_missing_attribute
    assert_raise(NoMethodError) { Topic.find_by_undertitle(&quot;The First Topic!&quot;) }
  end

  def test_find_by_invalid_method_syntax
    assert_raise(NoMethodError) { Topic.fail_to_find_by_title(&quot;The First Topic&quot;) }
    assert_raise(NoMethodError) { Topic.find_by_title?(&quot;The First Topic&quot;) }
    assert_raise(NoMethodError) { Topic.fail_to_find_or_create_by_title(&quot;Nonexistent Title&quot;) }
    assert_raise(NoMethodError) { Topic.find_or_create_by_title?(&quot;Nonexistent Title&quot;) }
  end

  def test_find_by_two_attributes
    assert_equal topics(:first), Topic.find_by_title_and_author_name(&quot;The First Topic&quot;, &quot;David&quot;)
    assert_nil Topic.find_by_title_and_author_name(&quot;The First Topic&quot;, &quot;Mary&quot;)
  end

  def test_find_last_by_one_attribute
    assert_equal Topic.last, Topic.find_last_by_title(Topic.last.title)
    assert_nil Topic.find_last_by_title(&quot;A title with no matches&quot;)
  end

  def test_find_last_by_one_attribute_caches_dynamic_finder
    # ensure this test can run independently of order
    class &lt;&lt; Topic; self; end.send(:remove_method, :find_last_by_title) if Topic.public_methods.any? { |m| m.to_s == 'find_last_by_title' }
    assert !Topic.public_methods.any? { |m| m.to_s == 'find_last_by_title' }
    t = Topic.find_last_by_title(Topic.last.title)
    assert Topic.public_methods.any? { |m| m.to_s == 'find_last_by_title' }
  end

  def test_find_last_by_invalid_method_syntax
    assert_raise(NoMethodError) { Topic.fail_to_find_last_by_title(&quot;The First Topic&quot;) }
    assert_raise(NoMethodError) { Topic.find_last_by_title?(&quot;The First Topic&quot;) }
  end

  def test_find_last_by_one_attribute_with_several_options
    assert_equal accounts(:signals37), Account.find_last_by_credit_limit(50, :order =&gt; 'id DESC', :conditions =&gt; ['id != ?', 3])
  end

  def test_find_last_by_one_missing_attribute
    assert_raise(NoMethodError) { Topic.find_last_by_undertitle(&quot;The Last Topic!&quot;) }
  end

  def test_find_last_by_two_attributes
    topic = Topic.last
    assert_equal topic, Topic.find_last_by_title_and_author_name(topic.title, topic.author_name)
    assert_nil Topic.find_last_by_title_and_author_name(topic.title, &quot;Anonymous&quot;)
  end

  def test_find_all_by_one_attribute
    topics = Topic.find_all_by_content(&quot;Have a nice day&quot;)
    assert_equal 2, topics.size
    assert topics.include?(topics(:first))

    assert_equal [], Topic.find_all_by_title(&quot;The First Topic!!&quot;)
  end

  def test_find_all_by_one_attribute_that_is_an_aggregate
    balance = customers(:david).balance
    assert_kind_of Money, balance
    found_customers = Customer.find_all_by_balance(balance)
    assert_equal 1, found_customers.size
    assert_equal customers(:david), found_customers.first
  end

  def test_find_all_by_two_attributes_that_are_both_aggregates
    balance = customers(:david).balance
    address = customers(:david).address
    assert_kind_of Money, balance
    assert_kind_of Address, address
    found_customers = Customer.find_all_by_balance_and_address(balance, address)
    assert_equal 1, found_customers.size
    assert_equal customers(:david), found_customers.first
  end

  def test_find_all_by_two_attributes_with_one_being_an_aggregate
    balance = customers(:david).balance
    assert_kind_of Money, balance
    found_customers = Customer.find_all_by_balance_and_name(balance, customers(:david).name)
    assert_equal 1, found_customers.size
    assert_equal customers(:david), found_customers.first
  end

  def test_find_all_by_one_attribute_with_options
    topics = Topic.find_all_by_content(&quot;Have a nice day&quot;, :order =&gt; &quot;id DESC&quot;)
    assert topics(:first), topics.last

    topics = Topic.find_all_by_content(&quot;Have a nice day&quot;, :order =&gt; &quot;id&quot;)
    assert topics(:first), topics.first
  end

  def test_find_all_by_array_attribute
    assert_equal 2, Topic.find_all_by_title([&quot;The First Topic&quot;, &quot;The Second Topic of the day&quot;]).size
  end

  def test_find_all_by_boolean_attribute
    topics = Topic.find_all_by_approved(false)
    assert_equal 1, topics.size
    assert topics.include?(topics(:first))

    topics = Topic.find_all_by_approved(true)
    assert_equal 3, topics.size
    assert topics.include?(topics(:second))
  end

  def test_find_by_nil_attribute
    topic = Topic.find_by_last_read nil
    assert_not_nil topic
    assert_nil topic.last_read
  end

  def test_find_all_by_nil_attribute
    topics = Topic.find_all_by_last_read nil
    assert_equal 3, topics.size
    assert topics.collect(&amp;:last_read).all?(&amp;:nil?)
  end

  def test_find_by_nil_and_not_nil_attributes
    topic = Topic.find_by_last_read_and_author_name nil, &quot;Mary&quot;
    assert_equal &quot;Mary&quot;, topic.author_name
  end

  def test_find_all_by_nil_and_not_nil_attributes
    topics = Topic.find_all_by_last_read_and_author_name nil, &quot;Mary&quot;
    assert_equal 1, topics.size
    assert_equal &quot;Mary&quot;, topics[0].author_name
  end

  def test_find_or_create_from_one_attribute
    number_of_companies = Company.count
    sig38 = Company.find_or_create_by_name(&quot;38signals&quot;)
    assert_equal number_of_companies + 1, Company.count
    assert_equal sig38, Company.find_or_create_by_name(&quot;38signals&quot;)
    assert !sig38.new_record?
  end

  def test_find_or_create_from_two_attributes
    number_of_topics = Topic.count
    another = Topic.find_or_create_by_title_and_author_name(&quot;Another topic&quot;,&quot;John&quot;)
    assert_equal number_of_topics + 1, Topic.count
    assert_equal another, Topic.find_or_create_by_title_and_author_name(&quot;Another topic&quot;, &quot;John&quot;)
    assert !another.new_record?
  end

  def test_find_or_create_from_two_attributes_with_one_being_an_aggregate
    number_of_customers = Customer.count
    created_customer = Customer.find_or_create_by_balance_and_name(Money.new(123), &quot;Elizabeth&quot;)
    assert_equal number_of_customers + 1, Customer.count
    assert_equal created_customer, Customer.find_or_create_by_balance(Money.new(123), &quot;Elizabeth&quot;)
    assert !created_customer.new_record?
  end

  def test_find_or_create_from_one_attribute_and_hash
    number_of_companies = Company.count
    sig38 = Company.find_or_create_by_name({:name =&gt; &quot;38signals&quot;, :firm_id =&gt; 17, :client_of =&gt; 23})
    assert_equal number_of_companies + 1, Company.count
    assert_equal sig38, Company.find_or_create_by_name({:name =&gt; &quot;38signals&quot;, :firm_id =&gt; 17, :client_of =&gt; 23})
    assert !sig38.new_record?
    assert_equal &quot;38signals&quot;, sig38.name
    assert_equal 17, sig38.firm_id
    assert_equal 23, sig38.client_of
  end

  def test_find_or_create_from_one_aggregate_attribute
    number_of_customers = Customer.count
    created_customer = Customer.find_or_create_by_balance(Money.new(123))
    assert_equal number_of_customers + 1, Customer.count
    assert_equal created_customer, Customer.find_or_create_by_balance(Money.new(123))
    assert !created_customer.new_record?
  end

  def test_find_or_create_from_one_aggregate_attribute_and_hash
    number_of_customers = Customer.count
    balance = Money.new(123)
    name = &quot;Elizabeth&quot;
    created_customer = Customer.find_or_create_by_balance({:balance =&gt; balance, :name =&gt; name})
    assert_equal number_of_customers + 1, Customer.count
    assert_equal created_customer, Customer.find_or_create_by_balance({:balance =&gt; balance, :name =&gt; name})
    assert !created_customer.new_record?
    assert_equal balance, created_customer.balance
    assert_equal name, created_customer.name
  end

  def test_find_or_initialize_from_one_attribute
    sig38 = Company.find_or_initialize_by_name(&quot;38signals&quot;)
    assert_equal &quot;38signals&quot;, sig38.name
    assert sig38.new_record?
  end

  def test_find_or_initialize_from_one_aggregate_attribute
    new_customer = Customer.find_or_initialize_by_balance(Money.new(123))
    assert_equal 123, new_customer.balance.amount
    assert new_customer.new_record?
  end

  def test_find_or_initialize_from_one_attribute_should_not_set_attribute_even_when_protected
    c = Company.find_or_initialize_by_name({:name =&gt; &quot;Fortune 1000&quot;, :rating =&gt; 1000})
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_not_equal 1000, c.rating
    assert c.valid?
    assert c.new_record?
  end

  def test_find_or_create_from_one_attribute_should_not_set_attribute_even_when_protected
    c = Company.find_or_create_by_name({:name =&gt; &quot;Fortune 1000&quot;, :rating =&gt; 1000})
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_not_equal 1000, c.rating
    assert c.valid?
    assert !c.new_record?
  end

  def test_find_or_initialize_from_one_attribute_should_set_attribute_even_when_protected_and_also_set_the_hash
    c = Company.find_or_initialize_by_rating(1000, {:name =&gt; &quot;Fortune 1000&quot;})
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_equal 1000, c.rating
    assert c.valid?
    assert c.new_record?
  end

  def test_find_or_create_from_one_attribute_should_set_attribute_even_when_protected_and_also_set_the_hash
    c = Company.find_or_create_by_rating(1000, {:name =&gt; &quot;Fortune 1000&quot;})
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_equal 1000, c.rating
    assert c.valid?
    assert !c.new_record?
  end

  def test_find_or_initialize_from_one_attribute_should_set_attribute_even_when_protected
    c = Company.find_or_initialize_by_name_and_rating(&quot;Fortune 1000&quot;, 1000)
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_equal 1000, c.rating
    assert c.valid?
    assert c.new_record?
  end

  def test_find_or_create_from_one_attribute_should_set_attribute_even_when_protected
    c = Company.find_or_create_by_name_and_rating(&quot;Fortune 1000&quot;, 1000)
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_equal 1000, c.rating
    assert c.valid?
    assert !c.new_record?
  end

  def test_find_or_initialize_should_set_protected_attributes_if_given_as_block
    c = Company.find_or_initialize_by_name(:name =&gt; &quot;Fortune 1000&quot;) { |f| f.rating = 1000 }
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_equal 1000.to_f, c.rating.to_f
    assert c.valid?
    assert c.new_record?
  end

  def test_find_or_create_should_set_protected_attributes_if_given_as_block
    c = Company.find_or_create_by_name(:name =&gt; &quot;Fortune 1000&quot;) { |f| f.rating = 1000 }
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_equal 1000.to_f, c.rating.to_f
    assert c.valid?
    assert !c.new_record?
  end

  def test_find_or_create_should_work_with_block_on_first_call
	  class &lt;&lt; Company
		undef_method(:find_or_create_by_name) if method_defined?(:find_or_create_by_name)
	  end
    c = Company.find_or_create_by_name(:name =&gt; &quot;Fortune 1000&quot;) { |f| f.rating = 1000 }
    assert_equal &quot;Fortune 1000&quot;, c.name
    assert_equal 1000.to_f, c.rating.to_f
    assert c.valid?
    assert !c.new_record?
  end

  def test_dynamic_find_or_initialize_from_one_attribute_caches_method
    class &lt;&lt; Company; self; end.send(:remove_method, :find_or_initialize_by_name) if Company.public_methods.any? { |m| m.to_s == 'find_or_initialize_by_name' }
    assert !Company.public_methods.any? { |m| m.to_s == 'find_or_initialize_by_name' }
    sig38 = Company.find_or_initialize_by_name(&quot;38signals&quot;)
    assert Company.public_methods.any? { |m| m.to_s == 'find_or_initialize_by_name' }
  end

  def test_find_or_initialize_from_two_attributes
    another = Topic.find_or_initialize_by_title_and_author_name(&quot;Another topic&quot;,&quot;John&quot;)
    assert_equal &quot;Another topic&quot;, another.title
    assert_equal &quot;John&quot;, another.author_name
    assert another.new_record?
  end

  def test_find_or_initialize_from_one_aggregate_attribute_and_one_not
    new_customer = Customer.find_or_initialize_by_balance_and_name(Money.new(123), &quot;Elizabeth&quot;)
    assert_equal 123, new_customer.balance.amount
    assert_equal &quot;Elizabeth&quot;, new_customer.name
    assert new_customer.new_record?
  end

  def test_find_or_initialize_from_one_attribute_and_hash
    sig38 = Company.find_or_initialize_by_name({:name =&gt; &quot;38signals&quot;, :firm_id =&gt; 17, :client_of =&gt; 23})
    assert_equal &quot;38signals&quot;, sig38.name
    assert_equal 17, sig38.firm_id
    assert_equal 23, sig38.client_of
    assert sig38.new_record?
  end

  def test_find_or_initialize_from_one_aggregate_attribute_and_hash
    balance = Money.new(123)
    name = &quot;Elizabeth&quot;
    new_customer = Customer.find_or_initialize_by_balance({:balance =&gt; balance, :name =&gt; name})
    assert_equal balance, new_customer.balance
    assert_equal name, new_customer.name
    assert new_customer.new_record?
  end

  def test_find_with_bad_sql
    assert_raise(ActiveRecord::StatementInvalid) { Topic.find_by_sql &quot;select 1 from badtable&quot; }
  end

  def test_find_with_invalid_params
    assert_raise(ArgumentError) { Topic.find :first, :join =&gt; &quot;It should be `joins'&quot; }
    assert_raise(ArgumentError) { Topic.find :first, :conditions =&gt; '1 = 1', :join =&gt; &quot;It should be `joins'&quot; }
  end

  def test_dynamic_finder_with_invalid_params
    assert_raise(ArgumentError) { Topic.find_by_title 'No Title', :join =&gt; &quot;It should be `joins'&quot; }
  end

  def test_find_all_with_join
    developers_on_project_one = Developer.find(
      :all,
      :joins =&gt; 'LEFT JOIN developers_projects ON developers.id = developers_projects.developer_id',
      :conditions =&gt; 'project_id=1'
    )
    assert_equal 3, developers_on_project_one.length
    developer_names = developers_on_project_one.map { |d| d.name }
    assert developer_names.include?('David')
    assert developer_names.include?('Jamis')
  end

  def test_joins_dont_clobber_id
    first = Firm.find(
      :first,
      :joins =&gt; 'INNER JOIN companies AS clients ON clients.firm_id = companies.id',
      :conditions =&gt; 'companies.id = 1'
    )
    assert_equal 1, first.id
  end

  def test_joins_with_string_array
    person_with_reader_and_post = Post.find(
      :all,
      :joins =&gt; [
        &quot;INNER JOIN categorizations ON categorizations.post_id = posts.id&quot;,
        &quot;INNER JOIN categories ON categories.id = categorizations.category_id AND categories.type = 'SpecialCategory'&quot;
      ]
    )
    assert_equal 1, person_with_reader_and_post.size
  end

  def test_find_by_id_with_conditions_with_or
    assert_nothing_raised do
      Post.find([1,2,3],
        :conditions =&gt; &quot;posts.id &lt;= 3 OR posts.#{QUOTED_TYPE} = 'Post'&quot;)
    end
  end

  # http://dev.rubyonrails.org/ticket/6778
  def test_find_ignores_previously_inserted_record
    post = Post.create!(:title =&gt; 'test', :body =&gt; 'it out')
    assert_equal [], Post.find_all_by_id(nil)
  end

  def test_find_by_empty_ids
    assert_equal [], Post.find([])
  end

  def test_find_by_empty_in_condition
    assert_equal [], Post.find(:all, :conditions =&gt; ['id in (?)', []])
  end

  def test_find_by_records
    p1, p2 = Post.find(:all, :limit =&gt; 2, :order =&gt; 'id asc')
    assert_equal [p1, p2], Post.find(:all, :conditions =&gt; ['id in (?)', [p1, p2]], :order =&gt; 'id asc')
    assert_equal [p1, p2], Post.find(:all, :conditions =&gt; ['id in (?)', [p1, p2.id]], :order =&gt; 'id asc')
  end

  def test_select_value
    assert_equal &quot;37signals&quot;, Company.connection.select_value(&quot;SELECT name FROM companies WHERE id = 1&quot;)
    assert_nil Company.connection.select_value(&quot;SELECT name FROM companies WHERE id = -1&quot;)
    # make sure we didn't break count...
    assert_equal 0, Company.count_by_sql(&quot;SELECT COUNT(*) FROM companies WHERE name = 'Halliburton'&quot;)
    assert_equal 1, Company.count_by_sql(&quot;SELECT COUNT(*) FROM companies WHERE name = '37signals'&quot;)
  end

  def test_select_values
    assert_equal [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;], Company.connection.select_values(&quot;SELECT id FROM companies ORDER BY id&quot;).map! { |i| i.to_s }
    assert_equal [&quot;37signals&quot;,&quot;Summit&quot;,&quot;Microsoft&quot;, &quot;Flamboyant Software&quot;, &quot;Ex Nihilo&quot;, &quot;RailsCore&quot;, &quot;Leetsoft&quot;, &quot;Jadedpixel&quot;, &quot;Odegy&quot;], Company.connection.select_values(&quot;SELECT name FROM companies ORDER BY id&quot;)
  end

  def test_select_rows
    assert_equal(
      [[&quot;1&quot;, nil, nil, &quot;37signals&quot;],
       [&quot;2&quot;, &quot;1&quot;, &quot;2&quot;, &quot;Summit&quot;],
       [&quot;3&quot;, &quot;1&quot;, &quot;1&quot;, &quot;Microsoft&quot;]],
      Company.connection.select_rows(&quot;SELECT id, firm_id, client_of, name FROM companies WHERE id IN (1,2,3) ORDER BY id&quot;).map! {|i| i.map! {|j| j.to_s unless j.nil?}})
    assert_equal [[&quot;1&quot;, &quot;37signals&quot;], [&quot;2&quot;, &quot;Summit&quot;], [&quot;3&quot;, &quot;Microsoft&quot;]],
      Company.connection.select_rows(&quot;SELECT id, name FROM companies WHERE id IN (1,2,3) ORDER BY id&quot;).map! {|i| i.map! {|j| j.to_s unless j.nil?}}
  end

  def test_find_with_order_on_included_associations_with_construct_finder_sql_for_association_limiting_and_is_distinct
    assert_equal 2, Post.find(:all, :include =&gt; { :authors =&gt; :author_address }, :order =&gt; ' author_addresses.id DESC ', :limit =&gt; 2).size

    assert_equal 3, Post.find(:all, :include =&gt; { :author =&gt; :author_address, :authors =&gt; :author_address},
                              :order =&gt; ' author_addresses_authors.id DESC ', :limit =&gt; 3).size
  end

  def test_with_limiting_with_custom_select
    posts = Post.find(:all, :include =&gt; :author, :select =&gt; ' posts.*, authors.id as &quot;author_id&quot;', :limit =&gt; 3, :order =&gt; 'posts.id')
    assert_equal 3, posts.size
    assert_equal [0, 1, 1], posts.map(&amp;:author_id).sort
  end

  def test_finder_with_scoped_from
    all_topics = Topic.all

    Topic.with_scope(:find =&gt; { :from =&gt; 'fake_topics' }) do
      assert_equal all_topics, Topic.all(:from =&gt; 'topics')
    end
  end

  protected
    def bind(statement, *vars)
      if vars.first.is_a?(Hash)
        ActiveRecord::Base.send(:replace_named_bind_variables, statement, vars.first)
      else
        ActiveRecord::Base.send(:replace_bind_variables, statement, vars)
      end
    end
end
</pre>
    </div>