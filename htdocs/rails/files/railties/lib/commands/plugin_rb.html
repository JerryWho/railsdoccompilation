  <div id="fileHeader">
    <h1>plugin.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>railties/lib/commands/plugin.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Nov 27 16:38:16 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># Rails Plugin Manager.
# 
# Listing available plugins:
#
#   $ ./script/plugin list
#   continuous_builder            http://dev.rubyonrails.com/svn/rails/plugins/continuous_builder
#   asset_timestamping            http://svn.aviditybytes.com/rails/plugins/asset_timestamping
#   enumerations_mixin            http://svn.protocool.com/rails/plugins/enumerations_mixin/trunk
#   calculations                  http://techno-weenie.net/svn/projects/calculations/
#   ...
#
# Installing plugins:
#
#   $ ./script/plugin install continuous_builder asset_timestamping
#
# Finding Repositories:
#
#   $ ./script/plugin discover
# 
# Adding Repositories:
#
#   $ ./script/plugin source http://svn.protocool.com/rails/plugins/
#
# How it works:
# 
#   * Maintains a list of subversion repositories that are assumed to have
#     a plugin directory structure. Manage them with the (source, unsource,
#     and sources commands)
#     
#   * The discover command scrapes the following page for things that
#     look like subversion repositories with plugins:
#     http://wiki.rubyonrails.org/rails/pages/Plugins
# 
#   * Unless you specify that you want to use svn, script/plugin uses plain old
#     HTTP for downloads.  The following bullets are true if you specify
#     that you want to use svn.
#
#   * If `vendor/plugins` is under subversion control, the script will
#     modify the svn:externals property and perform an update. You can
#     use normal subversion commands to keep the plugins up to date.
# 
#   * Or, if `vendor/plugins` is not under subversion control, the
#     plugin is pulled via `svn checkout` or `svn export` but looks
#     exactly the same.
# 
# Specifying revisions:
#
#   * Subversion revision is a single integer.
#
#   * Git revision format:
#     - full - 'refs/tags/1.8.0' or 'refs/heads/experimental'
#     - short: 'experimental' (equivalent to 'refs/heads/experimental')
#              'tag 1.8.0' (equivalent to 'refs/tags/1.8.0')
#
#
# This is Free Software, copyright 2005 by Ryan Tomayko (rtomayko@gmail.com) 
# and is licensed MIT: (http://www.opensource.org/licenses/mit-license.php)

$verbose = false


require 'open-uri'
require 'fileutils'
require 'tempfile'

include FileUtils

class RailsEnvironment
  attr_reader :root

  def initialize(dir)
    @root = dir
  end

  def self.find(dir=nil)
    dir ||= pwd
    while dir.length &gt; 1
      return new(dir) if File.exist?(File.join(dir, 'config', 'environment.rb'))
      dir = File.dirname(dir)
    end
  end
  
  def self.default
    @default ||= find
  end
  
  def self.default=(rails_env)
    @default = rails_env
  end
  
  def install(name_uri_or_plugin)
    if name_uri_or_plugin.is_a? String
      if name_uri_or_plugin =~ /:\/\// 
        plugin = Plugin.new(name_uri_or_plugin)
      else
        plugin = Plugins[name_uri_or_plugin]
      end
    else
      plugin = name_uri_or_plugin
    end
    unless plugin.nil?
      plugin.install
    else
      puts &quot;Plugin not found: #{name_uri_or_plugin}&quot;
    end
  end
 
  def use_svn?
    require 'active_support/core_ext/kernel'
    silence_stderr {`svn --version` rescue nil}
    !$?.nil? &amp;&amp; $?.success?
  end

  def use_externals?
    use_svn? &amp;&amp; File.directory?(&quot;#{root}/vendor/plugins/.svn&quot;)
  end

  def use_checkout?
    # this is a bit of a guess. we assume that if the rails environment
    # is under subversion then they probably want the plugin checked out
    # instead of exported. This can be overridden on the command line
    File.directory?(&quot;#{root}/.svn&quot;)
  end

  def best_install_method
    return :http unless use_svn?
    case
      when use_externals? then :externals
      when use_checkout? then :checkout
      else :export
    end
  end

  def externals
    return [] unless use_externals?
    ext = `svn propget svn:externals &quot;#{root}/vendor/plugins&quot;`
    lines = ext.respond_to?(:lines) ? ext.lines : ext
    lines.reject{ |line| line.strip == '' }.map do |line|
      line.strip.split(/\s+/, 2) 
    end
  end

  def externals=(items)
    unless items.is_a? String
      items = items.map{|name,uri| &quot;#{name.ljust(29)} #{uri.chomp('/')}&quot;}.join(&quot;\n&quot;)
    end
    Tempfile.open(&quot;svn-set-prop&quot;) do |file|
      file.write(items)
      file.flush
      system(&quot;svn propset -q svn:externals -F \&quot;#{file.path}\&quot; \&quot;#{root}/vendor/plugins\&quot;&quot;)
    end
  end
  
end

class Plugin
  attr_reader :name, :uri
  
  def initialize(uri, name=nil)
    @uri = uri
    guess_name(uri)
  end
  
  def self.find(name)
    name =~ /\// ? new(name) : Repositories.instance.find_plugin(name)
  end
  
  def to_s
    &quot;#{@name.ljust(30)}#{@uri}&quot;
  end
  
  def svn_url?
    @uri =~ /svn(?:\+ssh)?:\/\/*/
  end
  
  def git_url?
    @uri =~ /^git:\/\// || @uri =~ /\.git$/
  end
  
  def installed?
    File.directory?(&quot;#{rails_env.root}/vendor/plugins/#{name}&quot;) \
      or rails_env.externals.detect{ |name, repo| self.uri == repo }
  end
  
  def install(method=nil, options = {})
    method ||= rails_env.best_install_method?
    if :http == method
      method = :export if svn_url?
      method = :git    if git_url?
    end

    uninstall if installed? and options[:force]

    unless installed?
      send(&quot;install_using_#{method}&quot;, options)
      run_install_hook
    else
      puts &quot;already installed: #{name} (#{uri}).  pass --force to reinstall&quot;
    end
  end

  def uninstall
    path = &quot;#{rails_env.root}/vendor/plugins/#{name}&quot;
    if File.directory?(path)
      puts &quot;Removing 'vendor/plugins/#{name}'&quot; if $verbose
      run_uninstall_hook
      rm_r path
    else
      puts &quot;Plugin doesn't exist: #{path}&quot;
    end
    # clean up svn:externals
    externals = rails_env.externals
    externals.reject!{|n,u| name == n or name == u}
    rails_env.externals = externals
  end

  def info
    tmp = &quot;#{rails_env.root}/_tmp_about.yml&quot;
    if svn_url?
      cmd = &quot;svn export #{@uri} \&quot;#{rails_env.root}/#{tmp}\&quot;&quot;
      puts cmd if $verbose
      system(cmd)
    end
    open(svn_url? ? tmp : File.join(@uri, 'about.yml')) do |stream|
      stream.read
    end rescue &quot;No about.yml found in #{uri}&quot;
  ensure
    FileUtils.rm_rf tmp if svn_url?
  end

  private 

    def run_install_hook
      install_hook_file = &quot;#{rails_env.root}/vendor/plugins/#{name}/install.rb&quot;
      load install_hook_file if File.exist? install_hook_file
    end

    def run_uninstall_hook
      uninstall_hook_file = &quot;#{rails_env.root}/vendor/plugins/#{name}/uninstall.rb&quot;
      load uninstall_hook_file if File.exist? uninstall_hook_file
    end

    def install_using_export(options = {})
      svn_command :export, options
    end
    
    def install_using_checkout(options = {})
      svn_command :checkout, options
    end
    
    def install_using_externals(options = {})
      externals = rails_env.externals
      externals.push([@name, uri])
      rails_env.externals = externals
      install_using_checkout(options)
    end

    def install_using_http(options = {})
      root = rails_env.root
      mkdir_p &quot;#{root}/vendor/plugins/#{@name}&quot;
      Dir.chdir &quot;#{root}/vendor/plugins/#{@name}&quot; do
        puts &quot;fetching from '#{uri}'&quot; if $verbose
        fetcher = RecursiveHTTPFetcher.new(uri, -1)
        fetcher.quiet = true if options[:quiet]
        fetcher.fetch
      end
    end
    
    def install_using_git(options = {})
      root = rails_env.root
      mkdir_p(install_path = &quot;#{root}/vendor/plugins/#{name}&quot;)
      Dir.chdir install_path do
        init_cmd = &quot;git init&quot;
        init_cmd += &quot; -q&quot; if options[:quiet] and not $verbose
        puts init_cmd if $verbose
        system(init_cmd)
        base_cmd = &quot;git pull --depth 1 #{uri}&quot;
        base_cmd += &quot; -q&quot; if options[:quiet] and not $verbose
        base_cmd += &quot; #{options[:revision]}&quot; if options[:revision]
        puts base_cmd if $verbose
        if system(base_cmd)
          puts &quot;removing: .git .gitignore&quot; if $verbose
          rm_rf %w(.git .gitignore)
        else
          rm_rf install_path
        end
      end
    end

    def svn_command(cmd, options = {})
      root = rails_env.root
      mkdir_p &quot;#{root}/vendor/plugins&quot;
      base_cmd = &quot;svn #{cmd} #{uri} \&quot;#{root}/vendor/plugins/#{name}\&quot;&quot;
      base_cmd += ' -q' if options[:quiet] and not $verbose
      base_cmd += &quot; -r #{options[:revision]}&quot; if options[:revision]
      puts base_cmd if $verbose
      system(base_cmd)
    end

    def guess_name(url)
      @name = File.basename(url)
      if @name == 'trunk' || @name.empty?
        @name = File.basename(File.dirname(url))
      end
      @name.gsub!(/\.git$/, '') if @name =~ /\.git$/
    end
    
    def rails_env
      @rails_env || RailsEnvironment.default
    end
end

class Repositories
  include Enumerable
  
  def initialize(cache_file = File.join(find_home, &quot;.rails-plugin-sources&quot;))
    @cache_file = File.expand_path(cache_file)
    load!
  end
  
  def each(&amp;block)
    @repositories.each(&amp;block)
  end
  
  def add(uri)
    unless find{|repo| repo.uri == uri }
      @repositories.push(Repository.new(uri)).last
    end
  end
  
  def remove(uri)
    @repositories.reject!{|repo| repo.uri == uri}
  end
  
  def exist?(uri)
    @repositories.detect{|repo| repo.uri == uri }
  end
  
  def all
    @repositories
  end
  
  def find_plugin(name)
    @repositories.each do |repo|
      repo.each do |plugin|
        return plugin if plugin.name == name
      end
    end
    return nil
  end
  
  def load!
    contents = File.exist?(@cache_file) ? File.read(@cache_file) : defaults
    contents = defaults if contents.empty?
    @repositories = contents.split(/\n/).reject do |line|
      line =~ /^\s*#/ or line =~ /^\s*$/
    end.map { |source| Repository.new(source.strip) }
  end
  
  def save
    File.open(@cache_file, 'w') do |f|
      each do |repo|
        f.write(repo.uri)
        f.write(&quot;\n&quot;)
      end
    end
  end
  
  def defaults
    &lt;&lt;-DEFAULTS
    http://dev.rubyonrails.com/svn/rails/plugins/
    DEFAULTS
  end
 
  def find_home
    ['HOME', 'USERPROFILE'].each do |homekey|
      return ENV[homekey] if ENV[homekey]
    end
    if ENV['HOMEDRIVE'] &amp;&amp; ENV['HOMEPATH']
      return &quot;#{ENV['HOMEDRIVE']}:#{ENV['HOMEPATH']}&quot;
    end
    begin
      File.expand_path(&quot;~&quot;)
    rescue StandardError =&gt; ex
      if File::ALT_SEPARATOR
        &quot;C:/&quot;
      else
        &quot;/&quot;
      end
    end
  end

  def self.instance
    @instance ||= Repositories.new
  end
  
  def self.each(&amp;block)
    self.instance.each(&amp;block)
  end
end

class Repository
  include Enumerable
  attr_reader :uri, :plugins
  
  def initialize(uri)
    @uri = uri.chomp('/') &lt;&lt; &quot;/&quot;
    @plugins = nil
  end
  
  def plugins
    unless @plugins
      if $verbose
        puts &quot;Discovering plugins in #{@uri}&quot; 
        puts index
      end

      @plugins = index.reject{ |line| line !~ /\/$/ }
      @plugins.map! { |name| Plugin.new(File.join(@uri, name), name) }
    end

    @plugins
  end
  
  def each(&amp;block)
    plugins.each(&amp;block)
  end
  
  private
    def index
      @index ||= RecursiveHTTPFetcher.new(@uri).ls
    end
end


# load default environment and parse arguments
require 'optparse'
module Commands

  class Plugin
    attr_reader :environment, :script_name, :sources
    def initialize
      @environment = RailsEnvironment.default
      @rails_root = RailsEnvironment.default.root
      @script_name = File.basename($0) 
      @sources = []
    end
    
    def environment=(value)
      @environment = value
      RailsEnvironment.default = value
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@script_name} [OPTIONS] command&quot;
        o.define_head &quot;Rails plugin manager.&quot;
        
        o.separator &quot;&quot;        
        o.separator &quot;GENERAL OPTIONS&quot;
        
        o.on(&quot;-r&quot;, &quot;--root=DIR&quot;, String,
             &quot;Set an explicit rails app directory.&quot;,
             &quot;Default: #{@rails_root}&quot;) { |rails_root| @rails_root = rails_root; self.environment = RailsEnvironment.new(@rails_root) }
        o.on(&quot;-s&quot;, &quot;--source=URL1,URL2&quot;, Array,
             &quot;Use the specified plugin repositories instead of the defaults.&quot;) { |sources| @sources = sources}
        
        o.on(&quot;-v&quot;, &quot;--verbose&quot;, &quot;Turn on verbose output.&quot;) { |verbose| $verbose = verbose }
        o.on(&quot;-h&quot;, &quot;--help&quot;, &quot;Show this help message.&quot;) { puts o; exit }
        
        o.separator &quot;&quot;
        o.separator &quot;COMMANDS&quot;
        
        o.separator &quot;  discover   Discover plugin repositories.&quot;
        o.separator &quot;  list       List available plugins.&quot;
        o.separator &quot;  install    Install plugin(s) from known repositories or URLs.&quot;
        o.separator &quot;  update     Update installed plugins.&quot;
        o.separator &quot;  remove     Uninstall plugins.&quot;
        o.separator &quot;  source     Add a plugin source repository.&quot;
        o.separator &quot;  unsource   Remove a plugin repository.&quot;
        o.separator &quot;  sources    List currently configured plugin repositories.&quot;
        
        o.separator &quot;&quot;
        o.separator &quot;EXAMPLES&quot;
        o.separator &quot;  Install a plugin:&quot;
        o.separator &quot;    #{@script_name} install continuous_builder\n&quot;
        o.separator &quot;  Install a plugin from a subversion URL:&quot;
        o.separator &quot;    #{@script_name} install http://dev.rubyonrails.com/svn/rails/plugins/continuous_builder\n&quot;
        o.separator &quot;  Install a plugin from a git URL:&quot;
        o.separator &quot;    #{@script_name} install git://github.com/SomeGuy/my_awesome_plugin.git\n&quot;
        o.separator &quot;  Install a plugin and add a svn:externals entry to vendor/plugins&quot;
        o.separator &quot;    #{@script_name} install -x continuous_builder\n&quot;
        o.separator &quot;  List all available plugins:&quot;
        o.separator &quot;    #{@script_name} list\n&quot;
        o.separator &quot;  List plugins in the specified repository:&quot;
        o.separator &quot;    #{@script_name} list --source=http://dev.rubyonrails.com/svn/rails/plugins/\n&quot;
        o.separator &quot;  Discover and prompt to add new repositories:&quot;
        o.separator &quot;    #{@script_name} discover\n&quot;
        o.separator &quot;  Discover new repositories but just list them, don't add anything:&quot;
        o.separator &quot;    #{@script_name} discover -l\n&quot;
        o.separator &quot;  Add a new repository to the source list:&quot;
        o.separator &quot;    #{@script_name} source http://dev.rubyonrails.com/svn/rails/plugins/\n&quot;
        o.separator &quot;  Remove a repository from the source list:&quot;
        o.separator &quot;    #{@script_name} unsource http://dev.rubyonrails.com/svn/rails/plugins/\n&quot;
        o.separator &quot;  Show currently configured repositories:&quot;
        o.separator &quot;    #{@script_name} sources\n&quot;        
      end
    end
    
    def parse!(args=ARGV)
      general, sub = split_args(args)
      options.parse!(general)
      
      command = general.shift
      if command =~ /^(list|discover|install|source|unsource|sources|remove|update|info)$/
        command = Commands.const_get(command.capitalize).new(self)
        command.parse!(sub)
      else
        puts &quot;Unknown command: #{command}&quot;
        puts options
        exit 1
      end
    end
    
    def split_args(args)
      left = []
      left &lt;&lt; args.shift while args[0] and args[0] =~ /^-/
      left &lt;&lt; args.shift if args[0]
      return [left, args]
    end
    
    def self.parse!(args=ARGV)
      Plugin.new.parse!(args)
    end
  end
  
  
  class List
    def initialize(base_command)
      @base_command = base_command
      @sources = []
      @local = false
      @remote = true
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} list [OPTIONS] [PATTERN]&quot;
        o.define_head &quot;List available plugins.&quot;
        o.separator   &quot;&quot;        
        o.separator   &quot;Options:&quot;
        o.separator   &quot;&quot;
        o.on(         &quot;-s&quot;, &quot;--source=URL1,URL2&quot;, Array,
                      &quot;Use the specified plugin repositories.&quot;) {|sources| @sources = sources}
        o.on(         &quot;--local&quot;, 
                      &quot;List locally installed plugins.&quot;) {|local| @local, @remote = local, false}
        o.on(         &quot;--remote&quot;,
                      &quot;List remotely available plugins. This is the default behavior&quot;,
                      &quot;unless --local is provided.&quot;) {|remote| @remote = remote}
      end
    end
    
    def parse!(args)
      options.order!(args)
      unless @sources.empty?
        @sources.map!{ |uri| Repository.new(uri) }
      else
        @sources = Repositories.instance.all
      end
      if @remote
        @sources.map{|r| r.plugins}.flatten.each do |plugin| 
          if @local or !plugin.installed?
            puts plugin.to_s
          end
        end
      else
        cd &quot;#{@base_command.environment.root}/vendor/plugins&quot;
        Dir[&quot;*&quot;].select{|p| File.directory?(p)}.each do |name| 
          puts name
        end
      end
    end
  end
  
  
  class Sources
    def initialize(base_command)
      @base_command = base_command
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} sources [OPTIONS] [PATTERN]&quot;
        o.define_head &quot;List configured plugin repositories.&quot;
        o.separator   &quot;&quot;        
        o.separator   &quot;Options:&quot;
        o.separator   &quot;&quot;
        o.on(         &quot;-c&quot;, &quot;--check&quot;, 
                      &quot;Report status of repository.&quot;) { |sources| @sources = sources}
      end
    end
    
    def parse!(args)
      options.parse!(args)
      Repositories.each do |repo|
        puts repo.uri
      end
    end
  end
  
  
  class Source
    def initialize(base_command)
      @base_command = base_command
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} source REPOSITORY [REPOSITORY [REPOSITORY]...]&quot;
        o.define_head &quot;Add new repositories to the default search list.&quot;
      end
    end
    
    def parse!(args)
      options.parse!(args)
      count = 0
      args.each do |uri|
        if Repositories.instance.add(uri)
          puts &quot;added: #{uri.ljust(50)}&quot; if $verbose
          count += 1
        else
          puts &quot;failed: #{uri.ljust(50)}&quot;
        end
      end
      Repositories.instance.save
      puts &quot;Added #{count} repositories.&quot;
    end
  end
  
  
  class Unsource
    def initialize(base_command)
      @base_command = base_command
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} unsource URI [URI [URI]...]&quot;
        o.define_head &quot;Remove repositories from the default search list.&quot;
        o.separator &quot;&quot;
        o.on_tail(&quot;-h&quot;, &quot;--help&quot;, &quot;Show this help message.&quot;) { puts o; exit }
      end
    end
    
    def parse!(args)
      options.parse!(args)
      count = 0
      args.each do |uri|
        if Repositories.instance.remove(uri)
          count += 1
          puts &quot;removed: #{uri.ljust(50)}&quot;
        else
          puts &quot;failed: #{uri.ljust(50)}&quot;
        end
      end
      Repositories.instance.save
      puts &quot;Removed #{count} repositories.&quot;
    end
  end

  
  class Discover
    def initialize(base_command)
      @base_command = base_command
      @list = false
      @prompt = true
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} discover URI [URI [URI]...]&quot;
        o.define_head &quot;Discover repositories referenced on a page.&quot;
        o.separator   &quot;&quot;        
        o.separator   &quot;Options:&quot;
        o.separator   &quot;&quot;
        o.on(         &quot;-l&quot;, &quot;--list&quot;, 
                      &quot;List but don't prompt or add discovered repositories.&quot;) { |list| @list, @prompt = list, !@list }
        o.on(         &quot;-n&quot;, &quot;--no-prompt&quot;, 
                      &quot;Add all new repositories without prompting.&quot;) { |v| @prompt = !v }
      end
    end

    def parse!(args)
      options.parse!(args)
      args = ['http://wiki.rubyonrails.org/rails/pages/Plugins'] if args.empty?
      args.each do |uri|
        scrape(uri) do |repo_uri|
          catch(:next_uri) do
            if @prompt
              begin
                $stdout.print &quot;Add #{repo_uri}? [Y/n] &quot;
                throw :next_uri if $stdin.gets !~ /^y?$/i
              rescue Interrupt
                $stdout.puts
                exit 1
              end
            elsif @list
              puts repo_uri
              throw :next_uri
            end
            Repositories.instance.add(repo_uri)
            puts &quot;discovered: #{repo_uri}&quot; if $verbose or !@prompt
          end
        end
      end
      Repositories.instance.save
    end
    
    def scrape(uri)
      require 'open-uri'
      puts &quot;Scraping #{uri}&quot; if $verbose
      dupes = []
      content = open(uri).each do |line|
        begin
          if line =~ /&lt;a[^&gt;]*href=['&quot;]([^'&quot;]*)['&quot;]/ || line =~ /(svn:\/\/[^&lt;|\n]*)/
            uri = $1
            if uri =~ /^\w+:\/\// &amp;&amp; uri =~ /\/plugins\// &amp;&amp; uri !~ /\/browser\// &amp;&amp; uri !~ /^http:\/\/wiki\.rubyonrails/ &amp;&amp; uri !~ /http:\/\/instiki/
              uri = extract_repository_uri(uri)
              yield uri unless dupes.include?(uri) || Repositories.instance.exist?(uri)
              dupes &lt;&lt; uri
            end
          end
        rescue
          puts &quot;Problems scraping '#{uri}': #{$!.to_s}&quot;
        end
      end
    end
    
    def extract_repository_uri(uri)
      uri.match(/(svn|https?):.*\/plugins\//i)[0]
    end 
  end
  
  class Install
    def initialize(base_command)
      @base_command = base_command
      @method = :http
      @options = { :quiet =&gt; false, :revision =&gt; nil, :force =&gt; false }
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} install PLUGIN [PLUGIN [PLUGIN] ...]&quot;
        o.define_head &quot;Install one or more plugins.&quot;
        o.separator   &quot;&quot;
        o.separator   &quot;Options:&quot;
        o.on(         &quot;-x&quot;, &quot;--externals&quot;, 
                      &quot;Use svn:externals to grab the plugin.&quot;, 
                      &quot;Enables plugin updates and plugin versioning.&quot;) { |v| @method = :externals }
        o.on(         &quot;-o&quot;, &quot;--checkout&quot;,
                      &quot;Use svn checkout to grab the plugin.&quot;,
                      &quot;Enables updating but does not add a svn:externals entry.&quot;) { |v| @method = :checkout }
        o.on(         &quot;-e&quot;, &quot;--export&quot;,
                      &quot;Use svn export to grab the plugin.&quot;,
                      &quot;Exports the plugin, allowing you to check it into your local repository. Does not enable updates, or add an svn:externals entry.&quot;) { |v| @method = :export }
        o.on(         &quot;-q&quot;, &quot;--quiet&quot;,
                      &quot;Suppresses the output from installation.&quot;,
                      &quot;Ignored if -v is passed (./script/plugin -v install ...)&quot;) { |v| @options[:quiet] = true }
        o.on(         &quot;-r REVISION&quot;, &quot;--revision REVISION&quot;,
                      &quot;Checks out the given revision from subversion or git.&quot;,
                      &quot;Ignored if subversion/git is not used.&quot;) { |v| @options[:revision] = v }
        o.on(         &quot;-f&quot;, &quot;--force&quot;,
                      &quot;Reinstalls a plugin if it's already installed.&quot;) { |v| @options[:force] = true }
        o.separator   &quot;&quot;
        o.separator   &quot;You can specify plugin names as given in 'plugin list' output or absolute URLs to &quot;
        o.separator   &quot;a plugin repository.&quot;
      end
    end
    
    def determine_install_method
      best = @base_command.environment.best_install_method
      @method = :http if best == :http and @method == :export
      case
      when (best == :http and @method != :http)
        msg = &quot;Cannot install using subversion because `svn' cannot be found in your PATH&quot;
      when (best == :export and (@method != :export and @method != :http))
        msg = &quot;Cannot install using #{@method} because this project is not under subversion.&quot;
      when (best != :externals and @method == :externals)
        msg = &quot;Cannot install using externals because vendor/plugins is not under subversion.&quot;
      end
      if msg
        puts msg
        exit 1
      end
      @method
    end
    
    def parse!(args)
      options.parse!(args)
      environment = @base_command.environment
      install_method = determine_install_method
      puts &quot;Plugins will be installed using #{install_method}&quot; if $verbose
      args.each do |name|
        ::Plugin.find(name).install(install_method, @options)
      end
    rescue StandardError =&gt; e
      puts &quot;Plugin not found: #{args.inspect}&quot;
      puts e.inspect if $verbose
      exit 1
    end
  end

  class Update
    def initialize(base_command)
      @base_command = base_command
    end
   
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} update [name [name]...]&quot;
        o.on(         &quot;-r REVISION&quot;, &quot;--revision REVISION&quot;,
                      &quot;Checks out the given revision from subversion.&quot;,
                      &quot;Ignored if subversion is not used.&quot;) { |v| @revision = v }
        o.define_head &quot;Update plugins.&quot;
      end
    end
   
    def parse!(args)
      options.parse!(args)
      root = @base_command.environment.root
      cd root
      args = Dir[&quot;vendor/plugins/*&quot;].map do |f|
        File.directory?(&quot;#{f}/.svn&quot;) ? File.basename(f) : nil
      end.compact if args.empty?
      cd &quot;vendor/plugins&quot;
      args.each do |name|
        if File.directory?(name)
          puts &quot;Updating plugin: #{name}&quot;
          system(&quot;svn #{$verbose ? '' : '-q'} up \&quot;#{name}\&quot; #{@revision ? &quot;-r #{@revision}&quot; : ''}&quot;)
        else
          puts &quot;Plugin doesn't exist: #{name}&quot;
        end
      end
    end
  end

  class Remove
    def initialize(base_command)
      @base_command = base_command
    end
    
    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} remove name [name]...&quot;
        o.define_head &quot;Remove plugins.&quot;
      end
    end
    
    def parse!(args)
      options.parse!(args)
      root = @base_command.environment.root
      args.each do |name|
        ::Plugin.new(name).uninstall
      end
    end
  end

  class Info
    def initialize(base_command)
      @base_command = base_command
    end

    def options
      OptionParser.new do |o|
        o.set_summary_indent('  ')
        o.banner =    &quot;Usage: #{@base_command.script_name} info name [name]...&quot;
        o.define_head &quot;Shows plugin info at {url}/about.yml.&quot;
      end
    end

    def parse!(args)
      options.parse!(args)
      args.each do |name|
        puts ::Plugin.find(name).info
        puts
      end
    end
  end
end
 
class RecursiveHTTPFetcher
  attr_accessor :quiet
  def initialize(urls_to_fetch, level = 1, cwd = &quot;.&quot;)
    @level = level
    @cwd = cwd
    @urls_to_fetch = RUBY_VERSION &gt;= '1.9' ? urls_to_fetch.lines : urls_to_fetch.to_a
    @quiet = false
  end

  def ls
    @urls_to_fetch.collect do |url|
      if url =~ /^svn(\+ssh)?:\/\/.*/
        `svn ls #{url}`.split(&quot;\n&quot;).map {|entry| &quot;/#{entry}&quot;} rescue nil
      else
        open(url) do |stream|
          links(&quot;&quot;, stream.read)
        end rescue nil
      end
    end.flatten
  end

  def push_d(dir)
    @cwd = File.join(@cwd, dir)
    FileUtils.mkdir_p(@cwd)
  end

  def pop_d
    @cwd = File.dirname(@cwd)
  end

  def links(base_url, contents)
    links = []
    contents.scan(/href\s*=\s*\&quot;*[^\&quot;&gt;]*/i) do |link|
      link = link.sub(/href=&quot;/i, &quot;&quot;)
      next if link =~ /svnindex.xsl$/
      next if link =~ /^(\w*:|)\/\// || link =~ /^\./
      links &lt;&lt; File.join(base_url, link)
    end
    links
  end
  
  def download(link)
    puts &quot;+ #{File.join(@cwd, File.basename(link))}&quot; unless @quiet
    open(link) do |stream|
      File.open(File.join(@cwd, File.basename(link)), &quot;wb&quot;) do |file|
        file.write(stream.read)
      end
    end
  end
  
  def fetch(links = @urls_to_fetch)
    links.each do |l|
      (l =~ /\/$/ || links == @urls_to_fetch) ? fetch_dir(l) : download(l)
    end
  end
  
  def fetch_dir(url)
    @level += 1
    push_d(File.basename(url)) if @level &gt; 0
    open(url) do |stream|
      contents =  stream.read
      fetch(links(url, contents))
    end
    pop_d if @level &gt; 0
    @level -= 1
  end
end

Commands::Plugin.parse!
</pre>
    </div>