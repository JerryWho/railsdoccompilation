  <div id="fileHeader">
    <h1>generator_test_helper.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>railties/test/generators/generator_test_helper.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:55:10 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'test/unit'
require 'fileutils'

# Mock out what we need from AR::Base
module ActiveRecord
  class Base
    class &lt;&lt; self
      attr_accessor :pluralize_table_names, :timestamped_migrations
    end
    self.pluralize_table_names = true
    self.timestamped_migrations = true
  end

  module ConnectionAdapters
    class Column
      attr_reader :name, :default, :type, :limit, :null, :sql_type, :precision, :scale

      def initialize(name, default, sql_type = nil)
        @name = name
        @default = default
        @type = @sql_type = sql_type
      end

      def human_name
        @name.humanize
      end
    end
  end
end

# Mock up necessities from ActionView
module ActionView
  module Helpers
    module ActionRecordHelper; end
    class InstanceTag; end
  end
end

# Set RAILS_ROOT appropriately fixture generation
tmp_dir = &quot;#{File.dirname(__FILE__)}/../fixtures/tmp&quot;

if defined? RAILS_ROOT
  RAILS_ROOT.replace tmp_dir
else
  RAILS_ROOT = tmp_dir
end
FileUtils.mkdir_p RAILS_ROOT

$LOAD_PATH.unshift &quot;#{File.dirname(__FILE__)}/../../lib&quot;
require 'initializer'

# Mocks out the configuration
module Rails
  def self.configuration
    Rails::Configuration.new
  end
end

require 'rails_generator'

class GeneratorTestCase &lt; Test::Unit::TestCase
  include FileUtils

  def setup
    ActiveRecord::Base.pluralize_table_names = true

    mkdir_p &quot;#{RAILS_ROOT}/app/views/layouts&quot;
    mkdir_p &quot;#{RAILS_ROOT}/config&quot;
    mkdir_p &quot;#{RAILS_ROOT}/db&quot;
    mkdir_p &quot;#{RAILS_ROOT}/test/fixtures&quot;
    mkdir_p &quot;#{RAILS_ROOT}/public/stylesheets&quot;

    File.open(&quot;#{RAILS_ROOT}/config/routes.rb&quot;, 'w') do |f|
      f &lt;&lt; &quot;ActionController::Routing::Routes.draw do |map|\n\nend&quot;
    end
  end

  def teardown
    rm_rf &quot;#{RAILS_ROOT}/app&quot;
    rm_rf &quot;#{RAILS_ROOT}/test&quot;
    rm_rf &quot;#{RAILS_ROOT}/config&quot;
    rm_rf &quot;#{RAILS_ROOT}/db&quot;
    rm_rf &quot;#{RAILS_ROOT}/public&quot;
  end

  def test_truth
    # don't complain, test/unit
  end

  # Instantiates the Generator.
  def build_generator(name, params)
    Rails::Generator::Base.instance(name, params)
  end

  # Runs the +create+ command (like the command line does).
  def run_generator(name, params)
    silence_generator do
      build_generator(name, params).command(:create).invoke!
    end
  end

  # Silences the logger temporarily and returns the output as a String.
  def silence_generator
    logger_original = Rails::Generator::Base.logger
    myout = StringIO.new
    Rails::Generator::Base.logger = Rails::Generator::SimpleLogger.new(myout)
    yield if block_given?
    Rails::Generator::Base.logger = logger_original
    myout.string
  end

  # Asserts that the given controller was generated.
  # It takes a name or symbol without the &lt;tt&gt;_controller&lt;/tt&gt; part and an optional super class.
  # The contents of the class source file is passed to a block.
  def assert_generated_controller_for(name, parent = &quot;ApplicationController&quot;)
    assert_generated_class &quot;app/controllers/#{name.to_s.underscore}_controller&quot;, parent do |body|
      yield body if block_given?
    end
  end

  # Asserts that the given model was generated.
  # It takes a name or symbol and an optional super class.
  # The contents of the class source file is passed to a block.
  def assert_generated_model_for(name, parent = &quot;ActiveRecord::Base&quot;)
    assert_generated_class &quot;app/models/#{name.to_s.underscore}&quot;, parent do |body|
      yield body if block_given?
    end
  end

  # Asserts that the given helper was generated.
  # It takes a name or symbol without the &lt;tt&gt;_helper&lt;/tt&gt; part.
  # The contents of the module source file is passed to a block.
  def assert_generated_helper_for(name)
    assert_generated_module &quot;app/helpers/#{name.to_s.underscore}_helper&quot; do |body|
      yield body if block_given?
    end
  end

  # Asserts that the given functional test was generated.
  # It takes a name or symbol without the &lt;tt&gt;_controller_test&lt;/tt&gt; part and an optional super class.
  # The contents of the class source file is passed to a block.
  def assert_generated_functional_test_for(name, parent = &quot;ActionController::TestCase&quot;)
    assert_generated_class &quot;test/functional/#{name.to_s.underscore}_controller_test&quot;,parent do |body|
      yield body if block_given?
    end
  end

  # Asserts that the given helper test test was generated.
  # It takes a name or symbol without the &lt;tt&gt;_helper_test&lt;/tt&gt; part and an optional super class.
  # The contents of the class source file is passed to a block.
  def assert_generated_helper_test_for(name, parent = &quot;ActionView::TestCase&quot;)
    path = &quot;test/unit/helpers/#{name.to_s.underscore}_helper_test&quot;
    # Have to pass the path without the &quot;test/&quot; part so that class_name_from_path will return a correct result
    class_name = class_name_from_path(path.gsub(/^test\//, ''))

    assert_generated_class path,parent,class_name do |body|
      yield body if block_given?
    end
  end

  # Asserts that the given unit test was generated.
  # It takes a name or symbol without the &lt;tt&gt;_test&lt;/tt&gt; part and an optional super class.
  # The contents of the class source file is passed to a block.
  def assert_generated_unit_test_for(name, parent = &quot;ActiveSupport::TestCase&quot;)
    assert_generated_class &quot;test/unit/#{name.to_s.underscore}_test&quot;, parent do |body|
      yield body if block_given?
    end
  end

  # Asserts that the given file was generated.
  # The contents of the file is passed to a block.
  def assert_generated_file(path)
    assert_file_exists(path)
    File.open(&quot;#{RAILS_ROOT}/#{path}&quot;) do |f|
      yield f.read if block_given?
    end
  end

  # asserts that the given file exists
  def assert_file_exists(path)
    assert File.exist?(&quot;#{RAILS_ROOT}/#{path}&quot;),
      &quot;The file '#{RAILS_ROOT}/#{path}' should exist&quot;
  end

  # Asserts that the given class source file was generated.
  # It takes a path without the &lt;tt&gt;.rb&lt;/tt&gt; part and an optional super class.
  # The contents of the class source file is passed to a block.
  def assert_generated_class(path, parent = nil, class_name = class_name_from_path(path))
    assert_generated_file(&quot;#{path}.rb&quot;) do |body|
      assert_match /class #{class_name}#{parent.nil? ? '':&quot; &lt; #{parent}&quot;}/, body, &quot;the file '#{path}.rb' should be a class&quot;
      yield body if block_given?
    end
  end

  def class_name_from_path(path)
    # FIXME: Sucky way to detect namespaced classes
    if path.split('/').size &gt; 3
      path =~ /\/?(\d+_)?(\w+)\/(\w+)$/
      &quot;#{$2.camelize}::#{$3.camelize}&quot;
    else
      path =~ /\/?(\d+_)?(\w+)$/
      $2.camelize
    end
  end

  # Asserts that the given module source file was generated.
  # It takes a path without the &lt;tt&gt;.rb&lt;/tt&gt; part.
  # The contents of the class source file is passed to a block.
  def assert_generated_module(path)
    # FIXME: Sucky way to detect namespaced modules
    if path.split('/').size &gt; 3
      path =~ /\/?(\w+)\/(\w+)$/
      module_name = &quot;#{$1.camelize}::#{$2.camelize}&quot;
    else
      path =~ /\/?(\w+)$/
      module_name = $1.camelize
    end

    assert_generated_file(&quot;#{path}.rb&quot;) do |body|
      assert_match /module #{module_name}/, body, &quot;the file '#{path}.rb' should be a module&quot;
      yield body if block_given?
    end
  end

  # Asserts that the given CSS stylesheet file was generated.
  # It takes a path without the &lt;tt&gt;.css&lt;/tt&gt; part.
  # The contents of the stylesheet source file is passed to a block.
  def assert_generated_stylesheet(path)
    assert_generated_file(&quot;public/stylesheets/#{path}.css&quot;) do |body|
      yield body if block_given?
    end
  end

  # Asserts that the given YAML file was generated.
  # It takes a path without the &lt;tt&gt;.yml&lt;/tt&gt; part.
  # The parsed YAML tree is passed to a block.
  def assert_generated_yaml(path)
    assert_generated_file(&quot;#{path}.yml&quot;) do |body|
      yaml = YAML.load(body)
      assert yaml, 'YAML data missing'
      yield yaml if block_given?
    end
  end

  # Asserts that the given fixtures YAML file was generated.
  # It takes a fixture name without the &lt;tt&gt;.yml&lt;/tt&gt; part.
  # The parsed YAML tree is passed to a block.
  def assert_generated_fixtures_for(name)
    assert_generated_yaml &quot;test/fixtures/#{name.to_s.underscore}&quot; do |yaml|
      yield yaml if block_given?
    end
  end

  # Asserts that the given views were generated.
  # It takes a controller name and a list of views (including extensions).
  # The body of each view is passed to a block.
  def assert_generated_views_for(name, *actions)
    actions.each do |action|
      assert_generated_file(&quot;app/views/#{name.to_s.underscore}/#{action}&quot;) do |body|
        yield body if block_given?
      end
    end
  end

  def assert_generated_migration(name, parent = &quot;ActiveRecord::Migration&quot;)
    file = Dir.glob(&quot;#{RAILS_ROOT}/db/migrate/*_#{name.to_s.underscore}.rb&quot;).first
    assert !file.nil?, &quot;should have generated the migration file but didn't&quot;

    file = file.match(/db\/migrate\/[0-9]+_\w+/).to_s
    assert_generated_class file, parent do |body|
      assert_match /timestamps/, body, &quot;should have timestamps defined&quot;
      yield body if block_given?
    end
  end

  # Asserts that the given migration file was not generated.
  # It takes the name of the migration as a parameter.
  def assert_skipped_migration(name)
    migration_file = &quot;#{RAILS_ROOT}/db/migrate/001_#{name.to_s.underscore}.rb&quot;
    assert !File.exist?(migration_file), &quot;should not create migration #{migration_file}&quot;
  end

  # Asserts that the given resource was added to the routes.
  def assert_added_route_for(name)
    assert_generated_file(&quot;config/routes.rb&quot;) do |body|
      assert_match /map.resources :#{name.to_s.underscore}/, body,
        &quot;should add route for :#{name.to_s.underscore}&quot;
    end
  end

  # Asserts that the given methods are defined in the body.
  # This does assume standard rails code conventions with regards to the source code.
  # The body of each individual method is passed to a block.
  def assert_has_method(body, *methods)
    methods.each do |name|
      assert body =~ /^  def #{name}(\(.+\))?\n((\n|   .*\n)*)  end/, &quot;should have method #{name}&quot;
      yield(name, $2) if block_given?
    end
  end

  # Asserts that the given column is defined in the migration.
  def assert_generated_column(body, name, type)
    assert_match /t\.#{type.to_s} :#{name.to_s}/, body, &quot;should have column #{name.to_s} defined&quot;
  end

  # Asserts that the given table is defined in the migration.
  def assert_generated_table(body, name)
    assert_match /create_table :#{name.to_s} do/, body, &quot;should have table #{name.to_s} defined&quot;
  end
end
</pre>
    </div>