  <div id="fileHeader">
    <h1>generator.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>railties/guides/rails_guides/generator.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:54 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'set'

module RailsGuides
  class Generator
    attr_reader :output, :view_path, :view, :guides_dir

    def initialize(output = nil)
      @guides_dir = File.join(File.dirname(__FILE__), '..')

      @output = output || File.join(@guides_dir, &quot;output&quot;)

      unless ENV[&quot;ONLY&quot;]
        FileUtils.rm_r(@output) if File.directory?(@output)
        FileUtils.mkdir(@output)
      end

      @view_path = File.join(@guides_dir, &quot;source&quot;)
    end

    def generate
      guides = Dir.entries(view_path).find_all {|g| g =~ /textile$/ }

      if ENV[&quot;ONLY&quot;]
        only = ENV[&quot;ONLY&quot;].split(&quot;,&quot;).map{|x| x.strip }.map {|o| &quot;#{o}.textile&quot; }
        guides = guides.find_all {|g| only.include?(g) }
        puts &quot;GENERATING ONLY #{guides.inspect}&quot;
      end

      guides.each do |guide|
        generate_guide(guide)
      end

      # Copy images and css files to html directory
      FileUtils.cp_r File.join(guides_dir, 'images'), File.join(output, 'images')
      FileUtils.cp_r File.join(guides_dir, 'files'), File.join(output, 'files')
    end

    def generate_guide(guide)
      guide =~ /(.*?)(\.erb)?\.textile/
      name = $1

      puts &quot;Generating #{name}&quot;

      file = File.join(output, &quot;#{name}.html&quot;)
      File.open(file, 'w') do |f|
        @view = ActionView::Base.new(view_path)
        @view.extend(Helpers)

        if guide =~ /\.erb\.textile/
          # Generate the erb pages with textile formatting - e.g. index/authors
          result = view.render(:layout =&gt; 'layout', :file =&gt; name)
          f.write textile(result)
        else
          body = File.read(File.join(view_path, guide))
          body = set_header_section(body, @view)
          body = set_index(body, @view)

          result = view.render(:layout =&gt; 'layout', :text =&gt; textile(body))
          f.write result
        end
      end
    end

    def set_header_section(body, view)
      new_body = body.gsub(/(.*?)endprologue\./m, '').strip
      header = $1

      header =~ /h2\.(.*)/
      page_title = $1.strip

      header = textile(header)

      view.content_for(:page_title) { page_title }
      view.content_for(:header_section) { header }
      new_body
    end

    def set_index(body, view)
      index = &lt;&lt;-INDEX
      &lt;div id=&quot;subCol&quot;&gt;
        &lt;h3 class=&quot;chapter&quot;&gt;&lt;img src=&quot;images/chapters_icon.gif&quot; alt=&quot;&quot; /&gt;Chapters&lt;/h3&gt;
        &lt;ol class=&quot;chapters&quot;&gt;
      INDEX

      i = Indexer.new(body)
      i.index

      # Set index for 2 levels
      i.level_hash.each do |key, value|
        link = view.content_tag(:a, :href =&gt; key[:id]) { textile(key[:title]) }

        children = value.keys.map do |k|
          l = view.content_tag(:a, :href =&gt; k[:id]) { textile(k[:title]) }
          view.content_tag(:li, l)
        end

        children_ul = view.content_tag(:ul, children)

        index &lt;&lt; view.content_tag(:li, link + children_ul)
      end

      index &lt;&lt; '&lt;/ol&gt;'
      index &lt;&lt; '&lt;/div&gt;'

      view.content_for(:index_section) { index }

      i.result
    end

    def textile(body)
      # If the issue with notextile is fixed just remove the wrapper.
      with_workaround_for_notextile(body) do |body|
        t = RedCloth.new(body)
        t.hard_breaks = false
        t.to_html(:notestuff, :plusplus, :code, :tip)
      end
    end

    # For some reason the notextile tag does not always turn off textile. See
    # LH ticket of the security guide (#7). As a temporary workaround we deal
    # with code blocks by hand.
    def with_workaround_for_notextile(body)
      code_blocks = []
      body.gsub!(%r{&lt;(yaml|shell|ruby|erb|html|sql|plain)&gt;(.*?)&lt;/\1&gt;}m) do |m|
        es = ERB::Util.h($2)
        css_class = ['erb', 'shell'].include?($1) ? 'html' : $1
        code_blocks &lt;&lt; %{&lt;div class=&quot;code_container&quot;&gt;&lt;code class=&quot;#{css_class}&quot;&gt;#{es}&lt;/code&gt;&lt;/div&gt;}
        &quot;\ndirty_workaround_for_notextile_#{code_blocks.size - 1}\n&quot;
      end
      
      body = yield body
      
      body.gsub(%r{&lt;p&gt;dirty_workaround_for_notextile_(\d+)&lt;/p&gt;}) do |_|
        code_blocks[$1.to_i]
      end
    end
  end
end
</pre>
    </div>