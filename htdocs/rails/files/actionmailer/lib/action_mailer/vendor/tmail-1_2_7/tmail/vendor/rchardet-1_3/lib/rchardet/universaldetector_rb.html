  <div id="fileHeader">
    <h1>universaldetector.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionmailer/lib/action_mailer/vendor/tmail-1.2.7/tmail/vendor/rchardet-1.3/lib/rchardet/universaldetector.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 11:32:52 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># encoding: us-ascii
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Jeff Hodges - port to Ruby
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

module CharDet
  MINIMUM_THRESHOLD = 0.20
  EPureAscii = 0
  EEscAscii = 1
  EHighbyte = 2

  class UniversalDetector
    attr_accessor :result
    def initialize
      @_highBitDetector = /[\x80-\xFF]/
      @_escDetector = /(\033|\~\{)/
      @_mEscCharSetProber = nil
      @_mCharSetProbers = []
      reset()
    end

    def reset
      @result = {'encoding' =&gt; nil, 'confidence' =&gt; 0.0}
      @done = false
      @_mStart = true
      @_mGotData = false
      @_mInputState = EPureAscii
      @_mLastChar = ''
      if @_mEscCharSetProber
        @_mEscCharSetProber.reset()
      end
      for prober in @_mCharSetProbers
        prober.reset()
      end
    end

    def feed(aBuf)
      return if @done

      aLen = aBuf.length
      return if not aLen

      if not @_mGotData
        # If the data starts with BOM, we know it is UTF
        if aBuf[0...3] == &quot;\xEF\xBB\xBF&quot;
          # EF BB BF  UTF-8 with BOM
          @result = {'encoding' =&gt; &quot;UTF-8&quot;, 'confidence' =&gt; 1.0}
        elsif aBuf[0...4] == &quot;\xFF\xFE\x00\x00&quot;
          # FF FE 00 00  UTF-32, little-endian BOM
          @result = {'encoding' =&gt; &quot;UTF-32LE&quot;, 'confidence' =&gt; 1.0}
        elsif aBuf[0...4] == &quot;\x00\x00\xFE\xFF&quot;
          # 00 00 FE FF  UTF-32, big-endian BOM
          @result = {'encoding' =&gt; &quot;UTF-32BE&quot;, 'confidence' =&gt; 1.0}
        elsif aBuf[0...4] == &quot;\xFE\xFF\x00\x00&quot;
          # FE FF 00 00  UCS-4, unusual octet order BOM (3412)
          @result = {'encoding' =&gt; &quot;X-ISO-10646-UCS-4-3412&quot;, 'confidence' =&gt; 1.0}
        elsif aBuf[0...4] == &quot;\x00\x00\xFF\xFE&quot;
          # 00 00 FF FE  UCS-4, unusual octet order BOM (2143)
          @result = {'encoding' =&gt;  &quot;X-ISO-10646-UCS-4-2143&quot;, 'confidence' =&gt;  1.0}
        elsif aBuf[0...2] == &quot;\xFF\xFE&quot;
          # FF FE  UTF-16, little endian BOM
          @result = {'encoding' =&gt;  &quot;UTF-16LE&quot;, 'confidence' =&gt;  1.0}
        elsif aBuf[0...2] == &quot;\xFE\xFF&quot;
          # FE FF  UTF-16, big endian BOM
          @result = {'encoding' =&gt;  &quot;UTF-16BE&quot;, 'confidence' =&gt;  1.0}
        end
      end

      @_mGotData = true
      if @result['encoding'] and (@result['confidence'] &gt; 0.0)
        @done = true
        return
      end

      if @_mInputState == EPureAscii
        if @_highBitDetector =~ (aBuf)
          @_mInputState = EHighbyte
        elsif (@_mInputState == EPureAscii) and @_escDetector =~ (@_mLastChar + aBuf)
          @_mInputState = EEscAscii
        end
      end

      @_mLastChar = aBuf[-1..-1]
      if @_mInputState == EEscAscii
        if not @_mEscCharSetProber
          @_mEscCharSetProber = EscCharSetProber.new()
        end
        if @_mEscCharSetProber.feed(aBuf) == EFoundIt
          @result = {'encoding' =&gt;  self._mEscCharSetProber.get_charset_name(),
                     'confidence' =&gt;  @_mEscCharSetProber.get_confidence()
          }
          @done = true
        end
      elsif @_mInputState == EHighbyte
        if not @_mCharSetProbers or @_mCharSetProbers.empty?
          @_mCharSetProbers = [MBCSGroupProber.new(), SBCSGroupProber.new(), Latin1Prober.new()]
        end
        for prober in @_mCharSetProbers
          if prober.feed(aBuf) == EFoundIt
            @result = {'encoding' =&gt;  prober.get_charset_name(),
                       'confidence' =&gt;  prober.get_confidence()}
            @done = true
            break
          end
        end
      end

    end

    def close
      return if @done
      if not @_mGotData
        $stderr &lt;&lt; &quot;no data received!\n&quot; if $debug
        return
      end
      @done = true

      if @_mInputState == EPureAscii
        @result = {'encoding' =&gt; 'ascii', 'confidence' =&gt; 1.0}
        return @result
      end

      if @_mInputState == EHighbyte
        confidences = {}
        @_mCharSetProbers.each{ |prober| confidences[prober] = prober.get_confidence }
        maxProber = @_mCharSetProbers.max{ |a,b| confidences[a] &lt;=&gt; confidences[b] }
        if maxProber and maxProber.get_confidence &gt; MINIMUM_THRESHOLD
          @result = {'encoding' =&gt;  maxProber.get_charset_name(),
                     'confidence' =&gt;  maxProber.get_confidence()}
          return @result
        end
      end

      if $debug
        $stderr &lt;&lt; &quot;no probers hit minimum threshhold\n&quot; if $debug
        for prober in @_mCharSetProbers[0]._mProbers
          next if not prober
          $stderr &lt;&lt; &quot;#{prober.get_charset_name} confidence = #{prober.get_confidence}\n&quot; if $debug
        end
      end
    end
  end
end
</pre>
    </div>