<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: DL::CPtr</title>
<link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '..';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (C)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../DL.html" title="DL (module)">DL</a></span></span>
     &raquo; 
    <span class="title">CPtr</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: DL::CPtr
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">DL::CPtr</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">ext/dl/cptr.c</dd>
  
</dl>
<div class="clear"></div>




  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D-class_method" title="[] (class method)">+ (Object) <strong>[]</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Get the underlying pointer for ruby object <tt>val</tt> and return it as a
DL::CPtr object.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#DL%3A%3ACPtr.malloc-class_method" title="DL::CPtr.malloc (class method)">+ (Object) <strong>DL::CPtr.malloc</strong>(size, freefunc = nil) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Allocate <tt>size</tt> bytes of memory and associate it with an optional
<tt>freefunc</tt> that will be called when the pointer is garbage
collected.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_ptr-class_method" title="to_ptr (class method)">+ (Object) <strong>to_ptr</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Get the underlying pointer for ruby object <tt>val</tt> and return it as a
DL::CPtr object.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2B-instance_method" title="#+ (instance method)">- (Object) <strong>+</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new DL::CPtr that has been advanced <tt>n</tt> bytes.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ptr-instance_method" title="#ptr (instance method)">- (Object) <strong>ptr</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#--instance_method" title="#- (instance method)">- (Object) <strong>-</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new DL::CPtr that has been moved back <tt>n</tt> bytes.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ref-instance_method" title="#ref (instance method)">- (Object) <strong>ref</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a DL::CPtr that is a reference pointer for this DL::CPtr.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3D%3E-instance_method" title="#&lt;=&gt; (instance method)">- (-1, ...) <strong>&lt;=&gt;</strong>(other) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns -1 if less than, 0 if equal to, 1 if greater than <tt>other</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Object) <strong>==</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true if <tt>other</tt> wraps the same pointer, otherwise returns
false.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D-instance_method" title="#[] (instance method)">- (Object) <strong>[]</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns integer stored at <em>index</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D%3D-instance_method" title="#[]= (instance method)">- (Object) <strong>[]=</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set the value at <tt>index</tt> to <tt>int</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">- (Object) <strong>eql?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true if <tt>other</tt> wraps the same pointer, otherwise returns
false.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#free-instance_method" title="#free (instance method)">- (Object) <strong>free</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Get the free function for this pointer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#free%3D-instance_method" title="#free= (instance method)">- (Object) <strong>free=</strong>(function) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set the free function for this pointer to the DL::CFunc in
<tt>function</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Create a new pointer to <tt>address</tt> with an optional <tt>size</tt> and
<tt>freefunc</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (Object) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a string formatted with an easily readable representation of the
internal state of the DL::CPtr.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#null%3F-instance_method" title="#null? (instance method)">- (Object) <strong>null?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true if this is a null pointer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ptr-instance_method" title="#ptr (instance method)">- (Object) <strong>ptr</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ref-instance_method" title="#ref (instance method)">- (Object) <strong>ref</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a DL::CPtr that is a reference pointer for this DL::CPtr.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#size-instance_method" title="#size (instance method)">- (Object) <strong>size</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Get the size of this pointer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#size%3D-instance_method" title="#size= (instance method)">- (Object) <strong>size=</strong>(size) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set the size of this pointer to <tt>size</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_i-instance_method" title="#to_i (instance method)">- (Object) <strong>to_i</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the integer memory location of this DL::CPtr.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_i-instance_method" title="#to_i (instance method)">- (Object) <strong>to_i</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the integer memory location of this DL::CPtr.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">- (Object) <strong>to_s</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the pointer contents as a string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_str-instance_method" title="#to_str (instance method)">- (Object) <strong>to_str</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the pointer contents as a string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_value-instance_method" title="#to_value (instance method)">- (Object) <strong>to_value</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Cast this CPtr to a ruby object.
</p>
</div></span>
  
</li>

      
    </ul>
  

<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr.new</strong>(address) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr.new</strong>(address, size) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr.new</strong>(address, size, freefunc) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Create a new pointer to <tt>address</tt> with an optional <tt>size</tt> and
<tt>freefunc</tt>. <tt>freefunc</tt> will be called when the instance is
garbage collected.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *    DL::CPtr.new(address)                   =&gt; dl_cptr
 *    DL::CPtr.new(address, size)             =&gt; dl_cptr
 *    DL::CPtr.new(address, size, freefunc)   =&gt; dl_cptr
 *
 * Create a new pointer to +address+ with an optional +size+ and +freefunc+.
 * +freefunc+ will be called when the instance is garbage collected.
 */
static VALUE
rb_dlptr_initialize(int argc, VALUE argv[], VALUE self)
{
    VALUE ptr, sym, size;
    struct ptr_data *data;
    void *p = NULL;
    freefunc_t f = NULL;
    long s = 0;

    switch (rb_scan_args(argc, argv, &quot;12&quot;, &amp;ptr, &amp;size, &amp;sym)) {
      case 1:
    p = (void*)(NUM2PTR(rb_Integer(ptr)));
    break;
      case 2:
    p = (void*)(NUM2PTR(rb_Integer(ptr)));
    s = NUM2LONG(size);
    break;
      case 3:
    p = (void*)(NUM2PTR(rb_Integer(ptr)));
    s = NUM2LONG(size);
    f = get_freefunc(sym);
    break;
      default:
    rb_bug(&quot;rb_dlptr_initialize&quot;);
    }

    if (p) {
    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    if (data-&gt;ptr &amp;&amp; data-&gt;free) {
        /* Free previous memory. Use of inappropriate initialize may cause SEGV. */
        (*(data-&gt;free))(data-&gt;ptr);
    }
    data-&gt;ptr  = p;
    data-&gt;size = s;
    data-&gt;free = f;
    }

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="[]-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr.to_ptr</strong>(val) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Get the underlying pointer for ruby object <tt>val</tt> and return it as a
DL::CPtr object.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *    DL::CPtr.to_ptr(val)  =&gt; cptr
 *    DL::CPtr[val]         =&gt; cptr
 *
 * Get the underlying pointer for ruby object +val+ and return it as a
 * DL::CPtr object.
 */
static VALUE
rb_dlptr_s_to_ptr(VALUE self, VALUE val)
{
    VALUE ptr;

    if (RTEST(rb_obj_is_kind_of(val, rb_cIO))){
    rb_io_t *fptr;
    FILE *fp;
    GetOpenFile(val, fptr);
    fp = rb_io_stdio_file(fptr);
    ptr = rb_dlptr_new(fp, 0, NULL);
    }
    else if (RTEST(rb_obj_is_kind_of(val, rb_cString))){
    char *str = StringValuePtr(val);
    ptr = rb_dlptr_new(str, RSTRING_LEN(val), NULL);
    }
    else if (rb_respond_to(val, id_to_ptr)){
    VALUE vptr = rb_funcall(val, id_to_ptr, 0);
    if (rb_obj_is_kind_of(vptr, rb_cDLCPtr)){
        ptr = vptr;
    }
    else{
        rb_raise(rb_eDLError, &quot;to_ptr should return a CPtr object&quot;);
    }
    }
    else{
    ptr = rb_dlptr_new(NUM2PTR(rb_Integer(val)), 0, NULL);
    }
    OBJ_INFECT(ptr, val);
    rb_iv_set(ptr, &quot;wrapping&quot;, val);
    return ptr;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="malloc-class_method">
  
    + (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr.malloc</strong>(size, freefunc = nil) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Allocate <tt>size</tt> bytes of memory and associate it with an optional
<tt>freefunc</tt> that will be called when the pointer is garbage
collected. <tt>freefunc</tt> must be an address pointing to a function or
an instance of DL::CFunc
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *
 *    DL::CPtr.malloc(size, freefunc = nil)  =&gt; dl cptr instance
 *
 * Allocate +size+ bytes of memory and associate it with an optional
 * +freefunc+ that will be called when the pointer is garbage collected.
 * +freefunc+ must be an address pointing to a function or an instance of
 * DL::CFunc
 */
static VALUE
rb_dlptr_s_malloc(int argc, VALUE argv[], VALUE klass)
{
    VALUE size, sym, obj;
    long s;
    freefunc_t f;

    switch (rb_scan_args(argc, argv, &quot;11&quot;, &amp;size, &amp;sym)) {
      case 1:
    s = NUM2LONG(size);
    f = NULL;
    break;
      case 2:
    s = NUM2LONG(size);
    f = get_freefunc(sym);
    break;
      default:
    rb_bug(&quot;rb_dlptr_s_malloc&quot;);
    }

    obj = rb_dlptr_malloc(s,f);

    return obj;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_ptr-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr.to_ptr</strong>(val) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>DL::CPtr</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Get the underlying pointer for ruby object <tt>val</tt> and return it as a
DL::CPtr object.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *    DL::CPtr.to_ptr(val)  =&gt; cptr
 *    DL::CPtr[val]         =&gt; cptr
 *
 * Get the underlying pointer for ruby object +val+ and return it as a
 * DL::CPtr object.
 */
static VALUE
rb_dlptr_s_to_ptr(VALUE self, VALUE val)
{
    VALUE ptr;

    if (RTEST(rb_obj_is_kind_of(val, rb_cIO))){
    rb_io_t *fptr;
    FILE *fp;
    GetOpenFile(val, fptr);
    fp = rb_io_stdio_file(fptr);
    ptr = rb_dlptr_new(fp, 0, NULL);
    }
    else if (RTEST(rb_obj_is_kind_of(val, rb_cString))){
    char *str = StringValuePtr(val);
    ptr = rb_dlptr_new(str, RSTRING_LEN(val), NULL);
    }
    else if (rb_respond_to(val, id_to_ptr)){
    VALUE vptr = rb_funcall(val, id_to_ptr, 0);
    if (rb_obj_is_kind_of(vptr, rb_cDLCPtr)){
        ptr = vptr;
    }
    else{
        rb_raise(rb_eDLError, &quot;to_ptr should return a CPtr object&quot;);
    }
    }
    else{
    ptr = rb_dlptr_new(NUM2PTR(rb_Integer(val)), 0, NULL);
    }
    OBJ_INFECT(ptr, val);
    rb_iv_set(ptr, &quot;wrapping&quot;, val);
    return ptr;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="+-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>+</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new DL::CPtr that has been advanced <tt>n</tt> bytes.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *    ptr + n   =&gt; new cptr
 *
 * Returns a new DL::CPtr that has been advanced +n+ bytes.
 */
static VALUE
rb_dlptr_plus(VALUE self, VALUE other)
{
    void *ptr;
    long num, size;

    ptr = rb_dlptr2cptr(self);
    size = RPTR_DATA(self)-&gt;size;
    num = NUM2LONG(other);
    return rb_dlptr_new((char *)ptr + num, size - num, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="+@-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>ptr</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.
Analogous to the star operator in C.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: ptr
 *
 * Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.
 * Analogous to the star operator in C.
 */
VALUE
rb_dlptr_ptr(VALUE self)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return rb_dlptr_new(*((void**)(data-&gt;ptr)),0,0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="--instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>-</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new DL::CPtr that has been moved back <tt>n</tt> bytes.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *    ptr - n   =&gt; new cptr
 *
 * Returns a new DL::CPtr that has been moved back +n+ bytes.
 */
static VALUE
rb_dlptr_minus(VALUE self, VALUE other)
{
    void *ptr;
    long num, size;

    ptr = rb_dlptr2cptr(self);
    size = RPTR_DATA(self)-&gt;size;
    num = NUM2LONG(other);
    return rb_dlptr_new((char *)ptr - num, size + num, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="-@-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>ref</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous
to the ampersand operator in C.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: ref
 *
 * Returns a DL::CPtr that is a reference pointer for this DL::CPtr.
 * Analogous to the ampersand operator in C.
 */
VALUE
rb_dlptr_ref(VALUE self)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return rb_dlptr_new(&amp;(data-&gt;ptr),0,0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<=>-instance_method">
  
    - (<tt>-1</tt>, ...) <strong>&lt;=&gt;</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns -1 if less than, 0 if equal to, 1 if greater than <tt>other</tt>. 
Returns nil if <tt>ptr</tt> cannot be compared to <tt>other</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>-1</tt>, <tt>0</tt>, <tt>1</tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 *  call-seq:
 *    ptr &lt;=&gt; other   =&gt; -1, 0, 1, or nil
 *
 * Returns -1 if less than, 0 if equal to, 1 if greater than +other+.  Returns
 * nil if +ptr+ cannot be compared to +other+.
 */
static VALUE
rb_dlptr_cmp(VALUE self, VALUE other)
{
    void *ptr1, *ptr2;
    SIGNED_VALUE diff;

    if(!rb_obj_is_kind_of(other, rb_cDLCPtr)) return Qnil;

    ptr1 = rb_dlptr2cptr(self);
    ptr2 = rb_dlptr2cptr(other);
    diff = (SIGNED_VALUE)ptr1 - (SIGNED_VALUE)ptr2;
    if (!diff) return INT2FIX(0);
    return diff &gt; 0 ? INT2NUM(1) : INT2NUM(-1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="==-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>==</strong>(other) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eql?</strong>(other) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true if <tt>other</tt> wraps the same pointer, otherwise returns
false.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>==</strong>(other) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eql?</strong>(other) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 *  call-seq:
 *    ptr == other    =&gt; true or false
 *    ptr.eql?(other) =&gt; true or false
 *
 * Returns true if +other+ wraps the same pointer, otherwise returns
 * false.
 */
VALUE
rb_dlptr_eql(VALUE self, VALUE other)
{
    void *ptr1, *ptr2;

    if(!rb_obj_is_kind_of(other, rb_cDLCPtr)) return Qfalse;

    ptr1 = rb_dlptr2cptr(self);
    ptr2 = rb_dlptr2cptr(other);

    return ptr1 == ptr2 ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>[]</strong>(index) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>[]</strong>(start, length) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns integer stored at <em>index</em>.  If <em>start</em> and
<em>length</em> are given, a string containing the bytes from
<em>start</em> of length <em>length</em> will be returned.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>[]</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>[]</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 *  call-seq:
 *     ptr[index]                -&gt; an_integer
 *     ptr[start, length]        -&gt; a_string
 *
 * Returns integer stored at _index_.  If _start_ and _length_ are given,
 * a string containing the bytes from _start_ of length _length_ will be
 * returned.
 */
VALUE
rb_dlptr_aref(int argc, VALUE argv[], VALUE self)
{
    VALUE arg0, arg1;
    VALUE retval = Qnil;
    size_t offset, len;

    switch( rb_scan_args(argc, argv, &quot;11&quot;, &amp;arg0, &amp;arg1) ){
      case 1:
    offset = NUM2ULONG(arg0);
    retval = INT2NUM(*((char*)RPTR_DATA(self)-&gt;ptr + offset));
    break;
      case 2:
    offset = NUM2ULONG(arg0);
    len    = NUM2ULONG(arg1);
    retval = rb_tainted_str_new((char *)RPTR_DATA(self)-&gt;ptr + offset, len);
    break;
      default:
    rb_bug(&quot;rb_dlptr_aref()&quot;);
    }
    return retval;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]=-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>[]=</strong>(index) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>[]=</strong>(start, length) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set the value at <tt>index</tt> to <tt>int</tt>.  Or, set the memory at
<tt>start</tt> until <tt>length</tt> with the contents of <tt>string</tt>,
the memory from <tt>dl_cptr</tt>, or the memory pointed at by the memory
address <tt>addr</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>[]=</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>[]=</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 *  call-seq:
 *     ptr[index]         = int                    -&gt;  int
 *     ptr[start, length] = string or cptr or addr -&gt;  string or dl_cptr or addr
 *
 * Set the value at +index+ to +int+.  Or, set the memory at +start+ until
 * +length+ with the contents of +string+, the memory from +dl_cptr+, or the
 * memory pointed at by the memory address +addr+.
 */
VALUE
rb_dlptr_aset(int argc, VALUE argv[], VALUE self)
{
    VALUE arg0, arg1, arg2;
    VALUE retval = Qnil;
    size_t offset, len;
    void *mem;

    switch( rb_scan_args(argc, argv, &quot;21&quot;, &amp;arg0, &amp;arg1, &amp;arg2) ){
      case 2:
    offset = NUM2ULONG(arg0);
    ((char*)RPTR_DATA(self)-&gt;ptr)[offset] = NUM2UINT(arg1);
    retval = arg1;
    break;
      case 3:
    offset = NUM2ULONG(arg0);
    len    = NUM2ULONG(arg1);
    if( TYPE(arg2) == T_STRING ){
        mem = StringValuePtr(arg2);
    }
    else if( rb_obj_is_kind_of(arg2, rb_cDLCPtr) ){
        mem = rb_dlptr2cptr(arg2);
    }
    else{
        mem    = NUM2PTR(arg2);
    }
    memcpy((char *)RPTR_DATA(self)-&gt;ptr + offset, mem, len);
    retval = arg2;
    break;
      default:
    rb_bug(&quot;rb_dlptr_aset()&quot;);
    }
    return retval;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eql?-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>==</strong>(other) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eql?</strong>(other) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true if <tt>other</tt> wraps the same pointer, otherwise returns
false.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>==</strong>(other) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eql?</strong>(other) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 *  call-seq:
 *    ptr == other    =&gt; true or false
 *    ptr.eql?(other) =&gt; true or false
 *
 * Returns true if +other+ wraps the same pointer, otherwise returns
 * false.
 */
VALUE
rb_dlptr_eql(VALUE self, VALUE other)
{
    void *ptr1, *ptr2;

    if(!rb_obj_is_kind_of(other, rb_cDLCPtr)) return Qfalse;

    ptr1 = rb_dlptr2cptr(self);
    ptr2 = rb_dlptr2cptr(other);

    return ptr1 == ptr2 ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="free-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>free</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Get the free function for this pointer.  Returns  DL::CFunc or nil.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: free
 *
 * Get the free function for this pointer.  Returns  DL::CFunc or nil.
 */
static VALUE
rb_dlptr_free_get(VALUE self)
{
    struct ptr_data *pdata;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, pdata);

    return rb_dlcfunc_new(pdata-&gt;free, DLTYPE_VOID, &quot;free&lt;anonymous&gt;&quot;, CFUNC_CDECL);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="free=-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>free=</strong>(function) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set the free function for this pointer to the DL::CFunc in
<tt>function</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: free=(function)
 *
 * Set the free function for this pointer to the DL::CFunc in +function+.
 */
static VALUE
rb_dlptr_free_set(VALUE self, VALUE val)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    data-&gt;free = get_freefunc(val);

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>inspect</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a string formatted with an easily readable representation of the
internal state of the DL::CPtr
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: inspect
 *
 * Returns a string formatted with an easily readable representation of the
 * internal state of the DL::CPtr
 */
static VALUE
rb_dlptr_inspect(VALUE self)
{
    struct ptr_data *data;
    char str[1024];

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    snprintf(str, 1023, &quot;#&lt;%s:%p ptr=%p size=%ld free=%p&gt;&quot;,
         rb_class2name(CLASS_OF(self)), data, data-&gt;ptr, data-&gt;size, data-&gt;free);
    return rb_str_new2(str);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="null?-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>null?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true if this is a null pointer.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: null?
 *
 * Returns true if this is a null pointer.
 */
VALUE
rb_dlptr_null_p(VALUE self)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return data-&gt;ptr ? Qfalse : Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ptr-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>ptr</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.
Analogous to the star operator in C.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: ptr
 *
 * Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr.
 * Analogous to the star operator in C.
 */
VALUE
rb_dlptr_ptr(VALUE self)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return rb_dlptr_new(*((void**)(data-&gt;ptr)),0,0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ref-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>ref</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous
to the ampersand operator in C.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: ref
 *
 * Returns a DL::CPtr that is a reference pointer for this DL::CPtr.
 * Analogous to the ampersand operator in C.
 */
VALUE
rb_dlptr_ref(VALUE self)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return rb_dlptr_new(&amp;(data-&gt;ptr),0,0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="size-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>size</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Get the size of this pointer.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: size
 *
 * Get the size of this pointer.
 */
static VALUE
rb_dlptr_size_get(VALUE self)
{
    return LONG2NUM(RPTR_DATA(self)-&gt;size);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="size=-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>size=</strong>(size) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set the size of this pointer to <tt>size</tt>
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: size=(size)
 *
 * Set the size of this pointer to +size+
 */
static VALUE
rb_dlptr_size_set(VALUE self, VALUE size)
{
    RPTR_DATA(self)-&gt;size = NUM2LONG(size);
    return size;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_i-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_i</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the integer memory location of this DL::CPtr.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: to_i
 *
 * Returns the integer memory location of this DL::CPtr.
 */
static VALUE
rb_dlptr_to_i(VALUE self)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return PTR2NUM(data-&gt;ptr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_int-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_i</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the integer memory location of this DL::CPtr.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: to_i
 *
 * Returns the integer memory location of this DL::CPtr.
 */
static VALUE
rb_dlptr_to_i(VALUE self)
{
    struct ptr_data *data;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return PTR2NUM(data-&gt;ptr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_s-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong>(len) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the pointer contents as a string.  When called with no arguments,
this method will return the contents until the first NULL byte.  When
called with <tt>len</tt>, a string of <tt>len</tt> bytes will be returned.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong>(len) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *
 *    ptr.to_s        =&gt; string
 *    ptr.to_s(len)   =&gt; string
 *
 * Returns the pointer contents as a string.  When called with no arguments,
 * this method will return the contents until the first NULL byte.  When
 * called with +len+, a string of +len+ bytes will be returned.
 */
static VALUE
rb_dlptr_to_s(int argc, VALUE argv[], VALUE self)
{
    struct ptr_data *data;
    VALUE arg1, val;
    int len;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    switch (rb_scan_args(argc, argv, &quot;01&quot;, &amp;arg1)) {
      case 0:
    val = rb_tainted_str_new2((char*)(data-&gt;ptr));
    break;
      case 1:
    len = NUM2INT(arg1);
    val = rb_tainted_str_new((char*)(data-&gt;ptr), len);
    break;
      default:
    rb_bug(&quot;rb_dlptr_to_s&quot;);
    }

    return val;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_str-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_str</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_str</strong>(len) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the pointer contents as a string.  When called with no arguments,
this method will return the contents with the length of this
pointer&#8217;s <tt>size</tt>. When called with <tt>len</tt>, a string of
<tt>len</tt> bytes will be returned.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_str</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>to_str</strong>(len) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq:
 *
 *    ptr.to_str        =&gt; string
 *    ptr.to_str(len)   =&gt; string
 *
 * Returns the pointer contents as a string.  When called with no arguments,
 * this method will return the contents with the length of this pointer's
 * +size+. When called with +len+, a string of +len+ bytes will be returned.
 */
static VALUE
rb_dlptr_to_str(int argc, VALUE argv[], VALUE self)
{
    struct ptr_data *data;
    VALUE arg1, val;
    int len;

    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    switch (rb_scan_args(argc, argv, &quot;01&quot;, &amp;arg1)) {
      case 0:
    val = rb_tainted_str_new((char*)(data-&gt;ptr),data-&gt;size);
    break;
      case 1:
    len = NUM2INT(arg1);
    val = rb_tainted_str_new((char*)(data-&gt;ptr), len);
    break;
      default:
    rb_bug(&quot;rb_dlptr_to_str&quot;);
    }

    return val;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_value-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_value</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Cast this CPtr to a ruby object.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/dl/cptr.c'</span>

/*
 * call-seq: to_value
 *
 * Cast this CPtr to a ruby object.
 */
static VALUE
rb_dlptr_to_value(VALUE self)
{
    struct ptr_data *data;
    TypedData_Get_Struct(self, struct ptr_data, &amp;dlptr_data_type, data);
    return (VALUE)(data-&gt;ptr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:01:50 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>