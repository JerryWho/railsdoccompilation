<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Addrinfo</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (A)</a> &raquo; 
    
    
    <span class="title">Addrinfo</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Addrinfo
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Data</span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Data</li>
          
            <li class="next">Addrinfo</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">ext/socket/raddrinfo.c</dd>
  
</dl>
<div class="clear"></div>



  

  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getaddrinfo-class_method" title="getaddrinfo (class method)">+ (Object) <strong>getaddrinfo</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns a list of addrinfo objects as an array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ip-class_method" title="ip (class method)">+ (Object) <strong>ip</strong>(host) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns an addrinfo object for IP address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tcp-class_method" title="tcp (class method)">+ (Object) <strong>tcp</strong>(host, port) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns an addrinfo object for TCP address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#udp-class_method" title="udp (class method)">+ (Object) <strong>udp</strong>(host, port) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns an addrinfo object for UDP address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unix-class_method" title="unix (class method)">+ (Object) <strong>unix</strong>(path[, socktype]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns an addrinfo object for UNIX socket address.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#afamily-instance_method" title="#afamily (instance method)">- (Integer) <strong>afamily</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the address family as an integer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#canonname-instance_method" title="#canonname (instance method)">- (String<sup>?</sup>) <strong>canonname</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the canonical name as an string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getnameinfo-instance_method" title="#getnameinfo (instance method)">- (Object) <strong>getnameinfo</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns nodename and service as a pair of strings.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns a new instance of Addrinfo.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns a string which shows addrinfo in human-readable form.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect_sockaddr-instance_method" title="#inspect_sockaddr (instance method)">- (String) <strong>inspect_sockaddr</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns a string which shows the sockaddr in <em>addrinfo</em> with
human-readable form.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ip%3F-instance_method" title="#ip? (instance method)">- (Boolean) <strong>ip?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns true if addrinfo is internet (IPv4/IPv6) address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ip_address-instance_method" title="#ip_address (instance method)">- (String) <strong>ip_address</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the IP address as a string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ip_port-instance_method" title="#ip_port (instance method)">- (Object) <strong>ip_port</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the port number as an integer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ip_unpack-instance_method" title="#ip_unpack (instance method)">- (Array) <strong>ip_unpack</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the IP address and port number as 2-element array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv4%3F-instance_method" title="#ipv4? (instance method)">- (Boolean) <strong>ipv4?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns true if addrinfo is IPv4 address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv4_loopback%3F-instance_method" title="#ipv4_loopback? (instance method)">- (Object) <strong>ipv4_loopback?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv4 loopback address (127.0.0.0/8).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv4_multicast%3F-instance_method" title="#ipv4_multicast? (instance method)">- (Object) <strong>ipv4_multicast?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv4 multicast address (224.0.0.0/4).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv4_private%3F-instance_method" title="#ipv4_private? (instance method)">- (Object) <strong>ipv4_private?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12,
192.168.0.0/16).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6%3F-instance_method" title="#ipv6? (instance method)">- (Boolean) <strong>ipv6?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns true if addrinfo is IPv6 address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_linklocal%3F-instance_method" title="#ipv6_linklocal? (instance method)">- (Object) <strong>ipv6_linklocal?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 link local address (ff80::/10).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_loopback%3F-instance_method" title="#ipv6_loopback? (instance method)">- (Object) <strong>ipv6_loopback?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 loopback address (::1).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_mc_global%3F-instance_method" title="#ipv6_mc_global? (instance method)">- (Object) <strong>ipv6_mc_global?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 multicast global scope address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_mc_linklocal%3F-instance_method" title="#ipv6_mc_linklocal? (instance method)">- (Object) <strong>ipv6_mc_linklocal?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 multicast link-local scope address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_mc_nodelocal%3F-instance_method" title="#ipv6_mc_nodelocal? (instance method)">- (Object) <strong>ipv6_mc_nodelocal?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 multicast node-local scope address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_mc_orglocal%3F-instance_method" title="#ipv6_mc_orglocal? (instance method)">- (Object) <strong>ipv6_mc_orglocal?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 multicast organization-local scope address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_mc_sitelocal%3F-instance_method" title="#ipv6_mc_sitelocal? (instance method)">- (Object) <strong>ipv6_mc_sitelocal?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 multicast site-local scope address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_multicast%3F-instance_method" title="#ipv6_multicast? (instance method)">- (Object) <strong>ipv6_multicast?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 multicast address (ff00::/8).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_sitelocal%3F-instance_method" title="#ipv6_sitelocal? (instance method)">- (Object) <strong>ipv6_sitelocal?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 site local address (ffc0::/10).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_to_ipv4-instance_method" title="#ipv6_to_ipv4 (instance method)">- (Object) <strong>ipv6_to_ipv4</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns IPv4 address of IPv4 mapped/compatible IPv6 address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_unspecified%3F-instance_method" title="#ipv6_unspecified? (instance method)">- (Object) <strong>ipv6_unspecified?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv6 unspecified address (::).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_v4compat%3F-instance_method" title="#ipv6_v4compat? (instance method)">- (Object) <strong>ipv6_v4compat?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv4-compatible IPv6 address (::/80).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ipv6_v4mapped%3F-instance_method" title="#ipv6_v4mapped? (instance method)">- (Object) <strong>ipv6_v4mapped?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#marshal_dump-instance_method" title="#marshal_dump (instance method)">- (Object) <strong>marshal_dump</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#marshal_load-instance_method" title="#marshal_load (instance method)">- (Object) <strong>marshal_load</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pfamily-instance_method" title="#pfamily (instance method)">- (Integer) <strong>pfamily</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the protocol family as an integer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#protocol-instance_method" title="#protocol (instance method)">- (Integer) <strong>protocol</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the socket type as an integer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#socktype-instance_method" title="#socktype (instance method)">- (Integer) <strong>socktype</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the socket type as an integer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_sockaddr-instance_method" title="#to_sockaddr (instance method)">- (String) <strong>to_sockaddr</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the socket address as packed struct sockaddr string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_sockaddr-instance_method" title="#to_sockaddr (instance method)">- (String) <strong>to_sockaddr</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the socket address as packed struct sockaddr string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unix%3F-instance_method" title="#unix? (instance method)">- (Boolean) <strong>unix?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns true if addrinfo is UNIX address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unix_path-instance_method" title="#unix_path (instance method)">- (Object) <strong>unix_path</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the socket path as a string.
</p>
</div></span>
  
</li>

      
    </ul>
  


  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(sockaddr) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(sockaddr, family) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(sockaddr, family, socktype) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(sockaddr, family, socktype, protocol) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns a new instance of Addrinfo. The instance contains sockaddr, family,
socktype, protocol. sockaddr means struct sockaddr which can be used for
connect(2), etc. family, socktype and protocol are integers which is used
for arguments of socket(2).
</p>
<p>
sockaddr is specified as an array or a string. The array should be
compatible to the value of IPSocket#addr or UNIXSocket#addr. The string
should be struct sockaddr as generated by Socket.sockaddr_in or
Socket.unpack_sockaddr_un.
</p>
<p>
sockaddr examples:
</p>
<ul>
<li><dl>
<dt>&#8220;AF_INET&#8221;, 46102, &#8220;localhost.localdomain&#8221;, &#8220;127.0.0.1&#8220;</dt><dd></dd>
</dl>
</li>
<li><dl>
<dt>&#8220;AF_INET6&#8221;, 42304, &#8220;ip6-localhost&#8221;, &#8220;::1&#8220;</dt><dd></dd>
</dl>
</li>
<li><dl>
<dt>&#8220;AF_UNIX&#8221;, &#8220;/tmp/sock&#8220;</dt><dd></dd>
</dl>
</li>
<li><p>
Socket.sockaddr_in(&#8220;smtp&#8221;, &#8220;2001:DB8::1&#8221;)
</p>
</li>
<li><p>
Socket.sockaddr_in(80, &#8220;172.18.22.42&#8221;)
</p>
</li>
<li><p>
Socket.sockaddr_in(80, &#8220;<a
href="http://www.ruby-lang.org">www.ruby-lang.org</a>&#8220;)
</p>
</li>
<li><p>
Socket.sockaddr_un(&#8220;/tmp/sock&#8221;)
</p>
</li>
</ul>
<p>
In an AF_INET/AF_INET6 sockaddr array, the 4th element, numeric IP address,
is used to construct socket address in the Addrinfo instance. If the 3rd
element, textual host name, is non-nil, it is also recorded but used only
for Addrinfo#inspect.
</p>
<p>
family is specified as an integer to specify the protocol family such as
Socket::PF_INET. It can be a symbol or a string which is the constant name
with or without PF_ prefix such as :INET, :INET6, :UNIX,
&#8220;PF_INET&#8221;, etc. If omitted, PF_UNSPEC is assumed.
</p>
<p>
socktype is specified as an integer to specify the socket type such as
Socket::SOCK_STREAM. It can be a symbol or a string which is the constant
name with or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW,
&#8220;SOCK_STREAM&#8221;, etc. If omitted, 0 is assumed.
</p>
<p>
protocol is specified as an integer to specify the protocol such as
Socket::IPPROTO_TCP. It must be an integer, unlike family and socktype. If
omitted, 0 is assumed. Note that 0 is reasonable value for most protocols,
except raw socket.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   Addrinfo.new(sockaddr)                             =&gt; addrinfo
 *   Addrinfo.new(sockaddr, family)                     =&gt; addrinfo
 *   Addrinfo.new(sockaddr, family, socktype)           =&gt; addrinfo
 *   Addrinfo.new(sockaddr, family, socktype, protocol) =&gt; addrinfo
 *
 * returns a new instance of Addrinfo.
 * The instance contains sockaddr, family, socktype, protocol.
 * sockaddr means struct sockaddr which can be used for connect(2), etc.
 * family, socktype and protocol are integers which is used for arguments of socket(2).
 *
 * sockaddr is specified as an array or a string.
 * The array should be compatible to the value of IPSocket#addr or UNIXSocket#addr.
 * The string should be struct sockaddr as generated by
 * Socket.sockaddr_in or Socket.unpack_sockaddr_un.
 *
 * sockaddr examples:
 * - [&quot;AF_INET&quot;, 46102, &quot;localhost.localdomain&quot;, &quot;127.0.0.1&quot;]
 * - [&quot;AF_INET6&quot;, 42304, &quot;ip6-localhost&quot;, &quot;::1&quot;]
 * - [&quot;AF_UNIX&quot;, &quot;/tmp/sock&quot;]
 * - Socket.sockaddr_in(&quot;smtp&quot;, &quot;2001:DB8::1&quot;)
 * - Socket.sockaddr_in(80, &quot;172.18.22.42&quot;)
 * - Socket.sockaddr_in(80, &quot;www.ruby-lang.org&quot;)
 * - Socket.sockaddr_un(&quot;/tmp/sock&quot;)
 *
 * In an AF_INET/AF_INET6 sockaddr array, the 4th element,
 * numeric IP address, is used to construct socket address in the Addrinfo instance.
 * If the 3rd element, textual host name, is non-nil, it is also recorded but used only for Addrinfo#inspect.
 *
 * family is specified as an integer to specify the protocol family such as Socket::PF_INET.
 * It can be a symbol or a string which is the constant name
 * with or without PF_ prefix such as :INET, :INET6, :UNIX, &quot;PF_INET&quot;, etc.
 * If omitted, PF_UNSPEC is assumed.
 *
 * socktype is specified as an integer to specify the socket type such as Socket::SOCK_STREAM.
 * It can be a symbol or a string which is the constant name
 * with or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW, &quot;SOCK_STREAM&quot;, etc.
 * If omitted, 0 is assumed.
 *
 * protocol is specified as an integer to specify the protocol such as Socket::IPPROTO_TCP.
 * It must be an integer, unlike family and socktype.
 * If omitted, 0 is assumed.
 * Note that 0 is reasonable value for most protocols, except raw socket.
 *
 */
static VALUE
addrinfo_initialize(int argc, VALUE *argv, VALUE self)
{
    rb_addrinfo_t *rai;
    VALUE sockaddr_arg, sockaddr_ary, pfamily, socktype, protocol;
    int i_pfamily, i_socktype, i_protocol;
    struct sockaddr *sockaddr_ptr;
    socklen_t sockaddr_len;
    VALUE canonname = Qnil, inspectname = Qnil;

    if (check_addrinfo(self))
        rb_raise(rb_eTypeError, &quot;already initialized socket address&quot;);
    DATA_PTR(self) = rai = alloc_addrinfo();

    rb_scan_args(argc, argv, &quot;13&quot;, &amp;sockaddr_arg, &amp;pfamily, &amp;socktype, &amp;protocol);

    i_pfamily = NIL_P(pfamily) ? PF_UNSPEC : rsock_family_arg(pfamily);
    i_socktype = NIL_P(socktype) ? 0 : rsock_socktype_arg(socktype);
    i_protocol = NIL_P(protocol) ? 0 : NUM2INT(protocol);

    sockaddr_ary = rb_check_array_type(sockaddr_arg);
    if (!NIL_P(sockaddr_ary)) {
        VALUE afamily = rb_ary_entry(sockaddr_ary, 0);
        int af;
        StringValue(afamily);
        if (rsock_family_to_int(RSTRING_PTR(afamily), RSTRING_LEN(afamily), &amp;af) == -1)
        rb_raise(rb_eSocket, &quot;unknown address family: %s&quot;, StringValueCStr(afamily));
        switch (af) {
          case AF_INET: /* [&quot;AF_INET&quot;, 46102, &quot;localhost.localdomain&quot;, &quot;127.0.0.1&quot;] */
#ifdef INET6
          case AF_INET6: /* [&quot;AF_INET6&quot;, 42304, &quot;ip6-localhost&quot;, &quot;::1&quot;] */
#endif
          {
            VALUE service = rb_ary_entry(sockaddr_ary, 1);
            VALUE nodename = rb_ary_entry(sockaddr_ary, 2);
            VALUE numericnode = rb_ary_entry(sockaddr_ary, 3);
            int flags;

            service = INT2NUM(NUM2INT(service));
            if (!NIL_P(nodename))
                StringValue(nodename);
            StringValue(numericnode);
            flags = AI_NUMERICHOST;
#ifdef AI_NUMERICSERV
            flags |= AI_NUMERICSERV;
#endif

            init_addrinfo_getaddrinfo(rai, numericnode, service,
                    INT2NUM(i_pfamily ? i_pfamily : af), INT2NUM(i_socktype), INT2NUM(i_protocol),
                    INT2NUM(flags),
                    nodename, service);
            break;
          }

#ifdef HAVE_SYS_UN_H
          case AF_UNIX: /* [&quot;AF_UNIX&quot;, &quot;/tmp/sock&quot;] */
          {
            VALUE path = rb_ary_entry(sockaddr_ary, 1);
            StringValue(path);
            init_unix_addrinfo(rai, path, SOCK_STREAM);
            break;
          }
#endif

          default:
            rb_raise(rb_eSocket, &quot;unexpected address family&quot;);
        }
    }
    else {
        StringValue(sockaddr_arg);
        sockaddr_ptr = (struct sockaddr *)RSTRING_PTR(sockaddr_arg);
        sockaddr_len = RSTRING_LENINT(sockaddr_arg);
        init_addrinfo(rai, sockaddr_ptr, sockaddr_len,
                      i_pfamily, i_socktype, i_protocol,
                      canonname, inspectname);
    }

    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="getaddrinfo-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family, socktype, protocol, flags) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family, socktype, protocol) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family, socktype) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns a list of addrinfo objects as an array.
</p>
<p>
This method converts nodename (hostname) and service (port) to addrinfo.
Since the conversion is not unique, the result is a list of addrinfo
objects.
</p>
<p>
nodename or service can be nil if no conversion intended.
</p>
<p>
family, socktype and protocol are hint for preferred protocol. If the
result will be used for a socket with SOCK_STREAM, SOCK_STREAM should be
specified as socktype. If so, Addrinfo.getaddrinfo returns addrinfo list
appropriate for SOCK_STREAM. If they are omitted or nil is given, the
result is not restricted.
</p>
<p>
Similarly, PF_INET6 as family restricts for IPv6.
</p>
<p>
flags should be bitwise OR of Socket::AI_??? constants.
</p>
<p>
Note that socktype should be specified whenever application knows the usage
of the address. Some platform causes an error when socktype is omitted and
servname is specified as an integer because some port numbers, 512 for
example, are ambiguous without socktype.
</p>
<pre class="code">
  Addrinfo.getaddrinfo(&quot;www.kame.net&quot;, 80, nil, :STREAM)
  #=&gt; [#&lt;Addrinfo: 203.178.141.194:80 TCP (www.kame.net:80)&gt;,
  #    #&lt;Addrinfo: [2001:200:0:8002:203:47ff:fea5:3085]:80 TCP (www.kame.net:80)&gt;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family, socktype, protocol, flags) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family, socktype, protocol) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family, socktype) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service, family) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, service) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol, flags) =&gt; [addrinfo, ...]
 *   Addrinfo.getaddrinfo(nodename, service, family, socktype, protocol)        =&gt; [addrinfo, ...]
 *   Addrinfo.getaddrinfo(nodename, service, family, socktype)                  =&gt; [addrinfo, ...]
 *   Addrinfo.getaddrinfo(nodename, service, family)                            =&gt; [addrinfo, ...]
 *   Addrinfo.getaddrinfo(nodename, service)                                    =&gt; [addrinfo, ...]
 *
 * returns a list of addrinfo objects as an array.
 *
 * This method converts nodename (hostname) and service (port) to addrinfo.
 * Since the conversion is not unique, the result is a list of addrinfo objects.
 *
 * nodename or service can be nil if no conversion intended.
 *
 * family, socktype and protocol are hint for preferred protocol.
 * If the result will be used for a socket with SOCK_STREAM,
 * SOCK_STREAM should be specified as socktype.
 * If so, Addrinfo.getaddrinfo returns addrinfo list appropriate for SOCK_STREAM.
 * If they are omitted or nil is given, the result is not restricted.
 *
 * Similarly, PF_INET6 as family restricts for IPv6.
 *
 * flags should be bitwise OR of Socket::AI_??? constants.
 *
 * Note that socktype should be specified whenever application knows the usage of the address.
 * Some platform causes an error when socktype is omitted and servname is specified as an integer
 * because some port numbers, 512 for example, are ambiguous without socktype.
 *
 *   Addrinfo.getaddrinfo(&quot;www.kame.net&quot;, 80, nil, :STREAM)
 *   #=&gt; [#&lt;Addrinfo: 203.178.141.194:80 TCP (www.kame.net:80)&gt;,
 *   #    #&lt;Addrinfo: [2001:200:0:8002:203:47ff:fea5:3085]:80 TCP (www.kame.net:80)&gt;]
 *
 */
static VALUE
addrinfo_s_getaddrinfo(int argc, VALUE *argv, VALUE self)
{
    VALUE node, service, family, socktype, protocol, flags;

    rb_scan_args(argc, argv, &quot;24&quot;, &amp;node, &amp;service, &amp;family, &amp;socktype, &amp;protocol, &amp;flags);
    return addrinfo_list_new(node, service, family, socktype, protocol, flags);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ip-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ip</strong>(host) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns an addrinfo object for IP address.
</p>
<p>
The port, socktype, protocol of the result is filled by zero. So, it is not
appropriate to create a socket.
</p>
<pre class="code">
  Addrinfo.ip(&quot;localhost&quot;) #=&gt; #&lt;Addrinfo: 127.0.0.1 (localhost)&gt;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   Addrinfo.ip(host) =&gt; addrinfo
 *
 * returns an addrinfo object for IP address.
 *
 * The port, socktype, protocol of the result is filled by zero.
 * So, it is not appropriate to create a socket.
 *
 *   Addrinfo.ip(&quot;localhost&quot;) #=&gt; #&lt;Addrinfo: 127.0.0.1 (localhost)&gt;
 */
static VALUE
addrinfo_s_ip(VALUE self, VALUE host)
{
    VALUE ret;
    rb_addrinfo_t *rai;
    ret = addrinfo_firstonly_new(host, Qnil,
            INT2NUM(PF_UNSPEC), INT2FIX(0), INT2FIX(0), INT2FIX(0));
    rai = get_addrinfo(ret);
    rai-&gt;socktype = 0;
    rai-&gt;protocol = 0;
    return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tcp-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>tcp</strong>(host, port) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns an addrinfo object for TCP address.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, &quot;smtp&quot;) #=&gt; #&lt;Addrinfo: 127.0.0.1:25 TCP (localhost:smtp)&gt;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   Addrinfo.tcp(host, port) =&gt; addrinfo
 *
 * returns an addrinfo object for TCP address.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, &quot;smtp&quot;) #=&gt; #&lt;Addrinfo: 127.0.0.1:25 TCP (localhost:smtp)&gt;
 */
static VALUE
addrinfo_s_tcp(VALUE self, VALUE host, VALUE port)
{
    return addrinfo_firstonly_new(host, port,
            INT2NUM(PF_UNSPEC), INT2NUM(SOCK_STREAM), INT2NUM(IPPROTO_TCP), INT2FIX(0));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="udp-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>udp</strong>(host, port) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns an addrinfo object for UDP address.
</p>
<pre class="code">
  Addrinfo.udp(&quot;localhost&quot;, &quot;daytime&quot;) #=&gt; #&lt;Addrinfo: 127.0.0.1:13 UDP (localhost:daytime)&gt;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   Addrinfo.udp(host, port) =&gt; addrinfo
 *
 * returns an addrinfo object for UDP address.
 *
 *   Addrinfo.udp(&quot;localhost&quot;, &quot;daytime&quot;) #=&gt; #&lt;Addrinfo: 127.0.0.1:13 UDP (localhost:daytime)&gt;
 */
static VALUE
addrinfo_s_udp(VALUE self, VALUE host, VALUE port)
{
    return addrinfo_firstonly_new(host, port,
            INT2NUM(PF_UNSPEC), INT2NUM(SOCK_DGRAM), INT2NUM(IPPROTO_UDP), INT2FIX(0));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="unix-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>unix</strong>(path[, socktype]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns an addrinfo object for UNIX socket address.
</p>
<p>
<em>socktype</em> specifies the socket type. If it is omitted, :STREAM is
used.
</p>
<pre class="code">
  Addrinfo.unix(&quot;/tmp/sock&quot;)         #=&gt; #&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;
  Addrinfo.unix(&quot;/tmp/sock&quot;, :DGRAM) #=&gt; #&lt;Addrinfo: /tmp/sock SOCK_DGRAM&gt;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   Addrinfo.unix(path [, socktype]) =&gt; addrinfo
 *
 * returns an addrinfo object for UNIX socket address.
 *
 * _socktype_ specifies the socket type.
 * If it is omitted, :STREAM is used.
 *
 *   Addrinfo.unix(&quot;/tmp/sock&quot;)         #=&gt; #&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;
 *   Addrinfo.unix(&quot;/tmp/sock&quot;, :DGRAM) #=&gt; #&lt;Addrinfo: /tmp/sock SOCK_DGRAM&gt;
 */
static VALUE
addrinfo_s_unix(int argc, VALUE *argv, VALUE self)
{
    VALUE path, vsocktype, addr;
    int socktype;
    rb_addrinfo_t *rai;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;path, &amp;vsocktype);

    if (NIL_P(vsocktype))
        socktype = SOCK_STREAM;
    else
        socktype = rsock_socktype_arg(vsocktype);

    addr = addrinfo_s_allocate(rb_cAddrinfo);
    DATA_PTR(addr) = rai = alloc_addrinfo();
    init_unix_addrinfo(rai, path, socktype);
    OBJ_INFECT(addr, path);
    return addr;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="afamily-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>afamily</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the address family as an integer.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).afamily == Socket::AF_INET #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.afamily =&gt; integer
 *
 * returns the address family as an integer.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).afamily == Socket::AF_INET #=&gt; true
 *
 */
static VALUE
addrinfo_afamily(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    return INT2NUM(ai_get_afamily(rai));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="canonname-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>canonname</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the canonical name as an string.
</p>
<p>
nil is returned if no canonical name.
</p>
<p>
The canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is
specified.
</p>
<pre class="code">
  list = Addrinfo.getaddrinfo(&quot;www.ruby-lang.org&quot;, 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)
  p list[0] #=&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org (www.ruby-lang.org:80)&gt;
  p list[0].canonname #=&gt; &quot;carbon.ruby-lang.org&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.canonname =&gt; string or nil
 *
 * returns the canonical name as an string.
 *
 * nil is returned if no canonical name.
 *
 * The canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is specified.
 *
 *   list = Addrinfo.getaddrinfo(&quot;www.ruby-lang.org&quot;, 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)
 *   p list[0] #=&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org (www.ruby-lang.org:80)&gt;
 *   p list[0].canonname #=&gt; &quot;carbon.ruby-lang.org&quot;
 *
 */
static VALUE
addrinfo_canonname(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    return rai-&gt;canonname;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getnameinfo-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getnameinfo</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getnameinfo</strong>(flags) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns nodename and service as a pair of strings. This converts struct
sockaddr in addrinfo to textual representation.
</p>
<p>
flags should be bitwise OR of Socket::NI_??? constants.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).getnameinfo #=&gt; [&quot;localhost&quot;, &quot;www&quot;]

  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).getnameinfo(Socket::NI_NUMERICSERV)
  #=&gt; [&quot;localhost&quot;, &quot;80&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getnameinfo</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getnameinfo</strong>(flags) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.getnameinfo        =&gt; [nodename, service]
 *   addrinfo.getnameinfo(flags) =&gt; [nodename, service]
 *
 * returns nodename and service as a pair of strings.
 * This converts struct sockaddr in addrinfo to textual representation.
 *
 * flags should be bitwise OR of Socket::NI_??? constants.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).getnameinfo #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).getnameinfo(Socket::NI_NUMERICSERV)
 *   #=&gt; [&quot;localhost&quot;, &quot;80&quot;]
 */
static VALUE
addrinfo_getnameinfo(int argc, VALUE *argv, VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    VALUE vflags;
    char hbuf[1024], pbuf[1024];
    int flags, error;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;vflags);

    flags = NIL_P(vflags) ? 0 : NUM2INT(vflags);

    if (rai-&gt;socktype == SOCK_DGRAM)
        flags |= NI_DGRAM;

    error = getnameinfo((struct sockaddr *)&amp;rai-&gt;addr, rai-&gt;sockaddr_len,
                        hbuf, (socklen_t)sizeof(hbuf), pbuf, (socklen_t)sizeof(pbuf),
                        flags);
    if (error) {
        rsock_raise_socket_error(&quot;getnameinfo&quot;, error);
    }

    return rb_assoc_new(rb_str_new2(hbuf), rb_str_new2(pbuf));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns a string which shows addrinfo in human-readable form.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).inspect #=&gt; &quot;#&lt;Addrinfo: 127.0.0.1:80 TCP (localhost:80)&gt;&quot;
  Addrinfo.unix(&quot;/tmp/sock&quot;).inspect    #=&gt; &quot;#&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.inspect =&gt; string
 *
 * returns a string which shows addrinfo in human-readable form.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).inspect #=&gt; &quot;#&lt;Addrinfo: 127.0.0.1:80 TCP (localhost:80)&gt;&quot;
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).inspect    #=&gt; &quot;#&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;&quot;
 *
 */
static VALUE
addrinfo_inspect(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    int internet_p;
    VALUE ret;

    ret = rb_sprintf(&quot;#&lt;%s: &quot;, rb_obj_classname(self));

    inspect_sockaddr(self, ret);

    if (rai-&gt;pfamily &amp;&amp; ai_get_afamily(rai) != rai-&gt;pfamily) {
        ID id = rsock_intern_protocol_family(rai-&gt;pfamily);
        if (id)
            rb_str_catf(ret, &quot; %s&quot;, rb_id2name(id));
        else
            rb_str_catf(ret, &quot; PF_\?\?\?(%d)&quot;, rai-&gt;pfamily);
    }

    internet_p = rai-&gt;pfamily == PF_INET;
#ifdef INET6
    internet_p = internet_p || rai-&gt;pfamily == PF_INET6;
#endif
    if (internet_p &amp;&amp; rai-&gt;socktype == SOCK_STREAM &amp;&amp;
        (rai-&gt;protocol == 0 || rai-&gt;protocol == IPPROTO_TCP)) {
        rb_str_cat2(ret, &quot; TCP&quot;);
    }
    else if (internet_p &amp;&amp; rai-&gt;socktype == SOCK_DGRAM &amp;&amp;
        (rai-&gt;protocol == 0 || rai-&gt;protocol == IPPROTO_UDP)) {
        rb_str_cat2(ret, &quot; UDP&quot;);
    }
    else {
        if (rai-&gt;socktype) {
            ID id = rsock_intern_socktype(rai-&gt;socktype);
            if (id)
                rb_str_catf(ret, &quot; %s&quot;, rb_id2name(id));
            else
                rb_str_catf(ret, &quot; SOCK_\?\?\?(%d)&quot;, rai-&gt;socktype);
        }

        if (rai-&gt;protocol) {
            if (internet_p) {
                ID id = rsock_intern_ipproto(rai-&gt;protocol);
                if (id)
                    rb_str_catf(ret, &quot; %s&quot;, rb_id2name(id));
                else
                    goto unknown_protocol;
            }
            else {
              unknown_protocol:
                rb_str_catf(ret, &quot; UNKNOWN_PROTOCOL(%d)&quot;, rai-&gt;protocol);
            }
        }
    }

    if (!NIL_P(rai-&gt;canonname)) {
        VALUE name = rai-&gt;canonname;
        rb_str_catf(ret, &quot; %s&quot;, StringValueCStr(name));
    }

    if (!NIL_P(rai-&gt;inspectname)) {
        VALUE name = rai-&gt;inspectname;
        rb_str_catf(ret, &quot; (%s)&quot;, StringValueCStr(name));
    }

    rb_str_buf_cat2(ret, &quot;&gt;&quot;);
    return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect_sockaddr-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect_sockaddr</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns a string which shows the sockaddr in <em>addrinfo</em> with
human-readable form.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).inspect_sockaddr     #=&gt; &quot;127.0.0.1:80&quot;
  Addrinfo.tcp(&quot;ip6-localhost&quot;, 80).inspect_sockaddr #=&gt; &quot;[::1]:80&quot;
  Addrinfo.unix(&quot;/tmp/sock&quot;).inspect_sockaddr        #=&gt; &quot;/tmp/sock&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.inspect_sockaddr =&gt; string
 *
 * returns a string which shows the sockaddr in _addrinfo_ with human-readable form.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).inspect_sockaddr     #=&gt; &quot;127.0.0.1:80&quot;
 *   Addrinfo.tcp(&quot;ip6-localhost&quot;, 80).inspect_sockaddr #=&gt; &quot;[::1]:80&quot;
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).inspect_sockaddr        #=&gt; &quot;/tmp/sock&quot;
 *
 */
static VALUE
addrinfo_inspect_sockaddr(VALUE self)
{
    return inspect_sockaddr(self, rb_str_new(&quot;&quot;, 0));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ip?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>ip?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns true if addrinfo is internet (IPv4/IPv6) address. returns false
otherwise.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip? #=&gt; true
  Addrinfo.tcp(&quot;::1&quot;, 80).ip?       #=&gt; true
  Addrinfo.unix(&quot;/tmp/sock&quot;).ip?    #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.ip? =&gt; true or false
 *
 * returns true if addrinfo is internet (IPv4/IPv6) address.
 * returns false otherwise.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip? #=&gt; true
 *   Addrinfo.tcp(&quot;::1&quot;, 80).ip?       #=&gt; true
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).ip?    #=&gt; false
 *
 */
static VALUE
addrinfo_ip_p(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    int family = ai_get_afamily(rai);
    return IS_IP_FAMILY(family) ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ip_address-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>ip_address</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the IP address as a string.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_address    #=&gt; &quot;127.0.0.1&quot;
  Addrinfo.tcp(&quot;::1&quot;, 80).ip_address          #=&gt; &quot;::1&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.ip_address =&gt; string
 *
 * Returns the IP address as a string.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_address    #=&gt; &quot;127.0.0.1&quot;
 *   Addrinfo.tcp(&quot;::1&quot;, 80).ip_address          #=&gt; &quot;::1&quot;
 */
static VALUE
addrinfo_ip_address(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    int family = ai_get_afamily(rai);
    VALUE vflags;
    VALUE ret;

    if (!IS_IP_FAMILY(family))
    rb_raise(rb_eSocket, &quot;need IPv4 or IPv6 address&quot;);

    vflags = INT2NUM(NI_NUMERICHOST|NI_NUMERICSERV);
    ret = addrinfo_getnameinfo(1, &amp;vflags, self);
    return rb_ary_entry(ret, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ip_port-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ip_port</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the port number as an integer.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_port    #=&gt; 80
  Addrinfo.tcp(&quot;::1&quot;, 80).ip_port          #=&gt; 80</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.ip_port =&gt; port
 *
 * Returns the port number as an integer.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_port    #=&gt; 80
 *   Addrinfo.tcp(&quot;::1&quot;, 80).ip_port          #=&gt; 80
 */
static VALUE
addrinfo_ip_port(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    int family = ai_get_afamily(rai);
    int port;

    if (!IS_IP_FAMILY(family)) {
      bad_family:
#ifdef AF_INET6
    rb_raise(rb_eSocket, &quot;need IPv4 or IPv6 address&quot;);
#else
    rb_raise(rb_eSocket, &quot;need IPv4 address&quot;);
#endif
    }

    switch (family) {
      case AF_INET:
        if (rai-&gt;sockaddr_len != sizeof(struct sockaddr_in))
            rb_raise(rb_eSocket, &quot;unexpected sockaddr size for IPv4&quot;);
        port = ntohs(((struct sockaddr_in *)&amp;rai-&gt;addr)-&gt;sin_port);
        break;

#ifdef AF_INET6
      case AF_INET6:
        if (rai-&gt;sockaddr_len != sizeof(struct sockaddr_in6))
            rb_raise(rb_eSocket, &quot;unexpected sockaddr size for IPv6&quot;);
        port = ntohs(((struct sockaddr_in6 *)&amp;rai-&gt;addr)-&gt;sin6_port);
        break;
#endif

      default:
    goto bad_family;
    }

    return INT2NUM(port);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ip_unpack-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>ip_unpack</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the IP address and port number as 2-element array.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_unpack    #=&gt; [&quot;127.0.0.1&quot;, 80]
  Addrinfo.tcp(&quot;::1&quot;, 80).ip_unpack          #=&gt; [&quot;::1&quot;, 80]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.ip_unpack =&gt; [addr, port]
 *
 * Returns the IP address and port number as 2-element array.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_unpack    #=&gt; [&quot;127.0.0.1&quot;, 80]
 *   Addrinfo.tcp(&quot;::1&quot;, 80).ip_unpack          #=&gt; [&quot;::1&quot;, 80]
 */
static VALUE
addrinfo_ip_unpack(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    int family = ai_get_afamily(rai);
    VALUE vflags;
    VALUE ret, portstr;

    if (!IS_IP_FAMILY(family))
    rb_raise(rb_eSocket, &quot;need IPv4 or IPv6 address&quot;);

    vflags = INT2NUM(NI_NUMERICHOST|NI_NUMERICSERV);
    ret = addrinfo_getnameinfo(1, &amp;vflags, self);
    portstr = rb_ary_entry(ret, 1);
    rb_ary_store(ret, 1, INT2NUM(atoi(StringValueCStr(portstr))));
    return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv4?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>ipv4?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns true if addrinfo is IPv4 address. returns false otherwise.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ipv4? #=&gt; true
  Addrinfo.tcp(&quot;::1&quot;, 80).ipv4?       #=&gt; false
  Addrinfo.unix(&quot;/tmp/sock&quot;).ipv4?    #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.ipv4? =&gt; true or false
 *
 * returns true if addrinfo is IPv4 address.
 * returns false otherwise.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ipv4? #=&gt; true
 *   Addrinfo.tcp(&quot;::1&quot;, 80).ipv4?       #=&gt; false
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).ipv4?    #=&gt; false
 *
 */
static VALUE
addrinfo_ipv4_p(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    return ai_get_afamily(rai) == AF_INET ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv4_loopback?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv4_loopback?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv4 loopback address (127.0.0.0/8). It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv4 loopback address (127.0.0.0/8).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv4_loopback_p(VALUE self)
{
    uint32_t a;
    if (!extract_in_addr(self, &amp;a)) return Qfalse;
    if ((a &amp; 0xff000000) == 0x7f000000) /* 127.0.0.0/8 */
        return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv4_multicast?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv4_multicast?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv4 multicast address (224.0.0.0/4). It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv4 multicast address (224.0.0.0/4).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv4_multicast_p(VALUE self)
{
    uint32_t a;
    if (!extract_in_addr(self, &amp;a)) return Qfalse;
    if ((a &amp; 0xf0000000) == 0xe0000000) /* 224.0.0.0/4 */
        return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv4_private?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv4_private?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12,
192.168.0.0/16). It returns false otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv4_private_p(VALUE self)
{
    uint32_t a;
    if (!extract_in_addr(self, &amp;a)) return Qfalse;
    if ((a &amp; 0xff000000) == 0x0a000000 || /* 10.0.0.0/8 */
        (a &amp; 0xfff00000) == 0xac100000 || /* 172.16.0.0/12 */
        (a &amp; 0xffff0000) == 0xc0a80000)   /* 192.168.0.0/16 */
        return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>ipv6?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns true if addrinfo is IPv6 address. returns false otherwise.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ipv6? #=&gt; false
  Addrinfo.tcp(&quot;::1&quot;, 80).ipv6?       #=&gt; true
  Addrinfo.unix(&quot;/tmp/sock&quot;).ipv6?    #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.ipv6? =&gt; true or false
 *
 * returns true if addrinfo is IPv6 address.
 * returns false otherwise.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ipv6? #=&gt; false
 *   Addrinfo.tcp(&quot;::1&quot;, 80).ipv6?       #=&gt; true
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).ipv6?    #=&gt; false
 *
 */
static VALUE
addrinfo_ipv6_p(VALUE self)
{
#ifdef AF_INET6
    rb_addrinfo_t *rai = get_addrinfo(self);
    return ai_get_afamily(rai) == AF_INET6 ? Qtrue : Qfalse;
#else
    return Qfalse;
#endif
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_linklocal?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_linklocal?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 link local address (ff80::/10). It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 link local address (ff80::/10).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_linklocal_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_LINKLOCAL(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_loopback?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_loopback?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 loopback address (::1). It returns false otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 loopback address (::1).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_loopback_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_LOOPBACK(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_mc_global?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_mc_global?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 multicast global scope address. It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 multicast global scope address.
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_mc_global_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_MC_GLOBAL(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_mc_linklocal?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_mc_linklocal?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 multicast link-local scope address. It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 multicast link-local scope address.
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_mc_linklocal_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_MC_LINKLOCAL(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_mc_nodelocal?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_mc_nodelocal?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 multicast node-local scope address. It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 multicast node-local scope address.
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_mc_nodelocal_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_MC_NODELOCAL(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_mc_orglocal?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_mc_orglocal?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 multicast organization-local scope address. It
returns false otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 multicast organization-local scope address.
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_mc_orglocal_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_MC_ORGLOCAL(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_mc_sitelocal?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_mc_sitelocal?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 multicast site-local scope address. It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 multicast site-local scope address.
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_mc_sitelocal_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_MC_SITELOCAL(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_multicast?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_multicast?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 multicast address (ff00::/8). It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 multicast address (ff00::/8).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_multicast_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_MULTICAST(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_sitelocal?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_sitelocal?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 site local address (ffc0::/10). It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 site local address (ffc0::/10).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_sitelocal_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_SITELOCAL(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_to_ipv4-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_to_ipv4</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns IPv4 address of IPv4 mapped/compatible IPv6 address. It returns nil
if <tt>self</tt> is not IPv4 mapped/compatible IPv6 address.
</p>
<pre class="code">
  Addrinfo.ip(&quot;::192.0.2.3&quot;).ipv6_to_ipv4      #=&gt; #&lt;Addrinfo: 192.0.2.3&gt;
  Addrinfo.ip(&quot;::ffff:192.0.2.3&quot;).ipv6_to_ipv4 #=&gt; #&lt;Addrinfo: 192.0.2.3&gt;
  Addrinfo.ip(&quot;::1&quot;).ipv6_to_ipv4              #=&gt; nil
  Addrinfo.ip(&quot;192.0.2.3&quot;).ipv6_to_ipv4        #=&gt; nil
  Addrinfo.unix(&quot;/tmp/sock&quot;).ipv6_to_ipv4      #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns IPv4 address of IPv4 mapped/compatible IPv6 address.
 * It returns nil if +self+ is not IPv4 mapped/compatible IPv6 address.
 *
 *   Addrinfo.ip(&quot;::192.0.2.3&quot;).ipv6_to_ipv4      #=&gt; #&lt;Addrinfo: 192.0.2.3&gt;
 *   Addrinfo.ip(&quot;::ffff:192.0.2.3&quot;).ipv6_to_ipv4 #=&gt; #&lt;Addrinfo: 192.0.2.3&gt;
 *   Addrinfo.ip(&quot;::1&quot;).ipv6_to_ipv4              #=&gt; nil
 *   Addrinfo.ip(&quot;192.0.2.3&quot;).ipv6_to_ipv4        #=&gt; nil
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).ipv6_to_ipv4      #=&gt; nil
 */
static VALUE
addrinfo_ipv6_to_ipv4(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    struct in6_addr *addr;
    int family = ai_get_afamily(rai);
    if (family != AF_INET6) return Qnil;
    addr = &amp;((struct sockaddr_in6 *)&amp;rai-&gt;addr)-&gt;sin6_addr;
    if (IN6_IS_ADDR_V4MAPPED(addr) || IN6_IS_ADDR_V4COMPAT(addr)) {
        struct sockaddr_in sin4;
        MEMZERO(&amp;sin4, struct sockaddr_in, 1);
        sin4.sin_family = AF_INET;
        SET_SIN_LEN(&amp;sin4, sizeof(sin4));
        memcpy(&amp;sin4.sin_addr, (char*)addr + sizeof(*addr) - sizeof(sin4.sin_addr), sizeof(sin4.sin_addr));
        return rsock_addrinfo_new((struct sockaddr *)&amp;sin4, (socklen_t)sizeof(sin4),
                                  PF_INET, rai-&gt;socktype, rai-&gt;protocol,
                                  rai-&gt;canonname, rai-&gt;inspectname);
    }
    else {
        return Qnil;
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_unspecified?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_unspecified?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv6 unspecified address (::). It returns false otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv6 unspecified address (::).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_unspecified_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_UNSPECIFIED(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_v4compat?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_v4compat?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv4-compatible IPv6 address (::/80). It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv4-compatible IPv6 address (::/80).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_v4compat_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_V4COMPAT(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ipv6_v4mapped?-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>ipv6_v4mapped?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80). It returns false
otherwise.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80).
 * It returns false otherwise.
 */
static VALUE
addrinfo_ipv6_v4mapped_p(VALUE self)
{
    struct in6_addr *addr = extract_in6_addr(self);
    if (addr &amp;&amp; IN6_IS_ADDR_V4MAPPED(addr)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="marshal_dump-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>marshal_dump</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/* :nodoc: */
static VALUE
addrinfo_mdump(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    VALUE sockaddr, afamily, pfamily, socktype, protocol, canonname, inspectname;
    int afamily_int = ai_get_afamily(rai);
    ID id;

    id = rsock_intern_protocol_family(rai-&gt;pfamily);
    if (id == 0)
        rb_raise(rb_eSocket, &quot;unknown protocol family: %d&quot;, rai-&gt;pfamily);
    pfamily = rb_id2str(id);

    if (rai-&gt;socktype == 0)
        socktype = INT2FIX(0);
    else {
        id = rsock_intern_socktype(rai-&gt;socktype);
        if (id == 0)
            rb_raise(rb_eSocket, &quot;unknown socktype: %d&quot;, rai-&gt;socktype);
        socktype = rb_id2str(id);
    }

    if (rai-&gt;protocol == 0)
        protocol = INT2FIX(0);
    else if (IS_IP_FAMILY(afamily_int)) {
        id = rsock_intern_ipproto(rai-&gt;protocol);
        if (id == 0)
            rb_raise(rb_eSocket, &quot;unknown IP protocol: %d&quot;, rai-&gt;protocol);
        protocol = rb_id2str(id);
    }
    else {
        rb_raise(rb_eSocket, &quot;unknown protocol: %d&quot;, rai-&gt;protocol);
    }

    canonname = rai-&gt;canonname;

    inspectname = rai-&gt;inspectname;

    id = rsock_intern_family(afamily_int);
    if (id == 0)
        rb_raise(rb_eSocket, &quot;unknown address family: %d&quot;, afamily_int);
    afamily = rb_id2str(id);

    switch(afamily_int) {
#ifdef HAVE_SYS_UN_H
      case AF_UNIX:
      {
        struct sockaddr_un *su = (struct sockaddr_un *)&amp;rai-&gt;addr;
        char *s, *e;
        s = su-&gt;sun_path;
        e = (char*)s + sizeof(su-&gt;sun_path);
        while (s &lt; e &amp;&amp; *(e-1) == '\0')
            e--;
        sockaddr = rb_str_new(s, e-s);
        break;
      }
#endif

      default:
      {
        char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV];
        int error;
        error = getnameinfo((struct sockaddr *)&amp;rai-&gt;addr, rai-&gt;sockaddr_len,
                            hbuf, (socklen_t)sizeof(hbuf), pbuf, (socklen_t)sizeof(pbuf),
                            NI_NUMERICHOST|NI_NUMERICSERV);
        if (error) {
            rsock_raise_socket_error(&quot;getnameinfo&quot;, error);
        }
        sockaddr = rb_assoc_new(rb_str_new_cstr(hbuf), rb_str_new_cstr(pbuf));
        break;
      }
    }

    return rb_ary_new3(7, afamily, sockaddr, pfamily, socktype, protocol, canonname, inspectname);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="marshal_load-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>marshal_load</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/* :nodoc: */
static VALUE
addrinfo_mload(VALUE self, VALUE ary)
{
    VALUE v;
    VALUE canonname, inspectname;
    int afamily, pfamily, socktype, protocol;
    struct sockaddr_storage ss;
    socklen_t len;
    rb_addrinfo_t *rai;

    if (check_addrinfo(self))
        rb_raise(rb_eTypeError, &quot;already initialized socket address&quot;);

    ary = rb_convert_type(ary, T_ARRAY, &quot;Array&quot;, &quot;to_ary&quot;);

    v = rb_ary_entry(ary, 0);
    StringValue(v);
    if (rsock_family_to_int(RSTRING_PTR(v), RSTRING_LEN(v), &amp;afamily) == -1)
        rb_raise(rb_eTypeError, &quot;unexpected address family&quot;);

    v = rb_ary_entry(ary, 2);
    StringValue(v);
    if (rsock_family_to_int(RSTRING_PTR(v), RSTRING_LEN(v), &amp;pfamily) == -1)
        rb_raise(rb_eTypeError, &quot;unexpected protocol family&quot;);

    v = rb_ary_entry(ary, 3);
    if (v == INT2FIX(0))
        socktype = 0;
    else {
        StringValue(v);
        if (rsock_socktype_to_int(RSTRING_PTR(v), RSTRING_LEN(v), &amp;socktype) == -1)
            rb_raise(rb_eTypeError, &quot;unexpected socktype&quot;);
    }

    v = rb_ary_entry(ary, 4);
    if (v == INT2FIX(0))
        protocol = 0;
    else {
        StringValue(v);
        if (IS_IP_FAMILY(afamily)) {
            if (rsock_ipproto_to_int(RSTRING_PTR(v), RSTRING_LEN(v), &amp;protocol) == -1)
                rb_raise(rb_eTypeError, &quot;unexpected protocol&quot;);
        }
        else {
            rb_raise(rb_eTypeError, &quot;unexpected protocol&quot;);
        }
    }

    v = rb_ary_entry(ary, 5);
    if (NIL_P(v))
        canonname = Qnil;
    else {
        StringValue(v);
        canonname = v;
    }

    v = rb_ary_entry(ary, 6);
    if (NIL_P(v))
        inspectname = Qnil;
    else {
        StringValue(v);
        inspectname = v;
    }

    v = rb_ary_entry(ary, 1);
    switch(afamily) {
#ifdef HAVE_SYS_UN_H
      case AF_UNIX:
      {
        struct sockaddr_un uaddr;
        memset(&amp;uaddr, 0, sizeof(uaddr));
        uaddr.sun_family = AF_UNIX;

        StringValue(v);
        if (sizeof(uaddr.sun_path) &lt;= (size_t)RSTRING_LEN(v))
            rb_raise(rb_eSocket, &quot;too long AF_UNIX path&quot;);
        memcpy(uaddr.sun_path, RSTRING_PTR(v), RSTRING_LEN(v));
        len = (socklen_t)sizeof(uaddr);
        memcpy(&amp;ss, &amp;uaddr, len);
        break;
      }
#endif

      default:
      {
        VALUE pair = rb_convert_type(v, T_ARRAY, &quot;Array&quot;, &quot;to_ary&quot;);
        struct addrinfo *res;
        int flags = AI_NUMERICHOST;
#ifdef AI_NUMERICSERV
        flags |= AI_NUMERICSERV;
#endif
        res = call_getaddrinfo(rb_ary_entry(pair, 0), rb_ary_entry(pair, 1),
                               INT2NUM(pfamily), INT2NUM(socktype), INT2NUM(protocol),
                               INT2NUM(flags), 1);

        len = res-&gt;ai_addrlen;
        memcpy(&amp;ss, res-&gt;ai_addr, res-&gt;ai_addrlen);
        break;
      }
    }

    DATA_PTR(self) = rai = alloc_addrinfo();
    init_addrinfo(rai, (struct sockaddr *)&amp;ss, len,
                  pfamily, socktype, protocol,
                  canonname, inspectname);
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pfamily-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>pfamily</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the protocol family as an integer.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).pfamily == Socket::PF_INET #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.pfamily =&gt; integer
 *
 * returns the protocol family as an integer.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).pfamily == Socket::PF_INET #=&gt; true
 *
 */
static VALUE
addrinfo_pfamily(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    return INT2NUM(rai-&gt;pfamily);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="protocol-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>protocol</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the socket type as an integer.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).protocol == Socket::IPPROTO_TCP #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.protocol =&gt; integer
 *
 * returns the socket type as an integer.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).protocol == Socket::IPPROTO_TCP #=&gt; true
 *
 */
static VALUE
addrinfo_protocol(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    return INT2NUM(rai-&gt;protocol);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="socktype-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>socktype</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the socket type as an integer.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).socktype == Socket::SOCK_STREAM #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.socktype =&gt; integer
 *
 * returns the socket type as an integer.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).socktype == Socket::SOCK_STREAM #=&gt; true
 *
 */
static VALUE
addrinfo_socktype(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    return INT2NUM(rai-&gt;socktype);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_s-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_sockaddr</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the socket address as packed struct sockaddr string.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).to_sockaddr
  #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.to_sockaddr =&gt; string
 *
 * returns the socket address as packed struct sockaddr string.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).to_sockaddr
 *   #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
 *
 */
static VALUE
addrinfo_to_sockaddr(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    VALUE ret;
    ret = rb_str_new((char*)&amp;rai-&gt;addr, rai-&gt;sockaddr_len);
    OBJ_INFECT(ret, self);
    return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_sockaddr-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_sockaddr</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the socket address as packed struct sockaddr string.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;localhost&quot;, 80).to_sockaddr
  #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.to_sockaddr =&gt; string
 *
 * returns the socket address as packed struct sockaddr string.
 *
 *   Addrinfo.tcp(&quot;localhost&quot;, 80).to_sockaddr
 *   #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
 *
 */
static VALUE
addrinfo_to_sockaddr(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    VALUE ret;
    ret = rb_str_new((char*)&amp;rai-&gt;addr, rai-&gt;sockaddr_len);
    OBJ_INFECT(ret, self);
    return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="unix?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>unix?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns true if addrinfo is UNIX address. returns false otherwise.
</p>
<pre class="code">
  Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).unix? #=&gt; false
  Addrinfo.tcp(&quot;::1&quot;, 80).unix?       #=&gt; false
  Addrinfo.unix(&quot;/tmp/sock&quot;).unix?    #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.unix? =&gt; true or false
 *
 * returns true if addrinfo is UNIX address.
 * returns false otherwise.
 *
 *   Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).unix? #=&gt; false
 *   Addrinfo.tcp(&quot;::1&quot;, 80).unix?       #=&gt; false
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).unix?    #=&gt; true
 *
 */
static VALUE
addrinfo_unix_p(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
#ifdef AF_UNIX
    return ai_get_afamily(rai) == AF_UNIX ? Qtrue : Qfalse;
#else
    return Qfalse;
#endif
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="unix_path-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>unix_path</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the socket path as a string.
</p>
<pre class="code">
  Addrinfo.unix(&quot;/tmp/sock&quot;).unix_path       #=&gt; &quot;/tmp/sock&quot;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/raddrinfo.c'</span>

/*
 * call-seq:
 *   addrinfo.unix_path =&gt; path
 *
 * Returns the socket path as a string.
 *
 *   Addrinfo.unix(&quot;/tmp/sock&quot;).unix_path       #=&gt; &quot;/tmp/sock&quot;
 */
static VALUE
addrinfo_unix_path(VALUE self)
{
    rb_addrinfo_t *rai = get_addrinfo(self);
    int family = ai_get_afamily(rai);
    struct sockaddr_un *addr;
    char *s, *e;

    if (family != AF_UNIX)
    rb_raise(rb_eSocket, &quot;need AF_UNIX address&quot;);

    addr = (struct sockaddr_un *)&amp;rai-&gt;addr;

    s = addr-&gt;sun_path;
    e = (char*)addr + rai-&gt;sockaddr_len;
    if (e &lt; s)
        rb_raise(rb_eSocket, &quot;too short AF_UNIX address&quot;);
    if (addr-&gt;sun_path + sizeof(addr-&gt;sun_path) &lt; e)
        rb_raise(rb_eSocket, &quot;too long AF_UNIX address&quot;);
    while (s &lt; e &amp;&amp; *(e-1) == '\0')
        e--;
    return rb_str_new(s, e-s);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:01:43 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>