<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Object::Syck::Resolver</title>
<link rel="stylesheet" href="../../css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="../../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '../..';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../../_index.html">Index (R)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Syck.html" title="Object::Syck (module)">Syck</a></span></span>
     &raquo; 
    <span class="title">Resolver</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Object::Syck::Resolver
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Object </span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Object </li>
          
            <li class="next">Object::Syck::Resolver</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">ext/syck/rubyext.c</dd>
  
</dl>
<div class="clear"></div>



  

  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#add_type-instance_method" title="#add_type (instance method)">- (Object) <strong>add_type</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
YAML::Syck::Resolver#add_type.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#detect_implicit-instance_method" title="#detect_implicit (instance method)">- (Object) <strong>detect_implicit</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
YAML::Syck::Resolver#detect_implicit.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
YAML::Syck::Resolver.initialize.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#node_import-instance_method" title="#node_import (instance method)">- (Object) <strong>node_import</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
YAML::Syck::Resolver#node_import.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tagurize-instance_method" title="#tagurize (instance method)">- (Object) <strong>tagurize</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
YAML::Syck::Resolver#tagurize.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transfer-instance_method" title="#transfer (instance method)">- (Object) <strong>transfer</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
YAML::Syck::Resolver#transfer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#use_types_at-instance_method" title="#use_types_at (instance method)">- (Object) <strong>use_types_at</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
YAML::Syck::Resolver#use_types_at.
</p>
</div></span>
  
</li>

      
    </ul>
  


  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object::Syck::Object (class)">Object</a></span></tt>) <strong>initialize</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
YAML::Syck::Resolver.initialize
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/syck/rubyext.c'</span>

/*
 * YAML::Syck::Resolver.initialize
 */
static VALUE
syck_resolver_initialize(VALUE self)
{
    rb_ivar_set(self, s_tags, rb_hash_new());
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="add_type-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object::Syck::Object (class)">Object</a></span></tt>) <strong>add_type</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
YAML::Syck::Resolver#add_type
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/syck/rubyext.c'</span>

/*
 * YAML::Syck::Resolver#add_type
 */
VALUE
syck_resolver_add_type(VALUE self, VALUE taguri, VALUE cls)
{
    VALUE tags = rb_attr_get(self, s_tags);
    rb_hash_aset( tags, taguri, cls );
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="detect_implicit-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object::Syck::Object (class)">Object</a></span></tt>) <strong>detect_implicit</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
YAML::Syck::Resolver#detect_implicit
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/syck/rubyext.c'</span>

/*
 * YAML::Syck::Resolver#detect_implicit
 */
VALUE
syck_resolver_detect_implicit(VALUE self, VALUE val)
{
    return rb_str_new2( &quot;&quot; );
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="node_import-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object::Syck::Object (class)">Object</a></span></tt>) <strong>node_import</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
YAML::Syck::Resolver#node_import
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/syck/rubyext.c'</span>

/*
 * YAML::Syck::Resolver#node_import
 */
VALUE
syck_resolver_node_import(VALUE self, VALUE node)
{
    SyckNode *n;
    VALUE obj = Qnil;
    int i = 0;
    Data_Get_Struct(node, SyckNode, n);

    switch (n-&gt;kind)
    {
        case syck_str_kind:
            obj = rb_str_new( n-&gt;data.str-&gt;ptr, n-&gt;data.str-&gt;len );
        break;

        case syck_seq_kind:
            obj = rb_ary_new2( n-&gt;data.list-&gt;idx );
            for ( i = 0; i &lt; n-&gt;data.list-&gt;idx; i++ )
            {
                rb_ary_store( obj, i, syck_seq_read( n, i ) );
            }
        break;

        case syck_map_kind:
            obj = rb_hash_new();
            for ( i = 0; i &lt; n-&gt;data.pairs-&gt;idx; i++ )
            {
                VALUE k = syck_map_read( n, map_key, i );
                VALUE v = syck_map_read( n, map_value, i );
                int skip_aset = 0;

                /*
                 * Handle merge keys
                 */
                if ( rb_obj_is_kind_of( k, cMergeKey ) )
                {
                    if ( rb_obj_is_kind_of( v, rb_cHash ) )
                    {
                        VALUE dup = rb_funcall( v, s_dup, 0 );
                        rb_funcall( dup, s_update, 1, obj );
                        obj = dup;
                        skip_aset = 1;
                    }
                    else if ( rb_obj_is_kind_of( v, rb_cArray ) )
                    {
                        VALUE end = rb_ary_pop( v );
                        if ( rb_obj_is_kind_of( end, rb_cHash ) )
                        {
                            VALUE dup = rb_funcall( end, s_dup, 0 );
                            v = rb_ary_reverse( v );
                            rb_ary_push( v, obj );
                            rb_block_call( v, s_each, 0, 0, syck_merge_i, dup );
                            obj = dup;
                            skip_aset = 1;
                        }
                    }
                }
                else if ( rb_obj_is_kind_of( k, cDefaultKey ) )
                {
                    rb_funcall( obj, s_default_set, 1, v );
                    skip_aset = 1;
                }

                if ( ! skip_aset )
                {
                    rb_hash_aset( obj, k, v );
                }
            }
        break;
    }

    if ( n-&gt;type_id != NULL )
    {
        obj = rb_funcall( self, s_transfer, 2, rb_str_new2( n-&gt;type_id ), obj );
    }
    return obj;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tagurize-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object::Syck::Object (class)">Object</a></span></tt>) <strong>tagurize</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
YAML::Syck::Resolver#tagurize
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/syck/rubyext.c'</span>

/*
 * YAML::Syck::Resolver#tagurize
 */
VALUE
syck_resolver_tagurize(VALUE self, VALUE val)
{
    VALUE tmp = rb_check_string_type(val);

    if ( !NIL_P(tmp) )
    {
        char *taguri = syck_type_id_to_uri( RSTRING_PTR(tmp) );
        val = rb_str_new2( taguri );
        S_FREE( taguri );
    }

    return val;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="transfer-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object::Syck::Object (class)">Object</a></span></tt>) <strong>transfer</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
YAML::Syck::Resolver#transfer
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/syck/rubyext.c'</span>

/*
 * YAML::Syck::Resolver#transfer
 */
VALUE
syck_resolver_transfer(VALUE self, VALUE type, VALUE val)
{
    if (NIL_P(type) || RSTRING_LEN(StringValue(type)) == 0)
    {
        type = rb_funcall( self, s_detect_implicit, 1, val );
    }

    if ( ! (NIL_P(type) || RSTRING_LEN(StringValue(type)) == 0) )
    {
        VALUE str_xprivate = rb_str_new2( &quot;x-private&quot; );
        VALUE colon = rb_str_new2( &quot;:&quot; );
        VALUE tags = rb_attr_get(self, s_tags);
        VALUE target_class = rb_hash_aref( tags, type );
        VALUE subclass = target_class;
        VALUE obj = Qnil;

        /*
         * Should no tag match exactly, check for subclass format
         */
        if ( NIL_P( target_class ) )
        {
            VALUE subclass_parts = rb_ary_new();
            VALUE parts = rb_str_split( type, &quot;:&quot; );

            while ( RARRAY_LEN(parts) &gt; 1 )
            {
                VALUE partial;
                rb_ary_unshift( subclass_parts, rb_ary_pop( parts ) );
                partial = rb_ary_join( parts, colon );
                target_class = rb_hash_aref( tags, partial );
                if ( NIL_P( target_class ) )
                {
                    rb_str_append( partial, colon );
                    target_class = rb_hash_aref( tags, partial );
                }

                /*
                 * Possible subclass found, see if it supports subclassing
                 */
                if ( ! NIL_P( target_class ) )
                {
                    subclass = target_class;
                    if ( RARRAY_LEN(subclass_parts) &gt; 0 &amp;&amp; rb_respond_to( target_class, s_tag_subclasses ) &amp;&amp;
                         RTEST( rb_funcall( target_class, s_tag_subclasses, 0 ) ) )
                    {
                        VALUE subclass_v;
                        subclass = rb_ary_join( subclass_parts, colon );
                        subclass = rb_funcall( target_class, s_tag_read_class, 1, subclass );
                        subclass_v = syck_const_find( subclass );

                        if ( subclass_v != Qnil )
                        {
                            subclass = subclass_v;
                        }
                        else if ( rb_cObject == target_class &amp;&amp; subclass_v == Qnil )
                        {
                            target_class = cYObject;
                            type = subclass;
                            subclass = cYObject;
                        }
                        else /* workaround for SEGV. real fix please */
                        {
                            rb_raise( rb_eTypeError, &quot;invalid subclass&quot; );
                        }
                    }
                    break;
                }
            }
        }

        /* rb_raise(rb_eTypeError, &quot;invalid typing scheme: %s given&quot;,
         *         scheme);
         */

        if ( rb_respond_to( target_class, s_call ) )
        {
            obj = rb_funcall( target_class, s_call, 2, type, val );
        }
        else
        {
            if ( rb_respond_to( target_class, s_yaml_new ) )
            {
                obj = rb_funcall( target_class, s_yaml_new, 3, subclass, type, val );
            }
            else if ( !NIL_P( target_class ) )
            {
                if ( subclass == rb_cBignum )
                {
                    obj = rb_str2inum( val, 10 ); /* for yaml dumped by 1.8.3 [ruby-core:6159] */
                }
                else
                {
                    obj = rb_obj_alloc( subclass );
                }

                if ( rb_respond_to( obj, s_yaml_initialize ) )
                {
                    rb_funcall( obj, s_yaml_initialize, 2, type, val );
                }
                else if ( !NIL_P( obj ) &amp;&amp; rb_obj_is_instance_of( val, rb_cHash ) )
                {
                    rb_block_call( val, s_each, 0, 0, syck_set_ivars, obj );
                }
            }
            else
            {
                VALUE parts = rb_str_split( type, &quot;:&quot; );
                VALUE scheme = rb_ary_shift( parts );
                if ( rb_str_cmp( scheme, str_xprivate ) == 0 )
                {
                    VALUE name = rb_ary_join( parts, colon );
                    obj = rb_funcall( cPrivateType, s_new, 2, name, val );
                }
                else
                {
                    VALUE domain = rb_ary_shift( parts );
                    VALUE name = rb_ary_join( parts, colon );
                    obj = rb_funcall( cDomainType, s_new, 3, domain, name, val );
                }
            }
        }
        val = obj;
    }

    return val;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="use_types_at-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object::Syck::Object (class)">Object</a></span></tt>) <strong>use_types_at</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
YAML::Syck::Resolver#use_types_at
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/syck/rubyext.c'</span>

/*
 * YAML::Syck::Resolver#use_types_at
 */
VALUE
syck_resolver_use_types_at(VALUE self, VALUE hsh)
{
    rb_ivar_set( self, s_tags, hsh );
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:02:59 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>