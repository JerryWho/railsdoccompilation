<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: JSON::Ext::Parser</title>
<link rel="stylesheet" href="../../css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="../../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '../..';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../../_index.html">Index (P)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../../JSON.html" title="JSON (module)">JSON</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../Ext.html" title="JSON::Ext (module)">Ext</a></span></span>
     &raquo; 
    <span class="title">Parser</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: JSON::Ext::Parser
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">JSON::Ext::Parser</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">ext/json/parser/parser.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
This is the JSON parser implemented as a C extension. It can be configured
to be used by setting
</p>
<pre class="code">
 <span class='const'>JSON</span><span class='period'>.</span><span class='id parser'>parser</span> <span class='op'>=</span> <span class='const'>JSON</span><span class='op'>::</span><span class='const'>Ext</span><span class='op'>::</span><span class='const'>Parser</span>
</pre>
<p>
with the method parser= in JSON.
</p>


  </div>
</div>
<div class="tags">
  
</div>


  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#new-instance_method" title="#new (instance method)">- (Object) <strong>new</strong>(source, opts) </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates a new JSON::Ext::Parser instance for the string <em>source</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#parse-instance_method" title="#parse (instance method)">- (Object) <strong>parse</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Parses the current JSON text <em>source</em> and returns the complete data.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#source-instance_method" title="#source (instance method)">- (Object) <strong>source</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of the current <em>source</em> string, that was used to
construct this Parser.
</p>
</div></span>
  
</li>

      
    </ul>
  

<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    - (<tt><span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(source, opts) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates a new JSON::Ext::Parser instance for the string <em>source</em>.
</p>
<p>
Creates a new JSON::Ext::Parser instance for the string <em>source</em>.
</p>
<p>
It will be configured by the <em>opts</em> hash. <em>opts</em> can have the
following keys:
</p>
<p>
<em>opts</em> can have the following keys:
</p>
<ul>
<li><p>
<b>max_nesting</b>: The maximum depth of nesting allowed in the parsed data
structures. Disable depth checking with :max_nesting => false|nil|0, it
defaults to 19.
</p>
</li>
<li><p>
<b>allow_nan</b>: If set to true, allow NaN, Infinity and -Infinity in
defiance of RFC 4627 to be parsed by the Parser. This option defaults to
false.
</p>
</li>
<li><p>
<b>symbolize_names</b>: If set to true, returns symbols for the names
(keys) in a JSON object. Otherwise strings are returned, which is also the
default.
</p>
</li>
<li><p>
<b>create_additions</b>: If set to false, the Parser doesn&#8217;t create
additions even if a matchin class and create_id was found. This option
defaults to true.
</p>
</li>
<li><p>
<b>object_class</b>: Defaults to Hash
</p>
</li>
<li><p>
<b>array_class</b>: Defaults to Array
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/json/parser/parser.c'</span>

/*
 * call-seq: new(source, opts =&gt; {})
 *
 * Creates a new JSON::Ext::Parser instance for the string _source_.
 *
 * Creates a new JSON::Ext::Parser instance for the string _source_.
 *
 * It will be configured by the _opts_ hash. _opts_ can have the following
 * keys:
 *
 * _opts_ can have the following keys:
 * * *max_nesting*: The maximum depth of nesting allowed in the parsed data
 *   structures. Disable depth checking with :max_nesting =&gt; false|nil|0, it
 *   defaults to 19.
 * * *allow_nan*: If set to true, allow NaN, Infinity and -Infinity in
 *   defiance of RFC 4627 to be parsed by the Parser. This option defaults to
 *   false.
 * * *symbolize_names*: If set to true, returns symbols for the names
 *   (keys) in a JSON object. Otherwise strings are returned, which is also
 *   the default.
 * * *create_additions*: If set to false, the Parser doesn't create
 *   additions even if a matchin class and create_id was found. This option
 *   defaults to true.
 * * *object_class*: Defaults to Hash
 * * *array_class*: Defaults to Array
 */
static VALUE cParser_initialize(int argc, VALUE *argv, VALUE self)
{
    char *ptr;
    long len;
    VALUE source, opts;
    GET_PARSER;
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;source, &amp;opts);
    source = convert_encoding(StringValue(source));
    ptr = RSTRING_PTR(source);
    len = RSTRING_LEN(source);
    if (!NIL_P(opts)) {
        opts = rb_convert_type(opts, T_HASH, &quot;Hash&quot;, &quot;to_hash&quot;);
        if (NIL_P(opts)) {
            rb_raise(rb_eArgError, &quot;opts needs to be like a hash&quot;);
        } else {
            VALUE tmp = ID2SYM(i_max_nesting);
            if (option_given_p(opts, tmp)) {
                VALUE max_nesting = rb_hash_aref(opts, tmp);
                if (RTEST(max_nesting)) {
                    Check_Type(max_nesting, T_FIXNUM);
                    json-&gt;max_nesting = FIX2INT(max_nesting);
                } else {
                    json-&gt;max_nesting = 0;
                }
            } else {
                json-&gt;max_nesting = 19;
            }
            tmp = ID2SYM(i_allow_nan);
            if (option_given_p(opts, tmp)) {
                VALUE allow_nan = rb_hash_aref(opts, tmp);
                json-&gt;allow_nan = RTEST(allow_nan) ? 1 : 0;
            } else {
                json-&gt;allow_nan = 0;
            }
            tmp = ID2SYM(i_symbolize_names);
            if (option_given_p(opts, tmp)) {
                VALUE symbolize_names = rb_hash_aref(opts, tmp);
                json-&gt;symbolize_names = RTEST(symbolize_names) ? 1 : 0;
            } else {
                json-&gt;symbolize_names = 0;
            }
            tmp = ID2SYM(i_create_additions);
            if (option_given_p(opts, tmp)) {
                VALUE create_additions = rb_hash_aref(opts, tmp);
                if (RTEST(create_additions)) {
                    json-&gt;create_id = rb_funcall(mJSON, i_create_id, 0);
                } else {
                    json-&gt;create_id = Qnil;
                }
            } else {
                json-&gt;create_id = rb_funcall(mJSON, i_create_id, 0);
            }
            tmp = ID2SYM(i_object_class);
            if (option_given_p(opts, tmp)) {
                json-&gt;object_class = rb_hash_aref(opts, tmp);
            } else {
                json-&gt;object_class = Qnil;
            }
            tmp = ID2SYM(i_array_class);
            if (option_given_p(opts, tmp)) {
                json-&gt;array_class = rb_hash_aref(opts, tmp);
            } else {
                json-&gt;array_class = Qnil;
            }
        }
    } else {
        json-&gt;max_nesting = 19;
        json-&gt;allow_nan = 0;
        json-&gt;create_id = rb_funcall(mJSON, i_create_id, 0);
        json-&gt;object_class = Qnil;
        json-&gt;array_class = Qnil;
    }
    json-&gt;current_nesting = 0;
    json-&gt;len = len;
    json-&gt;source = ptr;
    json-&gt;Vsource = source;
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="parse-instance_method">
  
    - (<tt><span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span></tt>) <strong>parse</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Parses the current JSON text <em>source</em> and returns the complete data
</p>
<pre class="code">
 structure as a result.</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/json/parser/parser.c'</span>

/*
 * call-seq: parse()
 *
 *  Parses the current JSON text _source_ and returns the complete data
 *  structure as a result.
 */
static VALUE cParser_parse(VALUE self)
{
    char *p, *pe;
    int cs = EVIL;
    VALUE result = Qnil;
    GET_PARSER;

    
#line 1702 &quot;parser.c&quot;
    {
    cs = JSON_start;
    }

#line 699 &quot;parser.rl&quot;
    p = json-&gt;source;
    pe = p + json-&gt;len;
    
#line 1711 &quot;parser.c&quot;
    {
    if ( p == pe )
        goto _test_eof;
    switch ( cs )
    {
st1:
    if ( ++p == pe )
        goto _test_eof1;
case 1:
    switch( (*p) ) {
        case 13: goto st1;
        case 32: goto st1;
        case 47: goto st2;
        case 91: goto tr3;
        case 123: goto tr4;
    }
    if ( 9 &lt;= (*p) &amp;&amp; (*p) &lt;= 10 )
        goto st1;
    goto st0;
st0:
cs = 0;
    goto _out;
st2:
    if ( ++p == pe )
        goto _test_eof2;
case 2:
    switch( (*p) ) {
        case 42: goto st3;
        case 47: goto st5;
    }
    goto st0;
st3:
    if ( ++p == pe )
        goto _test_eof3;
case 3:
    if ( (*p) == 42 )
        goto st4;
    goto st3;
st4:
    if ( ++p == pe )
        goto _test_eof4;
case 4:
    switch( (*p) ) {
        case 42: goto st4;
        case 47: goto st1;
    }
    goto st3;
st5:
    if ( ++p == pe )
        goto _test_eof5;
case 5:
    if ( (*p) == 10 )
        goto st1;
    goto st5;
tr3:
#line 507 &quot;parser.rl&quot;
    {
        char *np;
        json-&gt;current_nesting = 1;
        np = JSON_parse_array(json, p, pe, &amp;result);
        if (np == NULL) { p--; {p++; cs = 10; goto _out;} } else {p = (( np))-1;}
    }
    goto st10;
tr4:
#line 500 &quot;parser.rl&quot;
    {
        char *np;
        json-&gt;current_nesting = 1;
        np = JSON_parse_object(json, p, pe, &amp;result);
        if (np == NULL) { p--; {p++; cs = 10; goto _out;} } else {p = (( np))-1;}
    }
    goto st10;
st10:
    if ( ++p == pe )
        goto _test_eof10;
case 10:
#line 1788 &quot;parser.c&quot;
    switch( (*p) ) {
        case 13: goto st10;
        case 32: goto st10;
        case 47: goto st6;
    }
    if ( 9 &lt;= (*p) &amp;&amp; (*p) &lt;= 10 )
        goto st10;
    goto st0;
st6:
    if ( ++p == pe )
        goto _test_eof6;
case 6:
    switch( (*p) ) {
        case 42: goto st7;
        case 47: goto st9;
    }
    goto st0;
st7:
    if ( ++p == pe )
        goto _test_eof7;
case 7:
    if ( (*p) == 42 )
        goto st8;
    goto st7;
st8:
    if ( ++p == pe )
        goto _test_eof8;
case 8:
    switch( (*p) ) {
        case 42: goto st8;
        case 47: goto st10;
    }
    goto st7;
st9:
    if ( ++p == pe )
        goto _test_eof9;
case 9:
    if ( (*p) == 10 )
        goto st10;
    goto st9;
    }
    _test_eof1: cs = 1; goto _test_eof; 
    _test_eof2: cs = 2; goto _test_eof; 
    _test_eof3: cs = 3; goto _test_eof; 
    _test_eof4: cs = 4; goto _test_eof; 
    _test_eof5: cs = 5; goto _test_eof; 
    _test_eof10: cs = 10; goto _test_eof; 
    _test_eof6: cs = 6; goto _test_eof; 
    _test_eof7: cs = 7; goto _test_eof; 
    _test_eof8: cs = 8; goto _test_eof; 
    _test_eof9: cs = 9; goto _test_eof; 

    _test_eof: {}
    _out: {}
    }

#line 702 &quot;parser.rl&quot;

    if (cs &gt;= JSON_first_final &amp;&amp; p == pe) {
        return result;
    } else {
        rb_raise(eParserError, &quot;%u: unexpected token at '%s'&quot;, __LINE__, p);
        return Qnil;
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="source-instance_method">
  
    - (<tt><span class='object_link'><a href="../../Object.html" title="Object (class)">Object</a></span></tt>) <strong>source</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of the current <em>source</em> string, that was used to
construct this Parser.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/json/parser/parser.c'</span>

/*
 * call-seq: source()
 *
 * Returns a copy of the current _source_ string, that was used to construct
 * this Parser.
 */
static VALUE cParser_source(VALUE self)
{
    GET_PARSER;
    return rb_str_dup(json-&gt;Vsource);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:02:32 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>