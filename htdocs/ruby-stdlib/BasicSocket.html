<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: BasicSocket</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (B)</a> &raquo; 
    
    
    <span class="title">BasicSocket</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: BasicSocket
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="IO.html" title="IO (class)">IO</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next"><span class='object_link'><a href="IO.html" title="IO (class)">IO</a></span></li>
          
            <li class="next">BasicSocket</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">ext/socket/basicsocket.c</dd>
  
</dl>
<div class="clear"></div>

<div id="subclasses">
  <h2>Direct Known Subclasses</h2>
  <p class="children"><span class='object_link'><a href="IPSocket.html" title="IPSocket (class)">IPSocket</a></span>, <span class='object_link'><a href="Socket.html" title="Socket (class)">Socket</a></span>, <span class='object_link'><a href="UNIXSocket.html" title="UNIXSocket (class)">UNIXSocket</a></span></p>
</div>


  
  
  
  

  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#do_not_reverse_lookup-class_method" title="do_not_reverse_lookup (class method)">+ (Boolean) <strong>do_not_reverse_lookup</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Gets the global do_not_reverse_lookup flag.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#do_not_reverse_lookup%3D-class_method" title="do_not_reverse_lookup= (class method)">+ (Object) <strong>do_not_reverse_lookup=</strong>(bool) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets the global do_not_reverse_lookup flag.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#for_fd-class_method" title="for_fd (class method)">+ (Object) <strong>for_fd</strong>(fd) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a socket object which contains the file descriptor, <em>fd</em>.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_read-instance_method" title="#close_read (instance method)">- (nil) <strong>close_read</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Disallows further read using shutdown system call.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_write-instance_method" title="#close_write (instance method)">- (nil) <strong>close_write</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Disallows further write using shutdown system call.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#do_not_reverse_lookup-instance_method" title="#do_not_reverse_lookup (instance method)">- (Boolean) <strong>do_not_reverse_lookup</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Gets the do_not_reverse_lookup flag of <em>basicsocket</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#do_not_reverse_lookup%3D-instance_method" title="#do_not_reverse_lookup= (instance method)">- (Object) <strong>do_not_reverse_lookup=</strong>(bool) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets the do_not_reverse_lookup flag of <em>basicsocket</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getpeereid-instance_method" title="#getpeereid (instance method)">- (Array) <strong>getpeereid</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the user and group on the peer of the UNIX socket.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getpeername-instance_method" title="#getpeername (instance method)">- (Object) <strong>getpeername</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the remote address of the socket as a sockaddr string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getsockname-instance_method" title="#getsockname (instance method)">- (Object) <strong>getsockname</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the local address of the socket as a sockaddr string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getsockopt-instance_method" title="#getsockopt (instance method)">- (Object) <strong>getsockopt</strong>(level, optname) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Gets a socket option.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#local_address-instance_method" title="#local_address (instance method)">- (Object) <strong>local_address</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an Addrinfo object for local address obtained by getsockname.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#recv-instance_method" title="#recv (instance method)">- (Object) <strong>recv</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Receives a message.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#recv_nonblock-instance_method" title="#recv_nonblock (instance method)">- (Object) <strong>recv_nonblock</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using recvfrom(2)
after O_NONBLOCK is set for the underlying file descriptor.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#recvmsg-instance_method" title="#recvmsg (instance method)">- (Object) <strong>recvmsg</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#recvmsg_nonblock-instance_method" title="#recvmsg_nonblock (instance method)">- (Object) <strong>recvmsg_nonblock</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#remote_address-instance_method" title="#remote_address (instance method)">- (Object) <strong>remote_address</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an Addrinfo object for remote address obtained by getpeername.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#send-instance_method" title="#send (instance method)">- (Object) <strong>send</strong>(mesg, flags[, dest_sockaddr]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
send <em>mesg</em> via <em>basicsocket</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sendmsg-instance_method" title="#sendmsg (instance method)">- (Object) <strong>sendmsg</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sendmsg_nonblock-instance_method" title="#sendmsg_nonblock (instance method)">- (Object) <strong>sendmsg_nonblock</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#setsockopt-instance_method" title="#setsockopt (instance method)">- (Object) <strong>setsockopt</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets a socket option.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#shutdown-instance_method" title="#shutdown (instance method)">- (0) <strong>shutdown</strong>([how]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Calls shutdown(2) system call.
</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  <h3 class="inherited">Methods inherited from <span class='object_link'><a href="IO.html" title="IO (class)">IO</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="IO.html#nread-instance_method" title="IO#nread (method)">#nread</a></span>, <span class='object_link'><a href="IO.html#ready%3F-instance_method" title="IO#ready? (method)">#ready?</a></span>, <span class='object_link'><a href="IO.html#scanf-instance_method" title="IO#scanf (method)">#scanf</a></span>, <span class='object_link'><a href="IO.html#wait-instance_method" title="IO#wait (method)">#wait</a></span></p>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="do_not_reverse_lookup-class_method">
  
    + (<tt>Boolean</tt>) <strong>do_not_reverse_lookup</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Gets the global do_not_reverse_lookup flag.
</p>
<pre class="code">
  BasicSocket.do_not_reverse_lookup  #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   BasicSocket.do_not_reverse_lookup =&gt; true or false
 *
 * Gets the global do_not_reverse_lookup flag.
 *
 *   BasicSocket.do_not_reverse_lookup  #=&gt; false
 */
static VALUE
bsock_do_not_rev_lookup(void)
{
    return rsock_do_not_reverse_lookup?Qtrue:Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="do_not_reverse_lookup=-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>do_not_reverse_lookup=</strong>(bool) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets the global do_not_reverse_lookup flag.
</p>
<p>
The flag is used for initial value of do_not_reverse_lookup for each
socket.
</p>
<pre class="code">
  s1 = TCPSocket.new(&quot;localhost&quot;, 80)
  p s1.do_not_reverse_lookup                 #=&gt; true
  BasicSocket.do_not_reverse_lookup = false
  s2 = TCPSocket.new(&quot;localhost&quot;, 80)
  p s2.do_not_reverse_lookup                 #=&gt; false
  p s1.do_not_reverse_lookup                 #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   BasicSocket.do_not_reverse_lookup = bool
 *
 * Sets the global do_not_reverse_lookup flag.
 *
 * The flag is used for initial value of do_not_reverse_lookup for each socket.
 *
 *   s1 = TCPSocket.new(&quot;localhost&quot;, 80)
 *   p s1.do_not_reverse_lookup                 #=&gt; true
 *   BasicSocket.do_not_reverse_lookup = false
 *   s2 = TCPSocket.new(&quot;localhost&quot;, 80)
 *   p s2.do_not_reverse_lookup                 #=&gt; false
 *   p s1.do_not_reverse_lookup                 #=&gt; true
 *
 */
static VALUE
bsock_do_not_rev_lookup_set(VALUE self, VALUE val)
{
    rb_secure(4);
    rsock_do_not_reverse_lookup = RTEST(val);
    return val;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="for_fd-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>for_fd</strong>(fd) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a socket object which contains the file descriptor, <em>fd</em>.
</p>
<pre class="code">
  # If invoked by inetd, STDIN/STDOUT/STDERR is a socket.
  STDIN_SOCK = Socket.for_fd(STDIN.fileno)
  p STDIN_SOCK.remote_address</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   BasicSocket.for_fd(fd) =&gt; basicsocket
 *
 * Returns a socket object which contains the file descriptor, _fd_.
 *
 *   # If invoked by inetd, STDIN/STDOUT/STDERR is a socket.
 *   STDIN_SOCK = Socket.for_fd(STDIN.fileno)
 *   p STDIN_SOCK.remote_address
 *
 */
static VALUE
bsock_s_for_fd(VALUE klass, VALUE fd)
{
    rb_io_t *fptr;
    VALUE sock = rsock_init_sock(rb_obj_alloc(klass), NUM2INT(fd));

    GetOpenFile(sock, fptr);

    return sock;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="close_read-instance_method">
  
    - (<tt>nil</tt>) <strong>close_read</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Disallows further read using shutdown system call.
</p>
<pre class="code">
  s1, s2 = UNIXSocket.pair
  s1.close_read
  s2.puts #=&gt; Broken pipe (Errno::EPIPE)</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.close_read =&gt; nil
 *
 * Disallows further read using shutdown system call.
 *
 *   s1, s2 = UNIXSocket.pair
 *   s1.close_read
 *   s2.puts #=&gt; Broken pipe (Errno::EPIPE)
 */
static VALUE
bsock_close_read(VALUE sock)
{
    rb_io_t *fptr;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(sock)) {
    rb_raise(rb_eSecurityError, &quot;Insecure: can't close socket&quot;);
    }
    GetOpenFile(sock, fptr);
    shutdown(fptr-&gt;fd, 0);
    if (!(fptr-&gt;mode &amp; FMODE_WRITABLE)) {
    return rb_io_close(sock);
    }
    fptr-&gt;mode &amp;= ~FMODE_READABLE;

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="close_write-instance_method">
  
    - (<tt>nil</tt>) <strong>close_write</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Disallows further write using shutdown system call.
</p>
<pre class="code">
  UNIXSocket.pair {|s1, s2|
    s1.print &quot;ping&quot;
    s1.close_write
    p s2.read        #=&gt; &quot;ping&quot;
    s2.print &quot;pong&quot;
    s2.close
    p s1.read        #=&gt; &quot;pong&quot;
  }</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.close_write =&gt; nil
 *
 * Disallows further write using shutdown system call.
 *
 *   UNIXSocket.pair {|s1, s2|
 *     s1.print &quot;ping&quot;
 *     s1.close_write
 *     p s2.read        #=&gt; &quot;ping&quot;
 *     s2.print &quot;pong&quot;
 *     s2.close
 *     p s1.read        #=&gt; &quot;pong&quot;
 *   }
 */
static VALUE
bsock_close_write(VALUE sock)
{
    rb_io_t *fptr;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(sock)) {
    rb_raise(rb_eSecurityError, &quot;Insecure: can't close socket&quot;);
    }
    GetOpenFile(sock, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_READABLE)) {
    return rb_io_close(sock);
    }
    shutdown(fptr-&gt;fd, 1);
    fptr-&gt;mode &amp;= ~FMODE_WRITABLE;

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="do_not_reverse_lookup-instance_method">
  
    - (<tt>Boolean</tt>) <strong>do_not_reverse_lookup</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Gets the do_not_reverse_lookup flag of <em>basicsocket</em>.
</p>
<pre class="code">
  TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|sock|
    p sock.do_not_reverse_lookup      #=&gt; false
    p sock.peeraddr                   #=&gt; [&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;]
    sock.do_not_reverse_lookup = true
    p sock.peeraddr                   #=&gt; [&quot;AF_INET&quot;, 80, &quot;221.186.184.68&quot;, &quot;221.186.184.68&quot;]
  }</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.do_not_reverse_lookup =&gt; true or false
 *
 * Gets the do_not_reverse_lookup flag of _basicsocket_.
 *
 *   TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|sock|
 *     p sock.do_not_reverse_lookup      #=&gt; false
 *     p sock.peeraddr                   #=&gt; [&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;]
 *     sock.do_not_reverse_lookup = true
 *     p sock.peeraddr                   #=&gt; [&quot;AF_INET&quot;, 80, &quot;221.186.184.68&quot;, &quot;221.186.184.68&quot;]
 *   }
 */
static VALUE
bsock_do_not_reverse_lookup(VALUE sock)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    return (fptr-&gt;mode &amp; FMODE_NOREVLOOKUP) ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="do_not_reverse_lookup=-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>do_not_reverse_lookup=</strong>(bool) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets the do_not_reverse_lookup flag of <em>basicsocket</em>.
</p>
<pre class="code">
  BasicSocket.do_not_reverse_lookup = false
  p TCPSocket.new(&quot;127.0.0.1&quot;, 80).do_not_reverse_lookup #=&gt; false
  BasicSocket.do_not_reverse_lookup = true
  p TCPSocket.new(&quot;127.0.0.1&quot;, 80).do_not_reverse_lookup #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.do_not_reverse_lookup = bool
 *
 * Sets the do_not_reverse_lookup flag of _basicsocket_.
 *
 *   BasicSocket.do_not_reverse_lookup = false
 *   p TCPSocket.new(&quot;127.0.0.1&quot;, 80).do_not_reverse_lookup #=&gt; false
 *   BasicSocket.do_not_reverse_lookup = true
 *   p TCPSocket.new(&quot;127.0.0.1&quot;, 80).do_not_reverse_lookup #=&gt; true
 *
 */
static VALUE
bsock_do_not_reverse_lookup_set(VALUE sock, VALUE state)
{
    rb_io_t *fptr;

    rb_secure(4);
    GetOpenFile(sock, fptr);
    if (RTEST(state)) {
    fptr-&gt;mode |= FMODE_NOREVLOOKUP;
    }
    else {
    fptr-&gt;mode &amp;= ~FMODE_NOREVLOOKUP;
    }
    return sock;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getpeereid-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getpeereid</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the user and group on the peer of the UNIX socket. The result is a
two element array which contains the effective uid and the effective gid.
</p>
<pre class="code">
  Socket.unix_server_loop(&quot;/tmp/sock&quot;) {|s|
    begin
      euid, egid = s.getpeereid

      # Check the connected client is myself or not.
      next if euid != Process.uid

      # do something about my resource.

    ensure
      s.close
    end
  }</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.getpeereid =&gt; [euid, egid]
 *
 * Returns the user and group on the peer of the UNIX socket.
 * The result is a two element array which contains the effective uid and the effective gid.
 *
 *   Socket.unix_server_loop(&quot;/tmp/sock&quot;) {|s|
 *     begin
 *       euid, egid = s.getpeereid
 *
 *       # Check the connected client is myself or not.
 *       next if euid != Process.uid
 *
 *       # do something about my resource.
 *
 *     ensure
 *       s.close
 *     end
 *   }
 *
 */
static VALUE
bsock_getpeereid(VALUE self)
{
#if defined(HAVE_GETPEEREID)
    rb_io_t *fptr;
    uid_t euid;
    gid_t egid;
    GetOpenFile(self, fptr);
    if (getpeereid(fptr-&gt;fd, &amp;euid, &amp;egid) == -1)
    rb_sys_fail(&quot;getpeereid&quot;);
    return rb_assoc_new(UIDT2NUM(euid), GIDT2NUM(egid));
#elif defined(SO_PEERCRED) /* GNU/Linux */
    rb_io_t *fptr;
    struct ucred cred;
    socklen_t len = sizeof(cred);
    GetOpenFile(self, fptr);
    if (getsockopt(fptr-&gt;fd, SOL_SOCKET, SO_PEERCRED, &amp;cred, &amp;len) == -1)
    rb_sys_fail(&quot;getsockopt(SO_PEERCRED)&quot;);
    return rb_assoc_new(UIDT2NUM(cred.uid), GIDT2NUM(cred.gid));
#elif defined(HAVE_GETPEERUCRED) /* Solaris */
    rb_io_t *fptr;
    ucred_t *uc = NULL;
    VALUE ret;
    GetOpenFile(self, fptr);
    if (getpeerucred(fptr-&gt;fd, &amp;uc) == -1)
    rb_sys_fail(&quot;getpeerucred&quot;);
    ret = rb_assoc_new(UIDT2NUM(ucred_geteuid(uc)), GIDT2NUM(ucred_getegid(uc)));
    ucred_free(uc);
    return ret;
#endif
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getpeername-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>getpeername</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the remote address of the socket as a sockaddr string.
</p>
<pre class="code">
  TCPServer.open(&quot;127.0.0.1&quot;, 1440) {|serv|
    c = TCPSocket.new(&quot;127.0.0.1&quot;, 1440)
    s = serv.accept
    p s.getpeername #=&gt; &quot;\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
  }
</pre>
<p>
If Addrinfo object is preferred over the binary string, use
BasicSocket#remote_address.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.getpeername =&gt; sockaddr
 *
 * Returns the remote address of the socket as a sockaddr string.
 *
 *   TCPServer.open(&quot;127.0.0.1&quot;, 1440) {|serv|
 *     c = TCPSocket.new(&quot;127.0.0.1&quot;, 1440)
 *     s = serv.accept
 *     p s.getpeername #=&gt; &quot;\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
 *   }
 *
 * If Addrinfo object is preferred over the binary string,
 * use BasicSocket#remote_address.
 *
 */
static VALUE
bsock_getpeername(VALUE sock)
{
    struct sockaddr_storage buf;
    socklen_t len = (socklen_t)sizeof buf;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fptr-&gt;fd, (struct sockaddr*)&amp;buf, &amp;len) &lt; 0)
    rb_sys_fail(&quot;getpeername(2)&quot;);
    return rb_str_new((char*)&amp;buf, len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getsockname-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>getsockname</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the local address of the socket as a sockaddr string.
</p>
<pre class="code">
  TCPServer.open(&quot;127.0.0.1&quot;, 15120) {|serv|
    p serv.getsockname #=&gt; &quot;\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
  }
</pre>
<p>
If Addrinfo object is preferred over the binary string, use
BasicSocket#local_address.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.getsockname =&gt; sockaddr
 *
 * Returns the local address of the socket as a sockaddr string.
 *
 *   TCPServer.open(&quot;127.0.0.1&quot;, 15120) {|serv|
 *     p serv.getsockname #=&gt; &quot;\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
 *   }
 *
 * If Addrinfo object is preferred over the binary string,
 * use BasicSocket#local_address.
 */
static VALUE
bsock_getsockname(VALUE sock)
{
    struct sockaddr_storage buf;
    socklen_t len = (socklen_t)sizeof buf;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fptr-&gt;fd, (struct sockaddr*)&amp;buf, &amp;len) &lt; 0)
    rb_sys_fail(&quot;getsockname(2)&quot;);
    return rb_str_new((char*)&amp;buf, len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getsockopt-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>getsockopt</strong>(level, optname) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Gets a socket option. These are protocol and system specific, see your
local system documentation for details. The option is returned as a
Socket::Option object.
</p>
<h3>Parameters</h3>
<ul>
<li><p>
<tt>level</tt> is an integer, usually one of the SOL_ constants such as
Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
possibly without prefix, is also accepted.
</p>
</li>
<li><p>
<tt>optname</tt> is an integer, usually one of the SO_ constants, such as
Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
prefix, is also accepted.
</p>
</li>
</ul>
<h3>Examples</h3>
<p>
Some socket options are integers with boolean values, in this case
#getsockopt could be called like this:
</p>
<pre class="code">
  reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool

  optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
  optval = optval.unpack &quot;i&quot;
  reuseaddr = optval[0] == 0 ? false : true
</pre>
<p>
Some socket options are integers with numeric values, in this case
#getsockopt could be called like this:
</p>
<pre class="code">
  ipttl = sock.getsockopt(:IP, :TTL).int

  optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
  ipttl = optval.unpack(&quot;i&quot;)[0]
</pre>
<p>
Option values may be structs. Decoding them can be complex as it involves
examining your system headers to determine the correct definition. An
example is a <tt>struct linger</tt>, which may be defined in your system headers
as:
</p>
<pre class="code">
  struct linger {
    int l_onoff;
    int l_linger;
  };
</pre>
<p>
In this case #getsockopt could be called like this:
</p>
<pre class="code">
  # Socket::Option knows linger structure.
  onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger

  optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
  onoff, linger = optval.unpack &quot;ii&quot;
  onoff = onoff == 0 ? false : true</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * Document-method: getsockopt
 * call-seq:
 *   getsockopt(level, optname) =&gt; socketoption
 *
 * Gets a socket option. These are protocol and system specific, see your
 * local system documentation for details. The option is returned as
 * a Socket::Option object.
 *
 * === Parameters
 * * +level+ is an integer, usually one of the SOL_ constants such as
 *   Socket::SOL_SOCKET, or a protocol level.
 *   A string or symbol of the name, possibly without prefix, is also
 *   accepted.
 * * +optname+ is an integer, usually one of the SO_ constants, such
 *   as Socket::SO_REUSEADDR.
 *   A string or symbol of the name, possibly without prefix, is also
 *   accepted.
 *
 * === Examples
 *
 * Some socket options are integers with boolean values, in this case
 * #getsockopt could be called like this:
 *
 *   reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool
 *
 *   optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
 *   optval = optval.unpack &quot;i&quot;
 *   reuseaddr = optval[0] == 0 ? false : true
 *
 * Some socket options are integers with numeric values, in this case
 * #getsockopt could be called like this:
 *
 *   ipttl = sock.getsockopt(:IP, :TTL).int
 *
 *   optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
 *   ipttl = optval.unpack(&quot;i&quot;)[0]
 *
 * Option values may be structs. Decoding them can be complex as it involves
 * examining your system headers to determine the correct definition. An
 * example is a +struct linger+, which may be defined in your system headers
 * as:
 *   struct linger {
 *     int l_onoff;
 *     int l_linger;
 *   };
 *
 * In this case #getsockopt could be called like this:
 *
 *   # Socket::Option knows linger structure.
 *   onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger
 *
 *   optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
 *   onoff, linger = optval.unpack &quot;ii&quot;
 *   onoff = onoff == 0 ? false : true
*/
static VALUE
bsock_getsockopt(VALUE sock, VALUE lev, VALUE optname)
{
    int level, option;
    socklen_t len;
    char *buf;
    rb_io_t *fptr;
    int family;

    GetOpenFile(sock, fptr);
    family = rsock_getfamily(fptr-&gt;fd);
    level = rsock_level_arg(family, lev);
    option = rsock_optname_arg(family, level, optname);
    len = 256;
    buf = ALLOCA_N(char,len);

    rb_io_check_closed(fptr);

    if (getsockopt(fptr-&gt;fd, level, option, buf, &amp;len) &lt; 0)
    rb_sys_fail_path(fptr-&gt;pathv);

    return rsock_sockopt_new(family, level, option, rb_str_new(buf, len));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="local_address-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>local_address</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an Addrinfo object for local address obtained by getsockname.
</p>
<p>
Note that addrinfo.protocol is filled by 0.
</p>
<pre class="code">
  TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|s|
    p s.local_address #=&gt; #&lt;Addrinfo: 192.168.0.129:36873 TCP&gt;
  }

  TCPServer.open(&quot;127.0.0.1&quot;, 1512) {|serv|
    p serv.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:1512 TCP&gt;
  }</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   bsock.local_address =&gt; addrinfo
 *
 * Returns an Addrinfo object for local address obtained by getsockname.
 *
 * Note that addrinfo.protocol is filled by 0.
 *
 *   TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|s|
 *     p s.local_address #=&gt; #&lt;Addrinfo: 192.168.0.129:36873 TCP&gt;
 *   }
 *
 *   TCPServer.open(&quot;127.0.0.1&quot;, 1512) {|serv|
 *     p serv.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:1512 TCP&gt;
 *   }
 *
 */
static VALUE
bsock_local_address(VALUE sock)
{
    struct sockaddr_storage buf;
    socklen_t len = (socklen_t)sizeof buf;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fptr-&gt;fd, (struct sockaddr*)&amp;buf, &amp;len) &lt; 0)
    rb_sys_fail(&quot;getsockname(2)&quot;);
    return rsock_fd_socket_addrinfo(fptr-&gt;fd, (struct sockaddr *)&amp;buf, len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="recv-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>recv</strong>(maxlen) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>recv</strong>(maxlen, flags) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Receives a message.
</p>
<p>
<em>maxlen</em> is the maximum number of bytes to receive.
</p>
<p>
<em>flags</em> should be a bitwise OR of Socket::MSG_* constants.
</p>
<pre class="code">
  UNIXSocket.pair {|s1, s2|
    s1.puts &quot;Hello World&quot;
    p s2.recv(4)                     #=&gt; &quot;Hell&quot;
    p s2.recv(4, Socket::MSG_PEEK)   #=&gt; &quot;o Wo&quot;
    p s2.recv(4)                     #=&gt; &quot;o Wo&quot;
    p s2.recv(10)                    #=&gt; &quot;rld\n&quot;
  }</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.recv(maxlen) =&gt; mesg
 *   basicsocket.recv(maxlen, flags) =&gt; mesg
 *
 * Receives a message.
 *
 * _maxlen_ is the maximum number of bytes to receive.
 *
 * _flags_ should be a bitwise OR of Socket::MSG_* constants.
 *
 *   UNIXSocket.pair {|s1, s2|
 *     s1.puts &quot;Hello World&quot;
 *     p s2.recv(4)                     #=&gt; &quot;Hell&quot;
 *     p s2.recv(4, Socket::MSG_PEEK)   #=&gt; &quot;o Wo&quot;
 *     p s2.recv(4)                     #=&gt; &quot;o Wo&quot;
 *     p s2.recv(10)                    #=&gt; &quot;rld\n&quot;
 *   }
 */
static VALUE
bsock_recv(int argc, VALUE *argv, VALUE sock)
{
    return rsock_s_recvfrom(sock, argc, argv, RECV_RECV);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="recv_nonblock-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>recv_nonblock</strong>(maxlen) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>recv_nonblock</strong>(maxlen, flags) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using recvfrom(2)
after O_NONBLOCK is set for the underlying file descriptor. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The result, <em>mesg</em>, is
the data received.
</p>
<p>
When recvfrom(2) returns 0, Socket#recv_nonblock returns an empty string as
data. The meaning depends on the socket: EOF on TCP, empty packet on UDP,
etc.
</p>
<h3>Parameters</h3>
<ul>
<li><p>
<tt>maxlen</tt> - the number of bytes to receive from the socket
</p>
</li>
<li><p>
<tt>flags</tt> - zero or more of the <tt>MSG_</tt> options
</p>
</li>
</ul>
<h3>Example</h3>
<pre class="code">
 serv = TCPServer.new(&quot;127.0.0.1&quot;, 0)
 af, port, host, addr = serv.addr
 c = TCPSocket.new(addr, port)
 s = serv.accept
 c.send &quot;aaa&quot;, 0
 begin # emulate blocking recv.
   p s.recv_nonblock(10) #=&gt; &quot;aaa&quot;
 rescue IO::WaitReadable
   IO.select([s])
   retry
 end
</pre>
<p>
Refer to Socket#recvfrom for the exceptions that may be thrown if the call
to <em>recv_nonblock</em> fails.
</p>
<p>
BasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2)
failure, including Errno::EWOULDBLOCK.
</p>
<p>
If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions
for retrying recv_nonblock.
</p>
<h3>See</h3>
<ul>
<li><p>
Socket#recvfrom
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *  basicsocket.recv_nonblock(maxlen) =&gt; mesg
 *  basicsocket.recv_nonblock(maxlen, flags) =&gt; mesg
 *
 * Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * _flags_ is zero or more of the +MSG_+ options.
 * The result, _mesg_, is the data received.
 *
 * When recvfrom(2) returns 0, Socket#recv_nonblock returns
 * an empty string as data.
 * The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.
 *
 * === Parameters
 * * +maxlen+ - the number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options
 *
 * === Example
 *  serv = TCPServer.new(&quot;127.0.0.1&quot;, 0)
 *  af, port, host, addr = serv.addr
 *  c = TCPSocket.new(addr, port)
 *  s = serv.accept
 *  c.send &quot;aaa&quot;, 0
 *  begin # emulate blocking recv.
 *    p s.recv_nonblock(10) #=&gt; &quot;aaa&quot;
 *  rescue IO::WaitReadable
 *    IO.select([s])
 *    retry
 *  end
 *
 * Refer to Socket#recvfrom for the exceptions that may be thrown if the call
 * to _recv_nonblock_ fails.
 *
 * BasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2) failure,
 * including Errno::EWOULDBLOCK.
 *
 * If the exception is Errno::EWOULDBLOCK or Errno::AGAIN,
 * it is extended by IO::WaitReadable.
 * So IO::WaitReadable can be used to rescue the exceptions for retrying recv_nonblock.
 *
 * === See
 * * Socket#recvfrom
 */

static VALUE
bsock_recv_nonblock(int argc, VALUE *argv, VALUE sock)
{
    return rsock_s_recvfrom_nonblock(sock, argc, argv, RECV_RECV);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="recvmsg-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>recvmsg</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="recvmsg_nonblock-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>recvmsg_nonblock</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="remote_address-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>remote_address</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an Addrinfo object for remote address obtained by getpeername.
</p>
<p>
Note that addrinfo.protocol is filled by 0.
</p>
<pre class="code">
  TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|s|
    p s.remote_address #=&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP&gt;
  }

  TCPServer.open(&quot;127.0.0.1&quot;, 1728) {|serv|
    c = TCPSocket.new(&quot;127.0.0.1&quot;, 1728)
    s = serv.accept
    p s.remote_address #=&gt; #&lt;Addrinfo: 127.0.0.1:36504 TCP&gt;
  }</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   bsock.remote_address =&gt; addrinfo
 *
 * Returns an Addrinfo object for remote address obtained by getpeername.
 *
 * Note that addrinfo.protocol is filled by 0.
 *
 *   TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|s|
 *     p s.remote_address #=&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP&gt;
 *   }
 *
 *   TCPServer.open(&quot;127.0.0.1&quot;, 1728) {|serv|
 *     c = TCPSocket.new(&quot;127.0.0.1&quot;, 1728)
 *     s = serv.accept
 *     p s.remote_address #=&gt; #&lt;Addrinfo: 127.0.0.1:36504 TCP&gt;
 *   }
 *
 */
static VALUE
bsock_remote_address(VALUE sock)
{
    struct sockaddr_storage buf;
    socklen_t len = (socklen_t)sizeof buf;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fptr-&gt;fd, (struct sockaddr*)&amp;buf, &amp;len) &lt; 0)
    rb_sys_fail(&quot;getpeername(2)&quot;);
    return rsock_fd_socket_addrinfo(fptr-&gt;fd, (struct sockaddr *)&amp;buf, len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="send-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>send</strong>(mesg, flags[, dest_sockaddr]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
send <em>mesg</em> via <em>basicsocket</em>.
</p>
<p>
<em>mesg</em> should be a string.
</p>
<p>
<em>flags</em> should be a bitwise OR of Socket::MSG_* constants.
</p>
<p>
<em>dest_sockaddr</em> should be a packed sockaddr string or an addrinfo.
</p>
<pre class="code">
  TCPSocket.open(&quot;localhost&quot;, 80) {|s|
    s.send &quot;GET / HTTP/1.0\r\n\r\n&quot;, 0
    p s.read
  }</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.send(mesg, flags [, dest_sockaddr]) =&gt; numbytes_sent
 *
 * send _mesg_ via _basicsocket_.
 *
 * _mesg_ should be a string.
 *
 * _flags_ should be a bitwise OR of Socket::MSG_* constants.
 *
 * _dest_sockaddr_ should be a packed sockaddr string or an addrinfo.
 *
 *   TCPSocket.open(&quot;localhost&quot;, 80) {|s|
 *     s.send &quot;GET / HTTP/1.0\r\n\r\n&quot;, 0
 *     p s.read
 *   }
 */
VALUE
rsock_bsock_send(int argc, VALUE *argv, VALUE sock)
{
    struct rsock_send_arg arg;
    VALUE flags, to;
    rb_io_t *fptr;
    int n;
    rb_blocking_function_t *func;

    rb_secure(4);
    rb_scan_args(argc, argv, &quot;21&quot;, &amp;arg.mesg, &amp;flags, &amp;to);

    StringValue(arg.mesg);
    if (!NIL_P(to)) {
    SockAddrStringValue(to);
    to = rb_str_new4(to);
    arg.to = (struct sockaddr *)RSTRING_PTR(to);
    arg.tolen = (socklen_t)RSTRING_LENINT(to);
    func = rsock_sendto_blocking;
    }
    else {
    func = rsock_send_blocking;
    }
    GetOpenFile(sock, fptr);
    arg.fd = fptr-&gt;fd;
    arg.flags = NUM2INT(flags);
    while (rb_thread_fd_writable(arg.fd),
       (n = (int)BLOCKING_REGION(func, &amp;arg)) &lt; 0) {
    if (rb_io_wait_writable(arg.fd)) {
        continue;
    }
    rb_sys_fail(&quot;send(2)&quot;);
    }
    return INT2FIX(n);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sendmsg-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sendmsg</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sendmsg_nonblock-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sendmsg_nonblock</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="setsockopt-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>setsockopt</strong>(level, optname, optval) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>setsockopt</strong>(socketoption) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets a socket option. These are protocol and system specific, see your
local system documentation for details.
</p>
<h3>Parameters</h3>
<ul>
<li><p>
<tt>level</tt> is an integer, usually one of the SOL_ constants such as
Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name,
possibly without prefix, is also accepted.
</p>
</li>
<li><p>
<tt>optname</tt> is an integer, usually one of the SO_ constants, such as
Socket::SO_REUSEADDR. A string or symbol of the name, possibly without
prefix, is also accepted.
</p>
</li>
<li><p>
<tt>optval</tt> is the value of the option, it is passed to the underlying
setsockopt() as a pointer to a certain number of bytes. How this is done
depends on the type:
</p>
<ul>
<li><p>
Fixnum: value is assigned to an int, and a pointer to the int is passed,
with length of sizeof(int).
</p>
</li>
</ul>
<ul>
<li><p>
true or false: 1 or 0 (respectively) is assigned to an int, and the int is
passed as for a Fixnum. Note that <tt>false</tt> must be passed, not
<tt>nil</tt>.
</p>
</li>
</ul>
<ul>
<li><p>
String: the string&#8217;s data and length is passed to the socket.
</p>
</li>
</ul>
</li>
<li><p>
<tt>socketoption</tt> is an instance of Socket::Option
</p>
</li>
</ul>
<h3>Examples</h3>
<p>
Some socket options are integers with boolean values, in this case
#setsockopt could be called like this:
</p>
<pre class="code">
  sock.setsockopt(:SOCKET, :REUSEADDR, true)
  sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
  sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))
</pre>
<p>
Some socket options are integers with numeric values, in this case
#setsockopt could be called like this:
</p>
<pre class="code">
  sock.setsockopt(:IP, :TTL, 255)
  sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
  sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))
</pre>
<p>
Option values may be structs. Passing them can be complex as it involves
examining your system headers to determine the correct definition. An
example is an <tt>ip_mreq</tt>, which may be defined in your system headers
as:
</p>
<pre class="code">
  struct ip_mreq {
    struct  in_addr imr_multiaddr;
    struct  in_addr imr_interface;
  };
</pre>
<p>
In this case #setsockopt could be called like this:
</p>
<pre class="code">
  optval = IPAddr.new(&quot;224.0.0.251&quot;).hton +
           IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton
  sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * Document-method: setsockopt
 * call-seq:
 *   setsockopt(level, optname, optval)
 *   setsockopt(socketoption)
 *
 * Sets a socket option. These are protocol and system specific, see your
 * local system documentation for details.
 *
 * === Parameters
 * * +level+ is an integer, usually one of the SOL_ constants such as
 *   Socket::SOL_SOCKET, or a protocol level.
 *   A string or symbol of the name, possibly without prefix, is also
 *   accepted.
 * * +optname+ is an integer, usually one of the SO_ constants, such
 *   as Socket::SO_REUSEADDR.
 *   A string or symbol of the name, possibly without prefix, is also
 *   accepted.
 * * +optval+ is the value of the option, it is passed to the underlying
 *   setsockopt() as a pointer to a certain number of bytes. How this is
 *   done depends on the type:
 *   - Fixnum: value is assigned to an int, and a pointer to the int is
 *     passed, with length of sizeof(int).
 *   - true or false: 1 or 0 (respectively) is assigned to an int, and the
 *     int is passed as for a Fixnum. Note that +false+ must be passed,
 *     not +nil+.
 *   - String: the string's data and length is passed to the socket.
 * * +socketoption+ is an instance of Socket::Option
 *
 * === Examples
 *
 * Some socket options are integers with boolean values, in this case
 * #setsockopt could be called like this:
 *   sock.setsockopt(:SOCKET, :REUSEADDR, true)
 *   sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
 *   sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))
 *
 * Some socket options are integers with numeric values, in this case
 * #setsockopt could be called like this:
 *   sock.setsockopt(:IP, :TTL, 255)
 *   sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
 *   sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))
 *
 * Option values may be structs. Passing them can be complex as it involves
 * examining your system headers to determine the correct definition. An
 * example is an +ip_mreq+, which may be defined in your system headers as:
 *   struct ip_mreq {
 *     struct  in_addr imr_multiaddr;
 *     struct  in_addr imr_interface;
 *   };
 *
 * In this case #setsockopt could be called like this:
 *   optval = IPAddr.new(&quot;224.0.0.251&quot;).hton +
 *            IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton
 *   sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)
 *
*/
static VALUE
bsock_setsockopt(int argc, VALUE *argv, VALUE sock)
{
    VALUE lev, optname, val;
    int family, level, option;
    rb_io_t *fptr;
    int i;
    char *v;
    int vlen;

    if (argc == 1) {
        lev = rb_funcall(argv[0], rb_intern(&quot;level&quot;), 0);
        optname = rb_funcall(argv[0], rb_intern(&quot;optname&quot;), 0);
        val = rb_funcall(argv[0], rb_intern(&quot;data&quot;), 0);
    }
    else {
        rb_scan_args(argc, argv, &quot;30&quot;, &amp;lev, &amp;optname, &amp;val);
    }

    rb_secure(2);
    GetOpenFile(sock, fptr);
    family = rsock_getfamily(fptr-&gt;fd);
    level = rsock_level_arg(family, lev);
    option = rsock_optname_arg(family, level, optname);

    switch (TYPE(val)) {
      case T_FIXNUM:
    i = FIX2INT(val);
    goto numval;
      case T_FALSE:
    i = 0;
    goto numval;
      case T_TRUE:
    i = 1;
      numval:
    v = (char*)&amp;i; vlen = (int)sizeof(i);
    break;
      default:
    StringValue(val);
    v = RSTRING_PTR(val);
    vlen = RSTRING_LENINT(val);
    break;
    }

#define rb_sys_fail_path(path) rb_sys_fail(NIL_P(path) ? 0 : RSTRING_PTR(path))

    rb_io_check_closed(fptr);
    if (setsockopt(fptr-&gt;fd, level, option, v, vlen) &lt; 0)
    rb_sys_fail_path(fptr-&gt;pathv);

    return INT2FIX(0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="shutdown-instance_method">
  
    - (<tt>0</tt>) <strong>shutdown</strong>([how]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Calls shutdown(2) system call.
</p>
<p>
s.shutdown(Socket::SHUT_RD) disallows further read.
</p>
<p>
s.shutdown(Socket::SHUT_WR) disallows further write.
</p>
<p>
s.shutdown(Socket::SHUT_RDWR) disallows further read and write.
</p>
<p>
<em>how</em> can be symbol or string:
</p>
<ul>
<li><p>
:RD, :SHUT_RD, &#8220;RD&#8221; and &#8220;SHUT_RD&#8221; are accepted as
Socket::SHUT_RD.
</p>
</li>
<li><p>
:WR, :SHUT_WR, &#8220;WR&#8221; and &#8220;SHUT_WR&#8221; are accepted as
Socket::SHUT_WR.
</p>
</li>
<li><p>
:RDWR, :SHUT_RDWR, &#8220;RDWR&#8221; and &#8220;SHUT_RDWR&#8221; are
accepted as Socket::SHUT_RDWR.
</p>
<p>
UNIXSocket.pair {|s1, s2|
</p>
<pre class="code">
  s1.puts &quot;ping&quot;
  s1.shutdown(:WR)
  p s2.read          #=&gt; &quot;ping\n&quot;
  s2.puts &quot;pong&quot;
  s2.close
  p s1.read          #=&gt; &quot;pong\n&quot;
</pre>
<p>
}
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/basicsocket.c'</span>

/*
 * call-seq:
 *   basicsocket.shutdown([how]) =&gt; 0
 *
 * Calls shutdown(2) system call.
 *
 * s.shutdown(Socket::SHUT_RD) disallows further read.
 *
 * s.shutdown(Socket::SHUT_WR) disallows further write.
 *
 * s.shutdown(Socket::SHUT_RDWR) disallows further read and write.
 *
 * _how_ can be symbol or string:
 * - :RD, :SHUT_RD, &quot;RD&quot; and &quot;SHUT_RD&quot; are accepted as Socket::SHUT_RD.
 * - :WR, :SHUT_WR, &quot;WR&quot; and &quot;SHUT_WR&quot; are accepted as Socket::SHUT_WR.
 * - :RDWR, :SHUT_RDWR, &quot;RDWR&quot; and &quot;SHUT_RDWR&quot; are accepted as Socket::SHUT_RDWR.
 *
 *   UNIXSocket.pair {|s1, s2|
 *     s1.puts &quot;ping&quot;
 *     s1.shutdown(:WR)
 *     p s2.read          #=&gt; &quot;ping\n&quot;
 *     s2.puts &quot;pong&quot;
 *     s2.close
 *     p s1.read          #=&gt; &quot;pong\n&quot;
 *   }
 *
 */
static VALUE
bsock_shutdown(int argc, VALUE *argv, VALUE sock)
{
    VALUE howto;
    int how;
    rb_io_t *fptr;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(sock)) {
    rb_raise(rb_eSecurityError, &quot;Insecure: can't shutdown socket&quot;);
    }
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;howto);
    if (howto == Qnil)
    how = SHUT_RDWR;
    else {
    how = rsock_shutdown_how_arg(howto);
        if (how != SHUT_WR &amp;&amp; how != SHUT_RD &amp;&amp; how != SHUT_RDWR) {
        rb_raise(rb_eArgError, &quot;`how' should be either :SHUT_RD, :SHUT_WR, :SHUT_RDWR&quot;);
    }
    }
    GetOpenFile(sock, fptr);
    if (shutdown(fptr-&gt;fd, how) == -1)
    rb_sys_fail(0);

    return INT2FIX(0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:01:46 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>