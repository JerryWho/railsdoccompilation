<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Socket</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (S)</a> &raquo; 
    
    
    <span class="title">Socket</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Socket
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="BasicSocket.html" title="BasicSocket (class)">BasicSocket</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next"><span class='object_link'><a href="IO.html" title="IO (class)">IO</a></span></li>
          
            <li class="next"><span class='object_link'><a href="BasicSocket.html" title="BasicSocket (class)">BasicSocket</a></span></li>
          
            <li class="next">Socket</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">lib/ipaddr.rb<span class="defines">,<br />
  ext/socket/socket.c</span>
</dd>
  
</dl>
<div class="clear"></div>

<h2>Defined Under Namespace</h2>
<p class="children">
   
    
      <strong class="modules">Modules:</strong> <span class='object_link'><a href="Socket/Constants.html" title="Socket::Constants (module)">Constants</a></span>
    
   
    
      <strong class="classes">Classes:</strong> <span class='object_link'><a href="Socket/AncillaryData.html" title="Socket::AncillaryData (class)">AncillaryData</a></span>, <span class='object_link'><a href="Socket/Option.html" title="Socket::Option (class)">Option</a></span>
    
  
</p>

  <h2>Constant Summary</h2>
  
    <dl class="constants">
      
        <dt id="AF_INET6-constant" class="">AF_INET6 =
          
        </dt>
        <dd><pre class="code"><span class='const'>Object</span><span class='period'>.</span><span class='id new'>new</span></pre></dd>
      
    </dl>
  


  
  
  
  
  
  
  
  

  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getaddrinfo-class_method" title="getaddrinfo (class method)">+ (Array) <strong>getaddrinfo</strong>(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Obtains address information for <em>nodename</em>:<em>servname</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gethostbyaddr-class_method" title="gethostbyaddr (class method)">+ (Object) <strong>gethostbyaddr</strong>(address_string[, address_family]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Obtains the host information for <em>address</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gethostbyname-class_method" title="gethostbyname (class method)">+ (Array) <strong>gethostbyname</strong>(hostname) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Obtains the host information for <em>hostname</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gethostname-class_method" title="gethostname (class method)">+ (Object) <strong>gethostname</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the hostname.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getnameinfo-class_method" title="getnameinfo (class method)">+ (Array) <strong>getnameinfo</strong>(sockaddr[, flags]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Obtains name information for <em>sockaddr</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getservbyname-class_method" title="getservbyname (class method)">+ (Object) <strong>getservbyname</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Obtains the port number for <em>service_name</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getservbyport-class_method" title="getservbyport (class method)">+ (Object) <strong>getservbyport</strong>(port[, protocol_name]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Obtains the port number for <em>port</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ip_address_list-class_method" title="ip_address_list (class method)">+ (Array) <strong>ip_address_list</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns local IP addresses as an array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pack_sockaddr_in-class_method" title="pack_sockaddr_in (class method)">+ (Object) <strong>pack_sockaddr_in</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Packs <em>port</em> and <em>host</em> as an AF_INET/AF_INET6 sockaddr
string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pack_sockaddr_un-class_method" title="pack_sockaddr_un (class method)">+ (Object) <strong>pack_sockaddr_un</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Packs <em>path</em> as an AF_UNIX sockaddr string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pair-class_method" title="pair (class method)">+ (Object) <strong>pair</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates a pair of sockets connected each other.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sockaddr_in-class_method" title="sockaddr_in (class method)">+ (Object) <strong>sockaddr_in</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Packs <em>port</em> and <em>host</em> as an AF_INET/AF_INET6 sockaddr
string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sockaddr_un-class_method" title="sockaddr_un (class method)">+ (Object) <strong>sockaddr_un</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Packs <em>path</em> as an AF_UNIX sockaddr string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#socketpair-class_method" title="socketpair (class method)">+ (Object) <strong>socketpair</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates a pair of sockets connected each other.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unpack_sockaddr_in-class_method" title="unpack_sockaddr_in (class method)">+ (Array) <strong>unpack_sockaddr_in</strong>(sockaddr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Unpacks <em>sockaddr</em> into port and ip_address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unpack_sockaddr_un-class_method" title="unpack_sockaddr_un (class method)">+ (Object) <strong>unpack_sockaddr_un</strong>(sockaddr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Unpacks <em>sockaddr</em> into path.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#accept-instance_method" title="#accept (instance method)">- (Array) <strong>accept</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Accepts a next connection.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#accept_nonblock-instance_method" title="#accept_nonblock (instance method)">- (Array) <strong>accept_nonblock</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Accepts an incoming connection using accept(2) after O_NONBLOCK is set for
the underlying file descriptor.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bind-instance_method" title="#bind (instance method)">- (0) <strong>bind</strong>(local_sockaddr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Binds to the given local address.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#connect-instance_method" title="#connect (instance method)">- (0) <strong>connect</strong>(remote_sockaddr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Requests a connection to be made on the given <tt>remote_sockaddr</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#connect_nonblock-instance_method" title="#connect_nonblock (instance method)">- (0) <strong>connect_nonblock</strong>(remote_sockaddr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Requests a connection to be made on the given <tt>remote_sockaddr</tt>
after O_NONBLOCK is set for the underlying file descriptor.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#new-instance_method" title="#new (instance method)">- (Object) <strong>new</strong>(domain, socktype[, protocol]) </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates a new socket object.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#listen-instance_method" title="#listen (instance method)">- (0) <strong>listen</strong>(int) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Listens for connections, using the specified <tt>int</tt> as the backlog.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#recvfrom-instance_method" title="#recvfrom (instance method)">- (Object) <strong>recvfrom</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#recvfrom_nonblock-instance_method" title="#recvfrom_nonblock (instance method)">- (Object) <strong>recvfrom_nonblock</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using recvfrom(2)
after O_NONBLOCK is set for the underlying file descriptor.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sysaccept-instance_method" title="#sysaccept (instance method)">- (Array) <strong>sysaccept</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Accepts an incoming connection returning an array containing the (integer)
file descriptor for the incoming connection, <em>client_socket_fd</em>, and
an Addrinfo, <em>client_addrinfo</em>.
</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  <h3 class="inherited">Methods inherited from <span class='object_link'><a href="BasicSocket.html" title="BasicSocket (class)">BasicSocket</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="BasicSocket.html#close_read-instance_method" title="BasicSocket#close_read (method)">#close_read</a></span>, <span class='object_link'><a href="BasicSocket.html#close_write-instance_method" title="BasicSocket#close_write (method)">#close_write</a></span>, <span class='object_link'><a href="BasicSocket.html#do_not_reverse_lookup-instance_method" title="BasicSocket#do_not_reverse_lookup (method)">#do_not_reverse_lookup</a></span>, <span class='object_link'><a href="BasicSocket.html#do_not_reverse_lookup-class_method" title="BasicSocket.do_not_reverse_lookup (method)">do_not_reverse_lookup</a></span>, <span class='object_link'><a href="BasicSocket.html#do_not_reverse_lookup%3D-class_method" title="BasicSocket.do_not_reverse_lookup= (method)">do_not_reverse_lookup=</a></span>, <span class='object_link'><a href="BasicSocket.html#do_not_reverse_lookup%3D-instance_method" title="BasicSocket#do_not_reverse_lookup= (method)">#do_not_reverse_lookup=</a></span>, <span class='object_link'><a href="BasicSocket.html#for_fd-class_method" title="BasicSocket.for_fd (method)">for_fd</a></span>, <span class='object_link'><a href="BasicSocket.html#getpeereid-instance_method" title="BasicSocket#getpeereid (method)">#getpeereid</a></span>, <span class='object_link'><a href="BasicSocket.html#getpeername-instance_method" title="BasicSocket#getpeername (method)">#getpeername</a></span>, <span class='object_link'><a href="BasicSocket.html#getsockname-instance_method" title="BasicSocket#getsockname (method)">#getsockname</a></span>, <span class='object_link'><a href="BasicSocket.html#getsockopt-instance_method" title="BasicSocket#getsockopt (method)">#getsockopt</a></span>, <span class='object_link'><a href="BasicSocket.html#local_address-instance_method" title="BasicSocket#local_address (method)">#local_address</a></span>, <span class='object_link'><a href="BasicSocket.html#recv-instance_method" title="BasicSocket#recv (method)">#recv</a></span>, <span class='object_link'><a href="BasicSocket.html#recv_nonblock-instance_method" title="BasicSocket#recv_nonblock (method)">#recv_nonblock</a></span>, <span class='object_link'><a href="BasicSocket.html#recvmsg-instance_method" title="BasicSocket#recvmsg (method)">#recvmsg</a></span>, <span class='object_link'><a href="BasicSocket.html#recvmsg_nonblock-instance_method" title="BasicSocket#recvmsg_nonblock (method)">#recvmsg_nonblock</a></span>, <span class='object_link'><a href="BasicSocket.html#remote_address-instance_method" title="BasicSocket#remote_address (method)">#remote_address</a></span>, <span class='object_link'><a href="BasicSocket.html#send-instance_method" title="BasicSocket#send (method)">#send</a></span>, <span class='object_link'><a href="BasicSocket.html#sendmsg-instance_method" title="BasicSocket#sendmsg (method)">#sendmsg</a></span>, <span class='object_link'><a href="BasicSocket.html#sendmsg_nonblock-instance_method" title="BasicSocket#sendmsg_nonblock (method)">#sendmsg_nonblock</a></span>, <span class='object_link'><a href="BasicSocket.html#setsockopt-instance_method" title="BasicSocket#setsockopt (method)">#setsockopt</a></span>, <span class='object_link'><a href="BasicSocket.html#shutdown-instance_method" title="BasicSocket#shutdown (method)">#shutdown</a></span></p>

  
  
  
  
  
  
  
  <h3 class="inherited">Methods inherited from <span class='object_link'><a href="IO.html" title="IO (class)">IO</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="IO.html#nread-instance_method" title="IO#nread (method)">#nread</a></span>, <span class='object_link'><a href="IO.html#ready%3F-instance_method" title="IO#ready? (method)">#ready?</a></span>, <span class='object_link'><a href="IO.html#scanf-instance_method" title="IO#scanf (method)">#scanf</a></span>, <span class='object_link'><a href="IO.html#wait-instance_method" title="IO#wait (method)">#wait</a></span></p>
<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(domain, socktype[, protocol]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates a new socket object.
</p>
<p>
<em>domain</em> should be a communications domain such as: :INET, :INET6,
:UNIX, etc.
</p>
<p>
<em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW,
etc.
</p>
<p>
<em>protocol</em> should be a protocol defined in the domain. This is
optional. If it is not given, 0 is used internally.
</p>
<pre class="code">
  Socket.new(:INET, :STREAM) # TCP socket
  Socket.new(:INET, :DGRAM)  # UDP socket
  Socket.new(:UNIX, :STREAM) # UNIX stream socket
  Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.new(domain, socktype [, protocol]) =&gt; socket
 *
 * Creates a new socket object.
 *
 * _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.
 *
 * _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
 *
 * _protocol_ should be a protocol defined in the domain.
 * This is optional.
 * If it is not given, 0 is used internally.
 *
 *   Socket.new(:INET, :STREAM) # TCP socket
 *   Socket.new(:INET, :DGRAM)  # UDP socket
 *   Socket.new(:UNIX, :STREAM) # UNIX stream socket
 *   Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket
 */
static VALUE
sock_initialize(int argc, VALUE *argv, VALUE sock)
{
    VALUE domain, type, protocol;
    int fd;
    int d, t;

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;domain, &amp;type, &amp;protocol);
    if (NIL_P(protocol))
        protocol = INT2FIX(0);

    rb_secure(3);
    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    fd = rsock_socket(d, t, NUM2INT(protocol));
    if (fd &lt; 0) rb_sys_fail(&quot;socket(2)&quot;);

    return rsock_init_sock(sock, fd);
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="getaddrinfo-class_method">
  
    + (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getaddrinfo</strong>(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Obtains address information for <em>nodename</em>:<em>servname</em>.
</p>
<p>
<em>family</em> should be an address family such as: :INET, :INET6, :UNIX,
etc.
</p>
<p>
<em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW,
etc.
</p>
<p>
<em>protocol</em> should be a protocol defined in the family. 0 is default
protocol for the family.
</p>
<p>
<em>flags</em> should be bitwise OR of Socket::AI_* constants.
</p>
<pre class="code">
  Socket.getaddrinfo(&quot;www.ruby-lang.org&quot;, &quot;http&quot;, nil, :STREAM)
  #=&gt; [[&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;, 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP

  Socket.getaddrinfo(&quot;localhost&quot;, nil)
  #=&gt; [[&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
  #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
  #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP
</pre>
<p>
<em>reverse_lookup</em> directs the form of the third element, and has to
be one of below. If it is ommitted, the default value is <tt>nil</tt>.
</p>
<pre class="code">
  +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
  +false+, +:numeric+:  hostname is same as numeric address.
  +nil+:              obey to the current +do_not_reverse_lookup+ flag.
</pre>
<p>
If Addrinfo object is preferred, use Addrinfo.getaddrinfo.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.getaddrinfo(nodename, servname[, family[, socktype[, protocol[, flags[, reverse_lookup]]]]]) =&gt; array
 *
 * Obtains address information for _nodename_:_servname_.
 *
 * _family_ should be an address family such as: :INET, :INET6, :UNIX, etc.
 *
 * _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
 *
 * _protocol_ should be a protocol defined in the family.
 * 0 is default protocol for the family.
 *
 * _flags_ should be bitwise OR of Socket::AI_* constants.
 *
 *   Socket.getaddrinfo(&quot;www.ruby-lang.org&quot;, &quot;http&quot;, nil, :STREAM)
 *   #=&gt; [[&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;, 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP
 *
 *   Socket.getaddrinfo(&quot;localhost&quot;, nil)
 *   #=&gt; [[&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
 *   #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
 *   #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP
 *
 * _reverse_lookup_ directs the form of the third element, and has to
 * be one of below.
 * If it is ommitted, the default value is +nil+.
 *
 *   +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
 *   +false+, +:numeric+:  hostname is same as numeric address.
 *   +nil+:              obey to the current +do_not_reverse_lookup+ flag.
 *
 * If Addrinfo object is preferred, use Addrinfo.getaddrinfo.
 */
static VALUE
sock_s_getaddrinfo(int argc, VALUE *argv)
{
    VALUE host, port, family, socktype, protocol, flags, ret, revlookup;
    struct addrinfo hints, *res;
    int norevlookup;

    rb_scan_args(argc, argv, &quot;25&quot;, &amp;host, &amp;port, &amp;family, &amp;socktype, &amp;protocol, &amp;flags, &amp;revlookup);

    MEMZERO(&amp;hints, struct addrinfo, 1);
    hints.ai_family = NIL_P(family) ? PF_UNSPEC : rsock_family_arg(family);

    if (!NIL_P(socktype)) {
    hints.ai_socktype = rsock_socktype_arg(socktype);
    }
    if (!NIL_P(protocol)) {
    hints.ai_protocol = NUM2INT(protocol);
    }
    if (!NIL_P(flags)) {
    hints.ai_flags = NUM2INT(flags);
    }
    if (NIL_P(revlookup) || !rsock_revlookup_flag(revlookup, &amp;norevlookup)) {
    norevlookup = rsock_do_not_reverse_lookup;
    }
    res = rsock_getaddrinfo(host, port, &amp;hints, 0);

    ret = make_addrinfo(res, norevlookup);
    freeaddrinfo(res);
    return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="gethostbyaddr-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>gethostbyaddr</strong>(address_string[, address_family]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Obtains the host information for <em>address</em>.
</p>
<pre class="code">
  p Socket.gethostbyaddr([221,186,184,68].pack(&quot;CCCC&quot;))
  #=&gt; [&quot;carbon.ruby-lang.org&quot;, [], 2, &quot;\xDD\xBA\xB8D&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.gethostbyaddr(address_string [, address_family]) =&gt; hostent
 *
 * Obtains the host information for _address_.
 *
 *   p Socket.gethostbyaddr([221,186,184,68].pack(&quot;CCCC&quot;))
 *   #=&gt; [&quot;carbon.ruby-lang.org&quot;, [], 2, &quot;\xDD\xBA\xB8D&quot;]
 */
static VALUE
sock_s_gethostbyaddr(int argc, VALUE *argv)
{
    VALUE addr, family;
    struct hostent *h;
    struct sockaddr *sa;
    char **pch;
    VALUE ary, names;
    int t = AF_INET;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;addr, &amp;family);
    sa = (struct sockaddr*)StringValuePtr(addr);
    if (!NIL_P(family)) {
    t = rsock_family_arg(family);
    }
#ifdef AF_INET6
    else if (RSTRING_LEN(addr) == 16) {
    t = AF_INET6;
    }
#endif
    h = gethostbyaddr(RSTRING_PTR(addr), RSTRING_LENINT(addr), t);
    if (h == NULL) {
#ifdef HAVE_HSTRERROR
    extern int h_errno;
    rb_raise(rb_eSocket, &quot;%s&quot;, (char*)hstrerror(h_errno));
#else
    rb_raise(rb_eSocket, &quot;host not found&quot;);
#endif
    }
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h-&gt;h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
    if (h-&gt;h_aliases != NULL) {
    for (pch = h-&gt;h_aliases; *pch; pch++) {
        rb_ary_push(names, rb_str_new2(*pch));
    }
    }
    rb_ary_push(ary, INT2NUM(h-&gt;h_addrtype));
#ifdef h_addr
    for (pch = h-&gt;h_addr_list; *pch; pch++) {
    rb_ary_push(ary, rb_str_new(*pch, h-&gt;h_length));
    }
#else
    rb_ary_push(ary, rb_str_new(h-&gt;h_addr, h-&gt;h_length));
#endif

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="gethostbyname-class_method">
  
    + (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>gethostbyname</strong>(hostname) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Obtains the host information for <em>hostname</em>.
</p>
<pre class="code">
  p Socket.gethostbyname(&quot;hal&quot;) #=&gt; [&quot;localhost&quot;, [&quot;hal&quot;], 2, &quot;\x7F\x00\x00\x01&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.gethostbyname(hostname) =&gt; [official_hostname, alias_hostnames, address_family, *address_list]
 *
 * Obtains the host information for _hostname_.
 *
 *   p Socket.gethostbyname(&quot;hal&quot;) #=&gt; [&quot;localhost&quot;, [&quot;hal&quot;], 2, &quot;\x7F\x00\x00\x01&quot;]
 *
 */
static VALUE
sock_s_gethostbyname(VALUE obj, VALUE host)
{
    rb_secure(3);
    return rsock_make_hostent(host, rsock_addrinfo(host, Qnil, SOCK_STREAM, AI_CANONNAME), sock_sockaddr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="gethostname-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>gethostname</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the hostname.
</p>
<pre class="code">
  p Socket.gethostname #=&gt; &quot;hal&quot;
</pre>
<p>
Note that it is not guaranteed to be able to convert to IP address using
gethostbyname, getaddrinfo, etc. If you need local IP address, use
Socket.ip_address_list.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.gethostname =&gt; hostname
 *
 * Returns the hostname.
 *
 *   p Socket.gethostname #=&gt; &quot;hal&quot;
 *
 * Note that it is not guaranteed to be able to convert to IP address using gethostbyname, getaddrinfo, etc.
 * If you need local IP address, use Socket.ip_address_list.
 */
static VALUE
sock_gethostname(VALUE obj)
{
#ifndef HOST_NAME_MAX
#  define HOST_NAME_MAX 1024
#endif
    char buf[HOST_NAME_MAX+1];

    rb_secure(3);
    if (gethostname(buf, (int)sizeof buf - 1) &lt; 0)
    rb_sys_fail(&quot;gethostname&quot;);

    buf[sizeof buf - 1] = '\0';
    return rb_str_new2(buf);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getnameinfo-class_method">
  
    + (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>getnameinfo</strong>(sockaddr[, flags]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Obtains name information for <em>sockaddr</em>.
</p>
<p>
<em>sockaddr</em> should be one of follows.
</p>
<ul>
<li><p>
packed sockaddr string such as Socket.sockaddr_in(80,
&#8220;127.0.0.1&#8221;)
</p>
</li>
<li><p>
3-elements array such as [&#8220;AF_INET&#8221;, 80,
&#8220;127.0.0.1&#8221;]
</p>
</li>
<li><p>
4-elements array such as [&#8220;AF_INET&#8221;, 80, ignored,
&#8220;127.0.0.1&#8221;]
</p>
</li>
</ul>
<p>
<em>flags</em> should be bitwise OR of Socket::NI_* constants.
</p>
<p>
Note that the last form is compatible with IPSocket#addr,peeraddr.
</p>
<pre class="code">
  Socket.getnameinfo(Socket.sockaddr_in(80, &quot;127.0.0.1&quot;))       #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
  Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;])              #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
  Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;localhost&quot;, &quot;127.0.0.1&quot;]) #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
</pre>
<p>
If Addrinfo object is preferred, use Addrinfo#getnameinfo.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.getnameinfo(sockaddr [, flags]) =&gt; [hostname, servicename]
 *
 * Obtains name information for _sockaddr_.
 *
 * _sockaddr_ should be one of follows.
 * - packed sockaddr string such as Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
 * - 3-elements array such as [&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;]
 * - 4-elements array such as [&quot;AF_INET&quot;, 80, ignored, &quot;127.0.0.1&quot;]
 *
 * _flags_ should be bitwise OR of Socket::NI_* constants.
 *
 * Note that the last form is compatible with IPSocket#{addr,peeraddr}.
 *
 *   Socket.getnameinfo(Socket.sockaddr_in(80, &quot;127.0.0.1&quot;))       #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
 *   Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;])              #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
 *   Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;localhost&quot;, &quot;127.0.0.1&quot;]) #=&gt; [&quot;localhost&quot;, &quot;www&quot;]
 *
 * If Addrinfo object is preferred, use Addrinfo#getnameinfo.
 */
static VALUE
sock_s_getnameinfo(int argc, VALUE *argv)
{
    VALUE sa, af = Qnil, host = Qnil, port = Qnil, flags, tmp;
    char *hptr, *pptr;
    char hbuf[1024], pbuf[1024];
    int fl;
    struct addrinfo hints, *res = NULL, *r;
    int error;
    struct sockaddr_storage ss;
    struct sockaddr *sap;

    sa = flags = Qnil;
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;sa, &amp;flags);

    fl = 0;
    if (!NIL_P(flags)) {
    fl = NUM2INT(flags);
    }
    tmp = rb_check_sockaddr_string_type(sa);
    if (!NIL_P(tmp)) {
    sa = tmp;
    if (sizeof(ss) &lt; (size_t)RSTRING_LEN(sa)) {
        rb_raise(rb_eTypeError, &quot;sockaddr length too big&quot;);
    }
    memcpy(&amp;ss, RSTRING_PTR(sa), RSTRING_LEN(sa));
    if ((size_t)RSTRING_LEN(sa) != SS_LEN(&amp;ss)) {
        rb_raise(rb_eTypeError, &quot;sockaddr size differs - should not happen&quot;);
    }
    sap = (struct sockaddr*)&amp;ss;
    goto call_nameinfo;
    }
    tmp = rb_check_array_type(sa);
    if (!NIL_P(tmp)) {
    sa = tmp;
    MEMZERO(&amp;hints, struct addrinfo, 1);
    if (RARRAY_LEN(sa) == 3) {
        af = RARRAY_PTR(sa)[0];
        port = RARRAY_PTR(sa)[1];
        host = RARRAY_PTR(sa)[2];
    }
    else if (RARRAY_LEN(sa) &gt;= 4) {
        af = RARRAY_PTR(sa)[0];
        port = RARRAY_PTR(sa)[1];
        host = RARRAY_PTR(sa)[3];
        if (NIL_P(host)) {
        host = RARRAY_PTR(sa)[2];
        }
        else {
        /*
         * 4th element holds numeric form, don't resolve.
         * see rsock_ipaddr().
         */
#ifdef AI_NUMERICHOST /* AIX 4.3.3 doesn't have AI_NUMERICHOST. */
        hints.ai_flags |= AI_NUMERICHOST;
#endif
        }
    }
    else {
        rb_raise(rb_eArgError, &quot;array size should be 3 or 4, %ld given&quot;,
             RARRAY_LEN(sa));
    }
    /* host */
    if (NIL_P(host)) {
        hptr = NULL;
    }
    else {
        strncpy(hbuf, StringValuePtr(host), sizeof(hbuf));
        hbuf[sizeof(hbuf) - 1] = '\0';
        hptr = hbuf;
    }
    /* port */
    if (NIL_P(port)) {
        strcpy(pbuf, &quot;0&quot;);
        pptr = NULL;
    }
    else if (FIXNUM_P(port)) {
        snprintf(pbuf, sizeof(pbuf), &quot;%ld&quot;, NUM2LONG(port));
        pptr = pbuf;
    }
    else {
        strncpy(pbuf, StringValuePtr(port), sizeof(pbuf));
        pbuf[sizeof(pbuf) - 1] = '\0';
        pptr = pbuf;
    }
    hints.ai_socktype = (fl &amp; NI_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;
    /* af */
        hints.ai_family = NIL_P(af) ? PF_UNSPEC : rsock_family_arg(af);
    error = rb_getaddrinfo(hptr, pptr, &amp;hints, &amp;res);
    if (error) goto error_exit_addr;
    sap = res-&gt;ai_addr;
    }
    else {
    rb_raise(rb_eTypeError, &quot;expecting String or Array&quot;);
    }

  call_nameinfo:
    error = rb_getnameinfo(sap, SA_LEN(sap), hbuf, sizeof(hbuf),
               pbuf, sizeof(pbuf), fl);
    if (error) goto error_exit_name;
    if (res) {
    for (r = res-&gt;ai_next; r; r = r-&gt;ai_next) {
        char hbuf2[1024], pbuf2[1024];

        sap = r-&gt;ai_addr;
        error = rb_getnameinfo(sap, SA_LEN(sap), hbuf2, sizeof(hbuf2),
                   pbuf2, sizeof(pbuf2), fl);
        if (error) goto error_exit_name;
        if (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
        freeaddrinfo(res);
        rb_raise(rb_eSocket, &quot;sockaddr resolved to multiple nodename&quot;);
        }
    }
    freeaddrinfo(res);
    }
    return rb_assoc_new(rb_str_new2(hbuf), rb_str_new2(pbuf));

  error_exit_addr:
    if (res) freeaddrinfo(res);
    rsock_raise_socket_error(&quot;getaddrinfo&quot;, error);

  error_exit_name:
    if (res) freeaddrinfo(res);
    rsock_raise_socket_error(&quot;getnameinfo&quot;, error);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getservbyname-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>getservbyname</strong>(service_name) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>getservbyname</strong>(service_name, protocol_name) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Obtains the port number for <em>service_name</em>.
</p>
<p>
If <em>protocol_name</em> is not given, &#8220;tcp&#8221; is assumed.
</p>
<pre class="code">
  Socket.getservbyname(&quot;smtp&quot;)          #=&gt; 25
  Socket.getservbyname(&quot;shell&quot;)         #=&gt; 514
  Socket.getservbyname(&quot;syslog&quot;, &quot;udp&quot;) #=&gt; 514</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.getservbyname(service_name)                =&gt; port_number
 *   Socket.getservbyname(service_name, protocol_name) =&gt; port_number
 *
 * Obtains the port number for _service_name_.
 *
 * If _protocol_name_ is not given, &quot;tcp&quot; is assumed.
 *
 *   Socket.getservbyname(&quot;smtp&quot;)          #=&gt; 25
 *   Socket.getservbyname(&quot;shell&quot;)         #=&gt; 514
 *   Socket.getservbyname(&quot;syslog&quot;, &quot;udp&quot;) #=&gt; 514
 */
static VALUE
sock_s_getservbyname(int argc, VALUE *argv)
{
    VALUE service, proto;
    struct servent *sp;
    long port;
    const char *servicename, *protoname = &quot;tcp&quot;;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;service, &amp;proto);
    StringValue(service);
    if (!NIL_P(proto)) StringValue(proto);
    servicename = StringValueCStr(service);
    if (!NIL_P(proto)) protoname = StringValueCStr(proto);
    sp = getservbyname(servicename, protoname);
    if (sp) {
    port = ntohs(sp-&gt;s_port);
    }
    else {
    char *end;

    port = STRTOUL(servicename, &amp;end, 0);
    if (*end != '\0') {
        rb_raise(rb_eSocket, &quot;no such service %s/%s&quot;, servicename, protoname);
    }
    }
    return INT2FIX(port);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getservbyport-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>getservbyport</strong>(port[, protocol_name]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Obtains the port number for <em>port</em>.
</p>
<p>
If <em>protocol_name</em> is not given, &#8220;tcp&#8221; is assumed.
</p>
<pre class="code">
  Socket.getservbyport(80)         #=&gt; &quot;www&quot;
  Socket.getservbyport(514, &quot;tcp&quot;) #=&gt; &quot;shell&quot;
  Socket.getservbyport(514, &quot;udp&quot;) #=&gt; &quot;syslog&quot;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.getservbyport(port [, protocol_name]) =&gt; service
 *
 * Obtains the port number for _port_.
 *
 * If _protocol_name_ is not given, &quot;tcp&quot; is assumed.
 *
 *   Socket.getservbyport(80)         #=&gt; &quot;www&quot;
 *   Socket.getservbyport(514, &quot;tcp&quot;) #=&gt; &quot;shell&quot;
 *   Socket.getservbyport(514, &quot;udp&quot;) #=&gt; &quot;syslog&quot;
 *
 */
static VALUE
sock_s_getservbyport(int argc, VALUE *argv)
{
    VALUE port, proto;
    struct servent *sp;
    long portnum;
    const char *protoname = &quot;tcp&quot;;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;port, &amp;proto);
    portnum = NUM2LONG(port);
    if (portnum != (uint16_t)portnum) {
    const char *s = portnum &gt; 0 ? &quot;big&quot; : &quot;small&quot;;
    rb_raise(rb_eRangeError, &quot;integer %ld too %s to convert into `int16_t'&quot;, portnum, s);
    }
    if (!NIL_P(proto)) protoname = StringValueCStr(proto);

    sp = getservbyport((int)htons((uint16_t)portnum), protoname);
    if (!sp) {
    rb_raise(rb_eSocket, &quot;no such service for port %d/%s&quot;, (int)portnum, protoname);
    }
    return rb_tainted_str_new2(sp-&gt;s_name);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ip_address_list-class_method">
  
    + (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>ip_address_list</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns local IP addresses as an array.
</p>
<p>
The array contains Addrinfo objects.
</p>
<pre class="code">
 pp Socket.ip_address_list
 #=&gt; [#&lt;Addrinfo: 127.0.0.1&gt;,
      #&lt;Addrinfo: 192.168.0.128&gt;,
      #&lt;Addrinfo: ::1&gt;,
      ...]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.ip_address_list =&gt; array
 *
 * Returns local IP addresses as an array.
 *
 * The array contains Addrinfo objects.
 *
 *  pp Socket.ip_address_list
 *  #=&gt; [#&lt;Addrinfo: 127.0.0.1&gt;,
 *       #&lt;Addrinfo: 192.168.0.128&gt;,
 *       #&lt;Addrinfo: ::1&gt;,
 *       ...]
 *
 */
static VALUE
socket_s_ip_address_list(VALUE self)
{
#if defined(HAVE_GETIFADDRS)
    struct ifaddrs *ifp = NULL;
    struct ifaddrs *p;
    int ret;
    VALUE list;

    ret = getifaddrs(&amp;ifp);
    if (ret == -1) {
        rb_sys_fail(&quot;getifaddrs&quot;);
    }

    list = rb_ary_new();
    for (p = ifp; p; p = p-&gt;ifa_next) {
        if (p-&gt;ifa_addr != NULL &amp;&amp; IS_IP_FAMILY(p-&gt;ifa_addr-&gt;sa_family)) {
            rb_ary_push(list, sockaddr_obj(p-&gt;ifa_addr));
        }
    }

    freeifaddrs(ifp);

    return list;
#elif defined(SIOCGLIFCONF) &amp;&amp; defined(SIOCGLIFNUM) &amp;&amp; !defined(__hpux)
    /* Solaris if_tcp(7P) */
    /* HP-UX has SIOCGLIFCONF too.  But it uses different struct */
    int fd = -1;
    int ret;
    struct lifnum ln;
    struct lifconf lc;
    char *reason = NULL;
    int save_errno;
    int i;
    VALUE list = Qnil;

    lc.lifc_buf = NULL;

    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd == -1)
        rb_sys_fail(&quot;socket&quot;);

    memset(&amp;ln, 0, sizeof(ln));
    ln.lifn_family = AF_UNSPEC;

    ret = ioctl(fd, SIOCGLIFNUM, &amp;ln);
    if (ret == -1) {
    reason = &quot;SIOCGLIFNUM&quot;;
    goto finish;
    }

    memset(&amp;lc, 0, sizeof(lc));
    lc.lifc_family = AF_UNSPEC;
    lc.lifc_flags = 0;
    lc.lifc_len = sizeof(struct lifreq) * ln.lifn_count;
    lc.lifc_req = xmalloc(lc.lifc_len);

    ret = ioctl(fd, SIOCGLIFCONF, &amp;lc);
    if (ret == -1) {
    reason = &quot;SIOCGLIFCONF&quot;;
    goto finish;
    }

    list = rb_ary_new();
    for (i = 0; i &lt; ln.lifn_count; i++) {
    struct lifreq *req = &amp;lc.lifc_req[i];
        if (IS_IP_FAMILY(req-&gt;lifr_addr.ss_family)) {
            if (req-&gt;lifr_addr.ss_family == AF_INET6 &amp;&amp;
                IN6_IS_ADDR_LINKLOCAL(&amp;((struct sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_addr) &amp;&amp;
                ((struct sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_scope_id == 0) {
                struct lifreq req2;
                memcpy(req2.lifr_name, req-&gt;lifr_name, LIFNAMSIZ);
                ret = ioctl(fd, SIOCGLIFINDEX, &amp;req2);
                if (ret == -1) {
                    reason = &quot;SIOCGLIFINDEX&quot;;
                    goto finish;
                }
                ((struct sockaddr_in6 *)(&amp;req-&gt;lifr_addr))-&gt;sin6_scope_id = req2.lifr_index;
            }
            rb_ary_push(list, sockaddr_obj((struct sockaddr *)&amp;req-&gt;lifr_addr));
        }
    }

  finish:
    save_errno = errno;
    if (lc.lifc_buf != NULL)
    xfree(lc.lifc_req);
    if (fd != -1)
    close(fd);
    errno = save_errno;

    if (reason)
    rb_sys_fail(reason);
    return list;

#elif defined(SIOCGIFCONF)
    int fd = -1;
    int ret;
#define EXTRA_SPACE (sizeof(struct ifconf) + sizeof(struct sockaddr_storage))
    char initbuf[4096+EXTRA_SPACE];
    char *buf = initbuf;
    int bufsize;
    struct ifconf conf;
    struct ifreq *req;
    VALUE list = Qnil;
    const char *reason = NULL;
    int save_errno;

    fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd == -1)
        rb_sys_fail(&quot;socket&quot;);

    bufsize = sizeof(initbuf);
    buf = initbuf;

  retry:
    conf.ifc_len = bufsize;
    conf.ifc_req = (struct ifreq *)buf;

    /* fprintf(stderr, &quot;bufsize: %d\n&quot;, bufsize); */

    ret = ioctl(fd, SIOCGIFCONF, &amp;conf);
    if (ret == -1) {
        reason = &quot;SIOCGIFCONF&quot;;
        goto finish;
    }

    /* fprintf(stderr, &quot;conf.ifc_len: %d\n&quot;, conf.ifc_len); */

    if (bufsize - EXTRA_SPACE &lt; conf.ifc_len) {
    if (bufsize &lt; conf.ifc_len) {
        /* NetBSD returns required size for all interfaces. */
        bufsize = conf.ifc_len + EXTRA_SPACE;
    }
    else {
        bufsize = bufsize &lt;&lt; 1;
    }
    if (buf == initbuf)
        buf = NULL;
    buf = xrealloc(buf, bufsize);
    goto retry;
    }

    close(fd);
    fd = -1;

    list = rb_ary_new();
    req = conf.ifc_req;
    while ((char*)req &lt; (char*)conf.ifc_req + conf.ifc_len) {
    struct sockaddr *addr = &amp;req-&gt;ifr_addr;
        if (IS_IP_FAMILY(addr-&gt;sa_family)) {
        rb_ary_push(list, sockaddr_obj(addr));
    }
#ifdef HAVE_SA_LEN
# ifndef _SIZEOF_ADDR_IFREQ
#  define _SIZEOF_ADDR_IFREQ(r) \
          (sizeof(struct ifreq) + \
           (sizeof(struct sockaddr) &lt; (r).ifr_addr.sa_len ? \
            (r).ifr_addr.sa_len - sizeof(struct sockaddr) : \
            0))
# endif
    req = (struct ifreq *)((char*)req + _SIZEOF_ADDR_IFREQ(*req));
#else
    req = (struct ifreq *)((char*)req + sizeof(struct ifreq));
#endif
    }

  finish:

    save_errno = errno;
    if (buf != initbuf)
        xfree(buf);
    if (fd != -1)
    close(fd);
    errno = save_errno;

    if (reason)
    rb_sys_fail(reason);
    return list;

#undef EXTRA_SPACE
#elif defined(_WIN32)
    typedef struct ip_adapter_unicast_address_st {
    unsigned LONG_LONG dummy0;
    struct ip_adapter_unicast_address_st *Next;
    struct {
        struct sockaddr *lpSockaddr;
        int iSockaddrLength;
    } Address;
    int dummy1;
    int dummy2;
    int dummy3;
    long dummy4;
    long dummy5;
    long dummy6;
    } ip_adapter_unicast_address_t;
    typedef struct ip_adapter_anycast_address_st {
    unsigned LONG_LONG dummy0;
    struct ip_adapter_anycast_address_st *Next;
    struct {
        struct sockaddr *lpSockaddr;
        int iSockaddrLength;
    } Address;
    } ip_adapter_anycast_address_t;
    typedef struct ip_adapter_addresses_st {
    unsigned LONG_LONG dummy0;
    struct ip_adapter_addresses_st *Next;
    void *dummy1;
    ip_adapter_unicast_address_t *FirstUnicastAddress;
    ip_adapter_anycast_address_t *FirstAnycastAddress;
    void *dummy2;
    void *dummy3;
    void *dummy4;
    void *dummy5;
    void *dummy6;
    BYTE dummy7[8];
    DWORD dummy8;
    DWORD dummy9;
    DWORD dummy10;
    DWORD IfType;
    int OperStatus;
    DWORD dummy12;
    DWORD dummy13[16];
    void *dummy14;
    } ip_adapter_addresses_t;
    typedef ULONG (WINAPI *GetAdaptersAddresses_t)(ULONG, ULONG, PVOID, ip_adapter_addresses_t *, PULONG);
    HMODULE h;
    GetAdaptersAddresses_t pGetAdaptersAddresses;
    ULONG len;
    DWORD ret;
    ip_adapter_addresses_t *adapters;
    VALUE list;

    h = LoadLibrary(&quot;iphlpapi.dll&quot;);
    if (!h)
    rb_notimplement();
    pGetAdaptersAddresses = (GetAdaptersAddresses_t)GetProcAddress(h, &quot;GetAdaptersAddresses&quot;);
    if (!pGetAdaptersAddresses) {
    FreeLibrary(h);
    rb_notimplement();
    }

    ret = pGetAdaptersAddresses(AF_UNSPEC, 0, NULL, NULL, &amp;len);
    if (ret != ERROR_SUCCESS &amp;&amp; ret != ERROR_BUFFER_OVERFLOW) {
    errno = rb_w32_map_errno(ret);
    FreeLibrary(h);
    rb_sys_fail(&quot;GetAdaptersAddresses&quot;);
    }
    adapters = (ip_adapter_addresses_t *)ALLOCA_N(BYTE, len);
    ret = pGetAdaptersAddresses(AF_UNSPEC, 0, NULL, adapters, &amp;len);
    if (ret != ERROR_SUCCESS) {
    errno = rb_w32_map_errno(ret);
    FreeLibrary(h);
    rb_sys_fail(&quot;GetAdaptersAddresses&quot;);
    }

    list = rb_ary_new();
    for (; adapters; adapters = adapters-&gt;Next) {
    ip_adapter_unicast_address_t *uni;
    ip_adapter_anycast_address_t *any;
    if (adapters-&gt;OperStatus != 1) /* 1 means IfOperStatusUp */
        continue;
    for (uni = adapters-&gt;FirstUnicastAddress; uni; uni = uni-&gt;Next) {
#ifndef INET6
        if (uni-&gt;Address.lpSockaddr-&gt;sa_family == AF_INET)
#else
        if (IS_IP_FAMILY(uni-&gt;Address.lpSockaddr-&gt;sa_family))
#endif
        rb_ary_push(list, sockaddr_obj(uni-&gt;Address.lpSockaddr));
    }
    for (any = adapters-&gt;FirstAnycastAddress; any; any = any-&gt;Next) {
#ifndef INET6
        if (any-&gt;Address.lpSockaddr-&gt;sa_family == AF_INET)
#else
        if (IS_IP_FAMILY(any-&gt;Address.lpSockaddr-&gt;sa_family))
#endif
        rb_ary_push(list, sockaddr_obj(any-&gt;Address.lpSockaddr));
    }
    }

    FreeLibrary(h);
    return list;
#endif
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pack_sockaddr_in-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sockaddr_in</strong>(port, host) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>pack_sockaddr_in</strong>(port, host) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Packs <em>port</em> and <em>host</em> as an AF_INET/AF_INET6 sockaddr
string.
</p>
<pre class="code">
  Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
  #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;

  Socket.sockaddr_in(80, &quot;::1&quot;)
  #=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.sockaddr_in(port, host)      =&gt; sockaddr
 *   Socket.pack_sockaddr_in(port, host) =&gt; sockaddr
 *
 * Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string.
 *
 *   Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
 *   #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
 *
 *   Socket.sockaddr_in(80, &quot;::1&quot;)
 *   #=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;
 *
 */
static VALUE
sock_s_pack_sockaddr_in(VALUE self, VALUE port, VALUE host)
{
    struct addrinfo *res = rsock_addrinfo(host, port, 0, 0);
    VALUE addr = rb_str_new((char*)res-&gt;ai_addr, res-&gt;ai_addrlen);

    freeaddrinfo(res);
    OBJ_INFECT(addr, port);
    OBJ_INFECT(addr, host);

    return addr;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pack_sockaddr_un-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sockaddr_un</strong>(path) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>pack_sockaddr_un</strong>(path) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Packs <em>path</em> as an AF_UNIX sockaddr string.
</p>
<pre class="code">
  Socket.sockaddr_un(&quot;/tmp/sock&quot;) #=&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.sockaddr_un(path)      =&gt; sockaddr
 *   Socket.pack_sockaddr_un(path) =&gt; sockaddr
 *
 * Packs _path_ as an AF_UNIX sockaddr string.
 *
 *   Socket.sockaddr_un(&quot;/tmp/sock&quot;) #=&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;
 *
 */
static VALUE
sock_s_pack_sockaddr_un(VALUE self, VALUE path)
{
    struct sockaddr_un sockaddr;
    char *sun_path;
    VALUE addr;

    MEMZERO(&amp;sockaddr, struct sockaddr_un, 1);
    sockaddr.sun_family = AF_UNIX;
    sun_path = StringValueCStr(path);
    if (sizeof(sockaddr.sun_path) &lt;= strlen(sun_path)) {
        rb_raise(rb_eArgError, &quot;too long unix socket path (max: %dbytes)&quot;,
            (int)sizeof(sockaddr.sun_path)-1);
    }
    strncpy(sockaddr.sun_path, sun_path, sizeof(sockaddr.sun_path)-1);
    addr = rb_str_new((char*)&amp;sockaddr, sizeof(sockaddr));
    OBJ_INFECT(addr, path);

    return addr;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pair-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pair</strong>(domain, type, protocol) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>socketpair</strong>(domain, type, protocol) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates a pair of sockets connected each other.
</p>
<p>
<em>domain</em> should be a communications domain such as: :INET, :INET6,
:UNIX, etc.
</p>
<p>
<em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW,
etc.
</p>
<p>
<em>protocol</em> should be a protocol defined in the domain. 0 is default
protocol for the domain.
</p>
<pre class="code">
  s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  s1.send &quot;a&quot;, 0
  s1.send &quot;b&quot;, 0
  p s2.recv(10) #=&gt; &quot;a&quot;
  p s2.recv(10) #=&gt; &quot;b&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pair</strong>(domain, type, protocol) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>socketpair</strong>(domain, type, protocol) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.pair(domain, type, protocol)       =&gt; [socket1, socket2]
 *   Socket.socketpair(domain, type, protocol) =&gt; [socket1, socket2]
 *
 * Creates a pair of sockets connected each other.
 *
 * _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.
 *
 * _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
 *
 * _protocol_ should be a protocol defined in the domain.
 * 0 is default protocol for the domain.
 *
 *   s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
 *   s1.send &quot;a&quot;, 0
 *   s1.send &quot;b&quot;, 0
 *   p s2.recv(10) #=&gt; &quot;a&quot;
 *   p s2.recv(10) #=&gt; &quot;b&quot;
 *
 */
VALUE
rsock_sock_s_socketpair(int argc, VALUE *argv, VALUE klass)
{
    VALUE domain, type, protocol;
    int d, t, p, sp[2];
    int ret;
    VALUE s1, s2, r;

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;domain, &amp;type, &amp;protocol);
    if (NIL_P(protocol))
        protocol = INT2FIX(0);

    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    p = NUM2INT(protocol);
    ret = socketpair(d, t, p, sp);
    if (ret &lt; 0 &amp;&amp; (errno == EMFILE || errno == ENFILE)) {
        rb_gc();
        ret = socketpair(d, t, p, sp);
    }
    if (ret &lt; 0) {
    rb_sys_fail(&quot;socketpair(2)&quot;);
    }

    s1 = rsock_init_sock(rb_obj_alloc(klass), sp[0]);
    s2 = rsock_init_sock(rb_obj_alloc(klass), sp[1]);
    r = rb_assoc_new(s1, s2);
    if (rb_block_given_p()) {
        return rb_ensure(pair_yield, r, io_close, s1);
    }
    return r;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sockaddr_in-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sockaddr_in</strong>(port, host) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>pack_sockaddr_in</strong>(port, host) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Packs <em>port</em> and <em>host</em> as an AF_INET/AF_INET6 sockaddr
string.
</p>
<pre class="code">
  Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
  #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;

  Socket.sockaddr_in(80, &quot;::1&quot;)
  #=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.sockaddr_in(port, host)      =&gt; sockaddr
 *   Socket.pack_sockaddr_in(port, host) =&gt; sockaddr
 *
 * Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string.
 *
 *   Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
 *   #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
 *
 *   Socket.sockaddr_in(80, &quot;::1&quot;)
 *   #=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;
 *
 */
static VALUE
sock_s_pack_sockaddr_in(VALUE self, VALUE port, VALUE host)
{
    struct addrinfo *res = rsock_addrinfo(host, port, 0, 0);
    VALUE addr = rb_str_new((char*)res-&gt;ai_addr, res-&gt;ai_addrlen);

    freeaddrinfo(res);
    OBJ_INFECT(addr, port);
    OBJ_INFECT(addr, host);

    return addr;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sockaddr_un-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sockaddr_un</strong>(path) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>pack_sockaddr_un</strong>(path) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Packs <em>path</em> as an AF_UNIX sockaddr string.
</p>
<pre class="code">
  Socket.sockaddr_un(&quot;/tmp/sock&quot;) #=&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.sockaddr_un(path)      =&gt; sockaddr
 *   Socket.pack_sockaddr_un(path) =&gt; sockaddr
 *
 * Packs _path_ as an AF_UNIX sockaddr string.
 *
 *   Socket.sockaddr_un(&quot;/tmp/sock&quot;) #=&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;
 *
 */
static VALUE
sock_s_pack_sockaddr_un(VALUE self, VALUE path)
{
    struct sockaddr_un sockaddr;
    char *sun_path;
    VALUE addr;

    MEMZERO(&amp;sockaddr, struct sockaddr_un, 1);
    sockaddr.sun_family = AF_UNIX;
    sun_path = StringValueCStr(path);
    if (sizeof(sockaddr.sun_path) &lt;= strlen(sun_path)) {
        rb_raise(rb_eArgError, &quot;too long unix socket path (max: %dbytes)&quot;,
            (int)sizeof(sockaddr.sun_path)-1);
    }
    strncpy(sockaddr.sun_path, sun_path, sizeof(sockaddr.sun_path)-1);
    addr = rb_str_new((char*)&amp;sockaddr, sizeof(sockaddr));
    OBJ_INFECT(addr, path);

    return addr;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="socketpair-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pair</strong>(domain, type, protocol) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>socketpair</strong>(domain, type, protocol) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates a pair of sockets connected each other.
</p>
<p>
<em>domain</em> should be a communications domain such as: :INET, :INET6,
:UNIX, etc.
</p>
<p>
<em>socktype</em> should be a socket type such as: :STREAM, :DGRAM, :RAW,
etc.
</p>
<p>
<em>protocol</em> should be a protocol defined in the domain. 0 is default
protocol for the domain.
</p>
<pre class="code">
  s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
  s1.send &quot;a&quot;, 0
  s1.send &quot;b&quot;, 0
  p s2.recv(10) #=&gt; &quot;a&quot;
  p s2.recv(10) #=&gt; &quot;b&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pair</strong>(domain, type, protocol) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>socketpair</strong>(domain, type, protocol) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.pair(domain, type, protocol)       =&gt; [socket1, socket2]
 *   Socket.socketpair(domain, type, protocol) =&gt; [socket1, socket2]
 *
 * Creates a pair of sockets connected each other.
 *
 * _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.
 *
 * _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.
 *
 * _protocol_ should be a protocol defined in the domain.
 * 0 is default protocol for the domain.
 *
 *   s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
 *   s1.send &quot;a&quot;, 0
 *   s1.send &quot;b&quot;, 0
 *   p s2.recv(10) #=&gt; &quot;a&quot;
 *   p s2.recv(10) #=&gt; &quot;b&quot;
 *
 */
VALUE
rsock_sock_s_socketpair(int argc, VALUE *argv, VALUE klass)
{
    VALUE domain, type, protocol;
    int d, t, p, sp[2];
    int ret;
    VALUE s1, s2, r;

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;domain, &amp;type, &amp;protocol);
    if (NIL_P(protocol))
        protocol = INT2FIX(0);

    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    p = NUM2INT(protocol);
    ret = socketpair(d, t, p, sp);
    if (ret &lt; 0 &amp;&amp; (errno == EMFILE || errno == ENFILE)) {
        rb_gc();
        ret = socketpair(d, t, p, sp);
    }
    if (ret &lt; 0) {
    rb_sys_fail(&quot;socketpair(2)&quot;);
    }

    s1 = rsock_init_sock(rb_obj_alloc(klass), sp[0]);
    s2 = rsock_init_sock(rb_obj_alloc(klass), sp[1]);
    r = rb_assoc_new(s1, s2);
    if (rb_block_given_p()) {
        return rb_ensure(pair_yield, r, io_close, s1);
    }
    return r;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="unpack_sockaddr_in-class_method">
  
    + (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>unpack_sockaddr_in</strong>(sockaddr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Unpacks <em>sockaddr</em> into port and ip_address.
</p>
<p>
<em>sockaddr</em> should be a string or an addrinfo for AF_INET/AF_INET6.
</p>
<pre class="code">
  sockaddr = Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
  p sockaddr #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
  p Socket.unpack_sockaddr_in(sockaddr) #=&gt; [80, &quot;127.0.0.1&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.unpack_sockaddr_in(sockaddr) =&gt; [port, ip_address]
 *
 * Unpacks _sockaddr_ into port and ip_address.
 *
 * _sockaddr_ should be a string or an addrinfo for AF_INET/AF_INET6.
 *
 *   sockaddr = Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)
 *   p sockaddr #=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;
 *   p Socket.unpack_sockaddr_in(sockaddr) #=&gt; [80, &quot;127.0.0.1&quot;]
 *
 */
static VALUE
sock_s_unpack_sockaddr_in(VALUE self, VALUE addr)
{
    struct sockaddr_in * sockaddr;
    VALUE host;

    sockaddr = (struct sockaddr_in*)SockAddrStringValuePtr(addr);
    if (RSTRING_LEN(addr) &lt;
        (char*)&amp;((struct sockaddr *)sockaddr)-&gt;sa_family +
        sizeof(((struct sockaddr *)sockaddr)-&gt;sa_family) -
        (char*)sockaddr)
        rb_raise(rb_eArgError, &quot;too short sockaddr&quot;);
    if (((struct sockaddr *)sockaddr)-&gt;sa_family != AF_INET
#ifdef INET6
        &amp;&amp; ((struct sockaddr *)sockaddr)-&gt;sa_family != AF_INET6
#endif
        ) {
#ifdef INET6
        rb_raise(rb_eArgError, &quot;not an AF_INET/AF_INET6 sockaddr&quot;);
#else
        rb_raise(rb_eArgError, &quot;not an AF_INET sockaddr&quot;);
#endif
    }
    host = rsock_make_ipaddr((struct sockaddr*)sockaddr);
    OBJ_INFECT(host, addr);
    return rb_assoc_new(INT2NUM(ntohs(sockaddr-&gt;sin_port)), host);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="unpack_sockaddr_un-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>unpack_sockaddr_un</strong>(sockaddr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Unpacks <em>sockaddr</em> into path.
</p>
<p>
<em>sockaddr</em> should be a string or an addrinfo for AF_UNIX.
</p>
<pre class="code">
  sockaddr = Socket.sockaddr_un(&quot;/tmp/sock&quot;)
  p Socket.unpack_sockaddr_un(sockaddr) #=&gt; &quot;/tmp/sock&quot;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   Socket.unpack_sockaddr_un(sockaddr) =&gt; path
 *
 * Unpacks _sockaddr_ into path.
 *
 * _sockaddr_ should be a string or an addrinfo for AF_UNIX.
 *
 *   sockaddr = Socket.sockaddr_un(&quot;/tmp/sock&quot;)
 *   p Socket.unpack_sockaddr_un(sockaddr) #=&gt; &quot;/tmp/sock&quot;
 *
 */
static VALUE
sock_s_unpack_sockaddr_un(VALUE self, VALUE addr)
{
    struct sockaddr_un * sockaddr;
    const char *sun_path;
    VALUE path;

    sockaddr = (struct sockaddr_un*)SockAddrStringValuePtr(addr);
    if (RSTRING_LEN(addr) &lt;
        (char*)&amp;((struct sockaddr *)sockaddr)-&gt;sa_family +
        sizeof(((struct sockaddr *)sockaddr)-&gt;sa_family) -
        (char*)sockaddr)
        rb_raise(rb_eArgError, &quot;too short sockaddr&quot;);
    if (((struct sockaddr *)sockaddr)-&gt;sa_family != AF_UNIX) {
        rb_raise(rb_eArgError, &quot;not an AF_UNIX sockaddr&quot;);
    }
    if (sizeof(struct sockaddr_un) &lt; (size_t)RSTRING_LEN(addr)) {
    rb_raise(rb_eTypeError, &quot;too long sockaddr_un - %ld longer than %d&quot;,
         RSTRING_LEN(addr), (int)sizeof(struct sockaddr_un));
    }
    sun_path = rsock_unixpath(sockaddr, RSTRING_LENINT(addr));
    if (sizeof(struct sockaddr_un) == RSTRING_LEN(addr) &amp;&amp;
        sun_path == sockaddr-&gt;sun_path &amp;&amp;
        sun_path + strlen(sun_path) == RSTRING_PTR(addr) + RSTRING_LEN(addr)) {
        rb_raise(rb_eArgError, &quot;sockaddr_un.sun_path not NUL terminated&quot;);
    }
    path = rb_str_new2(sun_path);
    OBJ_INFECT(path, addr);
    return path;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="accept-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>accept</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Accepts a next connection. Returns a new Socket object and Addrinfo object.
</p>
<pre class="code">
  serv = Socket.new(:INET, :STREAM, 0)
  serv.listen(5)
  c = Socket.new(:INET, :STREAM, 0)
  c.connect(serv.connect_address)
  p serv.accept #=&gt; [#&lt;Socket:fd 6&gt;, #&lt;Addrinfo: 127.0.0.1:48555 TCP&gt;]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *   socket.accept =&gt; [client_socket, client_addrinfo]
 *
 * Accepts a next connection.
 * Returns a new Socket object and Addrinfo object.
 *
 *   serv = Socket.new(:INET, :STREAM, 0)
 *   serv.listen(5)
 *   c = Socket.new(:INET, :STREAM, 0)
 *   c.connect(serv.connect_address)
 *   p serv.accept #=&gt; [#&lt;Socket:fd 6&gt;, #&lt;Addrinfo: 127.0.0.1:48555 TCP&gt;]
 *
 */
static VALUE
sock_accept(VALUE sock)
{
    rb_io_t *fptr;
    VALUE sock2;
    struct sockaddr_storage buf;
    socklen_t len = (socklen_t)sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = rsock_s_accept(rb_cSocket,fptr-&gt;fd,(struct sockaddr*)&amp;buf,&amp;len);

    return rb_assoc_new(sock2, rsock_io_socket_addrinfo(sock2, (struct sockaddr*)&amp;buf, len));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="accept_nonblock-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>accept_nonblock</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Accepts an incoming connection using accept(2) after O_NONBLOCK is set for
the underlying file descriptor. It returns an array containing the accepted
socket for the incoming connection, <em>client_socket</em>, and an
Addrinfo, <em>client_addrinfo</em>.
</p>
<h3>Example</h3>
<pre class="code">
 # In one script, start this first
 require 'socket'
 include Socket::Constants
 socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 sockaddr = Socket.sockaddr_in(2200, 'localhost')
 socket.bind(sockaddr)
 socket.listen(5)
 begin # emulate blocking accept
   client_socket, client_addrinfo = socket.accept_nonblock
 rescue IO::WaitReadable, Errno::EINTR
   IO.select([socket])
   retry
 end
 puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 client_socket.puts &quot;Hello from script one!&quot;
 socket.close

 # In another script, start this second
 require 'socket'
 include Socket::Constants
 socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 sockaddr = Socket.sockaddr_in(2200, 'localhost')
 socket.connect(sockaddr)
 socket.puts &quot;Hello from script 2.&quot;
 puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 socket.close
</pre>
<p>
Refer to Socket#accept for the exceptions that may be thrown if the call to
<em>accept_nonblock</em> fails.
</p>
<p>
Socket#accept_nonblock may raise any error corresponding to accept(2)
failure, including Errno::EWOULDBLOCK.
</p>
<p>
If the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED
or Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable
can be used to rescue the exceptions for retrying accept_nonblock.
</p>
<h3>See</h3>
<ul>
<li><p>
Socket#accept
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.accept_nonblock =&gt; [client_socket, client_addrinfo]
 *
 * Accepts an incoming connection using accept(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * It returns an array containing the accepted socket
 * for the incoming connection, _client_socket_,
 * and an Addrinfo, _client_addrinfo_.
 *
 * === Example
 *  # In one script, start this first
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *  sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *  socket.bind(sockaddr)
 *  socket.listen(5)
 *  begin # emulate blocking accept
 *    client_socket, client_addrinfo = socket.accept_nonblock
 *  rescue IO::WaitReadable, Errno::EINTR
 *    IO.select([socket])
 *    retry
 *  end
 *  puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 *  client_socket.puts &quot;Hello from script one!&quot;
 *  socket.close
 *
 *  # In another script, start this second
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *  sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *  socket.connect(sockaddr)
 *  socket.puts &quot;Hello from script 2.&quot;
 *  puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 *  socket.close
 *
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to _accept_nonblock_ fails.
 *
 * Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
 * including Errno::EWOULDBLOCK.
 *
 * If the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED or Errno::EPROTO,
 * it is extended by IO::WaitReadable.
 * So IO::WaitReadable can be used to rescue the exceptions for retrying accept_nonblock.
 *
 * === See
 * * Socket#accept
 */
static VALUE
sock_accept_nonblock(VALUE sock)
{
    rb_io_t *fptr;
    VALUE sock2;
    struct sockaddr_storage buf;
    socklen_t len = (socklen_t)sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = rsock_s_accept_nonblock(rb_cSocket, fptr, (struct sockaddr *)&amp;buf, &amp;len);
    return rb_assoc_new(sock2, rsock_io_socket_addrinfo(sock2, (struct sockaddr*)&amp;buf, len));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="bind-instance_method">
  
    - (<tt>0</tt>) <strong>bind</strong>(local_sockaddr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Binds to the given local address.
</p>
<h3>Parameter</h3>
<ul>
<li><p>
<tt>local_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string or an Addrinfo object
</p>
</li>
</ul>
<h3>Example</h3>
<pre class="code">
 require 'socket'

 # use Addrinfo
 socket = Socket.new(:INET, :STREAM, 0)
 socket.bind(Addrinfo.tcp(&quot;127.0.0.1&quot;, 2222))
 p socket.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:2222 TCP&gt;

 # use struct sockaddr
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 socket.bind( sockaddr )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>bind</em> fails:
</p>
<ul>
<li><p>
Errno::EACCES - the specified <em>sockaddr</em> is protected and the
current user does not have permission to bind to it
</p>
</li>
<li><p>
Errno::EADDRINUSE - the specified <em>sockaddr</em> is already in use
</p>
</li>
<li><p>
Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine
</p>
</li>
<li><p>
Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid
address for the family of the calling <tt>socket</tt>
</p>
</li>
<li><p>
Errno::EBADF - the <em>sockaddr</em> specified is not a valid file
descriptor
</p>
</li>
<li><p>
Errno::EFAULT - the <em>sockaddr</em> argument cannot be accessed
</p>
</li>
<li><p>
Errno::EINVAL - the <tt>socket</tt> is already bound to an address, and the
protocol does not support binding to the new <em>sockaddr</em> or the
<tt>socket</tt> has been shut down.
</p>
</li>
<li><p>
Errno::EINVAL - the address length is not a valid length for the address
family
</p>
</li>
<li><p>
Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX
</p>
</li>
<li><p>
Errno::ENOBUFS - no buffer space is available
</p>
</li>
<li><p>
Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation
</p>
</li>
<li><p>
Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket
</p>
</li>
<li><p>
Errno::EOPNOTSUPP - the socket type of the <tt>socket</tt> does not support
binding to an address
</p>
</li>
</ul>
<p>
On unix-based based systems if the address family of the calling
<tt>socket</tt> is Socket::AF_UNIX the follow exceptions may be raised if
the call to <em>bind</em> fails:
</p>
<ul>
<li><p>
Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denied
</p>
</li>
<li><p>
Errno::EDESTADDRREQ - the <em>sockaddr</em> argument is a null pointer
</p>
</li>
<li><p>
Errno::EISDIR - same as Errno::EDESTADDRREQ
</p>
</li>
<li><p>
Errno::EIO - an i/o error occurred
</p>
</li>
<li><p>
Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>
</p>
</li>
<li><p>
Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entire pathname exceeded PATH_MAX characters
</p>
</li>
<li><p>
Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string
</p>
</li>
<li><p>
Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory
</p>
</li>
<li><p>
Errno::EROFS - the name would reside on a read only filesystem
</p>
</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>bind</em> fails:
</p>
<ul>
<li><p>
Errno::ENETDOWN&#8212; the network is down
</p>
</li>
<li><p>
Errno::EACCES - the attempt to connect the datagram socket to the broadcast
address failed
</p>
</li>
<li><p>
Errno::EADDRINUSE - the socket&#8217;s local address is already in use
</p>
</li>
<li><p>
Errno::EADDRNOTAVAIL - the specified address is not a valid address for
this computer
</p>
</li>
<li><p>
Errno::EFAULT - the socket&#8217;s internal address or address length
parameter is too small or is not a valid part of the user space addressed
</p>
</li>
<li><p>
Errno::EINVAL - the <tt>socket</tt> is already bound to an address
</p>
</li>
<li><p>
Errno::ENOBUFS - no buffer space is available
</p>
</li>
<li><p>
Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket
</p>
</li>
</ul>
<h3>See</h3>
<ul>
<li><p>
bind manual pages on unix-based systems
</p>
</li>
<li><p>
bind function in Microsoft&#8217;s Winsock functions reference
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.bind(local_sockaddr) =&gt; 0
 *
 * Binds to the given local address.
 *
 * === Parameter
 * * +local_sockaddr+ - the +struct+ sockaddr contained in a string or an Addrinfo object
 *
 * === Example
 *  require 'socket'
 *
 *  # use Addrinfo
 *  socket = Socket.new(:INET, :STREAM, 0)
 *  socket.bind(Addrinfo.tcp(&quot;127.0.0.1&quot;, 2222))
 *  p socket.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:2222 TCP&gt;
 *
 *  # use struct sockaddr
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *  socket.bind( sockaddr )
 *
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if
 * the call to _bind_ fails:
 * * Errno::EACCES - the specified _sockaddr_ is protected and the current
 *   user does not have permission to bind to it
 * * Errno::EADDRINUSE - the specified _sockaddr_ is already in use
 * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the
 *   local machine
 * * Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for
 *   the family of the calling +socket+
 * * Errno::EBADF - the _sockaddr_ specified is not a valid file descriptor
 * * Errno::EFAULT - the _sockaddr_ argument cannot be accessed
 * * Errno::EINVAL - the +socket+ is already bound to an address, and the
 *   protocol does not support binding to the new _sockaddr_ or the +socket+
 *   has been shut down.
 * * Errno::EINVAL - the address length is not a valid length for the address
 *   family
 * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
 *   PATH_MAX
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOSR - there were insufficient STREAMS resources available to
 *   complete the operation
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the socket type of the +socket+ does not support
 *   binding to an address
 *
 * On unix-based based systems if the address family of the calling +socket+ is
 * Socket::AF_UNIX the follow exceptions may be raised if the call to _bind_
 * fails:
 * * Errno::EACCES - search permission is denied for a component of the prefix
 *   path or write access to the +socket+ is denied
 * * Errno::EDESTADDRREQ - the _sockaddr_ argument is a null pointer
 * * Errno::EISDIR - same as Errno::EDESTADDRREQ
 * * Errno::EIO - an i/o error occurred
 * * Errno::ELOOP - too many symbolic links were encountered in translating
 *   the pathname in _sockaddr_
 * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
 *   characters, or an entire pathname exceeded PATH_MAX characters
 * * Errno::ENOENT - a component of the pathname does not name an existing file
 *   or the pathname is an empty string
 * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_
 *   is not a directory
 * * Errno::EROFS - the name would reside on a read only filesystem
 *
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if
 * the call to _bind_ fails:
 * * Errno::ENETDOWN-- the network is down
 * * Errno::EACCES - the attempt to connect the datagram socket to the
 *   broadcast address failed
 * * Errno::EADDRINUSE - the socket's local address is already in use
 * * Errno::EADDRNOTAVAIL - the specified address is not a valid address for this
 *   computer
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space addressed
 * * Errno::EINVAL - the +socket+ is already bound to an address
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 *
 * === See
 * * bind manual pages on unix-based systems
 * * bind function in Microsoft's Winsock functions reference
 */
static VALUE
sock_bind(VALUE sock, VALUE addr)
{
    rb_io_t *fptr;

    SockAddrStringValue(addr);
    GetOpenFile(sock, fptr);
    if (bind(fptr-&gt;fd, (struct sockaddr*)RSTRING_PTR(addr), RSTRING_LENINT(addr)) &lt; 0)
    rb_sys_fail(&quot;bind(2)&quot;);

    return INT2FIX(0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="connect-instance_method">
  
    - (<tt>0</tt>) <strong>connect</strong>(remote_sockaddr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Requests a connection to be made on the given <tt>remote_sockaddr</tt>.
Returns 0 if successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><p>
<tt>remote_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string or Addrinfo object
</p>
</li>
</ul>
<h3>Example:</h3>
<pre class="code">
 # Pull down Google's web page
 require 'socket'
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
 socket.connect( sockaddr )
 socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
 results = socket.read
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based systems the following system exceptions may be raised if the
call to <em>connect</em> fails:
</p>
<ul>
<li><p>
Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denied
</p>
</li>
<li><p>
Errno::EADDRINUSE - the <em>sockaddr</em> is already in use
</p>
</li>
<li><p>
Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine
</p>
</li>
<li><p>
Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid
address for the address family of the specified <tt>socket</tt>
</p>
</li>
<li><p>
Errno::EALREADY - a connection is already in progress for the specified
socket
</p>
</li>
<li><p>
Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor
</p>
</li>
<li><p>
Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request
</p>
</li>
<li><p>
Errno::ECONNRESET - the remote host reset the connection request
</p>
</li>
<li><p>
Errno::EFAULT - the <em>sockaddr</em> cannot be accessed
</p>
</li>
<li><p>
Errno::EHOSTUNREACH - the destination host cannot be reached (probably
because the host is down or a remote router cannot reach it)
</p>
</li>
<li><p>
Errno::EINPROGRESS - the O_NONBLOCK is set for the <tt>socket</tt> and the
connection cannot be immediately established; the connection will be
established asynchronously
</p>
</li>
<li><p>
Errno::EINTR - the attempt to establish the connection was interrupted by
delivery of a signal that was caught; the connection will be established
asynchronously
</p>
</li>
<li><p>
Errno::EISCONN - the specified <tt>socket</tt> is already connected
</p>
</li>
<li><p>
Errno::EINVAL - the address length used for the <em>sockaddr</em> is not a
valid length for the address family or there is an invalid family in
<em>sockaddr</em>
</p>
</li>
<li><p>
Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX
</p>
</li>
<li><p>
Errno::ENETDOWN - the local interface used to reach the destination is down
</p>
</li>
<li><p>
Errno::ENETUNREACH - no route to the network is present
</p>
</li>
<li><p>
Errno::ENOBUFS - no buffer space is available
</p>
</li>
<li><p>
Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation
</p>
</li>
<li><p>
Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket
</p>
</li>
<li><p>
Errno::EOPNOTSUPP - the calling <tt>socket</tt> is listening and cannot be
connected
</p>
</li>
<li><p>
Errno::EPROTOTYPE - the <em>sockaddr</em> has a different type than the
socket bound to the specified peer address
</p>
</li>
<li><p>
Errno::ETIMEDOUT - the attempt to connect time out before a connection was
made.
</p>
</li>
</ul>
<p>
On unix-based systems if the address family of the calling <tt>socket</tt>
is AF_UNIX the follow exceptions may be raised if the call to
<em>connect</em> fails:
</p>
<ul>
<li><p>
Errno::EIO - an i/o error occurred while reading from or writing to the
file system
</p>
</li>
<li><p>
Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>
</p>
</li>
<li><p>
Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entire pathname exceeded PATH_MAX characters
</p>
</li>
<li><p>
Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string
</p>
</li>
<li><p>
Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory
</p>
</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>connect</em> fails:
</p>
<ul>
<li><p>
Errno::ENETDOWN - the network is down
</p>
</li>
<li><p>
Errno::EADDRINUSE - the socket&#8217;s local address is already in use
</p>
</li>
<li><p>
Errno::EINTR - the socket was cancelled
</p>
</li>
<li><p>
Errno::EINPROGRESS - a blocking socket is in progress or the service
provider is still processing a callback function. Or a nonblocking connect
call is in progress on the <tt>socket</tt>.
</p>
</li>
<li><p>
Errno::EALREADY - see Errno::EINVAL
</p>
</li>
<li><p>
Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
ADDR_ANY TODO check ADDRANY TO INADDR_ANY
</p>
</li>
<li><p>
Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
with this <tt>socket</tt>
</p>
</li>
<li><p>
Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request
</p>
</li>
<li><p>
Errno::EFAULT - the socket&#8217;s internal address or address length
parameter is too small or is not a valid part of the user space address
</p>
</li>
<li><p>
Errno::EINVAL - the <tt>socket</tt> is a listening socket
</p>
</li>
<li><p>
Errno::EISCONN - the <tt>socket</tt> is already connected
</p>
</li>
<li><p>
Errno::ENETUNREACH - the network cannot be reached from this host at this
time
</p>
</li>
<li><p>
Errno::EHOSTUNREACH - no route to the network is present
</p>
</li>
<li><p>
Errno::ENOBUFS - no buffer space is available
</p>
</li>
<li><p>
Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket
</p>
</li>
<li><p>
Errno::ETIMEDOUT - the attempt to connect time out before a connection was
made.
</p>
</li>
<li><p>
Errno::EWOULDBLOCK - the socket is marked as nonblocking and the connection
cannot be completed immediately
</p>
</li>
<li><p>
Errno::EACCES - the attempt to connect the datagram socket to the broadcast
address failed
</p>
</li>
</ul>
<h3>See</h3>
<ul>
<li><p>
connect manual pages on unix-based systems
</p>
</li>
<li><p>
connect function in Microsoft&#8217;s Winsock functions reference
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.connect(remote_sockaddr) =&gt; 0
 *
 * Requests a connection to be made on the given +remote_sockaddr+. Returns 0 if
 * successful, otherwise an exception is raised.
 *
 * === Parameter
 * * +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object
 *
 * === Example:
 *  # Pull down Google's web page
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
 *  socket.connect( sockaddr )
 *  socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
 *  results = socket.read
 *
 * === Unix-based Exceptions
 * On unix-based systems the following system exceptions may be raised if
 * the call to _connect_ fails:
 * * Errno::EACCES - search permission is denied for a component of the prefix
 *   path or write access to the +socket+ is denied
 * * Errno::EADDRINUSE - the _sockaddr_ is already in use
 * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the
 *   local machine
 * * Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for
 *   the address family of the specified +socket+
 * * Errno::EALREADY - a connection is already in progress for the specified
 *   socket
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections
 *   refused the connection request
 * * Errno::ECONNRESET - the remote host reset the connection request
 * * Errno::EFAULT - the _sockaddr_ cannot be accessed
 * * Errno::EHOSTUNREACH - the destination host cannot be reached (probably
 *   because the host is down or a remote router cannot reach it)
 * * Errno::EINPROGRESS - the O_NONBLOCK is set for the +socket+ and the
 *   connection cannot be immediately established; the connection will be
 *   established asynchronously
 * * Errno::EINTR - the attempt to establish the connection was interrupted by
 *   delivery of a signal that was caught; the connection will be established
 *   asynchronously
 * * Errno::EISCONN - the specified +socket+ is already connected
 * * Errno::EINVAL - the address length used for the _sockaddr_ is not a valid
 *   length for the address family or there is an invalid family in _sockaddr_
 * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
 *   PATH_MAX
 * * Errno::ENETDOWN - the local interface used to reach the destination is down
 * * Errno::ENETUNREACH - no route to the network is present
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOSR - there were insufficient STREAMS resources available to
 *   complete the operation
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * * Errno::EOPNOTSUPP - the calling +socket+ is listening and cannot be connected
 * * Errno::EPROTOTYPE - the _sockaddr_ has a different type than the socket
 *   bound to the specified peer address
 * * Errno::ETIMEDOUT - the attempt to connect time out before a connection
 *   was made.
 *
 * On unix-based systems if the address family of the calling +socket+ is
 * AF_UNIX the follow exceptions may be raised if the call to _connect_
 * fails:
 * * Errno::EIO - an i/o error occurred while reading from or writing to the
 *   file system
 * * Errno::ELOOP - too many symbolic links were encountered in translating
 *   the pathname in _sockaddr_
 * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
 *   characters, or an entire pathname exceeded PATH_MAX characters
 * * Errno::ENOENT - a component of the pathname does not name an existing file
 *   or the pathname is an empty string
 * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_
 *   is not a directory
 *
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if
 * the call to _connect_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EADDRINUSE - the socket's local address is already in use
 * * Errno::EINTR - the socket was cancelled
 * * Errno::EINPROGRESS - a blocking socket is in progress or the service provider
 *   is still processing a callback function. Or a nonblocking connect call is
 *   in progress on the +socket+.
 * * Errno::EALREADY - see Errno::EINVAL
 * * Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
 *   ADDR_ANY TODO check ADDRANY TO INADDR_ANY
 * * Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
 *   with this +socket+
 * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections
 *   refused the connection request
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space address
 * * Errno::EINVAL - the +socket+ is a listening socket
 * * Errno::EISCONN - the +socket+ is already connected
 * * Errno::ENETUNREACH - the network cannot be reached from this host at this time
 * * Errno::EHOSTUNREACH - no route to the network is present
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * * Errno::ETIMEDOUT - the attempt to connect time out before a connection
 *   was made.
 * * Errno::EWOULDBLOCK - the socket is marked as nonblocking and the
 *   connection cannot be completed immediately
 * * Errno::EACCES - the attempt to connect the datagram socket to the
 *   broadcast address failed
 *
 * === See
 * * connect manual pages on unix-based systems
 * * connect function in Microsoft's Winsock functions reference
 */
static VALUE
sock_connect(VALUE sock, VALUE addr)
{
    rb_io_t *fptr;
    int fd, n;

    SockAddrStringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    fd = fptr-&gt;fd;
    n = rsock_connect(fd, (struct sockaddr*)RSTRING_PTR(addr), RSTRING_LENINT(addr), 0);
    if (n &lt; 0) {
    rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(n);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="connect_nonblock-instance_method">
  
    - (<tt>0</tt>) <strong>connect_nonblock</strong>(remote_sockaddr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Requests a connection to be made on the given <tt>remote_sockaddr</tt>
after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if
successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><p>
<tt>remote_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string or Addrinfo object
</p>
</li>
</ul>
<h3>Example:</h3>
<pre class="code">
 # Pull down Google's web page
 require 'socket'
 include Socket::Constants
 socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 sockaddr = Socket.sockaddr_in(80, 'www.google.com')
 begin # emulate blocking connect
   socket.connect_nonblock(sockaddr)
 rescue IO::WaitWritable
   IO.select(nil, [socket]) # wait 3-way handshake completion
   begin
     socket.connect_nonblock(sockaddr) # check connection failure
   rescue Errno::EISCONN
   end
 end
 socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
 results = socket.read
</pre>
<p>
Refer to Socket#connect for the exceptions that may be thrown if the call
to <em>connect_nonblock</em> fails.
</p>
<p>
Socket#connect_nonblock may raise any error corresponding to connect(2)
failure, including Errno::EINPROGRESS.
</p>
<p>
If the exception is Errno::EINPROGRESS, it is extended by IO::WaitWritable.
So IO::WaitWritable can be used to rescue the exceptions for retrying
connect_nonblock.
</p>
<h3>See</h3>
<ul>
<li><p>
Socket#connect
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.connect_nonblock(remote_sockaddr) =&gt; 0
 *
 * Requests a connection to be made on the given +remote_sockaddr+ after
 * O_NONBLOCK is set for the underlying file descriptor.
 * Returns 0 if successful, otherwise an exception is raised.
 *
 * === Parameter
 * * +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object
 *
 * === Example:
 *  # Pull down Google's web page
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *  sockaddr = Socket.sockaddr_in(80, 'www.google.com')
 *  begin # emulate blocking connect
 *    socket.connect_nonblock(sockaddr)
 *  rescue IO::WaitWritable
 *    IO.select(nil, [socket]) # wait 3-way handshake completion
 *    begin
 *      socket.connect_nonblock(sockaddr) # check connection failure
 *    rescue Errno::EISCONN
 *    end
 *  end
 *  socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
 *  results = socket.read
 *
 * Refer to Socket#connect for the exceptions that may be thrown if the call
 * to _connect_nonblock_ fails.
 *
 * Socket#connect_nonblock may raise any error corresponding to connect(2) failure,
 * including Errno::EINPROGRESS.
 *
 * If the exception is Errno::EINPROGRESS,
 * it is extended by IO::WaitWritable.
 * So IO::WaitWritable can be used to rescue the exceptions for retrying connect_nonblock.
 *
 * === See
 * * Socket#connect
 */
static VALUE
sock_connect_nonblock(VALUE sock, VALUE addr)
{
    rb_io_t *fptr;
    int n;

    SockAddrStringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    rb_io_set_nonblock(fptr);
    n = connect(fptr-&gt;fd, (struct sockaddr*)RSTRING_PTR(addr), RSTRING_LENINT(addr));
    if (n &lt; 0) {
        if (errno == EINPROGRESS)
            rb_mod_sys_fail(rb_mWaitWritable, &quot;connect(2) would block&quot;);
    rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(n);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="listen-instance_method">
  
    - (<tt>0</tt>) <strong>listen</strong>(int) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Listens for connections, using the specified <tt>int</tt> as the backlog. A
call to <em>listen</em> only applies if the <tt>socket</tt> is of type
SOCK_STREAM or SOCK_SEQPACKET.
</p>
<h3>Parameter</h3>
<ul>
<li><p>
<tt>backlog</tt> - the maximum length of the queue for pending connections.
</p>
</li>
</ul>
<h3>Example 1</h3>
<pre class="code">
 require 'socket'
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 socket.bind( sockaddr )
 socket.listen( 5 )
</pre>
<h3>Example 2 (listening on an arbitrary port, unix-based systems only):</h3>
<pre class="code">
 require 'socket'
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 socket.listen( 1 )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix based systems the above will work because a new <tt>sockaddr</tt>
struct is created on the address ADDR_ANY, for an arbitrary port number as
handed off by the kernel. It will not work on Windows, because Windows
requires that the <tt>socket</tt> is bound by calling <em>bind</em> before
it can <em>listen</em>.
</p>
<p>
If the <em>backlog</em> amount exceeds the implementation-dependent maximum
queue length, the implementation&#8217;s maximum queue length will be used.
</p>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>listen</em> fails:
</p>
<ul>
<li><p>
Errno::EBADF - the <em>socket</em> argument is not a valid file descriptor
</p>
</li>
<li><p>
Errno::EDESTADDRREQ - the <em>socket</em> is not bound to a local address,
and the protocol does not support listening on an unbound socket
</p>
</li>
<li><p>
Errno::EINVAL - the <em>socket</em> is already connected
</p>
</li>
<li><p>
Errno::ENOTSOCK - the <em>socket</em> argument does not refer to a socket
</p>
</li>
<li><p>
Errno::EOPNOTSUPP - the <em>socket</em> protocol does not support listen
</p>
</li>
<li><p>
Errno::EACCES - the calling process does not have appropriate privileges
</p>
</li>
<li><p>
Errno::EINVAL - the <em>socket</em> has been shut down
</p>
</li>
<li><p>
Errno::ENOBUFS - insufficient resources are available in the system to
complete the call
</p>
</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>listen</em> fails:
</p>
<ul>
<li><p>
Errno::ENETDOWN - the network is down
</p>
</li>
<li><p>
Errno::EADDRINUSE - the socket&#8217;s local address is already in use.
This usually occurs during the execution of <em>bind</em> but could be
delayed if the call to <em>bind</em> was to a partially wildcard address
(involving ADDR_ANY) and if a specific address needs to be committed at the
time of the call to <em>listen</em>
</p>
</li>
<li><p>
Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
service provider is still processing a callback function
</p>
</li>
<li><p>
Errno::EINVAL - the <tt>socket</tt> has not been bound with a call to
<em>bind</em>.
</p>
</li>
<li><p>
Errno::EISCONN - the <tt>socket</tt> is already connected
</p>
</li>
<li><p>
Errno::EMFILE - no more socket descriptors are available
</p>
</li>
<li><p>
Errno::ENOBUFS - no buffer space is available
</p>
</li>
<li><p>
Errno::ENOTSOC - <tt>socket</tt> is not a socket
</p>
</li>
<li><p>
Errno::EOPNOTSUPP - the referenced <tt>socket</tt> is not a type that
supports the <em>listen</em> method
</p>
</li>
</ul>
<h3>See</h3>
<ul>
<li><p>
listen manual pages on unix-based systems
</p>
</li>
<li><p>
listen function in Microsoft&#8217;s Winsock functions reference
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.listen( int ) =&gt; 0
 *
 * Listens for connections, using the specified +int+ as the backlog. A call
 * to _listen_ only applies if the +socket+ is of type SOCK_STREAM or
 * SOCK_SEQPACKET.
 *
 * === Parameter
 * * +backlog+ - the maximum length of the queue for pending connections.
 *
 * === Example 1
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *  socket.bind( sockaddr )
 *  socket.listen( 5 )
 *
 * === Example 2 (listening on an arbitrary port, unix-based systems only):
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  socket.listen( 1 )
 *
 * === Unix-based Exceptions
 * On unix based systems the above will work because a new +sockaddr+ struct
 * is created on the address ADDR_ANY, for an arbitrary port number as handed
 * off by the kernel. It will not work on Windows, because Windows requires that
 * the +socket+ is bound by calling _bind_ before it can _listen_.
 *
 * If the _backlog_ amount exceeds the implementation-dependent maximum
 * queue length, the implementation's maximum queue length will be used.
 *
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _listen_ fails:
 * * Errno::EBADF - the _socket_ argument is not a valid file descriptor
 * * Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and
 *   the protocol does not support listening on an unbound socket
 * * Errno::EINVAL - the _socket_ is already connected
 * * Errno::ENOTSOCK - the _socket_ argument does not refer to a socket
 * * Errno::EOPNOTSUPP - the _socket_ protocol does not support listen
 * * Errno::EACCES - the calling process does not have appropriate privileges
 * * Errno::EINVAL - the _socket_ has been shut down
 * * Errno::ENOBUFS - insufficient resources are available in the system to
 *   complete the call
 *
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if
 * the call to _listen_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EADDRINUSE - the socket's local address is already in use. This
 *   usually occurs during the execution of _bind_ but could be delayed
 *   if the call to _bind_ was to a partially wildcard address (involving
 *   ADDR_ANY) and if a specific address needs to be committed at the
 *   time of the call to _listen_
 * * Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
 *   service provider is still processing a callback function
 * * Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.
 * * Errno::EISCONN - the +socket+ is already connected
 * * Errno::EMFILE - no more socket descriptors are available
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOC - +socket+ is not a socket
 * * Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports
 *   the _listen_ method
 *
 * === See
 * * listen manual pages on unix-based systems
 * * listen function in Microsoft's Winsock functions reference
 */
VALUE
rsock_sock_listen(VALUE sock, VALUE log)
{
    rb_io_t *fptr;
    int backlog;

    rb_secure(4);
    backlog = NUM2INT(log);
    GetOpenFile(sock, fptr);
    if (listen(fptr-&gt;fd, backlog) &lt; 0)
    rb_sys_fail(&quot;listen(2)&quot;);

    return INT2FIX(0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="recvfrom-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom</strong>(maxlen) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom</strong>(maxlen, flags) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt>. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_addrinfo</em>, contains protocol-specific address information of
the sender.
</p>
<h3>Parameters</h3>
<ul>
<li><p>
<tt>maxlen</tt> - the maximum number of bytes to receive from the socket
</p>
</li>
<li><p>
<tt>flags</tt> - zero or more of the <tt>MSG_</tt> options
</p>
</li>
</ul>
<h3>Example</h3>
<pre class="code">
 # In one file, start this first
 require 'socket'
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 socket.bind( sockaddr )
 socket.listen( 5 )
 client, client_addrinfo = socket.accept
 data = client.recvfrom( 20 )[0].chomp
 puts &quot;I only received 20 bytes '#{data}'&quot;
 sleep 1
 socket.close

 # In another file, start this second
 require 'socket'
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 socket.connect( sockaddr )
 socket.puts &quot;Watch this get cut short!&quot;
 socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>recvfrom</em> fails:
</p>
<ul>
<li><p>
Errno::EAGAIN - the <tt>socket</tt> file descriptor is marked as O_NONBLOCK
and no data is waiting to be received; or MSG_OOB is set and no out-of-band
data is available and either the <tt>socket</tt> file descriptor is marked
as O_NONBLOCK or the <tt>socket</tt> does not support blocking to wait for
out-of-band-data
</p>
</li>
<li><p>
Errno::EWOULDBLOCK - see Errno::EAGAIN
</p>
</li>
<li><p>
Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor
</p>
</li>
<li><p>
Errno::ECONNRESET - a connection was forcibly closed by a peer
</p>
</li>
<li><p>
Errno::EFAULT - the socket&#8217;s internal buffer, address or address
length cannot be accessed or written
</p>
</li>
<li><p>
Errno::EINTR - a signal interrupted <em>recvfrom</em> before any data was
available
</p>
</li>
<li><p>
Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
available
</p>
</li>
<li><p>
Errno::EIO - an i/o error occurred while reading from or writing to the
filesystem
</p>
</li>
<li><p>
Errno::ENOBUFS - insufficient resources were available in the system to
perform the operation
</p>
</li>
<li><p>
Errno::ENOMEM - insufficient memory was available to fulfill the request
</p>
</li>
<li><p>
Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation
</p>
</li>
<li><p>
Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
is not connected
</p>
</li>
<li><p>
Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket
</p>
</li>
<li><p>
Errno::EOPNOTSUPP - the specified flags are not supported for this socket
type
</p>
</li>
<li><p>
Errno::ETIMEDOUT - the connection timed out during connection establishment
or due to a transmission timeout on an active connection
</p>
</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>recvfrom</em> fails:
</p>
<ul>
<li><p>
Errno::ENETDOWN - the network is down
</p>
</li>
<li><p>
Errno::EFAULT - the internal buffer and from parameters on <tt>socket</tt>
are not part of the user address space, or the internal fromlen parameter
is too small to accommodate the peer address
</p>
</li>
<li><p>
Errno::EINTR - the (blocking) call was cancelled by an internal call to the
WinSock function WSACancelBlockingCall
</p>
</li>
<li><p>
Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function
</p>
</li>
<li><p>
Errno::EINVAL - <tt>socket</tt> has not been bound with a call to
<em>bind</em>, or an unknown flag was specified, or MSG_OOB was specified
for a socket with SO_OOBINLINE enabled, or (for byte stream-style sockets
only) the internal len parameter on <tt>socket</tt> was zero or negative
</p>
</li>
<li><p>
Errno::EISCONN - <tt>socket</tt> is already connected. The call to
<em>recvfrom</em> is not permitted with a connected socket on a socket that
is connection oriented or connectionless.
</p>
</li>
<li><p>
Errno::ENETRESET - the connection has been broken due to the keep-alive
activity detecting a failure while the operation was in progress.
</p>
</li>
<li><p>
Errno::EOPNOTSUPP - MSG_OOB was specified, but <tt>socket</tt> is not
stream-style such as type SOCK_STREAM. OOB data is not supported in the
communication domain associated with <tt>socket</tt>, or <tt>socket</tt> is
unidirectional and supports only send operations
</p>
</li>
<li><p>
Errno::ESHUTDOWN - <tt>socket</tt> has been shutdown. It is not possible to
call <em>recvfrom</em> on a socket after <em>shutdown</em> has been
invoked.
</p>
</li>
<li><p>
Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and a  call
to <em>recvfrom</em> would block.
</p>
</li>
<li><p>
Errno::EMSGSIZE - the message was too large to fit into the specified
buffer and was truncated.
</p>
</li>
<li><p>
Errno::ETIMEDOUT - the connection has been dropped, because of a network
failure or because the system on the other end went down without notice
</p>
</li>
<li><p>
Errno::ECONNRESET - the virtual circuit was reset by the remote side
executing a hard or abortive close. The application should close the
socket; it is no longer usable. On a UDP-datagram socket this error
indicates a previous send operation resulted in an ICMP Port Unreachable
message.
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom</strong>(maxlen) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom</strong>(maxlen, flags) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.recvfrom(maxlen) =&gt; [mesg, sender_addrinfo]
 *  socket.recvfrom(maxlen, flags) =&gt; [mesg, sender_addrinfo]
 *
 * Receives up to _maxlen_ bytes from +socket+. _flags_ is zero or more
 * of the +MSG_+ options. The first element of the results, _mesg_, is the data
 * received. The second element, _sender_addrinfo_, contains protocol-specific
 * address information of the sender.
 *
 * === Parameters
 * * +maxlen+ - the maximum number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options
 *
 * === Example
 *  # In one file, start this first
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *  socket.bind( sockaddr )
 *  socket.listen( 5 )
 *  client, client_addrinfo = socket.accept
 *  data = client.recvfrom( 20 )[0].chomp
 *  puts &quot;I only received 20 bytes '#{data}'&quot;
 *  sleep 1
 *  socket.close
 *
 *  # In another file, start this second
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *  socket.connect( sockaddr )
 *  socket.puts &quot;Watch this get cut short!&quot;
 *  socket.close
 *
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _recvfrom_ fails:
 * * Errno::EAGAIN - the +socket+ file descriptor is marked as O_NONBLOCK and no
 *   data is waiting to be received; or MSG_OOB is set and no out-of-band data
 *   is available and either the +socket+ file descriptor is marked as
 *   O_NONBLOCK or the +socket+ does not support blocking to wait for
 *   out-of-band-data
 * * Errno::EWOULDBLOCK - see Errno::EAGAIN
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNRESET - a connection was forcibly closed by a peer
 * * Errno::EFAULT - the socket's internal buffer, address or address length
 *   cannot be accessed or written
 * * Errno::EINTR - a signal interrupted _recvfrom_ before any data was available
 * * Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available
 * * Errno::EIO - an i/o error occurred while reading from or writing to the
 *   filesystem
 * * Errno::ENOBUFS - insufficient resources were available in the system to
 *   perform the operation
 * * Errno::ENOMEM - insufficient memory was available to fulfill the request
 * * Errno::ENOSR - there were insufficient STREAMS resources available to
 *   complete the operation
 * * Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
 *   is not connected
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the specified flags are not supported for this socket type
 * * Errno::ETIMEDOUT - the connection timed out during connection establishment
 *   or due to a transmission timeout on an active connection
 *
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if
 * the call to _recvfrom_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EFAULT - the internal buffer and from parameters on +socket+ are not
 *   part of the user address space, or the internal fromlen parameter is
 *   too small to accommodate the peer address
 * * Errno::EINTR - the (blocking) call was cancelled by an internal call to
 *   the WinSock function WSACancelBlockingCall
 * * Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
 *   the service provider is still processing a callback function
 * * Errno::EINVAL - +socket+ has not been bound with a call to _bind_, or an
 *   unknown flag was specified, or MSG_OOB was specified for a socket with
 *   SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
 *   len parameter on +socket+ was zero or negative
 * * Errno::EISCONN - +socket+ is already connected. The call to _recvfrom_ is
 *   not permitted with a connected socket on a socket that is connection
 *   oriented or connectionless.
 * * Errno::ENETRESET - the connection has been broken due to the keep-alive
 *   activity detecting a failure while the operation was in progress.
 * * Errno::EOPNOTSUPP - MSG_OOB was specified, but +socket+ is not stream-style
 *   such as type SOCK_STREAM. OOB data is not supported in the communication
 *   domain associated with +socket+, or +socket+ is unidirectional and
 *   supports only send operations
 * * Errno::ESHUTDOWN - +socket+ has been shutdown. It is not possible to
 *   call _recvfrom_ on a socket after _shutdown_ has been invoked.
 * * Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and a  call to
 *   _recvfrom_ would block.
 * * Errno::EMSGSIZE - the message was too large to fit into the specified buffer
 *   and was truncated.
 * * Errno::ETIMEDOUT - the connection has been dropped, because of a network
 *   failure or because the system on the other end went down without
 *   notice
 * * Errno::ECONNRESET - the virtual circuit was reset by the remote side
 *   executing a hard or abortive close. The application should close the
 *   socket; it is no longer usable. On a UDP-datagram socket this error
 *   indicates a previous send operation resulted in an ICMP Port Unreachable
 *   message.
 */
static VALUE
sock_recvfrom(int argc, VALUE *argv, VALUE sock)
{
    return rsock_s_recvfrom(sock, argc, argv, RECV_SOCKET);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="recvfrom_nonblock-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom_nonblock</strong>(maxlen) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom_nonblock</strong>(maxlen, flags) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using recvfrom(2)
after O_NONBLOCK is set for the underlying file descriptor. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_addrinfo</em>, contains protocol-specific address information of
the sender.
</p>
<p>
When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty
string as data. The meaning depends on the socket: EOF on TCP, empty packet
on UDP, etc.
</p>
<h3>Parameters</h3>
<ul>
<li><p>
<tt>maxlen</tt> - the maximum number of bytes to receive from the socket
</p>
</li>
<li><p>
<tt>flags</tt> - zero or more of the <tt>MSG_</tt> options
</p>
</li>
</ul>
<h3>Example</h3>
<pre class="code">
 # In one file, start this first
 require 'socket'
 include Socket::Constants
 socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 sockaddr = Socket.sockaddr_in(2200, 'localhost')
 socket.bind(sockaddr)
 socket.listen(5)
 client, client_addrinfo = socket.accept
 begin # emulate blocking recvfrom
   pair = client.recvfrom_nonblock(20)
 rescue IO::WaitReadable
   IO.select([client])
   retry
 end
 data = pair[0].chomp
 puts &quot;I only received 20 bytes '#{data}'&quot;
 sleep 1
 socket.close

 # In another file, start this second
 require 'socket'
 include Socket::Constants
 socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 sockaddr = Socket.sockaddr_in(2200, 'localhost')
 socket.connect(sockaddr)
 socket.puts &quot;Watch this get cut short!&quot;
 socket.close
</pre>
<p>
Refer to Socket#recvfrom for the exceptions that may be thrown if the call
to <em>recvfrom_nonblock</em> fails.
</p>
<p>
Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
failure, including Errno::EWOULDBLOCK.
</p>
<p>
If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions
for retrying recvfrom_nonblock.
</p>
<h3>See</h3>
<ul>
<li><p>
Socket#recvfrom
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom_nonblock</strong>(maxlen) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>recvfrom_nonblock</strong>(maxlen, flags) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.recvfrom_nonblock(maxlen) =&gt; [mesg, sender_addrinfo]
 *  socket.recvfrom_nonblock(maxlen, flags) =&gt; [mesg, sender_addrinfo]
 *
 * Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * _flags_ is zero or more of the +MSG_+ options.
 * The first element of the results, _mesg_, is the data received.
 * The second element, _sender_addrinfo_, contains protocol-specific address
 * information of the sender.
 *
 * When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns
 * an empty string as data.
 * The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.
 *
 * === Parameters
 * * +maxlen+ - the maximum number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options
 *
 * === Example
 *  # In one file, start this first
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *  sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *  socket.bind(sockaddr)
 *  socket.listen(5)
 *  client, client_addrinfo = socket.accept
 *  begin # emulate blocking recvfrom
 *    pair = client.recvfrom_nonblock(20)
 *  rescue IO::WaitReadable
 *    IO.select([client])
 *    retry
 *  end
 *  data = pair[0].chomp
 *  puts &quot;I only received 20 bytes '#{data}'&quot;
 *  sleep 1
 *  socket.close
 *
 *  # In another file, start this second
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 *  sockaddr = Socket.sockaddr_in(2200, 'localhost')
 *  socket.connect(sockaddr)
 *  socket.puts &quot;Watch this get cut short!&quot;
 *  socket.close
 *
 * Refer to Socket#recvfrom for the exceptions that may be thrown if the call
 * to _recvfrom_nonblock_ fails.
 *
 * Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure,
 * including Errno::EWOULDBLOCK.
 *
 * If the exception is Errno::EWOULDBLOCK or Errno::AGAIN,
 * it is extended by IO::WaitReadable.
 * So IO::WaitReadable can be used to rescue the exceptions for retrying recvfrom_nonblock.
 *
 * === See
 * * Socket#recvfrom
 */
static VALUE
sock_recvfrom_nonblock(int argc, VALUE *argv, VALUE sock)
{
    return rsock_s_recvfrom_nonblock(sock, argc, argv, RECV_SOCKET);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sysaccept-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>sysaccept</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Accepts an incoming connection returning an array containing the (integer)
file descriptor for the incoming connection, <em>client_socket_fd</em>, and
an Addrinfo, <em>client_addrinfo</em>.
</p>
<h3>Example</h3>
<pre class="code">
 # In one script, start this first
 require 'socket'
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 socket.bind( sockaddr )
 socket.listen( 5 )
 client_fd, client_addrinfo = socket.sysaccept
 client_socket = Socket.for_fd( client_fd )
 puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 client_socket.puts &quot;Hello from script one!&quot;
 socket.close

 # In another script, start this second
 require 'socket'
 include Socket::Constants
 socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 socket.connect( sockaddr )
 socket.puts &quot;Hello from script 2.&quot;
 puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 socket.close
</pre>
<p>
Refer to Socket#accept for the exceptions that may be thrown if the call to
<em>sysaccept</em> fails.
</p>
<h3>See</h3>
<ul>
<li><p>
Socket#accept
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'ext/socket/socket.c'</span>

/*
 * call-seq:
 *  socket.sysaccept =&gt; [client_socket_fd, client_addrinfo]
 *
 * Accepts an incoming connection returning an array containing the (integer)
 * file descriptor for the incoming connection, _client_socket_fd_,
 * and an Addrinfo, _client_addrinfo_.
 *
 * === Example
 *  # In one script, start this first
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *  socket.bind( sockaddr )
 *  socket.listen( 5 )
 *  client_fd, client_addrinfo = socket.sysaccept
 *  client_socket = Socket.for_fd( client_fd )
 *  puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 *  client_socket.puts &quot;Hello from script one!&quot;
 *  socket.close
 *
 *  # In another script, start this second
 *  require 'socket'
 *  include Socket::Constants
 *  socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 *  sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 *  socket.connect( sockaddr )
 *  socket.puts &quot;Hello from script 2.&quot;
 *  puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 *  socket.close
 *
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to _sysaccept_ fails.
 *
 * === See
 * * Socket#accept
 */
static VALUE
sock_sysaccept(VALUE sock)
{
    rb_io_t *fptr;
    VALUE sock2;
    struct sockaddr_storage buf;
    socklen_t len = (socklen_t)sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = rsock_s_accept(0,fptr-&gt;fd,(struct sockaddr*)&amp;buf,&amp;len);

    return rb_assoc_new(sock2, rsock_io_socket_addrinfo(sock2, (struct sockaddr*)&amp;buf, len));
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:01:30 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>