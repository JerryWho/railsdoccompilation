  <div id="fileHeader">
    <h1>configuration.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/cli/configuration.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:11:24 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Cucumber
  module Cli
    class YmlLoadError &lt; StandardError; end

    class Configuration
      FORMATS = %w{pretty profile progress rerun}
      DEFAULT_FORMAT = 'pretty'
    
      attr_reader :paths
      attr_reader :options
    
      def initialize(out_stream = STDOUT, error_stream = STDERR)
        @out_stream   = out_stream
        @error_stream = error_stream
      
        @paths          = []
        @options        = default_options
        @active_format  = DEFAULT_FORMAT
      end
    
      def parse!(args)
        @args = args
        return parse_args_from_profile('default') if @args.empty?
        @args.extend(::OptionParser::Arguable)
      
        @args.options do |opts|
          opts.banner = [&quot;Usage: cucumber [options] [ [FILE|DIR|URL][:LINE[:LINE]*] ]+&quot;, &quot;&quot;,
            &quot;Examples:&quot;,
            &quot;cucumber examples/i18n/en/features&quot;,
            &quot;cucumber --language it examples/i18n/it/features/somma.feature:6:98:113&quot;,
            &quot;cucumber -n -i http://rubyurl.com/eeCl&quot;, &quot;&quot;, &quot;&quot;,
          ].join(&quot;\n&quot;)
          opts.on(&quot;-r LIBRARY|DIR&quot;, &quot;--require LIBRARY|DIR&quot;, 
            &quot;Require files before executing the features. If this&quot;,
            &quot;option is not specified, all *.rb files that are&quot;,
            &quot;siblings or below the features will be loaded auto-&quot;,
            &quot;matically. Automatic loading is disabled when this&quot;,
            &quot;option is specified, and all loading becomes explicit.&quot;,
            &quot;Files under directories named \&quot;support\&quot; are always&quot;,
            &quot;loaded first.&quot;,
            &quot;This option can be specified multiple times.&quot;) do |v|
            @options[:require] ||= []
            @options[:require] &lt;&lt; v
          end
          opts.on(&quot;-l LANG&quot;, &quot;--language LANG&quot;, 
            &quot;Specify language for features (Default: #{@options[:lang]})&quot;,
            %{Run with &quot;--language help&quot; to see all languages},
            %{Run with &quot;--language LANG help&quot; to list keywords for LANG}) do |v|
            if v == 'help'
              list_languages
            elsif args==['help']
              list_keywords_and_exit(v)
            else
              @options[:lang] = v
            end
          end
          opts.on(&quot;-f FORMAT&quot;, &quot;--format FORMAT&quot;, 
            &quot;How to format features (Default: #{DEFAULT_FORMAT})&quot;,
            &quot;Available formats: #{FORMATS.join(&quot;, &quot;)}&quot;,
            &quot;You can also provide your own formatter classes as long&quot;,
            &quot;as they have been previously required using --require or&quot;,
            &quot;if they are in the folder structure such that cucumber&quot;,
            &quot;will require them automatically.&quot;, 
            &quot;This option can be specified multiple times.&quot;) do |v|
            @options[:formats][v] = @out_stream
            @active_format = v
          end
          opts.on(&quot;-o&quot;, &quot;--out FILE&quot;, 
            &quot;Write output to a file instead of STDOUT. This option&quot;,
            &quot;applies to the previously specified --format, or the&quot;,
            &quot;default format if no format is specified.&quot;) do |v|
            @options[:formats][@active_format] = v
          end
          opts.on(&quot;-t TAGS&quot;, &quot;--tags TAGS&quot;, 
            &quot;Only execute the features or scenarios with the specified tags.&quot;,
            &quot;TAGS must be comma-separated without spaces. Prefix tags with ~ to&quot;,
            &quot;exclude features or scenarios having that tag. Tags can be specified&quot;,
            &quot;with or without the @ prefix.&quot;) do |v|
            @options[:include_tags], @options[:exclude_tags] = *parse_tags(v)
          end
          opts.on(&quot;-s SCENARIO&quot;, &quot;--scenario SCENARIO&quot;, 
            &quot;Only execute the scenario with the given name. If this option&quot;,
            &quot;is given more than once, run all the specified scenarios.&quot;) do |v|
            @options[:scenario_names] &lt;&lt; v
          end
          opts.on(&quot;-e&quot;, &quot;--exclude PATTERN&quot;, &quot;Don't run feature files matching PATTERN&quot;) do |v|
            @options[:excludes] &lt;&lt; v
          end
          opts.on(&quot;-p&quot;, &quot;--profile PROFILE&quot;, &quot;Pull commandline arguments from cucumber.yml.&quot;) do |v|
            parse_args_from_profile(v)
          end
          opts.on(&quot;-c&quot;, &quot;--[no-]color&quot;,
            &quot;Whether or not to use ANSI color in the output. Cucumber decides&quot;,
            &quot;based on your platform and the output destination if not specified.&quot;) do |v|
            Term::ANSIColor.coloring = v
          end
          opts.on(&quot;-d&quot;, &quot;--dry-run&quot;, &quot;Invokes formatters without executing the steps.&quot;,
            &quot;This also omits the loading of your support/env.rb file if it exists.&quot;,
            &quot;Implies --quiet.&quot;) do
            @options[:dry_run] = true
            @quiet = true
          end
          opts.on(&quot;-a&quot;, &quot;--autoformat DIRECTORY&quot;, 
            &quot;Reformats (pretty prints) feature files and write them to DIRECTORY.&quot;,
            &quot;Be careful if you choose to overwrite the originals.&quot;,
            &quot;Implies --dry-run --formatter pretty.&quot;) do |directory|
            @options[:autoformat] = directory
            Term::ANSIColor.coloring = false
            @options[:dry_run] = true
            @quiet = true
          end
          opts.on(&quot;-m&quot;, &quot;--no-multiline&quot;, 
            &quot;Don't print multiline strings and tables under steps.&quot;) do
            @options[:no_multiline] = true
          end
          opts.on(&quot;-n&quot;, &quot;--no-source&quot;, 
            &quot;Don't print the file and line of the step definition with the steps.&quot;) do
            @options[:source] = false
          end
          opts.on(&quot;-i&quot;, &quot;--no-snippets&quot;, &quot;Don't print snippets for pending steps.&quot;) do
            @options[:snippets] = false
          end
          opts.on(&quot;-q&quot;, &quot;--quiet&quot;, &quot;Alias for --no-snippets --no-source.&quot;) do
            @quiet = true
          end
          opts.on(&quot;-b&quot;, &quot;--backtrace&quot;, &quot;Show full backtrace for all errors.&quot;) do
            Exception.cucumber_full_backtrace = true
          end
          opts.on(&quot;-S&quot;, &quot;--strict&quot;, &quot;Fail if there are any undefined steps.&quot;) do
            @options[:strict] = true
          end
          opts.on(&quot;-v&quot;, &quot;--verbose&quot;, &quot;Show the files and features loaded.&quot;) do
            @options[:verbose] = true
          end
          opts.on(&quot;-g&quot;, &quot;--guess&quot;, &quot;Guess best match for Ambiguous steps.&quot;) do
            @options[:guess] = true
          end
          opts.on(&quot;--no-diff&quot;, &quot;Disable diff output on failing expectations.&quot;) do
            @options[:diff_enabled] = false
          end
          opts.on_tail(&quot;--version&quot;, &quot;Show version.&quot;) do
            @out_stream.puts VERSION::STRING
            Kernel.exit
          end
          opts.on_tail(&quot;-h&quot;, &quot;--help&quot;, &quot;You're looking at it.&quot;) do
            @out_stream.puts opts.help
            Kernel.exit
          end
        end.parse!

        @options[:formats]['pretty'] = @out_stream if @options[:formats].empty?

        @options[:snippets] = true if !@quiet &amp;&amp; @options[:snippets].nil?
        @options[:source]   = true if !@quiet &amp;&amp; @options[:source].nil?

        # Whatever is left after option parsing is the FILE arguments
        @paths += args
      end
    
      def verbose?
        @options[:verbose]
      end
    
      def strict?
        @options[:strict]
      end
      
      def guess?
        @options[:guess]
      end
    
      def diff_enabled?
        @options[:diff_enabled]
      end

      def load_language
        if Cucumber.language_incomplete?(@options[:lang])
          list_keywords_and_exit(@options[:lang])
        else
          Cucumber.load_language(@options[:lang])
        end
      end

      def parse_tags(tag_string)
        tag_names = tag_string.split(&quot;,&quot;)
        excludes, includes = tag_names.partition{|tag| tag =~ /^~/}
        excludes = excludes.map{|tag| tag[1..-1]}

        # Strip @
        includes = includes.map{|tag| tag =~ /^@(.*)/ ? $1 : tag}
        excludes = excludes.map{|tag| tag =~ /^@(.*)/ ? $1 : tag}
        [includes, excludes]
      end

      def build_formatter_broadcaster(step_mother)
        return Formatter::Pretty.new(step_mother, nil, @options) if @options[:autoformat]
        formatters = @options[:formats].map do |format, out|
          if String === out # file name
            out = File.open(out, Cucumber.file_mode('w'))
            at_exit do
              out.flush
              out.close
            end
          end
        
          begin
            formatter_class = formatter_class(format)
            formatter_class.new(step_mother, out, @options)
          rescue Exception =&gt; e
            exit_with_error(&quot;Error creating formatter: #{format}&quot;, e)
          end
        end
      
        broadcaster = Broadcaster.new(formatters)
        broadcaster.options = @options
        return broadcaster
      end
    
      def formatter_class(format)
        case format
          when 'html'     then Formatter::Html
          when 'pretty'   then Formatter::Pretty
          when 'profile'  then Formatter::Profile
          when 'progress' then Formatter::Progress
          when 'rerun'    then Formatter::Rerun
          when 'usage'    then Formatter::Usage
        else
          constantize(format)
        end
      end
    
      def files_to_require
        requires = @options[:require] || feature_dirs
        files = requires.map do |path|
          path = path.gsub(/\\/, '/') # In case we're on windows. Globs don't work with backslashes.
          File.directory?(path) ? Dir[&quot;#{path}/**/*.rb&quot;] : path
        end.flatten.uniq
        sorted_files = files.sort { |a,b| (b =~ %r{/support/} || -1) &lt;=&gt;  (a =~ %r{/support/} || -1) }.reject{|f| f =~ /^http/}
        env_files = sorted_files.select {|f| f =~ %r{/support/env.rb} }
        files = env_files + sorted_files.reject {|f| f =~ %r{/support/env.rb} }
        files.reject! {|f| f =~ %r{/support/env.rb} } if @options[:dry_run]
        files
      end
    
      def feature_files
        potential_feature_files = @paths.map do |path|
          path = path.gsub(/\\/, '/') # In case we're on windows. Globs don't work with backslashes.
          path = path.chomp('/')
          File.directory?(path) ? Dir[&quot;#{path}/**/*.feature&quot;] : path
        end.flatten.uniq

        @options[:excludes].each do |exclude|
          potential_feature_files.reject! do |path|
            path =~ /#{Regexp.escape(exclude)}/
          end
        end

        potential_feature_files
      end
    
    protected
  
      def feature_dirs
        feature_files.map { |f| File.directory?(f) ? f : File.dirname(f) }.uniq
      end
    
      def constantize(camel_cased_word)
        names = camel_cased_word.split('::')
        names.shift if names.empty? || names.first.empty?

        constant = Object
        names.each do |name|
          constant = constant.const_defined?(name) ? constant.const_get(name) : constant.const_missing(name)
        end
        constant
      end
    
      def parse_args_from_profile(profile)
        unless cucumber_yml.has_key?(profile)
          return(exit_with_error &lt;&lt;-END_OF_ERROR)
Could not find profile: '#{profile}'

Defined profiles in cucumber.yml:
  * #{cucumber_yml.keys.join(&quot;\n  * &quot;)}
        END_OF_ERROR
        end

        args_from_yml = cucumber_yml[profile] || ''

        if !args_from_yml.is_a?(String)
          exit_with_error &quot;Profiles must be defined as a String.  The '#{profile}' profile was #{args_from_yml.inspect} (#{args_from_yml.class}).\n&quot;
        elsif args_from_yml =~ /^\s*$/
          exit_with_error &quot;The 'foo' profile in cucumber.yml was blank.  Please define the command line arguments for the 'foo' profile in cucumber.yml.\n&quot;
        else
          parse!(args_from_yml.split(' '))
        end

      rescue YmlLoadError =&gt; e
        exit_with_error(e.message)
      end
    
      def cucumber_yml
        return @cucumber_yml if @cucumber_yml
        unless File.exist?('cucumber.yml')
          raise(YmlLoadError,&quot;cucumber.yml was not found.  Please refer to cucumber's documentation on defining profiles in cucumber.yml.  You must define a 'default' profile to use the cucumber command without any arguments.\nType 'cucumber --help' for usage.\n&quot;)
        end

        require 'yaml'
        begin
          @cucumber_yml = YAML::load(IO.read('cucumber.yml'))
        rescue Exception =&gt; e
          raise(YmlLoadError,&quot;cucumber.yml was found, but could not be parsed. Please refer to cucumber's documentation on correct profile usage.\n&quot;)
        end

        if @cucumber_yml.nil? || !@cucumber_yml.is_a?(Hash)
          raise(YmlLoadError,&quot;cucumber.yml was found, but was blank or malformed. Please refer to cucumber's documentation on correct profile usage.\n&quot;)
        end

        return @cucumber_yml
      end
    
      def list_keywords_and_exit(lang)
        unless Cucumber::LANGUAGES[lang]
          exit_with_error(&quot;No language with key #{lang}&quot;)
        end
        LanguageHelpFormatter.list_keywords(@out_stream, lang)
        Kernel.exit
      end
    
      def list_languages
        LanguageHelpFormatter.list_languages(@out_stream)
        Kernel.exit
      end
    
      def default_options
        {
          :strict         =&gt; false,
          :require        =&gt; nil,
          :lang           =&gt; 'en',
          :dry_run        =&gt; false,
          :formats        =&gt; {},
          :excludes       =&gt; [],
          :include_tags   =&gt; [],
          :exclude_tags   =&gt; [],
          :scenario_names =&gt; [],
          :diff_enabled   =&gt; true
        }
      end
    
      def exit_with_error(error_message, e=nil)
        @error_stream.puts(error_message)
        if e
          @error_stream.puts(&quot;#{e.message} (#{e.class})&quot;)
          @error_stream.puts(e.backtrace.join(&quot;\n&quot;))
        end
        Kernel.exit 1
      end
    end
  
  end
end
</pre>
    </div>