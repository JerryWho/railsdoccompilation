  <div id="fileHeader">
    <h1>step_definition.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/step_definition.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:11:24 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'cucumber/step_match'
require 'cucumber/core_ext/string'
require 'cucumber/core_ext/proc'

module Cucumber
  module StepDefinitionMethods
    def step_match(name_to_match, name_to_report)
      if(match = name_to_match.match(regexp))
        StepMatch.new(self, name_to_match, name_to_report, match.captures)
      else
        nil
      end
    end

    # Formats the matched arguments of the associated Step. This method
    # is usually called from visitors, which render output.
    #
    # The +format+ can either be a String or a Proc.
    #
    # If it is a String it should be a format string according to
    # &lt;tt&gt;Kernel#sprinf&lt;/tt&gt;, for example:
    #
    #   '&lt;span class=&quot;param&quot;&gt;%s&lt;/span&gt;&lt;/tt&gt;'
    #
    # If it is a Proc, it should take one argument and return the formatted
    # argument, for example:
    #
    #   lambda { |param| &quot;[#{param}]&quot; }
    #
    def format_args(step_name, format)
      step_name.gzub(regexp, format)
    end

    def match(step_name)
      case step_name
      when String then regexp.match(step_name)
      when Regexp then regexp == step_name
      end
    end

    def backtrace_line
      &quot;#{file_colon_line}:in `#{regexp.inspect}'&quot;
    end

    def text_length
      regexp.inspect.jlength
    end
  end
  
  # A Step Definition holds a Regexp and a Proc, and is created
  # by calling &lt;tt&gt;Given&lt;/tt&gt;, &lt;tt&gt;When&lt;/tt&gt; or &lt;tt&gt;Then&lt;/tt&gt;
  # in the &lt;tt&gt;step_definitions&lt;/tt&gt; ruby files - for example:
  #
  #   Given /I have (\d+) cucumbers in my belly/ do
  #     # some code here
  #   end
  #
  class StepDefinition
    def self.snippet_text(step_keyword, step_name)
      escaped = Regexp.escape(step_name).gsub('\ ', ' ').gsub('/', '\/')
      param_pattern = /&quot;([^\&quot;]*)&quot;/

      match = escaped.match(param_pattern)
      if match
        n = 0
        block_args = match.captures.map do |a|
          n += 1
          &quot;arg#{n}&quot;
        end
        block_arg_string = &quot; |#{block_args.join(&quot;, &quot;)}|&quot;
      else
        block_arg_string = &quot;&quot;
      end

      escaped = escaped.gsub(param_pattern, '&quot;([^\\&quot;]*)&quot;')
      &quot;#{step_keyword} /^#{escaped}$/ do#{block_arg_string}\n  pending\nend&quot;
    end

    class MissingProc &lt; StandardError
      def message
        &quot;Step definitions must always have a proc&quot;
      end
    end

    include StepDefinitionMethods

    def initialize(pattern, &amp;proc)
      raise MissingProc if proc.nil?
      if String === pattern
        p = pattern.gsub(/\$\w+/, '(.*)') # Replace $var with (.*)
        pattern = Regexp.new(&quot;^#{p}$&quot;) 
      end
      @regexp, @proc = pattern, proc
    end

    def regexp
      @regexp
    end

    def invoke(world, args)
      args = args.map{|arg| Ast::PyString === arg ? arg.to_s : arg}
      begin
        world.cucumber_instance_exec(true, regexp.inspect, *args, &amp;@proc)
      rescue Cucumber::ArityMismatchError =&gt; e
        e.backtrace.unshift(self.backtrace_line)
        raise e
      end
    end

    def file_colon_line
      @proc.file_colon_line
    end
  end
end
</pre>
    </div>