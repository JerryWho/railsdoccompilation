  <div id="fileHeader">
    <h1>rb_step_definition.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/rb_support/rb_step_definition.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:54:52 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'cucumber/step_match'
require 'cucumber/core_ext/string'
require 'cucumber/core_ext/proc'
require 'cucumber/rb_support/regexp_argument_matcher'

module Cucumber
  module RbSupport
    # A Ruby Step Definition holds a Regexp and a Proc, and is created
    # by calling &lt;tt&gt;Given&lt;/tt&gt;, &lt;tt&gt;When&lt;/tt&gt; or &lt;tt&gt;Then&lt;/tt&gt;
    # in the &lt;tt&gt;step_definitions&lt;/tt&gt; ruby files. See also RbDsl.
    #
    # Example:
    #
    #   Given /I have (\d+) cucumbers in my belly/ do
    #     # some code here
    #   end
    #
    class RbStepDefinition

      class MissingProc &lt; StandardError
        def message
          &quot;Step definitions must always have a proc&quot;
        end
      end

      def initialize(rb_language, regexp, proc)
        raise MissingProc if proc.nil?
        if String === regexp
          p = Regexp.escape(regexp)
          p = p.gsub(/\\\$\w+/, '(.*)') # Replace $var with (.*)
          regexp = Regexp.new(&quot;^#{p}$&quot;) 
        end
        @rb_language, @regexp, @proc = rb_language, regexp, proc
        @rb_language.available_step_definition(regexp_source, file_colon_line)
      end

      def regexp_source
        @regexp.inspect
      end

      def ==(step_definition)
        regexp_source == step_definition.regexp_source
      end

      def arguments_from(step_name)
        args = RegexpArgumentMatcher.arguments_from(@regexp, step_name)
        @rb_language.invoked_step_definition(regexp_source, file_colon_line) if args
        args
      end

      def invoke(args)
        args = args.map{|arg| Ast::PyString === arg ? arg.to_s : arg}
        begin
          args = @rb_language.execute_transforms(args)
          @rb_language.current_world.cucumber_instance_exec(true, regexp_source, *args, &amp;@proc)
        rescue Cucumber::ArityMismatchError =&gt; e
          e.backtrace.unshift(self.backtrace_line)
          raise e
        end
      end

      def file_colon_line
        @proc.file_colon_line
      end
    
      def file
        @file ||= file_colon_line.split(':')[0]
      end
    end
  end
end
</pre>
    </div>