  <div id="fileHeader">
    <h1>console.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/formatter/console.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Oct 29 21:26:56 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'cucumber/formatter/ansicolor'
require 'cucumber/formatter/duration'
require 'cucumber/formatter/summary'

module Cucumber
  module Formatter
    # This module contains helper methods that are used by formatters
    # that print output to the terminal.
    module Console
      extend ANSIColor
      include Duration
      include Summary

      FORMATS = Hash.new{|hash, format| hash[format] = method(format).to_proc}

      def format_step(keyword, step_match, status, source_indent)
        comment = if source_indent
          c = (' # ' + step_match.file_colon_line).indent(source_indent)
          format_string(c, :comment)
        else
          ''
        end

        format = format_for(status, :param)
        line = keyword + &quot; &quot; + step_match.format_args(format) + comment
        format_string(line, status)
      end

      def format_string(string, status)
        fmt = format_for(status)
        if Proc === fmt
          fmt.call(string)
        else
          fmt % string
        end
      end

      def print_steps(status)
        print_elements(step_mother.steps(status), status, 'steps')
      end

      def print_elements(elements, status, kind)
        if elements.any?
          @io.puts(format_string(&quot;(::) #{status} #{kind} (::)&quot;, status))
          @io.puts
          @io.flush
        end

        elements.each_with_index do |element, i|
          if status == :failed
            print_exception(element.exception, status, 0)
          else
            @io.puts(format_string(element.backtrace_line, status))
          end
          @io.puts
          @io.flush
        end
      end

      def print_counts
        STDERR.puts(&quot;The #print_counts method is deprecated and will be removed in 0.4. Use #print_stats instead&quot;)
        print_stats(nil)
      end

      def print_stats(features)

        @failures = step_mother.scenarios(:failed).select { |s| s.is_a?(Cucumber::Ast::Scenario) }

        if !@failures.empty?
          @io.puts format_string(&quot;Failing Scenarios:&quot;, :failed)
          @failures.each do |failure|
            @io.puts format_string(&quot;cucumber &quot; + failure.file_colon_line, :failed) +
            format_string(&quot; # Scenario: &quot; + failure.name, :comment)
          end
          @io.puts
        end

        @io.puts scenario_summary(step_mother) {|status_count, status| format_string(status_count, status)}
        @io.puts step_summary(step_mother) {|status_count, status| format_string(status_count, status)}

        @io.puts(format_duration(features.duration)) if features &amp;&amp; features.duration

        @io.flush
      end

      def print_exception(e, status, indent)
        @io.puts(format_string(&quot;#{e.message} (#{e.class})\n#{e.backtrace.join(&quot;\n&quot;)}&quot;.indent(indent), status))
      end

      def print_snippets(options)
        return unless options[:snippets]
        undefined = step_mother.steps(:undefined)
        return if undefined.empty?
        
        unknown_programming_language = step_mother.unknown_programming_language?
        snippets = undefined.map do |step|
          step_name = Undefined === step.exception ? step.exception.step_name : step.name
          step_multiline_class = step.multiline_arg ? step.multiline_arg.class : nil
          snippet = @step_mother.snippet_text(step.actual_keyword, step_name, step_multiline_class)
          snippet
        end.compact.uniq

        text = &quot;\nYou can implement step definitions for undefined steps with these snippets:\n\n&quot;
        text += snippets.join(&quot;\n\n&quot;)
        @io.puts format_string(text, :undefined)

        if unknown_programming_language
          @io.puts format_string(&quot;\nIf you want snippets in a different programming language, just make sure a file\n&quot; +
                  &quot;with the appropriate file extension exists where cucumber looks for step definitions.&quot;, :failed)
        end

        @io.puts
        @io.flush
      end

      def print_passing_wip(options)
        return unless options[:wip]
        passed = step_mother.scenarios(:passed)
        if passed.any?
          @io.puts format_string(&quot;\nThe --wip switch was used, so I didn't expect anything to pass. These scenarios passed:&quot;, :failed)
          print_elements(passed, :passed, &quot;scenarios&quot;)
        else
          @io.puts format_string(&quot;\nThe --wip switch was used, so the failures were expected. All is good.\n&quot;, :passed)
        end
      end

      def print_tag_limit_warnings(options)
        if @tag_occurrences
          first_tag = true
          options[:tag_names].each do |tag_list|
            tag_list.each do |tag_name, limit|
              unless Ast::Tags.exclude_tag?(tag_name)
                tag_frequency = @tag_occurrences[tag_name].size
                if limit &amp;&amp; tag_frequency &gt; limit
                  @io.puts if first_tag
                  first_tag = false
                  @io.puts format_string(&quot;#{tag_name} occurred #{tag_frequency} times, but the limit was set to #{limit}&quot;, :failed)
                  @tag_occurrences[tag_name].each {|location| @io.puts format_string(&quot;  #{location}&quot;, :failed)}
                  @io.flush
                end
              end
            end
          end
        end
      end

      def record_tag_occurrences(feature_element, options)
        @tag_occurrences ||= Hash.new{|k,v| k[v] = []}
        options[:tag_names].each do |tag_list|
          tag_list.each do |tag_name, limit|
            if !Ast::Tags.exclude_tag?(tag_name) &amp;&amp; feature_element.tag_count(tag_name) &gt; 0
              @tag_occurrences[tag_name] &lt;&lt; feature_element.file_colon_line
            end
          end
        end
      end

      def embed(file, mime_type)
        # no-op
      end

      #define @delayed_announcements = [] in your Formatter if you want to
      #activate this feature
      def announce(announcement)
        if @delayed_announcements
          @delayed_announcements &lt;&lt; announcement
        else
          @io.puts
          @io.puts(format_string(announcement, :tag))
          @io.flush
        end
      end

      def print_announcements()
        @delayed_announcements.each {|ann| print_announcement(ann)}
        empty_announcements
      end

      def print_table_row_announcements
        return if @delayed_announcements.empty?
        @io.print(format_string(@delayed_announcements.join(', '), :tag).indent(2))
        @io.flush
        empty_announcements
      end

      def print_announcement(announcement)
        @io.puts(format_string(announcement, :tag).indent(@indent))
        @io.flush
      end

      def empty_announcements
        @delayed_announcements = []
      end

    private

      def format_for(*keys)
        key = keys.join('_').to_sym
        fmt = FORMATS[key]
        raise &quot;No format for #{key.inspect}: #{FORMATS.inspect}&quot; if fmt.nil?
        fmt
      end
    end
  end
end
</pre>
    </div>