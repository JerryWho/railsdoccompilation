  <div id="fileHeader">
    <h1>html.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/formatter/html.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Nov 26 17:02:17 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'cucumber/formatter/ordered_xml_markup'
require 'cucumber/formatter/duration'
require 'cucumber/formatter/summary'

module Cucumber
  module Formatter
    # The formatter used for &lt;tt&gt;--format html&lt;/tt&gt;
    class Html
      include ERB::Util # for the #h method
      include Duration
      include Summary

      def initialize(step_mother, io, options)
        @io = io
        @options = options
        @buffer = {}
        @step_mother = step_mother
        @current_builder = create_builder(@io)
      end
      
      def before_features(features)
        start_buffering :features
      end
      
      def after_features(features)
        stop_buffering :features
        # &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
        builder.declare!(
          :DOCTYPE,
          :html, 
          :PUBLIC, 
          '-//W3C//DTD XHTML 1.0 Strict//EN', 
          'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'
        )
        builder.html(:xmlns =&gt; 'http://www.w3.org/1999/xhtml') do
          builder.head do
            builder.meta(:content =&gt; 'text/html;charset=utf-8')
            builder.title 'Cucumber'
            inline_css
          end
          builder.body do
            builder.div(:class =&gt; 'cucumber') do
              builder &lt;&lt; buffer(:features)
              builder.div(scenario_summary(@step_mother) {|status_count, _| status_count}, :class =&gt; 'summary')
              builder.div(step_summary(@step_mother) {|status_count, _| status_count}, :class =&gt; 'summary')
              builder.div(format_duration(features.duration), :class =&gt; 'duration')
            end
          end
        end
      end
      
      def before_feature(feature)
        start_buffering :feature
        @exceptions = []
      end
      
      def after_feature(feature)
        stop_buffering :feature
        builder.div(:class =&gt; 'feature') do
          builder &lt;&lt; buffer(:feature)
        end
      end

      def before_comment(comment)
        start_buffering :comment
      end

      def after_comment(comment)
        stop_buffering :comment
        builder.pre(:class =&gt; 'comment') do
          builder &lt;&lt; buffer(:comment)
        end
      end

      def comment_line(comment_line)
        builder.text!(comment_line)
        builder.br
      end
      
      def after_tags(tags)
        @tag_spacer = nil
      end
      
      def tag_name(tag_name)
        builder.text!(@tag_spacer) if @tag_spacer
        @tag_spacer = ' '
        builder.span(tag_name, :class =&gt; 'tag')
      end

      def feature_name(name)
        lines = name.split(/\r?\n/)
        return if lines.empty?
        builder.h2 do |h2|
          builder.span(lines[0], :class =&gt; 'val')
        end
        builder.p(:class =&gt; 'narrative') do
          lines[1..-1].each do |line|
            builder.text!(line.strip)
            builder.br
          end
        end
      end

      def before_background(background)
        @in_background = true
        start_buffering :background
      end
      
      def after_background(background)
        stop_buffering :background
        @in_background = nil
        builder.div(:class =&gt; 'background') do
          builder &lt;&lt; buffer(:background)
        end
      end

      def background_name(keyword, name, file_colon_line, source_indent)
        @listing_background = true
        builder.h3 do |h3|
          builder.span(keyword, :class =&gt; 'keyword')
          builder.text!(' ')
          builder.span(name, :class =&gt; 'val')
        end
      end

      def before_feature_element(feature_element)
        start_buffering :feature_element
      end
      
      def after_feature_element(feature_element)
        stop_buffering :feature_element
        css_class = {
          Ast::Scenario        =&gt; 'scenario',
          Ast::ScenarioOutline =&gt; 'scenario outline'
        }[feature_element.class]

        builder.div(:class =&gt; css_class) do
          builder &lt;&lt; buffer(:feature_element)
        end
        @open_step_list = true
      end

      def scenario_name(keyword, name, file_colon_line, source_indent)
        @listing_background = false
        builder.h3 do
          builder.span(keyword, :class =&gt; 'keyword')
          builder.text!(' ')
          builder.span(name, :class =&gt; 'val')
        end
      end
      
      def before_outline_table(outline_table)
        @outline_row = 0
        start_buffering :outline_table
      end
      
      def after_outline_table(outline_table)
        stop_buffering :outline_table
        builder.table do
          builder &lt;&lt; buffer(:outline_table)
        end
        @outline_row = nil
      end

      def before_examples(examples)
        start_buffering :examples
      end
      
      def after_examples(examples)
        stop_buffering :examples
        builder.div(:class =&gt; 'examples') do
          builder &lt;&lt; buffer(:examples)
        end
      end

      def examples_name(keyword, name)
        builder.h4 do
          builder.span(keyword, :class =&gt; 'keyword')
          builder.text!(' ')
          builder.span(name, :class =&gt; 'val')
        end
      end

      def before_steps(steps)
        start_buffering :steps
      end
      
      def after_steps(steps)
        stop_buffering :steps
        builder.ol do
          builder &lt;&lt; buffer(:steps)
        end
      end
      
      def before_step(step)
        @step_id = step.dom_id
      end

      def before_step_result(keyword, step_match, multiline_arg, status, exception, source_indent, background)
        start_buffering :step_result
        @hide_this_step = false
        if exception
          if @exceptions.include?(exception)
            @hide_this_step = true
            return
          end
          @exceptions &lt;&lt; exception
        end
        if status != :failed &amp;&amp; @in_background ^ background
          @hide_this_step = true
          return
        end
        @status = status
      end
      
      def after_step_result(keyword, step_match, multiline_arg, status, exception, source_indent, background)
        stop_buffering :step_result
        return if @hide_this_step
        builder.li(:id =&gt; @step_id, :class =&gt; &quot;step #{status}&quot;) do
          builder &lt;&lt; buffer(:step_result)
        end
      end

      def step_name(keyword, step_match, status, source_indent, background)
        @step_matches ||= []
        background_in_scenario = background &amp;&amp; !@listing_background
        @skip_step = @step_matches.index(step_match) || background_in_scenario
        @step_matches &lt;&lt; step_match
      
        unless @skip_step
          build_step(keyword, step_match, status)
        end
      end

      def exception(exception, status)
        return if @hide_this_step
        builder.pre(format_exception(exception), :class =&gt; status)
      end
      
      def before_multiline_arg(multiline_arg)
        start_buffering :multiline_arg
      end

      def after_multiline_arg(multiline_arg)
        stop_buffering :multiline_arg
        return if @hide_this_step || @skip_step
        if Ast::Table === multiline_arg
          builder.table do
            builder &lt;&lt; buffer(:multiline_arg)
          end
        else
          builder &lt;&lt; buffer(:multiline_arg)
        end
      end

      def py_string(string)
        return if @hide_this_step
        builder.pre(:class =&gt; 'val') do |pre|
          builder &lt;&lt; string.gsub(&quot;\n&quot;, '&amp;#x000A;')
        end
      end

      def before_table_row(table_row)
        @row_id = table_row.dom_id
        @col_index = 0
        start_buffering :table_row
      end
      
      def after_table_row(table_row)
        stop_buffering :table_row
        return if @hide_this_step
        builder.tr(:id =&gt; @row_id) do
          builder &lt;&lt; buffer(:table_row)
        end
        if table_row.exception
          builder.tr do
            builder.td(:colspan =&gt; @col_index.to_s, :class =&gt; 'failed') do
              builder.pre do |pre|
                pre &lt;&lt; format_exception(table_row.exception)
              end
            end
          end
        end
        @outline_row += 1 if @outline_row
      end

      def table_cell_value(value, status)
        return if @hide_this_step
        
        cell_type = @outline_row == 0 ? :th : :td
        attributes = {:id =&gt; &quot;#{@row_id}_#{@col_index}&quot;, :class =&gt; 'val'}
        attributes[:class] += &quot; #{status}&quot; if status
        build_cell(cell_type, value, attributes)
        @col_index += 1
      end

      def announce(announcement)
        builder.pre(announcement, :class =&gt; 'announcement')
      end

      def embed(file, mime_type)
        case(mime_type)
        when /^image\/(png|gif|jpg)/
          embed_image(file)
        end
      end

      private
      
      def embed_image(file)
        id = file.hash
        builder.pre(:class =&gt; 'embed') do |pre|
          pre &lt;&lt; %{&lt;a href=&quot;#&quot; onclick=&quot;img=document.getElementById('#{id}'); img.style.display = (img.style.display == 'none' ? 'block' : 'none');&quot;&gt;Screenshot&lt;/a&gt;
          &lt;img id=&quot;#{id}&quot; style=&quot;display: none&quot; src=&quot;#{file}&quot; /&gt;}
        end
      end

      def build_step(keyword, step_match, status)
        step_name = step_match.format_args(lambda{|param| %{&lt;span class=&quot;param&quot;&gt;#{param}&lt;/span&gt;}})
        builder.div do |div|
          builder.span(keyword, :class =&gt; 'keyword')
          builder.text!(' ')
          builder.span(:class =&gt; 'step val') do |name|
            name &lt;&lt; h(step_name).gsub(/&amp;lt;span class=&amp;quot;(.*?)&amp;quot;&amp;gt;/, '&lt;span class=&quot;\1&quot;&gt;').gsub(/&amp;lt;\/span&amp;gt;/, '&lt;/span&gt;')
          end
        end
      end

      def build_cell(cell_type, value, attributes)
        builder.__send__(cell_type, value, attributes)
      end
      
      def inline_css
        builder.style(:type =&gt; 'text/css') do
          builder.text!(File.read(File.dirname(__FILE__) + '/cucumber.css'))
        end
      end
      
      def format_exception(exception)
        h(([&quot;#{exception.message} (#{exception.class})&quot;] + exception.backtrace).join(&quot;\n&quot;))
      end
      
      def builder
        @current_builder
      end
      
      def buffer(label)
        result = @buffer[label]
        @buffer[label] = ''
        result
      end
      
      def start_buffering(label)
        @buffer[label] ||= ''
        @parent_builder ||= {}
        @parent_builder[label] = @current_builder
        @current_builder = create_builder(@buffer[label])
      end
      
      def stop_buffering(label)
        @current_builder = @parent_builder[label]
      end
      
      def create_builder(io)
        OrderedXmlMarkup.new(:target =&gt; io, :indent =&gt; 0)
      end      
    end
  end
end
</pre>
    </div>