  <div id="fileHeader">
    <h1>html.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/formatter/html.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Dec 16 18:11:50 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'cucumber/formatter/ordered_xml_markup'
require 'cucumber/formatter/duration'
require 'cucumber/formatter/io'

module Cucumber
  module Formatter
    class Html
      include ERB::Util # for the #h method
      include Duration
      include Io

      def initialize(step_mother, path_or_io, options)
        @io = ensure_io(path_or_io, &quot;html&quot;)
        @step_mother = step_mother
        @options = options
        @buffer = {}
        @builder = create_builder(@io)
        @feature_number = 0
        @scenario_number = 0
        @step_number = 0
        @header_red = nil
      end

      def before_features(features)
        @step_count = get_step_count(features)

        # &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
        @builder.declare!(
          :DOCTYPE,
          :html, 
          :PUBLIC, 
          '-//W3C//DTD XHTML 1.0 Strict//EN',
          'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'
        )

        @builder &lt;&lt; '&lt;html xmlns =&quot;http://www.w3.org/1999/xhtml&quot;&gt;'
          @builder.head do
          @builder.meta(:content =&gt; 'text/html;charset=utf-8')
          @builder.title 'Cucumber'
          inline_css
          inline_js
        end
        @builder &lt;&lt; '&lt;body&gt;'
        @builder &lt;&lt; &quot;&lt;!-- Step count #{@step_count}--&gt;&quot;
        @builder &lt;&lt; '&lt;div class=&quot;cucumber&quot;&gt;'
        @builder.div(:id =&gt; 'cucumber-header') do
          @builder.div(:id =&gt; 'label') do
            @builder.h1('Cucumber Features')
          end
          @builder.div(:id =&gt; 'summary') do
            @builder.p('',:id =&gt; 'totals')
            @builder.p('',:id =&gt; 'duration')
          end
        end
      end

      def after_features(features)
        print_stats(features)
        @builder &lt;&lt; '&lt;/div&gt;'
        @builder &lt;&lt; '&lt;/body&gt;'
        @builder &lt;&lt; '&lt;/html&gt;'
      end

      def before_feature(feature)
        @exceptions = []
        @builder &lt;&lt; '&lt;div class=&quot;feature&quot;&gt;'
      end

      def after_feature(feature)
        @builder &lt;&lt; '&lt;/div&gt;'
      end
  
      def before_comment(comment)
        @builder &lt;&lt; '&lt;pre class=&quot;comment&quot;&gt;'
      end

      def after_comment(comment)
        @builder &lt;&lt; '&lt;/pre&gt;'
      end
  
      def comment_line(comment_line)
        @builder.text!(comment_line)
        @builder.br
      end
  
      def after_tags(tags)
        @tag_spacer = nil
      end
  
      def tag_name(tag_name)
        @builder.text!(@tag_spacer) if @tag_spacer
        @tag_spacer = ' '
        @builder.span(tag_name, :class =&gt; 'tag')
      end
  
      def feature_name(name)
        lines = name.split(/\r?\n/)
        return if lines.empty?
        @builder.h2 do |h2|
          @builder.span(lines[0], :class =&gt; 'val')
        end
        @builder.p(:class =&gt; 'narrative') do
          lines[1..-1].each do |line|
            @builder.text!(line.strip)
            @builder.br
          end
        end
      end
  
      def before_background(background)
        @in_background = true
        @builder &lt;&lt; '&lt;div class=&quot;background&quot;&gt;'
      end
  
      def after_background(background)
        @in_background = nil
        @builder &lt;&lt; '&lt;/div&gt;'
      end
  
      def background_name(keyword, name, file_colon_line, source_indent)
        @listing_background = true
        @builder.h3 do |h3|
          @builder.span(keyword, :class =&gt; 'keyword')
          @builder.text!(' ')
          @builder.span(name, :class =&gt; 'val')
        end
      end

      def before_feature_element(feature_element)
        @scenario_number+=1
        @scenario_red = false
        css_class = {
          Ast::Scenario        =&gt; 'scenario',
          Ast::ScenarioOutline =&gt; 'scenario outline'
        }[feature_element.class]      
        @builder &lt;&lt; &quot;&lt;div class='#{css_class}'&gt;&quot;
      end

      def after_feature_element(feature_element)
        @builder &lt;&lt; '&lt;/div&gt;'
        @open_step_list = true
      end

      def scenario_name(keyword, name, file_colon_line, source_indent)
        @listing_background = false
        @builder.h3(:id =&gt; &quot;scenario_#{@scenario_number}&quot;) do
          @builder.span(keyword, :class =&gt; 'keyword')
          @builder.text!(' ')
          @builder.span(name, :class =&gt; 'val')
        end
      end
  
      def before_outline_table(outline_table)
        @outline_row = 0
        @builder &lt;&lt; '&lt;table&gt;'
      end
  
      def after_outline_table(outline_table)
        @builder &lt;&lt; '&lt;/table&gt;'
        @outline_row = nil
      end
      
      def before_examples(examples)
         @builder &lt;&lt; '&lt;div class=&quot;examples&quot;&gt;'
      end
      
      def after_examples(examples)
        @builder &lt;&lt; '&lt;/div&gt;'
      end

      def examples_name(keyword, name)
        @builder.h4 do
          @builder.span(keyword, :class =&gt; 'keyword')
          @builder.text!(' ')
          @builder.span(name, :class =&gt; 'val')
        end
      end
  
      def before_steps(steps)
        @builder &lt;&lt; '&lt;ol&gt;'
      end
  
      def after_steps(steps)
        @builder &lt;&lt; '&lt;/ol&gt;'
      end

      def before_step(step)
        @step_id = step.dom_id
        @step_number += 1
        @step = step
      end

      def after_step(step)
        move_progress
      end

      def before_step_result(keyword, step_match, multiline_arg, status, exception, source_indent, background)
        @step_match = step_match
        @hide_this_step = false
        if exception
          if @exceptions.include?(exception)
            @hide_this_step = true
            return
          end
          @exceptions &lt;&lt; exception
        end
        if status != :failed &amp;&amp; @in_background ^ background
          @hide_this_step = true
          return
        end
        @status = status
        return if @hide_this_step
        set_scenario_color(status)      
        @builder &lt;&lt; &quot;&lt;li id='#{@step_id}' class='step #{status}'&gt;&quot;            
      end

      def after_step_result(keyword, step_match, multiline_arg, status, exception, source_indent, background)
        return if @hide_this_step
        # print snippet for undefined steps
        if status == :undefined
          step_multiline_class = @step.multiline_arg ? @step.multiline_arg.class : nil
          @builder.pre do |pre|
            pre &lt;&lt; @step_mother.snippet_text(keyword,step_match.instance_variable_get(&quot;@name&quot;) || '',step_multiline_class)
          end
        end
        @builder &lt;&lt; '&lt;/li&gt;'
      end

      def step_name(keyword, step_match, status, source_indent, background)
        @step_matches ||= []
        background_in_scenario = background &amp;&amp; !@listing_background
        @skip_step = @step_matches.index(step_match) || background_in_scenario
        @step_matches &lt;&lt; step_match

        unless @skip_step
          build_step(keyword, step_match, status)
        end
      end

      def exception(exception, status)
        build_exception_detail(exception)
      end

      def extra_failure_content(file_colon_line)
        @snippet_extractor ||= SnippetExtractor.new
        &quot;&lt;pre class=\&quot;ruby\&quot;&gt;&lt;code&gt;#{@snippet_extractor.snippet(file_colon_line)}&lt;/code&gt;&lt;/pre&gt;&quot;
      end

      def before_multiline_arg(multiline_arg)
        return if @hide_this_step || @skip_step
        if Ast::Table === multiline_arg
          @builder &lt;&lt; '&lt;table&gt;'
        end
      end
  
      def after_multiline_arg(multiline_arg)
        return if @hide_this_step || @skip_step
        if Ast::Table === multiline_arg
          @builder &lt;&lt; '&lt;/table&gt;'
        end
      end

      def py_string(string)
        return if @hide_this_step
        @builder.pre(:class =&gt; 'val') do |pre|
          @builder &lt;&lt; string.gsub(&quot;\n&quot;, '&amp;#x000A;')
        end
      end
  
  
      def before_table_row(table_row)
        @row_id = table_row.dom_id
        @col_index = 0
        return if @hide_this_step
        @builder &lt;&lt; &quot;&lt;tr class='step' id='#{@row_id}'&gt;&quot;
      end
  
      def after_table_row(table_row)
        return if @hide_this_step
        @builder &lt;&lt; '&lt;/tr&gt;'
        if table_row.exception
          @builder.tr do
            @builder.td(:colspan =&gt; @col_index.to_s, :class =&gt; 'failed') do
              @builder.pre do |pre|
                pre &lt;&lt; format_exception(table_row.exception)
              end
            end
          end
        end
        if @outline_row
          @outline_row += 1
        end
        @step_number += 1
        move_progress
      end

      def table_cell_value(value, status)
        return if @hide_this_step
        
        @cell_type = @outline_row == 0 ? :th : :td
        attributes = {:id =&gt; &quot;#{@row_id}_#{@col_index}&quot;, :class =&gt; 'step'}
        attributes[:class] += &quot; #{status}&quot; if status
        build_cell(@cell_type, value, attributes)
        set_scenario_color(status)
        @col_index += 1
      end

      def announce(announcement)
        @builder.pre(announcement, :class =&gt; 'announcement')
      end

      protected

        def build_exception_detail(exception)
          backtrace = Array.new
          @builder.div(:class =&gt; 'message') do
            message = exception.message
            if defined?(RAILS_ROOT) &amp;&amp; message.include?('Exception caught')
              matches = message.match(/Showing &lt;i&gt;(.+)&lt;\/i&gt;(?:.+)#(\d+)/)
              backtrace += [&quot;#{RAILS_ROOT}/#{matches[1]}:#{matches[2]}&quot;]
              message = message.match(/&lt;code&gt;([^(\/)]+)&lt;\//m)[1]
            end
            @builder.pre do 
              @builder.text!(message)
            end
          end
          @builder.div(:class =&gt; 'backtrace') do
            @builder.pre do
              backtrace = exception.backtrace
              backtrace.delete_if { |x| x =~ /\/gems\/(cucumber|rspec)/ }
              @builder &lt;&lt; backtrace_line(backtrace.join(&quot;\n&quot;))
            end
          end
          extra = extra_failure_content(backtrace)
          @builder &lt;&lt; extra unless extra == &quot;&quot;
        end

        def set_scenario_color(status)
          if status == :undefined
            @builder.script do
              @builder.text!(&quot;makeYellow('cucumber-header');&quot;) unless @header_red
              @builder.text!(&quot;makeYellow('scenario_#{@scenario_number}');&quot;) unless @scenario_red
            end 
          end
          if status == :failed
            @builder.script do
              @builder.text!(&quot;makeRed('cucumber-header');&quot;) unless @header_red
              @header_red = true
              @builder.text!(&quot;makeRed('scenario_#{@scenario_number}');&quot;) unless @scenario_red
              @scenario_red = true
            end
          end
        end

        def get_step_count(features)
          count = 0
          features = features.instance_variable_get(&quot;@features&quot;)
          features.each do |feature|
            #get background steps
            if feature.instance_variable_get(&quot;@background&quot;)
              background = feature.instance_variable_get(&quot;@background&quot;).instance_variable_get(&quot;@steps&quot;).instance_variable_get(&quot;@steps&quot;)
              count += background.size
            end
            #get scenarios
            feature.instance_variable_get(&quot;@feature_elements&quot;).each do |scenario|
              #get steps
              steps = scenario.instance_variable_get(&quot;@steps&quot;).instance_variable_get(&quot;@steps&quot;)
              count += steps.size

              #get example table
              examples = scenario.instance_variable_get(&quot;@examples_array&quot;)
              unless examples.nil?
                examples.each do |example|
                  example_matrix = example.instance_variable_get(&quot;@outline_table&quot;).instance_variable_get(&quot;@cell_matrix&quot;)
                  count += example_matrix.size
                end
              end

              #get multiline step tables
              steps.each do |step|
                multi_arg = step.instance_variable_get(&quot;@multiline_arg&quot;)
                next if multi_arg.nil?
                matrix = multi_arg.instance_variable_get(&quot;@cell_matrix&quot;)
                count += matrix.size unless matrix.nil?
              end
            end
          end
          return count
        end

        def build_step(keyword, step_match, status)
          step_name = step_match.format_args(lambda{|param| %{&lt;span class=&quot;param&quot;&gt;#{param}&lt;/span&gt;}})
          @builder.div do |div|
            @builder.span(keyword, :class =&gt; 'keyword')
            @builder.text!(' ')
            @builder.span(:class =&gt; 'step val') do |name|
              name &lt;&lt; h(step_name).gsub(/&amp;lt;span class=&amp;quot;(.*?)&amp;quot;&amp;gt;/, '&lt;span class=&quot;\1&quot;&gt;').gsub(/&amp;lt;\/span&amp;gt;/, '&lt;/span&gt;')
            end
          end
        end

        def build_cell(cell_type, value, attributes)
          @builder.__send__(cell_type, attributes) do
            @builder.div do
              @builder.span(value,:class =&gt; 'step param')
            end
          end
        end

        def inline_css
          @builder.style(:type =&gt; 'text/css') do
            @builder &lt;&lt; File.read(File.dirname(__FILE__) + '/cucumber.css')
          end
        end

        def inline_js
          @builder.script(:type =&gt; 'text/javascript') do
            @builder &lt;&lt; inline_js_content
          end
        end

        def inline_js_content
          &lt;&lt;-EOF
      function moveProgressBar(percentDone) {
      document.getElementById(&quot;cucumber-header&quot;).style.width = percentDone +&quot;%&quot;;
      }
      function makeRed(element_id) {
      document.getElementById(element_id).style.background = '#C40D0D';
      document.getElementById(element_id).style.color = '#FFFFFF';
      }

      function makeYellow(element_id) {
      document.getElementById(element_id).style.background = '#FAF834';
      document.getElementById(element_id).style.color = '#000000';
      }
      EOF
        end

        def move_progress
          @builder &lt;&lt; &quot; &lt;script type=\&quot;text/javascript\&quot;&gt;moveProgressBar('#{percent_done}');&lt;/script&gt;&quot;
        end

        def percent_done
          result = 100.0
          if @step_count != 0
            result = ((@step_number).to_f / @step_count.to_f * 1000).to_i / 10.0
          end
          result
        end

        def format_exception(exception)
          ([&quot;#{exception.message}&quot;] + exception.backtrace).join(&quot;\n&quot;)
        end

        def backtrace_line(line)
          line.gsub(/^([^:]*\.(?:rb|feature|haml)):(\d*)/) do
            if ENV['TM_PROJECT_DIRECTORY']
              &quot;&lt;a href=\&quot;txmt://open?url=file://#{File.expand_path($1)}&amp;line=#{$2}\&quot;&gt;#{$1}:#{$2}&lt;/a&gt; &quot;
            else
              line
            end
          end
        end

        def print_stats(features)
          @builder &lt;&lt;  &quot;&lt;script type=\&quot;text/javascript\&quot;&gt;document.getElementById('duration').innerHTML = \&quot;Finished in &lt;strong&gt;#{format_duration(features.duration)} seconds&lt;/strong&gt;\&quot;;&lt;/script&gt;&quot;
          @builder &lt;&lt;  &quot;&lt;script type=\&quot;text/javascript\&quot;&gt;document.getElementById('totals').innerHTML = \&quot;#{print_stat_string(features)}\&quot;;&lt;/script&gt;&quot;
        end

        def print_stat_string(features)
          string = String.new
          string &lt;&lt; dump_count(@step_mother.scenarios.length, &quot;scenario&quot;)
          scenario_count = print_status_counts{|status| @step_mother.scenarios(status)}
          string &lt;&lt; scenario_count if scenario_count
          string &lt;&lt; &quot;&lt;br /&gt;&quot;
          string &lt;&lt; dump_count(@step_mother.steps.length, &quot;step&quot;)
          step_count = print_status_counts{|status| @step_mother.steps(status)}
          string &lt;&lt; step_count if step_count
        end

        def print_status_counts
          counts = [:failed, :skipped, :undefined, :pending, :passed].map do |status|
            elements = yield status
            elements.any? ? &quot;#{elements.length} #{status.to_s}&quot; : nil
          end.compact
          return &quot; (#{counts.join(', ')})&quot; if counts.any?
        end

        def dump_count(count, what, state=nil)
          [count, state, &quot;#{what}#{count == 1 ? '' : 's'}&quot;].compact.join(&quot; &quot;)
        end

        def create_builder(io)
          OrderedXmlMarkup.new(:target =&gt; io, :indent =&gt; 0)
        end
    end
  end
end


class SnippetExtractor #:nodoc:
  class NullConverter; def convert(code, pre); code; end; end #:nodoc:
  begin; require 'syntax/convertors/html'; @@converter = Syntax::Convertors::HTML.for_syntax &quot;ruby&quot;; rescue LoadError =&gt; e; @@converter = NullConverter.new; end

  def snippet(error)
    raw_code, line = snippet_for(error[0])
    highlighted = @@converter.convert(raw_code, false)
    highlighted &lt;&lt; &quot;\n&lt;span class=\&quot;comment\&quot;&gt;# gem install syntax to get syntax highlighting&lt;/span&gt;&quot; if @@converter.is_a?(NullConverter)
    post_process(highlighted, line)
  end

  def snippet_for(error_line)
    if error_line =~ /(.*):(\d+)/
      file = $1
      line = $2.to_i
      [lines_around(file, line), line]
    else
      return snippet_for()
      [&quot;# Couldn't get snippet for #{error_line}&quot;, 1]
    end
  end

  def lines_around(file, line)
    if File.file?(file)
      lines = File.open(file).read.split(&quot;\n&quot;)
      min = [0, line-3].max
      max = [line+1, lines.length-1].min
      selected_lines = []
      selected_lines.join(&quot;\n&quot;)
      lines[min..max].join(&quot;\n&quot;)
    else
      &quot;# Couldn't get snippet for #{file}&quot;
    end
  end

  def post_process(highlighted, offending_line)
    new_lines = []
    highlighted.split(&quot;\n&quot;).each_with_index do |line, i|
      new_line = &quot;&lt;span class=\&quot;linenum\&quot;&gt;#{offending_line+i-2}&lt;/span&gt;#{line}&quot;
      new_line = &quot;&lt;span class=\&quot;offending\&quot;&gt;#{new_line}&lt;/span&gt;&quot; if i == 2
      new_lines &lt;&lt; new_line
    end
    new_lines.join(&quot;\n&quot;)
  end

end</pre>
    </div>