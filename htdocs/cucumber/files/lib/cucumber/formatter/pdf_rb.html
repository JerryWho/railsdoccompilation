  <div id="fileHeader">
    <h1>pdf.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/formatter/pdf.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Nov 26 17:02:17 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'cucumber/formatter/console'
require 'fileutils'
require 'prawn'
require &quot;prawn/layout&quot;
require &quot;prawn/format&quot;

module Cucumber
  module Formatter

    BLACK = '000000'
    GREY = '999999'

    class Pdf
      include FileUtils
      include Console
      attr_writer :indent

      def initialize(step_mother, io, options)
        @step_mother = step_mother
        raise &quot;You *must* specify --out FILE for the pdf formatter&quot; unless File === io

        if(options[:dry_run])
          @status_colors = { :passed =&gt; BLACK, :skipped =&gt; BLACK, :undefined =&gt; BLACK, :failed =&gt; BLACK}
        else
          @status_colors = { :passed =&gt; '055902', :skipped =&gt; GREY, :undefined =&gt; 'F27405', :failed =&gt; '730202'}
        end

        @pdf = Prawn::Document.new
        @scrap = Prawn::Document.new
        @doc = @scrap
        @io = io
        @options = options
        @exceptions = []
        @indent = 0
        @buffer = []
        puts &quot;writing to #{io.path}&quot;
        load_cover_page_image
        @pdf.text &quot;\n\n\nCucumber features&quot;, :align =&gt; :center, :size =&gt; 32
        @pdf.text &quot;Generated: #{Time.now.strftime(&quot;%Y-%m-%d %H:%M&quot;)}&quot;, :size =&gt; 10, :at =&gt; [0, 24]
        @pdf.text &quot;Command: &lt;code&gt;cucumber #{ARGV.join(&quot; &quot;)}&lt;/code&gt;&quot;, :size =&gt; 10, :at =&gt; [0,10]
        unless options[:dry_run]
          @pdf.bounding_box [450,100] , :width =&gt; 100 do  
            @pdf.text 'Legend', :size =&gt; 10
            @status_colors.each do |k,v|
              @pdf.fill_color v
              @pdf.text k.to_s, :size =&gt; 10
              @pdf.fill_color BLACK
            end
          end
        end
      end

      def load_cover_page_image()
        if (!load_image(&quot;features/support/logo.png&quot;))
          load_image(&quot;features/support/logo.jpg&quot;)
        end
      end

      def load_image(image_path)
        begin
          @pdf.image open(image_path, &quot;rb&quot;), :position =&gt; :center, :width =&gt; 500
          true
        rescue Errno::ENOENT
          false
        end
      end

      def after_features(features)
        @pdf.render_file(@io.path)
        puts &quot;\ndone&quot;
      end

      def feature_name(name)
        @pdf.start_new_page
        name[&quot;Feature:&quot;] = &quot;&quot; if name[&quot;Feature:&quot;]
        names = name.split(&quot;\n&quot;)
        @pdf.fill_color GREY
        @pdf.text('Feature', :align =&gt; :center)
        @pdf.fill_color BLACK
        names.each_with_index do |nameline, i|
          case i
          when 0
            @pdf.text(nameline.strip, :size =&gt; 30, :align =&gt; :center )
            @pdf.text(&quot;\n&quot;)
          else
            @pdf.text(nameline.strip, :size =&gt; 12)
          end
        end
        @pdf.move_down(30)
      end

      def before_feature_element(feature_element)
        record_tag_occurrences(feature_element, @options)
      end
      
      def after_feature_element(feature_element)
        flush
      end

      def after_feature(feature)
        flush
      end

      def feature_element_name(keyword, name)
        names = name.empty? ? [name] : name.split(&quot;\n&quot;)
        print &quot;.&quot;
        STDOUT.flush

        keep_with do
          @doc.move_down(20)
          @doc.fill_color GREY
          @doc.text(&quot;#{keyword}&quot;, :size =&gt; 8)
          @doc.fill_color BLACK
          @doc.text(&quot;#{names[0]}&quot;, :size =&gt; 16)
          names[1..-1].each { |s| @doc.text(s, :size =&gt; 12) }
          @doc.text(&quot;\n&quot;)
        end
      end

      def step_result(keyword, step_match, multiline_arg, status, exception, source_indent, background)
        @hide_this_step = false
        if exception
          if @exceptions.include?(exception)
            @hide_this_step = true
            return
          end
          @exceptions &lt;&lt; exception
        end
        if status != :failed &amp;&amp; @in_background ^ background
          @hide_this_step = true
          return
        end
      end

      def step_name(keyword, step_match, status, source_indent, background)
        return if @hide_this_step
        line = &quot;&lt;b&gt;#{keyword}&lt;/b&gt; #{step_match.format_args(&quot;%s&quot;).gsub('&lt;', '&amp;lt;').gsub('&gt;', '&amp;gt;')}&quot;
        colorize(line, status)
      end

      def before_background(background)
        @in_background = true
      end

      def after_background(background)
        @in_background = nil
      end

      def before_multiline_arg(table)
        return if @hide_this_step
        if(table.kind_of? Cucumber::Ast::Table)
          keep_with do
            @doc.table(table.rows &lt;&lt; table.headers , :position =&gt; :center, :row_colors =&gt; ['ffffff', 'f0f0f0'])
          end
        end
      end

      #using row_color hack to highlight each row correctly
      def before_outline_table(table)
        return if @hide_this_step
        row_colors = table.example_rows.map { |r| @status_colors[r.status] unless r.status == :skipped}
        keep_with do
          @doc.table(table.rows, :headers =&gt; table.headers, :position =&gt; :center, :row_colors =&gt; row_colors)
        end
      end

      def before_py_string(string)
        return if @hide_this_step
        s = %{&quot;&quot;&quot;\n#{string}\n&quot;&quot;&quot;}.indent(10)
        s = s.split(&quot;\n&quot;).map{|l| l =~ /^\s+$/ ? '' : l}
        s.each do |line|
          line.gsub!('&lt;', '&amp;lt;')
          line.gsub!('&gt;', '&amp;gt;')
          keep_with { @doc.text line, :size =&gt; 8 }
        end
      end

      def tag_name(tag_name)
        return if @hide_this_step
        tag = format_string(tag_name, :tag).indent(@indent)
        # TODO should we render tags at all? skipped for now. difficult to place due to page breaks
      end

      def background_name(keyword, name, file_colon_line, source_indent)
        feature_element_name(keyword, name)
      end

      def examples_name(keyword, name)
        feature_element_name(keyword, name)
      end

      def scenario_name(keyword, name, file_colon_line, source_indent)
        feature_element_name(keyword, name)
      end
      
      private
      
      def colorize(text, status)
        keep_with do
          @doc.fill_color(@status_colors[status] || BLACK)
          @doc.text(text)
          @doc.fill_color(BLACK)
        end
      end
      
      def keep_with(&amp;block)
        @buffer &lt;&lt; block
      end

      def render(doc)
        @doc = doc
        @buffer.each do |proc|
          proc.call
        end
      end

      # This method does a 'test' rendering on a blank page, to see the rendered height of the buffer
      # if that too high for the space left on the age in the real document, we do a page break.
      # This obviously doesn't work if a scenario is longer than a whole page (God forbid)
      def flush
        @scrap.start_new_page
        oldy = @scrap.y
        render @scrap
        height = (oldy - @scrap.y) + 36 # whops magic number
        if ((@pdf.y - height) &lt; @pdf.bounds.bottom)
          @pdf.start_new_page
        end
        render @pdf
        @pdf.move_down(20)
        @buffer = []
      end
    end
  end
end
</pre>
    </div>