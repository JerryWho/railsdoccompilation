  <div id="fileHeader">
    <h1>json.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/cucumber/formatter/json.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 18:21:09 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;json&quot;
require &quot;cucumber/formatter/io&quot;

module Cucumber
  module Formatter
    # The formatter used for &lt;tt&gt;--format json&lt;/tt&gt;
    class Json
      class Error &lt; StandardError
      end

      include Io

      def initialize(step_mother, io, options)
        @io      = ensure_io(io, &quot;json&quot;)
        @options = options
      end

      def before_features(features)
        @json = {:features =&gt; []}
      end

      def before_feature(feature)
        @current_object = {:file =&gt; feature.file, :name =&gt; feature.name}
        @json[:features] &lt;&lt; @current_object
      end

      def before_tags(tags)
        @current_object[:tags] = tags.tag_names.to_a
      end

      def before_background(background)
        background = {}
        @current_object[:background] = background
        @current_object = background
      end

      def after_background(background)
        @current_object = last_feature
      end

      def before_feature_element(feature_element)
        elements = @current_object[:elements] ||= []

        # change current object to the feature_element
        @current_object = {}
        elements &lt;&lt; @current_object
      end

      def scenario_name(keyword, name, file_colon_line, source_indent)
        @current_object[:keyword] = keyword
        @current_object[:name] = name
        @current_object[:file_colon_line] = file_colon_line
      end

      def before_steps(steps)
        @current_object[:steps] = []
      end

      def before_step(step)
        @current_step = {}
        @current_object[:steps] &lt;&lt; @current_step
      end

      def before_step_result(keyword, step_match, multiline_arg, status, exception, source_indent, background)
        if exception
          @current_step[:exception] = exception_hash_for(exception)
        end
      end

      def step_name(keyword, step_match, status, source_indent, background)
        @current_step[:status]          = status
        @current_step[:keyword]         = keyword
        @current_step[:name]            = &quot;#{step_match.name || step_match.format_args}&quot;
        @current_step[:file_colon_line] = step_match.file_colon_line
      end

      def after_step(step)
        @current_step = nil
      end

      def before_examples(examples)
        @current_object[:examples] = {}
      end

      def examples_name(keyword, name)
        @current_object[:examples][:name] = &quot;#{keyword} #{name}&quot;
      end

      def before_outline_table(*args)
        @current_object[:examples][:table] = []
      end

      def before_table_row(row)
        @current_row = {:cells =&gt; []}

        if @current_object.member? :examples
          @current_object[:examples][:table] &lt;&lt; @current_row
        elsif @current_step
          (@current_step[:table] ||= []) &lt;&lt; @current_row
        else
          internal_error
        end
      end

      def table_cell_value(value, status)
        @current_row[:cells] &lt;&lt; {:text =&gt; value, :status =&gt; status}
      end

      def after_table_row(row)
        if row.exception
          @current_row[:exception] = exception_hash_for(row.exception)
        end
        @current_row = nil
      end

      def py_string(string)
        @current_step[:py_string] = string
      end

      def after_feature_element(feature_element)
        # change current object back to the last feature
        @current_object = last_feature
      end

      def after_features(features)
        @io.write json_string
        @io.flush
      end

      def embed(file, mime_type)
        obj = @current_step || @current_object
        obj[:embedded] ||= []

        obj[:embedded] &lt;&lt; {
          :file      =&gt; file,
          :mime_type =&gt; mime_type,
          :data      =&gt; [File.read(file)].pack(&quot;m*&quot;) # base64
        }
      end

      private

      def json_string
        @json.to_json
      end

      def last_feature
        @json[:features].last
      end

      def exception_hash_for(e)
        {
          :class     =&gt; e.class.name,
          :message   =&gt; e.message,
          :backtrace =&gt; e.backtrace
        }
      end

      def internal_error
        raise Error, &quot;you've found a bug in the JSON formatter!&quot;
      end

    end # Json
  end # Formatter
end # Cucumber

</pre>
    </div>