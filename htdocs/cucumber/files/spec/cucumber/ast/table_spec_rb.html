  <div id="fileHeader">
    <h1>table_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/cucumber/ast/table_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Oct 29 21:26:56 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># encoding: utf-8
require File.dirname(__FILE__) + '/../../spec_helper'
require 'cucumber/ast/table'

module Cucumber
  module Ast
    describe Table do
      before do
        @table = Table.new([
          %w{one four seven},
          %w{4444 55555 666666}
        ])
        def @table.cells_rows; super; end
        def @table.columns; super; end
      end

      it &quot;should have rows&quot; do
        @table.cells_rows[0].map{|cell| cell.value}.should == %w{one four seven}
      end

      it &quot;should have columns&quot; do
        @table.columns[1].map{|cell| cell.value}.should == %w{four 55555}
      end

      it &quot;should have headers&quot; do
        @table.headers.should == %w{one four seven}
      end

      it &quot;should have same cell objects in rows and columns&quot; do
        # 666666
        @table.cells_rows[1].__send__(:[], 2).should equal(@table.columns[2].__send__(:[], 1))
      end

      it &quot;should know about max width of a row&quot; do
        @table.columns[1].__send__(:width).should == 5
      end

      it &quot;should be convertible to an array of hashes&quot; do
        @table.hashes.should == [
          {'one' =&gt; '4444', 'four' =&gt; '55555', 'seven' =&gt; '666666'}
        ]
      end

      it &quot;should accept symbols as keys for the hashes&quot; do
        @table.hashes.first[:one].should == '4444'
      end

      it &quot;should allow map'ing columns&quot; do
        @table.map_column!('one') { |v| v.to_i }
        @table.hashes.first['one'].should == 4444
      end

      it &quot;should pass silently if a mapped column does not exist in non-strict mode&quot; do
        lambda {
          @table.map_column!('two', false) { |v| v.to_i }
        }.should_not raise_error
      end

      it &quot;should fail if a mapped column does not exist in strict mode&quot; do
        lambda {
          @table.map_column!('two', true) { |v| v.to_i }
        }.should raise_error('The column named &quot;two&quot; does not exist')
      end

      describe &quot;#match&quot; do
        before(:each) do
          @table = Table.new([
            %w{one four seven},
            %w{4444 55555 666666}
          ])
        end
          
        it &quot;returns nil if headers do not match&quot; do
          @table.match('does,not,match').should be_nil
        end
        it &quot;requires a table: prefix on match&quot; do
          @table.match('table:one,four,seven').should_not be_nil
        end
        it &quot;does not match if no table: prefix on match&quot; do
          @table.match('one,four,seven').should be_nil
        end
      end
      describe &quot;#transpose&quot; do
        before(:each) do
          @table = Table.new([
            %w{one 1111},
            %w{two 22222}
          ])
        end
                
        it &quot;should be convertible in to an array where each row is a hash&quot; do 
          @table.transpose.hashes[0].should == {'one' =&gt; '1111', 'two' =&gt; '22222'}
        end
      end
      
      describe &quot;#rows_hash&quot; do
                
        it &quot;should return a hash of the rows&quot; do
          table = Table.new([
            %w{one 1111},
            %w{two 22222}
          ])
          table.rows_hash.should == {'one' =&gt; '1111', 'two' =&gt; '22222'}
        end

        it &quot;should fail if the table doesn't have two columns&quot; do
          faulty_table = Table.new([
            %w{one 1111 abc},
            %w{two 22222 def}
          ])
          lambda {
            faulty_table.rows_hash
          }.should raise_error('The table must have exactly 2 columns')
        end
      end

      describe '#map_headers' do
        it &quot;renames the columns to the specified values in the provided hash&quot; do
          table2 = @table.map_headers('one' =&gt; :three)
          table2.hashes.first[:three].should == '4444'
        end

        it &quot;allows renaming columns using regexp&quot; do
          table2 = @table.map_headers(/one|uno/ =&gt; :three)
          table2.hashes.first[:three].should == '4444'
        end

        it &quot;copies column mappings&quot; do
          @table.map_column!('one') { |v| v.to_i }
          table2 = @table.map_headers('one' =&gt; 'three')
          table2.hashes.first['three'].should == 4444
        end

        it &quot;takes a block and operates on all the headers with it&quot; do
          table = Table.new([
          ['HELLO', 'WORLD'],
          %w{4444 55555}
          ])

          table.map_headers! do |header|
            header.downcase
          end

          table.hashes.first.keys.should =~ %w[hello world]
        end

        it &quot;treats the mappings in the provided hash as overrides when used with a block&quot; do
          table = Table.new([
          ['HELLO', 'WORLD'],
          %w{4444 55555}
          ])

          table.map_headers!('WORLD' =&gt; 'foo') do |header|
            header.downcase
          end

          table.hashes.first.keys.should =~ %w[hello foo]
        end

      end

      describe &quot;replacing arguments&quot; do

        before(:each) do
          @table = Table.new([
            %w{qty book},
            %w{&lt;qty&gt; &lt;book&gt;}
          ])
        end

        it &quot;should return a new table with arguments replaced with values&quot; do
          table_with_replaced_args = @table.arguments_replaced({'&lt;book&gt;' =&gt; 'Unbearable lightness of being', '&lt;qty&gt;' =&gt; '5'})

          table_with_replaced_args.hashes[0]['book'].should == 'Unbearable lightness of being'
          table_with_replaced_args.hashes[0]['qty'].should == '5'
        end

        it &quot;should recognise when entire cell is delimited&quot; do
          @table.should have_text('&lt;book&gt;')
        end

        it &quot;should recognise when just a subset of a cell is delimited&quot; do
          table = Table.new([
            %w{qty book},
            [nil, &quot;This is &lt;who&gt;'s book&quot;]
          ])
          table.should have_text('&lt;who&gt;')
        end

        it &quot;should replace nil values with nil&quot; do
          table_with_replaced_args = @table.arguments_replaced({'&lt;book&gt;' =&gt; nil})

          table_with_replaced_args.hashes[0]['book'].should == nil
        end

        it &quot;should preserve values which don't match a placeholder when replacing with nil&quot; do
          table = Table.new([
                              %w{book},
                              %w{cat}
                            ])
          table_with_replaced_args = table.arguments_replaced({'&lt;book&gt;' =&gt; nil})
          
          table_with_replaced_args.hashes[0]['book'].should == 'cat'
        end

        it &quot;should not change the original table&quot; do
          @table.arguments_replaced({'&lt;book&gt;' =&gt; 'Unbearable lightness of being'})

          @table.hashes[0]['book'].should_not == 'Unbearable lightness of being'
        end

        it &quot;should not raise an error when there are nil values in the table&quot; do
          table = Table.new([
                              ['book', 'qty'],
                              ['&lt;book&gt;', nil],
                            ])
          lambda{ 
            table.arguments_replaced({'&lt;book&gt;' =&gt; nil, '&lt;qty&gt;' =&gt; '5'})
          }.should_not raise_error
        end

      end
      
      describe &quot;diff!&quot; do
        it &quot;should detect a complex diff&quot; do
          t1 = table(%{
            | 1         | 22          | 333         | 4444         |
            | 55555     | 666666      | 7777777     | 88888888     |
            | 999999999 | 0000000000  | 01010101010 | 121212121212 |
            | 4000      | ABC         | DEF         | 50000        |
          })
          
          t2 = table(%{
            | a     | 4444     | 1         | 
            | bb    | 88888888 | 55555     | 
            | ccc   | xxxxxxxx | 999999999 | 
            | dddd  | 4000     | 300       |
            | e     | 50000    | 4000      |
          })
          lambda{t1.diff!(t2)}.should raise_error
          t1.to_s(:indent =&gt; 12, :color =&gt; false).should == %{
            |     1         | (-) 22         | (-) 333         |     4444         | (+) a    |
            |     55555     | (-) 666666     | (-) 7777777     |     88888888     | (+) bb   |
            | (-) 999999999 | (-) 0000000000 | (-) 01010101010 | (-) 121212121212 | (+)      |
            | (+) 999999999 | (+)            | (+)             | (+) xxxxxxxx     | (+) ccc  |
            | (+) 300       | (+)            | (+)             | (+) 4000         | (+) dddd |
            |     4000      | (-) ABC        | (-) DEF         |     50000        | (+) e    |
          }
        end

        it &quot;should not change table when diffed with identical&quot; do
          t = table(%{
            |a|b|c|
            |d|e|f|
            |g|h|i|
          })
          t.diff!(t.dup)
          t.to_s(:indent =&gt; 12, :color =&gt; false).should == %{
            |     a |     b |     c |
            |     d |     e |     f |
            |     g |     h |     i |
          }
        end

        it &quot;should inspect missing and surplus cells&quot; do
          t1 = Table.new([
            ['name',  'male', 'lastname', 'swedish'],
            ['aslak', 'true', 'hellesøy', 'false']
          ])
          t2 = Table.new([
            ['name',  'male', 'lastname', 'swedish'],
            ['aslak', true,   'hellesøy', false]
          ])
          lambda{t1.diff!(t2)}.should raise_error
          t1.to_s(:indent =&gt; 12, :color =&gt; false).should == %{
            |     name  |     male       |     lastname |     swedish     |
            | (-) aslak | (-) (i) &quot;true&quot; | (-) hellesøy | (-) (i) &quot;false&quot; |
            | (+) aslak | (+) (i) true   | (+) hellesøy | (+) (i) false   |
          }
        end

        it &quot;should allow column mapping of target before diffing&quot; do
          t1 = Table.new([
            ['name',  'male'],
            ['aslak', 'true']
          ])
          t1.map_column!('male') { |m| m == 'true' }
          t2 = Table.new([
            ['name',  'male'],
            ['aslak', true]
          ])
          t1.diff!(t2)
          t1.to_s(:indent =&gt; 12, :color =&gt; false).should == %{
            |     name  |     male |
            |     aslak |     true |
          }
        end

        it &quot;should allow column mapping of argument before diffing&quot; do
          t1 = Table.new([
            ['name',  'male'],
            ['aslak', true]
          ])
          t1.map_column!('male') { 
            'true'
          }
          t2 = Table.new([
            ['name',  'male'],
            ['aslak', 'true']
          ])
          t2.diff!(t1)
          t1.to_s(:indent =&gt; 12, :color =&gt; false).should == %{
            |     name  |     male |
            |     aslak |     true |
          }
        end

        it &quot;should allow header mapping before diffing&quot; do
          t1 = Table.new([
            ['Name',  'Male'],
            ['aslak', 'true']
          ])
          t1.map_headers!('Name' =&gt; 'name', 'Male' =&gt; 'male')
          t1.map_column!('male') { |m| m == 'true' }
          t2 = Table.new([
            ['name',  'male'],
            ['aslak', true]
          ])
          t1.diff!(t2)
          t1.to_s(:indent =&gt; 12, :color =&gt; false).should == %{
            |     name  |     male |
            |     aslak |     true |
          }
        end

        it &quot;should not allow mappings that match more than 1 column&quot; do
          t1 = Table.new([
            ['Cuke',  'Duke'],
            ['Foo', 'Bar']
          ])
          lambda do
            t1.map_headers!(/uk/ =&gt; 'u')
          end.should raise_error(%{2 headers matched /uk/: [&quot;Cuke&quot;, &quot;Duke&quot;]})
        end
        
        describe &quot;raising&quot; do
          before do
            @t = table(%{
              | a | b |
              | c | d |
            })
          end
          
          it &quot;should raise on missing rows&quot; do
            t = table(%{
              | a | b |
            })
            lambda { @t.dup.diff!(t) }.should raise_error
            lambda { @t.dup.diff!(t, :missing_row =&gt; false) }.should_not raise_error
          end

          it &quot;should raise on surplus rows&quot; do
            t = table(%{
              | a | b |
              | c | d |
              | e | f |
            })
            lambda { @t.dup.diff!(t) }.should raise_error
            lambda { @t.dup.diff!(t, :surplus_row =&gt; false) }.should_not raise_error
          end

          it &quot;should raise on missing columns&quot; do
            t = table(%{
              | a |
              | c |
            })
            lambda { @t.dup.diff!(t) }.should raise_error
            lambda { @t.dup.diff!(t, :missing_col =&gt; false) }.should_not raise_error
          end

          it &quot;should not raise on surplus columns&quot; do
            t = table(%{
              | a | b | x |
              | c | d | y |
            })
            lambda { @t.dup.diff!(t) }.should_not raise_error
            lambda { @t.dup.diff!(t, :surplus_col =&gt; true) }.should raise_error
          end
        end

        def table(text, file=nil, line_offset=0)
          @table_parser ||= Parser::TableParser.new
          @table_parser.parse_or_fail(text.strip, file, line_offset)
        end
      end

      describe &quot;#new&quot; do
        it &quot;should allow Array of Hash&quot; do
          t1 = Table.new([{'name' =&gt; 'aslak', 'male' =&gt; 'true'}])
          t1.to_s(:indent =&gt; 12, :color =&gt; false).should == %{
            |     name  |     male |
            |     aslak |     true |
          }
        end
      end

      it &quot;should convert to sexp&quot; do
        @table.to_sexp.should == 
          [:table, 
            [:row, -1,
              [:cell, &quot;one&quot;], 
              [:cell, &quot;four&quot;],
              [:cell, &quot;seven&quot;]
            ],
            [:row, -1,
              [:cell, &quot;4444&quot;], 
              [:cell, &quot;55555&quot;],
              [:cell, &quot;666666&quot;]]]
      end
    end
  end
end
</pre>
    </div>