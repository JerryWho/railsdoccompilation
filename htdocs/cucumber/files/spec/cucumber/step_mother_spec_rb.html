  <div id="fileHeader">
    <h1>step_mother_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/cucumber/step_mother_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:58:05 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../spec_helper'

require 'cucumber'
require 'cucumber/rb_support/rb_language'

module Cucumber
  describe StepMother do
    before do
      @dsl = Object.new
      @dsl.extend(RbSupport::RbDsl)

      @step_mother = StepMother.new
      @step_mother.load_natural_language('en')
      @rb = @step_mother.load_programming_language('rb')

      @visitor = mock('Visitor')
    end

    it &quot;should format step names&quot; do
      @dsl.Given(/it (.*) in (.*)/) do |what, month|
      end
      @dsl.Given(/nope something else/) do |what, month|
      end
      
      format = @step_mother.step_match(&quot;it snows in april&quot;).format_args(&quot;[%s]&quot;)
      format.should == &quot;it [snows] in [april]&quot;
    end

    it &quot;should raise Ambiguous error with guess hint when multiple step definitions match&quot; do
      @dsl.Given(/Three (.*) mice/) {|disability|}
      @dsl.Given(/Three blind (.*)/) {|animal|}

      lambda do
        @step_mother.step_match(&quot;Three blind mice&quot;)
      end.should raise_error(Ambiguous, %{Ambiguous match of &quot;Three blind mice&quot;:

spec/cucumber/step_mother_spec.rb:30:in `/Three (.*) mice/'
spec/cucumber/step_mother_spec.rb:31:in `/Three blind (.*)/'

You can run again with --guess to make Cucumber be more smart about it
})
    end

    it &quot;should not show --guess hint when --guess is used&quot; do
      @step_mother.options = {:guess =&gt; true}

      @dsl.Given(/Three (.*) mice/) {|disability|}
      @dsl.Given(/Three cute (.*)/) {|animal|}
      
      lambda do
        @step_mother.step_match(&quot;Three cute mice&quot;)
      end.should raise_error(Ambiguous, %{Ambiguous match of &quot;Three cute mice&quot;:

spec/cucumber/step_mother_spec.rb:47:in `/Three (.*) mice/'
spec/cucumber/step_mother_spec.rb:48:in `/Three cute (.*)/'

})
    end

    it &quot;should not raise Ambiguous error when multiple step definitions match, but --guess is enabled&quot; do
      @step_mother.options = {:guess =&gt; true}
      @dsl.Given(/Three (.*) mice/) {|disability|}
      @dsl.Given(/Three (.*)/) {|animal|}
      
      lambda do
        @step_mother.step_match(&quot;Three blind mice&quot;)
      end.should_not raise_error
    end
    
    it &quot;should pick right step definition when --guess is enabled and equal number of capture groups&quot; do
      @step_mother.options = {:guess =&gt; true}
      right = @dsl.Given(/Three (.*) mice/) {|disability|}
      wrong = @dsl.Given(/Three (.*)/) {|animal|}
      
      @step_mother.step_match(&quot;Three blind mice&quot;).step_definition.should == right
    end
    
    it &quot;should pick right step definition when --guess is enabled and unequal number of capture groups&quot; do
      @step_mother.options = {:guess =&gt; true}
      right = @dsl.Given(/Three (.*) mice ran (.*)/) {|disability|}
      wrong = @dsl.Given(/Three (.*)/) {|animal|}
      
      @step_mother.step_match(&quot;Three blind mice ran far&quot;).step_definition.should == right
    end

    it &quot;should pick most specific step definition when --guess is enabled and unequal number of capture groups&quot; do
      @step_mother.options = {:guess =&gt; true}
      general       = @dsl.Given(/Three (.*) mice ran (.*)/) {|disability|}
      specific      = @dsl.Given(/Three blind mice ran far/) {}
      more_specific = @dsl.Given(/^Three blind mice ran far$/) {}
      
      @step_mother.step_match(&quot;Three blind mice ran far&quot;).step_definition.should == more_specific
    end
    
    it &quot;should raise Undefined error when no step definitions match&quot; do
      lambda do
        @step_mother.step_match(&quot;Three blind mice&quot;)
      end.should raise_error(Undefined)
    end

    # http://railsforum.com/viewtopic.php?pid=93881
    it &quot;should not raise Redundant unless it's really redundant&quot; do
      @dsl.Given(/^(.*) (.*) user named '(.*)'$/) {|a,b,c|}
      @dsl.Given(/^there is no (.*) user named '(.*)'$/) {|a,b|}
    end

    it &quot;should raise an error if the world is nil&quot; do
      @dsl.World do
      end

      begin
        @step_mother.before_and_after(nil) {}
        raise &quot;Should fail&quot;
      rescue RbSupport::NilWorld =&gt; e
        e.message.should == &quot;World procs should never return nil&quot;
        e.backtrace.should == [&quot;spec/cucumber/step_mother_spec.rb:108:in `World'&quot;]
      end
    end

    module ModuleOne
    end

    module ModuleTwo
    end

    class ClassOne
    end

    it &quot;should implicitly extend world with modules&quot; do
      @dsl.World(ModuleOne, ModuleTwo)
      @step_mother.before(nil)
      class &lt;&lt; @rb.current_world
        included_modules.index(ModuleOne).should_not == nil
        included_modules.index(ModuleTwo).should_not == nil
      end
      @rb.current_world.class.should == Object
    end

    it &quot;should raise error when we try to register more than one World proc&quot; do
      @dsl.World { Hash.new }
      lambda do
        @dsl.World { Array.new }
      end.should raise_error(RbSupport::MultipleWorld, %{You can only pass a proc to #World once, but it's happening
in 2 places:

spec/cucumber/step_mother_spec.rb:140:in `World'
spec/cucumber/step_mother_spec.rb:142:in `World'

Use Ruby modules instead to extend your worlds. See the Cucumber::RbSupport::RbDsl#World RDoc
or http://wiki.github.com/aslakhellesoy/cucumber/a-whole-new-world.

})
    end

    it &quot;should find before hooks&quot; do
      fish = @dsl.Before('@fish'){}
      meat = @dsl.Before('@meat'){}
            
      scenario = mock('Scenario')
      scenario.should_receive(:accept_hook?).with(fish).and_return(true)
      scenario.should_receive(:accept_hook?).with(meat).and_return(false)
      
      @rb.hooks_for(:before, scenario).should == [fish]
    end
  end

  describe StepMother, &quot;step argument transformations&quot; do
    before do
      @dsl = Object.new
      @dsl.extend(RbSupport::RbDsl)

      @step_mother = StepMother.new
      @step_mother.load_natural_language('en')
      @rb = @step_mother.load_programming_language('rb')
    end

    describe &quot;without capture groups&quot; do
      it &quot;complains when registering with a with no transform block&quot; do
        lambda do
          @dsl.Transform('^abc$')
        end.should raise_error(Cucumber::RbSupport::RbTransform::MissingProc)
      end
      
      it &quot;complains when registering with a zero-arg transform block&quot; do
        lambda do
          @dsl.Transform('^abc$') {42}
        end.should raise_error(Cucumber::RbSupport::RbTransform::MissingProc)
      end

      it &quot;complains when registering with a splat-arg transform block&quot; do
        lambda do
          @dsl.Transform('^abc$') {|*splat| 42 }
        end.should raise_error(Cucumber::RbSupport::RbTransform::MissingProc)
      end

      it &quot;complains when transforming with an arity mismatch&quot; do
        lambda do
          @dsl.Transform('^abc$') {|one, two| 42 }
          @rb.execute_transforms(['abc'])
        end.should raise_error(Cucumber::ArityMismatchError)
      end

      it &quot;allows registering a regexp pattern that yields the step_arg matched&quot; do
        @dsl.Transform(/^ab*c$/) {|arg| 42}
        @rb.execute_transforms(['ab']).should == ['ab']
        @rb.execute_transforms(['ac']).should == [42]
        @rb.execute_transforms(['abc']).should == [42]
        @rb.execute_transforms(['abbc']).should == [42]
      end
    end

    describe &quot;with capture groups&quot; do
      it &quot;complains when registering with a with no transform block&quot; do
        lambda do
          @dsl.Transform('^a(.)c$')
        end.should raise_error(Cucumber::RbSupport::RbTransform::MissingProc)
      end
      
      it &quot;complains when registering with a zero-arg transform block&quot; do
        lambda do
          @dsl.Transform('^a(.)c$') { 42 }
        end.should raise_error(Cucumber::RbSupport::RbTransform::MissingProc)
      end

      it &quot;complains when registering with a splat-arg transform block&quot; do
        lambda do
          @dsl.Transform('^a(.)c$') {|*splat| 42 }
        end.should raise_error(Cucumber::RbSupport::RbTransform::MissingProc)
      end

      it &quot;complains when transforming with an arity mismatch&quot; do
        lambda do
          @dsl.Transform('^a(.)c$') {|one, two| 42 }
          @rb.execute_transforms(['abc'])
        end.should raise_error(Cucumber::ArityMismatchError)
      end
      
      it &quot;allows registering a regexp pattern that yields capture groups&quot; do
        @dsl.Transform(/^shape: (.+), color: (.+)$/) do |shape, color|
          {shape.to_sym =&gt; color.to_sym}
        end
        @rb.execute_transforms(['shape: circle, color: blue']).should == [{:circle =&gt; :blue}]
        @rb.execute_transforms(['shape: square, color: red']).should == [{:square =&gt; :red}]
        @rb.execute_transforms(['not shape: square, not color: red']).should == ['not shape: square, not color: red']
      end
    end
    
    it &quot;allows registering a string pattern&quot; do
      @dsl.Transform('^ab*c$') {|arg| 42}
      @rb.execute_transforms(['ab']).should == ['ab']
      @rb.execute_transforms(['ac']).should == [42]
      @rb.execute_transforms(['abc']).should == [42]
      @rb.execute_transforms(['abbc']).should == [42]
    end

    it &quot;gives match priority to transforms defined last&quot; do
      @dsl.Transform(/^transform_me$/) {|arg| :foo }
      @dsl.Transform(/^transform_me$/) {|arg| :bar }
      @dsl.Transform(/^transform_me$/) {|arg| :baz }
      @rb.execute_transforms(['transform_me']).should == [:baz]
    end
    
    it &quot;allows registering a transform which returns nil&quot; do
      @dsl.Transform('^ac$') {|arg| nil}
      @rb.execute_transforms(['ab']).should == ['ab']
      @rb.execute_transforms(['ac']).should == [nil]
    end
  end

end
</pre>
    </div>