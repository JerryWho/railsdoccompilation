  <div id="fileHeader">
    <h1>feature_parser_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/cucumber/parser/feature_parser_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:58:05 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper'
require 'cucumber/parser/natural_language'

module Cucumber
  module Parser
    describe Feature do
      before do
        @step_mother = StepMother.new
        @parser = NaturalLanguage.get(@step_mother, 'en').parser
      end

      after do
        NaturalLanguage.instance_variable_set(:@languages, nil) # So that new StepMothers can be created and have adverbs registered
      end

      def parse(text)
        feature = @parser.parse_or_fail(text)
      end

      def parse_file(file)
        FeatureFile.new(File.dirname(__FILE__) + &quot;/../treetop_parser/&quot; + file).parse(@step_mother, {})
      end

      def parse_example_file(file)
        FeatureFile.new(File.dirname(__FILE__) + &quot;/../../../examples/&quot; + file).parse(@step_mother, {})
      end

      describe &quot;Comments&quot; do
        it &quot;should parse a file with only a one line comment&quot; do
          parse(%{# My comment
Feature: hi
}).to_sexp.should ==
          [:feature, nil, &quot;Feature: hi&quot;,
            [:comment, &quot;# My comment\n&quot;]]
        end

        it &quot;should parse a file with only a multiline comment&quot; do
          parse(%{# Hello
# World
Feature: hi
}).to_sexp.should ==
          [:feature, nil, &quot;Feature: hi&quot;,
            [:comment, &quot;# Hello\n# World\n&quot;]]
        end

        it &quot;should parse a file with no comments&quot; do
          parse(&quot;Feature: hi\n&quot;).to_sexp.should ==
          [:feature, nil, &quot;Feature: hi&quot;]
        end

        it &quot;should parse a file with only a multiline comment with newlines&quot; do
          parse(&quot;# Hello\n\n# World\n&quot;).to_sexp.should == 
          [:feature, nil, &quot;&quot;, 
            [:comment, &quot;# Hello\n\n# World\n&quot;]]
        end
        
        it &quot;should not consume comments as part of a multiline name&quot; do
          parse(&quot;Feature: hi\n Scenario: test\n\n#hello\n Scenario: another&quot;).to_sexp.should ==
            [:feature, nil, &quot;Feature: hi&quot;, 
             [:scenario, 2, &quot;Scenario:&quot;, &quot;test&quot;], 
             [:scenario, 5, &quot;Scenario:&quot;, &quot;another&quot;, 
              [:comment, &quot;#hello\n &quot;]]]
        end
      end

      describe &quot;Tags&quot; do
        it &quot;should parse a file with tags on a feature&quot; do
          parse(&quot;# My comment\n@hello @world Feature: hi\n&quot;).to_sexp.should ==
          [:feature, nil, &quot;Feature: hi&quot;,
            [:comment, &quot;# My comment\n&quot;],
            [:tag, &quot;@hello&quot;],
            [:tag, &quot;@world&quot;]]
        end

        it &quot;should not take the tags as part of a multiline name feature element&quot; do
          parse(&quot;Feature: hi\n Scenario: test\n\n@hello Scenario: another&quot;).to_sexp.should ==
          [:feature, nil, &quot;Feature: hi&quot;,
           [:scenario, 2, &quot;Scenario:&quot;, &quot;test&quot;], 
           [:scenario, 4, &quot;Scenario:&quot;, &quot;another&quot;, 
             [:tag, &quot;@hello&quot;]]]
        end

        it &quot;should parse a file with tags on a scenario&quot; do
          parse(%{# FC
  @ft
Feature: hi

  @st1 @st2   
  Scenario: First
    Given Pepper

@st3 
   @st4    @ST5  @#^%&amp;ST6**!
  Scenario: Second}).to_sexp.should ==
          [:feature, nil, &quot;Feature: hi&quot;,
            [:comment, &quot;# FC\n  &quot;],
            [:tag, &quot;@ft&quot;],
            [:scenario, 6, 'Scenario:', 'First',
              [:tag, &quot;@st1&quot;], [:tag, &quot;@st2&quot;],
              [:step_invocation, 7, &quot;Given&quot;, &quot;Pepper&quot;]
            ],
            [:scenario, 11, 'Scenario:', 'Second',
              [:tag, &quot;@st3&quot;], [:tag, &quot;@st4&quot;], [:tag, &quot;@ST5&quot;], [:tag, &quot;@#^%&amp;ST6**!&quot;]]]
        end
      end
      
      describe &quot;Background&quot; do
        it &quot;should have steps&quot; do
          parse(&quot;Feature: Hi\nBackground:\nGiven I am a step\n&quot;).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:background, 2, &quot;Background:&quot;,
              [:step, 3, &quot;Given&quot;, &quot;I am a step&quot;]]]
        end
        
        it &quot;should allow multiline names&quot; do
          parse(%{Feature: Hi
Background: It is my ambition to say 
            in ten sentences
            what others say 
            in a whole book.
Given I am a step}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:background, 2, &quot;Background:&quot;, &quot;It is my ambition to say\nin ten sentences\nwhat others say\nin a whole book.&quot;,
              [:step, 6, &quot;Given&quot;, &quot;I am a step&quot;]]]
        end
      end

      describe &quot;Scenarios&quot; do
        it &quot;can be empty&quot; do
          parse(&quot;Feature: Hi\n\nScenario: Hello\n&quot;).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario, 3, &quot;Scenario:&quot;, &quot;Hello&quot;]]
        end

        it &quot;should allow whitespace lines after the Scenario line&quot; do
          parse(%{Feature: Foo

Scenario: bar

  Given baz})
        end
            
        it &quot;should have steps&quot; do
          parse(&quot;Feature: Hi\nScenario: Hello\nGiven I am a step\n&quot;).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario, 2, &quot;Scenario:&quot;, &quot;Hello&quot;,
              [:step_invocation, 3, &quot;Given&quot;, &quot;I am a step&quot;]]]
        end

        it &quot;should have steps with inline table&quot; do
          parse(%{Feature: Hi
Scenario: Hello
Given I have a table
|a|b|
}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario, 2, &quot;Scenario:&quot;, &quot;Hello&quot;,
              [:step_invocation, 3, &quot;Given&quot;, &quot;I have a table&quot;,
                [:table,
                  [:row, 4,
                    [:cell, &quot;a&quot;],
                    [:cell, &quot;b&quot;]]]]]]
        end

        it &quot;should have steps with inline py_string&quot; do
          parse(%{Feature: Hi
Scenario: Hello
Given I have a string


   &quot;&quot;&quot;
  hello
  world
  &quot;&quot;&quot;

}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario, 2, &quot;Scenario:&quot;, &quot;Hello&quot;,
              [:step_invocation, 3, &quot;Given&quot;, &quot;I have a string&quot;,
                [:py_string, &quot;hello\nworld&quot;]]]]
        end
        
        it &quot;should allow multiline names&quot; do
          parse(%{Feature: Hi
Scenario: It is my ambition to say
          in ten sentences
          what others say 
          in a whole book.
Given I am a step

}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario, 2, &quot;Scenario:&quot;, &quot;It is my ambition to say\nin ten sentences\nwhat others say\nin a whole book.&quot;,
              [:step_invocation, 6, &quot;Given&quot;, &quot;I am a step&quot;]]]
        end

        it &quot;should ignore gherkin keywords which are parts of other words in the name&quot; do
          parse(%{Feature: Parser bug
Scenario: I have a Button
          Buttons are great
  Given I have it
}).to_sexp.should ==
            [:feature, nil, &quot;Feature: Parser bug&quot;,
            [:scenario, 2, &quot;Scenario:&quot;, &quot;I have a Button\nButtons are great&quot;,
              [:step_invocation, 4, &quot;Given&quot;, &quot;I have it&quot;]]]

        end
      end

      describe &quot;Scenario Outlines&quot; do
        it &quot;can be empty&quot; do
          parse(%{Feature: Hi
Scenario Outline: Hello
Given a &lt;what&gt; cucumber
Examples:
|what|
|green|
}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario_outline, &quot;Scenario Outline:&quot;, &quot;Hello&quot;,
              [:step, 3, &quot;Given&quot;, &quot;a &lt;what&gt; cucumber&quot;],
              [:examples, &quot;Examples:&quot;, &quot;&quot;,
                [:table, 
                  [:row, 5,
                    [:cell, &quot;what&quot;]], 
                  [:row, 6,
                    [:cell, &quot;green&quot;]]]]]]
        end

        it &quot;should have line numbered steps with inline table&quot; do
          parse(%{Feature: Hi
Scenario Outline: Hello

Given I have a table

|&lt;a&gt;|&lt;b&gt;|
Examples:
|a|b|
|c|d|
}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario_outline, &quot;Scenario Outline:&quot;, &quot;Hello&quot;,
              [:step, 4, &quot;Given&quot;, &quot;I have a table&quot;,
                [:table, 
                  [:row, 6,
                    [:cell, &quot;&lt;a&gt;&quot;], 
                    [:cell, &quot;&lt;b&gt;&quot;]]]],
            [:examples, &quot;Examples:&quot;, &quot;&quot;,
              [:table,
                [:row, 8,
                  [:cell, &quot;a&quot;], 
                  [:cell, &quot;b&quot;]],
                [:row, 9,
                  [:cell, &quot;c&quot;], 
                  [:cell, &quot;d&quot;]]]]]]
        end

        it &quot;should have examples&quot; do
          parse(&quot;Feature: Hi

  Scenario Outline: Hello

  Given I have a table
    |1|2|

  Examples:
|x|y|
|5|6|

&quot;).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario_outline, &quot;Scenario Outline:&quot;, &quot;Hello&quot;,
              [:step, 5, &quot;Given&quot;, &quot;I have a table&quot;,
                [:table,
                  [:row, 6, 
                    [:cell, &quot;1&quot;],
                    [:cell, &quot;2&quot;]]]],
              [:examples, &quot;Examples:&quot;, &quot;&quot;,
                [:table,
                  [:row, 9,
                    [:cell, &quot;x&quot;],
                    [:cell, &quot;y&quot;]],
                  [:row, 10,
                    [:cell, &quot;5&quot;],
                    [:cell, &quot;6&quot;]]]]]]
        end

        it &quot;should allow multiline names&quot; do
          parse(%{Feature: Hi
Scenario Outline: It is my ambition to say 
          in ten sentences
          what others say 
          in a whole book.
Given I am a step

}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario_outline, &quot;Scenario Outline:&quot;, &quot;It is my ambition to say\nin ten sentences\nwhat others say\nin a whole book.&quot;,
              [:step, 6, &quot;Given&quot;, &quot;I am a step&quot;]]]
        end
        
        it &quot;should allow Examples to have multiline names&quot; do
          parse(%{Feature: Hi
Scenario Outline: name
Given I am a step

Examples: I'm a multiline name
          and I'm ok
|x|
|5|

}).to_sexp.should ==
          [:feature, nil, &quot;Feature: Hi&quot;,
            [:scenario_outline, &quot;Scenario Outline:&quot;, &quot;name&quot;,
              [:step, 3, &quot;Given&quot;, &quot;I am a step&quot;],
              [:examples, &quot;Examples:&quot;, &quot;I'm a multiline name\nand I'm ok&quot;,
                [:table,
                  [:row, 7,
                    [:cell, &quot;x&quot;]],
                  [:row, 8,
                    [:cell, &quot;5&quot;]]]]]]
        end

        it &quot;should allow Examples to have multiline names&quot; do
            parse(%{Feature: Hi
Scenario: When I have when in scenario
          I should be fine
Given I am a step
}).to_sexp.should ==
            [:feature, nil, &quot;Feature: Hi&quot;,
              [:scenario, 2, &quot;Scenario:&quot;, &quot;When I have when in scenario\nI should be fine&quot;,
                [:step_invocation, 4, &quot;Given&quot;, &quot;I am a step&quot;]]]
          end
      end

      describe &quot;Syntax&quot; do
        it &quot;should parse empty_feature&quot; do
          parse_file(&quot;empty_feature.feature&quot;)
        end

        it &quot;should parse empty_scenario&quot; do
          parse_file(&quot;empty_scenario.feature&quot;)
        end

        it &quot;should parse empty_scenario_outline&quot; do
          parse_file(&quot;empty_scenario_outline.feature&quot;)
        end

        it &quot;should parse fit_scenario&quot; do
          parse_file(&quot;multiline_steps.feature&quot;)
        end

        it &quot;should parse scenario_outline&quot; do
          parse_file(&quot;scenario_outline.feature&quot;)
        end

        it &quot;should parse comments&quot; do
          parse_file(&quot;with_comments.feature&quot;)
        end
      end

      describe &quot;Filtering&quot; do
        it &quot;should filter outline tables&quot; do
          path = '/self_test/features/outline_sample.feature'
          f = parse_example_file(&quot;#{path}:12&quot;)
          actual_sexp = f.to_sexp
          
          # check path is equivalent, if not same
          File.expand_path(actual_sexp[1]).should == File.expand_path(File.dirname(__FILE__) + &quot;/../../../examples#{path}&quot;)
          actual_sexp[1] = 'made/up/path.feature'
          actual_sexp.should ==
          [:feature,
            'made/up/path.feature',
            &quot;Feature: Outline Sample&quot;,
            [:scenario_outline,
              &quot;Scenario Outline:&quot;,
              &quot;Test state&quot;,
              [:step, 6, &quot;Given&quot;, &quot;&lt;state&gt; without a table&quot;],
              [:step, 7, &quot;Given&quot;, &quot;&lt;other_state&gt; without a table&quot;],
              [:examples,
                &quot;Examples:&quot;,
                &quot;Rainbow colours&quot;,
                [:table,
                  [:row, 9, 
                    [:cell, &quot;state&quot;], 
                    [:cell, &quot;other_state&quot;]
                  ],
                  [:row, 12, 
                    [:cell, &quot;failing&quot;], 
                    [:cell, &quot;passing&quot;]
                  ]
                ]
              ]
            ]
          ]
        end
      end
    end
  end
end
</pre>
    </div>