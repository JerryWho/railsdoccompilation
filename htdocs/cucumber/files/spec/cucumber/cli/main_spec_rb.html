  <div id="fileHeader">
    <h1>main_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/cucumber/cli/main_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:11:24 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper'
require 'yaml'
require 'spec/expectations/differs/default'

module Cucumber
module Cli
  describe Main do
    before(:each) do
      @out = StringIO.new
      Kernel.stub!(:exit).and_return(nil)
    end

    describe &quot;verbose mode&quot; do
      
      before(:each) do
        @empty_feature = Ast::Feature.new(nil, Ast::Comment.new(''), Ast::Tags.new(2, []), &quot;Feature&quot;, [])
        Dir.stub!(:[])
      end

      it &quot;should show ruby files required&quot; do
        @cli = Main.new(%w{--verbose --require example.rb}, @out)
        @cli.stub!(:require)
        
        @cli.execute!(Object.new.extend(StepMother))
        
        @out.string.should include('example.rb')
      end
      
      it &quot;should show feature files parsed&quot; do
        @cli = Main.new(%w{--verbose example.feature}, @out)
        @cli.stub!(:require)
        
        Parser::FeatureParser.stub!(:new).and_return(mock(&quot;feature parser&quot;, :parse_file =&gt; @empty_feature))
          
        @cli.execute!(Object.new.extend(StepMother))

        @out.string.should include('example.feature')
      end
      
    end

    describe &quot;diffing&quot; do

      before :each do
        @configuration = mock('Configuration', :null_object =&gt; true)
        Configuration.should_receive(:new).and_return(@configuration)
        
        @step_mother = mock('StepMother', :null_object =&gt; true)
        
        @cli = Main.new(nil, @out)
      end
      
      it &quot;uses Spec Differ::Default when diff is enabled&quot; do
        @configuration.should_receive(:diff_enabled?).and_return(true)
        
        ::Spec::Expectations::Differs::Default.should_receive(:new)
        
        @cli.execute!(@step_mother)
      end
      
      it &quot;does not use Spec Differ::Default when diff is disabled&quot; do
        @configuration.should_receive(:diff_enabled?).and_return(false)
        
        ::Spec::Expectations::Differs::Default.should_not_receive(:new)
        
        @cli.execute!(@step_mother)
      end
      
    end

    describe &quot;--format with class&quot; do
     
     describe &quot;in module&quot; do

        it &quot;should resolve each module until it gets Formatter class&quot; do
          cli = Main.new(%w{--format ZooModule::MonkeyFormatterClass}, nil)
          mock_module = mock('module')
          Object.stub!(:const_defined?).and_return(true)
          mock_module.stub!(:const_defined?).and_return(true)

          f = stub('formatter', :null_object =&gt; true)

          Object.should_receive(:const_get).with('ZooModule').and_return(mock_module)
          mock_module.should_receive(:const_get).with('MonkeyFormatterClass').and_return(mock('formatter class', :new =&gt; f))

          cli.execute!(Object.new.extend(StepMother))
        end

      end
     
      describe &quot;exists and valid constructor&quot; do
     
        before(:each) do
          @mock_formatter_class = mock('formatter class')
          Object.stub!(:const_get).and_return(@mock_formatter_class)
          Object.stub!(:const_defined?).with('magical').and_return(true)
        end
        
        xit &quot;should create the formatter&quot; do
          cli = Main.new
          mock_formatter = mock('magical formatter')
          cli.parse_options!(%w{--format magical})

          @mock_formatter_class.should_receive(:new)

          cli.execute!(stub('step mother'), mock_executor, stub('features'))
        end
                
        xit &quot;should register the formatter with broadcaster&quot; do
          cli = Main.new
          broadcaster = Broadcaster.new
          mock_formatter = mock('magical formatter')
          Broadcaster.stub!(:new).and_return(broadcaster, stub(&quot;output broadcaster&quot;, :register =&gt; nil))
          @mock_formatter_class.stub!(:new).and_return(mock_formatter)
          cli.parse_options!(%w{--format magical})

          broadcaster.should_receive(:register).with(mock_formatter)
        
          cli.execute!(stub('step mother'), mock_executor, stub('features'))
        end
      
      end
          
      describe &quot;exists but invalid constructor&quot; do

        before(:each) do
          @out = StringIO.new
          @error = StringIO.new
          @cli = Main.new(@out, @error)
          
          mock_formatter_class = stub('formatter class')
          mock_formatter_class.stub!(:new).and_raise(&quot;No such method&quot;)
          Object.stub!(:const_get).and_return(mock_formatter_class)
          Object.stub!(:const_defined?).with('exists_but_evil').and_return(true)
          
          @cli.parse_options!(%w{--format exists_but_evil}) 
        end
        
        xit &quot;should show exception&quot; do
          Kernel.stub!(:exit)

          @cli.execute!(stub('step mother'))

          @error.string.should include(&quot;No such method&quot;)
        end
        
        xit &quot;should exit&quot; do
          Kernel.should_receive(:exit)

          @cli.execute!(stub('step mother'), mock_executor, stub('features'))
        end
                
      end
          
      describe &quot;non-existent&quot; do

        before(:each) do
          @out = StringIO.new
          @error = StringIO.new
          @cli = Main.new(%w{--format invalid}, @out, @error)
        end

        xit &quot;should display a format error&quot; do
          Kernel.stub!(:exit)

          @cli.execute!(stub('step mother'), mock_executor, stub('features'))
          
          @error.string.should include(&quot;Invalid format: invalid\n&quot;)
        end
        
        xit &quot;should display --help&quot; do
          Kernel.stub!(:exit)

          @cli.execute!(Object.new.extend(StepMother))
          
          @out.string.should include(&quot;Usage: cucumber&quot;)
        end

        xit &quot;should exit&quot; do
          Kernel.should_receive(:exit)

          @cli.execute!(stub('step mother'), mock_executor, stub('features'))
        end
        
      end
            
    end

  end
end
end
</pre>
    </div>