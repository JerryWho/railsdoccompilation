  <div id="fileHeader">
    <h1>profile_formatter_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/cucumber/formatters/profile_formatter_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:11:24 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper'
require 'cucumber/formatter/profile'

module Cucumber
  module Formatter
    describe Progress do
      attr_reader :io, :formatter

      def mock_proc(stubs={})
        stub(Proc, {:to_comment_line =&gt; '# steps/example_steps.rb:11'}.merge(stubs))
      end

      def mock_step(stubs={})
        stub('step', {:keyword =&gt; 'Given',
          :actual_keyword =&gt;  'Given',
          :format =&gt; 'test',
          :row? =&gt; false,
          :file =&gt; 'test.feature',
          :line =&gt; 5,
          :regexp_args_proc =&gt; [nil, nil, mock_proc]}.merge(stubs))
      end

      before(:each) do
        ::Term::ANSIColor.coloring = false
        @io = StringIO.new
        step_mother = stub('step_mother')
        @formatter = ProfileFormatter.new(step_mother, io)
      end
      
      after(:each) do
        ::Term::ANSIColor.coloring = true
      end

      xit &quot;should print a heading&quot; do
        formatter.visit_features(nil)

        io.string.should eql(&quot;Profiling enabled.\n&quot;)
      end

      xit &quot;should record the current time when starting a new step&quot; do
        now = Time.now
        Time.stub!(:now).and_return(now)
        formatter.step_executing('should foo', nil, nil)

        formatter.instance_variable_get(&quot;@step_time&quot;).should == now
      end
      
      describe &quot;grouping recorded passed steps&quot; do

        before(:each) do
          now = Time.now
          formatter.instance_variable_set(&quot;@step_time&quot;, now)
          Time.stub!(:now).and_return(now, now)
        end

        xit &quot;should group by regular expressions and actual keyword&quot; do
          step_1 = mock_step(:actual_keyword =&gt; 'Given')
          step_2 = mock_step(:actual_keyword =&gt; 'Given')

          formatter.step_passed(step_1, /nihon/, nil)
          formatter.step_passed(step_2, /ichiban/, nil)

          step_times = formatter.instance_variable_get(&quot;@step_times&quot;)

          step_times.has_key?('Given /nihon/').should be_true
          step_times.has_key?('Given /ichiban/').should be_true
        end

        xit &quot;should use a previous step's keyword when recording row steps&quot; do
          step = mock_step(:actual_keyword =&gt; 'Given')
          step_row = mock_step(:row? =&gt; true)

          formatter.step_passed(step, /nihon/, [])
          formatter.step_passed(step_row, /nihon/, [])

          step_times = formatter.instance_variable_get(&quot;@step_times&quot;)
          
          step_times['Given /nihon/'].length.should == 2
        end

      end

      xit &quot;should correctly record a passed step&quot; do
        formatter.step_executing(nil, nil, nil)
        formatter.step_passed(mock_step(:format =&gt; 'she doth teach the torches to burn bright', :actual_keyword =&gt; 'Given'), nil, nil)
        formatter.dump

        io.string.should include('Given she doth teach the torches to burn bright')
      end

      xit &quot;should correctly record a passed step row&quot; do
        formatter.step_executing(nil, nil, nil)
        formatter.step_passed(mock_step(:row? =&gt; true), /example/, ['fitty'])
        formatter.dump

        io.string.should include('fitty')
      end

      xit &quot;should calculate the mean step execution time&quot; do
        now = Time.now
        Time.stub!(:now).and_return(now, now+5, now, now+1)

        2.times do
          formatter.step_executing(mock_step, nil, nil)
          formatter.step_passed(mock_step, nil, nil)
        end

        formatter.dump

        io.string.should include('3.0000000')
      end

      xit &quot;should display file and line comment for step invocation&quot; do
        step = mock_step(:format =&gt; 'test', :actual_keyword =&gt; 'Given', :file =&gt; 'test.feature', :line =&gt; 5)

        formatter.step_executing(step, nil, nil)
        formatter.step_passed(step, nil, nil)
        formatter.dump

        @io.string.should include(&quot;# test.feature:5&quot;)
      end

      xit &quot;should display file and line comment for step definition&quot; do
        step = mock_step(:format =&gt; 'test', :actual_keyword =&gt; 'Given',
                         :regexp_args_proc =&gt; [/test/, nil, mock_proc(:to_comment_line =&gt; '# steps/example_steps.rb:11')])

        formatter.step_executing(step, nil, nil)
        formatter.step_passed(step, nil, nil)
        formatter.dump

        @io.string.should include(&quot;# steps/example_steps.rb:11&quot;)
      end

      xit &quot;should show the performance times of the step invocations for a step definition&quot; do
        now = Time.now
        Time.stub!(:now).and_return(now, now+5, now, now+1)

        step = mock_step(:format =&gt; 'step invocation', :actual_keyword =&gt; 'Given')

        2.times do
          formatter.step_executing(step, /example/, nil)
          formatter.step_passed(step, /example/, nil)
        end

        formatter.dump

        io.string.should include(&quot;3.0000000  Given /example/&quot;)
        io.string.should include(&quot;5.0000000  Given step invocation&quot;)
        io.string.should include(&quot;1.0000000  Given step invocation&quot;)
      end
      
      xit &quot;should sort the step invocations in descending order&quot; do
        now = Time.now
        Time.stub!(:now).and_return(now, now+1, now, now+5)
        
        step = mock_step(:format =&gt; 'step invocation', :actual_keyword =&gt; 'Given')
        
        2.times do
          formatter.step_executing(step, /example 1/, nil)
          formatter.step_passed(step, /example 1/, nil)
        end
        
        formatter.dump
        io_string_lines = io.string.split(&quot;\n&quot;)
        
        io_string_lines.at(-2).should include('5.0000000')
        io_string_lines.at(-1).should include('1.0000000')
      end

      xit &quot;should print the top average 10 step results&quot; do
        formatter.instance_variable_set(&quot;@step_time&quot;, Time.now)

        11.times do |test_number|
          step_regexp = Regexp.new &quot;unique_test_#{test_number}&quot;
          formatter.step_passed(mock_step(:format =&gt; 'test', :actual_keyword =&gt; 'Given',
          :regexp_args_proc =&gt; [step_regexp, nil, mock_proc]), step_regexp, nil)
        end

        formatter.dump

        io.string.scan(/unique_test_\d+/).length.should == 10
      end

      xit &quot;should print the top 5 step invocations for step definition&quot; do
        formatter.instance_variable_set(&quot;@step_time&quot;, Time.now)
   
        10.times do |test_number|
          formatter.step_passed(mock_step(:format =&gt; 'please invocate me', :actual_keyword =&gt; 'Given'), nil, nil)
        end

        formatter.dump

        io.string.scan(/please invocate me/).length.should == 5
      end

    end
  end
end
</pre>
    </div>