  <div id="fileHeader">
    <h1>route_to.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/rails/matchers/route_to.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:57:39 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rack/utils'

module Spec
  module Rails
    module Matchers
      USAGE = ArgumentError.new( 'usage: { :method =&gt; &quot;path&quot; }.should route_to( :controller =&gt; &quot;controller&quot;, :action =&gt; &quot;action&quot;, [ args ] )' )

      class PathDecomposer
        def self.decompose_path(path)
          method, path = if Hash === path
                           raise USAGE if path.keys.size &gt; 1
                           path.entries.first
                         else
                           [:get, path]
                         end
          path, querystring = path.split('?')
          return method, path, querystring
        end
      end

      class RouteTo #:nodoc:
        def initialize(expected, example)
          @route, @example = expected,example
        end

        def matches?(path)
          begin
            @actual = path
            method, path, querystring = PathDecomposer.decompose_path(path)
            params = querystring.blank? ? {} : Rack::Utils.parse_query(querystring).symbolize_keys!
            @example.assert_routing({ :method =&gt; method, :path =&gt; path }, @route, {}, params)
            true
          rescue ActionController::RoutingError, ::Test::Unit::AssertionFailedError, ActionController::MethodNotAllowed =&gt; e
            raise e.class, &quot;#{e}\nIf you're expecting this failure, we suggest { :#{method} =&gt; \&quot;#{path}\&quot; }.should_not be_routable&quot;
          rescue Exception =&gt; e
            raise e.class, &quot;#{e}\n#{e.backtrace.join( &quot;\n&quot; )}&quot;
          end
        end

        def does_not_match(path)
          raise ArgumentError, &quot;Don't test a negative route like this.&quot;
        end

        def failure_message_for_should
          &quot;Expected #{@expected.inspect} to route to #{@actual.inspect}, but it didn't.\n&quot;+
          &quot;In this case, we expected you to get an exception.  So this message probably means something weird happened.&quot;
        end

        def failure_message_for_should_not
          &quot;Expected a routing error, but the route passed instead.  \nNote, when expecting routes to fail, you should use 'should_not be_routable' instead.&quot;
        end

        def description
          &quot;route to #{@expected.inspect}&quot;
        end

        private
          attr_reader :expected
          attr_reader :actual

      end

      # :call-seq:
      #   &quot;path&quot;.should route_to(expected)  # assumes GET
      #   { :get =&gt; &quot;path&quot; }.should route_to(expected)
      #   { :put =&gt; &quot;path&quot; }.should route_to(expected)
      #
      # Uses ActionController::Routing::Routes to verify that
      # the path-and-method routes to a given set of options.
      # Also verifies route-generation, so that the expected options
      # do generate a pathname consisten with the indicated path/method.
      #
      # For negative tests, only the route recognition failure can be
      # tested; since route generation via path_to() will always generate
      # a path as requested.  Use .should_not be_routable() in this case.
      #
      # == Examples
      # { :get =&gt; '/registrations/1/edit' }.
      #   should route_to(:controller =&gt; 'registrations', :action =&gt; 'edit', :id =&gt; '1')
      # { :put =&gt; &quot;/registrations/1&quot; }.should
      #   route_to(:controller =&gt; 'registrations', :action =&gt; 'update', :id =&gt; 1)
      # { :post =&gt; &quot;/registrations/&quot; }.should
      #   route_to(:controller =&gt; 'registrations', :action =&gt; 'create')

      def route_to(expected)
        RouteTo.new(expected, self)
      end

      class BeRoutable
        def initialize(example)
          @example = example
        end

        def matches?(path)
          begin
            @actual = path
            method, path = PathDecomposer.decompose_path(path)
            @example.assert_recognizes({}, { :method =&gt; method, :path =&gt; path }, {} )
            true
          rescue ActionController::RoutingError, ActionController::MethodNotAllowed
            false
          rescue ::Test::Unit::AssertionFailedError =&gt; e
            # the second thingy will always be &quot;&lt;{}&gt;&quot; becaues of the way we called assert_recognizes({}...) above.
            e.to_s =~ /&lt;(.*)&gt; did not match &lt;\{\}&gt;/ and @actual_place = $1 or raise
            true
          end
        end
        def failure_message_for_should
          &quot;Expected '#{@actual.keys.first.to_s.upcase} #{@actual.values.first}' to be routable, but it wasn't.\n&quot;+
          &quot;To really test routability, we recommend #{@actual.inspect}.\n&quot;+
          &quot;  should route_to( :action =&gt; 'action', :controller =&gt; 'controller' )\n\n&quot;+

          &quot;That way, you'll verify where your route goes to.  Plus, we'll verify\n&quot;+
          &quot;the generation of the expected path from the action/controller, as in\n&quot;+
          &quot;the url_for() helper.&quot;
        end

        def failure_message_for_should_not
          &quot;Expected '#{@actual.keys.first.to_s.upcase} #{@actual.values.first}' to fail, but it routed to #{@actual_place} instead&quot;
        end

      end
      # :call-seq:
      #   { &quot;path&quot; }.should_not be_routable # assumes GET
      #   { :get =&gt; &quot;path&quot; }.should_not be_routable
      #   { :put =&gt; &quot;path&quot; }.should_not be_routable
      #
      # Uses ActionController::Routing::Routes to verify that
      # the path-and-method cannot be routed to a controller.
      # Since url_for() will always generate a path, even if that
      # path is not routable, the negative test only needs to be
      # performed on the route recognition.
      #
      # Don't use this matcher for testing expected routability -
      # use .should route_to( :controller =&gt; &quot;controller&quot;, :action =&gt; &quot;action&quot; ) instead
      #
      # == Examples
      # { :get =&gt; '/registrations/1/attendees/3/edit' }.should_not be_routable
      # { :get =&gt; '/attendees/3/edit' }.should route_to( ...&lt;controller/action&gt;... )

      def be_routable
        BeRoutable.new(self)
      end

      alias_method :be_routeable, :be_routable
    end
  end
end

</pre>
    </div>