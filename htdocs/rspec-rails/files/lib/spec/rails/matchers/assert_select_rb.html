  <div id="fileHeader">
    <h1>assert_select.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/rails/matchers/assert_select.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:57:39 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># This is a wrapper of assert_select for rspec.

module Spec # :nodoc:
  module Rails
    module Matchers

      class AssertSelect #:nodoc:
        attr_reader :options

        def initialize(selector_assertion, spec_scope, *args, &amp;block)
          @args, @options = args_and_options(args)
          @spec_scope = spec_scope
          @selector_assertion = selector_assertion
          @block = block
        end
        
        def matches?(response_or_text, &amp;block)
          @block = block if block

          if doc = doc_from(response_or_text)
            @args.unshift(doc)
          end

          begin
            @spec_scope.__send__(@selector_assertion, *@args, &amp;@block)
            true
          rescue ::Test::Unit::AssertionFailedError =&gt; @error
            false
          end
        end
        
        def failure_message_for_should; @error.message; end
        def failure_message_for_should_not; &quot;should not #{description}, but did&quot;; end

        def description
          {
            :assert_select =&gt; &quot;have tag#{format_args(*@args)}&quot;,
            :assert_select_email =&gt; &quot;send email#{format_args(*@args)}&quot;,
          }[@selector_assertion]
        end

      private

        module TestResponseOrString
          def test_response?
            ActionController::TestResponse === self and
                                               !self.headers['Content-Type'].blank? and
                                               self.headers['Content-Type'].to_sym == :xml
          end
        
          def string?
            String === self
          end
        end

        def doc_from(response_or_text)
          response_or_text.extend TestResponseOrString
          if response_or_text.test_response?
            HTML::Document.new(response_or_text.body, @options[:strict], @options[:xml]).root
          elsif response_or_text.string?
            HTML::Document.new(response_or_text, @options[:strict], @options[:xml]).root
           end
        end

        def format_args(*args)
          args.empty? ? &quot;&quot; : &quot;(#{arg_list(*args)})&quot;
        end

        def arg_list(*args)
          args.map do |arg|
            arg.respond_to?(:description) ? arg.description : arg.inspect
          end.join(&quot;, &quot;)
        end
        
        def args_and_options(args)
          opts = {:xml =&gt; false, :strict =&gt; false}
          if args.last.is_a?(::Hash)
            opts[:strict] = args.last.delete(:strict) unless args.last[:strict].nil?
            opts[:xml]    = args.last.delete(:xml)    unless args.last[:xml].nil?
            args.pop if args.last.empty?
          end
          return [args, opts]
        end
        
      end
      
      # :call-seq:
      #   response.should have_tag(*args, &amp;block)
      #   string.should have_tag(*args, &amp;block)
      #
      # wrapper for assert_select with additional support for using
      # css selectors to set expectation on Strings. Use this in
      # helper specs, for example, to set expectations on the results
      # of helper methods. Also allow specification of how the 
      # response is parsed using the options :xml and :strict options.
      # By default, these options are set to false.
      #
      # == Examples
      #
      #   # in a controller spec
      #   response.should have_tag(&quot;div&quot;, &quot;some text&quot;)
      #
      #   # to force xml and/or strict parsing of the response
      #   response.should have_tag(&quot;div&quot;, &quot;some text&quot;, :xml =&gt; true)
      #   response.should have_tag(&quot;div&quot;, &quot;some text&quot;, :strict =&gt; true)
      #   response.should have_tag(&quot;div&quot;, &quot;some text&quot;, :xml =&gt; true, :strict =&gt; false)
      #
      #   # in a helper spec (person_address_tag is a method in the helper)
      #   person_address_tag.should have_tag(&quot;input#person_address&quot;)
      #
      # see documentation for assert_select at http://api.rubyonrails.org/
      def have_tag(*args, &amp;block)
        @__current_scope_for_assert_select = AssertSelect.new(:assert_select, self, *args, &amp;block)
      end
    
      # wrapper for a nested assert_select
      #
      #   response.should have_tag(&quot;div#form&quot;) do
      #     with_tag(&quot;input#person_name[name=?]&quot;, &quot;person[name]&quot;)
      #   end
      #
      # see documentation for assert_select at http://api.rubyonrails.org/
      def with_tag(*args, &amp;block)
        args = prepare_args(args, @__current_scope_for_assert_select)
        @__current_scope_for_assert_select.should have_tag(*args, &amp;block)
      end
    
      # wrapper for a nested assert_select with false
      #
      #   response.should have_tag(&quot;div#1&quot;) do
      #     without_tag(&quot;span&quot;, &quot;some text that shouldn't be there&quot;)
      #   end
      #
      # see documentation for assert_select at http://api.rubyonrails.org/
      def without_tag(*args, &amp;block)
        args = prepare_args(args, @__current_scope_for_assert_select)
        @__current_scope_for_assert_select.should_not have_tag(*args, &amp;block)
      end
    
      # :call-seq:
      #   response.should have_rjs(*args, &amp;block)
      #
      # wrapper for assert_select_rjs
      #
      # see documentation for assert_select_rjs at http://api.rubyonrails.org/
      def have_rjs(*args, &amp;block)
        AssertSelect.new(:assert_select_rjs, self, *args, &amp;block)
      end
      
      # :call-seq:
      #   response.should send_email(*args, &amp;block)
      #
      # wrapper for assert_select_email
      #
      # see documentation for assert_select_email at http://api.rubyonrails.org/
      def send_email(*args, &amp;block)
        AssertSelect.new(:assert_select_email, self, *args, &amp;block)
      end
      
      # wrapper for assert_select_encoded
      #
      # see documentation for assert_select_encoded at http://api.rubyonrails.org/
      def with_encoded(*args, &amp;block)
        should AssertSelect.new(:assert_select_encoded, self, *args, &amp;block)
      end

    private
    
      def prepare_args(args, current_scope = nil)
        return args if current_scope.nil?
        defaults = current_scope.options || {:strict =&gt; false, :xml =&gt; false}
        args &lt;&lt; {} unless args.last.is_a?(::Hash)
        args.last[:strict] = defaults[:strict] if args.last[:strict].nil?
        args.last[:xml] = defaults[:xml] if args.last[:xml].nil?
        args
      end

    end
  end
end
</pre>
    </div>