  <div id="fileHeader">
    <h1>field.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/webrat/core/elements/field.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:44:05 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;cgi&quot;
require &quot;webrat/core_extensions/blank&quot;
require &quot;webrat/core_extensions/nil_to_param&quot;

require &quot;webrat/core/elements/element&quot;

module Webrat
  # Raised when Webrat is asked to manipulate a disabled form field
  class DisabledFieldError &lt; WebratError
  end

  class Field &lt; Element #:nodoc:
    attr_reader :value

    def self.xpath_search
      [&quot;.//button&quot;, &quot;.//input&quot;, &quot;.//textarea&quot;, &quot;.//select&quot;]
    end

    def self.xpath_search_excluding_hidden
      [&quot;.//button&quot;, &quot;.//input[ @type != 'hidden']&quot;, &quot;.//textarea&quot;, &quot;.//select&quot;]
    end

    def self.field_classes
      @field_classes || []
    end

    def self.inherited(klass)
      @field_classes ||= []
      @field_classes &lt;&lt; klass
      # raise args.inspect
    end

    def self.load(session, element)
      return nil if element.nil?
      session.elements[element.path] ||= field_class(element).new(session, element)
    end

    def self.field_class(element)
      case element.name
      when &quot;button&quot;   then ButtonField
      when &quot;select&quot;
        if element.attributes[&quot;multiple&quot;].nil?
          SelectField
        else
          MultipleSelectField
        end
      when &quot;textarea&quot; then TextareaField
      else
        case element[&quot;type&quot;]
        when &quot;checkbox&quot; then CheckboxField
        when &quot;hidden&quot;   then HiddenField
        when &quot;radio&quot;    then RadioField
        when &quot;password&quot; then PasswordField
        when &quot;file&quot;     then FileField
        when &quot;reset&quot;    then ResetField
        when &quot;submit&quot;   then ButtonField
        when &quot;button&quot;   then ButtonField
        when &quot;image&quot;    then ButtonField
        else  TextField
        end
      end
    end

    def initialize(*args)
      super
      @value = default_value
    end

    def label_text
      return nil if labels.empty?
      labels.first.text
    end

    def id
      @element[&quot;id&quot;]
    end

    def disabled?
      @element.attributes.has_key?(&quot;disabled&quot;) &amp;&amp; @element[&quot;disabled&quot;] != 'false'
    end

    def raise_error_if_disabled
      return unless disabled?
      raise DisabledFieldError.new(&quot;Cannot interact with disabled form element (#{self})&quot;)
    end

    def to_param
      return nil if disabled?

      params = case Webrat.configuration.mode
      when :rails
        parse_rails_request_params(&quot;#{name}=#{escaped_value}&quot;)
      when :merb
        ::Merb::Parse.query(&quot;#{name}=#{escaped_value}&quot;)
      else
        { name =&gt; [*@value].first.to_s }
      end

      unescape_params(params)
    end

    def set(value)
      @value = value
    end

    def unset
      @value = default_value
    end

  protected

    def parse_rails_request_params(params)
      if defined?(ActionController::AbstractRequest)
        ActionController::AbstractRequest.parse_query_parameters(params)
      elsif defined?(ActionController::UrlEncodedPairParser)
        # For Rails &gt; 2.2
        ActionController::UrlEncodedPairParser.parse_query_parameters(params)
      else
        # For Rails &gt; 2.3
        Rack::Utils.parse_nested_query(params)
      end
    end

    def form
      Form.load(@session, form_element)
    end

    def form_element
      parent = @element.parent

      while parent.respond_to?(:parent)
        return parent if parent.name == 'form'
        parent = parent.parent
      end
    end

    def name
      @element[&quot;name&quot;]
    end

    def escaped_value
      CGI.escape(@value.to_s)
    end

    # Because we have to escape it before sending it to the above case statement,
    # we have to make sure we unescape each value when it gets back so assertions
    # involving characters like &lt;, &gt;, and &amp;  work as expected
    def unescape_params(params)
      case params.class.name
      when 'Hash', 'Mash'
        params.each { |key,value| params[key] = unescape_params(value) }
        params
      when 'Array'
        params.collect { |value| unescape_params(value) }
      else
        CGI.unescapeHTML(params)
      end
    end

    def labels
      @labels ||= label_elements.map do |element|
        Label.load(@session, element)
      end
    end

    def label_elements
      return @label_elements unless @label_elements.nil?
      @label_elements = []

      parent = @element.parent
      while parent.respond_to?(:parent)
        if parent.name == 'label'
          @label_elements.push parent
          break
        end
        parent = parent.parent
      end

      unless id.blank?
        @label_elements += form.element.xpath(&quot;.//label[@for = '#{id}']&quot;)
      end

      @label_elements
    end

    def default_value
      @element[&quot;value&quot;]
    end

    def replace_param_value(params, oval, nval)
      output = Hash.new
      params.each do |key, value|
        case value
        when Hash
          value = replace_param_value(value, oval, nval)
        when Array
          value = value.map { |o| o == oval ? nval : oval }
        when oval
          value = nval
        end
        output[key] = value
      end
      output
    end
  end

  class ButtonField &lt; Field #:nodoc:

    def self.xpath_search
      [&quot;.//button&quot;, &quot;.//input[@type = 'submit']&quot;, &quot;.//input[@type = 'button']&quot;, &quot;.//input[@type = 'image']&quot;]
    end

    def to_param
      return nil if @value.nil?
      super
    end

    def default_value
      nil
    end

    def click
      raise_error_if_disabled
      set(@element[&quot;value&quot;]) unless @element[&quot;name&quot;].blank?
      form.submit
    end

  end

  class HiddenField &lt; Field #:nodoc:

    def self.xpath_search
      &quot;.//input[@type = 'hidden']&quot;
    end

    def to_param
      if collection_name?
        super
      else
        checkbox_with_same_name = form.field_named(name, CheckboxField)

        if checkbox_with_same_name.to_param.blank?
          super
        else
          nil
        end
      end
    end

  protected

    def collection_name?
      name =~ /\[\]/
    end

  end

  class CheckboxField &lt; Field #:nodoc:

    def self.xpath_search
      &quot;.//input[@type = 'checkbox']&quot;
    end

    def to_param
      return nil if @value.nil?
      super
    end

    def check
      raise_error_if_disabled
      set(@element[&quot;value&quot;] || &quot;on&quot;)
    end

    def checked?
      @element[&quot;checked&quot;] == &quot;checked&quot;
    end

    def uncheck
      raise_error_if_disabled
      set(nil)
    end

  protected

    def default_value
      if @element[&quot;checked&quot;] == &quot;checked&quot;
        @element[&quot;value&quot;] || &quot;on&quot;
      else
        nil
      end
    end

  end

  class PasswordField &lt; Field #:nodoc:

    def self.xpath_search
      &quot;.//input[@type = 'password']&quot;
    end

  end

  class RadioField &lt; Field #:nodoc:

    def self.xpath_search
      &quot;.//input[@type = 'radio']&quot;
    end

    def to_param
      return nil if @value.nil?
      super
    end

    def choose
      raise_error_if_disabled
      other_options.each do |option|
        option.set(nil)
      end

      set(@element[&quot;value&quot;] || &quot;on&quot;)
    end

    def checked?
      @element[&quot;checked&quot;] == &quot;checked&quot;
    end

  protected

    def other_options
      form.fields.select { |f| f.name == name }
    end

    def default_value
      if @element[&quot;checked&quot;] == &quot;checked&quot;
        @element[&quot;value&quot;] || &quot;on&quot;
      else
        nil
      end
    end

  end

  class TextareaField &lt; Field #:nodoc:

    def self.xpath_search
      &quot;.//textarea&quot;
    end

  protected

    def default_value
      @element.inner_html
    end

  end

  class FileField &lt; Field #:nodoc:

    def self.xpath_search
      &quot;.//input[@type = 'file']&quot;
    end

    attr_accessor :content_type

    def set(value, content_type = nil)
      super(value)
      @content_type = content_type
    end

    def to_param
      if @value.nil?
        super
      else
        replace_param_value(super, @value, test_uploaded_file)
      end
    end

  protected

    def test_uploaded_file
      case Webrat.configuration.mode
      when :rails
        if content_type
          ActionController::TestUploadedFile.new(@value, content_type)
        else
          ActionController::TestUploadedFile.new(@value)
        end
      when :rack, :merb
        Rack::Test::UploadedFile.new(@value, content_type)
      end
    end

  end

  class TextField &lt; Field #:nodoc:
    def self.xpath_search
      [&quot;.//input[@type = 'text']&quot;, &quot;.//input[not(@type)]&quot;]
    end
  end

  class ResetField &lt; Field #:nodoc:
    def self.xpath_search
      [&quot;.//input[@type = 'reset']&quot;]
    end
  end

  class SelectField &lt; Field #:nodoc:

    def self.xpath_search
      [&quot;.//select[not(@multiple)]&quot;]
    end

    def options
      @options ||= SelectOption.load_all(@session, @element)
    end

    def unset(value)
      @value = nil
    end

  protected

    def default_value
      selected_options = @element.xpath(&quot;.//option[@selected = 'selected']&quot;)
      selected_options = @element.xpath(&quot;.//option[position() = 1]&quot;) if selected_options.empty?

      selected_options.map do |option|
        return &quot;&quot; if option.nil?
        option[&quot;value&quot;] || option.inner_html
      end.uniq.first
    end

  end

  class MultipleSelectField &lt; Field #:nodoc:

    def self.xpath_search
      [&quot;.//select[@multiple='multiple']&quot;]
    end

    def options
      @options ||= SelectOption.load_all(@session, @element)
    end

    def set(value)
      @value &lt;&lt; value
    end

    def unset(value)
      @value.delete(value)
    end

    # We have to overide how the uri string is formed when dealing with multiples
    # Where normally a select field might produce   name=value   with a multiple,
    # we need to form something like   name[]=value1&amp;name[]=value2
    def to_param
      return nil if disabled?

      uri_string = @value.collect {|value| &quot;#{name}=#{CGI.escape(value)}&quot;}.join(&quot;&amp;&quot;)
      params = case Webrat.configuration.mode
      when :rails
        parse_rails_request_params(uri_string)
      when :merb
        ::Merb::Parse.query(uri_string)
      else
        { name =&gt; @value }
      end

      unescape_params(params)
    end

  protected

    # Overwrite SelectField definition because we don't want to select the first option
    # (mutliples don't select the first option unlike their non multiple versions)
    def default_value
      selected_options = @element.xpath(&quot;.//option[@selected = 'selected']&quot;)

      selected_options.map do |option|
        return &quot;&quot; if option.nil?
        option[&quot;value&quot;] || option.inner_html
      end.uniq
    end

  end

end
</pre>
    </div>