  <div id="fileHeader">
    <h1>have_xpath.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/webrat/core/matchers/have_xpath.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:11:40 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;webrat/core/xml/nokogiri&quot;
require &quot;webrat/core/xml/rexml&quot;

module Webrat
  module Matchers
    
    class HaveXpath #:nodoc:
      def initialize(expected, options = {}, &amp;block)
        @expected = expected
        @options  = options
        @block    = block
      end
    
      def matches?(stringlike, &amp;block)
        @block ||= block
        matched = matches(stringlike)
        
        if @options[:count]
          matched.size == @options[:count] &amp;&amp; (!@block || @block.call(matched))
        else
          matched.any? &amp;&amp; (!@block || @block.call(matched))
        end
      end
      
      def matches(stringlike)
        if Webrat.configuration.parse_with_nokogiri?
          nokogiri_matches(stringlike)
        else
          rexml_matches(stringlike)
        end
      end
    
      def rexml_matches(stringlike)
        if REXML::Node === stringlike || Array === stringlike
          @query = query.map { |q| q.gsub(%r'//', './') }
        else
          @query = query
        end

        add_options_conditions_to(@query)

        @document = Webrat.rexml_document(stringlike)

        @query.map do |q|
          if @document.is_a?(Array)
            @document.map { |d| REXML::XPath.match(d, q) }
          else
            REXML::XPath.match(@document, q)
          end
        end.flatten.compact
      end
    
      def nokogiri_matches(stringlike)
        if Nokogiri::XML::NodeSet === stringlike
          @query = query.gsub(%r'//', './')
        else
          @query = query
        end
        
        add_options_conditions_to(@query)
        
        @document = Webrat::XML.document(stringlike)
        @document.xpath(*@query)
      end
      
      def add_options_conditions_to(query)
        add_attributes_conditions_to(query)
        add_content_condition_to(query)
      end
      
      def add_attributes_conditions_to(query)
        attribute_conditions = []
        
        @options.each do |key, value|
          next if [:content, :count].include?(key)
          attribute_conditions &lt;&lt; &quot;@#{key} = #{xpath_escape(value)}&quot;
        end
        
        if attribute_conditions.any?
          query &lt;&lt; &quot;[#{attribute_conditions.join(' and ')}]&quot;
        end
      end
      
      def add_content_condition_to(query)
        if @options[:content]
          query &lt;&lt; &quot;[contains(., #{xpath_escape(@options[:content])})]&quot;
        end
      end
      
      def query
        @expected
      end
    
      # ==== Returns
      # String:: The failure message.
      def failure_message
        &quot;expected following text to match xpath #{@expected}:\n#{@document}&quot;
      end

      # ==== Returns
      # String:: The failure message to be displayed in negative matches.
      def negative_failure_message
        &quot;expected following text to not match xpath #{@expected}:\n#{@document}&quot;
      end
      
    protected
    
      def xpath_escape(string)
        if string.include?(&quot;'&quot;) &amp;&amp; string.include?('&quot;')
          parts = string.split(&quot;'&quot;).map do |part|
            &quot;'#{part}'&quot;
          end
          
          &quot;concat(&quot; + parts.join(&quot;, \&quot;'\&quot;, &quot;) + &quot;)&quot;
        elsif string.include?(&quot;'&quot;)
          &quot;\&quot;#{string}\&quot;&quot;
        else
          &quot;'#{string}'&quot;
        end
      end
      
    end
    
    # Matches HTML content against an XPath query
    #
    # ==== Parameters
    # expected&lt;String&gt;:: The XPath query to look for.
    #
    # ==== Returns
    # HaveXpath:: A new have xpath matcher.
    def have_xpath(expected, options = {}, &amp;block)
      HaveXpath.new(expected, options, &amp;block)
    end
    alias_method :match_xpath, :have_xpath
    
    def assert_have_xpath(expected, options = {}, &amp;block)
      hs = HaveXpath.new(expected, options, &amp;block)
      assert hs.matches?(response_body), hs.failure_message
    end
    
    def assert_have_no_xpath(expected, options = {}, &amp;block)
      hs = HaveXpath.new(expected, options, &amp;block)
      assert !hs.matches?(response_body), hs.negative_failure_message
    end
    
  end
end</pre>
    </div>