  <div id="fileHeader">
    <h1>have_xpath.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/webrat/core/matchers/have_xpath.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 20:11:08 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;webrat/core/xml&quot;

module Webrat
  module Matchers

    class HaveXpath #:nodoc:
      def initialize(expected, options = {}, &amp;block)
        @expected = expected
        @options  = options
        @block    = block
      end

      def matches?(stringlike, &amp;block)
        @block ||= block
        matched = matches(stringlike)

        @block.call(matched) if @block

        if @options[:count]
          matched.size == @options[:count].to_i
        else
          matched.any?
        end
      end

      def matches(stringlike)
        nokogiri_matches(stringlike)
      end

      def nokogiri_matches(stringlike)
        if Nokogiri::XML::NodeSet === stringlike
          @query = query.gsub(%r'^//', './/')
        else
          @query = query
        end

        add_options_conditions_to(@query)

        @document = Webrat::XML.document(stringlike)
        @document.xpath(*@query)
      end

      def add_options_conditions_to(query)
        add_attributes_conditions_to(query)
        add_content_condition_to(query)
      end

      def add_attributes_conditions_to(query)
        attribute_conditions = []

        @options.each do |key, value|
          next if [:content, :count].include?(key)
          attribute_conditions &lt;&lt; &quot;@#{key} = #{xpath_escape(value)}&quot;
        end

        if attribute_conditions.any?
          query &lt;&lt; &quot;[#{attribute_conditions.join(' and ')}]&quot;
        end
      end

      def add_content_condition_to(query)
        if @options[:content]
          query &lt;&lt; &quot;[contains(., #{xpath_escape(@options[:content])})]&quot;
        end
      end

      def query
        @expected
      end

      # ==== Returns
      # String:: The failure message.
      def failure_message
        &quot;expected following text to match xpath #{@expected}:\n#{@document}&quot;
      end

      # ==== Returns
      # String:: The failure message to be displayed in negative matches.
      def negative_failure_message
        &quot;expected following text to not match xpath #{@expected}:\n#{@document}&quot;
      end

    protected

      def xpath_escape(string)
        if string.include?(&quot;'&quot;) &amp;&amp; string.include?('&quot;')
          parts = string.split(&quot;'&quot;).map do |part|
            &quot;'#{part}'&quot;
          end

          &quot;concat(&quot; + parts.join(&quot;, \&quot;'\&quot;, &quot;) + &quot;)&quot;
        elsif string.include?(&quot;'&quot;)
          &quot;\&quot;#{string}\&quot;&quot;
        else
          &quot;'#{string}'&quot;
        end
      end

    end

    # Matches HTML content against an XPath query
    #
    # ==== Parameters
    # expected&lt;String&gt;:: The XPath query to look for.
    #
    # ==== Returns
    # HaveXpath:: A new have xpath matcher.
    def have_xpath(expected, options = {}, &amp;block)
      HaveXpath.new(expected, options, &amp;block)
    end
    alias_method :match_xpath, :have_xpath

    def assert_have_xpath(expected, options = {}, &amp;block)
      hs = HaveXpath.new(expected, options, &amp;block)
      assert hs.matches?(response_body), hs.failure_message
    end

    def assert_have_no_xpath(expected, options = {}, &amp;block)
      hs = HaveXpath.new(expected, options, &amp;block)
      assert !hs.matches?(response_body), hs.negative_failure_message
    end

  end
end
</pre>
    </div>