  <div id="fileHeader">
    <h1>selenium_session.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/webrat/selenium/selenium_session.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:44:05 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;webrat/core/save_and_open_page&quot;
require &quot;webrat/selenium/selenium_rc_server&quot;
require &quot;webrat/selenium/application_server_factory&quot;
require &quot;webrat/selenium/application_servers/base&quot;

require &quot;selenium&quot;

module Webrat
  class TimeoutError &lt; WebratError
  end

  class SeleniumResponse
    attr_reader :body
    attr_reader :session

    def initialize(session, body)
      @session = session
      @body = body
    end

    def selenium
      session.selenium
    end
  end

  class SeleniumSession
    include Webrat::SaveAndOpenPage
    include Webrat::Selenium::SilenceStream

    def initialize(*args) # :nodoc:
    end

    def simulate
    end

    def automate
      yield
    end

    def visit(url)
      selenium.open(url)
    end

    webrat_deprecate :visits, :visit

    def fill_in(field_identifier, options)
      locator = &quot;webrat=#{field_identifier}&quot;
      selenium.wait_for_element locator, :timeout_in_seconds =&gt; 5
      selenium.type(locator, &quot;#{options[:with]}&quot;)
    end

    webrat_deprecate :fills_in, :fill_in

    def response
      SeleniumResponse.new(self, response_body)
    end

    def response_body #:nodoc:
      selenium.get_html_source
    end

    def current_url
      selenium.location
    end

    def click_button(button_text_or_regexp = nil, options = {})
      if button_text_or_regexp.is_a?(Hash) &amp;&amp; options == {}
        pattern, options = nil, button_text_or_regexp
      elsif button_text_or_regexp
        pattern = adjust_if_regexp(button_text_or_regexp)
      end
      pattern ||= '*'
      locator = &quot;button=#{pattern}&quot;

      selenium.wait_for_element locator, :timeout_in_seconds =&gt; 5
      selenium.click locator
    end

    webrat_deprecate :clicks_button, :click_button

    def click_link(link_text_or_regexp, options = {})
      if link_text_or_regexp.is_a?(Regexp)
        pattern = &quot;evalregex:#{link_text_or_regexp.inspect}&quot;
      else
        pattern = link_text_or_regexp.to_s
      end

      locator = &quot;webratlink=#{pattern}&quot;
      selenium.wait_for_element locator, :timeout_in_seconds =&gt; 5
      selenium.click locator
    end

    webrat_deprecate :clicks_link, :click_link

    def click_link_within(selector, link_text, options = {})
      locator = &quot;webratlinkwithin=#{selector}|#{link_text}&quot;
      selenium.wait_for_element locator, :timeout_in_seconds =&gt; 5
      selenium.click locator
    end

    webrat_deprecate :clicks_link_within, :click_link_within

    def select(option_text, options = {})
      id_or_name_or_label = options[:from]

      if id_or_name_or_label
        select_locator = &quot;webrat=#{id_or_name_or_label}&quot;
      else
        select_locator = &quot;webratselectwithoption=#{option_text}&quot;
      end

      selenium.wait_for_element select_locator, :timeout_in_seconds =&gt; 5
      selenium.select(select_locator, option_text)
    end

    webrat_deprecate :selects, :select

    def choose(label_text)
      locator = &quot;webrat=#{label_text}&quot;
      selenium.wait_for_element locator, :timeout_in_seconds =&gt; 5
      selenium.click locator
    end

    webrat_deprecate :chooses, :choose

    def check(label_text)
      locator = &quot;webrat=#{label_text}&quot;
      selenium.wait_for_element locator, :timeout_in_seconds =&gt; 5
      selenium.click locator
    end
    alias_method :uncheck, :check

    webrat_deprecate :checks, :check

    def fire_event(field_identifier, event)
      locator = &quot;webrat=#{Regexp.escape(field_identifier)}&quot;
      selenium.fire_event(locator, &quot;#{event}&quot;)
    end

    def key_down(field_identifier, key_code)
      locator = &quot;webrat=#{Regexp.escape(field_identifier)}&quot;
      selenium.key_down(locator, key_code)
    end

    def key_up(field_identifier, key_code)
      locator = &quot;webrat=#{Regexp.escape(field_identifier)}&quot;
      selenium.key_up(locator, key_code)
    end

    def wait_for(params={})
      timeout = params[:timeout] || 5
      message = params[:message] || &quot;Timeout exceeded&quot;

      begin_time = Time.now

      while (Time.now - begin_time) &lt; timeout
        value = nil

        begin
          value = yield
        rescue Exception =&gt; e
          unless is_ignorable_wait_for_exception?(e)
            raise e
          end
        end

        return value if value

        sleep 0.25
      end

      error_message = &quot;#{message} (after #{timeout} sec)&quot;

      if $browser
        error_message += &lt;&lt;-EOS


HTML of the page was:

#{selenium.get_html_source}&quot;
EOS
      end

      raise Webrat::TimeoutError.new(error_message)
      true
    end

    def selenium
      return $browser if $browser
      setup
      $browser
    end

    webrat_deprecate :browser, :selenium


    def save_and_open_screengrab
      return unless File.exist?(saved_page_dir)

      filename = &quot;#{saved_page_dir}/webrat-#{Time.now.to_i}.png&quot;

      if $browser.chrome_backend?
        $browser.capture_entire_page_screenshot(filename, '')
      else
        $browser.capture_screenshot(filename)
      end
      open_in_browser(filename)

    end

    protected
    def is_ignorable_wait_for_exception?(exception) #:nodoc:
      if defined?(::Spec::Expectations::ExpectationNotMetError)
        return true if exception.class == ::Spec::Expectations::ExpectationNotMetError
      end
      return true if [::Selenium::CommandError, Webrat::WebratError].include?(exception.class)
      return false
    end

    def setup #:nodoc:
      Webrat::Selenium::SeleniumRCServer.boot
      Webrat::Selenium::ApplicationServerFactory.app_server_instance.boot

      create_browser
      $browser.start

      extend_selenium
      define_location_strategies
      $browser.window_maximize
    end


    def create_browser
      $browser = ::Selenium::Client::Driver.new(Webrat.configuration.selenium_server_address || &quot;localhost&quot;,
      Webrat.configuration.selenium_server_port, Webrat.configuration.selenium_browser_key, &quot;http://#{Webrat.configuration.application_address}:#{Webrat.configuration.application_port}&quot;)
      $browser.set_speed(0) unless Webrat.configuration.selenium_server_address

      at_exit do
        silence_stream(STDOUT) do
          $browser.stop
        end
      end
    end

    def adjust_if_regexp(text_or_regexp) #:nodoc:
      if text_or_regexp.is_a?(Regexp)
        &quot;evalregex:#{text_or_regexp.inspect}&quot;
      else
        &quot;evalregex:/#{text_or_regexp}/&quot;
      end
    end

    def extend_selenium #:nodoc:
      extensions_file = File.join(File.dirname(__FILE__), &quot;selenium_extensions.js&quot;)
      extenions_js = File.read(extensions_file)
      selenium.get_eval(extenions_js)
    end

    def define_location_strategies #:nodoc:
      Dir[File.join(File.dirname(__FILE__), &quot;location_strategy_javascript&quot;, &quot;*.js&quot;)].sort.each do |file|
        strategy_js = File.read(file)
        strategy_name = File.basename(file, '.js')
        selenium.add_location_strategy(strategy_name, strategy_js)
      end
    end
  end
end
</pre>
    </div>