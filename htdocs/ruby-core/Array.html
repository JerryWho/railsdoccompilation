<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Array</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (A)</a> &raquo; 
    
    
    <span class="title">Array</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Array
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Array</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
      <dt class="r2">Includes:</dt>
      <dd class="r2"><span class='object_link'><a href="Enumerable.html" title="Enumerable (module)">Enumerable</a></span></dd>
      
    
  
  
  
    <dt class="r1 last">Defined in:</dt>
    <dd class="r1 last">array.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
Arrays are ordered, integer-indexed collections of any object. Array
indexing starts at 0, as in C or Java.  A negative index is assumed to be
relative to the end of the array--that is, an index of -1 indicates
the last element of the array, -2 is the next to last element in the array,
and so on.
</p>


  </div>
</div>
<div class="tags">
  
</div>

  
  
  
  

  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D-class_method" title="[] (class method)">+ (Object) <strong>[]</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array populated with the given objects.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_convert-class_method" title="try_convert (class method)">+ (Array<sup>?</sup>) <strong>try_convert</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Try to convert <em>obj</em> into an array, using <tt>to_ary</tt> method.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%26-instance_method" title="#&amp; (instance method)">- (Object) <strong>&amp;</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set Intersection--Returns a new array containing elements common to
the two arrays, with no duplicates.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2A-instance_method" title="#* (instance method)">- (Object) <strong>*</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Repetition--With a String argument, equivalent to self.join(str).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2B-instance_method" title="#+ (instance method)">- (Object) <strong>+</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Concatenation--Returns a new array built by concatenating the two
arrays together to produce a third array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#--instance_method" title="#- (instance method)">- (Object) <strong>-</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Array Difference--Returns a new array that is a copy of the original
array, removing any items that also appear in <em>other_ary</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3C-instance_method" title="#&lt;&lt; (instance method)">- (Object) <strong>&lt;&lt;</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Append--Pushes the given object on to the end of this array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3D%3E-instance_method" title="#&lt;=&gt; (instance method)">- (-1, ...) <strong>&lt;=&gt;</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Comparison--Returns an integer (-1, 0, or +1) if this array is less
than, equal to, or greater than <em>other_ary</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Object) <strong>==</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equality--Two arrays are equal if they contain the same number of
elements and if each element is equal to (according to Object.==) the
corresponding element in the other array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D-instance_method" title="#[] (instance method)">- (Object) <strong>[]</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Element Reference--Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D%3D-instance_method" title="#[]= (instance method)">- (Object) <strong>[]=</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Element Assignment--Sets the element at <em>index</em>, or replaces a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or replaces a subarray specified by <em>range</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#assoc-instance_method" title="#assoc (instance method)">- (nil) <strong>assoc</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Searches through an array whose elements are also arrays comparing
<em>obj</em> with the first element of each contained array using obj.==.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#at-instance_method" title="#at (instance method)">- (Object<sup>?</sup>) <strong>at</strong>(index) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the element at <em>index</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clear-instance_method" title="#clear (instance method)">- (Object) <strong>clear</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Removes all elements from <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#collect-instance_method" title="#collect (instance method)">- (Object) <strong>collect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes <em>block</em> once for each element of <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#collect%21-instance_method" title="#collect! (instance method)">- (Object) <strong>collect!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block once for each element of <tt>self</tt>, replacing the
element with the value returned by <em>block</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#combination-instance_method" title="#combination (instance method)">- (Object) <strong>combination</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
When invoked with a block, yields all combinations of length <em>n</em> of
elements from <em>ary</em> and then returns <em>ary</em> itself.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#compact-instance_method" title="#compact (instance method)">- (Object) <strong>compact</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <tt>self</tt> with all <tt>nil</tt> elements removed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#compact%21-instance_method" title="#compact! (instance method)">- (nil) <strong>compact!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Removes <tt>nil</tt> elements from the array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#concat-instance_method" title="#concat (instance method)">- (Object) <strong>concat</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Appends the elements of <em>other_ary</em> to <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#count-instance_method" title="#count (instance method)">- (Object) <strong>count</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the number of elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cycle-instance_method" title="#cycle (instance method)">- (Object) <strong>cycle</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Calls <em>block</em> for each element repeatedly <em>n</em> times or
forever if none or <tt>nil</tt> is given.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#delete-instance_method" title="#delete (instance method)">- (Object) <strong>delete</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Deletes items from <tt>self</tt> that are equal to <em>obj</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#delete_at-instance_method" title="#delete_at (instance method)">- (Object<sup>?</sup>) <strong>delete_at</strong>(index) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Deletes the element at the specified index, returning that element, or
<tt>nil</tt> if the index is out of range.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#delete_if-instance_method" title="#delete_if (instance method)">- (Object) <strong>delete_if</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Deletes every element of <tt>self</tt> for which <em>block</em> evaluates
to true.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#drop-instance_method" title="#drop (instance method)">- (Object) <strong>drop</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Drops first n elements from <em>ary</em>, and returns rest elements in an
array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#drop_while-instance_method" title="#drop_while (instance method)">- (Object) <strong>drop_while</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Drops elements up to, but not including, the first element for which the
block returns <tt>nil</tt> or <tt>false</tt> and returns an array
containing the remaining elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each-instance_method" title="#each (instance method)">- (Object) <strong>each</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Calls <em>block</em> once for each element in <tt>self</tt>, passing that
element as a parameter.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_index-instance_method" title="#each_index (instance method)">- (Object) <strong>each_index</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Same as <tt>Array#each</tt>, but passes the index of the element instead of
the element itself.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#empty%3F-instance_method" title="#empty? (instance method)">- (Boolean) <strong>empty?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <tt>self</tt> contains no elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">- (Boolean) <strong>eql?</strong>(other) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <tt>self</tt> and <em>other</em> are the same
object, or are both arrays with the same content.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fetch-instance_method" title="#fetch (instance method)">- (Object) <strong>fetch</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Tries to return the element at position <em>index</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fill-instance_method" title="#fill (instance method)">- (Object) <strong>fill</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
The first three forms set the selected elements of <tt>self</tt> (which may
be the entire array) to <em>obj</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#find_index-instance_method" title="#find_index (instance method)">- (Object) <strong>find_index</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the index of the first object in <tt>self</tt> such that is
<tt>==</tt> to <em>obj</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#first-instance_method" title="#first (instance method)">- (Object) <strong>first</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the first element, or the first <tt>n</tt> elements, of the array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flatten-instance_method" title="#flatten (instance method)">- (Object) <strong>flatten</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array that is a one-dimensional flattening of this array
(recursively).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flatten%21-instance_method" title="#flatten! (instance method)">- (Object) <strong>flatten!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Flattens <tt>self</tt> in place.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#frozen%3F-instance_method" title="#frozen? (instance method)">- (Boolean) <strong>frozen?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return <tt>true</tt> if this array is frozen (or temporarily frozen while
being sorted).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hash-instance_method" title="#hash (instance method)">- (Fixnum) <strong>hash</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Compute a hash-code for this array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#include%3F-instance_method" title="#include? (instance method)">- (Boolean) <strong>include?</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if the given object is present in <tt>self</tt> (that
is, if any object <tt>==</tt> <em>anObject</em>), <tt>false</tt> otherwise.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#index-instance_method" title="#index (instance method)">- (Object) <strong>index</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the index of the first object in <tt>self</tt> such that is
<tt>==</tt> to <em>obj</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replace-instance_method" title="#replace (instance method)">- (Object) <strong>replace</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Replaces the contents of <tt>self</tt> with the contents of
<em>other_ary</em>, truncating or expanding if necessary.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#insert-instance_method" title="#insert (instance method)">- (Object) <strong>insert</strong>(index, obj...) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Inserts the given values before the element with the given index (which may
be negative).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (Object) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates a string representation of <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#join-instance_method" title="#join (instance method)">- (String) <strong>join</strong>(sep = $,) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a string created by converting each element of the array to a
string, separated by <em>sep</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#keep_if-instance_method" title="#keep_if (instance method)">- (Object) <strong>keep_if</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Deletes every element of <tt>self</tt> for which <em>block</em> evaluates
to false.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#last-instance_method" title="#last (instance method)">- (Object) <strong>last</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the last element(s) of <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#length-instance_method" title="#length (instance method)">- (Integer) <strong>length</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the number of elements in <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#map-instance_method" title="#map (instance method)">- (Object) <strong>map</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes <em>block</em> once for each element of <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#map%21-instance_method" title="#map! (instance method)">- (Object) <strong>map!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block once for each element of <tt>self</tt>, replacing the
element with the value returned by <em>block</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pack-instance_method" title="#pack (instance method)">- (Object) <strong>pack</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Packs the contents of <em>arr</em> into a binary sequence according to the
directives in <em>aTemplateString</em> (see the table below) Directives
``A,&#8217;&#8217; ``a,&#8217;&#8217; and ``Z&#8217;&#8217; may be followed
by a count, which gives the width of the resulting field.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#permutation-instance_method" title="#permutation (instance method)">- (Object) <strong>permutation</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
When invoked with a block, yield all permutations of length <em>n</em> of
the elements of <em>ary</em>, then return the array itself.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pop-instance_method" title="#pop (instance method)">- (Object) <strong>pop</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Removes the last element from <tt>self</tt> and returns it, or <tt>nil</tt>
if the array is empty.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#product-instance_method" title="#product (instance method)">- (Object) <strong>product</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array of all combinations of elements from all arrays, The
length of the returned array is the product of the length of <tt>self</tt>
and the argument arrays.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#push-instance_method" title="#push (instance method)">- (Object) <strong>push</strong>(obj, ...) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Append--Pushes the given object(s) on to the end of this array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rassoc-instance_method" title="#rassoc (instance method)">- (nil) <strong>rassoc</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Searches through the array whose elements are also arrays.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reject-instance_method" title="#reject (instance method)">- (Object) <strong>reject</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array containing the items in <tt>self</tt> for which the
block is not true.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reject%21-instance_method" title="#reject! (instance method)">- (Object) <strong>reject!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equivalent to <tt>Array#delete_if</tt>, deleting elements from
<tt>self</tt> for which the block evaluates to true, but returns
<tt>nil</tt> if no changes were made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#repeated_combination-instance_method" title="#repeated_combination (instance method)">- (Object) <strong>repeated_combination</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
When invoked with a block, yields all repeated combinations of length
<em>n</em> of elements from <em>ary</em> and then returns <em>ary</em>
itself.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#repeated_permutation-instance_method" title="#repeated_permutation (instance method)">- (Object) <strong>repeated_permutation</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
When invoked with a block, yield all repeated permutations of length
<em>n</em> of the elements of <em>ary</em>, then return the array itself.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replace-instance_method" title="#replace (instance method)">- (Object) <strong>replace</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Replaces the contents of <tt>self</tt> with the contents of
<em>other_ary</em>, truncating or expanding if necessary.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reverse-instance_method" title="#reverse (instance method)">- (Object) <strong>reverse</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array containing <tt>self</tt>&#8217;s elements in reverse
order.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reverse%21-instance_method" title="#reverse! (instance method)">- (Object) <strong>reverse!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reverses <tt>self</tt> in place.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reverse_each-instance_method" title="#reverse_each (instance method)">- (Object) <strong>reverse_each</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Same as <tt>Array#each</tt>, but traverses <tt>self</tt> in reverse order.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rindex-instance_method" title="#rindex (instance method)">- (Object) <strong>rindex</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the index of the last object in <tt>self</tt> <tt>==</tt> to
<em>obj</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rotate-instance_method" title="#rotate (instance method)">- (Object) <strong>rotate</strong>([n = 1]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns new array by rotating <tt>self</tt>, whose first element is the
element at <tt>cnt</tt> in <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rotate%21-instance_method" title="#rotate! (instance method)">- (Object) <strong>rotate!</strong>(cnt = 1) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Rotates <tt>self</tt> in place so that the element at <tt>cnt</tt> comes
first, and returns <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sample-instance_method" title="#sample (instance method)">- (Object) <strong>sample</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Choose a random element or <tt>n</tt> random elements from the array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select-instance_method" title="#select (instance method)">- (Object) <strong>select</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block passing in successive elements from <tt>self</tt>,
returning an array containing those elements for which the block returns a
true value (equivalent to <tt>Enumerable#select</tt>).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select%21-instance_method" title="#select! (instance method)">- (Object) <strong>select!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block passing in successive elements from <tt>self</tt>,
deleting elements for which the block returns a false value.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#shift-instance_method" title="#shift (instance method)">- (Object) <strong>shift</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the first element of <tt>self</tt> and removes it (shifting all
other elements down by one).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#shuffle-instance_method" title="#shuffle (instance method)">- (Object) <strong>shuffle</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array with elements of this array shuffled.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#shuffle%21-instance_method" title="#shuffle! (instance method)">- (Object) <strong>shuffle!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Shuffles elements in <tt>self</tt> in place.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#slice-instance_method" title="#slice (instance method)">- (Object) <strong>slice</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Element Reference--Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#slice%21-instance_method" title="#slice! (instance method)">- (Object) <strong>slice!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Deletes the element(s) given by an index (optionally with a length) or by a
range.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sort-instance_method" title="#sort (instance method)">- (Object) <strong>sort</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array created by sorting <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sort%21-instance_method" title="#sort! (instance method)">- (Object) <strong>sort!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sorts <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sort_by%21-instance_method" title="#sort_by! (instance method)">- (Object) <strong>sort_by!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sorts <tt>self</tt> in place using a set of keys generated by mapping the
values in <tt>self</tt> through the given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#take-instance_method" title="#take (instance method)">- (Object) <strong>take</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns first n elements from <em>ary</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#take_while-instance_method" title="#take_while (instance method)">- (Object) <strong>take_while</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes elements to the block until the block returns <tt>nil</tt> or
<tt>false</tt>, then stops iterating and returns an array of all prior
elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_a-instance_method" title="#to_a (instance method)">- (Object) <strong>to_a</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_ary-instance_method" title="#to_ary (instance method)">- (Object) <strong>to_ary</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#transpose-instance_method" title="#transpose (instance method)">- (Object) <strong>transpose</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Assumes that <tt>self</tt> is an array of arrays and transposes the rows
and columns.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#uniq-instance_method" title="#uniq (instance method)">- (Object) <strong>uniq</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array by removing duplicate values in <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#uniq%21-instance_method" title="#uniq! (instance method)">- (nil) <strong>uniq!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Removes duplicate elements from <tt>self</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unshift-instance_method" title="#unshift (instance method)">- (Object) <strong>unshift</strong>(obj, ...) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Prepends objects to the front of <tt>self</tt>, moving other elements
upwards.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#values_at-instance_method" title="#values_at (instance method)">- (Object) <strong>values_at</strong>(selector, ...) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array containing the elements in <tt>self</tt> corresponding to
the given selector(s).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zip-instance_method" title="#zip (instance method)">- (Object) <strong>zip</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Converts any arguments to arrays, then merges elements of <tt>self</tt>
with corresponding elements from each argument.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%7C-instance_method" title="#| (instance method)">- (Object) <strong>|</strong>(other_ary) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Set Union--Returns a new array by joining this array with
<em>other_ary</em>, removing duplicates.
</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  <h3 class="inherited">Methods included from <span class='object_link'><a href="Enumerable.html" title="Enumerable (module)">Enumerable</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="Enumerable.html#all%3F-instance_method" title="Enumerable#all? (method)">#all?</a></span>, <span class='object_link'><a href="Enumerable.html#any%3F-instance_method" title="Enumerable#any? (method)">#any?</a></span>, <span class='object_link'><a href="Enumerable.html#chunk-instance_method" title="Enumerable#chunk (method)">#chunk</a></span>, <span class='object_link'><a href="Enumerable.html#collect_concat-instance_method" title="Enumerable#collect_concat (method)">#collect_concat</a></span>, <span class='object_link'><a href="Enumerable.html#detect-instance_method" title="Enumerable#detect (method)">#detect</a></span>, <span class='object_link'><a href="Enumerable.html#each_cons-instance_method" title="Enumerable#each_cons (method)">#each_cons</a></span>, <span class='object_link'><a href="Enumerable.html#each_entry-instance_method" title="Enumerable#each_entry (method)">#each_entry</a></span>, <span class='object_link'><a href="Enumerable.html#each_slice-instance_method" title="Enumerable#each_slice (method)">#each_slice</a></span>, <span class='object_link'><a href="Enumerable.html#each_with_index-instance_method" title="Enumerable#each_with_index (method)">#each_with_index</a></span>, <span class='object_link'><a href="Enumerable.html#each_with_object-instance_method" title="Enumerable#each_with_object (method)">#each_with_object</a></span>, <span class='object_link'><a href="Enumerable.html#entries-instance_method" title="Enumerable#entries (method)">#entries</a></span>, <span class='object_link'><a href="Enumerable.html#find-instance_method" title="Enumerable#find (method)">#find</a></span>, <span class='object_link'><a href="Enumerable.html#find_all-instance_method" title="Enumerable#find_all (method)">#find_all</a></span>, <span class='object_link'><a href="Enumerable.html#flat_map-instance_method" title="Enumerable#flat_map (method)">#flat_map</a></span>, <span class='object_link'><a href="Enumerable.html#grep-instance_method" title="Enumerable#grep (method)">#grep</a></span>, <span class='object_link'><a href="Enumerable.html#group_by-instance_method" title="Enumerable#group_by (method)">#group_by</a></span>, <span class='object_link'><a href="Enumerable.html#inject-instance_method" title="Enumerable#inject (method)">#inject</a></span>, <span class='object_link'><a href="Enumerable.html#max-instance_method" title="Enumerable#max (method)">#max</a></span>, <span class='object_link'><a href="Enumerable.html#max_by-instance_method" title="Enumerable#max_by (method)">#max_by</a></span>, <span class='object_link'><a href="Enumerable.html#member%3F-instance_method" title="Enumerable#member? (method)">#member?</a></span>, <span class='object_link'><a href="Enumerable.html#min-instance_method" title="Enumerable#min (method)">#min</a></span>, <span class='object_link'><a href="Enumerable.html#min_by-instance_method" title="Enumerable#min_by (method)">#min_by</a></span>, <span class='object_link'><a href="Enumerable.html#minmax-instance_method" title="Enumerable#minmax (method)">#minmax</a></span>, <span class='object_link'><a href="Enumerable.html#minmax_by-instance_method" title="Enumerable#minmax_by (method)">#minmax_by</a></span>, <span class='object_link'><a href="Enumerable.html#none%3F-instance_method" title="Enumerable#none? (method)">#none?</a></span>, <span class='object_link'><a href="Enumerable.html#one%3F-instance_method" title="Enumerable#one? (method)">#one?</a></span>, <span class='object_link'><a href="Enumerable.html#partition-instance_method" title="Enumerable#partition (method)">#partition</a></span>, <span class='object_link'><a href="Enumerable.html#reduce-instance_method" title="Enumerable#reduce (method)">#reduce</a></span>, <span class='object_link'><a href="Enumerable.html#slice_before-instance_method" title="Enumerable#slice_before (method)">#slice_before</a></span>, <span class='object_link'><a href="Enumerable.html#sort_by-instance_method" title="Enumerable#sort_by (method)">#sort_by</a></span></p>
<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(size = 0, obj = nil) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(array) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(size) {|index| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array. In the first form, the new array is empty. In the
second it is created with <em>size</em> copies of <em>obj</em> (that is,
<em>size</em> references to the same <em>obj</em>). The third form creates
a copy of the array passed as a parameter (the array is generated by
calling to_ary  on the parameter). In the last form, an array of the given
size is created. Each element in this array is calculated by passing the
element&#8217;s index to the given block and storing the return value.
</p>
<pre class="code">
   Array.new
   Array.new(2)
   Array.new(5, &quot;A&quot;)

   # only one copy of the object is created
   a = Array.new(2, Hash.new)
   a[0]['cat'] = 'feline'
   a
   a[1]['cat'] = 'Felix'
   a

   # here multiple copies are created
   a = Array.new(2) { Hash.new }
   a[0]['cat'] = 'feline'
   a

   squares = Array.new(5) {|i| i*i}
   squares

   copy = Array.new(squares)</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong>(size) {|index| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>index</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     Array.new(size=0, obj=nil)
 *     Array.new(array)
 *     Array.new(size) {|index| block }
 *
 *  Returns a new array. In the first form, the new array is
 *  empty. In the second it is created with _size_ copies of _obj_
 *  (that is, _size_ references to the same
 *  _obj_). The third form creates a copy of the array
 *  passed as a parameter (the array is generated by calling
 *  to_ary  on the parameter). In the last form, an array
 *  of the given size is created. Each element in this array is
 *  calculated by passing the element's index to the given block and
 *  storing the return value.
 *
 *     Array.new
 *     Array.new(2)
 *     Array.new(5, &quot;A&quot;)
 *
 *     # only one copy of the object is created
 *     a = Array.new(2, Hash.new)
 *     a[0]['cat'] = 'feline'
 *     a
 *     a[1]['cat'] = 'Felix'
 *     a
 *
 *     # here multiple copies are created
 *     a = Array.new(2) { Hash.new }
 *     a[0]['cat'] = 'feline'
 *     a
 *
 *     squares = Array.new(5) {|i| i*i}
 *     squares
 *
 *     copy = Array.new(squares)
 */

static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
    if (ARY_OWNS_HEAP_P(ary) &amp;&amp; RARRAY_PTR(ary)) {
        xfree(RARRAY_PTR(ary));
    }
        rb_ary_unshare_safe(ary);
        FL_SET_EMBED(ary);
    ARY_SET_EMBED_LEN(ary, 0);
    if (rb_block_given_p()) {
        rb_warning(&quot;given block not used&quot;);
    }
    return ary;
    }
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
    val = rb_check_array_type(size);
    if (!NIL_P(val)) {
        rb_ary_replace(ary, val);
        return ary;
    }
    }

    len = NUM2LONG(size);
    if (len &lt; 0) {
    rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
    rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
    long i;

    if (argc == 2) {
        rb_warn(&quot;block supersedes default value argument&quot;);
    }
    for (i=0; i&lt;len; i++) {
        rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
        ARY_SET_LEN(ary, i + 1);
    }
    }
    else {
    memfill(RARRAY_PTR(ary), len, val);
    ARY_SET_LEN(ary, len);
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="[]-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array populated with the given objects.
</p>
<pre class="code">
  Array.[]( 1, 'a', /^A/ )
  Array[ 1, 'a', /^A/ ]
  [ 1, 'a', /^A/ ]</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
* Returns a new array populated with the given objects.
*
*   Array.[]( 1, 'a', /^A/ )
*   Array[ 1, 'a', /^A/ ]
*   [ 1, 'a', /^A/ ]
*/

static VALUE
rb_ary_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE ary = ary_new(klass, argc);
    if (argc &gt; 0 &amp;&amp; argv) {
        MEMCPY(RARRAY_PTR(ary), argv, VALUE, argc);
        ARY_SET_LEN(ary, argc);
    }

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="try_convert-class_method">
  
    + (<tt><span class='object_link'><a href="" title="Array (class)">Array</a></span></tt><sup>?</sup>) <strong>try_convert</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Try to convert <em>obj</em> into an array, using <tt>to_ary</tt> method.
Returns converted array or <tt>nil</tt> if <em>obj</em> cannot be converted
for any reason. This method can be used to check if an argument is an
array.
</p>
<pre class="code">
   Array.try_convert([1])   #=&gt; [1]
   Array.try_convert(&quot;1&quot;)   #=&gt; nil

   if tmp = Array.try_convert(arg)
     # the argument is an array
   elsif tmp = String.try_convert(arg)
     # the argument is a string
   end</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Array (class)">Array</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     Array.try_convert(obj) -&gt; array or nil
 *
 *  Try to convert &lt;i&gt;obj&lt;/i&gt; into an array, using +to_ary+ method.
 *  Returns converted array or +nil+ if &lt;i&gt;obj&lt;/i&gt; cannot be converted
 *  for any reason. This method can be used to check if an argument is an
 *  array.
 *
 *     Array.try_convert([1])   #=&gt; [1]
 *     Array.try_convert(&quot;1&quot;)   #=&gt; nil
 *
 *     if tmp = Array.try_convert(arg)
 *       # the argument is an array
 *     elsif tmp = String.try_convert(arg)
 *       # the argument is a string
 *     end
 *
 */

static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="&-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>&amp;</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set Intersection--Returns a new array containing elements common to
the two arrays, with no duplicates.
</p>
<pre class="code">
   [ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ]   #=&gt; [ 1, 3 ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary &amp; other_ary      -&gt; new_ary
 *
 *  Set Intersection---Returns a new array
 *  containing elements common to the two arrays, with no duplicates.
 *
 *     [ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ]   #=&gt; [ 1, 3 ]
 */


static VALUE
rb_ary_and(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3, v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY_LEN(ary1) &lt; RARRAY_LEN(ary2) ?
        RARRAY_LEN(ary1) : RARRAY_LEN(ary2));
    hash = ary_make_hash(ary2);

    if (RHASH_EMPTY_P(hash))
        return ary3;

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
    v = vv = rb_ary_elt(ary1, i);
    if (st_delete(RHASH_TBL(hash), (st_data_t*)&amp;vv, 0)) {
        rb_ary_push(ary3, v);
    }
    }
    ary_recycle_hash(hash);

    return ary3;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="*-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>*</strong>(int) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>*</strong>(str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Repetition--With a String argument, equivalent to self.join(str).
Otherwise, returns a new array built by concatenating the <em>int</em>
copies of <tt>self</tt>.
</p>
<pre class="code">
   [ 1, 2, 3 ] * 3    #=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
   [ 1, 2, 3 ] * &quot;,&quot;  #=&gt; &quot;1,2,3&quot;</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary * int     -&gt; new_ary
 *     ary * str     -&gt; new_string
 *
 *  Repetition---With a String argument, equivalent to
 *  self.join(str). Otherwise, returns a new array
 *  built by concatenating the _int_ copies of +self+.
 *
 *
 *     [ 1, 2, 3 ] * 3    #=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
 *     [ 1, 2, 3 ] * &quot;,&quot;  #=&gt; &quot;1,2,3&quot;
 *
 */

static VALUE
rb_ary_times(VALUE ary, VALUE times)
{
    VALUE ary2, tmp, *ptr, *ptr2;
    long i, t, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
    return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) {
    ary2 = ary_new(rb_obj_class(ary), 0);
    goto out;
    }
    if (len &lt; 0) {
    rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY_LEN(ary)) {
    rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    len *= RARRAY_LEN(ary);

    ary2 = ary_new(rb_obj_class(ary), len);
    ARY_SET_LEN(ary2, len);

    ptr = RARRAY_PTR(ary);
    ptr2 = RARRAY_PTR(ary2);
    t = RARRAY_LEN(ary);
    for (i=0; i&lt;len; i+=t) {
    MEMCPY(ptr2+i, ptr, VALUE, t);
    }
  out:
    OBJ_INFECT(ary2, ary);

    return ary2;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="+-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>+</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Concatenation--Returns a new array built by concatenating the two
arrays together to produce a third array.
</p>
<pre class="code">
   [ 1, 2, 3 ] + [ 4, 5 ]    #=&gt; [ 1, 2, 3, 4, 5 ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary + other_ary   -&gt; new_ary
 *
 *  Concatenation---Returns a new array built by concatenating the
 *  two arrays together to produce a third array.
 *
 *     [ 1, 2, 3 ] + [ 4, 5 ]    #=&gt; [ 1, 2, 3, 4, 5 ]
 */

VALUE
rb_ary_plus(VALUE x, VALUE y)
{
    VALUE z;
    long len;

    y = to_ary(y);
    len = RARRAY_LEN(x) + RARRAY_LEN(y);
    z = rb_ary_new2(len);
    MEMCPY(RARRAY_PTR(z), RARRAY_PTR(x), VALUE, RARRAY_LEN(x));
    MEMCPY(RARRAY_PTR(z) + RARRAY_LEN(x), RARRAY_PTR(y), VALUE, RARRAY_LEN(y));
    ARY_SET_LEN(z, len);
    return z;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="--instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>-</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Array Difference--Returns a new array that is a copy of the original
array, removing any items that also appear in <em>other_ary</em>. (If you
need set-like behavior, see the library class Set.)
</p>
<pre class="code">
   [ 1, 1, 2, 2, 3, 3, 4, 5 ] * [ 1, 2, 4 ]  #=&gt;  [ 3, 3, 5 ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary - other_ary    -&gt; new_ary
 *
 *  Array Difference---Returns a new array that is a copy of
 *  the original array, removing any items that also appear in
 *  &lt;i&gt;other_ary&lt;/i&gt;. (If you need set-like behavior, see the
 *  library class Set.)
 *
 *     [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=&gt;  [ 3, 3, 5 ]
 */

static VALUE
rb_ary_diff(VALUE ary1, VALUE ary2)
{
    VALUE ary3;
    volatile VALUE hash;
    long i;

    hash = ary_make_hash(to_ary(ary2));
    ary3 = rb_ary_new();

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
    if (st_lookup(RHASH_TBL(hash), RARRAY_PTR(ary1)[i], 0)) continue;
    rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }
    ary_recycle_hash(hash);
    return ary3;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<<-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>&lt;&lt;</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Append--Pushes the given object on to the end of this array. This
expression returns the array itself, so several appends may be chained
together.
</p>
<pre class="code">
   [ 1, 2 ] &lt;&lt; &quot;c&quot; &lt;&lt; &quot;d&quot; &lt;&lt; [ 3, 4 ]
           #=&gt;  [ 1, 2, &quot;c&quot;, &quot;d&quot;, [ 3, 4 ] ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary &lt;&lt; obj            -&gt; ary
 *
 *  Append---Pushes the given object on to the end of this array. This
 *  expression returns the array itself, so several appends
 *  may be chained together.
 *
 *     [ 1, 2 ] &lt;&lt; &quot;c&quot; &lt;&lt; &quot;d&quot; &lt;&lt; [ 3, 4 ]
 *             #=&gt;  [ 1, 2, &quot;c&quot;, &quot;d&quot;, [ 3, 4 ] ]
 *
 */

VALUE
rb_ary_push(VALUE ary, VALUE item)
{
    rb_ary_modify(ary);
    return rb_ary_push_1(ary, item);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<=>-instance_method">
  
    - (<tt>-1</tt>, ...) <strong>&lt;=&gt;</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Comparison--Returns an integer (-1, 0, or +1) if this array is less
than, equal to, or greater than <em>other_ary</em>.  Each object in each
array is compared (using <=>). If any value isn&#8217;t equal, then that
inequality is the return value. If all the values found are equal, then the
return is based on a comparison of the array lengths.  Thus, two arrays are
``equal&#8217;&#8217; according to <tt>Array#&lt;=&gt;</tt> if and only if
they have the same length and the value of each element is equal to the
value of the corresponding element in the other array.
</p>
<pre class="code">
   [ &quot;a&quot;, &quot;a&quot;, &quot;c&quot; ]    &lt;=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]   #=&gt; -1
   [ 1, 2, 3, 4, 5, 6 ] &lt;=&gt; [ 1, 2 ]            #=&gt; +1</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>-1</tt>, <tt>0</tt>, <tt>+1</tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary &lt;=&gt; other_ary   -&gt;  -1, 0, +1 or nil
 *
 *  Comparison---Returns an integer (-1, 0,
 *  or +1) if this array is less than, equal to, or greater than
 *  &lt;i&gt;other_ary&lt;/i&gt;.  Each object in each array is compared
 *  (using &lt;=&gt;). If any value isn't
 *  equal, then that inequality is the return value. If all the
 *  values found are equal, then the return is based on a
 *  comparison of the array lengths.  Thus, two arrays are
 *  ``equal'' according to &lt;code&gt;Array#&lt;=&gt;&lt;/code&gt; if and only if they have
 *  the same length and the value of each element is equal to the
 *  value of the corresponding element in the other array.
 *
 *     [ &quot;a&quot;, &quot;a&quot;, &quot;c&quot; ]    &lt;=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]   #=&gt; -1
 *     [ 1, 2, 3, 4, 5, 6 ] &lt;=&gt; [ 1, 2 ]            #=&gt; +1
 *
 */

VALUE
rb_ary_cmp(VALUE ary1, VALUE ary2)
{
    long len;
    VALUE v;

    ary2 = rb_check_array_type(ary2);
    if (NIL_P(ary2)) return Qnil;
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2);
    if (v != Qundef) return v;
    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="==-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>==</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equality--Two arrays are equal if they contain the same number of
elements and if each element is equal to (according to Object.==) the
corresponding element in the other array.
</p>
<pre class="code">
   [ &quot;a&quot;, &quot;c&quot; ]    == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; false
   [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; true
   [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;d&quot;, &quot;f&quot; ]   #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary == other_ary   -&gt;   bool
 *
 *  Equality---Two arrays are equal if they contain the same number
 *  of elements and if each element is equal to (according to
 *  Object.==) the corresponding element in the other array.
 *
 *     [ &quot;a&quot;, &quot;c&quot; ]    == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; false
 *     [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; true
 *     [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;d&quot;, &quot;f&quot; ]   #=&gt; false
 *
 */

static VALUE
rb_ary_equal(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) {
    if (!rb_respond_to(ary2, rb_intern(&quot;to_ary&quot;))) {
        return Qfalse;
    }
    return rb_equal(ary2, ary1);
    }
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    return rb_exec_recursive_paired(recursive_equal, ary1, ary2, ary2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]</strong>(index) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>[]</strong>(start, length) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>[]</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>slice</strong>(index) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>slice</strong>(start, length) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>slice</strong>(range) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Element Reference--Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>. Negative
indices count backward from the end of the array (-1 is the last element).
Returns <tt>nil</tt> if the index (or starting index) are out of range.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
   a[6]                   #=&gt; nil
   a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
   a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a[4..7]                #=&gt; [ &quot;e&quot; ]
   a[6..10]               #=&gt; nil
   a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   # special cases
   a[5]                   #=&gt; nil
   a[5, 1]                #=&gt; []
   a[5..10]               #=&gt; []</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>[]</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>[]</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>slice</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>slice</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>slice</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary[index]                -&gt; obj     or nil
 *     ary[start, length]        -&gt; new_ary or nil
 *     ary[range]                -&gt; new_ary or nil
 *     ary.slice(index)          -&gt; obj     or nil
 *     ary.slice(start, length)  -&gt; new_ary or nil
 *     ary.slice(range)          -&gt; new_ary or nil
 *
 *  Element Reference---Returns the element at _index_,
 *  or returns a subarray starting at _start_ and
 *  continuing for _length_ elements, or returns a subarray
 *  specified by _range_.
 *  Negative indices count backward from the end of the
 *  array (-1 is the last element). Returns +nil+ if the index
 *  (or starting index) are out of range.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
 *     a[6]                   #=&gt; nil
 *     a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
 *     a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a[4..7]                #=&gt; [ &quot;e&quot; ]
 *     a[6..10]               #=&gt; nil
 *     a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     # special cases
 *     a[5]                   #=&gt; nil
 *     a[5, 1]                #=&gt; []
 *     a[5..10]               #=&gt; []
 *
 */

VALUE
rb_ary_aref(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
    beg = NUM2LONG(argv[0]);
    len = NUM2LONG(argv[1]);
    if (beg &lt; 0) {
        beg += RARRAY_LEN(ary);
    }
    return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
    rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
    return rb_ary_entry(ary, FIX2LONG(arg));
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY_LEN(ary), 0)) {
      case Qfalse:
    break;
      case Qnil:
    return Qnil;
      default:
    return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]=-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(index) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]=</strong>(start, length) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]=</strong>(range) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Element Assignment--Sets the element at <em>index</em>, or replaces a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or replaces a subarray specified by <em>range</em>.  If indices
are greater than the current capacity of the array, the array grows
automatically. A negative indices will count backward from the end of the
array. Inserts elements if <em>length</em> is zero. An <tt>IndexError</tt>
is raised if a negative index points past the beginning of the array. See
also <tt>Array#push</tt>, and <tt>Array#unshift</tt>.
</p>
<pre class="code">
   a = Array.new
   a[4] = &quot;4&quot;;                 #=&gt; [nil, nil, nil, nil, &quot;4&quot;]
   a[0, 3] = [ 'a', 'b', 'c' ] #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, &quot;4&quot;]
   a[1..2] = [ 1, 2 ]          #=&gt; [&quot;a&quot;, 1, 2, nil, &quot;4&quot;]
   a[0, 2] = &quot;?&quot;               #=&gt; [&quot;?&quot;, 2, nil, &quot;4&quot;]
   a[0..2] = &quot;A&quot;               #=&gt; [&quot;A&quot;, &quot;4&quot;]
   a[-1]   = &quot;Z&quot;               #=&gt; [&quot;A&quot;, &quot;Z&quot;]
   a[1..-1] = nil              #=&gt; [&quot;A&quot;, nil]
   a[1..-1] = []               #=&gt; [&quot;A&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]=</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]=</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary[index]         = obj                      -&gt;  obj
 *     ary[start, length] = obj or other_ary or nil  -&gt;  obj or other_ary or nil
 *     ary[range]         = obj or other_ary or nil  -&gt;  obj or other_ary or nil
 *
 *  Element Assignment---Sets the element at _index_,
 *  or replaces a subarray starting at _start_ and
 *  continuing for _length_ elements, or replaces a subarray
 *  specified by _range_.  If indices are greater than
 *  the current capacity of the array, the array grows
 *  automatically. A negative indices will count backward
 *  from the end of the array. Inserts elements if _length_ is
 *  zero. An +IndexError+ is raised if a negative index points
 *  past the beginning of the array. See also
 *  &lt;code&gt;Array#push&lt;/code&gt;, and &lt;code&gt;Array#unshift&lt;/code&gt;.
 *
 *     a = Array.new
 *     a[4] = &quot;4&quot;;                 #=&gt; [nil, nil, nil, nil, &quot;4&quot;]
 *     a[0, 3] = [ 'a', 'b', 'c' ] #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, &quot;4&quot;]
 *     a[1..2] = [ 1, 2 ]          #=&gt; [&quot;a&quot;, 1, 2, nil, &quot;4&quot;]
 *     a[0, 2] = &quot;?&quot;               #=&gt; [&quot;?&quot;, 2, nil, &quot;4&quot;]
 *     a[0..2] = &quot;A&quot;               #=&gt; [&quot;A&quot;, &quot;4&quot;]
 *     a[-1]   = &quot;Z&quot;               #=&gt; [&quot;A&quot;, &quot;Z&quot;]
 *     a[1..-1] = nil              #=&gt; [&quot;A&quot;, nil]
 *     a[1..-1] = []               #=&gt; [&quot;A&quot;]
 */

static VALUE
rb_ary_aset(int argc, VALUE *argv, VALUE ary)
{
    long offset, beg, len;

    if (argc == 3) {
    rb_ary_modify_check(ary);
    beg = NUM2LONG(argv[0]);
    len = NUM2LONG(argv[1]);
    rb_ary_splice(ary, beg, len, argv[2]);
    return argv[2];
    }
    if (argc != 2) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2)&quot;, argc);
    }
    rb_ary_modify_check(ary);
    if (FIXNUM_P(argv[0])) {
    offset = FIX2LONG(argv[0]);
    goto fixnum;
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
    /* check if idx is Range */
    rb_ary_splice(ary, beg, len, argv[1]);
    return argv[1];
    }

    offset = NUM2LONG(argv[0]);
fixnum:
    rb_ary_store(ary, offset, argv[1]);
    return argv[1];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="assoc-instance_method">
  
    - (<tt>nil</tt>) <strong>assoc</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Searches through an array whose elements are also arrays comparing
<em>obj</em> with the first element of each contained array using obj.==.
Returns the first contained array that matches (that is, the first
associated array), or <tt>nil</tt> if no match is found. See also
<tt>Array#rassoc</tt>.
</p>
<pre class="code">
   s1 = [ &quot;colors&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ]
   s2 = [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   s3 = &quot;foo&quot;
   a  = [ s1, s2, s3 ]
   a.assoc(&quot;letters&quot;)  #=&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.assoc(&quot;foo&quot;)      #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.assoc(obj)   -&gt; new_ary  or  nil
 *
 *  Searches through an array whose elements are also arrays
 *  comparing _obj_ with the first element of each contained array
 *  using obj.==.
 *  Returns the first contained array that matches (that
 *  is, the first associated array),
 *  or +nil+ if no match is found.
 *  See also &lt;code&gt;Array#rassoc&lt;/code&gt;.
 *
 *     s1 = [ &quot;colors&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ]
 *     s2 = [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     s3 = &quot;foo&quot;
 *     a  = [ s1, s2, s3 ]
 *     a.assoc(&quot;letters&quot;)  #=&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.assoc(&quot;foo&quot;)      #=&gt; nil
 */

VALUE
rb_ary_assoc(VALUE ary, VALUE key)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
    v = rb_check_array_type(RARRAY_PTR(ary)[i]);
    if (!NIL_P(v) &amp;&amp; RARRAY_LEN(v) &gt; 0 &amp;&amp;
        rb_equal(RARRAY_PTR(v)[0], key))
        return v;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="at-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>at</strong>(index) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the element at <em>index</em>. A negative index counts from the end
of <tt>self</tt>.  Returns <tt>nil</tt> if the index is out of range. See
also <tt>Array#[]</tt>.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.at(0)     #=&gt; &quot;a&quot;
   a.at(-1)    #=&gt; &quot;e&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.at(index)   -&gt;   obj  or nil
 *
 *  Returns the element at _index_. A
 *  negative index counts from the end of +self+.  Returns +nil+
 *  if the index is out of range. See also &lt;code&gt;Array#[]&lt;/code&gt;.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a.at(0)     #=&gt; &quot;a&quot;
 *     a.at(-1)    #=&gt; &quot;e&quot;
 */

static VALUE
rb_ary_at(VALUE ary, VALUE pos)
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="clear-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>clear</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Removes all elements from <tt>self</tt>.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.clear    #=&gt; [ ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.clear    -&gt; ary
 *
 *  Removes all elements from +self+.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a.clear    #=&gt; [ ]
 */

VALUE
rb_ary_clear(VALUE ary)
{
    rb_ary_modify(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
    ary_resize_capa(ary, ARY_DEFAULT_SIZE * 2);
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="collect-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes <em>block</em> once for each element of <tt>self</tt>. Creates a
new array containing the values returned by the block. See also
<tt>Enumerable#collect</tt>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
   a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.collect {|item| block }  -&gt; new_ary
 *     ary.map     {|item| block }  -&gt; new_ary
 *     ary.collect                  -&gt; an_enumerator
 *     ary.map                      -&gt; an_enumerator
 *
 *  Invokes &lt;i&gt;block&lt;/i&gt; once for each element of +self+. Creates a
 *  new array containing the values returned by the block.
 *  See also &lt;code&gt;Enumerable#collect&lt;/code&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
 *     a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 */

static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_ENUMERATOR(ary, 0, 0);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
    rb_ary_push(collect, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return collect;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="collect!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect!</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map!</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block once for each element of <tt>self</tt>, replacing the
element with the value returned by <em>block</em>. See also
<tt>Enumerable#collect</tt>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect! {|x| x + &quot;!&quot; }
   a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect!</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map!</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.collect! {|item| block }   -&gt; ary
 *     ary.map!     {|item| block }   -&gt; ary
 *     ary.collect                    -&gt; an_enumerator
 *     ary.map                        -&gt; an_enumerator
 *
 *  Invokes the block once for each element of +self+, replacing the
 *  element with the value returned by _block_.
 *  See also &lt;code&gt;Enumerable#collect&lt;/code&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.collect! {|x| x + &quot;!&quot; }
 *     a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]
 */

static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
    rb_ary_store(ary, i, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="combination-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>combination</strong>(n) {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>combination</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
When invoked with a block, yields all combinations of length <em>n</em> of
elements from <em>ary</em> and then returns <em>ary</em> itself. The
implementation makes no guarantees about the order in which the
combinations are yielded.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<p>
Examples:
</p>
<pre class="code">
   a = [1, 2, 3, 4]
   a.combination(1).to_a  #=&gt; [[1],[2],[3],[4]]
   a.combination(2).to_a  #=&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
   a.combination(3).to_a  #=&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
   a.combination(4).to_a  #=&gt; [[1,2,3,4]]
   a.combination(0).to_a  #=&gt; [[]] # one combination of length 0
   a.combination(5).to_a  #=&gt; []   # no combinations of length 5</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>combination</strong>(n) {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.combination(n) { |c| block }    -&gt; ary
 *     ary.combination(n)                  -&gt; an_enumerator
 *
 * When invoked with a block, yields all combinations of length &lt;i&gt;n&lt;/i&gt;
 * of elements from &lt;i&gt;ary&lt;/i&gt; and then returns &lt;i&gt;ary&lt;/i&gt; itself.
 * The implementation makes no guarantees about the order in which
 * the combinations are yielded.
 *
 * If no block is given, an enumerator is returned instead.
 *
 * Examples:
 *
 *     a = [1, 2, 3, 4]
 *     a.combination(1).to_a  #=&gt; [[1],[2],[3],[4]]
 *     a.combination(2).to_a  #=&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
 *     a.combination(3).to_a  #=&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
 *     a.combination(4).to_a  #=&gt; [[1,2,3,4]]
 *     a.combination(0).to_a  #=&gt; [[]] # one combination of length 0
 *     a.combination(5).to_a  #=&gt; []   # no combinations of length 5
 *
 */

static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);
    RETURN_ENUMERATOR(ary, 1, &amp;num);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
    /* yield nothing */
    }
    else if (n == 0) {
    rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
    for (i = 0; i &lt; len; i++) {
        rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
    }
    }
    else {
    volatile VALUE t0 = tmpbuf(n+1, sizeof(long));
    long *stack = (long*)RSTRING_PTR(t0);
    volatile VALUE cc = tmpary(n);
    VALUE *chosen = RARRAY_PTR(cc);
    long lev = 0;

    MEMZERO(stack, long, n);
    stack[0] = -1;
    for (;;) {
        chosen[lev] = RARRAY_PTR(ary)[stack[lev+1]];
        for (lev++; lev &lt; n; lev++) {
        chosen[lev] = RARRAY_PTR(ary)[stack[lev+1] = stack[lev]+1];
        }
        rb_yield(rb_ary_new4(n, chosen));
        if (RBASIC(t0)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;combination reentered&quot;);
        }
        do {
        if (lev == 0) goto done;
        stack[lev--]++;
        } while (stack[lev+1]+n == len+lev+1);
    }
    done:
    tmpbuf_discard(t0);
    tmpary_discard(cc);
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="compact-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>compact</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <tt>self</tt> with all <tt>nil</tt> elements removed.
</p>
<pre class="code">
   [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot;, nil ].compact
                     #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.compact     -&gt; new_ary
 *
 *  Returns a copy of +self+ with all +nil+ elements removed.
 *
 *     [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot;, nil ].compact
 *                       #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 */

static VALUE
rb_ary_compact(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="compact!-instance_method">
  
    - (<tt>nil</tt>) <strong>compact!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Removes <tt>nil</tt> elements from the array. Returns <tt>nil</tt> if no
changes were made, otherwise returns </i>ary</i>.
</p>
<pre class="code">
   [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot; ].compact! #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].compact!           #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.compact!    -&gt; ary  or  nil
 *
 *  Removes +nil+ elements from the array.
 *  Returns +nil+ if no changes were made, otherwise returns
 *  &lt;/i&gt;ary&lt;/i&gt;.
 *
 *     [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot; ].compact! #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].compact!           #=&gt; nil
 */

static VALUE
rb_ary_compact_bang(VALUE ary)
{
    VALUE *p, *t, *end;
    long n;

    rb_ary_modify(ary);
    p = t = RARRAY_PTR(ary);
    end = p + RARRAY_LEN(ary);

    while (t &lt; end) {
    if (NIL_P(*t)) t++;
    else *p++ = *t++;
    }
    n = p - RARRAY_PTR(ary);
    if (RARRAY_LEN(ary) == n) {
    return Qnil;
    }
    ARY_SET_LEN(ary, n);
    if (n * 2 &lt; ARY_CAPA(ary) &amp;&amp; ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
    ary_resize_capa(ary, n * 2);
    }

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="concat-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>concat</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Appends the elements of <em>other_ary</em> to <tt>self</tt>.
</p>
<pre class="code">
   [ &quot;a&quot;, &quot;b&quot; ].concat( [&quot;c&quot;, &quot;d&quot;] ) #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.concat(other_ary)   -&gt; ary
 *
 *  Appends the elements of &lt;i&gt;other_ary&lt;/i&gt; to +self+.
 *
 *     [ &quot;a&quot;, &quot;b&quot; ].concat( [&quot;c&quot;, &quot;d&quot;] ) #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 */


VALUE
rb_ary_concat(VALUE x, VALUE y)
{
    rb_ary_modify_check(x);
    y = to_ary(y);
    if (RARRAY_LEN(y) &gt; 0) {
    rb_ary_splice(x, RARRAY_LEN(x), 0, y);
    }
    return x;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="count-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> {|item| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the number of elements.  If an argument is given, counts the number
of elements which equals to <em>obj</em>.  If a block is given, counts the
number of elements yielding a true value.
</p>
<pre class="code">
   ary = [1, 2, 4, 2]
   ary.count             #=&gt; 4
   ary.count(2)          #=&gt; 2
   ary.count{|x|x%2==0}  #=&gt; 3</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.count      -&gt; int
 *     ary.count(obj) -&gt; int
 *     ary.count { |item| block }  -&gt; int
 *
 *  Returns the number of elements.  If an argument is given, counts
 *  the number of elements which equals to &lt;i&gt;obj&lt;/i&gt;.  If a block is
 *  given, counts the number of elements yielding a true value.
 *
 *     ary = [1, 2, 4, 2]
 *     ary.count             #=&gt; 4
 *     ary.count(2)          #=&gt; 2
 *     ary.count{|x|x%2==0}  #=&gt; 3
 *
 */

static VALUE
rb_ary_count(int argc, VALUE *argv, VALUE ary)
{
    long n = 0;

    if (argc == 0) {
    VALUE *p, *pend;

    if (!rb_block_given_p())
        return LONG2NUM(RARRAY_LEN(ary));

    for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
        if (RTEST(rb_yield(*p))) n++;
    }
    }
    else {
    VALUE obj, *p, *pend;

    rb_scan_args(argc, argv, &quot;1&quot;, &amp;obj);
    if (rb_block_given_p()) {
        rb_warn(&quot;given block not used&quot;);
    }
    for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
        if (rb_equal(*p, obj)) n++;
    }
    }

    return LONG2NUM(n);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="cycle-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>cycle</strong>(n = nil) {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>cycle</strong>(n = nil) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Calls <em>block</em> for each element repeatedly <em>n</em> times or
forever if none or <tt>nil</tt> is given.  If a non-positive number is
given or the array is empty, does nothing.  Returns <tt>nil</tt> if the
loop has finished without getting interrupted.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
   a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>cycle</strong>(n = nil) {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.cycle(n=nil) {|obj| block }  -&gt; nil
 *     ary.cycle(n=nil)                 -&gt; an_enumerator
 *
 *  Calls &lt;i&gt;block&lt;/i&gt; for each element repeatedly _n_ times or
 *  forever if none or +nil+ is given.  If a non-positive number is
 *  given or the array is empty, does nothing.  Returns +nil+ if the
 *  loop has finished without getting interrupted.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *
 *     a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
 *     a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.
 *
 */

static VALUE
rb_ary_cycle(int argc, VALUE *argv, VALUE ary)
{
    long n, i;
    VALUE nv = Qnil;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(ary, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY_LEN(ary) &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            rb_yield(RARRAY_PTR(ary)[i]);
        }
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="delete-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>delete</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>delete</strong>(obj) { ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Deletes items from <tt>self</tt> that are equal to <em>obj</em>. If any
items are found, returns <em>obj</em>.   If the item is not found, returns
<tt>nil</tt>. If the optional code block is given, returns the result of
<em>block</em> if the item is not found.  (To remove <tt>nil</tt> elements
and get an informative return value, use #compact!)
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.delete(&quot;b&quot;)                   #=&gt; &quot;b&quot;
   a                               #=&gt; [&quot;a&quot;, &quot;c&quot;]
   a.delete(&quot;z&quot;)                   #=&gt; nil
   a.delete(&quot;z&quot;) { &quot;not found&quot; }   #=&gt; &quot;not found&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>delete</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>delete</strong>(obj) { ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'></span>
      
      
      
      
        
        <div class='inline'></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.delete(obj)            -&gt; obj or nil
 *     ary.delete(obj) { block }  -&gt; obj or nil
 *
 *  Deletes items from +self+ that are equal to &lt;i&gt;obj&lt;/i&gt;.
 *  If any items are found, returns &lt;i&gt;obj&lt;/i&gt;.   If
 *  the item is not found, returns &lt;code&gt;nil&lt;/code&gt;. If the optional
 *  code block is given, returns the result of &lt;i&gt;block&lt;/i&gt; if the item
 *  is not found.  (To remove &lt;code&gt;nil&lt;/code&gt; elements and
 *  get an informative return value, use #compact!)
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.delete(&quot;b&quot;)                   #=&gt; &quot;b&quot;
 *     a                               #=&gt; [&quot;a&quot;, &quot;c&quot;]
 *     a.delete(&quot;z&quot;)                   #=&gt; nil
 *     a.delete(&quot;z&quot;) { &quot;not found&quot; }   #=&gt; &quot;not found&quot;
 */

VALUE
rb_ary_delete(VALUE ary, VALUE item)
{
    VALUE v = item;
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
    VALUE e = RARRAY_PTR(ary)[i1];

    if (rb_equal(e, item)) {
        v = e;
        continue;
    }
    if (i1 != i2) {
        rb_ary_store(ary, i2, e);
    }
    i2++;
    }
    if (RARRAY_LEN(ary) == i2) {
    if (rb_block_given_p()) {
        return rb_yield(item);
    }
    return Qnil;
    }

    rb_ary_modify(ary);
    if (RARRAY_LEN(ary) &gt; i2) {
    ARY_SET_LEN(ary, i2);
    if (i2 * 2 &lt; ARY_CAPA(ary) &amp;&amp;
        ARY_CAPA(ary) &gt; ARY_DEFAULT_SIZE) {
        ary_resize_capa(ary, i2*2);
    }
    }

    return v;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="delete_at-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>delete_at</strong>(index) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Deletes the element at the specified index, returning that element, or
<tt>nil</tt> if the index is out of range. See also <tt>Array#slice!</tt>.
</p>
<pre class="code">
   a = %w( ant bat cat dog )
   a.delete_at(2)    #=&gt; &quot;cat&quot;
   a                 #=&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]
   a.delete_at(99)   #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.delete_at(index)  -&gt; obj or nil
 *
 *  Deletes the element at the specified index, returning that element,
 *  or &lt;code&gt;nil&lt;/code&gt; if the index is out of range. See also
 *  &lt;code&gt;Array#slice!&lt;/code&gt;.
 *
 *     a = %w( ant bat cat dog )
 *     a.delete_at(2)    #=&gt; &quot;cat&quot;
 *     a                 #=&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]
 *     a.delete_at(99)   #=&gt; nil
 */

static VALUE
rb_ary_delete_at_m(VALUE ary, VALUE pos)
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="delete_if-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>delete_if</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>delete_if</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Deletes every element of <tt>self</tt> for which <em>block</em> evaluates
to true. See also <tt>Array#reject!</tt>
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.delete_if {|x| x &gt;= &quot;b&quot; }   #=&gt; [&quot;a&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>delete_if</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.delete_if {|item| block }  -&gt; ary
 *     ary.delete_if                  -&gt; an_enumerator
 *
 *  Deletes every element of +self+ for which &lt;i&gt;block&lt;/i&gt; evaluates
 *  to true.
 *  See also &lt;code&gt;Array#reject!&lt;/code&gt;
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.delete_if {|x| x &gt;= &quot;b&quot; }   #=&gt; [&quot;a&quot;]
 */

static VALUE
rb_ary_delete_if(VALUE ary)
{
    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_reject_bang(ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="drop-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>drop</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Drops first n elements from <em>ary</em>, and returns rest elements in an
array.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.drop(3)             #=&gt; [4, 5, 0]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.drop(n)               -&gt; new_ary
 *
 *  Drops first n elements from &lt;i&gt;ary&lt;/i&gt;, and returns rest elements
 *  in an array.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop(3)             #=&gt; [4, 5, 0]
 *
 */

static VALUE
rb_ary_drop(VALUE ary, VALUE n)
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
    rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_subseq(ary, pos, RARRAY_LEN(ary));
    if (result == Qnil) result = rb_ary_new();
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="drop_while-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>drop_while</strong> {|arr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>drop_while</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Drops elements up to, but not including, the first element for which the
block returns <tt>nil</tt> or <tt>false</tt> and returns an array
containing the remaining elements.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.drop_while {|i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>drop_while</strong> {|arr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>arr</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.drop_while {|arr| block }   -&gt; new_ary
 *     ary.drop_while                  -&gt; an_enumerator
 *
 *  Drops elements up to, but not including, the first element for
 *  which the block returns +nil+ or +false+ and returns an array
 *  containing the remaining elements.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop_while {|i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]
 *
 */

static VALUE
rb_ary_drop_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
    if (!RTEST(rb_yield(RARRAY_PTR(ary)[i]))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Calls <em>block</em> once for each element in <tt>self</tt>, passing that
element as a parameter.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.each {|x| print x, &quot; -- &quot; }
</pre>
<p>
produces:
</p>
<pre class="code">
   a -- b -- c --</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.each {|item| block }   -&gt; ary
 *     ary.each                   -&gt; an_enumerator
 *
 *  Calls &lt;i&gt;block&lt;/i&gt; once for each element in +self+, passing that
 *  element as a parameter.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.each {|x| print x, &quot; -- &quot; }
 *
 *  produces:
 *
 *     a -- b -- c --
 */

VALUE
rb_ary_each(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    rb_yield(RARRAY_PTR(ary)[i]);
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_index-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_index</strong> {|index| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_index</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Same as <tt>Array#each</tt>, but passes the index of the element instead of
the element itself.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.each_index {|x| print x, &quot; -- &quot; }
</pre>
<p>
produces:
</p>
<pre class="code">
   0 -- 1 -- 2 --</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_index</strong> {|index| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>index</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.each_index {|index| block }  -&gt; ary
 *     ary.each_index                   -&gt; an_enumerator
 *
 *  Same as &lt;code&gt;Array#each&lt;/code&gt;, but passes the index of the element
 *  instead of the element itself.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.each_index {|x| print x, &quot; -- &quot; }
 *
 *  produces:
 *
 *     0 -- 1 -- 2 --
 */

static VALUE
rb_ary_each_index(VALUE ary)
{
    long i;
    RETURN_ENUMERATOR(ary, 0, 0);

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    rb_yield(LONG2NUM(i));
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="empty?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>empty?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <tt>self</tt> contains no elements.
</p>
<pre class="code">
   [].empty?   #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.empty?   -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if +self+ contains no elements.
 *
 *     [].empty?   #=&gt; true
 */

static VALUE
rb_ary_empty_p(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0)
    return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eql?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>eql?</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <tt>self</tt> and <em>other</em> are the same
object, or are both arrays with the same content.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.eql?(other)  -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if +self+ and _other_ are the same object,
 *  or are both arrays with the same content.
 */

static VALUE
rb_ary_eql(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    return rb_exec_recursive_paired(recursive_eql, ary1, ary2, ary2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fetch-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fetch</strong>(index) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fetch</strong>(index, default) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fetch</strong>(index) {|index| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Tries to return the element at position <em>index</em>. If the index lies
outside the array, the first form throws an <tt>IndexError</tt> exception,
the second form returns <em>default</em>, and the third form returns the
value of invoking the block, passing in the index. Negative values of
<em>index</em> count from the end of the array.
</p>
<pre class="code">
   a = [ 11, 22, 33, 44 ]
   a.fetch(1)               #=&gt; 22
   a.fetch(-1)              #=&gt; 44
   a.fetch(4, 'cat')        #=&gt; &quot;cat&quot;
   a.fetch(4) { |i| i*i }   #=&gt; 16</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fetch</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fetch</strong>(index, default) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fetch</strong>(index) {|index| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>index</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.fetch(index)                    -&gt; obj
 *     ary.fetch(index, default )          -&gt; obj
 *     ary.fetch(index) {|index| block }   -&gt; obj
 *
 *  Tries to return the element at position &lt;i&gt;index&lt;/i&gt;. If the index
 *  lies outside the array, the first form throws an
 *  &lt;code&gt;IndexError&lt;/code&gt; exception, the second form returns
 *  &lt;i&gt;default&lt;/i&gt;, and the third form returns the value of invoking
 *  the block, passing in the index. Negative values of &lt;i&gt;index&lt;/i&gt;
 *  count from the end of the array.
 *
 *     a = [ 11, 22, 33, 44 ]
 *     a.fetch(1)               #=&gt; 22
 *     a.fetch(-1)              #=&gt; 44
 *     a.fetch(4, 'cat')        #=&gt; &quot;cat&quot;
 *     a.fetch(4) { |i| i*i }   #=&gt; 16
 */

static VALUE
rb_ary_fetch(int argc, VALUE *argv, VALUE ary)
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
    rb_warn(&quot;block supersedes default value argument&quot;);
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
    idx +=  RARRAY_LEN(ary);
    }
    if (idx &lt; 0 || RARRAY_LEN(ary) &lt;= idx) {
    if (block_given) return rb_yield(pos);
    if (argc == 1) {
        rb_raise(rb_eIndexError, &quot;index %ld outside of array bounds: %ld...%ld&quot;,
            idx - (idx &lt; 0 ? RARRAY_LEN(ary) : 0), -RARRAY_LEN(ary), RARRAY_LEN(ary));
    }
    return ifnone;
    }
    return RARRAY_PTR(ary)[idx];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fill-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong>(obj, start[, length]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong>(obj, range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong> {|index| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong>(start[, length]) {|index| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong>(range) {|index| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
The first three forms set the selected elements of <tt>self</tt> (which may
be the entire array) to <em>obj</em>. A <em>start</em> of <tt>nil</tt> is
equivalent to zero. A <em>length</em> of <tt>nil</tt> is equivalent to
<em>self.length</em>. The last three forms fill the array with the value of
the block. The block is passed the absolute index of each element to be
filled. Negative values of <em>start</em> count from the end of the array.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.fill(&quot;x&quot;)              #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]
   a.fill(&quot;z&quot;, 2, 2)        #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]
   a.fill(&quot;y&quot;, 0..1)        #=&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]
   a.fill {|i| i*i}         #=&gt; [0, 1, 4, 9]
   a.fill(-2) {|i| i*i*i}   #=&gt; [0, 1, 8, 27]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong> {|index| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>index</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong>(start[, length]) {|index| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>index</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>fill</strong>(range) {|index| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>index</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.fill(obj)                                -&gt; ary
 *     ary.fill(obj, start [, length])              -&gt; ary
 *     ary.fill(obj, range )                        -&gt; ary
 *     ary.fill {|index| block }                    -&gt; ary
 *     ary.fill(start [, length] ) {|index| block } -&gt; ary
 *     ary.fill(range) {|index| block }             -&gt; ary
 *
 *  The first three forms set the selected elements of +self+ (which
 *  may be the entire array) to &lt;i&gt;obj&lt;/i&gt;. A &lt;i&gt;start&lt;/i&gt; of
 *  &lt;code&gt;nil&lt;/code&gt; is equivalent to zero. A &lt;i&gt;length&lt;/i&gt; of
 *  &lt;code&gt;nil&lt;/code&gt; is equivalent to &lt;i&gt;self.length&lt;/i&gt;. The last three
 *  forms fill the array with the value of the block. The block is
 *  passed the absolute index of each element to be filled.
 *  Negative values of &lt;i&gt;start&lt;/i&gt; count from the end of the array.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.fill(&quot;x&quot;)              #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]
 *     a.fill(&quot;z&quot;, 2, 2)        #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]
 *     a.fill(&quot;y&quot;, 0..1)        #=&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]
 *     a.fill {|i| i*i}         #=&gt; [0, 1, 4, 9]
 *     a.fill(-2) {|i| i*i*i}   #=&gt; [0, 1, 8, 27]
 */

static VALUE
rb_ary_fill(int argc, VALUE *argv, VALUE ary)
{
    VALUE item, arg1, arg2;
    long beg = 0, end = 0, len = 0;
    VALUE *p, *pend;
    int block_p = FALSE;

    if (rb_block_given_p()) {
    block_p = TRUE;
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
    argc += 1;     /* hackish */
    }
    else {
    rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
    beg = 0;
    len = RARRAY_LEN(ary);
    break;
      case 2:
    if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
        break;
    }
    /* fall through */
      case 3:
    beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
    if (beg &lt; 0) {
        beg = RARRAY_LEN(ary) + beg;
        if (beg &lt; 0) beg = 0;
    }
    len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
    break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
    rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    end = beg + len;
    if (RARRAY_LEN(ary) &lt; end) {
    if (end &gt;= ARY_CAPA(ary)) {
        ary_resize_capa(ary, end);
    }
    rb_mem_clear(RARRAY_PTR(ary) + RARRAY_LEN(ary), end - RARRAY_LEN(ary));
    ARY_SET_LEN(ary, end);
    }

    if (block_p) {
    VALUE v;
    long i;

    for (i=beg; i&lt;end; i++) {
        v = rb_yield(LONG2NUM(i));
        if (i&gt;=RARRAY_LEN(ary)) break;
        RARRAY_PTR(ary)[i] = v;
    }
    }
    else {
    p = RARRAY_PTR(ary) + beg;
    pend = p + len;
    while (p &lt; pend) {
        *p++ = item;
    }
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="find_index-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>index</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the index of the first object in <tt>self</tt> such that is
<tt>==</tt> to <em>obj</em>. If a block is given instead of an argument,
returns first object for which <em>block</em> is true. Returns <tt>nil</tt>
if no match is found. See also <tt>Array#rindex</tt>.
</p>
<p>
If neither block nor argument is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.index(&quot;b&quot;)        #=&gt; 1
   a.index(&quot;z&quot;)        #=&gt; nil
   a.index{|x|x==&quot;b&quot;}  #=&gt; 1
</pre>
<p>
This is an alias of <tt>#find_index</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.index(obj)           -&gt;  int or nil
 *     ary.index {|item| block} -&gt;  int or nil
 *     ary.index                -&gt;  an_enumerator
 *
 *  Returns the index of the first object in +self+ such that is
 *  &lt;code&gt;==&lt;/code&gt; to &lt;i&gt;obj&lt;/i&gt;. If a block is given instead of an
 *  argument, returns first object for which &lt;em&gt;block&lt;/em&gt; is true.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no match is found.
 *  See also &lt;code&gt;Array#rindex&lt;/code&gt;.
 *
 *  If neither block nor argument is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.index(&quot;b&quot;)        #=&gt; 1
 *     a.index(&quot;z&quot;)        #=&gt; nil
 *     a.index{|x|x==&quot;b&quot;}  #=&gt; 1
 *
 *  This is an alias of &lt;code&gt;#find_index&lt;/code&gt;.
 */

static VALUE
rb_ary_index(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i;

    if (argc == 0) {
    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
        return LONG2NUM(i);
        }
    }
    return Qnil;
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;val);
    if (rb_block_given_p())
    rb_warn(&quot;given block not used&quot;);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    if (rb_equal(RARRAY_PTR(ary)[i], val))
        return LONG2NUM(i);
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="first-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>first</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>first</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the first element, or the first <tt>n</tt> elements, of the array.
If the array is empty, the first form returns <tt>nil</tt>, and the second
form returns an empty array.
</p>
<pre class="code">
   a = [ &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot; ]
   a.first     #=&gt; &quot;q&quot;
   a.first(2)  #=&gt; [&quot;q&quot;, &quot;r&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>first</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.first     -&gt;   obj or nil
 *     ary.first(n)  -&gt;   new_ary
 *
 *  Returns the first element, or the first +n+ elements, of the array.
 *  If the array is empty, the first form returns &lt;code&gt;nil&lt;/code&gt;, and the
 *  second form returns an empty array.
 *
 *     a = [ &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot; ]
 *     a.first     #=&gt; &quot;q&quot;
 *     a.first(2)  #=&gt; [&quot;q&quot;, &quot;r&quot;]
 */

static VALUE
rb_ary_first(int argc, VALUE *argv, VALUE ary)
{
    if (argc == 0) {
    if (RARRAY_LEN(ary) == 0) return Qnil;
    return RARRAY_PTR(ary)[0];
    }
    else {
    return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="flatten-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>flatten</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>flatten</strong>(level) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array that is a one-dimensional flattening of this array
(recursively). That is, for every element that is an array, extract its
elements into the new array.  If the optional <em>level</em> argument
determines the level of recursion to flatten.
</p>
<pre class="code">
   s = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
   t = [ 4, 5, 6, [7, 8] ]   #=&gt; [4, 5, 6, [7, 8]]
   a = [ s, t, 9, 10 ]       #=&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
   a.flatten                 #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   a = [ 1, 2, [3, [4, 5] ] ]
   a.flatten(1)              #=&gt; [1, 2, 3, [4, 5]]</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.flatten -&gt; new_ary
 *     ary.flatten(level) -&gt; new_ary
 *
 *  Returns a new array that is a one-dimensional flattening of this
 *  array (recursively). That is, for every element that is an array,
 *  extract its elements into the new array.  If the optional
 *  &lt;i&gt;level&lt;/i&gt; argument determines the level of recursion to flatten.
 *
 *     s = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
 *     t = [ 4, 5, 6, [7, 8] ]   #=&gt; [4, 5, 6, [7, 8]]
 *     a = [ s, t, 9, 10 ]       #=&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
 *     a.flatten                 #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *     a = [ 1, 2, [3, [4, 5] ] ]
 *     a.flatten(1)              #=&gt; [1, 2, 3, [4, 5]]
 */

static VALUE
rb_ary_flatten(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return ary_make_shared_copy(ary);

    result = flatten(ary, level, &amp;mod);
    OBJ_INFECT(result, ary);

    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="flatten!-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>flatten!</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Array (class)">Array</a></span></tt><sup>?</sup>) <strong>flatten!</strong>(level) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Flattens <tt>self</tt> in place. Returns <tt>nil</tt> if no modifications
were made (i.e., <em>ary</em> contains no subarrays.)  If the optional
<em>level</em> argument determines the level of recursion to flatten.
</p>
<pre class="code">
   a = [ 1, 2, [3, [4, 5] ] ]
   a.flatten!   #=&gt; [1, 2, 3, 4, 5]
   a.flatten!   #=&gt; nil
   a            #=&gt; [1, 2, 3, 4, 5]
   a = [ 1, 2, [3, [4, 5] ] ]
   a.flatten!(1) #=&gt; [1, 2, 3, [4, 5]]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>flatten!</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Array (class)">Array</a></span></tt><sup>?</sup>) <strong>flatten!</strong>(level) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Array (class)">Array</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.flatten!        -&gt; ary or nil
 *     ary.flatten!(level) -&gt; array or nil
 *
 *  Flattens +self+ in place.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no modifications were made (i.e.,
 *  &lt;i&gt;ary&lt;/i&gt; contains no subarrays.)  If the optional &lt;i&gt;level&lt;/i&gt;
 *  argument determines the level of recursion to flatten.
 *
 *     a = [ 1, 2, [3, [4, 5] ] ]
 *     a.flatten!   #=&gt; [1, 2, 3, 4, 5]
 *     a.flatten!   #=&gt; nil
 *     a            #=&gt; [1, 2, 3, 4, 5]
 *     a = [ 1, 2, [3, [4, 5] ] ]
 *     a.flatten!(1) #=&gt; [1, 2, 3, [4, 5]]
 */

static VALUE
rb_ary_flatten_bang(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    rb_ary_modify_check(ary);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return Qnil;

    result = flatten(ary, level, &amp;mod);
    if (mod == 0) {
    ary_discard(result);
    return Qnil;
    }
    if (!(mod = ARY_EMBED_P(result))) rb_obj_freeze(result);
    rb_ary_replace(ary, result);
    if (mod) ARY_SET_EMBED_LEN(result, 0);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="frozen?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>frozen?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return <tt>true</tt> if this array is frozen (or temporarily frozen while
being sorted).
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.frozen?  -&gt; true or false
 *
 *  Return &lt;code&gt;true&lt;/code&gt; if this array is frozen (or temporarily frozen
 *  while being sorted).
 */

static VALUE
rb_ary_frozen_p(VALUE ary)
{
    if (OBJ_FROZEN(ary)) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="hash-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>hash</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Compute a hash-code for this array. Two arrays with the same content will
have the same hash code (and will compare using <tt>eql?</tt>).
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.hash   -&gt; fixnum
 *
 *  Compute a hash-code for this array. Two arrays with the same content
 *  will have the same hash code (and will compare using &lt;code&gt;eql?&lt;/code&gt;).
 */

static VALUE
rb_ary_hash(VALUE ary)
{
    return rb_exec_recursive_outer(recursive_hash, ary, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="include?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>include?</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if the given object is present in <tt>self</tt> (that
is, if any object <tt>==</tt> <em>anObject</em>), <tt>false</tt> otherwise.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.include?(&quot;b&quot;)   #=&gt; true
   a.include?(&quot;z&quot;)   #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.include?(obj)   -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if the given object is present in
 *  +self+ (that is, if any object &lt;code&gt;==&lt;/code&gt; &lt;i&gt;anObject&lt;/i&gt;),
 *  &lt;code&gt;false&lt;/code&gt; otherwise.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.include?(&quot;b&quot;)   #=&gt; true
 *     a.include?(&quot;z&quot;)   #=&gt; false
 */

VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
    long i;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    if (rb_equal(RARRAY_PTR(ary)[i], item)) {
        return Qtrue;
    }
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="index-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>index</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the index of the first object in <tt>self</tt> such that is
<tt>==</tt> to <em>obj</em>. If a block is given instead of an argument,
returns first object for which <em>block</em> is true. Returns <tt>nil</tt>
if no match is found. See also <tt>Array#rindex</tt>.
</p>
<p>
If neither block nor argument is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.index(&quot;b&quot;)        #=&gt; 1
   a.index(&quot;z&quot;)        #=&gt; nil
   a.index{|x|x==&quot;b&quot;}  #=&gt; 1
</pre>
<p>
This is an alias of <tt>#find_index</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>index</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.index(obj)           -&gt;  int or nil
 *     ary.index {|item| block} -&gt;  int or nil
 *     ary.index                -&gt;  an_enumerator
 *
 *  Returns the index of the first object in +self+ such that is
 *  &lt;code&gt;==&lt;/code&gt; to &lt;i&gt;obj&lt;/i&gt;. If a block is given instead of an
 *  argument, returns first object for which &lt;em&gt;block&lt;/em&gt; is true.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no match is found.
 *  See also &lt;code&gt;Array#rindex&lt;/code&gt;.
 *
 *  If neither block nor argument is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.index(&quot;b&quot;)        #=&gt; 1
 *     a.index(&quot;z&quot;)        #=&gt; nil
 *     a.index{|x|x==&quot;b&quot;}  #=&gt; 1
 *
 *  This is an alias of &lt;code&gt;#find_index&lt;/code&gt;.
 */

static VALUE
rb_ary_index(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i;

    if (argc == 0) {
    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
        return LONG2NUM(i);
        }
    }
    return Qnil;
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;val);
    if (rb_block_given_p())
    rb_warn(&quot;given block not used&quot;);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    if (rb_equal(RARRAY_PTR(ary)[i], val))
        return LONG2NUM(i);
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="initialize_copy-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>replace</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Replaces the contents of <tt>self</tt> with the contents of
<em>other_ary</em>, truncating or expanding if necessary.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
   a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.replace(other_ary)  -&gt; ary
 *
 *  Replaces the contents of +self+ with the contents of
 *  &lt;i&gt;other_ary&lt;/i&gt;, truncating or expanding if necessary.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 *     a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 */

VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    if (RARRAY_LEN(orig) &lt;= RARRAY_EMBED_LEN_MAX) {
        VALUE *ptr;
        VALUE shared = 0;

        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else if (ARY_SHARED_P(copy)) {
            shared = ARY_SHARED(copy);
            FL_UNSET_SHARED(copy);
        }
        FL_SET_EMBED(copy);
        ptr = RARRAY_PTR(orig);
        MEMCPY(RARRAY_PTR(copy), ptr, VALUE, RARRAY_LEN(orig));
        if (shared) {
            rb_ary_decrement_share(shared);
        }
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
    }
    else {
        VALUE shared = ary_make_shared(orig);
        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else {
            rb_ary_unshare_safe(copy);
        }
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, RARRAY_PTR(orig));
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
        rb_ary_set_shared(copy, shared);
    }
    return copy;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="insert-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>insert</strong>(index, obj...) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Inserts the given values before the element with the given index (which may
be negative).
</p>
<pre class="code">
   a = %w{ a b c d }
   a.insert(2, 99)         #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]
   a.insert(-2, 1, 2, 3)   #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.insert(index, obj...)  -&gt; ary
 *
 *  Inserts the given values before the element with the given index
 *  (which may be negative).
 *
 *     a = %w{ a b c d }
 *     a.insert(2, 99)         #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]
 *     a.insert(-2, 1, 2, 3)   #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]
 */

static VALUE
rb_ary_insert(int argc, VALUE *argv, VALUE ary)
{
    long pos;

    if (argc &lt; 1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (at least 1)&quot;);
    }
    rb_ary_modify_check(ary);
    if (argc == 1) return ary;
    pos = NUM2LONG(argv[0]);
    if (pos == -1) {
    pos = RARRAY_LEN(ary);
    }
    if (pos &lt; 0) {
    pos++;
    }
    rb_ary_splice(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates a string representation of <tt>self</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.to_s -&gt; string
 *     ary.inspect  -&gt; string
 *
 *  Creates a string representation of +self+.
 */

static VALUE
rb_ary_inspect(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0) return rb_usascii_str_new2(&quot;[]&quot;);
    return rb_exec_recursive(inspect_ary, ary, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="join-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>join</strong>(sep = $,) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a string created by converting each element of the array to a
string, separated by <em>sep</em>.
</p>
<pre class="code">
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        #=&gt; &quot;abc&quot;
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   #=&gt; &quot;a-b-c&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.join(sep=$,)    -&gt; str
 *
 *  Returns a string created by converting each element of the array to
 *  a string, separated by &lt;i&gt;sep&lt;/i&gt;.
 *
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        #=&gt; &quot;abc&quot;
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   #=&gt; &quot;a-b-c&quot;
 */

static VALUE
rb_ary_join_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE sep;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;sep);
    if (NIL_P(sep)) sep = rb_output_fs;

    return rb_ary_join(ary, sep);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="keep_if-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>keep_if</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>keep_if</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Deletes every element of <tt>self</tt> for which <em>block</em> evaluates
to false. See also <tt>Array#select!</tt>
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = %w{ a b c d e f }
   a.keep_if {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>keep_if</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.keep_if {|item| block } -&gt; ary
 *     ary.keep_if                 -&gt; an_enumerator
 *
 *  Deletes every element of +self+ for which &lt;i&gt;block&lt;/i&gt; evaluates
 *  to false.
 *  See also &lt;code&gt;Array#select!&lt;/code&gt;
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = %w{ a b c d e f }
 *     a.keep_if {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]
 */

static VALUE
rb_ary_keep_if(VALUE ary)
{
    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_select_bang(ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="last-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>last</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>last</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the last element(s) of <tt>self</tt>. If the array is empty, the
first form returns <tt>nil</tt>.
</p>
<pre class="code">
   a = [ &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ]
   a.last     #=&gt; &quot;z&quot;
   a.last(2)  #=&gt; [&quot;y&quot;, &quot;z&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>last</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.last     -&gt;  obj or nil
 *     ary.last(n)  -&gt;  new_ary
 *
 *  Returns the last element(s) of +self+. If the array is empty,
 *  the first form returns &lt;code&gt;nil&lt;/code&gt;.
 *
 *     a = [ &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ]
 *     a.last     #=&gt; &quot;z&quot;
 *     a.last(2)  #=&gt; [&quot;y&quot;, &quot;z&quot;]
 */

VALUE
rb_ary_last(int argc, VALUE *argv, VALUE ary)
{
    if (argc == 0) {
    if (RARRAY_LEN(ary) == 0) return Qnil;
    return RARRAY_PTR(ary)[RARRAY_LEN(ary)-1];
    }
    else {
    return ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="length-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the number of elements in <tt>self</tt>. May be zero.
</p>
<pre class="code">
   [ 1, 2, 3, 4, 5 ].length   #=&gt; 5</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.length -&gt; int
 *
 *  Returns the number of elements in +self+. May be zero.
 *
 *     [ 1, 2, 3, 4, 5 ].length   #=&gt; 5
 */

static VALUE
rb_ary_length(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    return LONG2NUM(len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="map-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes <em>block</em> once for each element of <tt>self</tt>. Creates a
new array containing the values returned by the block. See also
<tt>Enumerable#collect</tt>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
   a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.collect {|item| block }  -&gt; new_ary
 *     ary.map     {|item| block }  -&gt; new_ary
 *     ary.collect                  -&gt; an_enumerator
 *     ary.map                      -&gt; an_enumerator
 *
 *  Invokes &lt;i&gt;block&lt;/i&gt; once for each element of +self+. Creates a
 *  new array containing the values returned by the block.
 *  See also &lt;code&gt;Enumerable#collect&lt;/code&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
 *     a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 */

static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_ENUMERATOR(ary, 0, 0);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
    rb_ary_push(collect, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return collect;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="map!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect!</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map!</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block once for each element of <tt>self</tt>, replacing the
element with the value returned by <em>block</em>. See also
<tt>Enumerable#collect</tt>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.collect! {|x| x + &quot;!&quot; }
   a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect!</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map!</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.collect! {|item| block }   -&gt; ary
 *     ary.map!     {|item| block }   -&gt; ary
 *     ary.collect                    -&gt; an_enumerator
 *     ary.map                        -&gt; an_enumerator
 *
 *  Invokes the block once for each element of +self+, replacing the
 *  element with the value returned by _block_.
 *  See also &lt;code&gt;Enumerable#collect&lt;/code&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.collect! {|x| x + &quot;!&quot; }
 *     a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]
 */

static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
    rb_ary_store(ary, i, rb_yield(RARRAY_PTR(ary)[i]));
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pack-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>pack</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Packs the contents of <em>arr</em> into a binary sequence according to the
directives in <em>aTemplateString</em> (see the table below) Directives
``A,&#8217;&#8217; ``a,&#8217;&#8217; and ``Z&#8217;&#8217; may be followed
by a count, which gives the width of the resulting field. The remaining
directives also may take a count, indicating the number of array elements
to convert. If the count is an asterisk (``<tt>*</tt>&#8217;&#8217;), all
remaining array elements will be converted. Any of the directives
``<tt>sSiIlL</tt>&#8217;&#8217; may be followed by an underscore
(``<tt>_</tt>&#8217;&#8217;) or exclamation mark
(``<tt>!</tt>&#8217;&#8217;) to use the underlying platform&#8217;s native
size for the specified type; otherwise, they use a platform-independent
size. Spaces are ignored in the template string. See also
<tt>String#unpack</tt>.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   n = [ 65, 66, 67 ]
   a.pack(&quot;A3A3A3&quot;)   #=&gt; &quot;a  b  c  &quot;
   a.pack(&quot;a3a3a3&quot;)   #=&gt; &quot;a\000\000b\000\000c\000\000&quot;
   n.pack(&quot;ccc&quot;)      #=&gt; &quot;ABC&quot;
</pre>
<p>
Directives for <tt>pack</tt>.
</p>
<pre class="code">
 Integer      | Array   |
 Directive    | Element | Meaning
 ---------------------------------------------------------------------------
    C         | Integer | 8-bit unsigned integer (unsigned char)
    S         | Integer | 16-bit unsigned integer, native endian (uint16_t)
    L         | Integer | 32-bit unsigned integer, native endian (uint32_t)
    Q         | Integer | 64-bit unsigned integer, native endian (uint64_t)
              |         |
    c         | Integer | 8-bit signed integer (char)
    s         | Integer | 16-bit signed integer, native endian (int16_t)
    l         | Integer | 32-bit signed integer, native endian (int32_t)
    q         | Integer | 64-bit signed integer, native endian (int64_t)
              |         |
    S_, S!    | Integer | unsigned short, native endian
    I, I_, I! | Integer | unsigned int, native endian
    L_, L!    | Integer | unsigned long, native endian
              |         |
    s_, s!    | Integer | signed short, native endian
    i, i_, i! | Integer | signed int, native endian
    l_, l!    | Integer | signed long, native endian
              |         |
    n         | Integer | 16-bit unsigned integer, network (big-endian) byte order
    N         | Integer | 32-bit unsigned integer, network (big-endian) byte order
    v         | Integer | 16-bit unsigned integer, VAX (little-endian) byte order
    V         | Integer | 32-bit unsigned integer, VAX (little-endian) byte order
              |         |
    U         | Integer | UTF-8 character
    w         | Integer | BER-compressed integer

 Float        |         |
 Directive    |         | Meaning
 ---------------------------------------------------------------------------
    D, d      | Float   | double-precision float, native format
    F, f      | Float   | single-precision float, native format
    E         | Float   | double-precision float, little-endian byte order
    e         | Float   | single-precision float, little-endian byte order
    G         | Float   | double-precision float, network (big-endian) byte order
    g         | Float   | single-precision float, network (big-endian) byte order

 String       |         |
 Directive    |         | Meaning
 ---------------------------------------------------------------------------
    A         | String  | arbitrary binary string (space padded, count is width)
    a         | String  | arbitrary binary string (null padded, count is width)
    Z         | String  | same as ``a'', except that null is added with *
    B         | String  | bit string (MSB first)
    b         | String  | bit string (LSB first)
    H         | String  | hex string (high nibble first)
    h         | String  | hex string (low nibble first)
    u         | String  | UU-encoded string
    M         | String  | quoted printable, MIME encoding (see RFC2045)
    m         | String  | base64 encoded string (see RFC 2045, count is width)
              |         | (if count is 0, no line feed are added, see RFC 4648)
    P         | String  | pointer to a structure (fixed-length string)
    p         | String  | pointer to a null-terminated string

 Misc.        |         |
 Directive    |         | Meaning
 ---------------------------------------------------------------------------
    @         | ---     | moves to absolute position
    X         | ---     | back up a byte
    x         | ---     | null byte</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'pack.c'</span>

/*
 *  call-seq:
 *     arr.pack ( aTemplateString ) -&gt; aBinaryString
 *
 *  Packs the contents of &lt;i&gt;arr&lt;/i&gt; into a binary sequence according to
 *  the directives in &lt;i&gt;aTemplateString&lt;/i&gt; (see the table below)
 *  Directives ``A,'' ``a,'' and ``Z'' may be followed by a count,
 *  which gives the width of the resulting field. The remaining
 *  directives also may take a count, indicating the number of array
 *  elements to convert. If the count is an asterisk
 *  (``&lt;code&gt;*&lt;/code&gt;''), all remaining array elements will be
 *  converted. Any of the directives ``&lt;code&gt;sSiIlL&lt;/code&gt;'' may be
 *  followed by an underscore (``&lt;code&gt;_&lt;/code&gt;'') or
 *  exclamation mark (``&lt;code&gt;!&lt;/code&gt;'') to use the underlying
 *  platform's native size for the specified type; otherwise, they use a
 *  platform-independent size. Spaces are ignored in the template
 *  string. See also &lt;code&gt;String#unpack&lt;/code&gt;.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     n = [ 65, 66, 67 ]
 *     a.pack(&quot;A3A3A3&quot;)   #=&gt; &quot;a  b  c  &quot;
 *     a.pack(&quot;a3a3a3&quot;)   #=&gt; &quot;a\000\000b\000\000c\000\000&quot;
 *     n.pack(&quot;ccc&quot;)      #=&gt; &quot;ABC&quot;
 *
 *  Directives for +pack+.
 *
 *   Integer      | Array   |
 *   Directive    | Element | Meaning
 *   ---------------------------------------------------------------------------
 *      C         | Integer | 8-bit unsigned integer (unsigned char)
 *      S         | Integer | 16-bit unsigned integer, native endian (uint16_t)
 *      L         | Integer | 32-bit unsigned integer, native endian (uint32_t)
 *      Q         | Integer | 64-bit unsigned integer, native endian (uint64_t)
 *                |         |
 *      c         | Integer | 8-bit signed integer (char)
 *      s         | Integer | 16-bit signed integer, native endian (int16_t)
 *      l         | Integer | 32-bit signed integer, native endian (int32_t)
 *      q         | Integer | 64-bit signed integer, native endian (int64_t)
 *                |         |
 *      S_, S!    | Integer | unsigned short, native endian
 *      I, I_, I! | Integer | unsigned int, native endian
 *      L_, L!    | Integer | unsigned long, native endian
 *                |         |
 *      s_, s!    | Integer | signed short, native endian
 *      i, i_, i! | Integer | signed int, native endian
 *      l_, l!    | Integer | signed long, native endian
 *                |         |
 *      n         | Integer | 16-bit unsigned integer, network (big-endian) byte order
 *      N         | Integer | 32-bit unsigned integer, network (big-endian) byte order
 *      v         | Integer | 16-bit unsigned integer, VAX (little-endian) byte order
 *      V         | Integer | 32-bit unsigned integer, VAX (little-endian) byte order
 *                |         |
 *      U         | Integer | UTF-8 character
 *      w         | Integer | BER-compressed integer
 *                
 *   Float        |         |
 *   Directive    |         | Meaning
 *   ---------------------------------------------------------------------------
 *      D, d      | Float   | double-precision float, native format
 *      F, f      | Float   | single-precision float, native format
 *      E         | Float   | double-precision float, little-endian byte order
 *      e         | Float   | single-precision float, little-endian byte order
 *      G         | Float   | double-precision float, network (big-endian) byte order
 *      g         | Float   | single-precision float, network (big-endian) byte order
 *                
 *   String       |         |
 *   Directive    |         | Meaning
 *   ---------------------------------------------------------------------------
 *      A         | String  | arbitrary binary string (space padded, count is width)
 *      a         | String  | arbitrary binary string (null padded, count is width)
 *      Z         | String  | same as ``a'', except that null is added with *
 *      B         | String  | bit string (MSB first)
 *      b         | String  | bit string (LSB first)
 *      H         | String  | hex string (high nibble first)
 *      h         | String  | hex string (low nibble first)
 *      u         | String  | UU-encoded string
 *      M         | String  | quoted printable, MIME encoding (see RFC2045)
 *      m         | String  | base64 encoded string (see RFC 2045, count is width)
 *                |         | (if count is 0, no line feed are added, see RFC 4648)
 *      P         | String  | pointer to a structure (fixed-length string)
 *      p         | String  | pointer to a null-terminated string
 *                
 *   Misc.        |         |
 *   Directive    |         | Meaning
 *   ---------------------------------------------------------------------------
 *      @         | ---     | moves to absolute position
 *      X         | ---     | back up a byte
 *      x         | ---     | null byte
 */

static VALUE
pack_pack(VALUE ary, VALUE fmt)
{
    static const char nul10[] = &quot;\0\0\0\0\0\0\0\0\0\0&quot;;
    static const char spc10[] = &quot;          &quot;;
    const char *p, *pend;
    VALUE res, from, associates = 0;
    char type;
    long items, len, idx, plen;
    const char *ptr;
    int enc_info = 1;       /* 0 - BINARY, 1 - US-ASCII, 2 - UTF-8 */
#ifdef NATINT_PACK
    int natint;     /* native integer */
#endif
    int signed_p, integer_size, bigendian_p;

    StringValue(fmt);
    p = RSTRING_PTR(fmt);
    pend = p + RSTRING_LEN(fmt);
    res = rb_str_buf_new(0);

    items = RARRAY_LEN(ary);
    idx = 0;

#define TOO_FEW (rb_raise(rb_eArgError, toofew), 0)
#define THISFROM (items &gt; 0 ? RARRAY_PTR(ary)[idx] : TOO_FEW)
#define NEXTFROM (items-- &gt; 0 ? RARRAY_PTR(ary)[idx++] : TOO_FEW)

    while (p &lt; pend) {
    if (RSTRING_PTR(fmt) + RSTRING_LEN(fmt) != pend) {
        rb_raise(rb_eRuntimeError, &quot;format string modified&quot;);
    }
    type = *p++;       /* get data type */
#ifdef NATINT_PACK
    natint = 0;
#endif

    if (ISSPACE(type)) continue;
    if (type == '#') {
        while ((p &lt; pend) &amp;&amp; (*p != '\n')) {
        p++;
        }
        continue;
    }
        if (*p == '_' || *p == '!') {
        static const char natstr[] = &quot;sSiIlL&quot;;

        if (strchr(natstr, type)) {
#ifdef NATINT_PACK
        natint = 1;
#endif
        p++;
        }
        else {
        rb_raise(rb_eArgError, &quot;'%c' allowed only after types %s&quot;, *p, natstr);
        }
    }
    if (*p == '*') {   /* set data length */
        len = strchr(&quot;@Xxu&quot;, type) ? 0
                : strchr(&quot;PMm&quot;, type) ? 1
                : items;
        p++;
    }
    else if (ISDIGIT(*p)) {
        errno = 0;
        len = STRTOUL(p, (char**)&amp;p, 10);
        if (errno) {
        rb_raise(rb_eRangeError, &quot;pack length too big&quot;);
        }
    }
    else {
        len = 1;
    }

    switch (type) {
      case 'U':
        /* if encoding is US-ASCII, upgrade to UTF-8 */
        if (enc_info == 1) enc_info = 2;
        break;
      case 'm': case 'M': case 'u':
        /* keep US-ASCII (do nothing) */
        break;
      default:
        /* fall back to BINARY */
        enc_info = 0;
        break;
    }
    switch (type) {
      case 'A': case 'a': case 'Z':
      case 'B': case 'b':
      case 'H': case 'h':
        from = NEXTFROM;
        if (NIL_P(from)) {
        ptr = &quot;&quot;;
        plen = 0;
        }
        else {
        StringValue(from);
        ptr = RSTRING_PTR(from);
        plen = RSTRING_LEN(from);
        OBJ_INFECT(res, from);
        }

        if (p[-1] == '*')
        len = plen;

        switch (type) {
          case 'a':        /* arbitrary binary string (null padded)  */
          case 'A':         /* arbitrary binary string (ASCII space padded) */
          case 'Z':         /* null terminated string  */
        if (plen &gt;= len) {
            rb_str_buf_cat(res, ptr, len);
            if (p[-1] == '*' &amp;&amp; type == 'Z')
            rb_str_buf_cat(res, nul10, 1);
        }
        else {
            rb_str_buf_cat(res, ptr, plen);
            len -= plen;
            while (len &gt;= 10) {
            rb_str_buf_cat(res, (type == 'A')?spc10:nul10, 10);
            len -= 10;
            }
            rb_str_buf_cat(res, (type == 'A')?spc10:nul10, len);
        }
        break;

          case 'b':        /* bit string (ascending) */
        {
            int byte = 0;
            long i, j = 0;

            if (len &gt; plen) {
            j = (len - plen + 1)/2;
            len = plen;
            }
            for (i=0; i++ &lt; len; ptr++) {
            if (*ptr &amp; 1)
                byte |= 128;
            if (i &amp; 7)
                byte &gt;&gt;= 1;
            else {
                char c = byte &amp; 0xff;
                rb_str_buf_cat(res, &amp;c, 1);
                byte = 0;
            }
            }
            if (len &amp; 7) {
            char c;
            byte &gt;&gt;= 7 - (len &amp; 7);
            c = byte &amp; 0xff;
            rb_str_buf_cat(res, &amp;c, 1);
            }
            len = j;
            goto grow;
        }
        break;

          case 'B':        /* bit string (descending) */
        {
            int byte = 0;
            long i, j = 0;

            if (len &gt; plen) {
            j = (len - plen + 1)/2;
            len = plen;
            }
            for (i=0; i++ &lt; len; ptr++) {
            byte |= *ptr &amp; 1;
            if (i &amp; 7)
                byte &lt;&lt;= 1;
            else {
                char c = byte &amp; 0xff;
                rb_str_buf_cat(res, &amp;c, 1);
                byte = 0;
            }
            }
            if (len &amp; 7) {
            char c;
            byte &lt;&lt;= 7 - (len &amp; 7);
            c = byte &amp; 0xff;
            rb_str_buf_cat(res, &amp;c, 1);
            }
            len = j;
            goto grow;
        }
        break;

          case 'h':        /* hex string (low nibble first) */
        {
            int byte = 0;
            long i, j = 0;

            if (len &gt; plen) {
            j = (len + 1) / 2 - (plen + 1) / 2;
            len = plen;
            }
            for (i=0; i++ &lt; len; ptr++) {
            if (ISALPHA(*ptr))
                byte |= (((*ptr &amp; 15) + 9) &amp; 15) &lt;&lt; 4;
            else
                byte |= (*ptr &amp; 15) &lt;&lt; 4;
            if (i &amp; 1)
                byte &gt;&gt;= 4;
            else {
                char c = byte &amp; 0xff;
                rb_str_buf_cat(res, &amp;c, 1);
                byte = 0;
            }
            }
            if (len &amp; 1) {
            char c = byte &amp; 0xff;
            rb_str_buf_cat(res, &amp;c, 1);
            }
            len = j;
            goto grow;
        }
        break;

          case 'H':        /* hex string (high nibble first) */
        {
            int byte = 0;
            long i, j = 0;

            if (len &gt; plen) {
            j = (len + 1) / 2 - (plen + 1) / 2;
            len = plen;
            }
            for (i=0; i++ &lt; len; ptr++) {
            if (ISALPHA(*ptr))
                byte |= ((*ptr &amp; 15) + 9) &amp; 15;
            else
                byte |= *ptr &amp; 15;
            if (i &amp; 1)
                byte &lt;&lt;= 4;
            else {
                char c = byte &amp; 0xff;
                rb_str_buf_cat(res, &amp;c, 1);
                byte = 0;
            }
            }
            if (len &amp; 1) {
            char c = byte &amp; 0xff;
            rb_str_buf_cat(res, &amp;c, 1);
            }
            len = j;
            goto grow;
        }
        break;
        }
        break;

      case 'c':        /* signed char */
      case 'C':        /* unsigned char */
        while (len-- &gt; 0) {
        char c;

        from = NEXTFROM;
        c = (char)num2i32(from);
        rb_str_buf_cat(res, &amp;c, sizeof(char));
        }
        break;

      case 's':        /* signed short */
            signed_p = 1;
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'S':        /* unsigned short */
            signed_p = 0;
            integer_size = NATINT_LEN(short, 2);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'i':        /* signed int */
            signed_p = 1;
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'I':        /* unsigned int */
            signed_p = 0;
            integer_size = (int)sizeof(int);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'l':        /* signed long */
            signed_p = 1;
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'L':        /* unsigned long */
            signed_p = 0;
            integer_size = NATINT_LEN(long, 4);
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'q':        /* signed quad (64bit) int */
            signed_p = 1;
            integer_size = 8;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'Q':        /* unsigned quad (64bit) int */
            signed_p = 0;
            integer_size = 8;
            bigendian_p = BIGENDIAN_P();
            goto pack_integer;

      case 'n':        /* unsigned short (network byte-order)  */
            signed_p = 0;
            integer_size = 2;
            bigendian_p = 1;
            goto pack_integer;

      case 'N':        /* unsigned long (network byte-order) */
            signed_p = 0;
            integer_size = 4;
            bigendian_p = 1;
            goto pack_integer;

      case 'v':        /* unsigned short (VAX byte-order) */
            signed_p = 0;
            integer_size = 2;
            bigendian_p = 0;
            goto pack_integer;

      case 'V':        /* unsigned long (VAX byte-order) */
            signed_p = 0;
            integer_size = 4;
            bigendian_p = 0;
            goto pack_integer;

          pack_integer:
            switch (integer_size) {
#if defined(HAVE_INT16_T) &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT16_T:
        while (len-- &gt; 0) {
                    union {
                        int16_t i;
                        char a[sizeof(int16_t)];
                    } v;

            from = NEXTFROM;
            v.i = (int16_t)num2i32(from);
            if (bigendian_p != BIGENDIAN_P()) v.i = swap16(v.i);
            rb_str_buf_cat(res, v.a, sizeof(int16_t));
        }
        break;
#endif

#if defined(HAVE_INT32_T) &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT32_T:
        while (len-- &gt; 0) {
            union {
                        int32_t i;
                        char a[sizeof(int32_t)];
                    } v;

            from = NEXTFROM;
            v.i = (int32_t)num2i32(from);
            if (bigendian_p != BIGENDIAN_P()) v.i = swap32(v.i);
            rb_str_buf_cat(res, v.a, sizeof(int32_t));
        }
        break;
#endif

#if defined(HAVE_INT64_T) &amp;&amp; SIZEOF_LONG == SIZEOF_INT64_T &amp;&amp; !defined(FORCE_BIG_PACK)
              case SIZEOF_INT64_T:
        while (len-- &gt; 0) {
            union {
                        int64_t i;
                        char a[sizeof(int64_t)];
                    } v;

            from = NEXTFROM;
            v.i = num2i32(from); /* can return 64bit value if SIZEOF_LONG == SIZEOF_INT64_T */
            if (bigendian_p != BIGENDIAN_P()) v.i = swap64(v.i);
            rb_str_buf_cat(res, v.a, sizeof(int64_t));
        }
        break;
#endif

          default:
                if (integer_size &gt; MAX_INTEGER_PACK_SIZE)
                    rb_bug(&quot;unexpected intger size for pack: %d&quot;, integer_size);
                while (len-- &gt; 0) {
                    union {
                        unsigned long i[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG-1)/SIZEOF_LONG];
                        char a[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG-1)/SIZEOF_LONG*SIZEOF_LONG];
                    } v;
                    int num_longs = (integer_size+SIZEOF_LONG-1)/SIZEOF_LONG;
                    int i;

                    from = NEXTFROM;
                    rb_big_pack(from, v.i, num_longs);
                    if (bigendian_p) {
                        for (i = 0; i &lt; num_longs/2; i++) {
                            unsigned long t = v.i[i];
                            v.i[i] = v.i[num_longs-1-i];
                            v.i[num_longs-1-i] = t;
                        }
                    }
            if (bigendian_p != BIGENDIAN_P()) {
                        for (i = 0; i &lt; num_longs; i++)
                            v.i[i] = swapl(v.i[i]);
                    }
                    rb_str_buf_cat(res,
                                   bigendian_p ?
                                     v.a + sizeof(long)*num_longs - integer_size :
                                     v.a,
                                   integer_size);
                }
                break;
        }
        break;

      case 'f':        /* single precision float in native format */
      case 'F':        /* ditto */
        while (len-- &gt; 0) {
        float f;

        from = NEXTFROM;
        f = (float)RFLOAT_VALUE(rb_to_float(from));
        rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
        }
        break;

      case 'e':        /* single precision float in VAX byte-order */
        while (len-- &gt; 0) {
        float f;
        FLOAT_CONVWITH(ftmp);

        from = NEXTFROM;
        f = (float)RFLOAT_VALUE(rb_to_float(from));
        f = HTOVF(f,ftmp);
        rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
        }
        break;

      case 'E':        /* double precision float in VAX byte-order */
        while (len-- &gt; 0) {
        double d;
        DOUBLE_CONVWITH(dtmp);

        from = NEXTFROM;
        d = RFLOAT_VALUE(rb_to_float(from));
        d = HTOVD(d,dtmp);
        rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
        }
        break;

      case 'd':        /* double precision float in native format */
      case 'D':        /* ditto */
        while (len-- &gt; 0) {
        double d;

        from = NEXTFROM;
        d = RFLOAT_VALUE(rb_to_float(from));
        rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
        }
        break;

      case 'g':        /* single precision float in network byte-order */
        while (len-- &gt; 0) {
        float f;
        FLOAT_CONVWITH(ftmp);

        from = NEXTFROM;
        f = (float)RFLOAT_VALUE(rb_to_float(from));
        f = HTONF(f,ftmp);
        rb_str_buf_cat(res, (char*)&amp;f, sizeof(float));
        }
        break;

      case 'G':        /* double precision float in network byte-order */
        while (len-- &gt; 0) {
        double d;
        DOUBLE_CONVWITH(dtmp);

        from = NEXTFROM;
        d = RFLOAT_VALUE(rb_to_float(from));
        d = HTOND(d,dtmp);
        rb_str_buf_cat(res, (char*)&amp;d, sizeof(double));
        }
        break;

      case 'x':        /* null byte */
      grow:
        while (len &gt;= 10) {
        rb_str_buf_cat(res, nul10, 10);
        len -= 10;
        }
        rb_str_buf_cat(res, nul10, len);
        break;

      case 'X':        /* back up byte */
      shrink:
        plen = RSTRING_LEN(res);
        if (plen &lt; len)
        rb_raise(rb_eArgError, &quot;X outside of string&quot;);
        rb_str_set_len(res, plen - len);
        break;

      case '@':        /* null fill to absolute position */
        len -= RSTRING_LEN(res);
        if (len &gt; 0) goto grow;
        len = -len;
        if (len &gt; 0) goto shrink;
        break;

      case '%':
        rb_raise(rb_eArgError, &quot;%% is not supported&quot;);
        break;

      case 'U':        /* Unicode character */
        while (len-- &gt; 0) {
        SIGNED_VALUE l;
        char buf[8];
        int le;

        from = NEXTFROM;
        from = rb_to_int(from);
        l = NUM2LONG(from);
        if (l &lt; 0) {
            rb_raise(rb_eRangeError, &quot;pack(U): value out of range&quot;);
        }
        le = rb_uv_to_utf8(buf, l);
        rb_str_buf_cat(res, (char*)buf, le);
        }
        break;

      case 'u':        /* uuencoded string */
      case 'm':        /* base64 encoded string */
        from = NEXTFROM;
        StringValue(from);
        ptr = RSTRING_PTR(from);
        plen = RSTRING_LEN(from);

        if (len == 0 &amp;&amp; type == 'm') {
        encodes(res, ptr, plen, type, 0);
        ptr += plen;
        break;
        }
        if (len &lt;= 2)
        len = 45;
        else
        len = len / 3 * 3;
        while (plen &gt; 0) {
        long todo;

        if (plen &gt; len)
            todo = len;
        else
            todo = plen;
        encodes(res, ptr, todo, type, 1);
        plen -= todo;
        ptr += todo;
        }
        break;

      case 'M':        /* quoted-printable encoded string */
        from = rb_obj_as_string(NEXTFROM);
        if (len &lt;= 1)
        len = 72;
        qpencode(res, from, len);
        break;

      case 'P':        /* pointer to packed byte string */
        from = THISFROM;
        if (!NIL_P(from)) {
        StringValue(from);
        if (RSTRING_LEN(from) &lt; len) {
            rb_raise(rb_eArgError, &quot;too short buffer for P(%ld for %ld)&quot;,
                 RSTRING_LEN(from), len);
        }
        }
        len = 1;
        /* FALL THROUGH */
      case 'p':        /* pointer to string */
        while (len-- &gt; 0) {
        char *t;
        from = NEXTFROM;
        if (NIL_P(from)) {
            t = 0;
        }
        else {
            t = StringValuePtr(from);
        }
        if (!associates) {
            associates = rb_ary_new();
        }
        rb_ary_push(associates, from);
        rb_obj_taint(from);
        rb_str_buf_cat(res, (char*)&amp;t, sizeof(char*));
        }
        break;

      case 'w':        /* BER compressed integer  */
        while (len-- &gt; 0) {
        unsigned long ul;
        VALUE buf = rb_str_new(0, 0);
        char c, *bufs, *bufe;

        from = NEXTFROM;
        if (TYPE(from) == T_BIGNUM) {
            VALUE big128 = rb_uint2big(128);
            while (TYPE(from) == T_BIGNUM) {
            from = rb_big_divmod(from, big128);
            c = NUM2INT(RARRAY_PTR(from)[1]) | 0x80; /* mod */
            rb_str_buf_cat(buf, &amp;c, sizeof(char));
            from = RARRAY_PTR(from)[0]; /* div */
            }
        }

        {
            long l = NUM2LONG(from);
            if (l &lt; 0) {
            rb_raise(rb_eArgError, &quot;can't compress negative numbers&quot;);
            }
            ul = l;
        }

        while (ul) {
            c = (char)(ul &amp; 0x7f) | 0x80;
            rb_str_buf_cat(buf, &amp;c, sizeof(char));
            ul &gt;&gt;=  7;
        }

        if (RSTRING_LEN(buf)) {
            bufs = RSTRING_PTR(buf);
            bufe = bufs + RSTRING_LEN(buf) - 1;
            *bufs &amp;= 0x7f; /* clear continue bit */
            while (bufs &lt; bufe) { /* reverse */
            c = *bufs;
            *bufs++ = *bufe;
            *bufe-- = c;
            }
            rb_str_buf_cat(res, RSTRING_PTR(buf), RSTRING_LEN(buf));
        }
        else {
            c = 0;
            rb_str_buf_cat(res, &amp;c, sizeof(char));
        }
        }
        break;

      default:
        break;
    }
    }

    if (associates) {
    rb_str_associate(res, associates);
    }
    OBJ_INFECT(res, fmt);
    switch (enc_info) {
      case 1:
    ENCODING_CODERANGE_SET(res, rb_usascii_encindex(), ENC_CODERANGE_7BIT);
    break;
      case 2:
    rb_enc_set_index(res, rb_utf8_encindex());
    break;
      default:
    /* do nothing, keep ASCII-8BIT */
    break;
    }
    return res;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="permutation-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>permutation</strong> {|p| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>permutation</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>permutation</strong>(n) {|p| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>permutation</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
When invoked with a block, yield all permutations of length <em>n</em> of
the elements of <em>ary</em>, then return the array itself. If <em>n</em>
is not specified, yield all permutations of all elements. The
implementation makes no guarantees about the order in which the
permutations are yielded.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<p>
Examples:
</p>
<pre class="code">
   a = [1, 2, 3]
   a.permutation.to_a     #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
   a.permutation(1).to_a  #=&gt; [[1],[2],[3]]
   a.permutation(2).to_a  #=&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
   a.permutation(3).to_a  #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
   a.permutation(0).to_a  #=&gt; [[]] # one permutation of length 0
   a.permutation(4).to_a  #=&gt; []   # no permutations of length 4</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>permutation</strong> {|p| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>p</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>permutation</strong>(n) {|p| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>p</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.permutation { |p| block }          -&gt; ary
 *     ary.permutation                        -&gt; an_enumerator
 *     ary.permutation(n) { |p| block }       -&gt; ary
 *     ary.permutation(n)                     -&gt; an_enumerator
 *
 * When invoked with a block, yield all permutations of length &lt;i&gt;n&lt;/i&gt;
 * of the elements of &lt;i&gt;ary&lt;/i&gt;, then return the array itself.
 * If &lt;i&gt;n&lt;/i&gt; is not specified, yield all permutations of all elements.
 * The implementation makes no guarantees about the order in which
 * the permutations are yielded.
 *
 * If no block is given, an enumerator is returned instead.
 *
 * Examples:
 *
 *     a = [1, 2, 3]
 *     a.permutation.to_a     #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 *     a.permutation(1).to_a  #=&gt; [[1],[2],[3]]
 *     a.permutation(2).to_a  #=&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
 *     a.permutation(3).to_a  #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 *     a.permutation(0).to_a  #=&gt; [[]] # one permutation of length 0
 *     a.permutation(4).to_a  #=&gt; []   # no permutations of length 4
 */

static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    VALUE num;
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_ENUMERATOR(ary, argc, argv);   /* Return enumerator if no block */
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);
    r = NIL_P(num) ? n : NUM2LONG(num);   /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) {
    /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
    rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
    }
    }
    else {             /* this is the general case */
    volatile VALUE t0 = tmpbuf(n,sizeof(long));
    long *p = (long*)RSTRING_PTR(t0);
    volatile VALUE t1 = tmpbuf(n,sizeof(char));
    char *used = (char*)RSTRING_PTR(t1);
    VALUE ary0 = ary_make_substitution(ary); /* private defensive copy of ary */
    RBASIC(ary0)-&gt;klass = 0;

    MEMZERO(used, char, n); /* initialize array */

    permute0(n, r, p, 0, used, ary0); /* compute and yield permutations */
    tmpbuf_discard(t0);
    tmpbuf_discard(t1);
    RBASIC(ary0)-&gt;klass = rb_cArray;
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pop-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>pop</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>pop</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Removes the last element from <tt>self</tt> and returns it, or <tt>nil</tt>
if the array is empty.
</p>
<p>
If a number <em>n</em> is given, returns an array of the last n elements
(or less) just like <tt>array.slice!(-n, n)</tt> does.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.pop     #=&gt; &quot;d&quot;
   a.pop(2)  #=&gt; [&quot;b&quot;, &quot;c&quot;]
   a         #=&gt; [&quot;a&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>pop</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.pop    -&gt; obj or nil
 *     ary.pop(n) -&gt; new_ary
 *
 *  Removes the last element from +self+ and returns it, or
 *  &lt;code&gt;nil&lt;/code&gt; if the array is empty.
 *
 *  If a number _n_ is given, returns an array of the last n elements
 *  (or less) just like &lt;code&gt;array.slice!(-n, n)&lt;/code&gt; does.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.pop     #=&gt; &quot;d&quot;
 *     a.pop(2)  #=&gt; [&quot;b&quot;, &quot;c&quot;]
 *     a         #=&gt; [&quot;a&quot;]
 */

static VALUE
rb_ary_pop_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;

    if (argc == 0) {
    return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="product-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>product</strong>(other_ary, ...) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>product</strong>(other_ary, ...) {|p| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array of all combinations of elements from all arrays, The
length of the returned array is the product of the length of <tt>self</tt>
and the argument arrays. If given a block, <em>product</em> will yield all
combinations and return <tt>self</tt> instead.
</p>
<pre class="code">
   [1,2,3].product([4,5])     #=&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
   [1,2].product([1,2])       #=&gt; [[1,1],[1,2],[2,1],[2,2]]
   [1,2].product([3,4],[5,6]) #=&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
                              #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
   [1,2].product()            #=&gt; [[1],[2]]
   [1,2].product([])          #=&gt; []</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>product</strong>(other_ary, ...) {|p| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>p</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.product(other_ary, ...)                -&gt; new_ary
 *     ary.product(other_ary, ...) { |p| block }  -&gt; ary
 *
 *  Returns an array of all combinations of elements from all arrays,
 *  The length of the returned array is the product of the length
 *  of +self+ and the argument arrays.
 *  If given a block, &lt;i&gt;product&lt;/i&gt; will yield all combinations
 *  and return +self+ instead.
 *
 *
 *     [1,2,3].product([4,5])     #=&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
 *     [1,2].product([1,2])       #=&gt; [[1,1],[1,2],[2,1],[2,2]]
 *     [1,2].product([3,4],[5,6]) #=&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
 *                                #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
 *     [1,2].product()            #=&gt; [[1],[2]]
 *     [1,2].product([])          #=&gt; []
 */

static VALUE
rb_ary_product(int argc, VALUE *argv, VALUE ary)
{
    int n = argc+1;    /* How many arrays we're operating on */
    volatile VALUE t0 = tmpary(n);
    volatile VALUE t1 = tmpbuf(n, sizeof(int));
    VALUE *arrays = RARRAY_PTR(t0); /* The arrays we're computing the product of */
    int *counters = (int*)RSTRING_PTR(t1); /* The current position in each one */
    VALUE result = Qnil;      /* The array we'll be returning, when no block given */
    long i,j;
    long resultlen = 1;

    RBASIC(t0)-&gt;klass = 0;
    RBASIC(t1)-&gt;klass = 0;

    /* initialize the arrays of arrays */
    ARY_SET_LEN(t0, n);
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = Qnil;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);

    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Otherwise, allocate and fill in an array of results */
    if (rb_block_given_p()) {
    /* Make defensive copies of arrays; exit if any is empty */
    for (i = 0; i &lt; n; i++) {
        if (RARRAY_LEN(arrays[i]) == 0) goto done;
        arrays[i] = ary_make_substitution(arrays[i]);
    }
    }
    else {
    /* Compute the length of the result array; return [] if any is empty */
    for (i = 0; i &lt; n; i++) {
        long k = RARRAY_LEN(arrays[i]), l = resultlen;
        if (k == 0) {
        result = rb_ary_new2(0);
        goto done;
        }
        resultlen *= k;
        if (resultlen &lt; k || resultlen &lt; l || resultlen / k != l) {
        rb_raise(rb_eRangeError, &quot;too big to product&quot;);
        }
    }
    result = rb_ary_new2(resultlen);
    }
    for (;;) {
    int m;
    /* fill in one subarray */
    VALUE subarray = rb_ary_new2(n);
    for (j = 0; j &lt; n; j++) {
        rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
    }

    /* put it on the result array */
    if(NIL_P(result)) {
        FL_SET(t0, FL_USER5);
        rb_yield(subarray);
        if (! FL_TEST(t0, FL_USER5)) {
        rb_raise(rb_eRuntimeError, &quot;product reentered&quot;);
        }
        else {
        FL_UNSET(t0, FL_USER5);
        }
    }
    else {
        rb_ary_push(result, subarray);
    }

    /*
     * Increment the last counter.  If it overflows, reset to 0
     * and increment the one before it.
     */
    m = n-1;
    counters[m]++;
    while (counters[m] == RARRAY_LEN(arrays[m])) {
        counters[m] = 0;
        /* If the first counter overlows, we are done */
        if (--m &lt; 0) goto done;
        counters[m]++;
    }
    }
done:
    tmpary_discard(t0);
    tmpbuf_discard(t1);

    return NIL_P(result) ? ary : result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="push-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>push</strong>(obj, ...) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Append--Pushes the given object(s) on to the end of this array. This
expression returns the array itself, so several appends may be chained
together.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.push(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)
           #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.push(obj, ... )   -&gt; ary
 *
 *  Append---Pushes the given object(s) on to the end of this array. This
 *  expression returns the array itself, so several appends
 *  may be chained together.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.push(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)
 *             #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
 */

static VALUE
rb_ary_push_m(int argc, VALUE *argv, VALUE ary)
{
    rb_ary_modify(ary);
    while (argc--) {
    rb_ary_push_1(ary, *argv++);
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rassoc-instance_method">
  
    - (<tt>nil</tt>) <strong>rassoc</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Searches through the array whose elements are also arrays. Compares
<em>obj</em> with the second element of each contained array using
<tt>==</tt>. Returns the first contained array that matches. See also
<tt>Array#assoc</tt>.
</p>
<pre class="code">
   a = [ [ 1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [&quot;ii&quot;, &quot;two&quot;] ]
   a.rassoc(&quot;two&quot;)    #=&gt; [2, &quot;two&quot;]
   a.rassoc(&quot;four&quot;)   #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.rassoc(obj) -&gt; new_ary or nil
 *
 *  Searches through the array whose elements are also arrays. Compares
 *  _obj_ with the second element of each contained array using
 *  &lt;code&gt;==&lt;/code&gt;. Returns the first contained array that matches. See
 *  also &lt;code&gt;Array#assoc&lt;/code&gt;.
 *
 *     a = [ [ 1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [&quot;ii&quot;, &quot;two&quot;] ]
 *     a.rassoc(&quot;two&quot;)    #=&gt; [2, &quot;two&quot;]
 *     a.rassoc(&quot;four&quot;)   #=&gt; nil
 */

VALUE
rb_ary_rassoc(VALUE ary, VALUE value)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
    v = RARRAY_PTR(ary)[i];
    if (TYPE(v) == T_ARRAY &amp;&amp;
        RARRAY_LEN(v) &gt; 1 &amp;&amp;
        rb_equal(RARRAY_PTR(v)[1], value))
        return v;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reject-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reject</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reject</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array containing the items in <tt>self</tt> for which the
block is not true. See also <tt>Array#delete_if</tt>
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reject</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.reject {|item| block }  -&gt; new_ary
 *     ary.reject                  -&gt; an_enumerator
 *
 *  Returns a new array containing the items in +self+
 *  for which the block is not true.
 *  See also &lt;code&gt;Array#delete_if&lt;/code&gt;
 *
 *  If no block is given, an enumerator is returned instead.
 *
 */

static VALUE
rb_ary_reject(VALUE ary)
{
    RETURN_ENUMERATOR(ary, 0, 0);
    ary = rb_ary_dup(ary);
    rb_ary_reject_bang(ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reject!-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>reject!</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reject!</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equivalent to <tt>Array#delete_if</tt>, deleting elements from
<tt>self</tt> for which the block evaluates to true, but returns
<tt>nil</tt> if no changes were made. See also <tt>Enumerable#reject</tt>
and <tt>Array#delete_if</tt>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>reject!</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.reject! {|item| block }  -&gt; ary or nil
 *     ary.reject!                  -&gt; an_enumerator
 *
 *  Equivalent to &lt;code&gt;Array#delete_if&lt;/code&gt;, deleting elements from
 *  +self+ for which the block evaluates to true, but returns
 *  &lt;code&gt;nil&lt;/code&gt; if no changes were made.
 *  See also &lt;code&gt;Enumerable#reject&lt;/code&gt; and &lt;code&gt;Array#delete_if&lt;/code&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 */

static VALUE
rb_ary_reject_bang(VALUE ary)
{
    long i1, i2;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
    VALUE v = RARRAY_PTR(ary)[i1];
    if (RTEST(rb_yield(v))) continue;
    if (i1 != i2) {
        rb_ary_store(ary, i2, v);
    }
    i2++;
    }

    if (RARRAY_LEN(ary) == i2) return Qnil;
    if (i2 &lt; RARRAY_LEN(ary))
    ARY_SET_LEN(ary, i2);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="repeated_combination-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>repeated_combination</strong>(n) {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>repeated_combination</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
When invoked with a block, yields all repeated combinations of length
<em>n</em> of elements from <em>ary</em> and then returns <em>ary</em>
itself. The implementation makes no guarantees about the order in which the
repeated combinations are yielded.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<p>
Examples:
</p>
<pre class="code">
   a = [1, 2, 3]
   a.repeated_combination(1).to_a  #=&gt; [[1], [2], [3]]
   a.repeated_combination(2).to_a  #=&gt; [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
   a.repeated_combination(3).to_a  #=&gt; [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],
                                   #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]
   a.repeated_combination(4).to_a  #=&gt; [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],
                                   #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],
                                   #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]
   a.repeated_combination(0).to_a  #=&gt; [[]] # one combination of length 0</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>repeated_combination</strong>(n) {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.repeated_combination(n) { |c| block } -&gt; ary
 *     ary.repeated_combination(n)               -&gt; an_enumerator
 *
 * When invoked with a block, yields all repeated combinations of
 * length &lt;i&gt;n&lt;/i&gt; of elements from &lt;i&gt;ary&lt;/i&gt; and then returns
 * &lt;i&gt;ary&lt;/i&gt; itself.
 * The implementation makes no guarantees about the order in which
 * the repeated combinations are yielded.
 *
 * If no block is given, an enumerator is returned instead.
 *
 * Examples:
 *
 *     a = [1, 2, 3]
 *     a.repeated_combination(1).to_a  #=&gt; [[1], [2], [3]]
 *     a.repeated_combination(2).to_a  #=&gt; [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]
 *     a.repeated_combination(3).to_a  #=&gt; [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],
 *                                     #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]
 *     a.repeated_combination(4).to_a  #=&gt; [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],
 *                                     #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],
 *                                     #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]
 *     a.repeated_combination(0).to_a  #=&gt; [[]] # one combination of length 0
 *
 */

static VALUE
rb_ary_repeated_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);                 /* Combination size from argument */
    RETURN_ENUMERATOR(ary, 1, &amp;num);   /* Return enumerator if no block */
    len = RARRAY_LEN(ary);
    if (n &lt; 0) {
    /* yield nothing */
    }
    else if (n == 0) {
    rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
    for (i = 0; i &lt; len; i++) {
        rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
    }
    }
    else if (len == 0) {
    /* yield nothing */
    }
    else {
    volatile VALUE t0 = tmpbuf(n, sizeof(long));
    long *p = (long*)RSTRING_PTR(t0);
    VALUE ary0 = ary_make_substitution(ary); /* private defensive copy of ary */
    RBASIC(ary0)-&gt;klass = 0;

    rcombinate0(len, n, p, 0, n, ary0); /* compute and yield repeated combinations */
    tmpbuf_discard(t0);
    RBASIC(ary0)-&gt;klass = rb_cArray;
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="repeated_permutation-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>repeated_permutation</strong>(n) {|p| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>repeated_permutation</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
When invoked with a block, yield all repeated permutations of length
<em>n</em> of the elements of <em>ary</em>, then return the array itself.
The implementation makes no guarantees about the order in which the
repeated permutations are yielded.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<p>
Examples:
</p>
<pre class="code">
   a = [1, 2]
   a.repeated_permutation(1).to_a  #=&gt; [[1], [2]]
   a.repeated_permutation(2).to_a  #=&gt; [[1,1],[1,2],[2,1],[2,2]]
   a.repeated_permutation(3).to_a  #=&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],
                                   #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]
   a.repeated_permutation(0).to_a  #=&gt; [[]] # one permutation of length 0</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>repeated_permutation</strong>(n) {|p| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>p</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.repeated_permutation(n) { |p| block } -&gt; ary
 *     ary.repeated_permutation(n)               -&gt; an_enumerator
 *
 * When invoked with a block, yield all repeated permutations of length
 * &lt;i&gt;n&lt;/i&gt; of the elements of &lt;i&gt;ary&lt;/i&gt;, then return the array itself.
 * The implementation makes no guarantees about the order in which
 * the repeated permutations are yielded.
 *
 * If no block is given, an enumerator is returned instead.
 *
 * Examples:
 *
 *     a = [1, 2]
 *     a.repeated_permutation(1).to_a  #=&gt; [[1], [2]]
 *     a.repeated_permutation(2).to_a  #=&gt; [[1,1],[1,2],[2,1],[2,2]]
 *     a.repeated_permutation(3).to_a  #=&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],
 *                                     #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]
 *     a.repeated_permutation(0).to_a  #=&gt; [[]] # one permutation of length 0
 */

static VALUE
rb_ary_repeated_permutation(VALUE ary, VALUE num)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_ENUMERATOR(ary, 1, &amp;num);      /* Return enumerator if no block */
    r = NUM2LONG(num);                    /* Permutation size from argument */

    if (r &lt; 0) {
    /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
    rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_yield(rb_ary_new3(1, RARRAY_PTR(ary)[i]));
    }
    }
    else {             /* this is the general case */
    volatile VALUE t0 = tmpbuf(r, sizeof(long));
    long *p = (long*)RSTRING_PTR(t0);
    VALUE ary0 = ary_make_substitution(ary); /* private defensive copy of ary */
    RBASIC(ary0)-&gt;klass = 0;

    rpermute0(n, r, p, 0, ary0); /* compute and yield repeated permutations */
    tmpbuf_discard(t0);
    RBASIC(ary0)-&gt;klass = rb_cArray;
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="replace-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>replace</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Replaces the contents of <tt>self</tt> with the contents of
<em>other_ary</em>, truncating or expanding if necessary.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
   a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.replace(other_ary)  -&gt; ary
 *
 *  Replaces the contents of +self+ with the contents of
 *  &lt;i&gt;other_ary&lt;/i&gt;, truncating or expanding if necessary.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 *     a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 */

VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    if (RARRAY_LEN(orig) &lt;= RARRAY_EMBED_LEN_MAX) {
        VALUE *ptr;
        VALUE shared = 0;

        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else if (ARY_SHARED_P(copy)) {
            shared = ARY_SHARED(copy);
            FL_UNSET_SHARED(copy);
        }
        FL_SET_EMBED(copy);
        ptr = RARRAY_PTR(orig);
        MEMCPY(RARRAY_PTR(copy), ptr, VALUE, RARRAY_LEN(orig));
        if (shared) {
            rb_ary_decrement_share(shared);
        }
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
    }
    else {
        VALUE shared = ary_make_shared(orig);
        if (ARY_OWNS_HEAP_P(copy)) {
            xfree(RARRAY_PTR(copy));
        }
        else {
            rb_ary_unshare_safe(copy);
        }
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, RARRAY_PTR(orig));
        ARY_SET_LEN(copy, RARRAY_LEN(orig));
        rb_ary_set_shared(copy, shared);
    }
    return copy;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reverse-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reverse</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array containing <tt>self</tt>&#8217;s elements in reverse
order.
</p>
<pre class="code">
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].reverse   #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
   [ 1 ].reverse               #=&gt; [1]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.reverse -&gt; new_ary
 *
 *  Returns a new array containing +self+'s elements in reverse order.
 *
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].reverse   #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 *     [ 1 ].reverse               #=&gt; [1]
 */

static VALUE
rb_ary_reverse_m(VALUE ary)
{
    VALUE dup = rb_ary_dup_setup(ary);
    long len = RARRAY_LEN(ary);

    if (len &gt; 0) {
    VALUE *p1 = RARRAY_PTR(ary);
    VALUE *p2 = RARRAY_PTR(dup) + len - 1;
    do *p2-- = *p1++; while (--len &gt; 0);
    }
    return dup;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reverse!-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reverse!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reverses <tt>self</tt> in place.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.reverse!       #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
   a                #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.reverse!   -&gt; ary
 *
 *  Reverses +self+ in place.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.reverse!       #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 *     a                #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 */

static VALUE
rb_ary_reverse_bang(VALUE ary)
{
    return rb_ary_reverse(ary);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reverse_each-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reverse_each</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reverse_each</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Same as <tt>Array#each</tt>, but traverses <tt>self</tt> in reverse order.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.reverse_each {|x| print x, &quot; &quot; }
</pre>
<p>
produces:
</p>
<pre class="code">
   c b a</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reverse_each</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.reverse_each {|item| block }   -&gt; ary
 *     ary.reverse_each                   -&gt; an_enumerator
 *
 *  Same as &lt;code&gt;Array#each&lt;/code&gt;, but traverses +self+ in reverse
 *  order.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.reverse_each {|x| print x, &quot; &quot; }
 *
 *  produces:
 *
 *     c b a
 */

static VALUE
rb_ary_reverse_each(VALUE ary)
{
    long len;

    RETURN_ENUMERATOR(ary, 0, 0);
    len = RARRAY_LEN(ary);
    while (len--) {
    rb_yield(RARRAY_PTR(ary)[len]);
    if (RARRAY_LEN(ary) &lt; len) {
        len = RARRAY_LEN(ary);
    }
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rindex-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>rindex</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>rindex</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>rindex</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the index of the last object in <tt>self</tt> <tt>==</tt> to
<em>obj</em>. If a block is given instead of an argument, returns first
object for which <em>block</em> is true, starting from the last object.
Returns <tt>nil</tt> if no match is found. See also <tt>Array#index</tt>.
</p>
<p>
If neither block nor argument is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.rindex(&quot;b&quot;)        #=&gt; 3
   a.rindex(&quot;z&quot;)        #=&gt; nil
   a.rindex{|x|x==&quot;b&quot;}  #=&gt; 3</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>rindex</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>rindex</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.rindex(obj)           -&gt;  int or nil
 *     ary.rindex {|item| block} -&gt;  int or nil
 *     ary.rindex                -&gt;  an_enumerator
 *
 *  Returns the index of the last object in +self+
 *  &lt;code&gt;==&lt;/code&gt; to &lt;i&gt;obj&lt;/i&gt;. If a block is given instead of an
 *  argument, returns first object for which &lt;em&gt;block&lt;/em&gt; is
 *  true, starting from the last object.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no match is found.
 *  See also &lt;code&gt;Array#index&lt;/code&gt;.
 *
 *  If neither block nor argument is given, an enumerator is returned instead.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.rindex(&quot;b&quot;)        #=&gt; 3
 *     a.rindex(&quot;z&quot;)        #=&gt; nil
 *     a.rindex{|x|x==&quot;b&quot;}  #=&gt; 3
 */

static VALUE
rb_ary_rindex(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i = RARRAY_LEN(ary);

    if (argc == 0) {
    RETURN_ENUMERATOR(ary, 0, 0);
    while (i--) {
        if (RTEST(rb_yield(RARRAY_PTR(ary)[i])))
        return LONG2NUM(i);
        if (i &gt; RARRAY_LEN(ary)) {
        i = RARRAY_LEN(ary);
        }
    }
    return Qnil;
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;val);
    if (rb_block_given_p())
    rb_warn(&quot;given block not used&quot;);
    while (i--) {
    if (rb_equal(RARRAY_PTR(ary)[i], val))
        return LONG2NUM(i);
    if (i &gt; RARRAY_LEN(ary)) {
        i = RARRAY_LEN(ary);
    }
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rotate-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>rotate</strong>([n = 1]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns new array by rotating <tt>self</tt>, whose first element is the
element at <tt>cnt</tt> in <tt>self</tt>.  If <tt>cnt</tt> is negative then
it rotates in counter direction.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.rotate         #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
   a                #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
   a.rotate(2)      #=&gt; [&quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;]
   a.rotate(-3)     #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.rotate([n = 1]) -&gt; new_ary
 *
 *  Returns new array by rotating +self+, whose first element is the
 *  element at +cnt+ in +self+.  If +cnt+ is negative then it rotates
 *  in counter direction.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.rotate         #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
 *     a                #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 *     a.rotate(2)      #=&gt; [&quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;]
 *     a.rotate(-3)     #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
 */

static VALUE
rb_ary_rotate_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE rotated, *ptr, *ptr2;
    long len, cnt = 1;

    switch (argc) {
      case 1: cnt = NUM2LONG(argv[0]);
      case 0: break;
      default: rb_scan_args(argc, argv, &quot;01&quot;, NULL);
    }

    len = RARRAY_LEN(ary);
    rotated = rb_ary_dup_setup(ary);
    if (len &gt; 0) {
    cnt = rotate_count(cnt, len);
    ptr = RARRAY_PTR(ary);
    ptr2 = RARRAY_PTR(rotated);
    len -= cnt;
    MEMCPY(ptr2, ptr + cnt, VALUE, len);
    MEMCPY(ptr2 + len, ptr, VALUE, cnt);
    }
    return rotated;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rotate!-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>rotate!</strong>(cnt = 1) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Rotates <tt>self</tt> in place so that the element at <tt>cnt</tt> comes
first, and returns <tt>self</tt>.  If <tt>cnt</tt> is negative then it
rotates in counter direction.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.rotate!        #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
   a                #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
   a.rotate!(2)     #=&gt; [&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   a.rotate!(-3)    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.rotate!(cnt=1) -&gt; ary
 *
 *  Rotates +self+ in place so that the element at +cnt+ comes first,
 *  and returns +self+.  If +cnt+ is negative then it rotates in
 *  counter direction.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.rotate!        #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
 *     a                #=&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]
 *     a.rotate!(2)     #=&gt; [&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     a.rotate!(-3)    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 */

static VALUE
rb_ary_rotate_bang(int argc, VALUE *argv, VALUE ary)
{
    long n = 1;

    switch (argc) {
      case 1: n = NUM2LONG(argv[0]);
      case 0: break;
      default: rb_scan_args(argc, argv, &quot;01&quot;, NULL);
    }
    rb_ary_rotate(ary, n);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sample-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sample</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sample</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Choose a random element or <tt>n</tt> random elements from the array. The
elements are chosen by using random and unique indices into the array in
order to ensure that an element doesn&#8217;t repeat itself unless the
array already contained duplicate elements. If the array is empty the first
form returns <tt>nil</tt> and the second form returns an empty array.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sample</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.sample        -&gt; obj
 *     ary.sample(n)     -&gt; new_ary
 *
 *  Choose a random element or +n+ random elements from the array. The elements
 *  are chosen by using random and unique indices into the array in order to
 *  ensure that an element doesn't repeat itself unless the array already
 *  contained duplicate elements. If the array is empty the first form returns
 *  &lt;code&gt;nil&lt;/code&gt; and the second form returns an empty array.
 *
 */


static VALUE
rb_ary_sample(int argc, VALUE *argv, VALUE ary)
{
    VALUE nv, result, *ptr;
    long n, len, i, j, k, idx[10];

    len = RARRAY_LEN(ary);
    if (argc == 0) {
    if (len == 0) return Qnil;
    i = len == 1 ? 0 : (long)(rb_genrand_real()*len);
    return RARRAY_PTR(ary)[i];
    }
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;nv);
    n = NUM2LONG(nv);
    if (n &lt; 0) rb_raise(rb_eArgError, &quot;negative sample number&quot;);
    ptr = RARRAY_PTR(ary);
    len = RARRAY_LEN(ary);
    if (n &gt; len) n = len;
    switch (n) {
      case 0: return rb_ary_new2(0);
      case 1:
    return rb_ary_new4(1, &amp;ptr[(long)(rb_genrand_real()*len)]);
      case 2:
    i = (long)(rb_genrand_real()*len);
    j = (long)(rb_genrand_real()*(len-1));
    if (j &gt;= i) j++;
    return rb_ary_new3(2, ptr[i], ptr[j]);
      case 3:
    i = (long)(rb_genrand_real()*len);
    j = (long)(rb_genrand_real()*(len-1));
    k = (long)(rb_genrand_real()*(len-2));
    {
        long l = j, g = i;
        if (j &gt;= i) l = i, g = ++j;
        if (k &gt;= l &amp;&amp; (++k &gt;= g)) ++k;
    }
    return rb_ary_new3(3, ptr[i], ptr[j], ptr[k]);
    }
    if ((size_t)n &lt; sizeof(idx)/sizeof(idx[0])) {
    VALUE *ptr_result;
    long sorted[sizeof(idx)/sizeof(idx[0])];
    sorted[0] = idx[0] = (long)(rb_genrand_real()*len);
    for (i=1; i&lt;n; i++) {
        k = (long)(rb_genrand_real()*--len);
        for (j = 0; j &lt; i; ++j) {
        if (k &lt; sorted[j]) break;
        ++k;
        }
        memmove(&amp;sorted[j+1], &amp;sorted[j], sizeof(sorted[0])*(i-j));
        sorted[j] = idx[i] = k;
    }
    result = rb_ary_new2(n);
    ptr_result = RARRAY_PTR(result);
    for (i=0; i&lt;n; i++) {
        ptr_result[i] = ptr[idx[i]];
    }
    }
    else {
    VALUE *ptr_result;
    result = rb_ary_new4(len, ptr);
    ptr_result = RARRAY_PTR(result);
    RB_GC_GUARD(ary);
    for (i=0; i&lt;n; i++) {
        j = (long)(rb_genrand_real()*(len-i)) + i;
        nv = ptr_result[j];
        ptr_result[j] = ptr_result[i];
        ptr_result[i] = nv;
    }
    }
    ARY_SET_LEN(result, n);

    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="select-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>select</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>select</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block passing in successive elements from <tt>self</tt>,
returning an array containing those elements for which the block returns a
true value (equivalent to <tt>Enumerable#select</tt>).
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = %w{ a b c d e f }
   a.select {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>select</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.select {|item| block } -&gt; new_ary
 *     ary.select                 -&gt; an_enumerator
 *
 *  Invokes the block passing in successive elements from +self+,
 *  returning an array containing those elements for which the block
 *  returns a true value (equivalent to &lt;code&gt;Enumerable#select&lt;/code&gt;).
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = %w{ a b c d e f }
 *     a.select {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]
 */

static VALUE
rb_ary_select(VALUE ary)
{
    VALUE result;
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    result = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
    if (RTEST(rb_yield(RARRAY_PTR(ary)[i]))) {
        rb_ary_push(result, rb_ary_elt(ary, i));
    }
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="select!-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>select!</strong> {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>select!</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block passing in successive elements from <tt>self</tt>,
deleting elements for which the block returns a false value. It returns
<tt>self</tt> if changes were made, otherwise it returns <tt>nil</tt>. See
also <tt>Array#keep_if</tt>
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>select!</strong> {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.select! {|item| block } -&gt; new_ary or nil
 *     ary.select!                 -&gt; an_enumerator
 *
 *  Invokes the block passing in successive elements from
 *  +self+, deleting elements for which the block returns a
 *  false value. It returns +self+ if changes were made,
 *  otherwise it returns &lt;code&gt;nil&lt;/code&gt;.
 *  See also &lt;code&gt;Array#keep_if&lt;/code&gt;
 *
 *  If no block is given, an enumerator is returned instead.
 *
 */

static VALUE
rb_ary_select_bang(VALUE ary)
{
    long i1, i2;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
    VALUE v = RARRAY_PTR(ary)[i1];
    if (!RTEST(rb_yield(v))) continue;
    if (i1 != i2) {
        rb_ary_store(ary, i2, v);
    }
    i2++;
    }

    if (RARRAY_LEN(ary) == i2) return Qnil;
    if (i2 &lt; RARRAY_LEN(ary))
    ARY_SET_LEN(ary, i2);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="shift-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>shift</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>shift</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the first element of <tt>self</tt> and removes it (shifting all
other elements down by one). Returns <tt>nil</tt> if the array is empty.
</p>
<p>
If a number <em>n</em> is given, returns an array of the first n elements
(or less) just like <tt>array.slice!(0, n)</tt> does.
</p>
<pre class="code">
   args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
   args.shift     #=&gt; &quot;-m&quot;
   args           #=&gt; [&quot;-q&quot;, &quot;filename&quot;]

   args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
   args.shift(2)  #=&gt; [&quot;-m&quot;, &quot;-q&quot;]
   args           #=&gt; [&quot;filename&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>shift</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.shift    -&gt; obj or nil
 *     ary.shift(n) -&gt; new_ary
 *
 *  Returns the first element of +self+ and removes it (shifting all
 *  other elements down by one). Returns &lt;code&gt;nil&lt;/code&gt; if the array
 *  is empty.
 *
 *  If a number _n_ is given, returns an array of the first n elements
 *  (or less) just like &lt;code&gt;array.slice!(0, n)&lt;/code&gt; does.
 *
 *     args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
 *     args.shift     #=&gt; &quot;-m&quot;
 *     args           #=&gt; [&quot;-q&quot;, &quot;filename&quot;]
 *
 *     args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
 *     args.shift(2)  #=&gt; [&quot;-m&quot;, &quot;-q&quot;]
 *     args           #=&gt; [&quot;filename&quot;]
 */

static VALUE
rb_ary_shift_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;
    long n;

    if (argc == 0) {
    return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    n = RARRAY_LEN(result);
    if (ARY_SHARED_P(ary)) {
    if (ARY_SHARED_NUM(ARY_SHARED(ary)) == 1) {
        rb_mem_clear(RARRAY_PTR(ary), n);
    }
        ARY_INCREASE_PTR(ary, n);
    }
    else {
    MEMMOVE(RARRAY_PTR(ary), RARRAY_PTR(ary)+n, VALUE, RARRAY_LEN(ary)-n);
    }
    ARY_INCREASE_LEN(ary, -n);

    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="shuffle-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>shuffle</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array with elements of this array shuffled.
</p>
<pre class="code">
   a = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
   a.shuffle                 #=&gt; [2, 3, 1]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.shuffle -&gt; new_ary
 *
 *  Returns a new array with elements of this array shuffled.
 *
 *     a = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
 *     a.shuffle                 #=&gt; [2, 3, 1]
 */

static VALUE
rb_ary_shuffle(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_shuffle_bang(ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="shuffle!-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>shuffle!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Shuffles elements in <tt>self</tt> in place.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.shuffle!        -&gt; ary
 *
 *  Shuffles elements in +self+ in place.
 */


static VALUE
rb_ary_shuffle_bang(VALUE ary)
{
    VALUE *ptr;
    long i = RARRAY_LEN(ary);

    rb_ary_modify(ary);
    ptr = RARRAY_PTR(ary);
    while (i) {
    long j = (long)(rb_genrand_real()*i);
    VALUE tmp = ptr[--i];
    ptr[i] = ptr[j];
    ptr[j] = tmp;
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="slice-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]</strong>(index) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>[]</strong>(start, length) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>[]</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>slice</strong>(index) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>slice</strong>(start, length) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>slice</strong>(range) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Element Reference--Returns the element at <em>index</em>, or returns a
subarray starting at <em>start</em> and continuing for <em>length</em>
elements, or returns a subarray specified by <em>range</em>. Negative
indices count backward from the end of the array (-1 is the last element).
Returns <tt>nil</tt> if the index (or starting index) are out of range.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
   a[6]                   #=&gt; nil
   a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
   a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a[4..7]                #=&gt; [ &quot;e&quot; ]
   a[6..10]               #=&gt; nil
   a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
   # special cases
   a[5]                   #=&gt; nil
   a[5, 1]                #=&gt; []
   a[5..10]               #=&gt; []</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>[]</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>[]</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>[]</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>slice</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>slice</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>slice</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary[index]                -&gt; obj     or nil
 *     ary[start, length]        -&gt; new_ary or nil
 *     ary[range]                -&gt; new_ary or nil
 *     ary.slice(index)          -&gt; obj     or nil
 *     ary.slice(start, length)  -&gt; new_ary or nil
 *     ary.slice(range)          -&gt; new_ary or nil
 *
 *  Element Reference---Returns the element at _index_,
 *  or returns a subarray starting at _start_ and
 *  continuing for _length_ elements, or returns a subarray
 *  specified by _range_.
 *  Negative indices count backward from the end of the
 *  array (-1 is the last element). Returns +nil+ if the index
 *  (or starting index) are out of range.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
 *     a[6]                   #=&gt; nil
 *     a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
 *     a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a[4..7]                #=&gt; [ &quot;e&quot; ]
 *     a[6..10]               #=&gt; nil
 *     a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     # special cases
 *     a[5]                   #=&gt; nil
 *     a[5, 1]                #=&gt; []
 *     a[5..10]               #=&gt; []
 *
 */

VALUE
rb_ary_aref(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
    beg = NUM2LONG(argv[0]);
    len = NUM2LONG(argv[1]);
    if (beg &lt; 0) {
        beg += RARRAY_LEN(ary);
    }
    return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
    rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
    return rb_ary_entry(ary, FIX2LONG(arg));
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY_LEN(ary), 0)) {
      case Qfalse:
    break;
      case Qnil:
    return Qnil;
      default:
    return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="slice!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>slice!</strong>(index) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>slice!</strong>(start, length) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>slice!</strong>(range) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Deletes the element(s) given by an index (optionally with a length) or by a
range. Returns the deleted object (or objects), or <tt>nil</tt> if the
index is out of range.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.slice!(1)     #=&gt; &quot;b&quot;
   a               #=&gt; [&quot;a&quot;, &quot;c&quot;]
   a.slice!(-1)    #=&gt; &quot;c&quot;
   a               #=&gt; [&quot;a&quot;]
   a.slice!(100)   #=&gt; nil
   a               #=&gt; [&quot;a&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>slice!</strong>(index) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>slice!</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>slice!</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.slice!(index)         -&gt; obj or nil
 *     ary.slice!(start, length) -&gt; new_ary or nil
 *     ary.slice!(range)         -&gt; new_ary or nil
 *
 *  Deletes the element(s) given by an index (optionally with a length)
 *  or by a range. Returns the deleted object (or objects), or
 *  &lt;code&gt;nil&lt;/code&gt; if the index is out of range.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.slice!(1)     #=&gt; &quot;b&quot;
 *     a               #=&gt; [&quot;a&quot;, &quot;c&quot;]
 *     a.slice!(-1)    #=&gt; &quot;c&quot;
 *     a               #=&gt; [&quot;a&quot;]
 *     a.slice!(100)   #=&gt; nil
 *     a               #=&gt; [&quot;a&quot;]
 */

static VALUE
rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg1, arg2;
    long pos, len, orig_len;

    rb_ary_modify_check(ary);
    if (argc == 2) {
    pos = NUM2LONG(argv[0]);
    len = NUM2LONG(argv[1]);
      delete_pos_len:
    if (len &lt; 0) return Qnil;
    orig_len = RARRAY_LEN(ary);
    if (pos &lt; 0) {
        pos += orig_len;
        if (pos &lt; 0) return Qnil;
    }
    else if (orig_len &lt; pos) return Qnil;
    if (orig_len &lt; pos + len) {
        len = orig_len - pos;
    }
    if (len == 0) return rb_ary_new2(0);
    arg2 = rb_ary_new4(len, RARRAY_PTR(ary)+pos);
    RBASIC(arg2)-&gt;klass = rb_obj_class(ary);
    rb_ary_splice(ary, pos, len, Qundef);
    return arg2;
    }

    if (argc != 1) {
    /* error report */
    rb_scan_args(argc, argv, &quot;11&quot;, NULL, NULL);
    }
    arg1 = argv[0];

    if (!FIXNUM_P(arg1)) {
    switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
      case Qtrue:
        /* valid range */
        goto delete_pos_len;
      case Qnil:
        /* invalid range */
        return Qnil;
      default:
        /* not a range */
        break;
    }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sort-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort</strong> {|a, b| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array created by sorting <tt>self</tt>. Comparisons for the
sort will be done using the <tt>&lt;=&gt;</tt> operator or using an
optional code block. The block implements a comparison between <em>a</em>
and <em>b</em>, returning -1, 0, or +1. See also
<tt>Enumerable#sort_by</tt>.
</p>
<pre class="code">
   a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
   a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
   a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort</strong> {|a, b| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>a</tt>, <tt>b</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.sort                   -&gt; new_ary
 *     ary.sort {| a,b | block }  -&gt; new_ary
 *
 *  Returns a new array created by sorting +self+. Comparisons for
 *  the sort will be done using the &lt;code&gt;&lt;=&gt;&lt;/code&gt; operator or using
 *  an optional code block. The block implements a comparison between
 *  &lt;i&gt;a&lt;/i&gt; and &lt;i&gt;b&lt;/i&gt;, returning -1, 0, or +1. See also
 *  &lt;code&gt;Enumerable#sort_by&lt;/code&gt;.
 *
 *     a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
 *     a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
 *     a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 */

VALUE
rb_ary_sort(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sort!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort!</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort!</strong> {|a, b| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sorts <tt>self</tt>. Comparisons for the sort will be done using the
<tt>&lt;=&gt;</tt> operator or using an optional code block. The block
implements a comparison between <em>a</em> and <em>b</em>, returning -1, 0,
or +1. See also <tt>Enumerable#sort_by</tt>.
</p>
<pre class="code">
   a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
   a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
   a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort!</strong> {|a, b| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>a</tt>, <tt>b</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.sort!                   -&gt; ary
 *     ary.sort! {| a,b | block }  -&gt; ary
 *
 *  Sorts +self+. Comparisons for
 *  the sort will be done using the &lt;code&gt;&lt;=&gt;&lt;/code&gt; operator or using
 *  an optional code block. The block implements a comparison between
 *  &lt;i&gt;a&lt;/i&gt; and &lt;i&gt;b&lt;/i&gt;, returning -1, 0, or +1. See also
 *  &lt;code&gt;Enumerable#sort_by&lt;/code&gt;.
 *
 *     a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
 *     a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
 *     a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 */

VALUE
rb_ary_sort_bang(VALUE ary)
{
    rb_ary_modify(ary);
    assert(!ARY_SHARED_P(ary));
    if (RARRAY_LEN(ary) &gt; 1) {
    VALUE tmp = ary_make_substitution(ary); /* only ary refers tmp */
    struct ary_sort_data data;

    RBASIC(tmp)-&gt;klass = 0;
    data.ary = tmp;
    data.opt_methods = 0;
    data.opt_inited = 0;
    ruby_qsort(RARRAY_PTR(tmp), RARRAY_LEN(tmp), sizeof(VALUE),
           rb_block_given_p()?sort_1:sort_2, &amp;data);

        if (ARY_EMBED_P(tmp)) {
            assert(ARY_EMBED_P(tmp));
            if (ARY_SHARED_P(ary)) { /* ary might be destructively operated in the given block */
                rb_ary_unshare(ary);
            }
            FL_SET_EMBED(ary);
            MEMCPY(RARRAY_PTR(ary), ARY_EMBED_PTR(tmp), VALUE, ARY_EMBED_LEN(tmp));
            ARY_SET_LEN(ary, ARY_EMBED_LEN(tmp));
        }
        else {
            assert(!ARY_EMBED_P(tmp));
            if (ARY_HEAP_PTR(ary) == ARY_HEAP_PTR(tmp)) {
                assert(!ARY_EMBED_P(ary));
                FL_UNSET_SHARED(ary);
                ARY_SET_CAPA(ary, ARY_CAPA(tmp));
            }
            else {
                assert(!ARY_SHARED_P(tmp));
                if (ARY_EMBED_P(ary)) {
                    FL_UNSET_EMBED(ary);
                }
                else if (ARY_SHARED_P(ary)) {
                    /* ary might be destructively operated in the given block */
                    rb_ary_unshare(ary);
                }
                else {
                    xfree(ARY_HEAP_PTR(ary));
                }
                ARY_SET_PTR(ary, RARRAY_PTR(tmp));
                ARY_SET_HEAP_LEN(ary, RARRAY_LEN(tmp));
                ARY_SET_CAPA(ary, ARY_CAPA(tmp));
            }
            /* tmp was lost ownership for the ptr */
            FL_UNSET(tmp, FL_FREEZE);
            FL_SET_EMBED(tmp);
            ARY_SET_EMBED_LEN(tmp, 0);
            FL_SET(tmp, FL_FREEZE);
    }
        /* tmp will be GC'ed. */
        RBASIC(tmp)-&gt;klass = rb_cArray;
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sort_by!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort_by!</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort_by!</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sorts <tt>self</tt> in place using a set of keys generated by mapping the
values in <tt>self</tt> through the given block.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort_by!</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.sort_by! {| obj | block }    -&gt; ary
 *     ary.sort_by!                     -&gt; an_enumerator
 *
 *  Sorts +self+ in place using a set of keys generated by mapping the
 *  values in +self+ through the given block.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 */

static VALUE
rb_ary_sort_by_bang(VALUE ary)
{
    VALUE sorted;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    sorted = rb_block_call(ary, rb_intern(&quot;sort_by&quot;), 0, 0, sort_by_i, 0);
    rb_ary_replace(ary, sorted);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="take-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>take</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns first n elements from <em>ary</em>.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.take(3)             #=&gt; [1, 2, 3]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.take(n)               -&gt; new_ary
 *
 *  Returns first n elements from &lt;i&gt;ary&lt;/i&gt;.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take(3)             #=&gt; [1, 2, 3]
 *
 */

static VALUE
rb_ary_take(VALUE obj, VALUE n)
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
    rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }
    return rb_ary_subseq(obj, 0, len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="take_while-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>take_while</strong> {|arr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>take_while</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes elements to the block until the block returns <tt>nil</tt> or
<tt>false</tt>, then stops iterating and returns an array of all prior
elements.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.take_while {|i| i &lt; 3 }   #=&gt; [1, 2]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>take_while</strong> {|arr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>arr</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.take_while {|arr| block }   -&gt; new_ary
 *     ary.take_while                  -&gt; an_enumerator
 *
 *  Passes elements to the block until the block returns +nil+ or +false+,
 *  then stops iterating and returns an array of all prior elements.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take_while {|i| i &lt; 3 }   #=&gt; [1, 2]
 *
 */

static VALUE
rb_ary_take_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
    if (!RTEST(rb_yield(RARRAY_PTR(ary)[i]))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_a-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_a</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>self</tt>. If called on a subclass of Array, converts the
receiver to an Array object.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.to_a     -&gt; ary
 *
 *  Returns +self+. If called on a subclass of Array, converts
 *  the receiver to an Array object.
 */

static VALUE
rb_ary_to_a(VALUE ary)
{
    if (rb_obj_class(ary) != rb_cArray) {
    VALUE dup = rb_ary_new2(RARRAY_LEN(ary));
    rb_ary_replace(dup, ary);
    return dup;
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_ary-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_ary</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>self</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.to_ary -&gt; ary
 *
 *  Returns +self+.
 */

static VALUE
rb_ary_to_ary_m(VALUE ary)
{
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="transpose-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>transpose</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Assumes that <tt>self</tt> is an array of arrays and transposes the rows
and columns.
</p>
<pre class="code">
   a = [[1,2], [3,4], [5,6]]
   a.transpose   #=&gt; [[1, 3, 5], [2, 4, 6]]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.transpose -&gt; new_ary
 *
 *  Assumes that +self+ is an array of arrays and transposes the
 *  rows and columns.
 *
 *     a = [[1,2], [3,4], [5,6]]
 *     a.transpose   #=&gt; [[1, 3, 5], [2, 4, 6]]
 */

static VALUE
rb_ary_transpose(VALUE ary)
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY_LEN(ary);
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
    tmp = to_ary(rb_ary_elt(ary, i));
    if (elen &lt; 0) {        /* first element */
        elen = RARRAY_LEN(tmp);
        result = rb_ary_new2(elen);
        for (j=0; j&lt;elen; j++) {
        rb_ary_store(result, j, rb_ary_new2(alen));
        }
    }
    else if (elen != RARRAY_LEN(tmp)) {
        rb_raise(rb_eIndexError, &quot;element size differs (%ld should be %ld)&quot;,
             RARRAY_LEN(tmp), elen);
    }
    for (j=0; j&lt;elen; j++) {
        rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
    }
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="uniq-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>uniq</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array by removing duplicate values in <tt>self</tt>.
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.uniq   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]
   c.uniq {|s| s[/^\w+/]}  #=&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.uniq   -&gt; new_ary
 *
 *  Returns a new array by removing duplicate values in +self+.
 *
 *     a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.uniq   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]
 *     c.uniq {|s| s[/^\w+/]}  #=&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]
 */

static VALUE
rb_ary_uniq(VALUE ary)
{
    VALUE hash, uniq, v;
    long i;

    if (RARRAY_LEN(ary) &lt;= 1)
        return rb_ary_dup(ary);
    if (rb_block_given_p()) {
    hash = ary_make_hash_by(ary);
    uniq = ary_new(rb_obj_class(ary), RHASH_SIZE(hash));
    st_foreach(RHASH_TBL(hash), push_value, uniq);
    }
    else {
    hash = ary_make_hash(ary);
    uniq = ary_new(rb_obj_class(ary), RHASH_SIZE(hash));
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        st_data_t vv = (st_data_t)(v = rb_ary_elt(ary, i));
        if (st_delete(RHASH_TBL(hash), &amp;vv, 0)) {
        rb_ary_push(uniq, v);
        }
    }
    }
    ary_recycle_hash(hash);

    return uniq;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="uniq!-instance_method">
  
    - (<tt>nil</tt>) <strong>uniq!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Removes duplicate elements from <tt>self</tt>. Returns <tt>nil</tt> if no
changes are made (that is, no duplicates are found).
</p>
<pre class="code">
   a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
   a.uniq!   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   b = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
   b.uniq!   #=&gt; nil
   c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]
   c.uniq! {|s| s[/^\w+/]}  #=&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.uniq! -&gt; ary or nil
 *
 *  Removes duplicate elements from +self+.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no changes are made (that is, no
 *  duplicates are found).
 *
 *     a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.uniq!   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     b = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     b.uniq!   #=&gt; nil
 *     c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]
 *     c.uniq! {|s| s[/^\w+/]}  #=&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]
 */

static VALUE
rb_ary_uniq_bang(VALUE ary)
{
    VALUE hash, v;
    long i, j;

    rb_ary_modify_check(ary);
    if (RARRAY_LEN(ary) &lt;= 1)
        return Qnil;
    if (rb_block_given_p()) {
    hash = ary_make_hash_by(ary);
    if (RARRAY_LEN(ary) == (i = RHASH_SIZE(hash))) {
        return Qnil;
    }
    ary_resize_capa(ary, i);
    ARY_SET_LEN(ary, 0);
    st_foreach(RHASH_TBL(hash), push_value, ary);
    }
    else {
    hash = ary_make_hash(ary);
    if (RARRAY_LEN(ary) == (long)RHASH_SIZE(hash)) {
        return Qnil;
    }
    for (i=j=0; i&lt;RARRAY_LEN(ary); i++) {
        st_data_t vv = (st_data_t)(v = rb_ary_elt(ary, i));
        if (st_delete(RHASH_TBL(hash), &amp;vv, 0)) {
        rb_ary_store(ary, j++, v);
        }
    }
    ARY_SET_LEN(ary, j);
    }
    ary_recycle_hash(hash);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="unshift-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>unshift</strong>(obj, ...) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Prepends objects to the front of <tt>self</tt>, moving other elements
upwards.
</p>
<pre class="code">
   a = [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
   a.unshift(&quot;a&quot;)   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
   a.unshift(1, 2)  #=&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.unshift(obj, ...)  -&gt; ary
 *
 *  Prepends objects to the front of +self+,
 *  moving other elements upwards.
 *
 *     a = [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.unshift(&quot;a&quot;)   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 *     a.unshift(1, 2)  #=&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 */

static VALUE
rb_ary_unshift_m(int argc, VALUE *argv, VALUE ary)
{
    long len;

    rb_ary_modify(ary);
    if (argc == 0) return ary;
    if (ARY_CAPA(ary) &lt;= (len = RARRAY_LEN(ary)) + argc) {
    ary_double_capa(ary, len + argc);
    }

    /* sliding items */
    MEMMOVE(RARRAY_PTR(ary) + argc, RARRAY_PTR(ary), VALUE, len);
    MEMCPY(RARRAY_PTR(ary), argv, VALUE, argc);
    ARY_INCREASE_LEN(ary, argc);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="values_at-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>values_at</strong>(selector, ...) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array containing the elements in <tt>self</tt> corresponding to
the given selector(s). The selectors may be either integer indices or
ranges. See also <tt>Array#select</tt>.
</p>
<pre class="code">
   a = %w{ a b c d e f }
   a.values_at(1, 3, 5)
   a.values_at(1, 3, 5, 7)
   a.values_at(-1, -3, -5, -7)
   a.values_at(1..3, 2...5)</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.values_at(selector,... )  -&gt; new_ary
 *
 *  Returns an array containing the elements in
 *  +self+ corresponding to the given selector(s). The selectors
 *  may be either integer indices or ranges.
 *  See also &lt;code&gt;Array#select&lt;/code&gt;.
 *
 *     a = %w{ a b c d e f }
 *     a.values_at(1, 3, 5)
 *     a.values_at(1, 3, 5, 7)
 *     a.values_at(-1, -3, -5, -7)
 *     a.values_at(1..3, 2...5)
 */

static VALUE
rb_ary_values_at(int argc, VALUE *argv, VALUE ary)
{
    return rb_get_values_at(ary, RARRAY_LEN(ary), argc, argv, rb_ary_entry);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="zip-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>zip</strong>(arg, ...) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>zip</strong>(arg, ...) {|arr| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Converts any arguments to arrays, then merges elements of <tt>self</tt>
with corresponding elements from each argument. This generates a sequence
of <tt>self.size</tt> <em>n</em>-element arrays, where <em>n</em> is one
more that the count of arguments. If the size of any argument is less than
<tt>enumObj.size</tt>, <tt>nil</tt> values are supplied. If a block is
given, it is invoked for each output array, otherwise an array of arrays is
returned.
</p>
<pre class="code">
   a = [ 4, 5, 6 ]
   b = [ 7, 8, 9 ]
   [1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
   [1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
   a.zip([1,2],[8])       #=&gt; [[4,1,8], [5,2,nil], [6,nil,nil]]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>zip</strong>(arg, ...) {|arr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>arr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary.zip(arg, ...)                   -&gt; new_ary
 *     ary.zip(arg, ...) {| arr | block }  -&gt; nil
 *
 *  Converts any arguments to arrays, then merges elements of
 *  +self+ with corresponding elements from each argument. This
 *  generates a sequence of &lt;code&gt;self.size&lt;/code&gt; &lt;em&gt;n&lt;/em&gt;-element
 *  arrays, where &lt;em&gt;n&lt;/em&gt; is one more that the count of arguments. If
 *  the size of any argument is less than &lt;code&gt;enumObj.size&lt;/code&gt;,
 *  &lt;code&gt;nil&lt;/code&gt; values are supplied. If a block is given, it is
 *  invoked for each output array, otherwise an array of arrays is
 *  returned.
 *
 *     a = [ 4, 5, 6 ]
 *     b = [ 7, 8, 9 ]
 *     [1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
 *     [1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
 *     a.zip([1,2],[8])       #=&gt; [[4,1,8], [5,2,nil], [6,nil,nil]]
 */

static VALUE
rb_ary_zip(int argc, VALUE *argv, VALUE ary)
{
    int i, j;
    long len;
    VALUE result = Qnil;

    len = RARRAY_LEN(ary);
    for (i=0; i&lt;argc; i++) {
    argv[i] = take_items(argv[i], len);
    }
    if (!rb_block_given_p()) {
    result = rb_ary_new2(len);
    }

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    VALUE tmp = rb_ary_new2(argc+1);

    rb_ary_push(tmp, rb_ary_elt(ary, i));
    for (j=0; j&lt;argc; j++) {
        rb_ary_push(tmp, rb_ary_elt(argv[j], i));
    }
    if (NIL_P(result)) {
        rb_yield(tmp);
    }
    else {
        rb_ary_push(result, tmp);
    }
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="|-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>|</strong>(other_ary) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Set Union--Returns a new array by joining this array with
<em>other_ary</em>, removing duplicates.
</p>
<pre class="code">
   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] | [ &quot;c&quot;, &quot;d&quot;, &quot;a&quot; ]
          #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'array.c'</span>

/*
 *  call-seq:
 *     ary | other_ary     -&gt; new_ary
 *
 *  Set Union---Returns a new array by joining this array with
 *  &lt;i&gt;other_ary&lt;/i&gt;, removing duplicates.
 *
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] | [ &quot;c&quot;, &quot;d&quot;, &quot;a&quot; ]
 *            #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 */

static VALUE
rb_ary_or(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3;
    VALUE v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY_LEN(ary1)+RARRAY_LEN(ary2));
    hash = ary_add_hash(ary_make_hash(ary1), ary2);

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
    v = vv = rb_ary_elt(ary1, i);
    if (st_delete(RHASH_TBL(hash), (st_data_t*)&amp;vv, 0)) {
        rb_ary_push(ary3, v);
    }
    }
    for (i=0; i&lt;RARRAY_LEN(ary2); i++) {
    v = vv = rb_ary_elt(ary2, i);
    if (st_delete(RHASH_TBL(hash), (st_data_t*)&amp;vv, 0)) {
        rb_ary_push(ary3, v);
    }
    }
    ary_recycle_hash(hash);
    return ary3;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:06:02 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>