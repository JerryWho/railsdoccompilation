<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: MatchData</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (M)</a> &raquo; 
    
    
    <span class="title">MatchData</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: MatchData
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">MatchData</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">re.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
<tt>MatchData</tt> is the type of the special variable <tt>$~</tt>, and is
the type of the object returned by <tt>Regexp#match</tt> and
<tt>Regexp.last_match</tt>. It encapsulates all the results of a pattern
match, results normally accessed through the special variables
<tt>$&amp;</tt>, <tt>$'</tt>, <tt>$`</tt>, <tt>$1</tt>, <tt>$2</tt>, and so
on.
</p>


  </div>
</div>
<div class="tags">
  
</div>


  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Boolean) <strong>==</strong>(mtch2) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equality--Two matchdata are equal if their target strings,.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D-instance_method" title="#[] (instance method)">- (Object) <strong>[]</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Match Reference--<tt>MatchData</tt> acts as an array, and may be
accessed using the normal array indexing techniques.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#begin-instance_method" title="#begin (instance method)">- (Integer) <strong>begin</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the offset of the start of the <em>n</em>th element of the match
array in the string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#captures-instance_method" title="#captures (instance method)">- (Array) <strong>captures</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the array of captures; equivalent to <tt><a
href="http://1..-1">mtch.to_a</a></tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#end-instance_method" title="#end (instance method)">- (Integer) <strong>end</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the offset of the character immediately following the end of the
<em>n</em>th element of the match array in the string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Boolean) <strong>==</strong>(mtch2) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equality--Two matchdata are equal if their target strings,.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hash-instance_method" title="#hash (instance method)">- (Integer) <strong>hash</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Produce a hash based on the target string, regexp and matched positions of
this matchdata.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize_copy-instance_method" title="#initialize_copy (instance method)">- (Object) <strong>initialize_copy</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a printable version of <em>mtch</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#length-instance_method" title="#length (instance method)">- (Object) <strong>length</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the number of elements in the match array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#names-instance_method" title="#names (instance method)">- (Array) <strong>names</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a list of names of captures as an array of strings.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#offset-instance_method" title="#offset (instance method)">- (Array) <strong>offset</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a two-element array containing the beginning and ending offsets of
the <em>n</em>th match.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#post_match-instance_method" title="#post_match (instance method)">- (String) <strong>post_match</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the portion of the original string after the current match.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pre_match-instance_method" title="#pre_match (instance method)">- (String) <strong>pre_match</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the portion of the original string before the current match.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#regexp-instance_method" title="#regexp (instance method)">- (Regexp) <strong>regexp</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the regexp.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#size-instance_method" title="#size (instance method)">- (Object) <strong>size</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the number of elements in the match array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#string-instance_method" title="#string (instance method)">- (String) <strong>string</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a frozen copy of the string passed in to <tt>match</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_a-instance_method" title="#to_a (instance method)">- (Array) <strong>to_a</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the array of matches.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">- (String) <strong>to_s</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the entire matched string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#values_at-instance_method" title="#values_at (instance method)">- (Array) <strong>values_at</strong>([index]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Uses each <em>index</em> to access the matching values, returning an array
of the corresponding matches.
</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="==-instance_method">
  
    - (<tt>Boolean</tt>) <strong>==</strong>(mtch2) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equality--Two matchdata are equal if their target strings,
</p>
<pre class="code">
 patterns, and matched positions are identical.</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    mtch == mtch2   -&gt; true or false
 *
 *  Equality---Two matchdata are equal if their target strings,
 *  patterns, and matched positions are identical.
 */

static VALUE
match_equal(VALUE match1, VALUE match2)
{
    const struct re_registers *regs1, *regs2;
    if (match1 == match2) return Qtrue;
    if (TYPE(match2) != T_MATCH) return Qfalse;
    if (!rb_str_equal(RMATCH(match1)-&gt;str, RMATCH(match2)-&gt;str)) return Qfalse;
    if (!rb_reg_equal(RMATCH(match1)-&gt;regexp, RMATCH(match2)-&gt;regexp)) return Qfalse;
    regs1 = RMATCH_REGS(match1);
    regs2 = RMATCH_REGS(match2);
    if (regs1-&gt;num_regs != regs2-&gt;num_regs) return Qfalse;
    if (memcmp(regs1-&gt;beg, regs2-&gt;beg, regs1-&gt;num_regs * sizeof(*regs1-&gt;beg))) return Qfalse;
    if (memcmp(regs1-&gt;end, regs2-&gt;end, regs1-&gt;num_regs * sizeof(*regs1-&gt;end))) return Qfalse;
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(i) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>[]</strong>(start, length) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>[]</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(name) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Match Reference--<tt>MatchData</tt> acts as an array, and may be
accessed using the normal array indexing techniques.  <em>mtch</em>[0] is
equivalent to the special variable <tt>$&amp;</tt>, and returns the entire
matched string.  <em>mtch</em>[1], <em>mtch</em>[2], and so on return the
values of the matched backreferences (portions of the pattern between
parentheses).
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m          #=&gt; #&lt;MatchData &quot;HX1138&quot; 1:&quot;H&quot; 2:&quot;X&quot; 3:&quot;113&quot; 4:&quot;8&quot;&gt;
   m[0]       #=&gt; &quot;HX1138&quot;
   m[1, 2]    #=&gt; [&quot;H&quot;, &quot;X&quot;]
   m[1..3]    #=&gt; [&quot;H&quot;, &quot;X&quot;, &quot;113&quot;]
   m[-3, 2]   #=&gt; [&quot;X&quot;, &quot;113&quot;]

   m = /(?&lt;foo&gt;a+)b/.match(&quot;ccaaab&quot;)
   m          #=&gt; #&lt;MatchData &quot;aaab&quot; foo:&quot;aaa&quot;&gt;
   m[&quot;foo&quot;]   #=&gt; &quot;aaa&quot;
   m[:foo]    #=&gt; &quot;aaa&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(i) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>[]</strong>(start, length) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>[]</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(name) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch[i]               -&gt; str or nil
 *     mtch[start, length]   -&gt; array
 *     mtch[range]           -&gt; array
 *     mtch[name]            -&gt; str or nil
 *
 *  Match Reference---&lt;code&gt;MatchData&lt;/code&gt; acts as an array, and may be
 *  accessed using the normal array indexing techniques.  &lt;i&gt;mtch&lt;/i&gt;[0] is
 *  equivalent to the special variable &lt;code&gt;$&amp;&lt;/code&gt;, and returns the entire
 *  matched string.  &lt;i&gt;mtch&lt;/i&gt;[1], &lt;i&gt;mtch&lt;/i&gt;[2], and so on return the values
 *  of the matched backreferences (portions of the pattern between parentheses).
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m          #=&gt; #&lt;MatchData &quot;HX1138&quot; 1:&quot;H&quot; 2:&quot;X&quot; 3:&quot;113&quot; 4:&quot;8&quot;&gt;
 *     m[0]       #=&gt; &quot;HX1138&quot;
 *     m[1, 2]    #=&gt; [&quot;H&quot;, &quot;X&quot;]
 *     m[1..3]    #=&gt; [&quot;H&quot;, &quot;X&quot;, &quot;113&quot;]
 *     m[-3, 2]   #=&gt; [&quot;X&quot;, &quot;113&quot;]
 *
 *     m = /(?&lt;foo&gt;a+)b/.match(&quot;ccaaab&quot;)
 *     m          #=&gt; #&lt;MatchData &quot;aaab&quot; foo:&quot;aaa&quot;&gt;
 *     m[&quot;foo&quot;]   #=&gt; &quot;aaa&quot;
 *     m[:foo]    #=&gt; &quot;aaa&quot;
 */

static VALUE
match_aref(int argc, VALUE *argv, VALUE match)
{
    VALUE idx, rest;

    match_check(match);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;idx, &amp;rest);

    if (NIL_P(rest)) {
    if (FIXNUM_P(idx)) {
        if (FIX2INT(idx) &gt;= 0) {
        return rb_reg_nth_match(FIX2INT(idx), match);
        }
    }
    else {
        const char *p;
        int num;

        switch (TYPE(idx)) {
          case T_SYMBOL:
        p = rb_id2name(SYM2ID(idx));
        goto name_to_backref;
        break;
          case T_STRING:
        p = StringValuePtr(idx);

          name_to_backref:
        num = name_to_backref_number(RMATCH_REGS(match),
                         RMATCH(match)-&gt;regexp, p, p + strlen(p));
        return rb_reg_nth_match(num, match);
        break;

          default:
        break;
        }
    }
    }

    return rb_ary_aref(argc, argv, match_to_a(match));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="begin-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>begin</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the offset of the start of the <em>n</em>th element of the match
array in the string. <em>n</em> can be a string or symbol to reference a
named capture.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.begin(0)       #=&gt; 1
   m.begin(2)       #=&gt; 2

   m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)
   p m.begin(:foo)  #=&gt; 0
   p m.begin(:bar)  #=&gt; 2</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.begin(n)   -&gt; integer
 *
 *  Returns the offset of the start of the &lt;em&gt;n&lt;/em&gt;th element of the match
 *  array in the string.
 *  &lt;em&gt;n&lt;/em&gt; can be a string or symbol to reference a named capture.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.begin(0)       #=&gt; 1
 *     m.begin(2)       #=&gt; 2
 *
 *     m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)
 *     p m.begin(:foo)  #=&gt; 0
 *     p m.begin(:bar)  #=&gt; 2
 */

static VALUE
match_begin(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    match_check(match);
    if (i &lt; 0 || regs-&gt;num_regs &lt;= i)
    rb_raise(rb_eIndexError, &quot;index %d out of matches&quot;, i);

    if (BEG(i) &lt; 0)
    return Qnil;

    update_char_offset(match);
    return INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].beg);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="captures-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>captures</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the array of captures; equivalent to <tt><a
href="http://1..-1">mtch.to_a</a></tt>.
</p>
<pre class="code">
   f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;).captures
   f1    #=&gt; &quot;H&quot;
   f2    #=&gt; &quot;X&quot;
   f3    #=&gt; &quot;113&quot;
   f4    #=&gt; &quot;8&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.captures   -&gt; array
 *
 *  Returns the array of captures; equivalent to &lt;code&gt;mtch.to_a[1..-1]&lt;/code&gt;.
 *
 *     f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;).captures
 *     f1    #=&gt; &quot;H&quot;
 *     f2    #=&gt; &quot;X&quot;
 *     f3    #=&gt; &quot;113&quot;
 *     f4    #=&gt; &quot;8&quot;
 */
static VALUE
match_captures(VALUE match)
{
    return match_array(match, 1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="end-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>end</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the offset of the character immediately following the end of the
<em>n</em>th element of the match array in the string. <em>n</em> can be a
string or symbol to reference a named capture.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.end(0)         #=&gt; 7
   m.end(2)         #=&gt; 3

   m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)
   p m.end(:foo)    #=&gt; 1
   p m.end(:bar)    #=&gt; 3</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.end(n)   -&gt; integer
 *
 *  Returns the offset of the character immediately following the end of the
 *  &lt;em&gt;n&lt;/em&gt;th element of the match array in the string.
 *  &lt;em&gt;n&lt;/em&gt; can be a string or symbol to reference a named capture.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.end(0)         #=&gt; 7
 *     m.end(2)         #=&gt; 3
 *
 *     m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)
 *     p m.end(:foo)    #=&gt; 1
 *     p m.end(:bar)    #=&gt; 3
 */

static VALUE
match_end(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    match_check(match);
    if (i &lt; 0 || regs-&gt;num_regs &lt;= i)
    rb_raise(rb_eIndexError, &quot;index %d out of matches&quot;, i);

    if (BEG(i) &lt; 0)
    return Qnil;

    update_char_offset(match);
    return INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].end);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eql?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>==</strong>(mtch2) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equality--Two matchdata are equal if their target strings,
</p>
<pre class="code">
 patterns, and matched positions are identical.</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    mtch == mtch2   -&gt; true or false
 *
 *  Equality---Two matchdata are equal if their target strings,
 *  patterns, and matched positions are identical.
 */

static VALUE
match_equal(VALUE match1, VALUE match2)
{
    const struct re_registers *regs1, *regs2;
    if (match1 == match2) return Qtrue;
    if (TYPE(match2) != T_MATCH) return Qfalse;
    if (!rb_str_equal(RMATCH(match1)-&gt;str, RMATCH(match2)-&gt;str)) return Qfalse;
    if (!rb_reg_equal(RMATCH(match1)-&gt;regexp, RMATCH(match2)-&gt;regexp)) return Qfalse;
    regs1 = RMATCH_REGS(match1);
    regs2 = RMATCH_REGS(match2);
    if (regs1-&gt;num_regs != regs2-&gt;num_regs) return Qfalse;
    if (memcmp(regs1-&gt;beg, regs2-&gt;beg, regs1-&gt;num_regs * sizeof(*regs1-&gt;beg))) return Qfalse;
    if (memcmp(regs1-&gt;end, regs2-&gt;end, regs1-&gt;num_regs * sizeof(*regs1-&gt;end))) return Qfalse;
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="hash-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>hash</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Produce a hash based on the target string, regexp and matched positions of
this matchdata.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    mtch.hash   -&gt; integer
 *
 * Produce a hash based on the target string, regexp and matched
 * positions of this matchdata.
 */

static VALUE
match_hash(VALUE match)
{
    const struct re_registers *regs;
    st_index_t hashval = rb_hash_start(rb_str_hash(RMATCH(match)-&gt;str));

    rb_hash_uint(hashval, reg_hash(RMATCH(match)-&gt;regexp));
    regs = RMATCH_REGS(match);
    hashval = rb_hash_uint(hashval, regs-&gt;num_regs);
    hashval = rb_hash_uint(hashval, rb_memhash(regs-&gt;beg, regs-&gt;num_regs * sizeof(*regs-&gt;beg)));
    hashval = rb_hash_uint(hashval, rb_memhash(regs-&gt;end, regs-&gt;num_regs * sizeof(*regs-&gt;end)));
    hashval = rb_hash_end(hashval);
    return LONG2FIX(hashval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="initialize_copy-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>initialize_copy</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/* :nodoc: */
static VALUE
match_init_copy(VALUE obj, VALUE orig)
{
    struct rmatch *rm;

    if (obj == orig) return obj;

    if (!rb_obj_is_instance_of(orig, rb_obj_class(obj))) {
    rb_raise(rb_eTypeError, &quot;wrong argument class&quot;);
    }
    RMATCH(obj)-&gt;str = RMATCH(orig)-&gt;str;
    RMATCH(obj)-&gt;regexp = RMATCH(orig)-&gt;regexp;

    rm = RMATCH(obj)-&gt;rmatch;
    onig_region_copy(&amp;rm-&gt;regs, RMATCH_REGS(orig));

    if (!RMATCH(orig)-&gt;rmatch-&gt;char_offset_updated) {
        rm-&gt;char_offset_updated = 0;
    }
    else {
        if (rm-&gt;char_offset_num_allocated &lt; rm-&gt;regs.num_regs) {
            REALLOC_N(rm-&gt;char_offset, struct rmatch_offset, rm-&gt;regs.num_regs);
            rm-&gt;char_offset_num_allocated = rm-&gt;regs.num_regs;
        }
        MEMCPY(rm-&gt;char_offset, RMATCH(orig)-&gt;rmatch-&gt;char_offset,
               struct rmatch_offset, rm-&gt;regs.num_regs);
        rm-&gt;char_offset_updated = 1;
    }

    return obj;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a printable version of <em>mtch</em>.
</p>
<pre class="code">
    puts /.$/.match(&quot;foo&quot;).inspect
    #=&gt; #&lt;MatchData &quot;o&quot;&gt;

    puts /(.)(.)(.)/.match(&quot;foo&quot;).inspect
    #=&gt; #&lt;MatchData &quot;foo&quot; 1:&quot;f&quot; 2:&quot;o&quot; 3:&quot;o&quot;&gt;

    puts /(.)(.)?(.)/.match(&quot;fo&quot;).inspect
    #=&gt; #&lt;MatchData &quot;fo&quot; 1:&quot;f&quot; 2:nil 3:&quot;o&quot;&gt;

    puts /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match(&quot;hoge&quot;).inspect
    #=&gt; #&lt;MatchData &quot;hog&quot; foo:&quot;h&quot; bar:&quot;o&quot; baz:&quot;g&quot;&gt;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    mtch.inspect   -&gt; str
 *
 * Returns a printable version of &lt;i&gt;mtch&lt;/i&gt;.
 *
 *     puts /.$/.match(&quot;foo&quot;).inspect
 *     #=&gt; #&lt;MatchData &quot;o&quot;&gt;
 *
 *     puts /(.)(.)(.)/.match(&quot;foo&quot;).inspect
 *     #=&gt; #&lt;MatchData &quot;foo&quot; 1:&quot;f&quot; 2:&quot;o&quot; 3:&quot;o&quot;&gt;
 *
 *     puts /(.)(.)?(.)/.match(&quot;fo&quot;).inspect
 *     #=&gt; #&lt;MatchData &quot;fo&quot; 1:&quot;f&quot; 2:nil 3:&quot;o&quot;&gt;
 *
 *     puts /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match(&quot;hoge&quot;).inspect
 *     #=&gt; #&lt;MatchData &quot;hog&quot; foo:&quot;h&quot; bar:&quot;o&quot; baz:&quot;g&quot;&gt;
 *
 */

static VALUE
match_inspect(VALUE match)
{
    const char *cname = rb_obj_classname(match);
    VALUE str;
    int i;
    struct re_registers *regs = RMATCH_REGS(match);
    int num_regs = regs-&gt;num_regs;
    struct backref_name_tag *names;
    VALUE regexp = RMATCH(match)-&gt;regexp;

    if (regexp == 0) {
        return rb_sprintf(&quot;#&lt;%s:%p&gt;&quot;, cname, (void*)match);
    }

    names = ALLOCA_N(struct backref_name_tag, num_regs);
    MEMZERO(names, struct backref_name_tag, num_regs);

    onig_foreach_name(RREGEXP(regexp)-&gt;ptr,
            match_inspect_name_iter, names);

    str = rb_str_buf_new2(&quot;#&lt;&quot;);
    rb_str_buf_cat2(str, cname);

    for (i = 0; i &lt; num_regs; i++) {
        VALUE v;
        rb_str_buf_cat2(str, &quot; &quot;);
        if (0 &lt; i) {
            if (names[i].name)
                rb_str_buf_cat(str, (const char *)names[i].name, names[i].len);
            else {
                rb_str_catf(str, &quot;%d&quot;, i);
            }
            rb_str_buf_cat2(str, &quot;:&quot;);
        }
        v = rb_reg_nth_match(i, match);
        if (v == Qnil)
            rb_str_buf_cat2(str, &quot;nil&quot;);
        else
            rb_str_buf_append(str, rb_str_inspect(v));
    }
    rb_str_buf_cat2(str, &quot;&gt;&quot;);

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="length-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the number of elements in the match array.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.length   #=&gt; 5
   m.size     #=&gt; 5</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.length   -&gt; integer
 *     mtch.size     -&gt; integer
 *
 *  Returns the number of elements in the match array.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.length   #=&gt; 5
 *     m.size     #=&gt; 5
 */

static VALUE
match_size(VALUE match)
{
    match_check(match);
    return INT2FIX(RMATCH_REGS(match)-&gt;num_regs);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="names-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>names</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a list of names of captures as an array of strings. It is same as
mtch.regexp.names.
</p>
<pre class="code">
    /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match(&quot;hoge&quot;).names
    #=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]

    m = /(?&lt;x&gt;.)(?&lt;y&gt;.)?/.match(&quot;a&quot;) #=&gt; #&lt;MatchData &quot;a&quot; x:&quot;a&quot; y:nil&gt;
    m.names                          #=&gt; [&quot;x&quot;, &quot;y&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    mtch.names   -&gt; [name1, name2, ...]
 *
 * Returns a list of names of captures as an array of strings.
 * It is same as mtch.regexp.names.
 *
 *     /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match(&quot;hoge&quot;).names
 *     #=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
 *
 *     m = /(?&lt;x&gt;.)(?&lt;y&gt;.)?/.match(&quot;a&quot;) #=&gt; #&lt;MatchData &quot;a&quot; x:&quot;a&quot; y:nil&gt;
 *     m.names                          #=&gt; [&quot;x&quot;, &quot;y&quot;]
 */

static VALUE
match_names(VALUE match)
{
    match_check(match);
    return rb_reg_names(RMATCH(match)-&gt;regexp);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="offset-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>offset</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a two-element array containing the beginning and ending offsets of
the <em>n</em>th match. <em>n</em> can be a string or symbol to reference a
named capture.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.offset(0)      #=&gt; [1, 7]
   m.offset(4)      #=&gt; [6, 7]

   m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)
   p m.offset(:foo) #=&gt; [0, 1]
   p m.offset(:bar) #=&gt; [2, 3]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.offset(n)   -&gt; array
 *
 *  Returns a two-element array containing the beginning and ending offsets of
 *  the &lt;em&gt;n&lt;/em&gt;th match.
 *  &lt;em&gt;n&lt;/em&gt; can be a string or symbol to reference a named capture.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.offset(0)      #=&gt; [1, 7]
 *     m.offset(4)      #=&gt; [6, 7]
 *
 *     m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)
 *     p m.offset(:foo) #=&gt; [0, 1]
 *     p m.offset(:bar) #=&gt; [2, 3]
 *
 */

static VALUE
match_offset(VALUE match, VALUE n)
{
    int i = match_backref_number(match, n);
    struct re_registers *regs = RMATCH_REGS(match);

    match_check(match);
    if (i &lt; 0 || regs-&gt;num_regs &lt;= i)
    rb_raise(rb_eIndexError, &quot;index %d out of matches&quot;, i);

    if (BEG(i) &lt; 0)
    return rb_assoc_new(Qnil, Qnil);

    update_char_offset(match);
    return rb_assoc_new(INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].beg),
            INT2FIX(RMATCH(match)-&gt;rmatch-&gt;char_offset[i].end));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="post_match-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>post_match</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the portion of the original string after the current match.
Equivalent to the special variable <tt>$'</tt>.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)
   m.post_match   #=&gt; &quot;: The Movie&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.post_match   -&gt; str
 *
 *  Returns the portion of the original string after the current match.
 *  Equivalent to the special variable &lt;code&gt;$'&lt;/code&gt;.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)
 *     m.post_match   #=&gt; &quot;: The Movie&quot;
 */

VALUE
rb_reg_match_post(VALUE match)
{
    VALUE str;
    long pos;
    struct re_registers *regs;

    if (NIL_P(match)) return Qnil;
    match_check(match);
    regs = RMATCH_REGS(match);
    if (BEG(0) == -1) return Qnil;
    str = RMATCH(match)-&gt;str;
    pos = END(0);
    str = rb_str_subseq(str, pos, RSTRING_LEN(str) - pos);
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pre_match-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>pre_match</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the portion of the original string before the current match.
Equivalent to the special variable <tt>$`</tt>.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.pre_match   #=&gt; &quot;T&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.pre_match   -&gt; str
 *
 *  Returns the portion of the original string before the current match.
 *  Equivalent to the special variable &lt;code&gt;$`&lt;/code&gt;.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.pre_match   #=&gt; &quot;T&quot;
 */

VALUE
rb_reg_match_pre(VALUE match)
{
    VALUE str;
    struct re_registers *regs;

    if (NIL_P(match)) return Qnil;
    match_check(match);
    regs = RMATCH_REGS(match);
    if (BEG(0) == -1) return Qnil;
    str = rb_str_subseq(RMATCH(match)-&gt;str, 0, BEG(0));
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="regexp-instance_method">
  
    - (<tt><span class='object_link'><a href="Regexp.html" title="Regexp (class)">Regexp</a></span></tt>) <strong>regexp</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the regexp.
</p>
<pre class="code">
    m = /a.*b/.match(&quot;abc&quot;)
    m.regexp #=&gt; /a.*b/</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Regexp.html" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    mtch.regexp   -&gt; regexp
 *
 * Returns the regexp.
 *
 *     m = /a.*b/.match(&quot;abc&quot;)
 *     m.regexp #=&gt; /a.*b/
 */

static VALUE
match_regexp(VALUE match)
{
    match_check(match);
    return RMATCH(match)-&gt;regexp;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="size-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the number of elements in the match array.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.length   #=&gt; 5
   m.size     #=&gt; 5</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.length   -&gt; integer
 *     mtch.size     -&gt; integer
 *
 *  Returns the number of elements in the match array.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.length   #=&gt; 5
 *     m.size     #=&gt; 5
 */

static VALUE
match_size(VALUE match)
{
    match_check(match);
    return INT2FIX(RMATCH_REGS(match)-&gt;num_regs);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="string-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>string</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a frozen copy of the string passed in to <tt>match</tt>.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.string   #=&gt; &quot;THX1138.&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.string   -&gt; str
 *
 *  Returns a frozen copy of the string passed in to &lt;code&gt;match&lt;/code&gt;.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.string   #=&gt; &quot;THX1138.&quot;
 */

static VALUE
match_string(VALUE match)
{
    match_check(match);
    return RMATCH(match)-&gt;str;  /* str is frozen */
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_a-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>to_a</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the array of matches.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.to_a   #=&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]
</pre>
<p>
Because <tt>to_a</tt> is called when expanding <tt>*</tt><em>variable</em>,
there&#8217;s a useful assignment shortcut for extracting matched fields.
This is slightly slower than accessing the fields directly (as an
intermediate array is generated).
</p>
<pre class="code">
   all,f1,f2,f3 = *(/(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;))
   all   #=&gt; &quot;HX1138&quot;
   f1    #=&gt; &quot;H&quot;
   f2    #=&gt; &quot;X&quot;
   f3    #=&gt; &quot;113&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.to_a   -&gt; anArray
 *
 *  Returns the array of matches.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.to_a   #=&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]
 *
 *  Because &lt;code&gt;to_a&lt;/code&gt; is called when expanding
 *  &lt;code&gt;*&lt;/code&gt;&lt;em&gt;variable&lt;/em&gt;, there's a useful assignment
 *  shortcut for extracting matched fields. This is slightly slower than
 *  accessing the fields directly (as an intermediate array is
 *  generated).
 *
 *     all,f1,f2,f3 = *(/(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;))
 *     all   #=&gt; &quot;HX1138&quot;
 *     f1    #=&gt; &quot;H&quot;
 *     f2    #=&gt; &quot;X&quot;
 *     f3    #=&gt; &quot;113&quot;
 */

static VALUE
match_to_a(VALUE match)
{
    return match_array(match, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_s-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the entire matched string.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
   m.to_s   #=&gt; &quot;HX1138&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     mtch.to_s   -&gt; str
 *
 *  Returns the entire matched string.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)
 *     m.to_s   #=&gt; &quot;HX1138&quot;
 */

static VALUE
match_to_s(VALUE match)
{
    VALUE str = rb_reg_last_match(match);

    match_check(match);
    if (NIL_P(str)) str = rb_str_new(0,0);
    if (OBJ_TAINTED(match)) OBJ_TAINT(str);
    if (OBJ_TAINTED(RMATCH(match)-&gt;str)) OBJ_TAINT(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="values_at-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>values_at</strong>([index]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Uses each <em>index</em> to access the matching values, returning an array
of the corresponding matches.
</p>
<pre class="code">
   m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)
   m.to_a               #=&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]
   m.values_at(0, 2, -2)   #=&gt; [&quot;HX1138&quot;, &quot;X&quot;, &quot;113&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *
 *     mtch.values_at([index]*)   -&gt; array
 *
 *  Uses each &lt;i&gt;index&lt;/i&gt; to access the matching values, returning an array of
 *  the corresponding matches.
 *
 *     m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)
 *     m.to_a               #=&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]
 *     m.values_at(0, 2, -2)   #=&gt; [&quot;HX1138&quot;, &quot;X&quot;, &quot;113&quot;]
 */

static VALUE
match_values_at(int argc, VALUE *argv, VALUE match)
{
    struct re_registers *regs;

    match_check(match);
    regs = RMATCH_REGS(match);
    return rb_get_values_at(match, regs-&gt;num_regs, argc, argv, match_entry);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:05:57 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>