<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Encoding::Converter</title>
<link rel="stylesheet" href="../css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '..';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (C)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></span>
     &raquo; 
    <span class="title">Converter</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Encoding::Converter
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="../Data.html" title="Data (class)">Data</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next"><span class='object_link'><a href="../Data.html" title="Data (class)">Data</a></span></li>
          
            <li class="next">Encoding::Converter</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">transcode.c</dd>
  
</dl>
<div class="clear"></div>



  
  
  
  

  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#asciicompat_encoding-class_method" title="asciicompat_encoding (class method)">+ (Object) <strong>asciicompat_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the corresponding ASCII compatible encoding.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#search_convpath-class_method" title="search_convpath (class method)">+ (Object) <strong>search_convpath</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a conversion path.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#convert-instance_method" title="#convert (instance method)">- (Object) <strong>convert</strong>(source_string) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Convert source_string and return destination_string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#convpath-instance_method" title="#convpath (instance method)">- (Object) <strong>convpath</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the conversion path of ec.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#destination_encoding-instance_method" title="#destination_encoding (instance method)">- (Encoding) <strong>destination_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the destination encoding as an Encoding object.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#finish-instance_method" title="#finish (instance method)">- (String) <strong>finish</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Finishes the converter.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
possible options elements:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#insert_output-instance_method" title="#insert_output (instance method)">- (nil) <strong>insert_output</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Inserts string into the encoding converter.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a printable version of <em>ec</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#last_error-instance_method" title="#last_error (instance method)">- (Exception<sup>?</sup>) <strong>last_error</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an exception object for the last conversion.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#primitive_convert-instance_method" title="#primitive_convert (instance method)">- (Object) <strong>primitive_convert</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
possible opt elements:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#primitive_errinfo-instance_method" title="#primitive_errinfo (instance method)">- (Array) <strong>primitive_errinfo</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
primitive_errinfo returns important information regarding the last error as
a 5-element array:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#putback-instance_method" title="#putback (instance method)">- (Object) <strong>putback</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
call-seq.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replacement-instance_method" title="#replacement (instance method)">- (String) <strong>replacement</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the replacement string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replacement%3D-instance_method" title="#replacement= (instance method)">- (Object) <strong>replacement=</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets the replacement string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#source_encoding-instance_method" title="#source_encoding (instance method)">- (Encoding) <strong>source_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the source encoding as an Encoding object.
</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.new</strong>(source_encoding, destination_encoding) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.new</strong>(source_encoding, destination_encoding, opt) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.new</strong>(convpath) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
possible options elements:
</p>
<pre class="code">
  hash form:
    :invalid =&gt; nil            # raise error on invalid byte sequence (default)
    :invalid =&gt; :replace       # replace invalid byte sequence
    :undef =&gt; nil              # raise error on undefined conversion (default)
    :undef =&gt; :replace         # replace undefined conversion
    :replace =&gt; string         # replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)
    :universal_newline =&gt; true # decorator for converting CRLF and CR to LF
    :crlf_newline =&gt; true      # decorator for converting LF to CRLF
    :cr_newline =&gt; true        # decorator for converting LF to CR
    :xml =&gt; :text              # escape as XML CharData.
    :xml =&gt; :attr              # escape as XML AttValue
  integer form:
    Encoding::Converter::INVALID_REPLACE
    Encoding::Converter::UNDEF_REPLACE
    Encoding::Converter::UNDEF_HEX_CHARREF
    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
    Encoding::Converter::CRLF_NEWLINE_DECORATOR
    Encoding::Converter::CR_NEWLINE_DECORATOR
    Encoding::Converter::XML_TEXT_DECORATOR
    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR
</pre>
<p>
Encoding::Converter.new creates an instance of Encoding::Converter.
</p>
<p>
Source_encoding and destination_encoding should be a string or Encoding
object.
</p>
<p>
opt should be nil, a hash or an integer.
</p>
<p>
convpath should be an array. convpath may contain
</p>
<ul>
<li><p>
two-element arrays which contain encodings or encoding names, or
</p>
</li>
<li><p>
strings representing decorator names.
</p>
</li>
</ul>
<p>
Encoding::Converter.new optionally takes an option. The option should be a
hash or an integer. The option hash can contain :invalid => nil, etc. The
option integer should be logical-or of constants such as
Encoding::Converter::INVALID_REPLACE, etc.
</p>
<dl>
<dt>:invalid => nil</dt><dd><p>
Raise error on invalid byte sequence.  This is a default behavior.
</p>
</dd>
<dt>:invalid => :replace</dt><dd><p>
Replace invalid byte sequence by replacement string.
</p>
</dd>
<dt>:undef => nil</dt><dd><p>
Raise an error if a character in source_encoding is not defined in
destination_encoding. This is a default behavior.
</p>
</dd>
<dt>:undef => :replace</dt><dd><p>
Replace undefined character in destination_encoding with replacement
string.
</p>
</dd>
<dt>:replace => string</dt><dd><p>
Specify the replacement string. If not specified, &#8220;\uFFFD&#8221; is
used for Unicode encodings and &#8220;?&#8221; for others.
</p>
</dd>
<dt>:universal_newline => true</dt><dd><p>
Convert CRLF and CR to LF.
</p>
</dd>
<dt>:crlf_newline => true</dt><dd><p>
Convert LF to CRLF.
</p>
</dd>
<dt>:cr_newline => true</dt><dd><p>
Convert LF to CR.
</p>
</dd>
<dt>:xml => :text</dt><dd><p>
Escape as XML CharData. This form can be used as a HTML 4.0 #PCDATA.
</p>
<ul>
<li><p>
&#8217;&amp;&#8217; -> &#8217;&amp;amp;&#8217;
</p>
</li>
</ul>
<ul>
<li><p>
&#8217;<&#8217; -> &#8217;&amp;lt;&#8217;
</p>
</li>
</ul>
<ul>
<li><p>
&#8217;>&#8217; -> &#8217;&amp;gt;&#8217;
</p>
</li>
</ul>
<ul>
<li><p>
undefined characters in destination_encoding -> hexadecimal CharRef such as
&amp;#xHH;
</p>
</li>
</ul>
</dd>
<dt>:xml => :attr</dt><dd><p>
Escape as XML AttValue. The converted result is quoted as
&#8220;&#8230;&#8221;. This form can be used as a HTML 4.0 attribute value.
</p>
<ul>
<li><p>
&#8217;&amp;&#8217; -> &#8217;&amp;amp;&#8217;
</p>
</li>
</ul>
<ul>
<li><p>
&#8217;<&#8217; -> &#8217;&amp;lt;&#8217;
</p>
</li>
</ul>
<ul>
<li><p>
&#8217;>&#8217; -> &#8217;&amp;gt;&#8217;
</p>
</li>
</ul>
<ul>
<li><p>
&#8217;&#8221;&#8217; -> &#8217;&amp;quot;&#8217;
</p>
</li>
</ul>
<ul>
<li><p>
undefined characters in destination_encoding -> hexadecimal CharRef such as
&amp;#xHH;
</p>
</li>
</ul>
</dd>
</dl>
<p>
Examples:
</p>
<pre class="code">
  # UTF-16BE to UTF-8
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)

  # Usually, decorators such as newline conversion are inserted last.
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;, :universal_newline =&gt; true)
  p ec.convpath #=&gt; [[#&lt;Encoding:UTF-16BE&gt;, #&lt;Encoding:UTF-8&gt;],
                #    &quot;universal_newline&quot;]

  # But, if the last encoding is ASCII incompatible,
  # decorators are inserted before the last conversion.
  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;, :crlf_newline =&gt; true)
  p ec.convpath #=&gt; [&quot;crlf_newline&quot;,
                #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]

  # Conversion path can be specified directly.
  ec = Encoding::Converter.new([&quot;universal_newline&quot;, [&quot;EUC-JP&quot;, &quot;UTF-8&quot;], [&quot;UTF-8&quot;, &quot;UTF-16BE&quot;]])
  p ec.convpath #=&gt; [&quot;universal_newline&quot;,
                #    [#&lt;Encoding:EUC-JP&gt;, #&lt;Encoding:UTF-8&gt;],
                #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   Encoding::Converter.new(source_encoding, destination_encoding)
 *   Encoding::Converter.new(source_encoding, destination_encoding, opt)
 *   Encoding::Converter.new(convpath)
 *
 * possible options elements:
 *   hash form:
 *     :invalid =&gt; nil            # raise error on invalid byte sequence (default)
 *     :invalid =&gt; :replace       # replace invalid byte sequence
 *     :undef =&gt; nil              # raise error on undefined conversion (default)
 *     :undef =&gt; :replace         # replace undefined conversion
 *     :replace =&gt; string         # replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)
 *     :universal_newline =&gt; true # decorator for converting CRLF and CR to LF
 *     :crlf_newline =&gt; true      # decorator for converting LF to CRLF
 *     :cr_newline =&gt; true        # decorator for converting LF to CR
 *     :xml =&gt; :text              # escape as XML CharData.
 *     :xml =&gt; :attr              # escape as XML AttValue
 *   integer form:
 *     Encoding::Converter::INVALID_REPLACE
 *     Encoding::Converter::UNDEF_REPLACE
 *     Encoding::Converter::UNDEF_HEX_CHARREF
 *     Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
 *     Encoding::Converter::CRLF_NEWLINE_DECORATOR
 *     Encoding::Converter::CR_NEWLINE_DECORATOR
 *     Encoding::Converter::XML_TEXT_DECORATOR
 *     Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
 *     Encoding::Converter::XML_ATTR_QUOTE_DECORATOR
 *
 * Encoding::Converter.new creates an instance of Encoding::Converter.
 *
 * Source_encoding and destination_encoding should be a string or
 * Encoding object.
 *
 * opt should be nil, a hash or an integer.
 *
 * convpath should be an array.
 * convpath may contain
 * - two-element arrays which contain encodings or encoding names, or
 * - strings representing decorator names.
 *
 * Encoding::Converter.new optionally takes an option.
 * The option should be a hash or an integer.
 * The option hash can contain :invalid =&gt; nil, etc.
 * The option integer should be logical-or of constants such as
 * Encoding::Converter::INVALID_REPLACE, etc.
 *
 * [:invalid =&gt; nil]
 *   Raise error on invalid byte sequence.  This is a default behavior.
 * [:invalid =&gt; :replace]
 *   Replace invalid byte sequence by replacement string.
 * [:undef =&gt; nil]
 *   Raise an error if a character in source_encoding is not defined in destination_encoding.
 *   This is a default behavior.
 * [:undef =&gt; :replace]
 *   Replace undefined character in destination_encoding with replacement string.
 * [:replace =&gt; string]
 *   Specify the replacement string.
 *   If not specified, &quot;\uFFFD&quot; is used for Unicode encodings and &quot;?&quot; for others.
 * [:universal_newline =&gt; true]
 *   Convert CRLF and CR to LF.
 * [:crlf_newline =&gt; true]
 *   Convert LF to CRLF.
 * [:cr_newline =&gt; true]
 *   Convert LF to CR.
 * [:xml =&gt; :text]
 *   Escape as XML CharData.
 *   This form can be used as a HTML 4.0 #PCDATA.
 *   - '&amp;' -&gt; '&amp;amp;'
 *   - '&lt;' -&gt; '&amp;lt;'
 *   - '&gt;' -&gt; '&amp;gt;'
 *   - undefined characters in destination_encoding -&gt; hexadecimal CharRef such as &amp;#xHH;
 * [:xml =&gt; :attr]
 *   Escape as XML AttValue.
 *   The converted result is quoted as &quot;...&quot;.
 *   This form can be used as a HTML 4.0 attribute value.
 *   - '&amp;' -&gt; '&amp;amp;'
 *   - '&lt;' -&gt; '&amp;lt;'
 *   - '&gt;' -&gt; '&amp;gt;'
 *   - '&quot;' -&gt; '&amp;quot;'
 *   - undefined characters in destination_encoding -&gt; hexadecimal CharRef such as &amp;#xHH;
 *
 * Examples:
 *   # UTF-16BE to UTF-8
 *   ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)
 *
 *   # Usually, decorators such as newline conversion are inserted last.
 *   ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;, :universal_newline =&gt; true)
 *   p ec.convpath #=&gt; [[#&lt;Encoding:UTF-16BE&gt;, #&lt;Encoding:UTF-8&gt;],
 *                 #    &quot;universal_newline&quot;]
 *
 *   # But, if the last encoding is ASCII incompatible,
 *   # decorators are inserted before the last conversion.
 *   ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;, :crlf_newline =&gt; true)
 *   p ec.convpath #=&gt; [&quot;crlf_newline&quot;,
 *                 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]
 *
 *   # Conversion path can be specified directly.
 *   ec = Encoding::Converter.new([&quot;universal_newline&quot;, [&quot;EUC-JP&quot;, &quot;UTF-8&quot;], [&quot;UTF-8&quot;, &quot;UTF-16BE&quot;]])
 *   p ec.convpath #=&gt; [&quot;universal_newline&quot;,
 *                 #    [#&lt;Encoding:EUC-JP&gt;, #&lt;Encoding:UTF-8&gt;],
 *                 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]
 */
static VALUE
econv_init(int argc, VALUE *argv, VALUE self)
{
    VALUE ecopts;
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    rb_econv_t *ec;
    int ecflags;
    VALUE convpath;

    if (rb_check_typeddata(self, &amp;econv_data_type)) {
        rb_raise(rb_eTypeError, &quot;already initialized&quot;);
    }

    if (argc == 1 &amp;&amp; !NIL_P(convpath = rb_check_array_type(argv[0]))) {
        ec = rb_econv_init_by_convpath(self, convpath, &amp;sname, &amp;dname, &amp;senc, &amp;denc);
        ecflags = 0;
        ecopts = Qnil;
    }
    else {
        econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);
        ec = rb_econv_open_opts(sname, dname, ecflags, ecopts);
    }

    if (!ec) {
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));
    }

    if (!DECORATOR_P(sname, dname)) {
        if (!senc)
            senc = make_dummy_encoding(sname);
        if (!denc)
            denc = make_dummy_encoding(dname);
    }

    ec-&gt;source_encoding = senc;
    ec-&gt;destination_encoding = denc;

    DATA_PTR(self) = ec;

    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="asciicompat_encoding-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(string) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(encoding) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the corresponding ASCII compatible encoding.
</p>
<p>
Returns nil if the argument is an ASCII compatible encoding.
</p>
<p>
&#8220;corresponding ASCII compatible encoding&#8221; is a ASCII compatible
encoding which can represents exactly the same characters as the given
ASCII incompatible encoding. So, no conversion undefined error occurs when
converting between the two encodings.
</p>
<pre class="code">
  Encoding::Converter.asciicompat_encoding(&quot;ISO-2022-JP&quot;) #=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;
  Encoding::Converter.asciicompat_encoding(&quot;UTF-16BE&quot;) #=&gt; #&lt;Encoding:UTF-8&gt;
  Encoding::Converter.asciicompat_encoding(&quot;UTF-8&quot;) #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(string) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt><sup>?</sup>) <strong>Encoding::Converter.asciicompat_encoding</strong>(encoding) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   Encoding::Converter.asciicompat_encoding(string) -&gt; encoding or nil
 *   Encoding::Converter.asciicompat_encoding(encoding) -&gt; encoding or nil
 *
 * Returns the corresponding ASCII compatible encoding.
 *
 * Returns nil if the argument is an ASCII compatible encoding.
 *
 * &quot;corresponding ASCII compatible encoding&quot; is a ASCII compatible encoding which
 * can represents exactly the same characters as the given ASCII incompatible encoding.
 * So, no conversion undefined error occurs when converting between the two encodings.
 *
 *   Encoding::Converter.asciicompat_encoding(&quot;ISO-2022-JP&quot;) #=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;
 *   Encoding::Converter.asciicompat_encoding(&quot;UTF-16BE&quot;) #=&gt; #&lt;Encoding:UTF-8&gt;
 *   Encoding::Converter.asciicompat_encoding(&quot;UTF-8&quot;) #=&gt; nil
 *
 */
static VALUE
econv_s_asciicompat_encoding(VALUE klass, VALUE arg)
{
    const char *arg_name, *result_name;
    rb_encoding *arg_enc, *result_enc;

    enc_arg(&amp;arg, &amp;arg_name, &amp;arg_enc);

    result_name = rb_econv_asciicompat_encoding(arg_name);

    if (result_name == NULL)
        return Qnil;

    result_enc = make_encoding(result_name);

    return rb_enc_from_encoding(result_enc);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="search_convpath-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.search_convpath</strong>(source_encoding, destination_encoding) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>Encoding::Converter.search_convpath</strong>(source_encoding, destination_encoding, opt) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a conversion path.
</p>
<pre class="code">
  p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;)
  #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
  #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;]]

  p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, universal_newline: true)
  #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
  #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
  #    &quot;universal_newline&quot;]

  p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;UTF-32BE&quot;, universal_newline: true)
  #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
  #    &quot;universal_newline&quot;,
  #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-32BE&gt;]]</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   Encoding::Converter.search_convpath(source_encoding, destination_encoding)         -&gt; ary
 *   Encoding::Converter.search_convpath(source_encoding, destination_encoding, opt)    -&gt; ary
 *
 *  Returns a conversion path.
 *
 *   p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;)
 *   #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 *   #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;]]
 *
 *   p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, universal_newline: true)
 *   #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 *   #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
 *   #    &quot;universal_newline&quot;]
 *
 *   p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;UTF-32BE&quot;, universal_newline: true)
 *   #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 *   #    &quot;universal_newline&quot;,
 *   #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-32BE&gt;]]
 */
static VALUE
econv_s_search_convpath(int argc, VALUE *argv, VALUE klass)
{
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    int ecflags;
    VALUE ecopts;
    VALUE convpath;

    econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);

    convpath = Qnil;
    transcode_search_path(sname, dname, search_convpath_i, &amp;convpath);

    if (NIL_P(convpath))
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    if (decorate_convpath(convpath, ecflags) == -1)
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    return convpath;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="convert-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>convert</strong>(source_string) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Convert source_string and return destination_string.
</p>
<p>
source_string is assumed as a part of source. i.e.  :partial_input=>true is
specified internally. finish method should be used last.
</p>
<pre class="code">
  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;euc-jp&quot;)
  puts ec.convert(&quot;\u3042&quot;).dump     #=&gt; &quot;\xA4\xA2&quot;
  puts ec.finish.dump                #=&gt; &quot;&quot;

  ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
  puts ec.convert(&quot;\xA4&quot;).dump       #=&gt; &quot;&quot;
  puts ec.convert(&quot;\xA2&quot;).dump       #=&gt; &quot;\xE3\x81\x82&quot;
  puts ec.finish.dump                #=&gt; &quot;&quot;

  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
  puts ec.convert(&quot;\xE3&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.convert(&quot;\x81&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.convert(&quot;\x82&quot;).dump       #=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.finish.dump                #=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
</pre>
<p>
If a conversion error occur, Encoding::UndefinedConversionError or
Encoding::InvalidByteSequenceError is raised. Encoding::Converter#convert
doesn&#8217;t supply methods to recover or restart from these exceptions.
When you want to handle these conversion errors, use
Encoding::Converter#primitive_convert.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.convert(source_string) -&gt; destination_string
 *
 * Convert source_string and return destination_string.
 *
 * source_string is assumed as a part of source.
 * i.e.  :partial_input=&gt;true is specified internally.
 * finish method should be used last.
 *
 *   ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;euc-jp&quot;)
 *   puts ec.convert(&quot;\u3042&quot;).dump     #=&gt; &quot;\xA4\xA2&quot;
 *   puts ec.finish.dump                #=&gt; &quot;&quot;
 *
 *   ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
 *   puts ec.convert(&quot;\xA4&quot;).dump       #=&gt; &quot;&quot;
 *   puts ec.convert(&quot;\xA2&quot;).dump       #=&gt; &quot;\xE3\x81\x82&quot;
 *   puts ec.finish.dump                #=&gt; &quot;&quot;
 *
 *   ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
 *   puts ec.convert(&quot;\xE3&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *   puts ec.convert(&quot;\x81&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *   puts ec.convert(&quot;\x82&quot;).dump       #=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *   puts ec.finish.dump                #=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
 *
 * If a conversion error occur,
 * Encoding::UndefinedConversionError or
 * Encoding::InvalidByteSequenceError is raised.
 * Encoding::Converter#convert doesn't supply methods to recover or restart
 * from these exceptions.
 * When you want to handle these conversion errors,
 * use Encoding::Converter#primitive_convert.
 *
 */
static VALUE
econv_convert(VALUE self, VALUE source_string)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    StringValue(source_string);

    dst = rb_str_new(NULL, 0);

    av[0] = rb_str_dup(source_string);
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(ECONV_PARTIAL_INPUT);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret == sym_finished) {
        rb_raise(rb_eArgError, &quot;converter already finished&quot;);
    }

    if (ret != sym_source_buffer_empty) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="convpath-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>convpath</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the conversion path of ec.
</p>
<p>
The result is an array of conversions.
</p>
<pre class="code">
  ec = Encoding::Converter.new(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, crlf_newline: true)
  p ec.convpath
  #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
  #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
  #    &quot;crlf_newline&quot;]
</pre>
<p>
Each element of the array is a pair of encodings or a string. A pair means
an encoding conversion. A string means a decorator.
</p>
<p>
In the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means a
converter from ISO-8859-1 to UTF-8. &#8220;crlf_newline&#8221; means
newline converter from LF to CRLF.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.convpath        -&gt; ary
 *
 * Returns the conversion path of ec.
 *
 * The result is an array of conversions.
 *
 *   ec = Encoding::Converter.new(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, crlf_newline: true)
 *   p ec.convpath
 *   #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 *   #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
 *   #    &quot;crlf_newline&quot;]
 *
 * Each element of the array is a pair of encodings or a string.
 * A pair means an encoding conversion.
 * A string means a decorator.
 *
 * In the above example, [#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;] means
 * a converter from ISO-8859-1 to UTF-8.
 * &quot;crlf_newline&quot; means newline converter from LF to CRLF.
 */
static VALUE
econv_convpath(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE result;
    int i;

    result = rb_ary_new();
    for (i = 0; i &lt; ec-&gt;num_trans; i++) {
        const rb_transcoder *tr = ec-&gt;elems[i].tc-&gt;transcoder;
        VALUE v;
        if (DECORATOR_P(tr-&gt;src_encoding, tr-&gt;dst_encoding))
            v = rb_str_new_cstr(tr-&gt;dst_encoding);
        else
            v = rb_assoc_new(make_encobj(tr-&gt;src_encoding), make_encobj(tr-&gt;dst_encoding));
        rb_ary_push(result, v);
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="destination_encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>) <strong>destination_encoding</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the destination encoding as an Encoding object.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.destination_encoding -&gt; encoding
 *
 * Returns the destination encoding as an Encoding object.
 */
static VALUE
econv_destination_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;destination_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;destination_encoding);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="finish-instance_method">
  
    - (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>finish</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Finishes the converter. It returns the last part of the converted string.
</p>
<pre class="code">
  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
  p ec.convert(&quot;\u3042&quot;)     #=&gt; &quot;\e$B$\&quot;&quot;
  p ec.finish                #=&gt; &quot;\e(B&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.finish -&gt; string
 *
 * Finishes the converter.
 * It returns the last part of the converted string.
 *
 *   ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
 *   p ec.convert(&quot;\u3042&quot;)     #=&gt; &quot;\e$B$\&quot;&quot;
 *   p ec.finish                #=&gt; &quot;\e(B&quot;
 */
static VALUE
econv_finish(VALUE self)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    dst = rb_str_new(NULL, 0);

    av[0] = Qnil;
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(0);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret != sym_finished) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="insert_output-instance_method">
  
    - (<tt>nil</tt>) <strong>insert_output</strong>(string) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Inserts string into the encoding converter. The string will be converted to
the destination encoding and output on later conversions.
</p>
<p>
If the destination encoding is stateful, string is converted according to
the state and the state is updated.
</p>
<p>
This method should be used only when a conversion error occurs.
</p>
<pre class="code">
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 src = &quot;HIRAGANA LETTER A is \u{3042}.&quot;
 dst = &quot;&quot;
 p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &quot;, &quot;.&quot;]
 ec.insert_output(&quot;&lt;err&gt;&quot;)
 p ec.primitive_convert(src, dst)    #=&gt; :finished
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &lt;err&gt;.&quot;, &quot;&quot;]

 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
 src = &quot;\u{306F 3041 3068 2661 3002}&quot; # U+2661 is not representable in iso-2022-jp
 dst = &quot;&quot;
 p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;\xE3\x80\x82&quot;]
 ec.insert_output &quot;?&quot;                # state change required to output &quot;?&quot;.
 p ec.primitive_convert(src, dst)    #=&gt; :finished
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H\e(B?\e$B!#\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.insert_output(string) -&gt; nil
 *
 * Inserts string into the encoding converter.
 * The string will be converted to the destination encoding and
 * output on later conversions.
 *
 * If the destination encoding is stateful,
 * string is converted according to the state and the state is updated.
 *
 * This method should be used only when a conversion error occurs.
 *
 *  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 *  src = &quot;HIRAGANA LETTER A is \u{3042}.&quot;
 *  dst = &quot;&quot;
 *  p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 *  puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &quot;, &quot;.&quot;]
 *  ec.insert_output(&quot;&lt;err&gt;&quot;)
 *  p ec.primitive_convert(src, dst)    #=&gt; :finished
 *  puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &lt;err&gt;.&quot;, &quot;&quot;]
 *
 *  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
 *  src = &quot;\u{306F 3041 3068 2661 3002}&quot; # U+2661 is not representable in iso-2022-jp
 *  dst = &quot;&quot;
 *  p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 *  puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;\xE3\x80\x82&quot;]
 *  ec.insert_output &quot;?&quot;                # state change required to output &quot;?&quot;.
 *  p ec.primitive_convert(src, dst)    #=&gt; :finished
 *  puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H\e(B?\e$B!#\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;&quot;]
 *
 */
static VALUE
econv_insert_output(VALUE self, VALUE string)
{
    const char *insert_enc;

    int ret;

    rb_econv_t *ec = check_econv(self);

    StringValue(string);
    insert_enc = rb_econv_encoding_to_insert_output(ec);
    string = rb_str_encode(string, rb_enc_from_encoding(rb_enc_find(insert_enc)), 0, Qnil);

    ret = rb_econv_insert_output(ec, (const unsigned char *)RSTRING_PTR(string), RSTRING_LEN(string), insert_enc);
    if (ret == -1) {
    rb_raise(rb_eArgError, &quot;too big string&quot;);
    }

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a printable version of <em>ec</em>
</p>
<pre class="code">
  ec = Encoding::Converter.new(&quot;iso-8859-1&quot;, &quot;utf-8&quot;)
  puts ec.inspect    #=&gt; #&lt;Encoding::Converter: ISO-8859-1 to UTF-8&gt;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.inspect         -&gt; string
 *
 * Returns a printable version of &lt;i&gt;ec&lt;/i&gt;
 *
 *   ec = Encoding::Converter.new(&quot;iso-8859-1&quot;, &quot;utf-8&quot;)
 *   puts ec.inspect    #=&gt; #&lt;Encoding::Converter: ISO-8859-1 to UTF-8&gt;
 *
 */
static VALUE
econv_inspect(VALUE self)
{
    const char *cname = rb_obj_classname(self);
    rb_econv_t *ec;

    TypedData_Get_Struct(self, rb_econv_t, &amp;econv_data_type, ec);
    if (!ec)
        return rb_sprintf(&quot;#&lt;%s: uninitialized&gt;&quot;, cname);
    else {
        const char *sname = ec-&gt;source_encoding_name;
        const char *dname = ec-&gt;destination_encoding_name;
        VALUE str;
        str = rb_sprintf(&quot;#&lt;%s: &quot;, cname);
        econv_description(sname, dname, ec-&gt;flags, str);
        rb_str_cat2(str, &quot;&gt;&quot;);
        return str;
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="last_error-instance_method">
  
    - (<tt><span class='object_link'><a href="../Exception.html" title="Exception (class)">Exception</a></span></tt><sup>?</sup>) <strong>last_error</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an exception object for the last conversion. Returns nil if the
last conversion did not produce an error.
</p>
<p>
&#8220;error&#8221; means that Encoding::InvalidByteSequenceError and
Encoding::UndefinedConversionError for Encoding::Converter#convert and
:invalid_byte_sequence, :incomplete_input and :undefined_conversion for
Encoding::Converter#primitive_convert.
</p>
<pre class="code">
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 p ec.primitive_convert(src=&quot;\xf1abcd&quot;, dst=&quot;&quot;)       #=&gt; :invalid_byte_sequence
 p ec.last_error      #=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xF1&quot; followed by &quot;a&quot; on UTF-8&gt;
 p ec.primitive_convert(src, dst, nil, 1)             #=&gt; :destination_buffer_full
 p ec.last_error      #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Exception.html" title="Exception (class)">Exception</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.last_error -&gt; exception or nil
 *
 * Returns an exception object for the last conversion.
 * Returns nil if the last conversion did not produce an error.
 *
 * &quot;error&quot; means that
 * Encoding::InvalidByteSequenceError and Encoding::UndefinedConversionError for
 * Encoding::Converter#convert and
 * :invalid_byte_sequence, :incomplete_input and :undefined_conversion for
 * Encoding::Converter#primitive_convert.
 *
 *  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 *  p ec.primitive_convert(src=&quot;\xf1abcd&quot;, dst=&quot;&quot;)       #=&gt; :invalid_byte_sequence
 *  p ec.last_error      #=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xF1&quot; followed by &quot;a&quot; on UTF-8&gt;
 *  p ec.primitive_convert(src, dst, nil, 1)             #=&gt; :destination_buffer_full
 *  p ec.last_error      #=&gt; nil
 *
 */
static VALUE
econv_last_error(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE exc;

    exc = make_econv_exception(ec);
    if (NIL_P(exc))
        return Qnil;
    return exc;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="primitive_convert-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer, destination_byteoffset) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>primitive_convert</strong>(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
possible opt elements:
</p>
<pre class="code">
  hash form:
    :partial_input =&gt; true           # source buffer may be part of larger source
    :after_output =&gt; true            # stop conversion after output before input
  integer form:
    Encoding::Converter::PARTIAL_INPUT
    Encoding::Converter::AFTER_OUTPUT
</pre>
<p>
possible results:
</p>
<pre class="code">
   :invalid_byte_sequence
   :incomplete_input
   :undefined_conversion
   :after_output
   :destination_buffer_full
   :source_buffer_empty
   :finished
</pre>
<p>
primitive_convert converts source_buffer into destination_buffer.
</p>
<p>
source_buffer should be a string or nil. nil means a empty string.
</p>
<p>
destination_buffer should be a string.
</p>
<p>
destination_byteoffset should be an integer or nil. nil means the end of
destination_buffer. If it is omitted, nil is assumed.
</p>
<p>
destination_bytesize should be an integer or nil. nil means unlimited. If
it is omitted, nil is assumed.
</p>
<p>
opt should be nil, a hash or an integer. nil means no flags. If it is
omitted, nil is assumed.
</p>
<p>
primitive_convert converts the content of source_buffer from beginning and
store the result into destination_buffer.
</p>
<p>
destination_byteoffset and destination_bytesize specify the region which
the converted result is stored. destination_byteoffset specifies the start
position in destination_buffer in bytes. If destination_byteoffset is nil,
destination_buffer.bytesize is used for appending the result.
destination_bytesize specifies maximum number of bytes. If
destination_bytesize is nil, destination size is unlimited. After
conversion, destination_buffer is resized to destination_byteoffset +
actually produced number of bytes. Also destination_buffer&#8217;s encoding
is set to destination_encoding.
</p>
<p>
primitive_convert drops the converted part of source_buffer. the dropped
part is converted in destination_buffer or buffered in Encoding::Converter
object.
</p>
<p>
primitive_convert stops conversion when one of following condition met.
</p>
<ul>
<li><p>
invalid byte sequence found in source buffer (:invalid_byte_sequence)
</p>
</li>
<li><p>
unexpected end of source buffer (:incomplete_input) this occur only when
:partial_input is not specified.
</p>
</li>
<li><p>
character not representable in output encoding (:undefined_conversion)
</p>
</li>
<li><p>
after some output is generated, before input is done (:after_output) this
occur only when :after_output is specified.
</p>
</li>
<li><p>
destination buffer is full (:destination_buffer_full) this occur only when
destination_bytesize is non-nil.
</p>
</li>
<li><p>
source buffer is empty (:source_buffer_empty) this occur only when
:partial_input is specified.
</p>
</li>
<li><p>
conversion is finished (:finished)
</p>
</li>
</ul>
<p>
example:
</p>
<pre class="code">
  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
  ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 100)
  p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]

  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
  ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;i&quot;]</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.primitive_convert(source_buffer, destination_buffer) -&gt; symbol
 *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset) -&gt; symbol
 *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) -&gt; symbol
 *   ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) -&gt; symbol
 *
 * possible opt elements:
 *   hash form:
 *     :partial_input =&gt; true           # source buffer may be part of larger source
 *     :after_output =&gt; true            # stop conversion after output before input
 *   integer form:
 *     Encoding::Converter::PARTIAL_INPUT
 *     Encoding::Converter::AFTER_OUTPUT
 *
 * possible results:
 *    :invalid_byte_sequence
 *    :incomplete_input
 *    :undefined_conversion
 *    :after_output
 *    :destination_buffer_full
 *    :source_buffer_empty
 *    :finished
 *
 * primitive_convert converts source_buffer into destination_buffer.
 *
 * source_buffer should be a string or nil.
 * nil means a empty string.
 *
 * destination_buffer should be a string.
 *
 * destination_byteoffset should be an integer or nil.
 * nil means the end of destination_buffer.
 * If it is omitted, nil is assumed.
 *
 * destination_bytesize should be an integer or nil.
 * nil means unlimited.
 * If it is omitted, nil is assumed.
 *
 * opt should be nil, a hash or an integer.
 * nil means no flags.
 * If it is omitted, nil is assumed.
 *
 * primitive_convert converts the content of source_buffer from beginning
 * and store the result into destination_buffer.
 *
 * destination_byteoffset and destination_bytesize specify the region which
 * the converted result is stored.
 * destination_byteoffset specifies the start position in destination_buffer in bytes.
 * If destination_byteoffset is nil,
 * destination_buffer.bytesize is used for appending the result.
 * destination_bytesize specifies maximum number of bytes.
 * If destination_bytesize is nil,
 * destination size is unlimited.
 * After conversion, destination_buffer is resized to
 * destination_byteoffset + actually produced number of bytes.
 * Also destination_buffer's encoding is set to destination_encoding.
 *
 * primitive_convert drops the converted part of source_buffer.
 * the dropped part is converted in destination_buffer or
 * buffered in Encoding::Converter object.
 *
 * primitive_convert stops conversion when one of following condition met.
 * - invalid byte sequence found in source buffer (:invalid_byte_sequence)
 * - unexpected end of source buffer (:incomplete_input)
 *   this occur only when :partial_input is not specified.
 * - character not representable in output encoding (:undefined_conversion)
 * - after some output is generated, before input is done (:after_output)
 *   this occur only when :after_output is specified.
 * - destination buffer is full (:destination_buffer_full)
 *   this occur only when destination_bytesize is non-nil.
 * - source buffer is empty (:source_buffer_empty)
 *   this occur only when :partial_input is specified.
 * - conversion is finished (:finished)
 *
 * example:
 *   ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
 *   ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 100)
 *   p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]
 *
 *   ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
 *   ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]
 *   ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]
 *   ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]
 *   ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
 *   p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;i&quot;]
 *
 */
static VALUE
econv_primitive_convert(int argc, VALUE *argv, VALUE self)
{
    VALUE input, output, output_byteoffset_v, output_bytesize_v, opt, flags_v;
    rb_econv_t *ec = check_econv(self);
    rb_econv_result_t res;
    const unsigned char *ip, *is;
    unsigned char *op, *os;
    long output_byteoffset, output_bytesize;
    unsigned long output_byteend;
    int flags;

    rb_scan_args(argc, argv, &quot;23&quot;, &amp;input, &amp;output, &amp;output_byteoffset_v, &amp;output_bytesize_v, &amp;opt);

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = 0; /* dummy */
    else
        output_byteoffset = NUM2LONG(output_byteoffset_v);

    if (NIL_P(output_bytesize_v))
        output_bytesize = 0; /* dummy */
    else
        output_bytesize = NUM2LONG(output_bytesize_v);

    if (NIL_P(opt)) {
        flags = 0;
    }
    else if (!NIL_P(flags_v = rb_check_to_integer(opt, &quot;to_int&quot;))) {
        flags = NUM2INT(flags_v);
    }
    else {
        VALUE v;
        opt = rb_convert_type(opt, T_HASH, &quot;Hash&quot;, &quot;to_hash&quot;);
        flags = 0;
        v = rb_hash_aref(opt, sym_partial_input);
        if (RTEST(v))
            flags |= ECONV_PARTIAL_INPUT;
        v = rb_hash_aref(opt, sym_after_output);
        if (RTEST(v))
            flags |= ECONV_AFTER_OUTPUT;
    }

    StringValue(output);
    if (!NIL_P(input))
        StringValue(input);
    rb_str_modify(output);

    if (NIL_P(output_bytesize_v)) {
        output_bytesize = RSTRING_EMBED_LEN_MAX;
        if (!NIL_P(input) &amp;&amp; output_bytesize &lt; RSTRING_LEN(input))
            output_bytesize = RSTRING_LEN(input);
    }

  retry:

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = RSTRING_LEN(output);

    if (output_byteoffset &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_byteoffset&quot;);

    if (RSTRING_LEN(output) &lt; output_byteoffset)
        rb_raise(rb_eArgError, &quot;output_byteoffset too big&quot;);

    if (output_bytesize &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_bytesize&quot;);

    output_byteend = (unsigned long)output_byteoffset +
                     (unsigned long)output_bytesize;

    if (output_byteend &lt; (unsigned long)output_byteoffset ||
        LONG_MAX &lt; output_byteend)
        rb_raise(rb_eArgError, &quot;output_byteoffset+output_bytesize too big&quot;);

    if (rb_str_capacity(output) &lt; output_byteend)
        rb_str_resize(output, output_byteend);

    if (NIL_P(input)) {
        ip = is = NULL;
    }
    else {
        ip = (const unsigned char *)RSTRING_PTR(input);
        is = ip + RSTRING_LEN(input);
    }

    op = (unsigned char *)RSTRING_PTR(output) + output_byteoffset;
    os = op + output_bytesize;

    res = rb_econv_convert(ec, &amp;ip, is, &amp;op, os, flags);
    rb_str_set_len(output, op-(unsigned char *)RSTRING_PTR(output));
    if (!NIL_P(input))
        rb_str_drop_bytes(input, ip - (unsigned char *)RSTRING_PTR(input));

    if (NIL_P(output_bytesize_v) &amp;&amp; res == econv_destination_buffer_full) {
        if (LONG_MAX / 2 &lt; output_bytesize)
            rb_raise(rb_eArgError, &quot;too long conversion result&quot;);
        output_bytesize *= 2;
        output_byteoffset_v = Qnil;
        goto retry;
    }

    if (ec-&gt;destination_encoding) {
        rb_enc_associate(output, ec-&gt;destination_encoding);
    }

    return econv_result_to_symbol(res);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="primitive_errinfo-instance_method">
  
    - (<tt><span class='object_link'><a href="../Array.html" title="Array (class)">Array</a></span></tt>) <strong>primitive_errinfo</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
primitive_errinfo returns important information regarding the last error as
a 5-element array:
</p>
<pre class="code">
  [result, enc1, enc2, error_bytes, readagain_bytes]
</pre>
<p>
result is the last result of primitive_convert.
</p>
<p>
Other elements are only meaningful when result is :invalid_byte_sequence,
:incomplete_input or :undefined_conversion.
</p>
<p>
enc1 and enc2 indicate a conversion step as a pair of strings. For example,
a converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP
-> UTF-8 -> ISO-8859-1. So [enc1, enc2] is either [&#8220;EUC-JP&#8221;,
&#8220;UTF-8&#8221;] or [&#8220;UTF-8&#8221;, &#8220;ISO-8859-1&#8221;].
</p>
<p>
error_bytes and readagain_bytes indicate the byte sequences which caused
the error. error_bytes is discarded portion. readagain_bytes is buffered
portion which is read again on next conversion.
</p>
<p>
Example:
</p>
<pre class="code">
  # \xff is invalid as EUC-JP.
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;Shift_JIS&quot;)
  ec.primitive_convert(src=&quot;\xff&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]

  # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
  # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
  # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4\xa2&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]

  # partial character is invalid
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]

  # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
  # partial characters.
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10, Encoding::Converter::PARTIAL_INPUT)
  p ec.primitive_errinfo
  #=&gt; [:source_buffer_empty, nil, nil, nil, nil]

  # \xd8\x00\x00@ is invalid as UTF-16BE because
  # no low surrogate after high surrogate (\xd8\x00).
  # It is detected by 3rd byte (\00) which is part of next character.
  # So the high surrogate (\xd8\x00) is discarded and
  # the 3rd byte is read again later.
  # Since the byte is buffered in ec, it is dropped from src.
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)
  ec.primitive_convert(src=&quot;\xd8\x00\x00@&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]
  p src
  #=&gt; &quot;@&quot;

  # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
  # The problem is detected by 4th byte.
  ec = Encoding::Converter.new(&quot;UTF-16LE&quot;, &quot;UTF-8&quot;)
  ec.primitive_convert(src=&quot;\x00\xd8@\x00&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]
  p src
  #=&gt; &quot;&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.primitive_errinfo -&gt; array
 *
 * primitive_errinfo returns important information regarding the last error
 * as a 5-element array:
 *
 *   [result, enc1, enc2, error_bytes, readagain_bytes]
 *
 * result is the last result of primitive_convert.
 *
 * Other elements are only meaningful when result is
 * :invalid_byte_sequence, :incomplete_input or :undefined_conversion.
 *
 * enc1 and enc2 indicate a conversion step as a pair of strings.
 * For example, a converter from EUC-JP to ISO-8859-1 converts
 * a string as follows: EUC-JP -&gt; UTF-8 -&gt; ISO-8859-1.
 * So [enc1, enc2] is either [&quot;EUC-JP&quot;, &quot;UTF-8&quot;] or [&quot;UTF-8&quot;, &quot;ISO-8859-1&quot;].
 *
 * error_bytes and readagain_bytes indicate the byte sequences which caused the error.
 * error_bytes is discarded portion.
 * readagain_bytes is buffered portion which is read again on next conversion.
 *
 * Example:
 *
 *   # \xff is invalid as EUC-JP.
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;Shift_JIS&quot;)
 *   ec.primitive_convert(src=&quot;\xff&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]
 *
 *   # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
 *   # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
 *   # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
 *   ec.primitive_convert(src=&quot;\xa4\xa2&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]
 *
 *   # partial character is invalid
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
 *   ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]
 *
 *   # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
 *   # partial characters.
 *   ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
 *   ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10, Encoding::Converter::PARTIAL_INPUT)
 *   p ec.primitive_errinfo
 *   #=&gt; [:source_buffer_empty, nil, nil, nil, nil]
 *
 *   # \xd8\x00\x00@ is invalid as UTF-16BE because
 *   # no low surrogate after high surrogate (\xd8\x00).
 *   # It is detected by 3rd byte (\00) which is part of next character.
 *   # So the high surrogate (\xd8\x00) is discarded and
 *   # the 3rd byte is read again later.
 *   # Since the byte is buffered in ec, it is dropped from src.
 *   ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)
 *   ec.primitive_convert(src=&quot;\xd8\x00\x00@&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]
 *   p src
 *   #=&gt; &quot;@&quot;
 *
 *   # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
 *   # The problem is detected by 4th byte.
 *   ec = Encoding::Converter.new(&quot;UTF-16LE&quot;, &quot;UTF-8&quot;)
 *   ec.primitive_convert(src=&quot;\x00\xd8@\x00&quot;, dst=&quot;&quot;, nil, 10)
 *   p ec.primitive_errinfo
 *   #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]
 *   p src
 *   #=&gt; &quot;&quot;
 *
 */
static VALUE
econv_primitive_errinfo(VALUE self)
{
    rb_econv_t *ec = check_econv(self);

    VALUE ary;

    ary = rb_ary_new2(5);

    rb_ary_store(ary, 0, econv_result_to_symbol(ec-&gt;last_error.result));
    rb_ary_store(ary, 4, Qnil);

    if (ec-&gt;last_error.source_encoding)
        rb_ary_store(ary, 1, rb_str_new2(ec-&gt;last_error.source_encoding));

    if (ec-&gt;last_error.destination_encoding)
        rb_ary_store(ary, 2, rb_str_new2(ec-&gt;last_error.destination_encoding));

    if (ec-&gt;last_error.error_bytes_start) {
        rb_ary_store(ary, 3, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start, ec-&gt;last_error.error_bytes_len));
        rb_ary_store(ary, 4, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start + ec-&gt;last_error.error_bytes_len, ec-&gt;last_error.readagain_len));
    }

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="putback-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>putback</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
call-seq
</p>
<pre class="code">
  ec.putback                    -&gt; string
  ec.putback(max_numbytes)      -&gt; string
</pre>
<p>
Put back the bytes which will be converted.
</p>
<p>
The bytes are caused by invalid_byte_sequence error. When
invalid_byte_sequence error, some bytes are discarded and some bytes are
buffered to be converted later. The latter bytes can be put back. It can be
observed by Encoding::InvalidByteSequenceError#readagain_bytes and
Encoding::Converter#primitive_errinfo.
</p>
<pre class="code">
  ec = Encoding::Converter.new(&quot;utf-16le&quot;, &quot;iso-8859-1&quot;)
  src = &quot;\x00\xd8\x61\x00&quot;
  dst = &quot;&quot;
  p ec.primitive_convert(src, dst)   #=&gt; :invalid_byte_sequence
  p ec.primitive_errinfo     #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;a\x00&quot;]
  p ec.putback               #=&gt; &quot;a\x00&quot;
  p ec.putback               #=&gt; &quot;&quot;          # no more bytes to put back</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq
 *   ec.putback                    -&gt; string
 *   ec.putback(max_numbytes)      -&gt; string
 *
 * Put back the bytes which will be converted.
 *
 * The bytes are caused by invalid_byte_sequence error.
 * When invalid_byte_sequence error, some bytes are discarded and
 * some bytes are buffered to be converted later.
 * The latter bytes can be put back.
 * It can be observed by
 * Encoding::InvalidByteSequenceError#readagain_bytes and
 * Encoding::Converter#primitive_errinfo.
 *
 *   ec = Encoding::Converter.new(&quot;utf-16le&quot;, &quot;iso-8859-1&quot;)
 *   src = &quot;\x00\xd8\x61\x00&quot;
 *   dst = &quot;&quot;
 *   p ec.primitive_convert(src, dst)   #=&gt; :invalid_byte_sequence
 *   p ec.primitive_errinfo     #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;a\x00&quot;]
 *   p ec.putback               #=&gt; &quot;a\x00&quot;
 *   p ec.putback               #=&gt; &quot;&quot;          # no more bytes to put back
 *
 */
static VALUE
econv_putback(int argc, VALUE *argv, VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int n;
    int putbackable;
    VALUE str, max;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;max);

    if (NIL_P(max))
        n = rb_econv_putbackable(ec);
    else {
        n = NUM2INT(max);
        putbackable = rb_econv_putbackable(ec);
        if (putbackable &lt; n)
            n = putbackable;
    }

    str = rb_str_new(NULL, n);
    rb_econv_putback(ec, (unsigned char *)RSTRING_PTR(str), n);

    if (ec-&gt;source_encoding) {
        rb_enc_associate(str, ec-&gt;source_encoding);
    }

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="replacement-instance_method">
  
    - (<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>) <strong>replacement</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the replacement string.
</p>
<pre class="code">
 ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;us-ascii&quot;)
 p ec.replacement    #=&gt; &quot;?&quot;

 ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
 p ec.replacement    #=&gt; &quot;\uFFFD&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.replacement -&gt; string
 *
 * Returns the replacement string.
 *
 *  ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;us-ascii&quot;)
 *  p ec.replacement    #=&gt; &quot;?&quot;
 *
 *  ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
 *  p ec.replacement    #=&gt; &quot;\uFFFD&quot;
 */
static VALUE
econv_get_replacement(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int ret;
    rb_encoding *enc;

    ret = make_replacement(ec);
    if (ret == -1) {
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    enc = rb_enc_find(ec-&gt;replacement_enc);
    return rb_enc_str_new((const char *)ec-&gt;replacement_str, (long)ec-&gt;replacement_len, enc);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="replacement=-instance_method">
  
    - (<tt><span class='object_link'><a href="../Object.html" title="Object (class)">Object</a></span></tt>) <strong>replacement=</strong>(string) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets the replacement string.
</p>
<pre class="code">
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;us-ascii&quot;, :undef =&gt; :replace)
 ec.replacement = &quot;&lt;undef&gt;&quot;
 p ec.convert(&quot;a \u3042 b&quot;)      #=&gt; &quot;a &lt;undef&gt; b&quot;</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.replacement = string
 *
 * Sets the replacement string.
 *
 *  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;us-ascii&quot;, :undef =&gt; :replace)
 *  ec.replacement = &quot;&lt;undef&gt;&quot;
 *  p ec.convert(&quot;a \u3042 b&quot;)      #=&gt; &quot;a &lt;undef&gt; b&quot;
 */
static VALUE
econv_set_replacement(VALUE self, VALUE arg)
{
    rb_econv_t *ec = check_econv(self);
    VALUE string = arg;
    int ret;
    rb_encoding *enc;

    StringValue(string);
    enc = rb_enc_get(string);

    ret = rb_econv_set_replacement(ec,
            (const unsigned char *)RSTRING_PTR(string),
            RSTRING_LEN(string),
            rb_enc_name(enc));

    if (ret == -1) {
        /* xxx: rb_eInvalidByteSequenceError? */
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    return arg;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="source_encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>) <strong>source_encoding</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the source encoding as an Encoding object.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="../Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 * call-seq:
 *   ec.source_encoding -&gt; encoding
 *
 * Returns the source encoding as an Encoding object.
 */
static VALUE
econv_source_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;source_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;source_encoding);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:06:14 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>