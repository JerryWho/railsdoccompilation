<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Regexp</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (R)</a> &raquo; 
    
    
    <span class="title">Regexp</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Regexp
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Regexp</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">re.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
Document-class: Regexp
</p>
<p>
A <tt>Regexp</tt> holds a regular expression, used to match a pattern
against strings. Regexps are created using the <tt>/.../</tt> and
<tt>%r{...}</tt> literals, and by the <tt>Regexp::new</tt> constructor.
</p>
<p>
:include: doc/re.rdoc
</p>


  </div>
</div>
<div class="tags">
  
</div>


  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#compile-class_method" title="compile (class method)">+ (Object) <strong>compile</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Synonym for <tt>Regexp.new</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#escape-class_method" title="escape (class method)">+ (Object) <strong>escape</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Escapes any characters that would have special meaning in a regular
expression.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#last_match-class_method" title="last_match (class method)">+ (Object) <strong>last_match</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
The first form returns the <tt>MatchData</tt> object generated by the last
successful pattern match.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#quote-class_method" title="quote (class method)">+ (Object) <strong>quote</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Escapes any characters that would have special meaning in a regular
expression.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_convert-class_method" title="try_convert (class method)">+ (nil) <strong>try_convert</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Try to convert <em>obj</em> into a Regexp, using to_regexp method.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#union-class_method" title="union (class method)">+ (Object) <strong>union</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return a <tt>Regexp</tt> object that is the union of the given
<em>pattern</em>s, i.e., will match any of its parts.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Object) <strong>==</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equality--Two regexps are equal if their patterns are identical, they
have the same character set code, and their <tt>casefold?</tt> values are
the same.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D%3D-instance_method" title="#=== (instance method)">- (Boolean) <strong>===</strong>(str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Case Equality--Synonym for <tt>Regexp#=~</tt> used in case statements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%7E-instance_method" title="#=~ (instance method)">- (Integer<sup>?</sup>) <strong>=~</strong>(str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Match--Matches <em>rxp</em> against <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#casefold%3F-instance_method" title="#casefold? (instance method)">- (Boolean) <strong>casefold?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the value of the case-insensitive flag.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encoding-instance_method" title="#encoding (instance method)">- (Object) <strong>encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">- (Object) <strong>eql?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equality--Two regexps are equal if their patterns are identical, they
have the same character set code, and their <tt>casefold?</tt> values are
the same.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fixed_encoding%3F-instance_method" title="#fixed_encoding? (instance method)">- (Boolean) <strong>fixed_encoding?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns false if rxp is applicable to a string with any ASCII compatible
encoding.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hash-instance_method" title="#hash (instance method)">- (Fixnum) <strong>hash</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Produce a hash based on the text and options of this regular expression.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">- (Object) <strong>initialize</strong> </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Constructs a new regular expression from <em>pattern</em>, which can be
either a <tt>String</tt> or a <tt>Regexp</tt> (in which case that
regexp&#8217;s options are propagated, and new options may not be specified
(a change as of Ruby 1.8). If <em>options</em> is a <tt>Fixnum</tt>, it
should be one or more of the constants <tt>Regexp::EXTENDED</tt>,
<tt>Regexp::IGNORECASE</tt>, and <tt>Regexp::MULTILINE</tt>, <em>or</em>-ed
together. Otherwise, if <em>options</em> is not <tt>nil</tt>, the regexp
will be case insensitive. When the <em>lang</em> parameter is `n&#8217; or
`N&#8217; sets the regexp no encoding.
</p>
<pre class="code">
   <span class='id r1'>r1</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>^a-z+:\\s+\w+</span><span class='tstring_end'>'</span></span><span class='rparen'>)</span>           <span class='comment'>#=&gt; /^a-z+:\s+\w+/
</span>   <span class='id r2'>r2</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>cat</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='kw'>true</span><span class='rparen'>)</span>               <span class='comment'>#=&gt; /cat/i
</span>   <span class='id r3'>r3</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>dog</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'>EXTENDED</span><span class='rparen'>)</span>   <span class='comment'>#=&gt; /dog/x
</span>   <span class='id r4'>r4</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='id r2'>r2</span><span class='rparen'>)</span>                        <span class='comment'>#=&gt; /cat/i.</span></pre>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize_copy-instance_method" title="#initialize_copy (instance method)">- (Object) <strong>initialize_copy</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Produce a nicely formatted string-version of <em>rxp</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#match-instance_method" title="#match (instance method)">- (Object) <strong>match</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a <tt>MatchData</tt> object describing the match, or <tt>nil</tt>
if there was no match.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#named_captures-instance_method" title="#named_captures (instance method)">- (Hash) <strong>named_captures</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a hash representing information about named captures of
<em>rxp</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#names-instance_method" title="#names (instance method)">- (Array) <strong>names</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a list of names of captures as an array of strings.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#options-instance_method" title="#options (instance method)">- (Fixnum) <strong>options</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the set of bits corresponding to the options used when creating
this Regexp (see <tt>Regexp::new</tt> for details. Note that additional
bits may be set in the returned options: these are used internally by the
regular expression code. These extra bits are ignored if the options are
passed to <tt>Regexp::new</tt>.
</p>
<pre class="code">
   <span class='const'>Regexp</span><span class='op'>::</span><span class='const'>IGNORECASE</span>                  <span class='comment'>#=&gt; 1
</span>   <span class='const'>Regexp</span><span class='op'>::</span><span class='const'>EXTENDED</span>                    <span class='comment'>#=&gt; 2
</span>   <span class='const'>Regexp</span><span class='op'>::</span><span class='const'>MULTILINE</span>                   <span class='comment'>#=&gt; 4
</span>
   <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>cat</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id options'>options</span>                       <span class='comment'>#=&gt; 0
</span>   <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>cat</span><span class='regexp_end'>/ix</span></span><span class='period'>.</span><span class='id options'>options</span>                     <span class='comment'>#=&gt; 3
</span>   <span class='const'>Regexp</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>'</span><span class='tstring_content'>cat</span><span class='tstring_end'>'</span></span><span class='comma'>,</span> <span class='kw'>true</span><span class='rparen'>)</span><span class='period'>.</span><span class='id options'>options</span>     <span class='comment'>#=&gt; 1
</span>   <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\xa1\xa2</span><span class='regexp_end'>/e</span></span><span class='period'>.</span><span class='id options'>options</span>                 <span class='comment'>#=&gt; 16
</span>
   <span class='id r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>cat</span><span class='regexp_end'>/ix</span></span>
   <span class='const'>Regexp</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='id r'>r</span><span class='period'>.</span><span class='id source'>source</span><span class='comma'>,</span> <span class='id r'>r</span><span class='period'>.</span><span class='id options'>options</span><span class='rparen'>)</span>     <span class='comment'>#=&gt; /cat/ix.</span></pre>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#source-instance_method" title="#source (instance method)">- (String) <strong>source</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the original string of the pattern.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">- (String) <strong>to_s</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a string containing the regular expression and its options (using
the <tt>(?opts:source)</tt> notation. This string can be fed back in to
<tt>Regexp::new</tt> to a regular expression with the same semantics as the
original. (However, <tt>Regexp#==</tt> may not return true when comparing
the two, as the source of the regular expression itself may differ, as the
example shows).  <tt>Regexp#inspect</tt> produces a generally more readable
version of <em>rxp</em>.
</p>
<pre class="code">
    <span class='id r1'>r1</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab+c</span><span class='regexp_end'>/ix</span></span>           <span class='comment'>#=&gt; /ab+c/ix
</span>    <span class='id s1'>s1</span> <span class='op'>=</span> <span class='id r1'>r1</span><span class='period'>.</span><span class='id to_s'>to_s</span>            <span class='comment'>#=&gt; &quot;(?ix-m:ab+c)&quot;
</span>    <span class='id r2'>r2</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id new'>new</span><span class='lparen'>(</span><span class='id s1'>s1</span><span class='rparen'>)</span>     <span class='comment'>#=&gt; /(?ix-m:ab+c)/
</span>    <span class='id r1'>r1</span> <span class='op'>==</span> <span class='id r2'>r2</span>                <span class='comment'>#=&gt; false
</span>    <span class='id r1'>r1</span><span class='period'>.</span><span class='id source'>source</span>               <span class='comment'>#=&gt; &quot;ab+c&quot;
</span>    <span class='id r2'>r2</span><span class='period'>.</span><span class='id source'>source</span>               <span class='comment'>#=&gt; &quot;(?ix-m:ab+c)&quot;.</span></pre>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%7E-instance_method" title="#~ (instance method)">- (Integer<sup>?</sup>) <strong>~</strong>(rxp) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Match--Matches <em>rxp</em> against the contents of <tt>$_</tt>.
</p>
</div></span>
  
</li>

      
    </ul>
  

<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(string, [options [, lang]]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(string, [options [, lang]]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(regexp) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Constructs a new regular expression from <em>pattern</em>, which can be
either a <tt>String</tt> or a <tt>Regexp</tt> (in which case that
regexp&#8217;s options are propagated, and new options may not be specified
(a change as of Ruby 1.8). If <em>options</em> is a <tt>Fixnum</tt>, it
should be one or more of the constants <tt>Regexp::EXTENDED</tt>,
<tt>Regexp::IGNORECASE</tt>, and <tt>Regexp::MULTILINE</tt>, <em>or</em>-ed
together. Otherwise, if <em>options</em> is not <tt>nil</tt>, the regexp
will be case insensitive. When the <em>lang</em> parameter is `n&#8217; or
`N&#8217; sets the regexp no encoding.
</p>
<pre class="code">
   r1 = Regexp.new('^a-z+:\\s+\w+')           #=&gt; /^a-z+:\s+\w+/
   r2 = Regexp.new('cat', true)               #=&gt; /cat/i
   r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x
   r4 = Regexp.new(r2)                        #=&gt; /cat/i</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(string, [options [, lang]]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>new</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(string, [options [, lang]]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>compile</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     Regexp.new(string, [options [, lang]])        -&gt; regexp
 *     Regexp.new(regexp)                            -&gt; regexp
 *     Regexp.compile(string, [options [, lang]])    -&gt; regexp
 *     Regexp.compile(regexp)                        -&gt; regexp
 *
 *  Constructs a new regular expression from &lt;i&gt;pattern&lt;/i&gt;, which can be either
 *  a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Regexp&lt;/code&gt; (in which case that regexp's
 *  options are propagated, and new options may not be specified (a change as of
 *  Ruby 1.8). If &lt;i&gt;options&lt;/i&gt; is a &lt;code&gt;Fixnum&lt;/code&gt;, it should be one or
 *  more of the constants &lt;code&gt;Regexp::EXTENDED&lt;/code&gt;,
 *  &lt;code&gt;Regexp::IGNORECASE&lt;/code&gt;, and &lt;code&gt;Regexp::MULTILINE&lt;/code&gt;,
 *  &lt;em&gt;or&lt;/em&gt;-ed together. Otherwise, if &lt;i&gt;options&lt;/i&gt; is not
 *  &lt;code&gt;nil&lt;/code&gt;, the regexp will be case insensitive.
 *  When the &lt;i&gt;lang&lt;/i&gt; parameter is `n' or `N' sets the regexp no encoding.
 *
 *     r1 = Regexp.new('^a-z+:\\s+\w+')           #=&gt; /^a-z+:\s+\w+/
 *     r2 = Regexp.new('cat', true)               #=&gt; /cat/i
 *     r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x
 *     r4 = Regexp.new(r2)                        #=&gt; /cat/i
 */

static VALUE
rb_reg_initialize_m(int argc, VALUE *argv, VALUE self)
{
    onig_errmsg_buffer err = &quot;&quot;;
    int flags = 0;
    VALUE str;
    rb_encoding *enc;
    const char *ptr;
    long len;

    if (argc == 0 || argc &gt; 3) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..3)&quot;, argc);
    }
    if (TYPE(argv[0]) == T_REGEXP) {
    VALUE re = argv[0];

    if (argc &gt; 1) {
        rb_warn(&quot;flags ignored&quot;);
    }
    rb_reg_check(re);
    flags = rb_reg_options(re);
    ptr = RREGEXP_SRC_PTR(re);
    len = RREGEXP_SRC_LEN(re);
    enc = rb_enc_get(re);
    if (rb_reg_initialize(self, ptr, len, enc, flags, err, NULL, 0)) {
        str = rb_enc_str_new(ptr, len, enc);
        rb_reg_raise_str(str, flags, err);
    }
    }
    else {
    if (argc &gt;= 2) {
        if (FIXNUM_P(argv[1])) flags = FIX2INT(argv[1]);
        else if (RTEST(argv[1])) flags = ONIG_OPTION_IGNORECASE;
    }
    enc = 0;
    if (argc == 3 &amp;&amp; !NIL_P(argv[2])) {
        char *kcode = StringValuePtr(argv[2]);
        if (kcode[0] == 'n' || kcode[0] == 'N') {
        enc = rb_ascii8bit_encoding();
        flags |= ARG_ENCODING_NONE;
        }
        else {
        rb_warn(&quot;encoding option is ignored - %s&quot;, kcode);
        }
    }
    str = argv[0];
    ptr = StringValuePtr(str);
    if (enc
        ? rb_reg_initialize(self, ptr, RSTRING_LEN(str), enc, flags, err, NULL, 0)
        : rb_reg_initialize_str(self, str, flags, err, NULL, 0)) {
        rb_reg_raise_str(str, flags, err);
    }
    }
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="compile-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>compile</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Synonym for <tt>Regexp.new</tt>
</p>


  </div>
</div>
<div class="tags">
  
</div>
</div>
    
      <div class="method_details ">
  <p class="signature " id="escape-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped.  For any string,
<tt>Regexp.new(Regexp.escape(<em>str</em>))=~<em>str</em></tt> will be
true.
</p>
<pre class="code">
   Regexp.escape('\*?{}.')   #=&gt; \\\*\?\{\}\.</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     Regexp.escape(str)   -&gt; string
 *     Regexp.quote(str)    -&gt; string
 *
 *  Escapes any characters that would have special meaning in a regular
 *  expression. Returns a new escaped string, or self if no characters are
 *  escaped.  For any string,
 *  &lt;code&gt;Regexp.new(Regexp.escape(&lt;i&gt;str&lt;/i&gt;))=~&lt;i&gt;str&lt;/i&gt;&lt;/code&gt; will be true.
 *
 *     Regexp.escape('\*?{}.')   #=&gt; \\\*\?\{\}\.
 *
 */

static VALUE
rb_reg_s_quote(VALUE c, VALUE str)
{
    return rb_reg_quote(reg_operand(str, TRUE));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="last_match-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>) <strong>last_match</strong> </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>last_match</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
The first form returns the <tt>MatchData</tt> object generated by the last
successful pattern match. Equivalent to reading the global variable
<tt>$~</tt>. The second form returns the <em>n</em>th field in this
<tt>MatchData</tt> object. <em>n</em> can be a string or symbol to
reference a named capture.
</p>
<p>
Note that the <tt>last_match</tt> is local to the thread and method scope
of the method that did the pattern match.
</p>
<pre class="code">
   /c(.)t/ =~ 'cat'        #=&gt; 0
   Regexp.last_match       #=&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;
   Regexp.last_match(0)    #=&gt; &quot;cat&quot;
   Regexp.last_match(1)    #=&gt; &quot;a&quot;
   Regexp.last_match(2)    #=&gt; nil

   /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;var = val&quot;
   Regexp.last_match       #=&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot; rhs:&quot;val&quot;&gt;
   Regexp.last_match(:lhs) #=&gt; &quot;var&quot;
   Regexp.last_match(:rhs) #=&gt; &quot;val&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>) <strong>last_match</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>last_match</strong>(n) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     Regexp.last_match           -&gt; matchdata
 *     Regexp.last_match(n)        -&gt; str
 *
 *  The first form returns the &lt;code&gt;MatchData&lt;/code&gt; object generated by the
 *  last successful pattern match. Equivalent to reading the global variable
 *  &lt;code&gt;$~&lt;/code&gt;. The second form returns the &lt;i&gt;n&lt;/i&gt;th field in this
 *  &lt;code&gt;MatchData&lt;/code&gt; object.
 *  &lt;em&gt;n&lt;/em&gt; can be a string or symbol to reference a named capture.
 *
 *  Note that the &lt;code&gt;last_match&lt;/code&gt; is local to the thread and method scope
 *  of the method that did the pattern match.
 *
 *     /c(.)t/ =~ 'cat'        #=&gt; 0
 *     Regexp.last_match       #=&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;
 *     Regexp.last_match(0)    #=&gt; &quot;cat&quot;
 *     Regexp.last_match(1)    #=&gt; &quot;a&quot;
 *     Regexp.last_match(2)    #=&gt; nil
 *
 *     /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;var = val&quot;
 *     Regexp.last_match       #=&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot; rhs:&quot;val&quot;&gt;
 *     Regexp.last_match(:lhs) #=&gt; &quot;var&quot;
 *     Regexp.last_match(:rhs) #=&gt; &quot;val&quot;
 */

static VALUE
rb_reg_s_last_match(int argc, VALUE *argv)
{
    VALUE nth;

    if (argc &gt; 0 &amp;&amp; rb_scan_args(argc, argv, &quot;01&quot;, &amp;nth) == 1) {
        VALUE match = rb_backref_get();
        int n;
        if (NIL_P(match)) return Qnil;
        n = match_backref_number(match, nth);
    return rb_reg_nth_match(n, match);
    }
    return match_getter();
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="quote-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped.  For any string,
<tt>Regexp.new(Regexp.escape(<em>str</em>))=~<em>str</em></tt> will be
true.
</p>
<pre class="code">
   Regexp.escape('\*?{}.')   #=&gt; \\\*\?\{\}\.</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>escape</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>quote</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     Regexp.escape(str)   -&gt; string
 *     Regexp.quote(str)    -&gt; string
 *
 *  Escapes any characters that would have special meaning in a regular
 *  expression. Returns a new escaped string, or self if no characters are
 *  escaped.  For any string,
 *  &lt;code&gt;Regexp.new(Regexp.escape(&lt;i&gt;str&lt;/i&gt;))=~&lt;i&gt;str&lt;/i&gt;&lt;/code&gt; will be true.
 *
 *     Regexp.escape('\*?{}.')   #=&gt; \\\*\?\{\}\.
 *
 */

static VALUE
rb_reg_s_quote(VALUE c, VALUE str)
{
    return rb_reg_quote(reg_operand(str, TRUE));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="try_convert-class_method">
  
    + (<tt>nil</tt>) <strong>try_convert</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Try to convert <em>obj</em> into a Regexp, using to_regexp method. Returns
converted regexp or nil if <em>obj</em> cannot be converted for any reason.
</p>
<pre class="code">
   Regexp.try_convert(/re/)         #=&gt; /re/
   Regexp.try_convert(&quot;re&quot;)         #=&gt; nil

   o = Object.new
   Regexp.try_convert(o)            #=&gt; nil
   def o.to_regexp() /foo/ end
   Regexp.try_convert(o)            #=&gt; /foo/</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     Regexp.try_convert(obj) -&gt; re or nil
 *
 *  Try to convert &lt;i&gt;obj&lt;/i&gt; into a Regexp, using to_regexp method.
 *  Returns converted regexp or nil if &lt;i&gt;obj&lt;/i&gt; cannot be converted
 *  for any reason.
 *
 *     Regexp.try_convert(/re/)         #=&gt; /re/
 *     Regexp.try_convert(&quot;re&quot;)         #=&gt; nil
 *
 *     o = Object.new
 *     Regexp.try_convert(o)            #=&gt; nil
 *     def o.to_regexp() /foo/ end
 *     Regexp.try_convert(o)            #=&gt; /foo/
 *
 */
static VALUE
rb_reg_s_try_convert(VALUE dummy, VALUE re)
{
    return rb_check_regexp_type(re);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="union-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pat1, pat2, ...) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pats_ary) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return a <tt>Regexp</tt> object that is the union of the given
<em>pattern</em>s, i.e., will match any of its parts. The <em>pattern</em>s
can be Regexp objects, in which case their options will be preserved, or
Strings. If no patterns are given, returns <tt>/(?!)/</tt>. The behavior is
unspecified if any given <em>pattern</em> contains capture.
</p>
<pre class="code">
   Regexp.union                         #=&gt; /(?!)/
   Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/
   Regexp.union(&quot;a+b*c&quot;)                #=&gt; /a\+b\*c/
   Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/
   Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) #=&gt; /skiing|sledding/
   Regexp.union(/dogs/, /cats/i)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pat1, pat2, ...) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>) <strong>union</strong>(pats_ary) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     Regexp.union(pat1, pat2, ...)            -&gt; new_regexp
 *     Regexp.union(pats_ary)                   -&gt; new_regexp
 *
 *  Return a &lt;code&gt;Regexp&lt;/code&gt; object that is the union of the given
 *  &lt;em&gt;pattern&lt;/em&gt;s, i.e., will match any of its parts. The &lt;em&gt;pattern&lt;/em&gt;s
 *  can be Regexp objects, in which case their options will be preserved, or
 *  Strings. If no patterns are given, returns &lt;code&gt;/(?!)/&lt;/code&gt;.
 *  The behavior is unspecified if any given &lt;em&gt;pattern&lt;/em&gt; contains capture.
 *
 *     Regexp.union                         #=&gt; /(?!)/
 *     Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/
 *     Regexp.union(&quot;a+b*c&quot;)                #=&gt; /a\+b\*c/
 *     Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/
 *     Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) #=&gt; /skiing|sledding/
 *     Regexp.union(/dogs/, /cats/i)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/
 */
static VALUE
rb_reg_s_union_m(VALUE self, VALUE args)
{
    VALUE v;
    if (RARRAY_LEN(args) == 1 &amp;&amp;
        !NIL_P(v = rb_check_array_type(rb_ary_entry(args, 0)))) {
        return rb_reg_s_union(self, v);
    }
    return rb_reg_s_union(self, args);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="==-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equality--Two regexps are equal if their patterns are identical, they
have the same character set code, and their <tt>casefold?</tt> values are
the same.
</p>
<pre class="code">
   /abc/  == /abc/x   #=&gt; false
   /abc/  == /abc/i   #=&gt; false
   /abc/  == /abc/n   #=&gt; false
   /abc/u == /abc/n   #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp == other_rxp      -&gt; true or false
 *     rxp.eql?(other_rxp)   -&gt; true or false
 *
 *  Equality---Two regexps are equal if their patterns are identical, they have
 *  the same character set code, and their &lt;code&gt;casefold?&lt;/code&gt; values are the
 *  same.
 *
 *     /abc/  == /abc/x   #=&gt; false
 *     /abc/  == /abc/i   #=&gt; false
 *     /abc/  == /abc/n   #=&gt; false
 *     /abc/u == /abc/n   #=&gt; false
 */

static VALUE
rb_reg_equal(VALUE re1, VALUE re2)
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (FL_TEST(re1, KCODE_FIXED) != FL_TEST(re2, KCODE_FIXED)) return Qfalse;
    if (RREGEXP(re1)-&gt;ptr-&gt;options != RREGEXP(re2)-&gt;ptr-&gt;options) return Qfalse;
    if (RREGEXP_SRC_LEN(re1) != RREGEXP_SRC_LEN(re2)) return Qfalse;
    if (ENCODING_GET(re1) != ENCODING_GET(re2)) return Qfalse;
    if (memcmp(RREGEXP_SRC_PTR(re1), RREGEXP_SRC_PTR(re2), RREGEXP_SRC_LEN(re1)) == 0) {
    return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="===-instance_method">
  
    - (<tt>Boolean</tt>) <strong>===</strong>(str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Case Equality--Synonym for <tt>Regexp#=~</tt> used in case statements.
</p>
<pre class="code">
   a = &quot;HELLO&quot;
   case a
   when /^[a-z]*$/; print &quot;Lower case\n&quot;
   when /^[A-Z]*$/; print &quot;Upper case\n&quot;
   else;            print &quot;Mixed case\n&quot;
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   Upper case</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp === str   -&gt; true or false
 *
 *  Case Equality---Synonym for &lt;code&gt;Regexp#=~&lt;/code&gt; used in case statements.
 *
 *     a = &quot;HELLO&quot;
 *     case a
 *     when /^[a-z]*$/; print &quot;Lower case\n&quot;
 *     when /^[A-Z]*$/; print &quot;Upper case\n&quot;
 *     else;            print &quot;Mixed case\n&quot;
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Upper case
 */

VALUE
rb_reg_eqq(VALUE re, VALUE str)
{
    long start;

    str = reg_operand(str, FALSE);
    if (NIL_P(str)) {
    rb_backref_set(Qnil);
    return Qfalse;
    }
    start = rb_reg_search(re, str, 0, 0);
    if (start &lt; 0) {
    return Qfalse;
    }
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="=~-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>=~</strong>(str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Match--Matches <em>rxp</em> against <em>str</em>.
</p>
<pre class="code">
   /at/ =~ &quot;input data&quot;   #=&gt; 7
   /ax/ =~ &quot;input data&quot;   #=&gt; nil
</pre>
<p>
If <tt>=~</tt> is used with a regexp literal with named captures, captured
strings (or nil) is assigned to local variables named by the capture names.
</p>
<pre class="code">
   /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;  x = y  &quot;
   p lhs    #=&gt; &quot;x&quot;
   p rhs    #=&gt; &quot;y&quot;
</pre>
<p>
If it is not matched, nil is assigned for the variables.
</p>
<pre class="code">
   /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;  x = &quot;
   p lhs    #=&gt; nil
   p rhs    #=&gt; nil
</pre>
<p>
This assignment is implemented in the Ruby parser. The parser detects
&#8216;regexp-literal =~ expression&#8217; for the assignment. The regexp
must be a literal without interpolation and placed at left hand side.
</p>
<p>
The assignment is not occur if the regexp is not a literal.
</p>
<pre class="code">
   re = /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/
   re =~ &quot;  x = y  &quot;
   p lhs    # undefined local variable
   p rhs    # undefined local variable
</pre>
<p>
A regexp interpolation, <tt>#{}</tt>, also disables the assignment.
</p>
<pre class="code">
   rhs_pat = /(?&lt;rhs&gt;\w+)/
   /(?&lt;lhs&gt;\w+)\s*=\s*#{rhs_pat}/ =~ &quot;x = y&quot;
   p lhs    # undefined local variable
</pre>
<p>
The assignment is not occur if the regexp is placed at right hand side.
</p>
<pre class="code">
  &quot;  x = y  &quot; =~ /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/
  p lhs, rhs # undefined local variable</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp =~ str    -&gt; integer or nil
 *
 *  Match---Matches &lt;i&gt;rxp&lt;/i&gt; against &lt;i&gt;str&lt;/i&gt;.
 *
 *     /at/ =~ &quot;input data&quot;   #=&gt; 7
 *     /ax/ =~ &quot;input data&quot;   #=&gt; nil
 *
 *  If &lt;code&gt;=~&lt;/code&gt; is used with a regexp literal with named captures,
 *  captured strings (or nil) is assigned to local variables named by
 *  the capture names.
 *
 *     /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;  x = y  &quot;
 *     p lhs    #=&gt; &quot;x&quot;
 *     p rhs    #=&gt; &quot;y&quot;
 *
 *  If it is not matched, nil is assigned for the variables.
 *
 *     /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;  x = &quot;
 *     p lhs    #=&gt; nil
 *     p rhs    #=&gt; nil
 *
 *  This assignment is implemented in the Ruby parser.
 *  The parser detects 'regexp-literal =~ expression' for the assignment.
 *  The regexp must be a literal without interpolation and placed at left hand side.
 *
 *  The assignment is not occur if the regexp is not a literal.
 *
 *     re = /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/
 *     re =~ &quot;  x = y  &quot;
 *     p lhs    # undefined local variable
 *     p rhs    # undefined local variable
 *
 *  A regexp interpolation, &lt;code&gt;#{}&lt;/code&gt;, also disables
 *  the assignment.
 *
 *     rhs_pat = /(?&lt;rhs&gt;\w+)/
 *     /(?&lt;lhs&gt;\w+)\s*=\s*#{rhs_pat}/ =~ &quot;x = y&quot;
 *     p lhs    # undefined local variable
 *
 *  The assignment is not occur if the regexp is placed at right hand side.
 *
 *    &quot;  x = y  &quot; =~ /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/
 *    p lhs, rhs # undefined local variable
 *
 */

VALUE
rb_reg_match(VALUE re, VALUE str)
{
    long pos = reg_match_pos(re, &amp;str, 0);
    if (pos &lt; 0) return Qnil;
    pos = rb_str_sublen(str, pos);
    return LONG2FIX(pos);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="casefold?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>casefold?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the value of the case-insensitive flag.
</p>
<pre class="code">
    /a/.casefold?           #=&gt; false
    /a/i.casefold?          #=&gt; true
    /(?i:a)/.casefold?      #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp.casefold?   -&gt; true or false
 *
 *  Returns the value of the case-insensitive flag.
 *
 *      /a/.casefold?           #=&gt; false
 *      /a/i.casefold?          #=&gt; true
 *      /(?i:a)/.casefold?      #=&gt; false
 */

static VALUE
rb_reg_casefold_p(VALUE re)
{
    rb_reg_check(re);
    if (RREGEXP(re)-&gt;ptr-&gt;options &amp; ONIG_OPTION_IGNORECASE) return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>encoding</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eql?-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equality--Two regexps are equal if their patterns are identical, they
have the same character set code, and their <tt>casefold?</tt> values are
the same.
</p>
<pre class="code">
   /abc/  == /abc/x   #=&gt; false
   /abc/  == /abc/i   #=&gt; false
   /abc/  == /abc/n   #=&gt; false
   /abc/u == /abc/n   #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>==</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eql?</strong>(other_rxp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp == other_rxp      -&gt; true or false
 *     rxp.eql?(other_rxp)   -&gt; true or false
 *
 *  Equality---Two regexps are equal if their patterns are identical, they have
 *  the same character set code, and their &lt;code&gt;casefold?&lt;/code&gt; values are the
 *  same.
 *
 *     /abc/  == /abc/x   #=&gt; false
 *     /abc/  == /abc/i   #=&gt; false
 *     /abc/  == /abc/n   #=&gt; false
 *     /abc/u == /abc/n   #=&gt; false
 */

static VALUE
rb_reg_equal(VALUE re1, VALUE re2)
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (FL_TEST(re1, KCODE_FIXED) != FL_TEST(re2, KCODE_FIXED)) return Qfalse;
    if (RREGEXP(re1)-&gt;ptr-&gt;options != RREGEXP(re2)-&gt;ptr-&gt;options) return Qfalse;
    if (RREGEXP_SRC_LEN(re1) != RREGEXP_SRC_LEN(re2)) return Qfalse;
    if (ENCODING_GET(re1) != ENCODING_GET(re2)) return Qfalse;
    if (memcmp(RREGEXP_SRC_PTR(re1), RREGEXP_SRC_PTR(re2), RREGEXP_SRC_LEN(re1)) == 0) {
    return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fixed_encoding?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>fixed_encoding?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns false if rxp is applicable to a string with any ASCII compatible
encoding. Returns true otherwise.
</p>
<pre class="code">
    r = /a/
    r.fixed_encoding?                               #=&gt; false
    r =~ &quot;\u{6666} a&quot;                               #=&gt; 2
    r =~ &quot;\xa1\xa2 a&quot;.force_encoding(&quot;euc-jp&quot;)      #=&gt; 2
    r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; 0

    r = /a/u
    r.fixed_encoding?                               #=&gt; true
    r.encoding                                      #=&gt; #&lt;Encoding:UTF-8&gt;
    r =~ &quot;\u{6666} a&quot;                               #=&gt; 2
    r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        #=&gt; ArgumentError
    r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; 0

    r = /\u{6666}/
    r.fixed_encoding?                               #=&gt; true
    r.encoding                                      #=&gt; #&lt;Encoding:UTF-8&gt;
    r =~ &quot;\u{6666} a&quot;                               #=&gt; 0
    r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        #=&gt; ArgumentError
    r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp.fixed_encoding?   -&gt; true or false
 *
 *  Returns false if rxp is applicable to
 *  a string with any ASCII compatible encoding.
 *  Returns true otherwise.
 *
 *      r = /a/
 *      r.fixed_encoding?                               #=&gt; false
 *      r =~ &quot;\u{6666} a&quot;                               #=&gt; 2
 *      r =~ &quot;\xa1\xa2 a&quot;.force_encoding(&quot;euc-jp&quot;)      #=&gt; 2
 *      r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; 0
 *
 *      r = /a/u
 *      r.fixed_encoding?                               #=&gt; true
 *      r.encoding                                      #=&gt; #&lt;Encoding:UTF-8&gt;
 *      r =~ &quot;\u{6666} a&quot;                               #=&gt; 2
 *      r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        #=&gt; ArgumentError
 *      r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; 0
 *
 *      r = /\u{6666}/
 *      r.fixed_encoding?                               #=&gt; true
 *      r.encoding                                      #=&gt; #&lt;Encoding:UTF-8&gt;
 *      r =~ &quot;\u{6666} a&quot;                               #=&gt; 0
 *      r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        #=&gt; ArgumentError
 *      r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             #=&gt; nil
 */

static VALUE
rb_reg_fixed_encoding_p(VALUE re)
{
    if (FL_TEST(re, KCODE_FIXED))
        return Qtrue;
    else
        return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="hash-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>hash</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Produce a hash based on the text and options of this regular expression.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *   rxp.hash   -&gt; fixnum
 *
 * Produce a hash based on the text and options of this regular expression.
 */

static VALUE
rb_reg_hash(VALUE re)
{
    st_index_t hashval = reg_hash(re);
    return LONG2FIX(hashval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="initialize_copy-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>initialize_copy</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/* :nodoc: */
static VALUE
rb_reg_init_copy(VALUE copy, VALUE re)
{
    onig_errmsg_buffer err = &quot;&quot;;
    const char *s;
    long len;

    if (copy == re) return copy;
    rb_check_frozen(copy);
    /* need better argument type check */
    if (!rb_obj_is_instance_of(re, rb_obj_class(copy))) {
    rb_raise(rb_eTypeError, &quot;wrong argument type&quot;);
    }
    rb_reg_check(re);
    s = RREGEXP_SRC_PTR(re);
    len = RREGEXP_SRC_LEN(re);
    if (rb_reg_initialize(copy, s, len, rb_enc_get(re), rb_reg_options(re),
        err, NULL, 0) != 0) {
    rb_reg_raise(s, len, err, re);
    }
    return copy;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Produce a nicely formatted string-version of <em>rxp</em>. Perhaps
surprisingly, <tt>#inspect</tt> actually produces the more natural version
of the string than <tt>#to_s</tt>.
</p>
<pre class="code">
     /ab+c/ix.inspect        #=&gt; &quot;/ab+c/ix&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    rxp.inspect   -&gt; string
 *
 * Produce a nicely formatted string-version of _rxp_. Perhaps surprisingly,
 * &lt;code&gt;#inspect&lt;/code&gt; actually produces the more natural version of
 * the string than &lt;code&gt;#to_s&lt;/code&gt;.
 *
 *      /ab+c/ix.inspect        #=&gt; &quot;/ab+c/ix&quot;
 *
 */

static VALUE
rb_reg_inspect(VALUE re)
{
    if (!RREGEXP(re)-&gt;ptr || !RREGEXP_SRC(re) || !RREGEXP_SRC_PTR(re)) {
        return rb_any_to_s(re);
    }
    return rb_reg_desc(RREGEXP_SRC_PTR(re), RREGEXP_SRC_LEN(re), re);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="match-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str, pos) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a <tt>MatchData</tt> object describing the match, or <tt>nil</tt>
if there was no match. This is equivalent to retrieving the value of the
special variable <tt>$~</tt> following a normal match. If the second
parameter is present, it specifies the position in the string to begin the
search.
</p>
<pre class="code">
   /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
   /(.)(.)/.match(&quot;abc&quot;, 1)[2]   #=&gt; &quot;c&quot;
</pre>
<p>
If a block is given, invoke the block with MatchData if match succeed, so
that you can write
</p>
<pre class="code">
   pat.match(str) {|m| ...}
</pre>
<p>
instead of
</p>
<pre class="code">
   if m = pat.match(str)
     ...
   end
</pre>
<p>
The return value is a value from block execution in this case.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(str, pos) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp.match(str)       -&gt; matchdata or nil
 *     rxp.match(str,pos)   -&gt; matchdata or nil
 *
 *  Returns a &lt;code&gt;MatchData&lt;/code&gt; object describing the match, or
 *  &lt;code&gt;nil&lt;/code&gt; if there was no match. This is equivalent to retrieving the
 *  value of the special variable &lt;code&gt;$~&lt;/code&gt; following a normal match.
 *  If the second parameter is present, it specifies the position in the string
 *  to begin the search.
 *
 *     /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
 *     /(.)(.)/.match(&quot;abc&quot;, 1)[2]   #=&gt; &quot;c&quot;
 *
 *  If a block is given, invoke the block with MatchData if match succeed, so
 *  that you can write
 *
 *     pat.match(str) {|m| ...}
 *
 *  instead of
 *
 *     if m = pat.match(str)
 *       ...
 *     end
 *
 *  The return value is a value from block execution in this case.
 */

static VALUE
rb_reg_match_m(int argc, VALUE *argv, VALUE re)
{
    VALUE result, str, initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;initpos) == 2) {
    pos = NUM2LONG(initpos);
    }
    else {
    pos = 0;
    }

    pos = reg_match_pos(re, &amp;str, pos);
    if (pos &lt; 0) {
    rb_backref_set(Qnil);
    return Qnil;
    }
    result = rb_backref_get();
    rb_match_busy(result);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
    return rb_yield(result);
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="named_captures-instance_method">
  
    - (<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span></tt>) <strong>named_captures</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a hash representing information about named captures of
<em>rxp</em>.
</p>
<p>
A key of the hash is a name of the named captures. A value of the hash is
an array which is list of indexes of corresponding named captures.
</p>
<pre class="code">
   /(?&lt;foo&gt;.)(?&lt;bar&gt;.)/.named_captures
   #=&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}

   /(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.named_captures
   #=&gt; {&quot;foo&quot;=&gt;[1, 2]}
</pre>
<p>
If there are no named captures, an empty hash is returned.
</p>
<pre class="code">
   /(.)(.)/.named_captures
   #=&gt; {}</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    rxp.named_captures  -&gt; hash
 *
 * Returns a hash representing information about named captures of &lt;i&gt;rxp&lt;/i&gt;.
 *
 * A key of the hash is a name of the named captures.
 * A value of the hash is an array which is list of indexes of corresponding
 * named captures.
 *
 *    /(?&lt;foo&gt;.)(?&lt;bar&gt;.)/.named_captures
 *    #=&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}
 *
 *    /(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.named_captures
 *    #=&gt; {&quot;foo&quot;=&gt;[1, 2]}
 *
 * If there are no named captures, an empty hash is returned.
 *
 *    /(.)(.)/.named_captures
 *    #=&gt; {}
 */

static VALUE
rb_reg_named_captures(VALUE re)
{
    VALUE hash = rb_hash_new();
    rb_reg_check(re);
    onig_foreach_name(RREGEXP(re)-&gt;ptr, reg_named_captures_iter, (void*)hash);
    return hash;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="names-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>names</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a list of names of captures as an array of strings.
</p>
<pre class="code">
    /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.names
    #=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]

    /(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.names
    #=&gt; [&quot;foo&quot;]

    /(.)(.)/.names
    #=&gt; []</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 * call-seq:
 *    rxp.names   -&gt; [name1, name2, ...]
 *
 * Returns a list of names of captures as an array of strings.
 *
 *     /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.names
 *     #=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
 *
 *     /(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.names
 *     #=&gt; [&quot;foo&quot;]
 *
 *     /(.)(.)/.names
 *     #=&gt; []
 */

static VALUE
rb_reg_names(VALUE re)
{
    VALUE ary = rb_ary_new();
    rb_reg_check(re);
    onig_foreach_name(RREGEXP(re)-&gt;ptr, reg_names_iter, (void*)ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="options-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>options</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the set of bits corresponding to the options used when creating
this Regexp (see <tt>Regexp::new</tt> for details. Note that additional
bits may be set in the returned options: these are used internally by the
regular expression code. These extra bits are ignored if the options are
passed to <tt>Regexp::new</tt>.
</p>
<pre class="code">
   Regexp::IGNORECASE                  #=&gt; 1
   Regexp::EXTENDED                    #=&gt; 2
   Regexp::MULTILINE                   #=&gt; 4

   /cat/.options                       #=&gt; 0
   /cat/ix.options                     #=&gt; 3
   Regexp.new('cat', true).options     #=&gt; 1
   /\xa1\xa2/e.options                 #=&gt; 16

   r = /cat/ix
   Regexp.new(r.source, r.options)     #=&gt; /cat/ix</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp.options   -&gt; fixnum
 *
 *  Returns the set of bits corresponding to the options used when creating this
 *  Regexp (see &lt;code&gt;Regexp::new&lt;/code&gt; for details. Note that additional bits
 *  may be set in the returned options: these are used internally by the regular
 *  expression code. These extra bits are ignored if the options are passed to
 *  &lt;code&gt;Regexp::new&lt;/code&gt;.
 *
 *     Regexp::IGNORECASE                  #=&gt; 1
 *     Regexp::EXTENDED                    #=&gt; 2
 *     Regexp::MULTILINE                   #=&gt; 4
 *
 *     /cat/.options                       #=&gt; 0
 *     /cat/ix.options                     #=&gt; 3
 *     Regexp.new('cat', true).options     #=&gt; 1
 *     /\xa1\xa2/e.options                 #=&gt; 16
 *
 *     r = /cat/ix
 *     Regexp.new(r.source, r.options)     #=&gt; /cat/ix
 */

static VALUE
rb_reg_options_m(VALUE re)
{
    int options = rb_reg_options(re);
    return INT2NUM(options);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="source-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>source</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the original string of the pattern.
</p>
<pre class="code">
    /ab+c/ix.source #=&gt; &quot;ab+c&quot;
</pre>
<p>
Note that escape sequences are retained as is.
</p>
<pre class="code">
   /\x20\+/.source  #=&gt; &quot;\\x20\\+&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *      rxp.source   -&gt; str
 *
 *  Returns the original string of the pattern.
 *
 *      /ab+c/ix.source #=&gt; &quot;ab+c&quot;
 *
 *  Note that escape sequences are retained as is.
 *
 *     /\x20\+/.source  #=&gt; &quot;\\x20\\+&quot;
 *
 */

static VALUE
rb_reg_source(VALUE re)
{
    VALUE str;

    rb_reg_check(re);
    str = rb_enc_str_new(RREGEXP_SRC_PTR(re),RREGEXP_SRC_LEN(re), rb_enc_get(re));
    if (OBJ_TAINTED(re)) OBJ_TAINT(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_s-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a string containing the regular expression and its options (using
the <tt>(?opts:source)</tt> notation. This string can be fed back in to
<tt>Regexp::new</tt> to a regular expression with the same semantics as the
original. (However, <tt>Regexp#==</tt> may not return true when comparing
the two, as the source of the regular expression itself may differ, as the
example shows).  <tt>Regexp#inspect</tt> produces a generally more readable
version of <em>rxp</em>.
</p>
<pre class="code">
    r1 = /ab+c/ix           #=&gt; /ab+c/ix
    s1 = r1.to_s            #=&gt; &quot;(?ix-m:ab+c)&quot;
    r2 = Regexp.new(s1)     #=&gt; /(?ix-m:ab+c)/
    r1 == r2                #=&gt; false
    r1.source               #=&gt; &quot;ab+c&quot;
    r2.source               #=&gt; &quot;(?ix-m:ab+c)&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     rxp.to_s   -&gt; str
 *
 *  Returns a string containing the regular expression and its options (using the
 *  &lt;code&gt;(?opts:source)&lt;/code&gt; notation. This string can be fed back in to
 *  &lt;code&gt;Regexp::new&lt;/code&gt; to a regular expression with the same semantics as
 *  the original. (However, &lt;code&gt;Regexp#==&lt;/code&gt; may not return true when
 *  comparing the two, as the source of the regular expression itself may
 *  differ, as the example shows).  &lt;code&gt;Regexp#inspect&lt;/code&gt; produces a
 *  generally more readable version of &lt;i&gt;rxp&lt;/i&gt;.
 *
 *      r1 = /ab+c/ix           #=&gt; /ab+c/ix
 *      s1 = r1.to_s            #=&gt; &quot;(?ix-m:ab+c)&quot;
 *      r2 = Regexp.new(s1)     #=&gt; /(?ix-m:ab+c)/
 *      r1 == r2                #=&gt; false
 *      r1.source               #=&gt; &quot;ab+c&quot;
 *      r2.source               #=&gt; &quot;(?ix-m:ab+c)&quot;
 */

static VALUE
rb_reg_to_s(VALUE re)
{
    int options, opt;
    const int embeddable = ONIG_OPTION_MULTILINE|ONIG_OPTION_IGNORECASE|ONIG_OPTION_EXTEND;
    long len;
    const UChar* ptr;
    VALUE str = rb_str_buf_new2(&quot;(?&quot;);
    char optbuf[5];
    rb_encoding *enc = rb_enc_get(re);

    rb_reg_check(re);

    rb_enc_copy(str, re);
    options = RREGEXP(re)-&gt;ptr-&gt;options;
    ptr = (UChar*)RREGEXP_SRC_PTR(re);
    len = RREGEXP_SRC_LEN(re);
  again:
    if (len &gt;= 4 &amp;&amp; ptr[0] == '(' &amp;&amp; ptr[1] == '?') {
    int err = 1;
    ptr += 2;
    if ((len -= 2) &gt; 0) {
        do {
                opt = char_to_option((int )*ptr);
                if (opt != 0) {
                    options |= opt;
                }
                else {
                    break;
                }
        ++ptr;
        } while (--len &gt; 0);
    }
    if (len &gt; 1 &amp;&amp; *ptr == '-') {
        ++ptr;
        --len;
        do {
                opt = char_to_option((int )*ptr);
                if (opt != 0) {
                    options &amp;= ~opt;
                }
                else {
                    break;
                }
        ++ptr;
        } while (--len &gt; 0);
    }
    if (*ptr == ')') {
        --len;
        ++ptr;
        goto again;
    }
    if (*ptr == ':' &amp;&amp; ptr[len-1] == ')') {
        Regexp *rp;

        ++ptr;
        len -= 2;
            err = onig_new(&amp;rp, ptr, ptr + len, ONIG_OPTION_DEFAULT,
               enc, OnigDefaultSyntax, NULL);
        onig_free(rp);
    }
    if (err) {
        options = RREGEXP(re)-&gt;ptr-&gt;options;
        ptr = (UChar*)RREGEXP_SRC_PTR(re);
        len = RREGEXP_SRC_LEN(re);
    }
    }

    if (*option_to_str(optbuf, options)) rb_str_buf_cat2(str, optbuf);

    if ((options &amp; embeddable) != embeddable) {
    optbuf[0] = '-';
    option_to_str(optbuf + 1, ~options);
    rb_str_buf_cat2(str, optbuf);
    }

    rb_str_buf_cat2(str, &quot;:&quot;);
    rb_reg_expr_str(str, (char*)ptr, len, enc, NULL);
    rb_str_buf_cat2(str, &quot;)&quot;);
    rb_enc_copy(str, re);

    OBJ_INFECT(str, re);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="~-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>~</strong>(rxp) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Match--Matches <em>rxp</em> against the contents of <tt>$_</tt>.
Equivalent to <tt><em>rxp</em> =~ $_</tt>.
</p>
<pre class="code">
   $_ = &quot;input data&quot;
   ~ /at/   #=&gt; 7</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 're.c'</span>

/*
 *  call-seq:
 *     ~ rxp   -&gt; integer or nil
 *
 *  Match---Matches &lt;i&gt;rxp&lt;/i&gt; against the contents of &lt;code&gt;$_&lt;/code&gt;.
 *  Equivalent to &lt;code&gt;&lt;i&gt;rxp&lt;/i&gt; =~ $_&lt;/code&gt;.
 *
 *     $_ = &quot;input data&quot;
 *     ~ /at/   #=&gt; 7
 */

VALUE
rb_reg_match2(VALUE re)
{
    long start;
    VALUE line = rb_lastline_get();

    if (TYPE(line) != T_STRING) {
    rb_backref_set(Qnil);
    return Qnil;
    }

    start = rb_reg_search(re, line, 0, 0);
    if (start &lt; 0) {
    return Qnil;
    }
    start = rb_str_sublen(line, start);
    return LONG2FIX(start);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:05:57 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>