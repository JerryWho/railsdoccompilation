<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Proc</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (P)</a> &raquo; 
    
    
    <span class="title">Proc</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Proc
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Proc</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">proc.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
<tt>Proc</tt> objects are blocks of code that have been bound to a set of
local variables. Once bound, the code may be called in different contexts
and still access those variables.
</p>
<pre class="code">
   <span class='kw'>def</span> <span class='id gen_times'>gen_times</span><span class='lparen'>(</span><span class='id factor'>factor</span><span class='rparen'>)</span>
     <span class='kw'>return</span> <span class='const'>Proc</span><span class='period'>.</span><span class='id new'>new</span> <span class='lbrace'>{</span><span class='op'>|</span><span class='id n'>n</span><span class='op'>|</span> <span class='id n'>n</span><span class='op'>*</span><span class='id factor'>factor</span> <span class='rbrace'>}</span>
   <span class='kw'>end</span>

   <span class='id times3'>times3</span> <span class='op'>=</span> <span class='id gen_times'>gen_times</span><span class='lparen'>(</span><span class='int'>3</span><span class='rparen'>)</span>
   <span class='id times5'>times5</span> <span class='op'>=</span> <span class='id gen_times'>gen_times</span><span class='lparen'>(</span><span class='int'>5</span><span class='rparen'>)</span>

   <span class='id times3'>times3</span><span class='period'>.</span><span class='id call'>call</span><span class='lparen'>(</span><span class='int'>12</span><span class='rparen'>)</span>               <span class='comment'>#=&gt; 36
</span>   <span class='id times5'>times5</span><span class='period'>.</span><span class='id call'>call</span><span class='lparen'>(</span><span class='int'>5</span><span class='rparen'>)</span>                <span class='comment'>#=&gt; 25
</span>   <span class='id times3'>times3</span><span class='period'>.</span><span class='id call'>call</span><span class='lparen'>(</span><span class='id times5'>times5</span><span class='period'>.</span><span class='id call'>call</span><span class='lparen'>(</span><span class='int'>4</span><span class='rparen'>)</span><span class='rparen'>)</span>   <span class='comment'>#=&gt; 60</span></pre>


  </div>
</div>
<div class="tags">
  
</div>


  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#new-class_method" title="new (class method)">+ (Object) <strong>new</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates a new <tt>Proc</tt> object, bound to the current context.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Boolean) <strong>==</strong>(other_proc) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return <tt>true</tt> if <em>prc</em> is the same object as
<em>other_proc</em>, or if they are both procs with the same body.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D%3D-instance_method" title="#=== (instance method)">- (Object) <strong>===</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D%3D-instance_method" title="#=== (instance method)">- (Object) <strong>===</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#arity-instance_method" title="#arity (instance method)">- (Fixnum) <strong>arity</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the number of arguments that would not be ignored.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#binding-instance_method" title="#binding (instance method)">- (Binding) <strong>binding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the binding associated with <em>prc</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D%3D-instance_method" title="#=== (instance method)">- (Object) <strong>===</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clone-instance_method" title="#clone (instance method)">- (Object) <strong>clone</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#curry-instance_method" title="#curry (instance method)">- (Object) <strong>curry</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a curried proc.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dup-instance_method" title="#dup (instance method)">- (Object) <strong>dup</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Boolean) <strong>==</strong>(other_proc) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return <tt>true</tt> if <em>prc</em> is the same object as
<em>other_proc</em>, or if they are both procs with the same body.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hash-instance_method" title="#hash (instance method)">- (Integer) <strong>hash</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return hash value corresponding to proc body.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lambda%3F-instance_method" title="#lambda? (instance method)">- (Boolean) <strong>lambda?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for a Proc object which argument handling is rigid.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#parameters-instance_method" title="#parameters (instance method)">- (Array) <strong>parameters</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the parameter information of this proc.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#source_location-instance_method" title="#source_location (instance method)">- (Array) <strong>source_location</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the ruby source filename and line number containing this proc or
nil if this proc was not defined in ruby (i.e. native).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_proc-instance_method" title="#to_proc (instance method)">- (Proc) <strong>to_proc</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Part of the protocol for converting objects to <tt>Proc</tt> objects.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">- (String) <strong>to_s</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Shows the unique identifier for this proc, along with an indication of
where the proc was defined.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D%3D-instance_method" title="#=== (instance method)">- (Object) <strong>===</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.
</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="new-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>new</strong> {|...| ... }</span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>new</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates a new <tt>Proc</tt> object, bound to the current context.
<tt>Proc::new</tt> may be called without a block only within a method with
an attached block, in which case that block is converted to the
<tt>Proc</tt> object.
</p>
<pre class="code">
   def proc_from
     Proc.new
   end
   proc = proc_from { &quot;hello&quot; }
   proc.call   #=&gt; &quot;hello&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>new</strong> {|...| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>...</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>new</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     Proc.new {|...| block } -&gt; a_proc
 *     Proc.new                -&gt; a_proc
 *
 *  Creates a new &lt;code&gt;Proc&lt;/code&gt; object, bound to the current
 *  context. &lt;code&gt;Proc::new&lt;/code&gt; may be called without a block only
 *  within a method with an attached block, in which case that block is
 *  converted to the &lt;code&gt;Proc&lt;/code&gt; object.
 *
 *     def proc_from
 *       Proc.new
 *     end
 *     proc = proc_from { &quot;hello&quot; }
 *     proc.call   #=&gt; &quot;hello&quot;
 */

static VALUE
rb_proc_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE block = proc_new(klass, FALSE);

    rb_obj_call_init(block, argc, argv);
    return block;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="==-instance_method">
  
    - (<tt>Boolean</tt>) <strong>==</strong>(other_proc) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return <tt>true</tt> if <em>prc</em> is the same object as
<em>other_proc</em>, or if they are both procs with the same body.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 * call-seq:
 *   prc == other_proc   -&gt;  true or false
 *
 * Return &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;prc&lt;/i&gt; is the same object as
 * &lt;i&gt;other_proc&lt;/i&gt;, or if they are both procs with the same body.
 */

static VALUE
proc_eq(VALUE self, VALUE other)
{
    if (self == other) {
    return Qtrue;
    }
    else {
    if (rb_obj_is_proc(other)) {
        rb_proc_t *p1, *p2;
        GetProcPtr(self, p1);
        GetProcPtr(other, p2);
        if (p1-&gt;envval == p2-&gt;envval &amp;&amp;
        p1-&gt;block.iseq-&gt;iseq_size == p2-&gt;block.iseq-&gt;iseq_size &amp;&amp;
        p1-&gt;block.iseq-&gt;local_size == p2-&gt;block.iseq-&gt;local_size &amp;&amp;
        MEMCMP(p1-&gt;block.iseq-&gt;iseq, p2-&gt;block.iseq-&gt;iseq, VALUE,
               p1-&gt;block.iseq-&gt;iseq_size) == 0) {
        return Qtrue;
        }
    }
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="===-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>===</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.  It is
to allow a proc object to be a target of <tt>when</tt> clause in the case
statement.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     prc === obj   -&gt; result_of_proc
 *
 *  Invokes the block, with &lt;i&gt;obj&lt;/i&gt; as the block's parameter.  It is
 *  to allow a proc object to be a target of +when+ clause in the case statement.
 */

static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    rb_proc_t *proc;
    rb_block_t *blockptr = 0;
    rb_iseq_t *iseq;
    GetProcPtr(procval, proc);

    iseq = proc-&gt;block.iseq;
    if (BUILTIN_TYPE(iseq) == T_NODE || iseq-&gt;arg_block != -1) {
    if (rb_block_given_p()) {
        rb_proc_t *proc;
        VALUE procval;
        procval = rb_block_proc();
        GetProcPtr(procval, proc);
        blockptr = &amp;proc-&gt;block;
    }
    }

    return rb_vm_invoke_proc(GET_THREAD(), proc, proc-&gt;block.self,
                 argc, argv, blockptr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>===</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.  It is
to allow a proc object to be a target of <tt>when</tt> clause in the case
statement.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     prc === obj   -&gt; result_of_proc
 *
 *  Invokes the block, with &lt;i&gt;obj&lt;/i&gt; as the block's parameter.  It is
 *  to allow a proc object to be a target of +when+ clause in the case statement.
 */

static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    rb_proc_t *proc;
    rb_block_t *blockptr = 0;
    rb_iseq_t *iseq;
    GetProcPtr(procval, proc);

    iseq = proc-&gt;block.iseq;
    if (BUILTIN_TYPE(iseq) == T_NODE || iseq-&gt;arg_block != -1) {
    if (rb_block_given_p()) {
        rb_proc_t *proc;
        VALUE procval;
        procval = rb_block_proc();
        GetProcPtr(procval, proc);
        blockptr = &amp;proc-&gt;block;
    }
    }

    return rb_vm_invoke_proc(GET_THREAD(), proc, proc-&gt;block.self,
                 argc, argv, blockptr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="arity-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>arity</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the number of arguments that would not be ignored. If the block is
declared to take no arguments, returns 0. If the block is known to take
exactly n arguments, returns n. If the block has optional arguments, return
-n-1, where n is the number of mandatory arguments. A <tt>proc</tt> with no
argument declarations is the same a block declaring <tt>||</tt> as its
arguments.
</p>
<pre class="code">
   Proc.new {}.arity          #=&gt;  0
   Proc.new {||}.arity        #=&gt;  0
   Proc.new {|a|}.arity       #=&gt;  1
   Proc.new {|a,b|}.arity     #=&gt;  2
   Proc.new {|a,b,c|}.arity   #=&gt;  3
   Proc.new {|*a|}.arity      #=&gt; -1
   Proc.new {|a,*b|}.arity    #=&gt; -2
   Proc.new {|a,*b, c|}.arity    #=&gt; -3</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     prc.arity -&gt; fixnum
 *
 *  Returns the number of arguments that would not be ignored. If the block
 *  is declared to take no arguments, returns 0. If the block is known
 *  to take exactly n arguments, returns n. If the block has optional
 *  arguments, return -n-1, where n is the number of mandatory
 *  arguments. A &lt;code&gt;proc&lt;/code&gt; with no argument declarations
 *  is the same a block declaring &lt;code&gt;||&lt;/code&gt; as its arguments.
 *
 *     Proc.new {}.arity          #=&gt;  0
 *     Proc.new {||}.arity        #=&gt;  0
 *     Proc.new {|a|}.arity       #=&gt;  1
 *     Proc.new {|a,b|}.arity     #=&gt;  2
 *     Proc.new {|a,b,c|}.arity   #=&gt;  3
 *     Proc.new {|*a|}.arity      #=&gt; -1
 *     Proc.new {|a,*b|}.arity    #=&gt; -2
 *     Proc.new {|a,*b, c|}.arity    #=&gt; -3
 */

static VALUE
proc_arity(VALUE self)
{
    int arity = rb_proc_arity(self);
    return INT2FIX(arity);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="binding-instance_method">
  
    - (<tt><span class='object_link'><a href="Binding.html" title="Binding (class)">Binding</a></span></tt>) <strong>binding</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the binding associated with <em>prc</em>. Note that
<tt>Kernel#eval</tt> accepts either a <tt>Proc</tt> or a <tt>Binding</tt>
object as its second parameter.
</p>
<pre class="code">
   def fred(param)
     proc {}
   end

   b = fred(99)
   eval(&quot;param&quot;, b.binding)   #=&gt; 99</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Binding.html" title="Binding (class)">Binding</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     prc.binding    -&gt; binding
 *
 *  Returns the binding associated with &lt;i&gt;prc&lt;/i&gt;. Note that
 *  &lt;code&gt;Kernel#eval&lt;/code&gt; accepts either a &lt;code&gt;Proc&lt;/code&gt; or a
 *  &lt;code&gt;Binding&lt;/code&gt; object as its second parameter.
 *
 *     def fred(param)
 *       proc {}
 *     end
 *
 *     b = fred(99)
 *     eval(&quot;param&quot;, b.binding)   #=&gt; 99
 */
static VALUE
proc_binding(VALUE self)
{
    rb_proc_t *proc;
    VALUE bindval;
    rb_binding_t *bind;

    GetProcPtr(self, proc);
    if (TYPE(proc-&gt;block.iseq) == T_NODE) {
    if (!IS_METHOD_PROC_NODE((NODE *)proc-&gt;block.iseq)) {
        rb_raise(rb_eArgError, &quot;Can't create Binding from C level Proc&quot;);
    }
    }

    bindval = binding_alloc(rb_cBinding);
    GetBindingPtr(bindval, bind);
    bind-&gt;env = proc-&gt;envval;
    if (RUBY_VM_NORMAL_ISEQ_P(proc-&gt;block.iseq)) {
    bind-&gt;filename = proc-&gt;block.iseq-&gt;filename;
    bind-&gt;line_no = rb_iseq_first_lineno(proc-&gt;block.iseq);
    }
    else {
    bind-&gt;filename = Qnil;
    bind-&gt;line_no = 0;
    }
    return bindval;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="call-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>===</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.  It is
to allow a proc object to be a target of <tt>when</tt> clause in the case
statement.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     prc === obj   -&gt; result_of_proc
 *
 *  Invokes the block, with &lt;i&gt;obj&lt;/i&gt; as the block's parameter.  It is
 *  to allow a proc object to be a target of +when+ clause in the case statement.
 */

static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    rb_proc_t *proc;
    rb_block_t *blockptr = 0;
    rb_iseq_t *iseq;
    GetProcPtr(procval, proc);

    iseq = proc-&gt;block.iseq;
    if (BUILTIN_TYPE(iseq) == T_NODE || iseq-&gt;arg_block != -1) {
    if (rb_block_given_p()) {
        rb_proc_t *proc;
        VALUE procval;
        procval = rb_block_proc();
        GetProcPtr(procval, proc);
        blockptr = &amp;proc-&gt;block;
    }
    }

    return rb_vm_invoke_proc(GET_THREAD(), proc, proc-&gt;block.self,
                 argc, argv, blockptr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="clone-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>clone</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/* :nodoc: */
static VALUE
proc_clone(VALUE self)
{
    VALUE procval = proc_dup(self);
    CLONESETUP(procval, self);
    return procval;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="curry-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>curry</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>curry</strong>(arity) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a curried proc. If the optional <em>arity</em> argument is given,
it determines the number of arguments. A curried proc receives some
arguments. If a sufficient number of arguments are supplied, it passes the
supplied arguments to the original proc and returns the result. Otherwise,
returns another curried proc that takes the rest of arguments.
</p>
<pre class="code">
   b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
   p b.curry[1][2][3]           #=&gt; 6
   p b.curry[1, 2][3, 4]        #=&gt; 6
   p b.curry(5)[1][2][3][4][5]  #=&gt; 6
   p b.curry(5)[1, 2][3, 4][5]  #=&gt; 6
   p b.curry(1)[1]              #=&gt; 1

   b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
   p b.curry[1][2][3]           #=&gt; 6
   p b.curry[1, 2][3, 4]        #=&gt; 10
   p b.curry(5)[1][2][3][4][5]  #=&gt; 15
   p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
   p b.curry(1)[1]              #=&gt; 1

   b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
   p b.curry[1][2][3]           #=&gt; 6
   p b.curry[1, 2][3, 4]        #=&gt; wrong number of arguments (4 for 3)
   p b.curry(5)                 #=&gt; wrong number of arguments (5 for 3)
   p b.curry(1)                 #=&gt; wrong number of arguments (1 for 3)

   b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
   p b.curry[1][2][3]           #=&gt; 6
   p b.curry[1, 2][3, 4]        #=&gt; 10
   p b.curry(5)[1][2][3][4][5]  #=&gt; 15
   p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
   p b.curry(1)                 #=&gt; wrong number of arguments (1 for 3)

   b = proc { :foo }
   p b.curry[]                  #=&gt; :foo</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>curry</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>curry</strong>(arity) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
  *  call-seq:
  *     prc.curry         -&gt; a_proc
  *     prc.curry(arity)  -&gt; a_proc
  *
  *  Returns a curried proc. If the optional &lt;i&gt;arity&lt;/i&gt; argument is given,
  *  it determines the number of arguments.
  *  A curried proc receives some arguments. If a sufficient number of
  *  arguments are supplied, it passes the supplied arguments to the original
  *  proc and returns the result. Otherwise, returns another curried proc that
  *  takes the rest of arguments.
  *
  *     b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
  *     p b.curry[1][2][3]           #=&gt; 6
  *     p b.curry[1, 2][3, 4]        #=&gt; 6
  *     p b.curry(5)[1][2][3][4][5]  #=&gt; 6
  *     p b.curry(5)[1, 2][3, 4][5]  #=&gt; 6
  *     p b.curry(1)[1]              #=&gt; 1
  *
  *     b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
  *     p b.curry[1][2][3]           #=&gt; 6
  *     p b.curry[1, 2][3, 4]        #=&gt; 10
  *     p b.curry(5)[1][2][3][4][5]  #=&gt; 15
  *     p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
  *     p b.curry(1)[1]              #=&gt; 1
  *
  *     b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
  *     p b.curry[1][2][3]           #=&gt; 6
  *     p b.curry[1, 2][3, 4]        #=&gt; wrong number of arguments (4 for 3)
  *     p b.curry(5)                 #=&gt; wrong number of arguments (5 for 3)
  *     p b.curry(1)                 #=&gt; wrong number of arguments (1 for 3)
  *
  *     b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
  *     p b.curry[1][2][3]           #=&gt; 6
  *     p b.curry[1, 2][3, 4]        #=&gt; 10
  *     p b.curry(5)[1][2][3][4][5]  #=&gt; 15
  *     p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
  *     p b.curry(1)                 #=&gt; wrong number of arguments (1 for 3)
  *
  *     b = proc { :foo }
  *     p b.curry[]                  #=&gt; :foo
  */
static VALUE
proc_curry(int argc, VALUE *argv, VALUE self)
{
    int sarity, marity = rb_proc_arity(self);
    VALUE arity, opt = Qfalse;

    if (marity &lt; 0) {
    marity = -marity - 1;
    opt = Qtrue;
    }

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;arity);
    if (NIL_P(arity)) {
    arity = INT2FIX(marity);
    }
    else {
    sarity = FIX2INT(arity);
    if (rb_proc_lambda_p(self) &amp;&amp; (sarity &lt; marity || (sarity &gt; marity &amp;&amp; !opt))) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for %d)&quot;, sarity, marity);
    }
    }

    return make_curry_proc(self, rb_ary_new(), arity);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="dup-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>dup</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/* :nodoc: */
static VALUE
proc_dup(VALUE self)
{
    VALUE procval = rb_proc_alloc(rb_cProc);
    rb_proc_t *src, *dst;
    GetProcPtr(self, src);
    GetProcPtr(procval, dst);

    dst-&gt;block = src-&gt;block;
    dst-&gt;block.proc = procval;
    dst-&gt;blockprocval = src-&gt;blockprocval;
    dst-&gt;envval = src-&gt;envval;
    dst-&gt;safe_level = src-&gt;safe_level;
    dst-&gt;is_lambda = src-&gt;is_lambda;

    return procval;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eql?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>==</strong>(other_proc) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return <tt>true</tt> if <em>prc</em> is the same object as
<em>other_proc</em>, or if they are both procs with the same body.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 * call-seq:
 *   prc == other_proc   -&gt;  true or false
 *
 * Return &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;prc&lt;/i&gt; is the same object as
 * &lt;i&gt;other_proc&lt;/i&gt;, or if they are both procs with the same body.
 */

static VALUE
proc_eq(VALUE self, VALUE other)
{
    if (self == other) {
    return Qtrue;
    }
    else {
    if (rb_obj_is_proc(other)) {
        rb_proc_t *p1, *p2;
        GetProcPtr(self, p1);
        GetProcPtr(other, p2);
        if (p1-&gt;envval == p2-&gt;envval &amp;&amp;
        p1-&gt;block.iseq-&gt;iseq_size == p2-&gt;block.iseq-&gt;iseq_size &amp;&amp;
        p1-&gt;block.iseq-&gt;local_size == p2-&gt;block.iseq-&gt;local_size &amp;&amp;
        MEMCMP(p1-&gt;block.iseq-&gt;iseq, p2-&gt;block.iseq-&gt;iseq, VALUE,
               p1-&gt;block.iseq-&gt;iseq_size) == 0) {
        return Qtrue;
        }
    }
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="hash-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>hash</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return hash value corresponding to proc body.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 * call-seq:
 *   prc.hash   -&gt;  integer
 *
 * Return hash value corresponding to proc body.
 */

static VALUE
proc_hash(VALUE self)
{
    st_index_t hash;
    rb_proc_t *proc;
    GetProcPtr(self, proc);
    hash = rb_hash_start((st_index_t)proc-&gt;block.iseq);
    hash = rb_hash_uint(hash, (st_index_t)proc-&gt;envval);
    hash = rb_hash_uint(hash, (st_index_t)proc-&gt;block.lfp &gt;&gt; 16);
    hash = rb_hash_end(hash);
    return LONG2FIX(hash);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lambda?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>lambda?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for a Proc object which argument handling is rigid. Such procs
are typically generated by lambda.
</p>
<p>
A Proc object generated by proc ignore extra arguments.
</p>
<pre class="code">
  proc {|a,b| [a,b] }.call(1,2,3)    #=&gt; [1,2]
</pre>
<p>
It provides nil for lacked arguments.
</p>
<pre class="code">
  proc {|a,b| [a,b] }.call(1)        #=&gt; [1,nil]
</pre>
<p>
It expand single-array argument.
</p>
<pre class="code">
  proc {|a,b| [a,b] }.call([1,2])    #=&gt; [1,2]
</pre>
<p>
A Proc object generated by lambda doesn&#8217;t have such tricks.
</p>
<pre class="code">
  lambda {|a,b| [a,b] }.call(1,2,3)  #=&gt; ArgumentError
  lambda {|a,b| [a,b] }.call(1)      #=&gt; ArgumentError
  lambda {|a,b| [a,b] }.call([1,2])  #=&gt; ArgumentError
</pre>
<p>
Proc#lambda? is a predicate for the tricks. It returns true if no tricks.
</p>
<pre class="code">
  lambda {}.lambda?            #=&gt; true
  proc {}.lambda?              #=&gt; false
</pre>
<p>
Proc.new is same as proc.
</p>
<pre class="code">
  Proc.new {}.lambda?          #=&gt; false
</pre>
<p>
lambda, proc and Proc.new preserves the tricks of a Proc object given by
&amp; argument.
</p>
<pre class="code">
  lambda(&amp;lambda {}).lambda?   #=&gt; true
  proc(&amp;lambda {}).lambda?     #=&gt; true
  Proc.new(&amp;lambda {}).lambda? #=&gt; true

  lambda(&amp;proc {}).lambda?     #=&gt; false
  proc(&amp;proc {}).lambda?       #=&gt; false
  Proc.new(&amp;proc {}).lambda?   #=&gt; false
</pre>
<p>
A Proc object generated by &amp; argument has the tricks
</p>
<pre class="code">
  def n(&amp;b) b.lambda? end
  n {}                         #=&gt; false
</pre>
<p>
The &amp; argument preserves the tricks if a Proc object is given by &amp;
argument.
</p>
<pre class="code">
  n(&amp;lambda {})                #=&gt; true
  n(&amp;proc {})                  #=&gt; false
  n(&amp;Proc.new {})              #=&gt; false
</pre>
<p>
A Proc object converted from a method has no tricks.
</p>
<pre class="code">
  def m() end
  method(:m).to_proc.lambda?   #=&gt; true

  n(&amp;method(:m))               #=&gt; true
  n(&amp;method(:m).to_proc)       #=&gt; true
</pre>
<p>
define_method is treated same as method definition. The defined method has
no tricks.
</p>
<pre class="code">
  class C
    define_method(:d) {}
  end
  C.new.e(1,2)       #=&gt; ArgumentError
  C.new.method(:d).to_proc.lambda?   #=&gt; true
</pre>
<p>
define_method always defines a method without the tricks, even if a
non-lambda Proc object is given. This is the only exception which the
tricks are not preserved.
</p>
<pre class="code">
  class C
    define_method(:e, &amp;proc {})
  end
  C.new.e(1,2)       #=&gt; ArgumentError
  C.new.method(:e).to_proc.lambda?   #=&gt; true
</pre>
<p>
This exception is for a wrapper of define_method. It eases defining a
method defining method which defines a usual method which has no tricks.
</p>
<pre class="code">
  class &lt;&lt; C
    def def2(name, &amp;body)
      define_method(name, &amp;body)
    end
  end
  class C
    def2(:f) {}
  end
  C.new.f(1,2)       #=&gt; ArgumentError
</pre>
<p>
The wrapper, def2, defines a method which has no tricks.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 * call-seq:
 *   prc.lambda? -&gt; true or false
 *
 * Returns true for a Proc object which argument handling is rigid.
 * Such procs are typically generated by lambda.
 *
 * A Proc object generated by proc ignore extra arguments.
 *
 *   proc {|a,b| [a,b] }.call(1,2,3)    #=&gt; [1,2]
 *
 * It provides nil for lacked arguments.
 *
 *   proc {|a,b| [a,b] }.call(1)        #=&gt; [1,nil]
 *
 * It expand single-array argument.
 *
 *   proc {|a,b| [a,b] }.call([1,2])    #=&gt; [1,2]
 *
 * A Proc object generated by lambda doesn't have such tricks.
 *
 *   lambda {|a,b| [a,b] }.call(1,2,3)  #=&gt; ArgumentError
 *   lambda {|a,b| [a,b] }.call(1)      #=&gt; ArgumentError
 *   lambda {|a,b| [a,b] }.call([1,2])  #=&gt; ArgumentError
 *
 * Proc#lambda? is a predicate for the tricks.
 * It returns true if no tricks.
 *
 *   lambda {}.lambda?            #=&gt; true
 *   proc {}.lambda?              #=&gt; false
 *
 * Proc.new is same as proc.
 *
 *   Proc.new {}.lambda?          #=&gt; false
 *
 * lambda, proc and Proc.new preserves the tricks of
 * a Proc object given by &amp; argument.
 *
 *   lambda(&amp;lambda {}).lambda?   #=&gt; true
 *   proc(&amp;lambda {}).lambda?     #=&gt; true
 *   Proc.new(&amp;lambda {}).lambda? #=&gt; true
 *
 *   lambda(&amp;proc {}).lambda?     #=&gt; false
 *   proc(&amp;proc {}).lambda?       #=&gt; false
 *   Proc.new(&amp;proc {}).lambda?   #=&gt; false
 *
 * A Proc object generated by &amp; argument has the tricks
 *
 *   def n(&amp;b) b.lambda? end
 *   n {}                         #=&gt; false
 *
 * The &amp; argument preserves the tricks if a Proc object is given
 * by &amp; argument.
 *
 *   n(&amp;lambda {})                #=&gt; true
 *   n(&amp;proc {})                  #=&gt; false
 *   n(&amp;Proc.new {})              #=&gt; false
 *
 * A Proc object converted from a method has no tricks.
 *
 *   def m() end
 *   method(:m).to_proc.lambda?   #=&gt; true
 *
 *   n(&amp;method(:m))               #=&gt; true
 *   n(&amp;method(:m).to_proc)       #=&gt; true
 *
 * define_method is treated same as method definition.
 * The defined method has no tricks.
 *
 *   class C
 *     define_method(:d) {}
 *   end
 *   C.new.e(1,2)       #=&gt; ArgumentError
 *   C.new.method(:d).to_proc.lambda?   #=&gt; true
 *
 * define_method always defines a method without the tricks,
 * even if a non-lambda Proc object is given.
 * This is the only exception which the tricks are not preserved.
 *
 *   class C
 *     define_method(:e, &amp;proc {})
 *   end
 *   C.new.e(1,2)       #=&gt; ArgumentError
 *   C.new.method(:e).to_proc.lambda?   #=&gt; true
 *
 * This exception is for a wrapper of define_method.
 * It eases defining a method defining method which defines a usual method which has no tricks.
 *
 *   class &lt;&lt; C
 *     def def2(name, &amp;body)
 *       define_method(name, &amp;body)
 *     end
 *   end
 *   class C
 *     def2(:f) {}
 *   end
 *   C.new.f(1,2)       #=&gt; ArgumentError
 *
 * The wrapper, def2, defines a method which has no tricks.
 *
 */

VALUE
rb_proc_lambda_p(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    return proc-&gt;is_lambda ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="parameters-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>parameters</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the parameter information of this proc.
</p>
<pre class="code">
   prc = lambda{|x, y=42, *rest|}
   prc.parameters  #=&gt; [[:req, :x], [:opt, :y], [:rest, :rest]]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 * call-seq:
 *    proc.parameters  -&gt; array
 *
 * returns the parameter information of this proc.
 *
 *    prc = lambda{|x, y=42, *rest|}
 *    prc.parameters  #=&gt; [[:req, :x], [:opt, :y], [:rest, :rest]]
 */

static VALUE
rb_proc_parameters(VALUE self)
{
    int is_proc;
    rb_iseq_t *iseq = get_proc_iseq(self, &amp;is_proc);
    if (!iseq) {
    return unnamed_parameters(rb_proc_arity(self));
    }
    return rb_iseq_parameters(iseq, is_proc);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="source_location-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>source_location</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the ruby source filename and line number containing this proc or
nil if this proc was not defined in ruby (i.e. native)
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 * call-seq:
 *    prc.source_location  -&gt; [String, Fixnum]
 *
 * returns the ruby source filename and line number containing this proc
 * or nil if this proc was not defined in ruby (i.e. native)
 */

VALUE
rb_proc_location(VALUE self)
{
    return iseq_location(get_proc_iseq(self, 0));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_proc-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>) <strong>to_proc</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Part of the protocol for converting objects to <tt>Proc</tt> objects.
Instances of class <tt>Proc</tt> simply return themselves.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Proc (class)">Proc</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     prc.to_proc -&gt; prc
 *
 *  Part of the protocol for converting objects to &lt;code&gt;Proc&lt;/code&gt;
 *  objects. Instances of class &lt;code&gt;Proc&lt;/code&gt; simply return
 *  themselves.
 */

static VALUE
proc_to_proc(VALUE self)
{
    return self;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_s-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>to_s</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Shows the unique identifier for this proc, along with an indication of
where the proc was defined.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 * call-seq:
 *   prc.to_s   -&gt; string
 *
 * Shows the unique identifier for this proc, along with
 * an indication of where the proc was defined.
 */

static VALUE
proc_to_s(VALUE self)
{
    VALUE str = 0;
    rb_proc_t *proc;
    const char *cname = rb_obj_classname(self);
    rb_iseq_t *iseq;
    const char *is_lambda;

    GetProcPtr(self, proc);
    iseq = proc-&gt;block.iseq;
    is_lambda = proc-&gt;is_lambda ? &quot; (lambda)&quot; : &quot;&quot;;

    if (RUBY_VM_NORMAL_ISEQ_P(iseq)) {
    int line_no = 0;

    if (iseq-&gt;insn_info_table) {
        line_no = rb_iseq_first_lineno(iseq);
    }
    str = rb_sprintf(&quot;#&lt;%s:%p@%s:%d%s&gt;&quot;, cname, (void *)self,
             RSTRING_PTR(iseq-&gt;filename),
             line_no, is_lambda);
    }
    else {
    str = rb_sprintf(&quot;#&lt;%s:%p%s&gt;&quot;, cname, (void *)proc-&gt;block.iseq,
             is_lambda);
    }

    if (OBJ_TAINTED(self)) {
    OBJ_TAINT(str);
    }
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="yield-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>===</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Invokes the block, with <em>obj</em> as the block&#8217;s parameter.  It is
to allow a proc object to be a target of <tt>when</tt> clause in the case
statement.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'proc.c'</span>

/*
 *  call-seq:
 *     prc === obj   -&gt; result_of_proc
 *
 *  Invokes the block, with &lt;i&gt;obj&lt;/i&gt; as the block's parameter.  It is
 *  to allow a proc object to be a target of +when+ clause in the case statement.
 */

static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    rb_proc_t *proc;
    rb_block_t *blockptr = 0;
    rb_iseq_t *iseq;
    GetProcPtr(procval, proc);

    iseq = proc-&gt;block.iseq;
    if (BUILTIN_TYPE(iseq) == T_NODE || iseq-&gt;arg_block != -1) {
    if (rb_block_given_p()) {
        rb_proc_t *proc;
        VALUE procval;
        procval = rb_block_proc();
        GetProcPtr(procval, proc);
        blockptr = &amp;proc-&gt;block;
    }
    }

    return rb_vm_invoke_proc(GET_THREAD(), proc, proc-&gt;block.self,
                 argc, argv, blockptr);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:06:00 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>