<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: String</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (S)</a> &raquo; 
    
    
    <span class="title">String</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: String
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">String</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
      <dt class="r2">Includes:</dt>
      <dd class="r2"><span class='object_link'><a href="Comparable.html" title="Comparable (module)">Comparable</a></span></dd>
      
    
  
  
  
    <dt class="r1 last">Defined in:</dt>
    <dd class="r1 last">string.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
A <tt>String</tt> object holds and manipulates an arbitrary sequence of
bytes, typically representing characters. String objects may be created
using <tt>String::new</tt> or as literals.
</p>
<p>
Because of aliasing issues, users of strings should be aware of the methods
that modify the contents of a <tt>String</tt> object.  Typically, methods
with names ending in ``!&#8217;&#8217; modify their receiver, while those
without a ``!&#8217;&#8217; return a new <tt>String</tt>.  However, there
are exceptions, such as <tt>String#[]=</tt>.
</p>


  </div>
</div>
<div class="tags">
  
</div>

  
  
  
  

  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_convert-class_method" title="try_convert (class method)">+ (String<sup>?</sup>) <strong>try_convert</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Try to convert <em>obj</em> into a String, using to_str method.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%25-instance_method" title="#% (instance method)">- (String) <strong>%</strong>(arg) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Format--Uses <em>str</em> as a format specification, and returns the
result of applying it to <em>arg</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2A-instance_method" title="#* (instance method)">- (String) <strong>*</strong>(integer) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Copy--Returns a new <tt>String</tt> containing <em>integer</em> copies
of the receiver.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%2B-instance_method" title="#+ (instance method)">- (String) <strong>+</strong>(other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Concatenation--Returns a new <tt>String</tt> containing
<em>other_str</em> concatenated to <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3C-instance_method" title="#&lt;&lt; (instance method)">- (Object) <strong>&lt;&lt;</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Append--Concatenates the given object to <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3D%3E-instance_method" title="#&lt;=&gt; (instance method)">- (-1, ...) <strong>&lt;=&gt;</strong>(other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Comparison--Returns -1 if <em>other_str</em> is greater than, 0 if
<em>other_str</em> is equal to, and +1 if <em>other_str</em> is less than
<em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Boolean) <strong>==</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equality--If <em>obj</em> is not a <tt>String</tt>, returns
<tt>false</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%3D-instance_method" title="#== (instance method)">- (Boolean) <strong>==</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equality--If <em>obj</em> is not a <tt>String</tt>, returns
<tt>false</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3D%7E-instance_method" title="#=~ (instance method)">- (Fixnum<sup>?</sup>) <strong>=~</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Match--If <em>obj</em> is a <tt>Regexp</tt>, use it as a pattern to
match against <em>str</em>,and returns the position the match starts, or
<tt>nil</tt> if there is no match.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D-instance_method" title="#[] (instance method)">- (Object) <strong>[]</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Element Reference--If passed a single <tt>Fixnum</tt>, returns a
substring of one character at that position.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%5B%5D%3D-instance_method" title="#[]= (instance method)">- (Object) <strong>[]=</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Element Assignment--Replaces some or all of the content of
<em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ascii_only%3F-instance_method" title="#ascii_only? (instance method)">- (Boolean) <strong>ascii_only?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for a string which has only ASCII characters.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bytes-instance_method" title="#bytes (instance method)">- (Object) <strong>bytes</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.each_byte {|fixnum| block }    -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bytesize-instance_method" title="#bytesize (instance method)">- (Integer) <strong>bytesize</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the length of <em>str</em> in bytes.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#capitalize-instance_method" title="#capitalize (instance method)">- (String) <strong>capitalize</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with the first character converted to
uppercase and the remainder to lowercase.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#capitalize%21-instance_method" title="#capitalize! (instance method)">- (String<sup>?</sup>) <strong>capitalize!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Modifies <em>str</em> by converting the first character to uppercase and
the remainder to lowercase.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#casecmp-instance_method" title="#casecmp (instance method)">- (-1, ...) <strong>casecmp</strong>(other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Case-insensitive version of <tt>String#&lt;=&gt;</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#center-instance_method" title="#center (instance method)">- (String) <strong>center</strong>(integer, padstr) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt>String</tt> of length <em>integer</em> with <em>str</em> centered
and padded with <em>padstr</em>; otherwise, returns <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chars-instance_method" title="#chars (instance method)">- (Object) <strong>chars</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.each_char {|cstr| block }    -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chomp-instance_method" title="#chomp (instance method)">- (String) <strong>chomp</strong>(separator = $/) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new <tt>String</tt> with the given record separator removed from
the end of <em>str</em> (if present).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chomp%21-instance_method" title="#chomp! (instance method)">- (String<sup>?</sup>) <strong>chomp!</strong>(separator = $/) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Modifies <em>str</em> in place as described for <tt>String#chomp</tt>,
returning <em>str</em>, or <tt>nil</tt> if no modifications were made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chop-instance_method" title="#chop (instance method)">- (String) <strong>chop</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new <tt>String</tt> with the last character removed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chop%21-instance_method" title="#chop! (instance method)">- (String<sup>?</sup>) <strong>chop!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Processes <em>str</em> as for <tt>String#chop</tt>, returning <em>str</em>,
or <tt>nil</tt> if <em>str</em> is the empty string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chr-instance_method" title="#chr (instance method)">- (String) <strong>chr</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a one-character string at the beginning of the string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#clear-instance_method" title="#clear (instance method)">- (String) <strong>clear</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Makes string empty.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#codepoints-instance_method" title="#codepoints (instance method)">- (Object) <strong>codepoints</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.each_codepoint {|integer| block }    -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#concat-instance_method" title="#concat (instance method)">- (Object) <strong>concat</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Append--Concatenates the given object to <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#count-instance_method" title="#count (instance method)">- (Fixnum) <strong>count</strong>([other_str]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Each <em>other_str</em> parameter defines a set of characters to count.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#crypt-instance_method" title="#crypt (instance method)">- (String) <strong>crypt</strong>(other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Applies a one-way cryptographic hash to <em>str</em> by invoking the
standard library function <tt>crypt</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#delete-instance_method" title="#delete (instance method)">- (String) <strong>delete</strong>([other_str]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with all characters in the intersection of
its arguments deleted.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#delete%21-instance_method" title="#delete! (instance method)">- (String<sup>?</sup>) <strong>delete!</strong>([other_str]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Performs a <tt>delete</tt> operation in place, returning <em>str</em>, or
<tt>nil</tt> if <em>str</em> was not modified.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#downcase-instance_method" title="#downcase (instance method)">- (String) <strong>downcase</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with all uppercase letters replaced with
their lowercase counterparts.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#downcase%21-instance_method" title="#downcase! (instance method)">- (String<sup>?</sup>) <strong>downcase!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Downcases the contents of <em>str</em>, returning <tt>nil</tt> if no
changes were made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#dump-instance_method" title="#dump (instance method)">- (String) <strong>dump</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Produces a version of <em>str</em> with all nonprinting characters replaced
by <tt>\nnn</tt> notation and all special characters escaped.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_byte-instance_method" title="#each_byte (instance method)">- (Object) <strong>each_byte</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.each_byte {|fixnum| block }    -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_char-instance_method" title="#each_char (instance method)">- (Object) <strong>each_char</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.each_char {|cstr| block }    -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_codepoint-instance_method" title="#each_codepoint (instance method)">- (Object) <strong>each_codepoint</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.each_codepoint {|integer| block }    -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_line-instance_method" title="#each_line (instance method)">- (Object) <strong>each_line</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.lines(separator=$/) {|substr| block }       -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#empty%3F-instance_method" title="#empty? (instance method)">- (Boolean) <strong>empty?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <em>str</em> has a length of zero.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encode-instance_method" title="#encode (instance method)">- (Object) <strong>encode</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
The first form returns a copy of <em>str</em> transcoded to encoding
<tt>encoding</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encode%21-instance_method" title="#encode! (instance method)">- (Object) <strong>encode!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
The first form transcodes the contents of <em>str</em> from str.encoding to
<tt>encoding</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encoding-instance_method" title="#encoding (instance method)">- (Object) <strong>encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'></div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#end_with%3F-instance_method" title="#end_with? (instance method)">- (Boolean) <strong>end_with?</strong>([suffix]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true if <em>str</em> ends with a suffix given.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">- (Boolean) <strong>eql?</strong>(other) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Two strings are equal if they have the same length and content.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#force_encoding-instance_method" title="#force_encoding (instance method)">- (String) <strong>force_encoding</strong>(encoding) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Changes the encoding to <tt>encoding</tt> and returns self.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getbyte-instance_method" title="#getbyte (instance method)">- (0 .. 255) <strong>getbyte</strong>(index) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
returns the <em>index</em>th byte as an integer.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gsub-instance_method" title="#gsub (instance method)">- (Object) <strong>gsub</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with the <em>all</em> occurrences of
<em>pattern</em> substituted for the second argument.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gsub%21-instance_method" title="#gsub! (instance method)">- (Object) <strong>gsub!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Performs the substitutions of <tt>String#gsub</tt> in place, returning
<em>str</em>, or <tt>nil</tt> if no substitutions were performed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hash-instance_method" title="#hash (instance method)">- (Fixnum) <strong>hash</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return a hash based on the string&#8217;s length and content.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hex-instance_method" title="#hex (instance method)">- (Integer) <strong>hex</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Treats leading characters from <em>str</em> as a string of hexadecimal
digits (with an optional sign and an optional <tt>0x</tt>) and returns the
corresponding number.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#include%3F-instance_method" title="#include? (instance method)">- (Boolean) <strong>include?</strong>(other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <em>str</em> contains the given string or
character.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#index-instance_method" title="#index (instance method)">- (Object) <strong>index</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the index of the first occurrence of the given <em>substring</em>
or pattern (<em>regexp</em>) in <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#new-instance_method" title="#new (instance method)">- (String) <strong>new</strong>(str = &quot;&quot;) </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new string object containing a copy of <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replace-instance_method" title="#replace (instance method)">- (String) <strong>replace</strong>(other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#insert-instance_method" title="#insert (instance method)">- (String) <strong>insert</strong>(index, other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Inserts <em>other_str</em> before the character at the given
<em>index</em>, modifying <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a printable version of <em>str</em>, surrounded by quote marks,
with special characters escaped.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#intern-instance_method" title="#intern (instance method)">- (Object) <strong>intern</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the <tt>Symbol</tt> corresponding to <em>str</em>, creating the
symbol if it did not previously exist.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#length-instance_method" title="#length (instance method)">- (Object) <strong>length</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the character length of <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lines-instance_method" title="#lines (instance method)">- (Object) <strong>lines</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
str.lines(separator=$/) {|substr| block }       -> str.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ljust-instance_method" title="#ljust (instance method)">- (String) <strong>ljust</strong>(integer, padstr = ' ') </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt>String</tt> of length <em>integer</em> with <em>str</em> left
justified and padded with <em>padstr</em>; otherwise, returns <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lstrip-instance_method" title="#lstrip (instance method)">- (String) <strong>lstrip</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with leading whitespace removed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lstrip%21-instance_method" title="#lstrip! (instance method)">- (String<sup>?</sup>) <strong>lstrip!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Removes leading whitespace from <em>str</em>, returning <tt>nil</tt> if no
change was made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#match-instance_method" title="#match (instance method)">- (Object) <strong>match</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Converts <em>pattern</em> to a <tt>Regexp</tt> (if it isn&#8217;t already
one), then invokes its <tt>match</tt> method on <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#next-instance_method" title="#next (instance method)">- (Object) <strong>next</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the successor to <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#next%21-instance_method" title="#next! (instance method)">- (Object) <strong>next!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equivalent to <tt>String#succ</tt>, but modifies the receiver in place.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#oct-instance_method" title="#oct (instance method)">- (Integer) <strong>oct</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Treats leading characters of <em>str</em> as a string of octal digits (with
an optional sign) and returns the corresponding number.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ord-instance_method" title="#ord (instance method)">- (Integer) <strong>ord</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return the <tt>Integer</tt> ordinal of a one-character string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#partition-instance_method" title="#partition (instance method)">- (Object) <strong>partition</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Searches <em>sep</em> or pattern (<em>regexp</em>) in the string and
returns the part before it, the match, and the part after it.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#replace-instance_method" title="#replace (instance method)">- (String) <strong>replace</strong>(other_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reverse-instance_method" title="#reverse (instance method)">- (String) <strong>reverse</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new string with the characters from <em>str</em> in reverse
order.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reverse%21-instance_method" title="#reverse! (instance method)">- (String) <strong>reverse!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reverses <em>str</em> in place.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rindex-instance_method" title="#rindex (instance method)">- (Object) <strong>rindex</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the index of the last occurrence of the given <em>substring</em> or
pattern (<em>regexp</em>) in <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rjust-instance_method" title="#rjust (instance method)">- (String) <strong>rjust</strong>(integer, padstr = ' ') </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt>String</tt> of length <em>integer</em> with <em>str</em> right
justified and padded with <em>padstr</em>; otherwise, returns <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rpartition-instance_method" title="#rpartition (instance method)">- (Object) <strong>rpartition</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Searches <em>sep</em> or pattern (<em>regexp</em>) in the string from the
end of the string, and returns the part before it, the match, and the part
after it.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rstrip-instance_method" title="#rstrip (instance method)">- (String) <strong>rstrip</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with trailing whitespace removed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rstrip%21-instance_method" title="#rstrip! (instance method)">- (String<sup>?</sup>) <strong>rstrip!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Removes trailing whitespace from <em>str</em>, returning <tt>nil</tt> if no
change was made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#scan-instance_method" title="#scan (instance method)">- (Object) <strong>scan</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Both forms iterate through <em>str</em>, matching the pattern (which may be
a <tt>Regexp</tt> or a <tt>String</tt>).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#setbyte-instance_method" title="#setbyte (instance method)">- (Integer) <strong>setbyte</strong>(index, int) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
modifies the <em>index</em>th byte as <em>int</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#size-instance_method" title="#size (instance method)">- (Object) <strong>size</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the character length of <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#slice-instance_method" title="#slice (instance method)">- (Object) <strong>slice</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Element Reference--If passed a single <tt>Fixnum</tt>, returns a
substring of one character at that position.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#slice%21-instance_method" title="#slice! (instance method)">- (Object) <strong>slice!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Deletes the specified portion from <em>str</em>, and returns the portion
deleted.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#split-instance_method" title="#split (instance method)">- (Array) <strong>split</strong>(pattern = $;, [limit]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Divides <em>str</em> into substrings based on a delimiter, returning an
array of these substrings.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#squeeze-instance_method" title="#squeeze (instance method)">- (String) <strong>squeeze</strong>([other_str]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Builds a set of characters from the <em>other_str</em> parameter(s) using
the procedure described for <tt>String#count</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#squeeze%21-instance_method" title="#squeeze! (instance method)">- (String<sup>?</sup>) <strong>squeeze!</strong>([other_str]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Squeezes <em>str</em> in place, returning either <em>str</em>, or
<tt>nil</tt> if no changes were made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#start_with%3F-instance_method" title="#start_with? (instance method)">- (Boolean) <strong>start_with?</strong>([prefix]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true if <em>str</em> starts with a prefix given.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#strip-instance_method" title="#strip (instance method)">- (String) <strong>strip</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with leading and trailing whitespace
removed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#strip%21-instance_method" title="#strip! (instance method)">- (String<sup>?</sup>) <strong>strip!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Removes leading and trailing whitespace from <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sub-instance_method" title="#sub (instance method)">- (Object) <strong>sub</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with the <em>first</em> occurrence of
<em>pattern</em> substituted for the second argument.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sub%21-instance_method" title="#sub! (instance method)">- (Object) <strong>sub!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Performs the substitutions of <tt>String#sub</tt> in place, returning
<em>str</em>, or <tt>nil</tt> if no substitutions were performed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#succ-instance_method" title="#succ (instance method)">- (Object) <strong>succ</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the successor to <em>str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#succ%21-instance_method" title="#succ! (instance method)">- (Object) <strong>succ!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equivalent to <tt>String#succ</tt>, but modifies the receiver in place.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sum-instance_method" title="#sum (instance method)">- (Integer) <strong>sum</strong>(n = 16) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a basic <em>n</em>-bit checksum of the characters in <em>str</em>,
where <em>n</em> is the optional <tt>Fixnum</tt> parameter, defaulting to
16.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#swapcase-instance_method" title="#swapcase (instance method)">- (String) <strong>swapcase</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with uppercase alphabetic characters
converted to lowercase and lowercase characters converted to uppercase.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#swapcase%21-instance_method" title="#swapcase! (instance method)">- (String<sup>?</sup>) <strong>swapcase!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Equivalent to <tt>String#swapcase</tt>, but modifies the receiver in place,
returning <em>str</em>, or <tt>nil</tt> if no changes were made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_c-instance_method" title="#to_c (instance method)">- (Object) <strong>to_c</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a complex which denotes the string form.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_f-instance_method" title="#to_f (instance method)">- (Float) <strong>to_f</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the result of interpreting leading characters in <em>str</em> as a
floating point number.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_i-instance_method" title="#to_i (instance method)">- (Integer) <strong>to_i</strong>(base = 10) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the result of interpreting leading characters in <em>str</em> as an
integer base <em>base</em> (between 2 and 36).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_r-instance_method" title="#to_r (instance method)">- (Object) <strong>to_r</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a rational which denotes the string form.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">- (Object) <strong>to_s</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the receiver.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_str-instance_method" title="#to_str (instance method)">- (Object) <strong>to_str</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the receiver.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_sym-instance_method" title="#to_sym (instance method)">- (Object) <strong>to_sym</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the <tt>Symbol</tt> corresponding to <em>str</em>, creating the
symbol if it did not previously exist.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tr-instance_method" title="#tr (instance method)">- (String) <strong>tr</strong>(from_str, to_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with the characters in <em>from_str</em>
replaced by the corresponding characters in <em>to_str</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tr%21-instance_method" title="#tr! (instance method)">- (String<sup>?</sup>) <strong>tr!</strong>(from_str, to_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Translates <em>str</em> in place, using the same rules as
<tt>String#tr</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tr_s-instance_method" title="#tr_s (instance method)">- (String) <strong>tr_s</strong>(from_str, to_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Processes a copy of <em>str</em> as described under <tt>String#tr</tt>,
then removes duplicate characters in regions that were affected by the
translation.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tr_s%21-instance_method" title="#tr_s! (instance method)">- (String<sup>?</sup>) <strong>tr_s!</strong>(from_str, to_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Performs <tt>String#tr_s</tt> processing on <em>str</em> in place,
returning <em>str</em>, or <tt>nil</tt> if no changes were made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#unpack-instance_method" title="#unpack (instance method)">- (Array) <strong>unpack</strong>(format) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Decodes <em>str</em> (which may contain binary data) according to the
format string, returning an array of each value extracted.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#upcase-instance_method" title="#upcase (instance method)">- (String) <strong>upcase</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a copy of <em>str</em> with all lowercase letters replaced with
their uppercase counterparts.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#upcase%21-instance_method" title="#upcase! (instance method)">- (String<sup>?</sup>) <strong>upcase!</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Upcases the contents of <em>str</em>, returning <tt>nil</tt> if no changes
were made.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#upto-instance_method" title="#upto (instance method)">- (Object) <strong>upto</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Iterates through successive values, starting at <em>str</em> and ending at
<em>other_str</em> inclusive, passing each value in turn to the block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#valid_encoding%3F-instance_method" title="#valid_encoding? (instance method)">- (Boolean) <strong>valid_encoding?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true for a string which encoded correctly.
</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  <h3 class="inherited">Methods included from <span class='object_link'><a href="Comparable.html" title="Comparable (module)">Comparable</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="Comparable.html#%3C-instance_method" title="Comparable#< (method)">#<</a></span>, <span class='object_link'><a href="Comparable.html#%3C%3D-instance_method" title="Comparable#<= (method)">#<=</a></span>, <span class='object_link'><a href="Comparable.html#%3E-instance_method" title="Comparable#> (method)">#></a></span>, <span class='object_link'><a href="Comparable.html#%3E%3D-instance_method" title="Comparable#>= (method)">#>=</a></span>, <span class='object_link'><a href="Comparable.html#between%3F-instance_method" title="Comparable#between? (method)">#between?</a></span></p>
<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>new</strong>(str = &quot;&quot;) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new string object containing a copy of <em>str</em>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     String.new(str=&quot;&quot;)   -&gt; new_str
 *
 *  Returns a new string object containing a copy of &lt;i&gt;str&lt;/i&gt;.
 */

static VALUE
rb_str_init(int argc, VALUE *argv, VALUE str)
{
    VALUE orig;

    if (argc &gt; 0 &amp;&amp; rb_scan_args(argc, argv, &quot;01&quot;, &amp;orig) == 1)
    rb_str_replace(str, orig);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="try_convert-class_method">
  
    + (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>try_convert</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Try to convert <em>obj</em> into a String, using to_str method. Returns
converted string or nil if <em>obj</em> cannot be converted for any reason.
</p>
<pre class="code">
   String.try_convert(&quot;str&quot;)     #=&gt; &quot;str&quot;
   String.try_convert(/re/)      #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     String.try_convert(obj) -&gt; string or nil
 *
 *  Try to convert &lt;i&gt;obj&lt;/i&gt; into a String, using to_str method.
 *  Returns converted string or nil if &lt;i&gt;obj&lt;/i&gt; cannot be converted
 *  for any reason.
 *
 *     String.try_convert(&quot;str&quot;)     #=&gt; &quot;str&quot;
 *     String.try_convert(/re/)      #=&gt; nil
 */
static VALUE
rb_str_s_try_convert(VALUE dummy, VALUE str)
{
    return rb_check_string_type(str);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="%-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>%</strong>(arg) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Format--Uses <em>str</em> as a format specification, and returns the
result of applying it to <em>arg</em>. If the format specification contains
more than one substitution, then <em>arg</em> must be an <tt>Array</tt>
containing the values to be substituted. See <tt>Kernel::sprintf</tt> for
details of the format string.
</p>
<pre class="code">
   &quot;%05d&quot; % 123                              #=&gt; &quot;00123&quot;
   &quot;%-5s: %08x&quot; % [ &quot;ID&quot;, self.object_id ]   #=&gt; &quot;ID   : 200e14d6&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str % arg   -&gt; new_str
 *
 *  Format---Uses &lt;i&gt;str&lt;/i&gt; as a format specification, and returns the result
 *  of applying it to &lt;i&gt;arg&lt;/i&gt;. If the format specification contains more than
 *  one substitution, then &lt;i&gt;arg&lt;/i&gt; must be an &lt;code&gt;Array&lt;/code&gt; containing
 *  the values to be substituted. See &lt;code&gt;Kernel::sprintf&lt;/code&gt; for details
 *  of the format string.
 *
 *     &quot;%05d&quot; % 123                              #=&gt; &quot;00123&quot;
 *     &quot;%-5s: %08x&quot; % [ &quot;ID&quot;, self.object_id ]   #=&gt; &quot;ID   : 200e14d6&quot;
 */

static VALUE
rb_str_format_m(VALUE str, VALUE arg)
{
    volatile VALUE tmp = rb_check_array_type(arg);

    if (!NIL_P(tmp)) {
    return rb_str_format(RARRAY_LENINT(tmp), RARRAY_PTR(tmp), str);
    }
    return rb_str_format(1, &amp;arg, str);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="*-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>*</strong>(integer) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Copy--Returns a new <tt>String</tt> containing <em>integer</em> copies
of the receiver.
</p>
<pre class="code">
   &quot;Ho! &quot; * 3   #=&gt; &quot;Ho! Ho! Ho! &quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str * integer   -&gt; new_str
 *
 *  Copy---Returns a new &lt;code&gt;String&lt;/code&gt; containing &lt;i&gt;integer&lt;/i&gt; copies of
 *  the receiver.
 *
 *     &quot;Ho! &quot; * 3   #=&gt; &quot;Ho! Ho! Ho! &quot;
 */

VALUE
rb_str_times(VALUE str, VALUE times)
{
    VALUE str2;
    long n, len;
    char *ptr2;

    len = NUM2LONG(times);
    if (len &lt; 0) {
    rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (len &amp;&amp; LONG_MAX/len &lt;  RSTRING_LEN(str)) {
    rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }

    str2 = rb_str_new5(str, 0, len *= RSTRING_LEN(str));
    ptr2 = RSTRING_PTR(str2);
    if (len) {
        n = RSTRING_LEN(str);
        memcpy(ptr2, RSTRING_PTR(str), n);
        while (n &lt;= len/2) {
            memcpy(ptr2 + n, ptr2, n);
            n *= 2;
        }
        memcpy(ptr2 + n, ptr2, len-n);
    }
    ptr2[RSTRING_LEN(str2)] = '\0';
    OBJ_INFECT(str2, str);
    rb_enc_cr_str_copy_for_substr(str2, str);

    return str2;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="+-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>+</strong>(other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Concatenation--Returns a new <tt>String</tt> containing
<em>other_str</em> concatenated to <em>str</em>.
</p>
<pre class="code">
   &quot;Hello from &quot; + self.to_s   #=&gt; &quot;Hello from main&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str + other_str   -&gt; new_str
 *
 *  Concatenation---Returns a new &lt;code&gt;String&lt;/code&gt; containing
 *  &lt;i&gt;other_str&lt;/i&gt; concatenated to &lt;i&gt;str&lt;/i&gt;.
 *
 *     &quot;Hello from &quot; + self.to_s   #=&gt; &quot;Hello from main&quot;
 */

VALUE
rb_str_plus(VALUE str1, VALUE str2)
{
    VALUE str3;
    rb_encoding *enc;

    StringValue(str2);
    enc = rb_enc_check(str1, str2);
    str3 = rb_str_new(0, RSTRING_LEN(str1)+RSTRING_LEN(str2));
    memcpy(RSTRING_PTR(str3), RSTRING_PTR(str1), RSTRING_LEN(str1));
    memcpy(RSTRING_PTR(str3) + RSTRING_LEN(str1),
       RSTRING_PTR(str2), RSTRING_LEN(str2));
    RSTRING_PTR(str3)[RSTRING_LEN(str3)] = '\0';

    if (OBJ_TAINTED(str1) || OBJ_TAINTED(str2))
    OBJ_TAINT(str3);
    ENCODING_CODERANGE_SET(str3, rb_enc_to_index(enc),
               ENC_CODERANGE_AND(ENC_CODERANGE(str1), ENC_CODERANGE(str2)));
    return str3;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<<-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(integer) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(integer) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(obj) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Append--Concatenates the given object to <em>str</em>. If the object
is a <tt>Integer</tt>, it is considered as a codepoint, and is converted to
a character before concatenation.
</p>
<pre class="code">
   a = &quot;hello &quot;
   a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
   a.concat(33)   #=&gt; &quot;hello world!&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(integer) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(integer) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str &lt;&lt; integer       -&gt; str
 *     str.concat(integer)  -&gt; str
 *     str &lt;&lt; obj           -&gt; str
 *     str.concat(obj)      -&gt; str
 *
 *  Append---Concatenates the given object to &lt;i&gt;str&lt;/i&gt;. If the object is a
 *  &lt;code&gt;Integer&lt;/code&gt;, it is considered as a codepoint, and is converted
 *  to a character before concatenation.
 *
 *     a = &quot;hello &quot;
 *     a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
 *     a.concat(33)   #=&gt; &quot;hello world!&quot;
 */

VALUE
rb_str_concat(VALUE str1, VALUE str2)
{
    SIGNED_VALUE lc;

    if (FIXNUM_P(str2)) {
    lc = FIX2LONG(str2);
    if (lc &lt; 0)
        rb_raise(rb_eRangeError, &quot;negative argument&quot;);
    }
    else if (TYPE(str2) == T_BIGNUM) {
    if (!RBIGNUM_SIGN(str2))
        rb_raise(rb_eRangeError, &quot;negative argument&quot;);
    lc = rb_big2ulong(str2);
    }
    else {
    return rb_str_append(str1, str2);
    }
#if SIZEOF_INT &lt; SIZEOF_VALUE
    if ((VALUE)lc &gt; UINT_MAX) {
    rb_raise(rb_eRangeError, &quot;%&quot;PRIuVALUE&quot; out of char range&quot;, lc);
    }
#endif
    {
    rb_encoding *enc = STR_ENC_GET(str1);
    long pos = RSTRING_LEN(str1);
    int cr = ENC_CODERANGE(str1);
    int c, len;

    if ((len = rb_enc_codelen(c = (int)lc, enc)) &lt;= 0) {
        rb_raise(rb_eRangeError, &quot;%u invalid char&quot;, c);
    }
    rb_str_resize(str1, pos+len);
    rb_enc_mbcput(c, RSTRING_PTR(str1)+pos, enc);
    ENC_CODERANGE_SET(str1, cr);
    return str1;
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="<=>-instance_method">
  
    - (<tt>-1</tt>, ...) <strong>&lt;=&gt;</strong>(other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Comparison--Returns -1 if <em>other_str</em> is greater than, 0 if
<em>other_str</em> is equal to, and +1 if <em>other_str</em> is less than
<em>str</em>. If the strings are of different lengths, and the strings are
equal when compared up to the shortest length, then the longer string is
considered greater than the shorter one. In older versions of Ruby, setting
<tt>$=</tt> allowed case-insensitive comparisons; this is now deprecated in
favor of using <tt>String#casecmp</tt>.
</p>
<p>
<tt>&lt;=&gt;</tt> is the basis for the methods <tt>&lt;</tt>,
<tt>&lt;=</tt>, <tt>&gt;</tt>, <tt>&gt;=</tt>, and <tt>between?</tt>,
included from module <tt>Comparable</tt>.  The method <tt>String#==</tt>
does not use <tt>Comparable#==</tt>.
</p>
<pre class="code">
   &quot;abcdef&quot; &lt;=&gt; &quot;abcde&quot;     #=&gt; 1
   &quot;abcdef&quot; &lt;=&gt; &quot;abcdef&quot;    #=&gt; 0
   &quot;abcdef&quot; &lt;=&gt; &quot;abcdefg&quot;   #=&gt; -1
   &quot;abcdef&quot; &lt;=&gt; &quot;ABCDEF&quot;    #=&gt; 1</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>-1</tt>, <tt>0</tt>, <tt>+1</tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str &lt;=&gt; other_str   -&gt; -1, 0, +1 or nil
 *
 *  Comparison---Returns -1 if &lt;i&gt;other_str&lt;/i&gt; is greater than, 0 if
 *  &lt;i&gt;other_str&lt;/i&gt; is equal to, and +1 if &lt;i&gt;other_str&lt;/i&gt; is less than
 *  &lt;i&gt;str&lt;/i&gt;. If the strings are of different lengths, and the strings are
 *  equal when compared up to the shortest length, then the longer string is
 *  considered greater than the shorter one. In older versions of Ruby, setting
 *  &lt;code&gt;$=&lt;/code&gt; allowed case-insensitive comparisons; this is now deprecated
 *  in favor of using &lt;code&gt;String#casecmp&lt;/code&gt;.
 *
 *  &lt;code&gt;&lt;=&gt;&lt;/code&gt; is the basis for the methods &lt;code&gt;&lt;&lt;/code&gt;,
 *  &lt;code&gt;&lt;=&lt;/code&gt;, &lt;code&gt;&gt;&lt;/code&gt;, &lt;code&gt;&gt;=&lt;/code&gt;, and &lt;code&gt;between?&lt;/code&gt;,
 *  included from module &lt;code&gt;Comparable&lt;/code&gt;.  The method
 *  &lt;code&gt;String#==&lt;/code&gt; does not use &lt;code&gt;Comparable#==&lt;/code&gt;.
 *
 *     &quot;abcdef&quot; &lt;=&gt; &quot;abcde&quot;     #=&gt; 1
 *     &quot;abcdef&quot; &lt;=&gt; &quot;abcdef&quot;    #=&gt; 0
 *     &quot;abcdef&quot; &lt;=&gt; &quot;abcdefg&quot;   #=&gt; -1
 *     &quot;abcdef&quot; &lt;=&gt; &quot;ABCDEF&quot;    #=&gt; 1
 */

static VALUE
rb_str_cmp_m(VALUE str1, VALUE str2)
{
    long result;

    if (TYPE(str2) != T_STRING) {
    if (!rb_respond_to(str2, rb_intern(&quot;to_str&quot;))) {
        return Qnil;
    }
    else if (!rb_respond_to(str2, rb_intern(&quot;&lt;=&gt;&quot;))) {
        return Qnil;
    }
    else {
        VALUE tmp = rb_funcall(str2, rb_intern(&quot;&lt;=&gt;&quot;), 1, str1);

        if (NIL_P(tmp)) return Qnil;
        if (!FIXNUM_P(tmp)) {
        return rb_funcall(LONG2FIX(0), '-', 1, tmp);
        }
        result = -FIX2LONG(tmp);
    }
    }
    else {
    result = rb_str_cmp(str1, str2);
    }
    return LONG2NUM(result);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="==-instance_method">
  
    - (<tt>Boolean</tt>) <strong>==</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equality--If <em>obj</em> is not a <tt>String</tt>, returns
<tt>false</tt>. Otherwise, returns <tt>true</tt> if <em>str</em>
<tt>&lt;=&gt;</tt> <em>obj</em> returns zero.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str == obj   -&gt; true or false
 *
 *  Equality---If &lt;i&gt;obj&lt;/i&gt; is not a &lt;code&gt;String&lt;/code&gt;, returns
 *  &lt;code&gt;false&lt;/code&gt;. Otherwise, returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt;
 *  &lt;code&gt;&lt;=&gt;&lt;/code&gt; &lt;i&gt;obj&lt;/i&gt; returns zero.
 */

VALUE
rb_str_equal(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (TYPE(str2) != T_STRING) {
    if (!rb_respond_to(str2, rb_intern(&quot;to_str&quot;))) {
        return Qfalse;
    }
    return rb_equal(str2, str1);
    }
    return str_eql(str1, str2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="===-instance_method">
  
    - (<tt>Boolean</tt>) <strong>==</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equality--If <em>obj</em> is not a <tt>String</tt>, returns
<tt>false</tt>. Otherwise, returns <tt>true</tt> if <em>str</em>
<tt>&lt;=&gt;</tt> <em>obj</em> returns zero.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str == obj   -&gt; true or false
 *
 *  Equality---If &lt;i&gt;obj&lt;/i&gt; is not a &lt;code&gt;String&lt;/code&gt;, returns
 *  &lt;code&gt;false&lt;/code&gt;. Otherwise, returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt;
 *  &lt;code&gt;&lt;=&gt;&lt;/code&gt; &lt;i&gt;obj&lt;/i&gt; returns zero.
 */

VALUE
rb_str_equal(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (TYPE(str2) != T_STRING) {
    if (!rb_respond_to(str2, rb_intern(&quot;to_str&quot;))) {
        return Qfalse;
    }
    return rb_equal(str2, str1);
    }
    return str_eql(str1, str2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="=~-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>=~</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Match--If <em>obj</em> is a <tt>Regexp</tt>, use it as a pattern to
match against <em>str</em>,and returns the position the match starts, or
<tt>nil</tt> if there is no match. Otherwise, invokes <em>obj.=~</em>,
passing <em>str</em> as an argument. The default <tt>=~</tt> in
<tt>Object</tt> returns <tt>false</tt>.
</p>
<pre class="code">
   &quot;cat o' 9 tails&quot; =~ /\d/   #=&gt; 7
   &quot;cat o' 9 tails&quot; =~ 9      #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str =~ obj   -&gt; fixnum or nil
 *
 *  Match---If &lt;i&gt;obj&lt;/i&gt; is a &lt;code&gt;Regexp&lt;/code&gt;, use it as a pattern to match
 *  against &lt;i&gt;str&lt;/i&gt;,and returns the position the match starts, or
 *  &lt;code&gt;nil&lt;/code&gt; if there is no match. Otherwise, invokes
 *  &lt;i&gt;obj.=~&lt;/i&gt;, passing &lt;i&gt;str&lt;/i&gt; as an argument. The default
 *  &lt;code&gt;=~&lt;/code&gt; in &lt;code&gt;Object&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
 *
 *     &quot;cat o' 9 tails&quot; =~ /\d/   #=&gt; 7
 *     &quot;cat o' 9 tails&quot; =~ 9      #=&gt; nil
 */

static VALUE
rb_str_match(VALUE x, VALUE y)
{
    switch (TYPE(y)) {
      case T_STRING:
    rb_raise(rb_eTypeError, &quot;type mismatch: String given&quot;);

      case T_REGEXP:
    return rb_reg_match(y, x);

      default:
    return rb_funcall(y, rb_intern(&quot;=~&quot;), 1, x);
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(other_str) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, capname) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(other_str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Element Reference--If passed a single <tt>Fixnum</tt>, returns a
substring of one character at that position. If passed two <tt>Fixnum</tt>
objects, returns a substring starting at the offset given by the first, and
a length given by the second. If given a range, a substring containing
characters at offsets given by the range is returned. In all three cases,
if an offset is negative, it is counted from the end of <em>str</em>.
Returns <tt>nil</tt> if the initial offset falls outside the string, the
length is negative, or the beginning of the range is greater than the end.
</p>
<p>
If a <tt>Regexp</tt> is supplied, the matching portion of <em>str</em> is
returned. If a numeric or name parameter follows the regular expression,
that component of the <tt>MatchData</tt> is returned instead. If a
<tt>String</tt> is given, that string is returned if it occurs in
<em>str</em>. In both cases, <tt>nil</tt> is returned if there is no match.
</p>
<pre class="code">
   a = &quot;hello there&quot;
   a[1]                   #=&gt; &quot;e&quot;
   a[1,3]                 #=&gt; &quot;ell&quot;
   a[1..3]                #=&gt; &quot;ell&quot;
   a[-3,2]                #=&gt; &quot;er&quot;
   a[-4..-2]              #=&gt; &quot;her&quot;
   a[12..-1]              #=&gt; nil
   a[-2..-4]              #=&gt; &quot;&quot;
   a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
   a[/[aeiou](.)\1/, 2]   #=&gt; nil
   a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
   a[&quot;bye&quot;]               #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(other_str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, capname) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(other_str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str[fixnum]                 -&gt; new_str or nil
 *     str[fixnum, fixnum]         -&gt; new_str or nil
 *     str[range]                  -&gt; new_str or nil
 *     str[regexp]                 -&gt; new_str or nil
 *     str[regexp, fixnum]         -&gt; new_str or nil
 *     str[other_str]              -&gt; new_str or nil
 *     str.slice(fixnum)           -&gt; new_str or nil
 *     str.slice(fixnum, fixnum)   -&gt; new_str or nil
 *     str.slice(range)            -&gt; new_str or nil
 *     str.slice(regexp)           -&gt; new_str or nil
 *     str.slice(regexp, fixnum)   -&gt; new_str or nil
 *     str.slice(regexp, capname)  -&gt; new_str or nil
 *     str.slice(other_str)        -&gt; new_str or nil
 *
 *  Element Reference---If passed a single &lt;code&gt;Fixnum&lt;/code&gt;, returns a
 *  substring of one character at that position. If passed two &lt;code&gt;Fixnum&lt;/code&gt;
 *  objects, returns a substring starting at the offset given by the first, and
 *  a length given by the second. If given a range, a substring containing
 *  characters at offsets given by the range is returned. In all three cases, if
 *  an offset is negative, it is counted from the end of &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if the initial offset falls outside the string, the length
 *  is negative, or the beginning of the range is greater than the end.
 *
 *  If a &lt;code&gt;Regexp&lt;/code&gt; is supplied, the matching portion of &lt;i&gt;str&lt;/i&gt; is
 *  returned. If a numeric or name parameter follows the regular expression, that
 *  component of the &lt;code&gt;MatchData&lt;/code&gt; is returned instead. If a
 *  &lt;code&gt;String&lt;/code&gt; is given, that string is returned if it occurs in
 *  &lt;i&gt;str&lt;/i&gt;. In both cases, &lt;code&gt;nil&lt;/code&gt; is returned if there is no
 *  match.
 *
 *     a = &quot;hello there&quot;
 *     a[1]                   #=&gt; &quot;e&quot;
 *     a[1,3]                 #=&gt; &quot;ell&quot;
 *     a[1..3]                #=&gt; &quot;ell&quot;
 *     a[-3,2]                #=&gt; &quot;er&quot;
 *     a[-4..-2]              #=&gt; &quot;her&quot;
 *     a[12..-1]              #=&gt; nil
 *     a[-2..-4]              #=&gt; &quot;&quot;
 *     a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
 *     a[/[aeiou](.)\1/, 2]   #=&gt; nil
 *     a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
 *     a[&quot;bye&quot;]               #=&gt; nil
 */

static VALUE
rb_str_aref_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
    if (TYPE(argv[0]) == T_REGEXP) {
        return rb_str_subpat(str, argv[0], argv[1]);
    }
    return rb_str_substr(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]));
    }
    if (argc != 1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..2)&quot;, argc);
    }
    return rb_str_aref(str, argv[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="[]=-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(fixnum, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(regexp, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(regexp, name) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>[]=</strong>(other_str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Element Assignment--Replaces some or all of the content of
<em>str</em>. The portion of the string affected is determined using the
same criteria as <tt>String#[]</tt>. If the replacement string is not the
same length as the text it is replacing, the string will be adjusted
accordingly. If the regular expression or string is used as the index
doesn&#8217;t match a position in the string, <tt>IndexError</tt> is
raised. If the regular expression form is used, the optional second
<tt>Fixnum</tt> allows you to specify which portion of the match to replace
(effectively using the <tt>MatchData</tt> indexing rules. The forms that
take a <tt>Fixnum</tt> will raise an <tt>IndexError</tt> if the value is
out of range; the <tt>Range</tt> form will raise a <tt>RangeError</tt>, and
the <tt>Regexp</tt> and <tt>String</tt> forms will silently ignore the
assignment.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str[fixnum] = new_str
 *     str[fixnum, fixnum] = new_str
 *     str[range] = aString
 *     str[regexp] = new_str
 *     str[regexp, fixnum] = new_str
 *     str[regexp, name] = new_str
 *     str[other_str] = new_str
 *
 *  Element Assignment---Replaces some or all of the content of &lt;i&gt;str&lt;/i&gt;. The
 *  portion of the string affected is determined using the same criteria as
 *  &lt;code&gt;String#[]&lt;/code&gt;. If the replacement string is not the same length as
 *  the text it is replacing, the string will be adjusted accordingly. If the
 *  regular expression or string is used as the index doesn't match a position
 *  in the string, &lt;code&gt;IndexError&lt;/code&gt; is raised. If the regular expression
 *  form is used, the optional second &lt;code&gt;Fixnum&lt;/code&gt; allows you to specify
 *  which portion of the match to replace (effectively using the
 *  &lt;code&gt;MatchData&lt;/code&gt; indexing rules. The forms that take a
 *  &lt;code&gt;Fixnum&lt;/code&gt; will raise an &lt;code&gt;IndexError&lt;/code&gt; if the value is
 *  out of range; the &lt;code&gt;Range&lt;/code&gt; form will raise a
 *  &lt;code&gt;RangeError&lt;/code&gt;, and the &lt;code&gt;Regexp&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;
 *  forms will silently ignore the assignment.
 */

static VALUE
rb_str_aset_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 3) {
    if (TYPE(argv[0]) == T_REGEXP) {
        rb_str_subpat_set(str, argv[0], argv[1], argv[2]);
    }
    else {
        rb_str_splice(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
    }
    return argv[2];
    }
    if (argc != 2) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2..3)&quot;, argc);
    }
    return rb_str_aset(str, argv[0], argv[1]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ascii_only?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>ascii_only?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for a string which has only ASCII characters.
</p>
<pre class="code">
  &quot;abc&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?          #=&gt; true
  &quot;abc\u{6666}&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?  #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.ascii_only?  -&gt; true or false
 *
 *  Returns true for a string which has only ASCII characters.
 *
 *    &quot;abc&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?          #=&gt; true
 *    &quot;abc\u{6666}&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?  #=&gt; false
 */

static VALUE
rb_str_is_ascii_only_p(VALUE str)
{
    int cr = rb_enc_str_coderange(str);

    return cr == ENC_CODERANGE_7BIT ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="bytes-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>bytes</strong> {|fixnum| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>bytes</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.each_byte {|fixnum| block }    -> str
</p>
<pre class="code">
   str.each_byte                      -&gt; an_enumerator
</pre>
<p>
Passes each byte in <em>str</em> to the given block, or returns an
enumerator if no block is given.
</p>
<pre class="code">
   &quot;hello&quot;.each_byte {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   104 101 108 108 111</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>bytes</strong> {|fixnum| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>fixnum</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.bytes {|fixnum| block }        -&gt; str
 *     str.bytes                          -&gt; an_enumerator
 *
 *     str.each_byte {|fixnum| block }    -&gt; str
 *     str.each_byte                      -&gt; an_enumerator
 *
 *  Passes each byte in &lt;i&gt;str&lt;/i&gt; to the given block, or returns
 *  an enumerator if no block is given.
 *
 *     &quot;hello&quot;.each_byte {|c| print c, ' ' }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     104 101 108 108 111
 */

static VALUE
rb_str_each_byte(VALUE str)
{
    long i;

    RETURN_ENUMERATOR(str, 0, 0);
    for (i=0; i&lt;RSTRING_LEN(str); i++) {
    rb_yield(INT2FIX(RSTRING_PTR(str)[i] &amp; 0xff));
    }
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="bytesize-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>bytesize</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the length of <em>str</em> in bytes.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.bytesize  -&gt; integer
 *
 *  Returns the length of &lt;i&gt;str&lt;/i&gt; in bytes.
 */

static VALUE
rb_str_bytesize(VALUE str)
{
    return INT2NUM(RSTRING_LEN(str));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="capitalize-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>capitalize</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with the first character converted to
uppercase and the remainder to lowercase. Note: case conversion is
effective only in ASCII region.
</p>
<pre class="code">
   &quot;hello&quot;.capitalize    #=&gt; &quot;Hello&quot;
   &quot;HELLO&quot;.capitalize    #=&gt; &quot;Hello&quot;
   &quot;123ABC&quot;.capitalize   #=&gt; &quot;123abc&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.capitalize   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with the first character converted to uppercase
 *  and the remainder to lowercase.
 *  Note: case conversion is effective only in ASCII region.
 *
 *     &quot;hello&quot;.capitalize    #=&gt; &quot;Hello&quot;
 *     &quot;HELLO&quot;.capitalize    #=&gt; &quot;Hello&quot;
 *     &quot;123ABC&quot;.capitalize   #=&gt; &quot;123abc&quot;
 */

static VALUE
rb_str_capitalize(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_capitalize_bang(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="capitalize!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>capitalize!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Modifies <em>str</em> by converting the first character to uppercase and
the remainder to lowercase. Returns <tt>nil</tt> if no changes are made.
Note: case conversion is effective only in ASCII region.
</p>
<pre class="code">
   a = &quot;hello&quot;
   a.capitalize!   #=&gt; &quot;Hello&quot;
   a               #=&gt; &quot;Hello&quot;
   a.capitalize!   #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.capitalize!   -&gt; str or nil
 *
 *  Modifies &lt;i&gt;str&lt;/i&gt; by converting the first character to uppercase and the
 *  remainder to lowercase. Returns &lt;code&gt;nil&lt;/code&gt; if no changes are made.
 *  Note: case conversion is effective only in ASCII region.
 *
 *     a = &quot;hello&quot;
 *     a.capitalize!   #=&gt; &quot;Hello&quot;
 *     a               #=&gt; &quot;Hello&quot;
 *     a.capitalize!   #=&gt; nil
 */

static VALUE
rb_str_capitalize_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *send;
    int modify = 0;
    unsigned int c;
    int n;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    rb_str_check_dummy_enc(enc);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    s = RSTRING_PTR(str); send = RSTRING_END(str);

    c = rb_enc_codepoint_len(s, send, &amp;n, enc);
    if (rb_enc_islower(c, enc)) {
    rb_enc_mbcput(rb_enc_toupper(c, enc), s, enc);
    modify = 1;
    }
    s += n;
    while (s &lt; send) {
    c = rb_enc_codepoint_len(s, send, &amp;n, enc);
    if (rb_enc_isupper(c, enc)) {
        rb_enc_mbcput(rb_enc_tolower(c, enc), s, enc);
        modify = 1;
    }
    s += n;
    }

    if (modify) return str;
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="casecmp-instance_method">
  
    - (<tt>-1</tt>, ...) <strong>casecmp</strong>(other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Case-insensitive version of <tt>String#&lt;=&gt;</tt>.
</p>
<pre class="code">
   &quot;abcdef&quot;.casecmp(&quot;abcde&quot;)     #=&gt; 1
   &quot;aBcDeF&quot;.casecmp(&quot;abcdef&quot;)    #=&gt; 0
   &quot;abcdef&quot;.casecmp(&quot;abcdefg&quot;)   #=&gt; -1
   &quot;abcdef&quot;.casecmp(&quot;ABCDEF&quot;)    #=&gt; 0</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>-1</tt>, <tt>0</tt>, <tt>+1</tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.casecmp(other_str)   -&gt; -1, 0, +1 or nil
 *
 *  Case-insensitive version of &lt;code&gt;String#&lt;=&gt;&lt;/code&gt;.
 *
 *     &quot;abcdef&quot;.casecmp(&quot;abcde&quot;)     #=&gt; 1
 *     &quot;aBcDeF&quot;.casecmp(&quot;abcdef&quot;)    #=&gt; 0
 *     &quot;abcdef&quot;.casecmp(&quot;abcdefg&quot;)   #=&gt; -1
 *     &quot;abcdef&quot;.casecmp(&quot;ABCDEF&quot;)    #=&gt; 0
 */

static VALUE
rb_str_casecmp(VALUE str1, VALUE str2)
{
    long len;
    rb_encoding *enc;
    char *p1, *p1end, *p2, *p2end;

    StringValue(str2);
    enc = rb_enc_compatible(str1, str2);
    if (!enc) {
    return Qnil;
    }

    p1 = RSTRING_PTR(str1); p1end = RSTRING_END(str1);
    p2 = RSTRING_PTR(str2); p2end = RSTRING_END(str2);
    if (single_byte_optimizable(str1) &amp;&amp; single_byte_optimizable(str2)) {
    while (p1 &lt; p1end &amp;&amp; p2 &lt; p2end) {
        if (*p1 != *p2) {
        unsigned int c1 = TOUPPER(*p1 &amp; 0xff);
        unsigned int c2 = TOUPPER(*p2 &amp; 0xff);
                if (c1 != c2)
                    return INT2FIX(c1 &lt; c2 ? -1 : 1);
        }
        p1++;
        p2++;
    }
    }
    else {
    while (p1 &lt; p1end &amp;&amp; p2 &lt; p2end) {
            int l1, c1 = rb_enc_ascget(p1, p1end, &amp;l1, enc);
            int l2, c2 = rb_enc_ascget(p2, p2end, &amp;l2, enc);

            if (0 &lt;= c1 &amp;&amp; 0 &lt;= c2) {
                c1 = TOUPPER(c1);
                c2 = TOUPPER(c2);
                if (c1 != c2)
                    return INT2FIX(c1 &lt; c2 ? -1 : 1);
            }
            else {
                int r;
                l1 = rb_enc_mbclen(p1, p1end, enc);
                l2 = rb_enc_mbclen(p2, p2end, enc);
                len = l1 &lt; l2 ? l1 : l2;
                r = memcmp(p1, p2, len);
                if (r != 0)
                    return INT2FIX(r &lt; 0 ? -1 : 1);
                if (l1 != l2)
                    return INT2FIX(l1 &lt; l2 ? -1 : 1);
            }
        p1 += l1;
        p2 += l2;
    }
    }
    if (RSTRING_LEN(str1) == RSTRING_LEN(str2)) return INT2FIX(0);
    if (RSTRING_LEN(str1) &gt; RSTRING_LEN(str2)) return INT2FIX(1);
    return INT2FIX(-1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="center-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>center</strong>(integer, padstr) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt>String</tt> of length <em>integer</em> with <em>str</em> centered
and padded with <em>padstr</em>; otherwise, returns <em>str</em>.
</p>
<pre class="code">
   &quot;hello&quot;.center(4)         #=&gt; &quot;hello&quot;
   &quot;hello&quot;.center(20)        #=&gt; &quot;       hello        &quot;
   &quot;hello&quot;.center(20, '123') #=&gt; &quot;1231231hello12312312&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.center(integer, padstr)   -&gt; new_str
 *
 *  If &lt;i&gt;integer&lt;/i&gt; is greater than the length of &lt;i&gt;str&lt;/i&gt;, returns a new
 *  &lt;code&gt;String&lt;/code&gt; of length &lt;i&gt;integer&lt;/i&gt; with &lt;i&gt;str&lt;/i&gt; centered and
 *  padded with &lt;i&gt;padstr&lt;/i&gt;; otherwise, returns &lt;i&gt;str&lt;/i&gt;.
 *
 *     &quot;hello&quot;.center(4)         #=&gt; &quot;hello&quot;
 *     &quot;hello&quot;.center(20)        #=&gt; &quot;       hello        &quot;
 *     &quot;hello&quot;.center(20, '123') #=&gt; &quot;1231231hello12312312&quot;
 */

static VALUE
rb_str_center(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'c');
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chars-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>chars</strong> {|cstr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chars</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.each_char {|cstr| block }    -> str
</p>
<pre class="code">
   str.each_char                    -&gt; an_enumerator
</pre>
<p>
Passes each character in <em>str</em> to the given block, or returns an
enumerator if no block is given.
</p>
<pre class="code">
   &quot;hello&quot;.each_char {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   h e l l o</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>chars</strong> {|cstr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>cstr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.chars {|cstr| block }        -&gt; str
 *     str.chars                        -&gt; an_enumerator
 *
 *     str.each_char {|cstr| block }    -&gt; str
 *     str.each_char                    -&gt; an_enumerator
 *
 *  Passes each character in &lt;i&gt;str&lt;/i&gt; to the given block, or returns
 *  an enumerator if no block is given.
 *
 *     &quot;hello&quot;.each_char {|c| print c, ' ' }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     h e l l o
 */

static VALUE
rb_str_each_char(VALUE str)
{
    VALUE orig = str;
    long i, len, n;
    const char *ptr;
    rb_encoding *enc;

    RETURN_ENUMERATOR(str, 0, 0);
    str = rb_str_new4(str);
    ptr = RSTRING_PTR(str);
    len = RSTRING_LEN(str);
    enc = rb_enc_get(str);
    switch (ENC_CODERANGE(str)) {
      case ENC_CODERANGE_VALID:
      case ENC_CODERANGE_7BIT:
    for (i = 0; i &lt; len; i += n) {
        n = rb_enc_fast_mbclen(ptr + i, ptr + len, enc);
        rb_yield(rb_str_subseq(str, i, n));
    }
    break;
      default:
    for (i = 0; i &lt; len; i += n) {
        n = rb_enc_mbclen(ptr + i, ptr + len, enc);
        rb_yield(rb_str_subseq(str, i, n));
    }
    }
    return orig;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chomp-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>chomp</strong>(separator = $/) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new <tt>String</tt> with the given record separator removed from
the end of <em>str</em> (if present). If <tt>$/</tt> has not been changed
from the default Ruby record separator, then <tt>chomp</tt> also removes
carriage return characters (that is it will remove <tt>\n</tt>,
<tt>\r</tt>, and <tt>\r\n</tt>).
</p>
<pre class="code">
   &quot;hello&quot;.chomp            #=&gt; &quot;hello&quot;
   &quot;hello\n&quot;.chomp          #=&gt; &quot;hello&quot;
   &quot;hello\r\n&quot;.chomp        #=&gt; &quot;hello&quot;
   &quot;hello\n\r&quot;.chomp        #=&gt; &quot;hello\n&quot;
   &quot;hello\r&quot;.chomp          #=&gt; &quot;hello&quot;
   &quot;hello \n there&quot;.chomp   #=&gt; &quot;hello \n there&quot;
   &quot;hello&quot;.chomp(&quot;llo&quot;)     #=&gt; &quot;he&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.chomp(separator=$/)   -&gt; new_str
 *
 *  Returns a new &lt;code&gt;String&lt;/code&gt; with the given record separator removed
 *  from the end of &lt;i&gt;str&lt;/i&gt; (if present). If &lt;code&gt;$/&lt;/code&gt; has not been
 *  changed from the default Ruby record separator, then &lt;code&gt;chomp&lt;/code&gt; also
 *  removes carriage return characters (that is it will remove &lt;code&gt;\n&lt;/code&gt;,
 *  &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\r\n&lt;/code&gt;).
 *
 *     &quot;hello&quot;.chomp            #=&gt; &quot;hello&quot;
 *     &quot;hello\n&quot;.chomp          #=&gt; &quot;hello&quot;
 *     &quot;hello\r\n&quot;.chomp        #=&gt; &quot;hello&quot;
 *     &quot;hello\n\r&quot;.chomp        #=&gt; &quot;hello\n&quot;
 *     &quot;hello\r&quot;.chomp          #=&gt; &quot;hello&quot;
 *     &quot;hello \n there&quot;.chomp   #=&gt; &quot;hello \n there&quot;
 *     &quot;hello&quot;.chomp(&quot;llo&quot;)     #=&gt; &quot;he&quot;
 */

static VALUE
rb_str_chomp(int argc, VALUE *argv, VALUE str)
{
    str = rb_str_dup(str);
    rb_str_chomp_bang(argc, argv, str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chomp!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>chomp!</strong>(separator = $/) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Modifies <em>str</em> in place as described for <tt>String#chomp</tt>,
returning <em>str</em>, or <tt>nil</tt> if no modifications were made.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.chomp!(separator=$/)   -&gt; str or nil
 *
 *  Modifies &lt;i&gt;str&lt;/i&gt; in place as described for &lt;code&gt;String#chomp&lt;/code&gt;,
 *  returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no modifications were made.
 */

static VALUE
rb_str_chomp_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    VALUE rs;
    int newline;
    char *p, *pp, *e;
    long len, rslen;

    str_modify_keep_cr(str);
    len = RSTRING_LEN(str);
    if (len == 0) return Qnil;
    p = RSTRING_PTR(str);
    e = p + len;
    if (argc == 0) {
    rs = rb_rs;
    if (rs == rb_default_rs) {
      smart_chomp:
        enc = rb_enc_get(str);
        if (rb_enc_mbminlen(enc) &gt; 1) {
        pp = rb_enc_left_char_head(p, e-rb_enc_mbminlen(enc), e, enc);
        if (rb_enc_is_newline(pp, e, enc)) {
            e = pp;
        }
        pp = e - rb_enc_mbminlen(enc);
        if (pp &gt;= p) {
            pp = rb_enc_left_char_head(p, pp, e, enc);
            if (rb_enc_ascget(pp, e, 0, enc) == '\r') {
            e = pp;
            }
        }
        if (e == RSTRING_END(str)) {
            return Qnil;
        }
        len = e - RSTRING_PTR(str);
        STR_SET_LEN(str, len);
        }
        else {
        if (RSTRING_PTR(str)[len-1] == '\n') {
            STR_DEC_LEN(str);
            if (RSTRING_LEN(str) &gt; 0 &amp;&amp;
            RSTRING_PTR(str)[RSTRING_LEN(str)-1] == '\r') {
            STR_DEC_LEN(str);
            }
        }
        else if (RSTRING_PTR(str)[len-1] == '\r') {
            STR_DEC_LEN(str);
        }
        else {
            return Qnil;
        }
        }
        RSTRING_PTR(str)[RSTRING_LEN(str)] = '\0';
        return str;
    }
    }
    else {
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs);
    }
    if (NIL_P(rs)) return Qnil;
    StringValue(rs);
    rslen = RSTRING_LEN(rs);
    if (rslen == 0) {
    while (len&gt;0 &amp;&amp; p[len-1] == '\n') {
        len--;
        if (len&gt;0 &amp;&amp; p[len-1] == '\r')
        len--;
    }
    if (len &lt; RSTRING_LEN(str)) {
        STR_SET_LEN(str, len);
        RSTRING_PTR(str)[len] = '\0';
        return str;
    }
    return Qnil;
    }
    if (rslen &gt; len) return Qnil;
    newline = RSTRING_PTR(rs)[rslen-1];
    if (rslen == 1 &amp;&amp; newline == '\n')
    goto smart_chomp;

    enc = rb_enc_check(str, rs);
    if (is_broken_string(rs)) {
    return Qnil;
    }
    pp = e - rslen;
    if (p[len-1] == newline &amp;&amp;
    (rslen &lt;= 1 ||
     memcmp(RSTRING_PTR(rs), pp, rslen) == 0)) {
    if (rb_enc_left_char_head(p, pp, e, enc) != pp)
        return Qnil;
    if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
        ENC_CODERANGE_CLEAR(str);
    }
    STR_SET_LEN(str, RSTRING_LEN(str) - rslen);
    RSTRING_PTR(str)[RSTRING_LEN(str)] = '\0';
    return str;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chop-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>chop</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new <tt>String</tt> with the last character removed.  If the
string ends with <tt>\r\n</tt>, both characters are removed. Applying
<tt>chop</tt> to an empty string returns an empty string.
<tt>String#chomp</tt> is often a safer alternative, as it leaves the string
unchanged if it doesn&#8217;t end in a record separator.
</p>
<pre class="code">
   &quot;string\r\n&quot;.chop   #=&gt; &quot;string&quot;
   &quot;string\n\r&quot;.chop   #=&gt; &quot;string\n&quot;
   &quot;string\n&quot;.chop     #=&gt; &quot;string&quot;
   &quot;string&quot;.chop       #=&gt; &quot;strin&quot;
   &quot;x&quot;.chop.chop       #=&gt; &quot;&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.chop   -&gt; new_str
 *
 *  Returns a new &lt;code&gt;String&lt;/code&gt; with the last character removed.  If the
 *  string ends with &lt;code&gt;\r\n&lt;/code&gt;, both characters are removed. Applying
 *  &lt;code&gt;chop&lt;/code&gt; to an empty string returns an empty
 *  string. &lt;code&gt;String#chomp&lt;/code&gt; is often a safer alternative, as it leaves
 *  the string unchanged if it doesn't end in a record separator.
 *
 *     &quot;string\r\n&quot;.chop   #=&gt; &quot;string&quot;
 *     &quot;string\n\r&quot;.chop   #=&gt; &quot;string\n&quot;
 *     &quot;string\n&quot;.chop     #=&gt; &quot;string&quot;
 *     &quot;string&quot;.chop       #=&gt; &quot;strin&quot;
 *     &quot;x&quot;.chop.chop       #=&gt; &quot;&quot;
 */

static VALUE
rb_str_chop(VALUE str)
{
    VALUE str2 = rb_str_new5(str, RSTRING_PTR(str), chopped_length(str));
    rb_enc_cr_str_copy_for_substr(str2, str);
    OBJ_INFECT(str2, str);
    return str2;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chop!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>chop!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Processes <em>str</em> as for <tt>String#chop</tt>, returning <em>str</em>,
or <tt>nil</tt> if <em>str</em> is the empty string.  See also
<tt>String#chomp!</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.chop!   -&gt; str or nil
 *
 *  Processes &lt;i&gt;str&lt;/i&gt; as for &lt;code&gt;String#chop&lt;/code&gt;, returning &lt;i&gt;str&lt;/i&gt;,
 *  or &lt;code&gt;nil&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; is the empty string.  See also
 *  &lt;code&gt;String#chomp!&lt;/code&gt;.
 */

static VALUE
rb_str_chop_bang(VALUE str)
{
    str_modify_keep_cr(str);
    if (RSTRING_LEN(str) &gt; 0) {
    long len;
    len = chopped_length(str);
    STR_SET_LEN(str, len);
    RSTRING_PTR(str)[len] = '\0';
    if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
        ENC_CODERANGE_CLEAR(str);
    }
    return str;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chr-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>chr</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a one-character string at the beginning of the string.
</p>
<pre class="code">
   a = &quot;abcde&quot;
   a.chr    #=&gt; &quot;a&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     string.chr    -&gt;  string
 *
 *  Returns a one-character string at the beginning of the string.
 *
 *     a = &quot;abcde&quot;
 *     a.chr    #=&gt; &quot;a&quot;
 */

static VALUE
rb_str_chr(VALUE str)
{
    return rb_str_substr(str, 0, 1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="clear-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>clear</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Makes string empty.
</p>
<pre class="code">
   a = &quot;abcde&quot;
   a.clear    #=&gt; &quot;&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     string.clear    -&gt;  string
 *
 *  Makes string empty.
 *
 *     a = &quot;abcde&quot;
 *     a.clear    #=&gt; &quot;&quot;
 */

static VALUE
rb_str_clear(VALUE str)
{
    str_discard(str);
    STR_SET_EMBED(str);
    STR_SET_EMBED_LEN(str, 0);
    RSTRING_PTR(str)[0] = 0;
    if (rb_enc_asciicompat(STR_ENC_GET(str)))
    ENC_CODERANGE_SET(str, ENC_CODERANGE_7BIT);
    else
    ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="codepoints-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>codepoints</strong> {|integer| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>codepoints</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.each_codepoint {|integer| block }    -> str
</p>
<pre class="code">
   str.each_codepoint                       -&gt; an_enumerator
</pre>
<p>
Passes the <tt>Integer</tt> ordinal of each character in <em>str</em>, also
known as a <em>codepoint</em> when applied to Unicode strings to the given
block.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   &quot;hello\u0639&quot;.each_codepoint {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   104 101 108 108 111 1593</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>codepoints</strong> {|integer| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>integer</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.codepoints {|integer| block }        -&gt; str
 *     str.codepoints                           -&gt; an_enumerator
 *
 *     str.each_codepoint {|integer| block }    -&gt; str
 *     str.each_codepoint                       -&gt; an_enumerator
 *
 *  Passes the &lt;code&gt;Integer&lt;/code&gt; ordinal of each character in &lt;i&gt;str&lt;/i&gt;,
 *  also known as a &lt;i&gt;codepoint&lt;/i&gt; when applied to Unicode strings to the
 *  given block.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     &quot;hello\u0639&quot;.each_codepoint {|c| print c, ' ' }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     104 101 108 108 111 1593
 */

static VALUE
rb_str_each_codepoint(VALUE str)
{
    VALUE orig = str;
    long len;
    int n;
    unsigned int c;
    const char *ptr, *end;
    rb_encoding *enc;

    if (single_byte_optimizable(str)) return rb_str_each_byte(str);
    RETURN_ENUMERATOR(str, 0, 0);
    str = rb_str_new4(str);
    ptr = RSTRING_PTR(str);
    len = RSTRING_LEN(str);
    end = RSTRING_END(str);
    enc = STR_ENC_GET(str);
    while (ptr &lt; end) {
    c = rb_enc_codepoint_len(ptr, end, &amp;n, enc);
    rb_yield(UINT2NUM(c));
    ptr += n;
    }
    return orig;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="concat-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(integer) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(integer) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(obj) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(obj) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Append--Concatenates the given object to <em>str</em>. If the object
is a <tt>Integer</tt>, it is considered as a codepoint, and is converted to
a character before concatenation.
</p>
<pre class="code">
   a = &quot;hello &quot;
   a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
   a.concat(33)   #=&gt; &quot;hello world!&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(integer) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(integer) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>&lt;&lt;</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>concat</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str &lt;&lt; integer       -&gt; str
 *     str.concat(integer)  -&gt; str
 *     str &lt;&lt; obj           -&gt; str
 *     str.concat(obj)      -&gt; str
 *
 *  Append---Concatenates the given object to &lt;i&gt;str&lt;/i&gt;. If the object is a
 *  &lt;code&gt;Integer&lt;/code&gt;, it is considered as a codepoint, and is converted
 *  to a character before concatenation.
 *
 *     a = &quot;hello &quot;
 *     a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
 *     a.concat(33)   #=&gt; &quot;hello world!&quot;
 */

VALUE
rb_str_concat(VALUE str1, VALUE str2)
{
    SIGNED_VALUE lc;

    if (FIXNUM_P(str2)) {
    lc = FIX2LONG(str2);
    if (lc &lt; 0)
        rb_raise(rb_eRangeError, &quot;negative argument&quot;);
    }
    else if (TYPE(str2) == T_BIGNUM) {
    if (!RBIGNUM_SIGN(str2))
        rb_raise(rb_eRangeError, &quot;negative argument&quot;);
    lc = rb_big2ulong(str2);
    }
    else {
    return rb_str_append(str1, str2);
    }
#if SIZEOF_INT &lt; SIZEOF_VALUE
    if ((VALUE)lc &gt; UINT_MAX) {
    rb_raise(rb_eRangeError, &quot;%&quot;PRIuVALUE&quot; out of char range&quot;, lc);
    }
#endif
    {
    rb_encoding *enc = STR_ENC_GET(str1);
    long pos = RSTRING_LEN(str1);
    int cr = ENC_CODERANGE(str1);
    int c, len;

    if ((len = rb_enc_codelen(c = (int)lc, enc)) &lt;= 0) {
        rb_raise(rb_eRangeError, &quot;%u invalid char&quot;, c);
    }
    rb_str_resize(str1, pos+len);
    rb_enc_mbcput(c, RSTRING_PTR(str1)+pos, enc);
    ENC_CODERANGE_SET(str1, cr);
    return str1;
    }
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="count-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>count</strong>([other_str]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Each <em>other_str</em> parameter defines a set of characters to count. 
The intersection of these sets defines the characters to count in
<em>str</em>. Any <em>other_str</em> that starts with a caret (^) is
negated. The sequence c1--c2 means all characters between c1 and c2.
</p>
<pre class="code">
   a = &quot;hello world&quot;
   a.count &quot;lo&quot;            #=&gt; 5
   a.count &quot;lo&quot;, &quot;o&quot;       #=&gt; 2
   a.count &quot;hello&quot;, &quot;^l&quot;   #=&gt; 4
   a.count &quot;ej-m&quot;          #=&gt; 4</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.count([other_str]+)   -&gt; fixnum
 *
 *  Each &lt;i&gt;other_str&lt;/i&gt; parameter defines a set of characters to count.  The
 *  intersection of these sets defines the characters to count in
 *  &lt;i&gt;str&lt;/i&gt;. Any &lt;i&gt;other_str&lt;/i&gt; that starts with a caret (^) is
 *  negated. The sequence c1--c2 means all characters between c1 and c2.
 *
 *     a = &quot;hello world&quot;
 *     a.count &quot;lo&quot;            #=&gt; 5
 *     a.count &quot;lo&quot;, &quot;o&quot;       #=&gt; 2
 *     a.count &quot;hello&quot;, &quot;^l&quot;   #=&gt; 4
 *     a.count &quot;ej-m&quot;          #=&gt; 4
 */

static VALUE
rb_str_count(int argc, VALUE *argv, VALUE str)
{
    char table[256];
    rb_encoding *enc = 0;
    VALUE del = 0, nodel = 0;
    char *s, *send;
    int i;
    int ascompat;

    if (argc &lt; 1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (at least 1)&quot;);
    }
    for (i=0; i&lt;argc; i++) {
    VALUE tstr = argv[i];
    unsigned char c;

    StringValue(tstr);
    enc = rb_enc_check(str, tstr);
    if (argc == 1 &amp;&amp; RSTRING_LEN(tstr) == 1 &amp;&amp; rb_enc_asciicompat(enc) &amp;&amp;
        (c = RSTRING_PTR(tstr)[0]) &lt; 0x80 &amp;&amp; !is_broken_string(str)) {
        int n = 0;

        s = RSTRING_PTR(str);
        if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
        send = RSTRING_END(str);
        while (s &lt; send) {
        if (*(unsigned char*)s++ == c) n++;
        }
        return INT2NUM(n);
    }
    tr_setup_table(tstr, table, i==0, &amp;del, &amp;nodel, enc);
    }

    s = RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
    send = RSTRING_END(str);
    ascompat = rb_enc_asciicompat(enc);
    i = 0;
    while (s &lt; send) {
    unsigned int c;
    int clen;

    if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
        clen = 1;
        if (table[c]) {
        i++;
        }
        s++;
    }
    else {
        c = rb_enc_codepoint_len(s, send, &amp;clen, enc);
        if (tr_find(c, table, del, nodel)) {
        i++;
        }
        s += clen;
    }
    }

    return INT2NUM(i);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="crypt-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>crypt</strong>(other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Applies a one-way cryptographic hash to <em>str</em> by invoking the
standard library function <tt>crypt</tt>. The argument is the salt string,
which should be two characters long, each character drawn from
<tt>[a-zA-Z0-9./]</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.crypt(other_str)   -&gt; new_str
 *
 *  Applies a one-way cryptographic hash to &lt;i&gt;str&lt;/i&gt; by invoking the standard
 *  library function &lt;code&gt;crypt&lt;/code&gt;. The argument is the salt string, which
 *  should be two characters long, each character drawn from
 *  &lt;code&gt;[a-zA-Z0-9./]&lt;/code&gt;.
 */

static VALUE
rb_str_crypt(VALUE str, VALUE salt)
{
    extern char *crypt(const char *, const char *);
    VALUE result;
    const char *s, *saltp;
#ifdef BROKEN_CRYPT
    char salt_8bit_clean[3];
#endif

    StringValue(salt);
    if (RSTRING_LEN(salt) &lt; 2)
    rb_raise(rb_eArgError, &quot;salt too short (need &gt;=2 bytes)&quot;);

    s = RSTRING_PTR(str);
    if (!s) s = &quot;&quot;;
    saltp = RSTRING_PTR(salt);
#ifdef BROKEN_CRYPT
    if (!ISASCII((unsigned char)saltp[0]) || !ISASCII((unsigned char)saltp[1])) {
    salt_8bit_clean[0] = saltp[0] &amp; 0x7f;
    salt_8bit_clean[1] = saltp[1] &amp; 0x7f;
    salt_8bit_clean[2] = '\0';
    saltp = salt_8bit_clean;
    }
#endif
    result = rb_str_new2(crypt(s, saltp));
    OBJ_INFECT(result, str);
    OBJ_INFECT(result, salt);
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="delete-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>delete</strong>([other_str]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with all characters in the intersection of
its arguments deleted. Uses the same rules for building the set of
characters as <tt>String#count</tt>.
</p>
<pre class="code">
   &quot;hello&quot;.delete &quot;l&quot;,&quot;lo&quot;        #=&gt; &quot;heo&quot;
   &quot;hello&quot;.delete &quot;lo&quot;            #=&gt; &quot;he&quot;
   &quot;hello&quot;.delete &quot;aeiou&quot;, &quot;^e&quot;   #=&gt; &quot;hell&quot;
   &quot;hello&quot;.delete &quot;ej-m&quot;          #=&gt; &quot;ho&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.delete([other_str]+)   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with all characters in the intersection of its
 *  arguments deleted. Uses the same rules for building the set of characters as
 *  &lt;code&gt;String#count&lt;/code&gt;.
 *
 *     &quot;hello&quot;.delete &quot;l&quot;,&quot;lo&quot;        #=&gt; &quot;heo&quot;
 *     &quot;hello&quot;.delete &quot;lo&quot;            #=&gt; &quot;he&quot;
 *     &quot;hello&quot;.delete &quot;aeiou&quot;, &quot;^e&quot;   #=&gt; &quot;hell&quot;
 *     &quot;hello&quot;.delete &quot;ej-m&quot;          #=&gt; &quot;ho&quot;
 */

static VALUE
rb_str_delete(int argc, VALUE *argv, VALUE str)
{
    str = rb_str_dup(str);
    rb_str_delete_bang(argc, argv, str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="delete!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>delete!</strong>([other_str]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Performs a <tt>delete</tt> operation in place, returning <em>str</em>, or
<tt>nil</tt> if <em>str</em> was not modified.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.delete!([other_str]+)   -&gt; str or nil
 *
 *  Performs a &lt;code&gt;delete&lt;/code&gt; operation in place, returning &lt;i&gt;str&lt;/i&gt;, or
 *  &lt;code&gt;nil&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; was not modified.
 */

static VALUE
rb_str_delete_bang(int argc, VALUE *argv, VALUE str)
{
    char squeez[256];
    rb_encoding *enc = 0;
    char *s, *send, *t;
    VALUE del = 0, nodel = 0;
    int modify = 0;
    int i, ascompat, cr;

    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    if (argc &lt; 1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (at least 1)&quot;);
    }
    for (i=0; i&lt;argc; i++) {
    VALUE s = argv[i];

    StringValue(s);
    enc = rb_enc_check(str, s);
    tr_setup_table(s, squeez, i==0, &amp;del, &amp;nodel, enc);
    }

    str_modify_keep_cr(str);
    ascompat = rb_enc_asciicompat(enc);
    s = t = RSTRING_PTR(str);
    send = RSTRING_END(str);
    cr = ascompat ? ENC_CODERANGE_7BIT : ENC_CODERANGE_VALID;
    while (s &lt; send) {
    unsigned int c;
    int clen;

    if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
        if (squeez[c]) {
        modify = 1;
        }
        else {
        if (t != s) *t = c;
        t++;
        }
        s++;
    }
    else {
        c = rb_enc_codepoint_len(s, send, &amp;clen, enc);

        if (tr_find(c, squeez, del, nodel)) {
        modify = 1;
        }
        else {
        if (t != s) rb_enc_mbcput(c, t, enc);
        t += clen;
        if (cr == ENC_CODERANGE_7BIT) cr = ENC_CODERANGE_VALID;
        }
        s += clen;
    }
    }
    *t = '\0';
    STR_SET_LEN(str, t - RSTRING_PTR(str));
    ENC_CODERANGE_SET(str, cr);

    if (modify) return str;
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="downcase-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>downcase</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with all uppercase letters replaced with
their lowercase counterparts. The operation is locale
insensitive--only characters ``A&#8217;&#8217; to ``Z&#8217;&#8217;
are affected. Note: case replacement is effective only in ASCII region.
</p>
<pre class="code">
   &quot;hEllO&quot;.downcase   #=&gt; &quot;hello&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.downcase   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with all uppercase letters replaced with their
 *  lowercase counterparts. The operation is locale insensitive---only
 *  characters ``A'' to ``Z'' are affected.
 *  Note: case replacement is effective only in ASCII region.
 *
 *     &quot;hEllO&quot;.downcase   #=&gt; &quot;hello&quot;
 */

static VALUE
rb_str_downcase(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_downcase_bang(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="downcase!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>downcase!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Downcases the contents of <em>str</em>, returning <tt>nil</tt> if no
changes were made. Note: case replacement is effective only in ASCII
region.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.downcase!   -&gt; str or nil
 *
 *  Downcases the contents of &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if no
 *  changes were made.
 *  Note: case replacement is effective only in ASCII region.
 */

static VALUE
rb_str_downcase_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *send;
    int modify = 0;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    rb_str_check_dummy_enc(enc);
    s = RSTRING_PTR(str); send = RSTRING_END(str);
    if (single_byte_optimizable(str)) {
    while (s &lt; send) {
        unsigned int c = *(unsigned char*)s;

        if (rb_enc_isascii(c, enc) &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z') {
        *s = 'a' + (c - 'A');
        modify = 1;
        }
        s++;
    }
    }
    else {
    int ascompat = rb_enc_asciicompat(enc);

    while (s &lt; send) {
        unsigned int c;
        int n;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
        if (rb_enc_isascii(c, enc) &amp;&amp; 'A' &lt;= c &amp;&amp; c &lt;= 'Z') {
            *s = 'a' + (c - 'A');
            modify = 1;
        }
        s++;
        }
        else {
        c = rb_enc_codepoint_len(s, send, &amp;n, enc);
        if (rb_enc_isupper(c, enc)) {
            /* assuming toupper returns codepoint with same size */
            rb_enc_mbcput(rb_enc_tolower(c, enc), s, enc);
            modify = 1;
        }
        s += n;
        }
    }
    }

    if (modify) return str;
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="dump-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>dump</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Produces a version of <em>str</em> with all nonprinting characters replaced
by <tt>\nnn</tt> notation and all special characters escaped.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.dump   -&gt; new_str
 *
 *  Produces a version of &lt;i&gt;str&lt;/i&gt; with all nonprinting characters replaced by
 *  &lt;code&gt;\nnn&lt;/code&gt; notation and all special characters escaped.
 */

VALUE
rb_str_dump(VALUE str)
{
    rb_encoding *enc = rb_enc_get(str);
    long len;
    const char *p, *pend;
    char *q, *qend;
    VALUE result;
    int u8 = (enc == rb_utf8_encoding());

    len = 2;            /* &quot;&quot; */
    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    while (p &lt; pend) {
    unsigned char c = *p++;
    switch (c) {
      case '&quot;':  case '\\':
      case '\n': case '\r':
      case '\t': case '\f':
      case '\013': case '\010': case '\007': case '\033':
        len += 2;
        break;

      case '#':
        len += IS_EVSTR(p, pend) ? 2 : 1;
        break;

      default:
        if (ISPRINT(c)) {
        len++;
        }
        else {
        if (u8) { /* \u{NN} */
            char buf[32];
            int n = rb_enc_precise_mbclen(p-1, pend, enc);
            if (MBCLEN_CHARFOUND_P(n)) {
            int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
            sprintf(buf, &quot;%x&quot;, cc);
            len += strlen(buf)+4;
            p += MBCLEN_CHARFOUND_LEN(n)-1;
            break;
            }
        }
        len += 4; /* \xNN */
        }
        break;
    }
    }
    if (!rb_enc_asciicompat(enc)) {
    len += 19;     /* &quot;.force_encoding('')&quot; */
    len += strlen(enc-&gt;name);
    }

    result = rb_str_new5(str, 0, len);
    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    q = RSTRING_PTR(result); qend = q + len + 1;

    *q++ = '&quot;';
    while (p &lt; pend) {
    unsigned char c = *p++;

    if (c == '&quot;' || c == '\\') {
        *q++ = '\\';
        *q++ = c;
    }
    else if (c == '#') {
        if (IS_EVSTR(p, pend)) *q++ = '\\';
        *q++ = '#';
    }
    else if (c == '\n') {
        *q++ = '\\';
        *q++ = 'n';
    }
    else if (c == '\r') {
        *q++ = '\\';
        *q++ = 'r';
    }
    else if (c == '\t') {
        *q++ = '\\';
        *q++ = 't';
    }
    else if (c == '\f') {
        *q++ = '\\';
        *q++ = 'f';
    }
    else if (c == '\013') {
        *q++ = '\\';
        *q++ = 'v';
    }
    else if (c == '\010') {
        *q++ = '\\';
        *q++ = 'b';
    }
    else if (c == '\007') {
        *q++ = '\\';
        *q++ = 'a';
    }
    else if (c == '\033') {
        *q++ = '\\';
        *q++ = 'e';
    }
    else if (ISPRINT(c)) {
        *q++ = c;
    }
    else {
        *q++ = '\\';
        if (u8) {
        int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
        if (MBCLEN_CHARFOUND_P(n)) {
            int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
            p += n;
            snprintf(q, qend-q, &quot;u{%x}&quot;, cc);
            q += strlen(q);
            continue;
        }
        }
        snprintf(q, qend-q, &quot;x%02X&quot;, c);
        q += 3;
    }
    }
    *q++ = '&quot;';
    *q = '\0';
    if (!rb_enc_asciicompat(enc)) {
    snprintf(q, qend-q, &quot;.force_encoding(\&quot;%s\&quot;)&quot;, enc-&gt;name);
    enc = rb_ascii8bit_encoding();
    }
    OBJ_INFECT(result, str);
    /* result from dump is ASCII */
    rb_enc_associate(result, enc);
    ENC_CODERANGE_SET(result, ENC_CODERANGE_7BIT);
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_byte-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>bytes</strong> {|fixnum| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>bytes</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.each_byte {|fixnum| block }    -> str
</p>
<pre class="code">
   str.each_byte                      -&gt; an_enumerator
</pre>
<p>
Passes each byte in <em>str</em> to the given block, or returns an
enumerator if no block is given.
</p>
<pre class="code">
   &quot;hello&quot;.each_byte {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   104 101 108 108 111</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>bytes</strong> {|fixnum| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>fixnum</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.bytes {|fixnum| block }        -&gt; str
 *     str.bytes                          -&gt; an_enumerator
 *
 *     str.each_byte {|fixnum| block }    -&gt; str
 *     str.each_byte                      -&gt; an_enumerator
 *
 *  Passes each byte in &lt;i&gt;str&lt;/i&gt; to the given block, or returns
 *  an enumerator if no block is given.
 *
 *     &quot;hello&quot;.each_byte {|c| print c, ' ' }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     104 101 108 108 111
 */

static VALUE
rb_str_each_byte(VALUE str)
{
    long i;

    RETURN_ENUMERATOR(str, 0, 0);
    for (i=0; i&lt;RSTRING_LEN(str); i++) {
    rb_yield(INT2FIX(RSTRING_PTR(str)[i] &amp; 0xff));
    }
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_char-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>chars</strong> {|cstr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chars</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.each_char {|cstr| block }    -> str
</p>
<pre class="code">
   str.each_char                    -&gt; an_enumerator
</pre>
<p>
Passes each character in <em>str</em> to the given block, or returns an
enumerator if no block is given.
</p>
<pre class="code">
   &quot;hello&quot;.each_char {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   h e l l o</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>chars</strong> {|cstr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>cstr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.chars {|cstr| block }        -&gt; str
 *     str.chars                        -&gt; an_enumerator
 *
 *     str.each_char {|cstr| block }    -&gt; str
 *     str.each_char                    -&gt; an_enumerator
 *
 *  Passes each character in &lt;i&gt;str&lt;/i&gt; to the given block, or returns
 *  an enumerator if no block is given.
 *
 *     &quot;hello&quot;.each_char {|c| print c, ' ' }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     h e l l o
 */

static VALUE
rb_str_each_char(VALUE str)
{
    VALUE orig = str;
    long i, len, n;
    const char *ptr;
    rb_encoding *enc;

    RETURN_ENUMERATOR(str, 0, 0);
    str = rb_str_new4(str);
    ptr = RSTRING_PTR(str);
    len = RSTRING_LEN(str);
    enc = rb_enc_get(str);
    switch (ENC_CODERANGE(str)) {
      case ENC_CODERANGE_VALID:
      case ENC_CODERANGE_7BIT:
    for (i = 0; i &lt; len; i += n) {
        n = rb_enc_fast_mbclen(ptr + i, ptr + len, enc);
        rb_yield(rb_str_subseq(str, i, n));
    }
    break;
      default:
    for (i = 0; i &lt; len; i += n) {
        n = rb_enc_mbclen(ptr + i, ptr + len, enc);
        rb_yield(rb_str_subseq(str, i, n));
    }
    }
    return orig;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_codepoint-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>codepoints</strong> {|integer| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>codepoints</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.each_codepoint {|integer| block }    -> str
</p>
<pre class="code">
   str.each_codepoint                       -&gt; an_enumerator
</pre>
<p>
Passes the <tt>Integer</tt> ordinal of each character in <em>str</em>, also
known as a <em>codepoint</em> when applied to Unicode strings to the given
block.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   &quot;hello\u0639&quot;.each_codepoint {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   104 101 108 108 111 1593</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>codepoints</strong> {|integer| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>integer</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.codepoints {|integer| block }        -&gt; str
 *     str.codepoints                           -&gt; an_enumerator
 *
 *     str.each_codepoint {|integer| block }    -&gt; str
 *     str.each_codepoint                       -&gt; an_enumerator
 *
 *  Passes the &lt;code&gt;Integer&lt;/code&gt; ordinal of each character in &lt;i&gt;str&lt;/i&gt;,
 *  also known as a &lt;i&gt;codepoint&lt;/i&gt; when applied to Unicode strings to the
 *  given block.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     &quot;hello\u0639&quot;.each_codepoint {|c| print c, ' ' }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     104 101 108 108 111 1593
 */

static VALUE
rb_str_each_codepoint(VALUE str)
{
    VALUE orig = str;
    long len;
    int n;
    unsigned int c;
    const char *ptr, *end;
    rb_encoding *enc;

    if (single_byte_optimizable(str)) return rb_str_each_byte(str);
    RETURN_ENUMERATOR(str, 0, 0);
    str = rb_str_new4(str);
    ptr = RSTRING_PTR(str);
    len = RSTRING_LEN(str);
    end = RSTRING_END(str);
    enc = STR_ENC_GET(str);
    while (ptr &lt; end) {
    c = rb_enc_codepoint_len(ptr, end, &amp;n, enc);
    rb_yield(UINT2NUM(c));
    ptr += n;
    }
    return orig;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_line-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>each_line</strong>(separator = $/) {|substr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_line</strong>(separator = $/) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.lines(separator=$/) {|substr| block }       -> str
</p>
<pre class="code">
   str.lines(separator=$/)                         -&gt; an_enumerator
</pre>
<p>
Splits <em>str</em> using the supplied parameter as the record separator
(<tt>$/</tt> by default), passing each substring in turn to the supplied
block. If a zero-length record separator is supplied, the string is split
into paragraphs delimited by multiple successive newlines.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   print &quot;Example one\n&quot;
   &quot;hello\nworld&quot;.each_line {|s| p s}
   print &quot;Example two\n&quot;
   &quot;hello\nworld&quot;.each_line('l') {|s| p s}
   print &quot;Example three\n&quot;
   &quot;hello\n\n\nworld&quot;.each_line('') {|s| p s}
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   Example one
   &quot;hello\n&quot;
   &quot;world&quot;
   Example two
   &quot;hel&quot;
   &quot;l&quot;
   &quot;o\nworl&quot;
   &quot;d&quot;
   Example three
   &quot;hello\n\n\n&quot;
   &quot;world&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>each_line</strong>(separator = $/) {|substr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>substr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.each_line(separator=$/) {|substr| block }   -&gt; str
 *     str.each_line(separator=$/)                     -&gt; an_enumerator
 *
 *     str.lines(separator=$/) {|substr| block }       -&gt; str
 *     str.lines(separator=$/)                         -&gt; an_enumerator
 *
 *  Splits &lt;i&gt;str&lt;/i&gt; using the supplied parameter as the record separator
 *  (&lt;code&gt;$/&lt;/code&gt; by default), passing each substring in turn to the supplied
 *  block. If a zero-length record separator is supplied, the string is split
 *  into paragraphs delimited by multiple successive newlines.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     print &quot;Example one\n&quot;
 *     &quot;hello\nworld&quot;.each_line {|s| p s}
 *     print &quot;Example two\n&quot;
 *     &quot;hello\nworld&quot;.each_line('l') {|s| p s}
 *     print &quot;Example three\n&quot;
 *     &quot;hello\n\n\nworld&quot;.each_line('') {|s| p s}
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Example one
 *     &quot;hello\n&quot;
 *     &quot;world&quot;
 *     Example two
 *     &quot;hel&quot;
 *     &quot;l&quot;
 *     &quot;o\nworl&quot;
 *     &quot;d&quot;
 *     Example three
 *     &quot;hello\n\n\n&quot;
 *     &quot;world&quot;
 */

static VALUE
rb_str_each_line(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    VALUE rs;
    unsigned int newline;
    const char *p, *pend, *s, *ptr;
    long len, rslen;
    VALUE line;
    int n;
    VALUE orig = str;

    if (argc == 0) {
    rs = rb_rs;
    }
    else {
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs);
    }
    RETURN_ENUMERATOR(str, argc, argv);
    if (NIL_P(rs)) {
    rb_yield(str);
    return orig;
    }
    str = rb_str_new4(str);
    ptr = p = s = RSTRING_PTR(str);
    pend = p + RSTRING_LEN(str);
    len = RSTRING_LEN(str);
    StringValue(rs);
    if (rs == rb_default_rs) {
    enc = rb_enc_get(str);
    while (p &lt; pend) {
        char *p0;

        p = memchr(p, '\n', pend - p);
        if (!p) break;
        p0 = rb_enc_left_char_head(s, p, pend, enc);
        if (!rb_enc_is_newline(p0, pend, enc)) {
        p++;
        continue;
        }
        p = p0 + rb_enc_mbclen(p0, pend, enc);
        line = rb_str_new5(str, s, p - s);
        OBJ_INFECT(line, str);
        rb_enc_cr_str_copy_for_substr(line, str);
        rb_yield(line);
        str_mod_check(str, ptr, len);
        s = p;
    }
    goto finish;
    }

    enc = rb_enc_check(str, rs);
    rslen = RSTRING_LEN(rs);
    if (rslen == 0) {
    newline = '\n';
    }
    else {
    newline = rb_enc_codepoint(RSTRING_PTR(rs), RSTRING_END(rs), enc);
    }

    while (p &lt; pend) {
    unsigned int c = rb_enc_codepoint_len(p, pend, &amp;n, enc);

      again:
    if (rslen == 0 &amp;&amp; c == newline) {
        p += n;
        if (p &lt; pend &amp;&amp; (c = rb_enc_codepoint_len(p, pend, &amp;n, enc)) != newline) {
        goto again;
        }
        while (p &lt; pend &amp;&amp; rb_enc_codepoint(p, pend, enc) == newline) {
        p += n;
        }
        p -= n;
    }
    if (c == newline &amp;&amp;
        (rslen &lt;= 1 || memcmp(RSTRING_PTR(rs), p, rslen) == 0)) {
        line = rb_str_new5(str, s, p - s + (rslen ? rslen : n));
        OBJ_INFECT(line, str);
        rb_enc_cr_str_copy_for_substr(line, str);
        rb_yield(line);
        str_mod_check(str, ptr, len);
        s = p + (rslen ? rslen : n);
    }
    p += n;
    }

  finish:
    if (s != pend) {
    line = rb_str_new5(str, s, pend - s);
    OBJ_INFECT(line, str);
    rb_enc_cr_str_copy_for_substr(line, str);
    rb_yield(line);
    }

    return orig;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="empty?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>empty?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <em>str</em> has a length of zero.
</p>
<pre class="code">
   &quot;hello&quot;.empty?   #=&gt; false
   &quot;&quot;.empty?        #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.empty?   -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; has a length of zero.
 *
 *     &quot;hello&quot;.empty?   #=&gt; false
 *     &quot;&quot;.empty?        #=&gt; true
 */

static VALUE
rb_str_empty(VALUE str)
{
    if (RSTRING_LEN(str) == 0)
    return Qtrue;
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="encode-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode</strong>(encoding[, options]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode</strong>(dst_encoding, src_encoding[, options]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode</strong>([options]) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
The first form returns a copy of <em>str</em> transcoded to encoding
<tt>encoding</tt>. The second form returns a copy of <em>str</em>
transcoded from src_encoding to dst_encoding. The last form returns a copy
of <em>str</em> transcoded to <tt>Encoding.default_internal</tt>. By
default, the first and second form raise Encoding::UndefinedConversionError
for characters that are undefined in the destination encoding, and
Encoding::InvalidByteSequenceError for invalid byte sequences in the source
encoding. The last form by default does not raise exceptions but uses
replacement strings. The <tt>options</tt> Hash gives details for
conversion.
</p>
<h3>options</h3>
<p>
The hash <tt>options</tt> can have the following keys:
</p>
<table>
<tr><td valign="top">:invalid </td><td><p>
If the value is <tt>:replace</tt>, <tt>#encode</tt> replaces invalid byte
sequences in <tt>str</tt> with the replacement character. The default is to
raise the exception
</p>
</td></tr>
<tr><td valign="top">:undef </td><td><p>
If the value is <tt>:replace</tt>, <tt>#encode</tt> replaces characters
which are undefined in the destination encoding with the replacement
character.
</p>
</td></tr>
<tr><td valign="top">:replace </td><td><p>
Sets the replacement string to the value. The default replacement string is
&#8220;\uFFFD&#8221; for Unicode encoding forms, and &#8220;?&#8221;
otherwise.
</p>
</td></tr>
<tr><td valign="top">:fallback </td><td><p>
Sets the replacement string by the hash for undefined character. Its key is
a such undefined character encoded in source encoding of current
transcoder. Its value can be any encoding until it can be converted into
the destination encoding of the transcoder.
</p>
</td></tr>
<tr><td valign="top">:xml </td><td><p>
The value must be <tt>:text</tt> or <tt>:attr</tt>. If the value is
<tt>:text</tt> <tt>#encode</tt> replaces undefined characters with their
(upper-case hexadecimal) numeric character references. &#8217;&amp;&#8217;,
&#8217;<&#8217;, and &#8217;>&#8217; are converted to
&#8220;&amp;amp;&#8221;, &#8220;&amp;lt;&#8221;, and
&#8220;&amp;gt;&#8221;, respectively. If the value is <tt>:attr</tt>,
<tt>#encode</tt> also quotes the replacement result (using
&#8217;&#8221;&#8217;), and replaces &#8217;&#8221;&#8217; with
&#8220;&amp;quot;&#8221;.
</p>
</td></tr>
<tr><td valign="top">:cr_newline </td><td><p>
Replaces LF (&#8220;\n&#8221;) with CR (&#8220;\r&#8221;) if value is true.
</p>
</td></tr>
<tr><td valign="top">:crlf_newline </td><td><p>
Replaces LF (&#8220;\n&#8221;) with CRLF (&#8220;\r\n&#8221;) if value is
true.
</p>
</td></tr>
<tr><td valign="top">:universal_newline </td><td><p>
Replaces CRLF (&#8220;\r\n&#8221;) and CR (&#8220;\r&#8221;) with LF
(&#8220;\n&#8221;) if value is true.
</p>
</td></tr>
</table>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode</strong>(encoding[, options]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode</strong>(dst_encoding, src_encoding[, options]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode</strong>([options]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 *  call-seq:
 *     str.encode(encoding [, options] )   -&gt; str
 *     str.encode(dst_encoding, src_encoding [, options] )   -&gt; str
 *     str.encode([options])   -&gt; str
 *
 *  The first form returns a copy of &lt;i&gt;str&lt;/i&gt; transcoded
 *  to encoding +encoding+.
 *  The second form returns a copy of &lt;i&gt;str&lt;/i&gt; transcoded
 *  from src_encoding to dst_encoding.
 *  The last form returns a copy of &lt;i&gt;str&lt;/i&gt; transcoded to
 *  &lt;code&gt;Encoding.default_internal&lt;/code&gt;.
 *  By default, the first and second form raise
 *  Encoding::UndefinedConversionError for characters that are
 *  undefined in the destination encoding, and
 *  Encoding::InvalidByteSequenceError for invalid byte sequences
 *  in the source encoding. The last form by default does not raise
 *  exceptions but uses replacement strings.
 *  The &lt;code&gt;options&lt;/code&gt; Hash gives details for conversion.
 *
 *  === options
 *  The hash &lt;code&gt;options&lt;/code&gt; can have the following keys:
 *  :invalid ::
 *    If the value is &lt;code&gt;:replace&lt;/code&gt;, &lt;code&gt;#encode&lt;/code&gt; replaces
 *    invalid byte sequences in &lt;code&gt;str&lt;/code&gt; with the replacement character.
 *    The default is to raise the exception
 *  :undef ::
 *    If the value is &lt;code&gt;:replace&lt;/code&gt;, &lt;code&gt;#encode&lt;/code&gt; replaces
 *    characters which are undefined in the destination encoding with
 *    the replacement character.
 *  :replace ::
 *    Sets the replacement string to the value. The default replacement
 *    string is &quot;\uFFFD&quot; for Unicode encoding forms, and &quot;?&quot; otherwise.
 *  :fallback ::
 *    Sets the replacement string by the hash for undefined character.
 *    Its key is a such undefined character encoded in source encoding
 *    of current transcoder. Its value can be any encoding until it
 *    can be converted into the destination encoding of the transcoder.
 *  :xml ::
 *    The value must be &lt;code&gt;:text&lt;/code&gt; or &lt;code&gt;:attr&lt;/code&gt;.
 *    If the value is &lt;code&gt;:text&lt;/code&gt; &lt;code&gt;#encode&lt;/code&gt; replaces
 *    undefined characters with their (upper-case hexadecimal) numeric
 *    character references. '&amp;', '&lt;', and '&gt;' are converted to &quot;&amp;amp;&quot;,
 *    &quot;&amp;lt;&quot;, and &quot;&amp;gt;&quot;, respectively.
 *    If the value is &lt;code&gt;:attr&lt;/code&gt;, &lt;code&gt;#encode&lt;/code&gt; also quotes
 *    the replacement result (using '&quot;'), and replaces '&quot;' with &quot;&amp;quot;&quot;.
 *  :cr_newline ::
 *    Replaces LF (&quot;\n&quot;) with CR (&quot;\r&quot;) if value is true.
 *  :crlf_newline ::
 *    Replaces LF (&quot;\n&quot;) with CRLF (&quot;\r\n&quot;) if value is true.
 *  :universal_newline ::
 *    Replaces CRLF (&quot;\r\n&quot;) and CR (&quot;\r&quot;) with LF (&quot;\n&quot;) if value is true.
 */

static VALUE
str_encode(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr = str;
    int encidx = str_transcode(argc, argv, &amp;newstr);

    if (encidx &lt; 0) return rb_str_dup(str);
    if (newstr == str) {
    newstr = rb_str_dup(str);
    }
    else {
    RBASIC(newstr)-&gt;klass = rb_obj_class(str);
    }
    return str_encode_associate(newstr, encidx);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="encode!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode!</strong>(encoding[, options]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode!</strong>(dst_encoding, src_encoding[, options]) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
The first form transcodes the contents of <em>str</em> from str.encoding to
<tt>encoding</tt>. The second form transcodes the contents of <em>str</em>
from src_encoding to dst_encoding. The options Hash gives details for
conversion. See String#encode for details. Returns the string even if no
changes were made.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode!</strong>(encoding[, options]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>encode!</strong>(dst_encoding, src_encoding[, options]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'transcode.c'</span>

/*
 *  call-seq:
 *     str.encode!(encoding [, options] )   -&gt; str
 *     str.encode!(dst_encoding, src_encoding [, options] )   -&gt; str
 *
 *  The first form transcodes the contents of &lt;i&gt;str&lt;/i&gt; from
 *  str.encoding to +encoding+.
 *  The second form transcodes the contents of &lt;i&gt;str&lt;/i&gt; from
 *  src_encoding to dst_encoding.
 *  The options Hash gives details for conversion. See String#encode
 *  for details.
 *  Returns the string even if no changes were made.
 */

static VALUE
str_encode_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr;
    int encidx;

    if (OBJ_FROZEN(str)) { /* in future, may use str_frozen_check from string.c, but that's currently static */
    rb_raise(rb_eRuntimeError, &quot;string frozen&quot;);
    }

    newstr = str;
    encidx = str_transcode(argc, argv, &amp;newstr);

    if (encidx &lt; 0) return str;
    rb_str_shared_replace(str, newstr);
    return str_encode_associate(str, encidx);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>encoding</strong> 
  

  
</p>
</div>
    
      <div class="method_details ">
  <p class="signature " id="end_with?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>end_with?</strong>([suffix]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true if <em>str</em> ends with a suffix given.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.end_with?([suffix]+)   -&gt; true or false
 *
 *  Returns true if &lt;i&gt;str&lt;/i&gt; ends with a suffix given.
 */

static VALUE
rb_str_end_with(int argc, VALUE *argv, VALUE str)
{
    int i;
    char *p, *s, *e;
    rb_encoding *enc;

    for (i=0; i&lt;argc; i++) {
    VALUE tmp = rb_check_string_type(argv[i]);
    if (NIL_P(tmp)) continue;
    enc = rb_enc_check(str, tmp);
    if (RSTRING_LEN(str) &lt; RSTRING_LEN(tmp)) continue;
    p = RSTRING_PTR(str);
        e = p + RSTRING_LEN(str);
    s = e - RSTRING_LEN(tmp);
    if (rb_enc_left_char_head(p, s, e, enc) != s)
        continue;
    if (memcmp(s, RSTRING_PTR(tmp), RSTRING_LEN(tmp)) == 0)
        return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eql?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>eql?</strong>(other) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Two strings are equal if they have the same length and content.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 * call-seq:
 *   str.eql?(other)   -&gt; true or false
 *
 * Two strings are equal if they have the same length and content.
 */

static VALUE
rb_str_eql(VALUE str1, VALUE str2)
{
    if (TYPE(str2) != T_STRING) return Qfalse;
    return str_eql(str1, str2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="force_encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>force_encoding</strong>(encoding) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Changes the encoding to <tt>encoding</tt> and returns self.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.force_encoding(encoding)   -&gt; str
 *
 *  Changes the encoding to +encoding+ and returns self.
 */

static VALUE
rb_str_force_encoding(VALUE str, VALUE enc)
{
    str_modifiable(str);
    rb_enc_associate(str, rb_to_encoding(enc));
    ENC_CODERANGE_CLEAR(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getbyte-instance_method">
  
    - (<tt>0 .. 255</tt>) <strong>getbyte</strong>(index) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
returns the <em>index</em>th byte as an integer.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0 .. 255</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.getbyte(index)          -&gt; 0 .. 255
 *
 *  returns the &lt;i&gt;index&lt;/i&gt;th byte as an integer.
 */
static VALUE
rb_str_getbyte(VALUE str, VALUE index)
{
    long pos = NUM2LONG(index);

    if (pos &lt; 0)
        pos += RSTRING_LEN(str);
    if (pos &lt; 0 ||  RSTRING_LEN(str) &lt;= pos)
        return Qnil;

    return INT2FIX((unsigned char)RSTRING_PTR(str)[pos]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="gsub-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>gsub</strong>(pattern, replacement) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>gsub</strong>(pattern, hash) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>gsub</strong>(pattern) {|match| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>gsub</strong>(pattern) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with the <em>all</em> occurrences of
<em>pattern</em> substituted for the second argument. The <em>pattern</em>
is typically a <tt>Regexp</tt>; if given as a <tt>String</tt>, any regular
expression metacharacters it contains will be interpreted literally, e.g.
<tt>'\\d'</tt> will match a backlash followed by &#8216;d&#8217;, instead
of a digit.
</p>
<p>
If <em>replacement</em> is a <tt>String</tt> it will be substituted for the
matched text. It may contain back-references to the pattern&#8217;s capture
groups of the form <tt>\\d</tt>, where <em>d</em> is a group number, or
<tt>\\k&lt;n&gt;</tt>, where <em>n</em> is a group name. If it is a
double-quoted string, both back-references must be preceded by an
additional backslash. However, within <em>replacement</em> the special
match variables, such as <tt>&amp;$</tt>, will not refer to the current
match.
</p>
<p>
If the second argument is a <tt>Hash</tt>, and the matched text is one of
its keys, the corresponding value is the replacement string.
</p>
<p>
In the block form, the current match string is passed in as a parameter,
and variables such as <tt>$1</tt>, <tt>$2</tt>, <tt>$`</tt>,
<tt>$&amp;</tt>, and <tt>$'</tt> will be set appropriately. The value
returned by the block will be substituted for the match on each call.
</p>
<p>
The result inherits any tainting in the original string or any supplied
replacement string.
</p>
<p>
When neither a block nor a second argument is supplied, an
<tt>Enumerator</tt> is returned.
</p>
<pre class="code">
   &quot;hello&quot;.gsub(/[aeiou]/, '*')                  #=&gt; &quot;h*ll*&quot;
   &quot;hello&quot;.gsub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; &quot;h&lt;e&gt;ll&lt;o&gt;&quot;
   &quot;hello&quot;.gsub(/./) {|s| s.ord.to_s + ' '}      #=&gt; &quot;104 101 108 108 111 &quot;
   &quot;hello&quot;.gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}')  #=&gt; &quot;h{e}ll{o}&quot;
   'hello'.gsub(/[eo]/, 'e' =&gt; 3, 'o' =&gt; '*')    #=&gt; &quot;h3ll*&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>gsub</strong>(pattern, replacement) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>gsub</strong>(pattern, hash) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>gsub</strong>(pattern) {|match| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>match</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.gsub(pattern, replacement)       -&gt; new_str
 *     str.gsub(pattern, hash)              -&gt; new_str
 *     str.gsub(pattern) {|match| block }   -&gt; new_str
 *     str.gsub(pattern)                    -&gt; enumerator
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with the &lt;em&gt;all&lt;/em&gt; occurrences of
 *  &lt;i&gt;pattern&lt;/i&gt; substituted for the second argument. The &lt;i&gt;pattern&lt;/i&gt; is
 *  typically a &lt;code&gt;Regexp&lt;/code&gt;; if given as a &lt;code&gt;String&lt;/code&gt;, any
 *  regular expression metacharacters it contains will be interpreted
 *  literally, e.g. &lt;code&gt;'\\\d'&lt;/code&gt; will match a backlash followed by 'd',
 *  instead of a digit.
 *
 *  If &lt;i&gt;replacement&lt;/i&gt; is a &lt;code&gt;String&lt;/code&gt; it will be substituted for
 *  the matched text. It may contain back-references to the pattern's capture
 *  groups of the form &lt;code&gt;\\\d&lt;/code&gt;, where &lt;i&gt;d&lt;/i&gt; is a group number, or
 *  &lt;code&gt;\\\k&lt;n&gt;&lt;/code&gt;, where &lt;i&gt;n&lt;/i&gt; is a group name. If it is a
 *  double-quoted string, both back-references must be preceded by an
 *  additional backslash. However, within &lt;i&gt;replacement&lt;/i&gt; the special match
 *  variables, such as &lt;code&gt;&amp;$&lt;/code&gt;, will not refer to the current match.
 *
 *  If the second argument is a &lt;code&gt;Hash&lt;/code&gt;, and the matched text is one
 *  of its keys, the corresponding value is the replacement string.
 *
 *  In the block form, the current match string is passed in as a parameter,
 *  and variables such as &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt;,
 *  &lt;code&gt;$&amp;&lt;/code&gt;, and &lt;code&gt;$'&lt;/code&gt; will be set appropriately. The value
 *  returned by the block will be substituted for the match on each call.
 *
 *  The result inherits any tainting in the original string or any supplied
 *  replacement string.
 *
 *  When neither a block nor a second argument is supplied, an
 *  &lt;code&gt;Enumerator&lt;/code&gt; is returned.
 *
 *     &quot;hello&quot;.gsub(/[aeiou]/, '*')                  #=&gt; &quot;h*ll*&quot;
 *     &quot;hello&quot;.gsub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; &quot;h&lt;e&gt;ll&lt;o&gt;&quot;
 *     &quot;hello&quot;.gsub(/./) {|s| s.ord.to_s + ' '}      #=&gt; &quot;104 101 108 108 111 &quot;
 *     &quot;hello&quot;.gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}')  #=&gt; &quot;h{e}ll{o}&quot;
 *     'hello'.gsub(/[eo]/, 'e' =&gt; 3, 'o' =&gt; '*')    #=&gt; &quot;h3ll*&quot;
 */

static VALUE
rb_str_gsub(int argc, VALUE *argv, VALUE str)
{
    return str_gsub(argc, argv, str, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="gsub!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gsub!</strong>(pattern, replacement) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gsub!</strong>(pattern) {|match| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>gsub!</strong>(pattern) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Performs the substitutions of <tt>String#gsub</tt> in place, returning
<em>str</em>, or <tt>nil</tt> if no substitutions were performed. If no
block and no <em>replacement</em> is given, an enumerator is returned
instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gsub!</strong>(pattern, replacement) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gsub!</strong>(pattern) {|match| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>match</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.gsub!(pattern, replacement)        -&gt; str or nil
 *     str.gsub!(pattern) {|match| block }    -&gt; str or nil
 *     str.gsub!(pattern)                     -&gt; an_enumerator
 *
 *  Performs the substitutions of &lt;code&gt;String#gsub&lt;/code&gt; in place, returning
 *  &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no substitutions were performed.
 *  If no block and no &lt;i&gt;replacement&lt;/i&gt; is given, an enumerator is returned instead.
 */

static VALUE
rb_str_gsub_bang(int argc, VALUE *argv, VALUE str)
{
    str_modify_keep_cr(str);
    return str_gsub(argc, argv, str, 1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="hash-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>hash</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return a hash based on the string&#8217;s length and content.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 * call-seq:
 *    str.hash   -&gt; fixnum
 *
 * Return a hash based on the string's length and content.
 */

static VALUE
rb_str_hash_m(VALUE str)
{
    st_index_t hval = rb_str_hash(str);
    return INT2FIX(hval);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="hex-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>hex</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Treats leading characters from <em>str</em> as a string of hexadecimal
digits (with an optional sign and an optional <tt>0x</tt>) and returns the
corresponding number. Zero is returned on error.
</p>
<pre class="code">
   &quot;0x0a&quot;.hex     #=&gt; 10
   &quot;-1234&quot;.hex    #=&gt; -4660
   &quot;0&quot;.hex        #=&gt; 0
   &quot;wombat&quot;.hex   #=&gt; 0</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.hex   -&gt; integer
 *
 *  Treats leading characters from &lt;i&gt;str&lt;/i&gt; as a string of hexadecimal digits
 *  (with an optional sign and an optional &lt;code&gt;0x&lt;/code&gt;) and returns the
 *  corresponding number. Zero is returned on error.
 *
 *     &quot;0x0a&quot;.hex     #=&gt; 10
 *     &quot;-1234&quot;.hex    #=&gt; -4660
 *     &quot;0&quot;.hex        #=&gt; 0
 *     &quot;wombat&quot;.hex   #=&gt; 0
 */

static VALUE
rb_str_hex(VALUE str)
{
    rb_encoding *enc = rb_enc_get(str);

    if (!rb_enc_asciicompat(enc)) {
    rb_raise(rb_eEncCompatError, &quot;ASCII incompatible encoding: %s&quot;, rb_enc_name(enc));
    }
    return rb_str_to_inum(str, 16, FALSE);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="include?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>include?</strong>(other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <em>str</em> contains the given string or
character.
</p>
<pre class="code">
   &quot;hello&quot;.include? &quot;lo&quot;   #=&gt; true
   &quot;hello&quot;.include? &quot;ol&quot;   #=&gt; false
   &quot;hello&quot;.include? ?h     #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.include? other_str   -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; contains the given string or
 *  character.
 *
 *     &quot;hello&quot;.include? &quot;lo&quot;   #=&gt; true
 *     &quot;hello&quot;.include? &quot;ol&quot;   #=&gt; false
 *     &quot;hello&quot;.include? ?h     #=&gt; true
 */

static VALUE
rb_str_include(VALUE str, VALUE arg)
{
    long i;

    StringValue(arg);
    i = rb_str_index(str, arg, 0);

    if (i == -1) return Qfalse;
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="index-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>index</strong>(substring[, offset]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>index</strong>(regexp[, offset]) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the index of the first occurrence of the given <em>substring</em>
or pattern (<em>regexp</em>) in <em>str</em>. Returns <tt>nil</tt> if not
found. If the second parameter is present, it specifies the position in the
string to begin the search.
</p>
<pre class="code">
   &quot;hello&quot;.index('e')             #=&gt; 1
   &quot;hello&quot;.index('lo')            #=&gt; 3
   &quot;hello&quot;.index('a')             #=&gt; nil
   &quot;hello&quot;.index(?e)              #=&gt; 1
   &quot;hello&quot;.index(/[aeiou]/, -3)   #=&gt; 4</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>index</strong>(substring[, offset]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>index</strong>(regexp[, offset]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.index(substring [, offset])   -&gt; fixnum or nil
 *     str.index(regexp [, offset])      -&gt; fixnum or nil
 *
 *  Returns the index of the first occurrence of the given &lt;i&gt;substring&lt;/i&gt; or
 *  pattern (&lt;i&gt;regexp&lt;/i&gt;) in &lt;i&gt;str&lt;/i&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if not
 *  found. If the second parameter is present, it specifies the position in the
 *  string to begin the search.
 *
 *     &quot;hello&quot;.index('e')             #=&gt; 1
 *     &quot;hello&quot;.index('lo')            #=&gt; 3
 *     &quot;hello&quot;.index('a')             #=&gt; nil
 *     &quot;hello&quot;.index(?e)              #=&gt; 1
 *     &quot;hello&quot;.index(/[aeiou]/, -3)   #=&gt; 4
 */

static VALUE
rb_str_index_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;initpos) == 2) {
    pos = NUM2LONG(initpos);
    }
    else {
    pos = 0;
    }
    if (pos &lt; 0) {
    pos += str_strlen(str, STR_ENC_GET(str));
    if (pos &lt; 0) {
        if (TYPE(sub) == T_REGEXP) {
        rb_backref_set(Qnil);
        }
        return Qnil;
    }
    }

    switch (TYPE(sub)) {
      case T_REGEXP:
    if (pos &gt; str_strlen(str, STR_ENC_GET(str)))
        return Qnil;
    pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
             rb_enc_check(str, sub), single_byte_optimizable(str));

    pos = rb_reg_search(sub, str, pos, 0);
    pos = rb_str_sublen(str, pos);
    break;

      default: {
    VALUE tmp;

    tmp = rb_check_string_type(sub);
    if (NIL_P(tmp)) {
        rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
             rb_obj_classname(sub));
    }
    sub = tmp;
      }
    /* fall through */
      case T_STRING:
    pos = rb_str_index(str, sub, pos);
    pos = rb_str_sublen(str, pos);
    break;
    }

    if (pos == -1) return Qnil;
    return LONG2NUM(pos);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="initialize_copy-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>replace</strong>(other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.
</p>
<pre class="code">
   s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
   s.replace &quot;world&quot;   #=&gt; &quot;world&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.replace(other_str)   -&gt; str
 *
 *  Replaces the contents and taintedness of &lt;i&gt;str&lt;/i&gt; with the corresponding
 *  values in &lt;i&gt;other_str&lt;/i&gt;.
 *
 *     s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
 *     s.replace &quot;world&quot;   #=&gt; &quot;world&quot;
 */

VALUE
rb_str_replace(VALUE str, VALUE str2)
{
    str_modifiable(str);
    if (str == str2) return str;

    StringValue(str2);
    str_discard(str);
    return str_replace(str, str2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="insert-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>insert</strong>(index, other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Inserts <em>other_str</em> before the character at the given
<em>index</em>, modifying <em>str</em>. Negative indices count from the end
of the string, and insert <em>after</em> the given character. The intent is
insert <em>aString</em> so that it starts at the given <em>index</em>.
</p>
<pre class="code">
   &quot;abcd&quot;.insert(0, 'X')    #=&gt; &quot;Xabcd&quot;
   &quot;abcd&quot;.insert(3, 'X')    #=&gt; &quot;abcXd&quot;
   &quot;abcd&quot;.insert(4, 'X')    #=&gt; &quot;abcdX&quot;
   &quot;abcd&quot;.insert(-3, 'X')   #=&gt; &quot;abXcd&quot;
   &quot;abcd&quot;.insert(-1, 'X')   #=&gt; &quot;abcdX&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.insert(index, other_str)   -&gt; str
 *
 *  Inserts &lt;i&gt;other_str&lt;/i&gt; before the character at the given
 *  &lt;i&gt;index&lt;/i&gt;, modifying &lt;i&gt;str&lt;/i&gt;. Negative indices count from the
 *  end of the string, and insert &lt;em&gt;after&lt;/em&gt; the given character.
 *  The intent is insert &lt;i&gt;aString&lt;/i&gt; so that it starts at the given
 *  &lt;i&gt;index&lt;/i&gt;.
 *
 *     &quot;abcd&quot;.insert(0, 'X')    #=&gt; &quot;Xabcd&quot;
 *     &quot;abcd&quot;.insert(3, 'X')    #=&gt; &quot;abcXd&quot;
 *     &quot;abcd&quot;.insert(4, 'X')    #=&gt; &quot;abcdX&quot;
 *     &quot;abcd&quot;.insert(-3, 'X')   #=&gt; &quot;abXcd&quot;
 *     &quot;abcd&quot;.insert(-1, 'X')   #=&gt; &quot;abcdX&quot;
 */

static VALUE
rb_str_insert(VALUE str, VALUE idx, VALUE str2)
{
    long pos = NUM2LONG(idx);

    if (pos == -1) {
    return rb_str_append(str, str2);
    }
    else if (pos &lt; 0) {
    pos++;
    }
    rb_str_splice(str, pos, 0, str2);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a printable version of <em>str</em>, surrounded by quote marks,
with special characters escaped.
</p>
<pre class="code">
   str = &quot;hello&quot;
   str[3] = &quot;\b&quot;
   str.inspect       #=&gt; &quot;\&quot;hel\\bo\&quot;&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 * call-seq:
 *   str.inspect   -&gt; string
 *
 * Returns a printable version of _str_, surrounded by quote marks,
 * with special characters escaped.
 *
 *    str = &quot;hello&quot;
 *    str[3] = &quot;\b&quot;
 *    str.inspect       #=&gt; &quot;\&quot;hel\\bo\&quot;&quot;
 */

VALUE
rb_str_inspect(VALUE str)
{
    rb_encoding *enc = STR_ENC_GET(str);
    const char *p, *pend, *prev;
    char buf[CHAR_ESC_LEN + 1];
    VALUE result = rb_str_buf_new(0);
    rb_encoding *resenc = rb_default_internal_encoding();
    int unicode_p = rb_enc_unicode_p(enc);
    int asciicompat = rb_enc_asciicompat(enc);

    if (resenc == NULL) resenc = rb_default_external_encoding();
    if (!rb_enc_asciicompat(resenc)) resenc = rb_usascii_encoding();
    rb_enc_associate(result, resenc);
    str_buf_cat2(result, &quot;\&quot;&quot;);

    p = RSTRING_PTR(str); pend = RSTRING_END(str);
    prev = p;
    while (p &lt; pend) {
    unsigned int c, cc;
    int n;

        n = rb_enc_precise_mbclen(p, pend, enc);
        if (!MBCLEN_CHARFOUND_P(n)) {
        if (p &gt; prev) str_buf_cat(result, prev, p - prev);
            n = rb_enc_mbminlen(enc);
            if (pend &lt; p + n)
                n = (int)(pend - p);
            while (n--) {
                snprintf(buf, CHAR_ESC_LEN, &quot;\\x%02X&quot;, *p &amp; 0377);
                str_buf_cat(result, buf, strlen(buf));
                prev = ++p;
            }
        continue;
    }
        n = MBCLEN_CHARFOUND_LEN(n);
    c = rb_enc_mbc_to_codepoint(p, pend, enc);
    p += n;
    if (c == '&quot;'|| c == '\\' ||
        (c == '#' &amp;&amp;
             p &lt; pend &amp;&amp;
             MBCLEN_CHARFOUND_P(rb_enc_precise_mbclen(p,pend,enc)) &amp;&amp;
             (cc = rb_enc_codepoint(p,pend,enc),
              (cc == '$' || cc == '@' || cc == '{')))) {
        if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
        str_buf_cat2(result, &quot;\\&quot;);
        prev = p - n;
        continue;
    }
    switch (c) {
      case '\n': cc = 'n'; break;
      case '\r': cc = 'r'; break;
      case '\t': cc = 't'; break;
      case '\f': cc = 'f'; break;
      case '\013': cc = 'v'; break;
      case '\010': cc = 'b'; break;
      case '\007': cc = 'a'; break;
      case 033: cc = 'e'; break;
      default: cc = 0; break;
    }
    if (cc) {
        if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
        buf[0] = '\\';
        buf[1] = (char)cc;
        str_buf_cat(result, buf, 2);
        prev = p;
        continue;
    }
    if ((enc == resenc &amp;&amp; rb_enc_isprint(c, enc)) ||
        (asciicompat &amp;&amp; rb_enc_isascii(c, enc) &amp;&amp; ISPRINT(c))) {
        continue;
    }
    else {
        if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
        rb_str_buf_cat_escaped_char(result, c, unicode_p);
        prev = p;
        continue;
    }
    }
    if (p &gt; prev) str_buf_cat(result, prev, p - prev);
    str_buf_cat2(result, &quot;\&quot;&quot;);

    OBJ_INFECT(result, str);
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="intern-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>intern</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_sym</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the <tt>Symbol</tt> corresponding to <em>str</em>, creating the
symbol if it did not previously exist. See <tt>Symbol#id2name</tt>.
</p>
<pre class="code">
   &quot;Koala&quot;.intern         #=&gt; :Koala
   s = 'cat'.to_sym       #=&gt; :cat
   s == :cat              #=&gt; true
   s = '@cat'.to_sym      #=&gt; :@cat
   s == :@cat             #=&gt; true
</pre>
<p>
This can also be used to create symbols that cannot be represented using
the <tt>:xxx</tt> notation.
</p>
<pre class="code">
   'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.intern   -&gt; symbol
 *     str.to_sym   -&gt; symbol
 *
 *  Returns the &lt;code&gt;Symbol&lt;/code&gt; corresponding to &lt;i&gt;str&lt;/i&gt;, creating the
 *  symbol if it did not previously exist. See &lt;code&gt;Symbol#id2name&lt;/code&gt;.
 *
 *     &quot;Koala&quot;.intern         #=&gt; :Koala
 *     s = 'cat'.to_sym       #=&gt; :cat
 *     s == :cat              #=&gt; true
 *     s = '@cat'.to_sym      #=&gt; :@cat
 *     s == :@cat             #=&gt; true
 *
 *  This can also be used to create symbols that cannot be represented using the
 *  &lt;code&gt;:xxx&lt;/code&gt; notation.
 *
 *     'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;
 */

VALUE
rb_str_intern(VALUE s)
{
    VALUE str = RB_GC_GUARD(s);
    ID id;

    id = rb_intern_str(str);
    return ID2SYM(id);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="length-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the character length of <em>str</em>.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.length   -&gt; integer
 *     str.size     -&gt; integer
 *
 *  Returns the character length of &lt;i&gt;str&lt;/i&gt;.
 */

VALUE
rb_str_length(VALUE str)
{
    long len;

    len = str_strlen(str, STR_ENC_GET(str));
    return LONG2NUM(len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lines-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>each_line</strong>(separator = $/) {|substr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_line</strong>(separator = $/) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
str.lines(separator=$/) {|substr| block }       -> str
</p>
<pre class="code">
   str.lines(separator=$/)                         -&gt; an_enumerator
</pre>
<p>
Splits <em>str</em> using the supplied parameter as the record separator
(<tt>$/</tt> by default), passing each substring in turn to the supplied
block. If a zero-length record separator is supplied, the string is split
into paragraphs delimited by multiple successive newlines.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   print &quot;Example one\n&quot;
   &quot;hello\nworld&quot;.each_line {|s| p s}
   print &quot;Example two\n&quot;
   &quot;hello\nworld&quot;.each_line('l') {|s| p s}
   print &quot;Example three\n&quot;
   &quot;hello\n\n\nworld&quot;.each_line('') {|s| p s}
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   Example one
   &quot;hello\n&quot;
   &quot;world&quot;
   Example two
   &quot;hel&quot;
   &quot;l&quot;
   &quot;o\nworl&quot;
   &quot;d&quot;
   Example three
   &quot;hello\n\n\n&quot;
   &quot;world&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>each_line</strong>(separator = $/) {|substr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>substr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.each_line(separator=$/) {|substr| block }   -&gt; str
 *     str.each_line(separator=$/)                     -&gt; an_enumerator
 *
 *     str.lines(separator=$/) {|substr| block }       -&gt; str
 *     str.lines(separator=$/)                         -&gt; an_enumerator
 *
 *  Splits &lt;i&gt;str&lt;/i&gt; using the supplied parameter as the record separator
 *  (&lt;code&gt;$/&lt;/code&gt; by default), passing each substring in turn to the supplied
 *  block. If a zero-length record separator is supplied, the string is split
 *  into paragraphs delimited by multiple successive newlines.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     print &quot;Example one\n&quot;
 *     &quot;hello\nworld&quot;.each_line {|s| p s}
 *     print &quot;Example two\n&quot;
 *     &quot;hello\nworld&quot;.each_line('l') {|s| p s}
 *     print &quot;Example three\n&quot;
 *     &quot;hello\n\n\nworld&quot;.each_line('') {|s| p s}
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Example one
 *     &quot;hello\n&quot;
 *     &quot;world&quot;
 *     Example two
 *     &quot;hel&quot;
 *     &quot;l&quot;
 *     &quot;o\nworl&quot;
 *     &quot;d&quot;
 *     Example three
 *     &quot;hello\n\n\n&quot;
 *     &quot;world&quot;
 */

static VALUE
rb_str_each_line(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    VALUE rs;
    unsigned int newline;
    const char *p, *pend, *s, *ptr;
    long len, rslen;
    VALUE line;
    int n;
    VALUE orig = str;

    if (argc == 0) {
    rs = rb_rs;
    }
    else {
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs);
    }
    RETURN_ENUMERATOR(str, argc, argv);
    if (NIL_P(rs)) {
    rb_yield(str);
    return orig;
    }
    str = rb_str_new4(str);
    ptr = p = s = RSTRING_PTR(str);
    pend = p + RSTRING_LEN(str);
    len = RSTRING_LEN(str);
    StringValue(rs);
    if (rs == rb_default_rs) {
    enc = rb_enc_get(str);
    while (p &lt; pend) {
        char *p0;

        p = memchr(p, '\n', pend - p);
        if (!p) break;
        p0 = rb_enc_left_char_head(s, p, pend, enc);
        if (!rb_enc_is_newline(p0, pend, enc)) {
        p++;
        continue;
        }
        p = p0 + rb_enc_mbclen(p0, pend, enc);
        line = rb_str_new5(str, s, p - s);
        OBJ_INFECT(line, str);
        rb_enc_cr_str_copy_for_substr(line, str);
        rb_yield(line);
        str_mod_check(str, ptr, len);
        s = p;
    }
    goto finish;
    }

    enc = rb_enc_check(str, rs);
    rslen = RSTRING_LEN(rs);
    if (rslen == 0) {
    newline = '\n';
    }
    else {
    newline = rb_enc_codepoint(RSTRING_PTR(rs), RSTRING_END(rs), enc);
    }

    while (p &lt; pend) {
    unsigned int c = rb_enc_codepoint_len(p, pend, &amp;n, enc);

      again:
    if (rslen == 0 &amp;&amp; c == newline) {
        p += n;
        if (p &lt; pend &amp;&amp; (c = rb_enc_codepoint_len(p, pend, &amp;n, enc)) != newline) {
        goto again;
        }
        while (p &lt; pend &amp;&amp; rb_enc_codepoint(p, pend, enc) == newline) {
        p += n;
        }
        p -= n;
    }
    if (c == newline &amp;&amp;
        (rslen &lt;= 1 || memcmp(RSTRING_PTR(rs), p, rslen) == 0)) {
        line = rb_str_new5(str, s, p - s + (rslen ? rslen : n));
        OBJ_INFECT(line, str);
        rb_enc_cr_str_copy_for_substr(line, str);
        rb_yield(line);
        str_mod_check(str, ptr, len);
        s = p + (rslen ? rslen : n);
    }
    p += n;
    }

  finish:
    if (s != pend) {
    line = rb_str_new5(str, s, pend - s);
    OBJ_INFECT(line, str);
    rb_enc_cr_str_copy_for_substr(line, str);
    rb_yield(line);
    }

    return orig;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ljust-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>ljust</strong>(integer, padstr = ' ') 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt>String</tt> of length <em>integer</em> with <em>str</em> left
justified and padded with <em>padstr</em>; otherwise, returns <em>str</em>.
</p>
<pre class="code">
   &quot;hello&quot;.ljust(4)            #=&gt; &quot;hello&quot;
   &quot;hello&quot;.ljust(20)           #=&gt; &quot;hello               &quot;
   &quot;hello&quot;.ljust(20, '1234')   #=&gt; &quot;hello123412341234123&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.ljust(integer, padstr=' ')   -&gt; new_str
 *
 *  If &lt;i&gt;integer&lt;/i&gt; is greater than the length of &lt;i&gt;str&lt;/i&gt;, returns a new
 *  &lt;code&gt;String&lt;/code&gt; of length &lt;i&gt;integer&lt;/i&gt; with &lt;i&gt;str&lt;/i&gt; left justified
 *  and padded with &lt;i&gt;padstr&lt;/i&gt;; otherwise, returns &lt;i&gt;str&lt;/i&gt;.
 *
 *     &quot;hello&quot;.ljust(4)            #=&gt; &quot;hello&quot;
 *     &quot;hello&quot;.ljust(20)           #=&gt; &quot;hello               &quot;
 *     &quot;hello&quot;.ljust(20, '1234')   #=&gt; &quot;hello123412341234123&quot;
 */

static VALUE
rb_str_ljust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'l');
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lstrip-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>lstrip</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with leading whitespace removed. See also
<tt>String#rstrip</tt> and <tt>String#strip</tt>.
</p>
<pre class="code">
   &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
   &quot;hello&quot;.lstrip       #=&gt; &quot;hello&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.lstrip   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with leading whitespace removed. See also
 *  &lt;code&gt;String#rstrip&lt;/code&gt; and &lt;code&gt;String#strip&lt;/code&gt;.
 *
 *     &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
 *     &quot;hello&quot;.lstrip       #=&gt; &quot;hello&quot;
 */

static VALUE
rb_str_lstrip(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_lstrip_bang(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lstrip!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>lstrip!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Removes leading whitespace from <em>str</em>, returning <tt>nil</tt> if no
change was made. See also <tt>String#rstrip!</tt> and
<tt>String#strip!</tt>.
</p>
<pre class="code">
   &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
   &quot;hello&quot;.lstrip!      #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.lstrip!   -&gt; self or nil
 *
 *  Removes leading whitespace from &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if no
 *  change was made. See also &lt;code&gt;String#rstrip!&lt;/code&gt; and
 *  &lt;code&gt;String#strip!&lt;/code&gt;.
 *
 *     &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
 *     &quot;hello&quot;.lstrip!      #=&gt; nil
 */

static VALUE
rb_str_lstrip_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *t, *e;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    s = RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return Qnil;
    e = t = RSTRING_END(str);
    /* remove spaces at head */
    while (s &lt; e) {
    int n;
    unsigned int cc = rb_enc_codepoint_len(s, e, &amp;n, enc);

    if (!rb_isspace(cc)) break;
    s += n;
    }

    if (s &gt; RSTRING_PTR(str)) {
    STR_SET_LEN(str, t-s);
    memmove(RSTRING_PTR(str), s, RSTRING_LEN(str));
    RSTRING_PTR(str)[RSTRING_LEN(str)] = '\0';
    return str;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="match-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(pattern) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(pattern, pos) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Converts <em>pattern</em> to a <tt>Regexp</tt> (if it isn&#8217;t already
one), then invokes its <tt>match</tt> method on <em>str</em>.  If the
second parameter is present, it specifies the position in the string to
begin the search. If the second parameter is present, it specifies the
position in the string to begin the search.
</p>
<pre class="code">
   'hello'.match('(.)\1')      #=&gt; #&lt;MatchData &quot;ll&quot; 1:&quot;l&quot;&gt;
   'hello'.match('(.)\1')[0]   #=&gt; &quot;ll&quot;
   'hello'.match(/(.)\1/)[0]   #=&gt; &quot;ll&quot;
   'hello'.match('xx')         #=&gt; nil
</pre>
<p>
If a block is given, invoke the block with MatchData if match succeed, so
that you can write
</p>
<pre class="code">
   str.match(pat) {|m| ...}
</pre>
<p>
instead of
</p>
<pre class="code">
   if m = str.match(pat)
     ...
   end
</pre>
<p>
The return value is a value from block execution in this case.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(pattern) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt><sup>?</sup>) <strong>match</strong>(pattern, pos) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.match(pattern)        -&gt; matchdata or nil
 *     str.match(pattern, pos)   -&gt; matchdata or nil
 *
 *  Converts &lt;i&gt;pattern&lt;/i&gt; to a &lt;code&gt;Regexp&lt;/code&gt; (if it isn't already one),
 *  then invokes its &lt;code&gt;match&lt;/code&gt; method on &lt;i&gt;str&lt;/i&gt;.  If the second
 *  parameter is present, it specifies the position in the string to begin the
 *  search.
 *  If the second parameter is present, it specifies the position in the string
 *  to begin the search.
 *
 *     'hello'.match('(.)\1')      #=&gt; #&lt;MatchData &quot;ll&quot; 1:&quot;l&quot;&gt;
 *     'hello'.match('(.)\1')[0]   #=&gt; &quot;ll&quot;
 *     'hello'.match(/(.)\1/)[0]   #=&gt; &quot;ll&quot;
 *     'hello'.match('xx')         #=&gt; nil
 *
 *  If a block is given, invoke the block with MatchData if match succeed, so
 *  that you can write
 *
 *     str.match(pat) {|m| ...}
 *
 *  instead of
 *
 *     if m = str.match(pat)
 *       ...
 *     end
 *
 *  The return value is a value from block execution in this case.
 */

static VALUE
rb_str_match_m(int argc, VALUE *argv, VALUE str)
{
    VALUE re, result;
    if (argc &lt; 1)
       rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..2)&quot;, argc);
    re = argv[0];
    argv[0] = str;
    result = rb_funcall2(get_pat(re, 0), rb_intern(&quot;match&quot;), argc, argv);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
    return rb_yield(result);
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="next-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the successor to <em>str</em>. The successor is calculated by
incrementing characters starting from the rightmost alphanumeric (or the
rightmost character if there are no alphanumerics) in the string.
Incrementing a digit always results in another digit, and incrementing a
letter results in another letter of the same case. Incrementing
nonalphanumerics uses the underlying character set&#8217;s collating
sequence.
</p>
<p>
If the increment generates a ``carry,&#8217;&#8217; the character to the
left of it is incremented. This process repeats until there is no carry,
adding an additional character if necessary.
</p>
<pre class="code">
   &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
   &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
   &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
   &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
   &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
   &quot;***&quot;.succ         #=&gt; &quot;**+&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.succ   -&gt; new_str
 *     str.next   -&gt; new_str
 *
 *  Returns the successor to &lt;i&gt;str&lt;/i&gt;. The successor is calculated by
 *  incrementing characters starting from the rightmost alphanumeric (or
 *  the rightmost character if there are no alphanumerics) in the
 *  string. Incrementing a digit always results in another digit, and
 *  incrementing a letter results in another letter of the same case.
 *  Incrementing nonalphanumerics uses the underlying character set's
 *  collating sequence.
 *
 *  If the increment generates a ``carry,'' the character to the left of
 *  it is incremented. This process repeats until there is no carry,
 *  adding an additional character if necessary.
 *
 *     &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
 *     &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
 *     &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
 *     &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
 *     &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
 *     &quot;***&quot;.succ         #=&gt; &quot;**+&quot;
 */

VALUE
rb_str_succ(VALUE orig)
{
    rb_encoding *enc;
    VALUE str;
    char *sbeg, *s, *e, *last_alnum = 0;
    int c = -1;
    long l;
    char carry[ONIGENC_CODE_TO_MBC_MAXLEN] = &quot;\1&quot;;
    long carry_pos = 0, carry_len = 1;
    enum neighbor_char neighbor = NEIGHBOR_FOUND;

    str = rb_str_new5(orig, RSTRING_PTR(orig), RSTRING_LEN(orig));
    rb_enc_cr_str_copy_for_substr(str, orig);
    OBJ_INFECT(str, orig);
    if (RSTRING_LEN(str) == 0) return str;

    enc = STR_ENC_GET(orig);
    sbeg = RSTRING_PTR(str);
    s = e = sbeg + RSTRING_LEN(str);

    while ((s = rb_enc_prev_char(sbeg, s, e, enc)) != 0) {
    if (neighbor == NEIGHBOR_NOT_CHAR &amp;&amp; last_alnum) {
        if (ISALPHA(*last_alnum) ? ISDIGIT(*s) :
        ISDIGIT(*last_alnum) ? ISALPHA(*s) : 0) {
        s = last_alnum;
        break;
        }
    }
    if ((l = rb_enc_precise_mbclen(s, e, enc)) &lt;= 0) continue;
        neighbor = enc_succ_alnum_char(s, l, enc, carry);
        switch (neighbor) {
      case NEIGHBOR_NOT_CHAR:
        continue;
      case NEIGHBOR_FOUND:
        return str;
      case NEIGHBOR_WRAPPED:
        last_alnum = s;
        break;
    }
        c = 1;
        carry_pos = s - sbeg;
        carry_len = l;
    }
    if (c == -1) {      /* str contains no alnum */
    s = e;
    while ((s = rb_enc_prev_char(sbeg, s, e, enc)) != 0) {
            enum neighbor_char neighbor;
            if ((l = rb_enc_precise_mbclen(s, e, enc)) &lt;= 0) continue;
            neighbor = enc_succ_char(s, l, enc);
            if (neighbor == NEIGHBOR_FOUND)
                return str;
            if (rb_enc_precise_mbclen(s, s+l, enc) != l) {
                /* wrapped to \0...\0.  search next valid char. */
                enc_succ_char(s, l, enc);
            }
            if (!rb_enc_asciicompat(enc)) {
                MEMCPY(carry, s, char, l);
                carry_len = l;
            }
            carry_pos = s - sbeg;
    }
    }
    RESIZE_CAPA(str, RSTRING_LEN(str) + carry_len);
    s = RSTRING_PTR(str) + carry_pos;
    memmove(s + carry_len, s, RSTRING_LEN(str) - carry_pos);
    memmove(s, carry, carry_len);
    STR_SET_LEN(str, RSTRING_LEN(str) + carry_len);
    RSTRING_PTR(str)[RSTRING_LEN(str)] = '\0';
    rb_enc_str_coderange(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="next!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ!</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next!</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equivalent to <tt>String#succ</tt>, but modifies the receiver in place.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ!</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next!</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.succ!   -&gt; str
 *     str.next!   -&gt; str
 *
 *  Equivalent to &lt;code&gt;String#succ&lt;/code&gt;, but modifies the receiver in
 *  place.
 */

static VALUE
rb_str_succ_bang(VALUE str)
{
    rb_str_shared_replace(str, rb_str_succ(str));

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="oct-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>oct</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Treats leading characters of <em>str</em> as a string of octal digits (with
an optional sign) and returns the corresponding number.  Returns 0 if the
conversion fails.
</p>
<pre class="code">
   &quot;123&quot;.oct       #=&gt; 83
   &quot;-377&quot;.oct      #=&gt; -255
   &quot;bad&quot;.oct       #=&gt; 0
   &quot;0377bad&quot;.oct   #=&gt; 255</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.oct   -&gt; integer
 *
 *  Treats leading characters of &lt;i&gt;str&lt;/i&gt; as a string of octal digits (with an
 *  optional sign) and returns the corresponding number.  Returns 0 if the
 *  conversion fails.
 *
 *     &quot;123&quot;.oct       #=&gt; 83
 *     &quot;-377&quot;.oct      #=&gt; -255
 *     &quot;bad&quot;.oct       #=&gt; 0
 *     &quot;0377bad&quot;.oct   #=&gt; 255
 */

static VALUE
rb_str_oct(VALUE str)
{
    rb_encoding *enc = rb_enc_get(str);

    if (!rb_enc_asciicompat(enc)) {
    rb_raise(rb_eEncCompatError, &quot;ASCII incompatible encoding: %s&quot;, rb_enc_name(enc));
    }
    return rb_str_to_inum(str, -8, FALSE);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ord-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>ord</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return the <tt>Integer</tt> ordinal of a one-character string.
</p>
<pre class="code">
   &quot;a&quot;.ord         #=&gt; 97</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.ord   -&gt; integer
 *
 *  Return the &lt;code&gt;Integer&lt;/code&gt; ordinal of a one-character string.
 *
 *     &quot;a&quot;.ord         #=&gt; 97
 */

VALUE
rb_str_ord(VALUE s)
{
    unsigned int c;

    c = rb_enc_codepoint(RSTRING_PTR(s), RSTRING_END(s), STR_ENC_GET(s));
    return UINT2NUM(c);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="partition-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>partition</strong>(sep) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>partition</strong>(regexp) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Searches <em>sep</em> or pattern (<em>regexp</em>) in the string and
returns the part before it, the match, and the part after it. If it is not
found, returns two empty strings and <em>str</em>.
</p>
<pre class="code">
   &quot;hello&quot;.partition(&quot;l&quot;)         #=&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]
   &quot;hello&quot;.partition(&quot;x&quot;)         #=&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]
   &quot;hello&quot;.partition(/.l/)        #=&gt; [&quot;h&quot;, &quot;el&quot;, &quot;lo&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>partition</strong>(sep) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>partition</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.partition(sep)              -&gt; [head, sep, tail]
 *     str.partition(regexp)           -&gt; [head, match, tail]
 *
 *  Searches &lt;i&gt;sep&lt;/i&gt; or pattern (&lt;i&gt;regexp&lt;/i&gt;) in the string
 *  and returns the part before it, the match, and the part
 *  after it.
 *  If it is not found, returns two empty strings and &lt;i&gt;str&lt;/i&gt;.
 *
 *     &quot;hello&quot;.partition(&quot;l&quot;)         #=&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]
 *     &quot;hello&quot;.partition(&quot;x&quot;)         #=&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]
 *     &quot;hello&quot;.partition(/.l/)        #=&gt; [&quot;h&quot;, &quot;el&quot;, &quot;lo&quot;]
 */

static VALUE
rb_str_partition(VALUE str, VALUE sep)
{
    long pos;
    int regex = FALSE;

    if (TYPE(sep) == T_REGEXP) {
    pos = rb_reg_search(sep, str, 0, 0);
    regex = TRUE;
    }
    else {
    VALUE tmp;

    tmp = rb_check_string_type(sep);
    if (NIL_P(tmp)) {
        rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
             rb_obj_classname(sep));
    }
    sep = tmp;
    pos = rb_str_index(str, sep, 0);
    }
    if (pos &lt; 0) {
      failed:
    return rb_ary_new3(3, str, str_new_empty(str), str_new_empty(str));
    }
    if (regex) {
    sep = rb_str_subpat(str, sep, INT2FIX(0));
    if (pos == 0 &amp;&amp; RSTRING_LEN(sep) == 0) goto failed;
    }
    return rb_ary_new3(3, rb_str_subseq(str, 0, pos),
                  sep,
                  rb_str_subseq(str, pos+RSTRING_LEN(sep),
                         RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="replace-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>replace</strong>(other_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.
</p>
<pre class="code">
   s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
   s.replace &quot;world&quot;   #=&gt; &quot;world&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.replace(other_str)   -&gt; str
 *
 *  Replaces the contents and taintedness of &lt;i&gt;str&lt;/i&gt; with the corresponding
 *  values in &lt;i&gt;other_str&lt;/i&gt;.
 *
 *     s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
 *     s.replace &quot;world&quot;   #=&gt; &quot;world&quot;
 */

VALUE
rb_str_replace(VALUE str, VALUE str2)
{
    str_modifiable(str);
    if (str == str2) return str;

    StringValue(str2);
    str_discard(str);
    return str_replace(str, str2);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reverse-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>reverse</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new string with the characters from <em>str</em> in reverse
order.
</p>
<pre class="code">
   &quot;stressed&quot;.reverse   #=&gt; &quot;desserts&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.reverse   -&gt; new_str
 *
 *  Returns a new string with the characters from &lt;i&gt;str&lt;/i&gt; in reverse order.
 *
 *     &quot;stressed&quot;.reverse   #=&gt; &quot;desserts&quot;
 */

static VALUE
rb_str_reverse(VALUE str)
{
    rb_encoding *enc;
    VALUE rev;
    char *s, *e, *p;
    int single = 1;

    if (RSTRING_LEN(str) &lt;= 1) return rb_str_dup(str);
    enc = STR_ENC_GET(str);
    rev = rb_str_new5(str, 0, RSTRING_LEN(str));
    s = RSTRING_PTR(str); e = RSTRING_END(str);
    p = RSTRING_END(rev);

    if (RSTRING_LEN(str) &gt; 1) {
    if (single_byte_optimizable(str)) {
        while (s &lt; e) {
        *--p = *s++;
        }
    }
    else if (ENC_CODERANGE(str) == ENC_CODERANGE_VALID) {
        while (s &lt; e) {
        int clen = rb_enc_fast_mbclen(s, e, enc);

        if (clen &gt; 1 || (*s &amp; 0x80)) single = 0;
        p -= clen;
        memcpy(p, s, clen);
        s += clen;
        }
    }
    else {
        while (s &lt; e) {
        int clen = rb_enc_mbclen(s, e, enc);

        if (clen &gt; 1 || (*s &amp; 0x80)) single = 0;
        p -= clen;
        memcpy(p, s, clen);
        s += clen;
        }
    }
    }
    STR_SET_LEN(rev, RSTRING_LEN(str));
    OBJ_INFECT(rev, str);
    if (ENC_CODERANGE(str) == ENC_CODERANGE_UNKNOWN) {
    if (single) {
        ENC_CODERANGE_SET(str, ENC_CODERANGE_7BIT);
    }
    else {
        ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
    }
    }
    rb_enc_cr_str_copy_for_substr(rev, str);

    return rev;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reverse!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>reverse!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reverses <em>str</em> in place.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.reverse!   -&gt; str
 *
 *  Reverses &lt;i&gt;str&lt;/i&gt; in place.
 */

static VALUE
rb_str_reverse_bang(VALUE str)
{
    if (RSTRING_LEN(str) &gt; 1) {
    if (single_byte_optimizable(str)) {
        char *s, *e, c;

        str_modify_keep_cr(str);
        s = RSTRING_PTR(str);
        e = RSTRING_END(str) - 1;
        while (s &lt; e) {
        c = *s;
        *s++ = *e;
        *e-- = c;
        }
    }
    else {
        rb_str_shared_replace(str, rb_str_reverse(str));
    }
    }
    else {
    str_modify_keep_cr(str);
    }
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rindex-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>rindex</strong>(substring[, fixnum]) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>rindex</strong>(regexp[, fixnum]) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the index of the last occurrence of the given <em>substring</em> or
pattern (<em>regexp</em>) in <em>str</em>. Returns <tt>nil</tt> if not
found. If the second parameter is present, it specifies the position in the
string to end the search--characters beyond this point will not be
considered.
</p>
<pre class="code">
   &quot;hello&quot;.rindex('e')             #=&gt; 1
   &quot;hello&quot;.rindex('l')             #=&gt; 3
   &quot;hello&quot;.rindex('a')             #=&gt; nil
   &quot;hello&quot;.rindex(?e)              #=&gt; 1
   &quot;hello&quot;.rindex(/[aeiou]/, -2)   #=&gt; 1</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>rindex</strong>(substring[, fixnum]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>rindex</strong>(regexp[, fixnum]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.rindex(substring [, fixnum])   -&gt; fixnum or nil
 *     str.rindex(regexp [, fixnum])   -&gt; fixnum or nil
 *
 *  Returns the index of the last occurrence of the given &lt;i&gt;substring&lt;/i&gt; or
 *  pattern (&lt;i&gt;regexp&lt;/i&gt;) in &lt;i&gt;str&lt;/i&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if not
 *  found. If the second parameter is present, it specifies the position in the
 *  string to end the search---characters beyond this point will not be
 *  considered.
 *
 *     &quot;hello&quot;.rindex('e')             #=&gt; 1
 *     &quot;hello&quot;.rindex('l')             #=&gt; 3
 *     &quot;hello&quot;.rindex('a')             #=&gt; nil
 *     &quot;hello&quot;.rindex(?e)              #=&gt; 1
 *     &quot;hello&quot;.rindex(/[aeiou]/, -2)   #=&gt; 1
 */

static VALUE
rb_str_rindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE vpos;
    rb_encoding *enc = STR_ENC_GET(str);
    long pos, len = str_strlen(str, enc);

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;vpos) == 2) {
    pos = NUM2LONG(vpos);
    if (pos &lt; 0) {
        pos += len;
        if (pos &lt; 0) {
        if (TYPE(sub) == T_REGEXP) {
            rb_backref_set(Qnil);
        }
        return Qnil;
        }
    }
    if (pos &gt; len) pos = len;
    }
    else {
    pos = len;
    }

    switch (TYPE(sub)) {
      case T_REGEXP:
    /* enc = rb_get_check(str, sub); */
    pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
             STR_ENC_GET(str), single_byte_optimizable(str));

    if (!RREGEXP(sub)-&gt;ptr || RREGEXP_SRC_LEN(sub)) {
        pos = rb_reg_search(sub, str, pos, 1);
        pos = rb_str_sublen(str, pos);
    }
    if (pos &gt;= 0) return LONG2NUM(pos);
    break;

      default: {
    VALUE tmp;

    tmp = rb_check_string_type(sub);
    if (NIL_P(tmp)) {
        rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
             rb_obj_classname(sub));
    }
    sub = tmp;
      }
    /* fall through */
      case T_STRING:
    pos = rb_str_rindex(str, sub, pos);
    if (pos &gt;= 0) return LONG2NUM(pos);
    break;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rjust-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>rjust</strong>(integer, padstr = ' ') 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt>String</tt> of length <em>integer</em> with <em>str</em> right
justified and padded with <em>padstr</em>; otherwise, returns <em>str</em>.
</p>
<pre class="code">
   &quot;hello&quot;.rjust(4)            #=&gt; &quot;hello&quot;
   &quot;hello&quot;.rjust(20)           #=&gt; &quot;               hello&quot;
   &quot;hello&quot;.rjust(20, '1234')   #=&gt; &quot;123412341234123hello&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.rjust(integer, padstr=' ')   -&gt; new_str
 *
 *  If &lt;i&gt;integer&lt;/i&gt; is greater than the length of &lt;i&gt;str&lt;/i&gt;, returns a new
 *  &lt;code&gt;String&lt;/code&gt; of length &lt;i&gt;integer&lt;/i&gt; with &lt;i&gt;str&lt;/i&gt; right justified
 *  and padded with &lt;i&gt;padstr&lt;/i&gt;; otherwise, returns &lt;i&gt;str&lt;/i&gt;.
 *
 *     &quot;hello&quot;.rjust(4)            #=&gt; &quot;hello&quot;
 *     &quot;hello&quot;.rjust(20)           #=&gt; &quot;               hello&quot;
 *     &quot;hello&quot;.rjust(20, '1234')   #=&gt; &quot;123412341234123hello&quot;
 */

static VALUE
rb_str_rjust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'r');
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rpartition-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>rpartition</strong>(sep) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>rpartition</strong>(regexp) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Searches <em>sep</em> or pattern (<em>regexp</em>) in the string from the
end of the string, and returns the part before it, the match, and the part
after it. If it is not found, returns two empty strings and <em>str</em>.
</p>
<pre class="code">
   &quot;hello&quot;.rpartition(&quot;l&quot;)         #=&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]
   &quot;hello&quot;.rpartition(&quot;x&quot;)         #=&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]
   &quot;hello&quot;.rpartition(/.l/)        #=&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>rpartition</strong>(sep) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>rpartition</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.rpartition(sep)             -&gt; [head, sep, tail]
 *     str.rpartition(regexp)          -&gt; [head, match, tail]
 *
 *  Searches &lt;i&gt;sep&lt;/i&gt; or pattern (&lt;i&gt;regexp&lt;/i&gt;) in the string from the end
 *  of the string, and returns the part before it, the match, and the part
 *  after it.
 *  If it is not found, returns two empty strings and &lt;i&gt;str&lt;/i&gt;.
 *
 *     &quot;hello&quot;.rpartition(&quot;l&quot;)         #=&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]
 *     &quot;hello&quot;.rpartition(&quot;x&quot;)         #=&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]
 *     &quot;hello&quot;.rpartition(/.l/)        #=&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]
 */

static VALUE
rb_str_rpartition(VALUE str, VALUE sep)
{
    long pos = RSTRING_LEN(str);
    int regex = FALSE;

    if (TYPE(sep) == T_REGEXP) {
    pos = rb_reg_search(sep, str, pos, 1);
    regex = TRUE;
    }
    else {
    VALUE tmp;

    tmp = rb_check_string_type(sep);
    if (NIL_P(tmp)) {
        rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
             rb_obj_classname(sep));
    }
    sep = tmp;
    pos = rb_str_sublen(str, pos);
    pos = rb_str_rindex(str, sep, pos);
    }
    if (pos &lt; 0) {
    return rb_ary_new3(3, str_new_empty(str), str_new_empty(str), str);
    }
    if (regex) {
    sep = rb_reg_nth_match(0, rb_backref_get());
    }
    return rb_ary_new3(3, rb_str_substr(str, 0, pos),
                  sep,
                  rb_str_substr(str,pos+str_strlen(sep,STR_ENC_GET(sep)),RSTRING_LEN(str)));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rstrip-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>rstrip</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with trailing whitespace removed. See also
<tt>String#lstrip</tt> and <tt>String#strip</tt>.
</p>
<pre class="code">
   &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
   &quot;hello&quot;.rstrip       #=&gt; &quot;hello&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.rstrip   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with trailing whitespace removed. See also
 *  &lt;code&gt;String#lstrip&lt;/code&gt; and &lt;code&gt;String#strip&lt;/code&gt;.
 *
 *     &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
 *     &quot;hello&quot;.rstrip       #=&gt; &quot;hello&quot;
 */

static VALUE
rb_str_rstrip(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_rstrip_bang(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rstrip!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>rstrip!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Removes trailing whitespace from <em>str</em>, returning <tt>nil</tt> if no
change was made. See also <tt>String#lstrip!</tt> and
<tt>String#strip!</tt>.
</p>
<pre class="code">
   &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
   &quot;hello&quot;.rstrip!      #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.rstrip!   -&gt; self or nil
 *
 *  Removes trailing whitespace from &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if
 *  no change was made. See also &lt;code&gt;String#lstrip!&lt;/code&gt; and
 *  &lt;code&gt;String#strip!&lt;/code&gt;.
 *
 *     &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
 *     &quot;hello&quot;.rstrip!      #=&gt; nil
 */

static VALUE
rb_str_rstrip_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *t, *e;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    rb_str_check_dummy_enc(enc);
    s = RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return Qnil;
    t = e = RSTRING_END(str);

    /* remove trailing spaces or '\0's */
    if (single_byte_optimizable(str)) {
    unsigned char c;
    while (s &lt; t &amp;&amp; ((c = *(t-1)) == '\0' || ascii_isspace(c))) t--;
    }
    else {
    char *tp;

        while ((tp = rb_enc_prev_char(s, t, e, enc)) != NULL) {
        unsigned int c = rb_enc_codepoint(tp, e, enc);
        if (c &amp;&amp; !rb_isspace(c)) break;
        t = tp;
    }
    }
    if (t &lt; e) {
    long len = t-RSTRING_PTR(str);

    STR_SET_LEN(str, len);
    RSTRING_PTR(str)[len] = '\0';
    return str;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="scan-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>scan</strong>(pattern) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>scan</strong>(pattern) {|match, ...| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Both forms iterate through <em>str</em>, matching the pattern (which may be
a <tt>Regexp</tt> or a <tt>String</tt>). For each match, a result is
generated and either added to the result array or passed to the block. If
the pattern contains no groups, each individual result consists of the
matched string, <tt>$&amp;</tt>.  If the pattern contains groups, each
individual result is itself an array containing one entry per group.
</p>
<pre class="code">
   a = &quot;cruel world&quot;
   a.scan(/\w+/)        #=&gt; [&quot;cruel&quot;, &quot;world&quot;]
   a.scan(/.../)        #=&gt; [&quot;cru&quot;, &quot;el &quot;, &quot;wor&quot;]
   a.scan(/(...)/)      #=&gt; [[&quot;cru&quot;], [&quot;el &quot;], [&quot;wor&quot;]]
   a.scan(/(..)(..)/)   #=&gt; [[&quot;cr&quot;, &quot;ue&quot;], [&quot;l &quot;, &quot;wo&quot;]]
</pre>
<p>
And the block form:
</p>
<pre class="code">
   a.scan(/\w+/) {|w| print &quot;&lt;&lt;#{w}&gt;&gt; &quot; }
   print &quot;\n&quot;
   a.scan(/(.)(.)/) {|x,y| print y, x }
   print &quot;\n&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   &lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;
   rceu lowlr</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>scan</strong>(pattern) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>scan</strong>(pattern) {|match, ...| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>match</tt>, <tt>...</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.scan(pattern)                         -&gt; array
 *     str.scan(pattern) {|match, ...| block }   -&gt; str
 *
 *  Both forms iterate through &lt;i&gt;str&lt;/i&gt;, matching the pattern (which may be a
 *  &lt;code&gt;Regexp&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt;). For each match, a result is
 *  generated and either added to the result array or passed to the block. If
 *  the pattern contains no groups, each individual result consists of the
 *  matched string, &lt;code&gt;$&amp;&lt;/code&gt;.  If the pattern contains groups, each
 *  individual result is itself an array containing one entry per group.
 *
 *     a = &quot;cruel world&quot;
 *     a.scan(/\w+/)        #=&gt; [&quot;cruel&quot;, &quot;world&quot;]
 *     a.scan(/.../)        #=&gt; [&quot;cru&quot;, &quot;el &quot;, &quot;wor&quot;]
 *     a.scan(/(...)/)      #=&gt; [[&quot;cru&quot;], [&quot;el &quot;], [&quot;wor&quot;]]
 *     a.scan(/(..)(..)/)   #=&gt; [[&quot;cr&quot;, &quot;ue&quot;], [&quot;l &quot;, &quot;wo&quot;]]
 *
 *  And the block form:
 *
 *     a.scan(/\w+/) {|w| print &quot;&lt;&lt;#{w}&gt;&gt; &quot; }
 *     print &quot;\n&quot;
 *     a.scan(/(.)(.)/) {|x,y| print y, x }
 *     print &quot;\n&quot;
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     &lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;
 *     rceu lowlr
 */

static VALUE
rb_str_scan(VALUE str, VALUE pat)
{
    VALUE result;
    long start = 0;
    long last = -1, prev = 0;
    char *p = RSTRING_PTR(str); long len = RSTRING_LEN(str);

    pat = get_pat(pat, 1);
    if (!rb_block_given_p()) {
    VALUE ary = rb_ary_new();

    while (!NIL_P(result = scan_once(str, pat, &amp;start))) {
        last = prev;
        prev = start;
        rb_ary_push(ary, result);
    }
    if (last &gt;= 0) rb_reg_search(pat, str, last, 0);
    return ary;
    }

    while (!NIL_P(result = scan_once(str, pat, &amp;start))) {
    last = prev;
    prev = start;
    rb_yield(result);
    str_mod_check(str, p, len);
    }
    if (last &gt;= 0) rb_reg_search(pat, str, last, 0);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="setbyte-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>setbyte</strong>(index, int) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
modifies the <em>index</em>th byte as <em>int</em>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.setbyte(index, int) -&gt; int
 *
 *  modifies the &lt;i&gt;index&lt;/i&gt;th byte as &lt;i&gt;int&lt;/i&gt;.
 */
static VALUE
rb_str_setbyte(VALUE str, VALUE index, VALUE value)
{
    long pos = NUM2LONG(index);
    int byte = NUM2INT(value);

    rb_str_modify(str);

    if (pos &lt; -RSTRING_LEN(str) || RSTRING_LEN(str) &lt;= pos)
        rb_raise(rb_eIndexError, &quot;index %ld out of string&quot;, pos);
    if (pos &lt; 0)
        pos += RSTRING_LEN(str);

    RSTRING_PTR(str)[pos] = byte;

    return value;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="size-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the character length of <em>str</em>.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>length</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>size</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.length   -&gt; integer
 *     str.size     -&gt; integer
 *
 *  Returns the character length of &lt;i&gt;str&lt;/i&gt;.
 */

VALUE
rb_str_length(VALUE str)
{
    long len;

    len = str_strlen(str, STR_ENC_GET(str));
    return LONG2NUM(len);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="slice-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(other_str) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, capname) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(other_str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Element Reference--If passed a single <tt>Fixnum</tt>, returns a
substring of one character at that position. If passed two <tt>Fixnum</tt>
objects, returns a substring starting at the offset given by the first, and
a length given by the second. If given a range, a substring containing
characters at offsets given by the range is returned. In all three cases,
if an offset is negative, it is counted from the end of <em>str</em>.
Returns <tt>nil</tt> if the initial offset falls outside the string, the
length is negative, or the beginning of the range is greater than the end.
</p>
<p>
If a <tt>Regexp</tt> is supplied, the matching portion of <em>str</em> is
returned. If a numeric or name parameter follows the regular expression,
that component of the <tt>MatchData</tt> is returned instead. If a
<tt>String</tt> is given, that string is returned if it occurs in
<em>str</em>. In both cases, <tt>nil</tt> is returned if there is no match.
</p>
<pre class="code">
   a = &quot;hello there&quot;
   a[1]                   #=&gt; &quot;e&quot;
   a[1,3]                 #=&gt; &quot;ell&quot;
   a[1..3]                #=&gt; &quot;ell&quot;
   a[-3,2]                #=&gt; &quot;er&quot;
   a[-4..-2]              #=&gt; &quot;her&quot;
   a[12..-1]              #=&gt; nil
   a[-2..-4]              #=&gt; &quot;&quot;
   a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
   a[/[aeiou](.)\1/, 2]   #=&gt; nil
   a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
   a[&quot;bye&quot;]               #=&gt; nil</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(fixnum, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(regexp, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>[]</strong>(other_str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(fixnum, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(regexp, capname) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice</strong>(other_str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str[fixnum]                 -&gt; new_str or nil
 *     str[fixnum, fixnum]         -&gt; new_str or nil
 *     str[range]                  -&gt; new_str or nil
 *     str[regexp]                 -&gt; new_str or nil
 *     str[regexp, fixnum]         -&gt; new_str or nil
 *     str[other_str]              -&gt; new_str or nil
 *     str.slice(fixnum)           -&gt; new_str or nil
 *     str.slice(fixnum, fixnum)   -&gt; new_str or nil
 *     str.slice(range)            -&gt; new_str or nil
 *     str.slice(regexp)           -&gt; new_str or nil
 *     str.slice(regexp, fixnum)   -&gt; new_str or nil
 *     str.slice(regexp, capname)  -&gt; new_str or nil
 *     str.slice(other_str)        -&gt; new_str or nil
 *
 *  Element Reference---If passed a single &lt;code&gt;Fixnum&lt;/code&gt;, returns a
 *  substring of one character at that position. If passed two &lt;code&gt;Fixnum&lt;/code&gt;
 *  objects, returns a substring starting at the offset given by the first, and
 *  a length given by the second. If given a range, a substring containing
 *  characters at offsets given by the range is returned. In all three cases, if
 *  an offset is negative, it is counted from the end of &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if the initial offset falls outside the string, the length
 *  is negative, or the beginning of the range is greater than the end.
 *
 *  If a &lt;code&gt;Regexp&lt;/code&gt; is supplied, the matching portion of &lt;i&gt;str&lt;/i&gt; is
 *  returned. If a numeric or name parameter follows the regular expression, that
 *  component of the &lt;code&gt;MatchData&lt;/code&gt; is returned instead. If a
 *  &lt;code&gt;String&lt;/code&gt; is given, that string is returned if it occurs in
 *  &lt;i&gt;str&lt;/i&gt;. In both cases, &lt;code&gt;nil&lt;/code&gt; is returned if there is no
 *  match.
 *
 *     a = &quot;hello there&quot;
 *     a[1]                   #=&gt; &quot;e&quot;
 *     a[1,3]                 #=&gt; &quot;ell&quot;
 *     a[1..3]                #=&gt; &quot;ell&quot;
 *     a[-3,2]                #=&gt; &quot;er&quot;
 *     a[-4..-2]              #=&gt; &quot;her&quot;
 *     a[12..-1]              #=&gt; nil
 *     a[-2..-4]              #=&gt; &quot;&quot;
 *     a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
 *     a[/[aeiou](.)\1/, 2]   #=&gt; nil
 *     a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
 *     a[&quot;bye&quot;]               #=&gt; nil
 */

static VALUE
rb_str_aref_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
    if (TYPE(argv[0]) == T_REGEXP) {
        return rb_str_subpat(str, argv[0], argv[1]);
    }
    return rb_str_substr(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]));
    }
    if (argc != 1) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..2)&quot;, argc);
    }
    return rb_str_aref(str, argv[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="slice!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>slice!</strong>(fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(fixnum, fixnum) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(range) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(regexp) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(other_str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Deletes the specified portion from <em>str</em>, and returns the portion
deleted.
</p>
<pre class="code">
   string = &quot;this is a string&quot;
   string.slice!(2)        #=&gt; &quot;i&quot;
   string.slice!(3..6)     #=&gt; &quot; is &quot;
   string.slice!(/s.*t/)   #=&gt; &quot;sa st&quot;
   string.slice!(&quot;r&quot;)      #=&gt; &quot;r&quot;
   string                  #=&gt; &quot;thing&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>slice!</strong>(fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(fixnum, fixnum) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(range) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(regexp) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>slice!</strong>(other_str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.slice!(fixnum)           -&gt; fixnum or nil
 *     str.slice!(fixnum, fixnum)   -&gt; new_str or nil
 *     str.slice!(range)            -&gt; new_str or nil
 *     str.slice!(regexp)           -&gt; new_str or nil
 *     str.slice!(other_str)        -&gt; new_str or nil
 *
 *  Deletes the specified portion from &lt;i&gt;str&lt;/i&gt;, and returns the portion
 *  deleted.
 *
 *     string = &quot;this is a string&quot;
 *     string.slice!(2)        #=&gt; &quot;i&quot;
 *     string.slice!(3..6)     #=&gt; &quot; is &quot;
 *     string.slice!(/s.*t/)   #=&gt; &quot;sa st&quot;
 *     string.slice!(&quot;r&quot;)      #=&gt; &quot;r&quot;
 *     string                  #=&gt; &quot;thing&quot;
 */

static VALUE
rb_str_slice_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE result;
    VALUE buf[3];
    int i;

    if (argc &lt; 1 || 2 &lt; argc) {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..2)&quot;, argc);
    }
    for (i=0; i&lt;argc; i++) {
    buf[i] = argv[i];
    }
    str_modify_keep_cr(str);
    buf[i] = rb_str_new(0,0);
    result = rb_str_aref_m(argc, buf, str);
    if (!NIL_P(result)) {
    rb_str_aset_m(argc+1, buf, str);
    }
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="split-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>split</strong>(pattern = $;, [limit]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Divides <em>str</em> into substrings based on a delimiter, returning an
array of these substrings.
</p>
<p>
If <em>pattern</em> is a <tt>String</tt>, then its contents are used as the
delimiter when splitting <em>str</em>. If <em>pattern</em> is a single
space, <em>str</em> is split on whitespace, with leading whitespace and
runs of contiguous whitespace characters ignored.
</p>
<p>
If <em>pattern</em> is a <tt>Regexp</tt>, <em>str</em> is divided where the
pattern matches. Whenever the pattern matches a zero-length string,
<em>str</em> is split into individual characters. If <em>pattern</em>
contains groups, the respective matches will be returned in the array as
well.
</p>
<p>
If <em>pattern</em> is omitted, the value of <tt>$;</tt> is used.  If
<tt>$;</tt> is <tt>nil</tt> (which is the default), <em>str</em> is split
on whitespace as if ` &#8217; were specified.
</p>
<p>
If the <em>limit</em> parameter is omitted, trailing null fields are
suppressed. If <em>limit</em> is a positive number, at most that number of
fields will be returned (if <em>limit</em> is <tt>1</tt>, the entire string
is returned as the only entry in an array). If negative, there is no limit
to the number of fields returned, and trailing null fields are not
suppressed.
</p>
<pre class="code">
   &quot; now's  the time&quot;.split        #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
   &quot; now's  the time&quot;.split(' ')   #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
   &quot; now's  the time&quot;.split(/ /)   #=&gt; [&quot;&quot;, &quot;now's&quot;, &quot;&quot;, &quot;the&quot;, &quot;time&quot;]
   &quot;1, 2.34,56, 7&quot;.split(%r{,\s*}) #=&gt; [&quot;1&quot;, &quot;2.34&quot;, &quot;56&quot;, &quot;7&quot;]
   &quot;hello&quot;.split(//)               #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
   &quot;hello&quot;.split(//, 3)            #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;llo&quot;]
   &quot;hi mom&quot;.split(%r{\s*})         #=&gt; [&quot;h&quot;, &quot;i&quot;, &quot;m&quot;, &quot;o&quot;, &quot;m&quot;]

   &quot;mellow yellow&quot;.split(&quot;ello&quot;)   #=&gt; [&quot;m&quot;, &quot;w y&quot;, &quot;w&quot;]
   &quot;1,2,,3,4,,&quot;.split(',')         #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;]
   &quot;1,2,,3,4,,&quot;.split(',', 4)      #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3,4,,&quot;]
   &quot;1,2,,3,4,,&quot;.split(',', -4)     #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.split(pattern=$;, [limit])   -&gt; anArray
 *
 *  Divides &lt;i&gt;str&lt;/i&gt; into substrings based on a delimiter, returning an array
 *  of these substrings.
 *
 *  If &lt;i&gt;pattern&lt;/i&gt; is a &lt;code&gt;String&lt;/code&gt;, then its contents are used as
 *  the delimiter when splitting &lt;i&gt;str&lt;/i&gt;. If &lt;i&gt;pattern&lt;/i&gt; is a single
 *  space, &lt;i&gt;str&lt;/i&gt; is split on whitespace, with leading whitespace and runs
 *  of contiguous whitespace characters ignored.
 *
 *  If &lt;i&gt;pattern&lt;/i&gt; is a &lt;code&gt;Regexp&lt;/code&gt;, &lt;i&gt;str&lt;/i&gt; is divided where the
 *  pattern matches. Whenever the pattern matches a zero-length string,
 *  &lt;i&gt;str&lt;/i&gt; is split into individual characters. If &lt;i&gt;pattern&lt;/i&gt; contains
 *  groups, the respective matches will be returned in the array as well.
 *
 *  If &lt;i&gt;pattern&lt;/i&gt; is omitted, the value of &lt;code&gt;$;&lt;/code&gt; is used.  If
 *  &lt;code&gt;$;&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; (which is the default), &lt;i&gt;str&lt;/i&gt; is
 *  split on whitespace as if ` ' were specified.
 *
 *  If the &lt;i&gt;limit&lt;/i&gt; parameter is omitted, trailing null fields are
 *  suppressed. If &lt;i&gt;limit&lt;/i&gt; is a positive number, at most that number of
 *  fields will be returned (if &lt;i&gt;limit&lt;/i&gt; is &lt;code&gt;1&lt;/code&gt;, the entire
 *  string is returned as the only entry in an array). If negative, there is no
 *  limit to the number of fields returned, and trailing null fields are not
 *  suppressed.
 *
 *     &quot; now's  the time&quot;.split        #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
 *     &quot; now's  the time&quot;.split(' ')   #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
 *     &quot; now's  the time&quot;.split(/ /)   #=&gt; [&quot;&quot;, &quot;now's&quot;, &quot;&quot;, &quot;the&quot;, &quot;time&quot;]
 *     &quot;1, 2.34,56, 7&quot;.split(%r{,\s*}) #=&gt; [&quot;1&quot;, &quot;2.34&quot;, &quot;56&quot;, &quot;7&quot;]
 *     &quot;hello&quot;.split(//)               #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
 *     &quot;hello&quot;.split(//, 3)            #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;llo&quot;]
 *     &quot;hi mom&quot;.split(%r{\s*})         #=&gt; [&quot;h&quot;, &quot;i&quot;, &quot;m&quot;, &quot;o&quot;, &quot;m&quot;]
 *
 *     &quot;mellow yellow&quot;.split(&quot;ello&quot;)   #=&gt; [&quot;m&quot;, &quot;w y&quot;, &quot;w&quot;]
 *     &quot;1,2,,3,4,,&quot;.split(',')         #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;]
 *     &quot;1,2,,3,4,,&quot;.split(',', 4)      #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3,4,,&quot;]
 *     &quot;1,2,,3,4,,&quot;.split(',', -4)     #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;]
 */

static VALUE
rb_str_split_m(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    VALUE spat;
    VALUE limit;
    enum {awk, string, regexp} split_type;
    long beg, end, i = 0;
    int lim = 0;
    VALUE result, tmp;

    if (rb_scan_args(argc, argv, &quot;02&quot;, &amp;spat, &amp;limit) == 2) {
    lim = NUM2INT(limit);
    if (lim &lt;= 0) limit = Qnil;
    else if (lim == 1) {
        if (RSTRING_LEN(str) == 0)
        return rb_ary_new2(0);
        return rb_ary_new3(1, str);
    }
    i = 1;
    }

    enc = STR_ENC_GET(str);
    if (NIL_P(spat)) {
    if (!NIL_P(rb_fs)) {
        spat = rb_fs;
        goto fs_set;
    }
    split_type = awk;
    }
    else {
      fs_set:
    if (TYPE(spat) == T_STRING) {
        rb_encoding *enc2 = STR_ENC_GET(spat);

        split_type = string;
        if (RSTRING_LEN(spat) == 0) {
        /* Special case - split into chars */
        spat = rb_reg_regcomp(spat);
        split_type = regexp;
        }
        else if (rb_enc_asciicompat(enc2) == 1) {
        if (RSTRING_LEN(spat) == 1 &amp;&amp; RSTRING_PTR(spat)[0] == ' '){
            split_type = awk;
        }
        }
        else {
        int l;
        if (rb_enc_ascget(RSTRING_PTR(spat), RSTRING_END(spat), &amp;l, enc2) == ' ' &amp;&amp;
            RSTRING_LEN(spat) == l) {
            split_type = awk;
        }
        }
    }
    else {
        spat = get_pat(spat, 1);
        split_type = regexp;
    }
    }

    result = rb_ary_new();
    beg = 0;
    if (split_type == awk) {
    char *ptr = RSTRING_PTR(str);
    char *eptr = RSTRING_END(str);
    char *bptr = ptr;
    int skip = 1;
    unsigned int c;

    end = beg;
    if (is_ascii_string(str)) {
        while (ptr &lt; eptr) {
        c = (unsigned char)*ptr++;
        if (skip) {
            if (ascii_isspace(c)) {
            beg = ptr - bptr;
            }
            else {
            end = ptr - bptr;
            skip = 0;
            if (!NIL_P(limit) &amp;&amp; lim &lt;= i) break;
            }
        }
        else if (ascii_isspace(c)) {
            rb_ary_push(result, rb_str_subseq(str, beg, end-beg));
            skip = 1;
            beg = ptr - bptr;
            if (!NIL_P(limit)) ++i;
        }
        else {
            end = ptr - bptr;
        }
        }
    }
    else {
        while (ptr &lt; eptr) {
        int n;

        c = rb_enc_codepoint_len(ptr, eptr, &amp;n, enc);
        ptr += n;
        if (skip) {
            if (rb_isspace(c)) {
            beg = ptr - bptr;
            }
            else {
            end = ptr - bptr;
            skip = 0;
            if (!NIL_P(limit) &amp;&amp; lim &lt;= i) break;
            }
        }
        else if (rb_isspace(c)) {
            rb_ary_push(result, rb_str_subseq(str, beg, end-beg));
            skip = 1;
            beg = ptr - bptr;
            if (!NIL_P(limit)) ++i;
        }
        else {
            end = ptr - bptr;
        }
        }
    }
    }
    else if (split_type == string) {
    char *ptr = RSTRING_PTR(str);
    char *temp = ptr;
    char *eptr = RSTRING_END(str);
    char *sptr = RSTRING_PTR(spat);
    long slen = RSTRING_LEN(spat);

    if (is_broken_string(str)) {
        rb_raise(rb_eArgError, &quot;invalid byte sequence in %s&quot;, rb_enc_name(STR_ENC_GET(str)));
    }
    if (is_broken_string(spat)) {
        rb_raise(rb_eArgError, &quot;invalid byte sequence in %s&quot;, rb_enc_name(STR_ENC_GET(spat)));
    }
    enc = rb_enc_check(str, spat);
    while (ptr &lt; eptr &amp;&amp;
           (end = rb_memsearch(sptr, slen, ptr, eptr - ptr, enc)) &gt;= 0) {
        /* Check we are at the start of a char */
        char *t = rb_enc_right_char_head(ptr, ptr + end, eptr, enc);
        if (t != ptr + end) {
        ptr = t;
        continue;
        }
        rb_ary_push(result, rb_str_subseq(str, ptr - temp, end));
        ptr += end + slen;
        if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
    }
    beg = ptr - temp;
    }
    else {
    char *ptr = RSTRING_PTR(str);
    long len = RSTRING_LEN(str);
    long start = beg;
    long idx;
    int last_null = 0;
    struct re_registers *regs;

    while ((end = rb_reg_search(spat, str, start, 0)) &gt;= 0) {
        regs = RMATCH_REGS(rb_backref_get());
        if (start == end &amp;&amp; BEG(0) == END(0)) {
        if (!ptr) {
            rb_ary_push(result, str_new_empty(str));
            break;
        }
        else if (last_null == 1) {
            rb_ary_push(result, rb_str_subseq(str, beg,
                              rb_enc_fast_mbclen(ptr+beg,
                                     ptr+len,
                                     enc)));
            beg = start;
        }
        else {
                    if (ptr+start == ptr+len)
                        start++;
                    else
                        start += rb_enc_fast_mbclen(ptr+start,ptr+len,enc);
            last_null = 1;
            continue;
        }
        }
        else {
        rb_ary_push(result, rb_str_subseq(str, beg, end-beg));
        beg = start = END(0);
        }
        last_null = 0;

        for (idx=1; idx &lt; regs-&gt;num_regs; idx++) {
        if (BEG(idx) == -1) continue;
        if (BEG(idx) == END(idx))
            tmp = str_new_empty(str);
        else
            tmp = rb_str_subseq(str, BEG(idx), END(idx)-BEG(idx));
        rb_ary_push(result, tmp);
        }
        if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
    }
    }
    if (RSTRING_LEN(str) &gt; 0 &amp;&amp; (!NIL_P(limit) || RSTRING_LEN(str) &gt; beg || lim &lt; 0)) {
    if (RSTRING_LEN(str) == beg)
        tmp = str_new_empty(str);
    else
        tmp = rb_str_subseq(str, beg, RSTRING_LEN(str)-beg);
    rb_ary_push(result, tmp);
    }
    if (NIL_P(limit) &amp;&amp; lim == 0) {
    long len;
    while ((len = RARRAY_LEN(result)) &gt; 0 &amp;&amp;
           (tmp = RARRAY_PTR(result)[len-1], RSTRING_LEN(tmp) == 0))
        rb_ary_pop(result);
    }

    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="squeeze-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>squeeze</strong>([other_str]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Builds a set of characters from the <em>other_str</em> parameter(s) using
the procedure described for <tt>String#count</tt>. Returns a new string
where runs of the same character that occur in this set are replaced by a
single character. If no arguments are given, all runs of identical
characters are replaced by a single character.
</p>
<pre class="code">
   &quot;yellow moon&quot;.squeeze                  #=&gt; &quot;yelow mon&quot;
   &quot;  now   is  the&quot;.squeeze(&quot; &quot;)         #=&gt; &quot; now is the&quot;
   &quot;putters shoot balls&quot;.squeeze(&quot;m-z&quot;)   #=&gt; &quot;puters shot balls&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.squeeze([other_str]*)    -&gt; new_str
 *
 *  Builds a set of characters from the &lt;i&gt;other_str&lt;/i&gt; parameter(s) using the
 *  procedure described for &lt;code&gt;String#count&lt;/code&gt;. Returns a new string
 *  where runs of the same character that occur in this set are replaced by a
 *  single character. If no arguments are given, all runs of identical
 *  characters are replaced by a single character.
 *
 *     &quot;yellow moon&quot;.squeeze                  #=&gt; &quot;yelow mon&quot;
 *     &quot;  now   is  the&quot;.squeeze(&quot; &quot;)         #=&gt; &quot; now is the&quot;
 *     &quot;putters shoot balls&quot;.squeeze(&quot;m-z&quot;)   #=&gt; &quot;puters shot balls&quot;
 */

static VALUE
rb_str_squeeze(int argc, VALUE *argv, VALUE str)
{
    str = rb_str_dup(str);
    rb_str_squeeze_bang(argc, argv, str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="squeeze!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>squeeze!</strong>([other_str]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Squeezes <em>str</em> in place, returning either <em>str</em>, or
<tt>nil</tt> if no changes were made.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.squeeze!([other_str]*)   -&gt; str or nil
 *
 *  Squeezes &lt;i&gt;str&lt;/i&gt; in place, returning either &lt;i&gt;str&lt;/i&gt;, or
 *  &lt;code&gt;nil&lt;/code&gt; if no changes were made.
 */

static VALUE
rb_str_squeeze_bang(int argc, VALUE *argv, VALUE str)
{
    char squeez[256];
    rb_encoding *enc = 0;
    VALUE del = 0, nodel = 0;
    char *s, *send, *t;
    int i, modify = 0;
    int ascompat, singlebyte = single_byte_optimizable(str);
    unsigned int save;

    if (argc == 0) {
    enc = STR_ENC_GET(str);
    }
    else {
    for (i=0; i&lt;argc; i++) {
        VALUE s = argv[i];

        StringValue(s);
        enc = rb_enc_check(str, s);
        if (singlebyte &amp;&amp; !single_byte_optimizable(s))
        singlebyte = 0;
        tr_setup_table(s, squeez, i==0, &amp;del, &amp;nodel, enc);
    }
    }

    str_modify_keep_cr(str);
    s = t = RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return Qnil;
    send = RSTRING_END(str);
    save = -1;
    ascompat = rb_enc_asciicompat(enc);

    if (singlebyte) {
        while (s &lt; send) {
        unsigned int c = *(unsigned char*)s++;
        if (c != save || (argc &gt; 0 &amp;&amp; !squeez[c])) {
            *t++ = save = c;
        }
    }
    } else {
    while (s &lt; send) {
        unsigned int c;
        int clen;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
        if (c != save || (argc &gt; 0 &amp;&amp; !squeez[c])) {
            *t++ = save = c;
        }
        s++;
        }
        else {
        c = rb_enc_codepoint_len(s, send, &amp;clen, enc);

        if (c != save || (argc &gt; 0 &amp;&amp; !tr_find(c, squeez, del, nodel))) {
            if (t != s) rb_enc_mbcput(c, t, enc);
            save = c;
            t += clen;
        }
        s += clen;
        }
    }
    }

    *t = '\0';
    if (t - RSTRING_PTR(str) != RSTRING_LEN(str)) {
    STR_SET_LEN(str, t - RSTRING_PTR(str));
    modify = 1;
    }

    if (modify) return str;
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="start_with?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>start_with?</strong>([prefix]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true if <em>str</em> starts with a prefix given.
</p>
<pre class="code">
  p &quot;hello&quot;.start_with?(&quot;hell&quot;)               #=&gt; true

  # returns true if one of prefix matches.
  p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;hell&quot;)     #=&gt; true
  p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;paradice&quot;) #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.start_with?([prefix]+)   -&gt; true or false
 *
 *  Returns true if &lt;i&gt;str&lt;/i&gt; starts with a prefix given.
 *
 *    p &quot;hello&quot;.start_with?(&quot;hell&quot;)               #=&gt; true
 *
 *    # returns true if one of prefix matches.
 *    p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;hell&quot;)     #=&gt; true
 *    p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;paradice&quot;) #=&gt; false
 *
 *
 *
 */

static VALUE
rb_str_start_with(int argc, VALUE *argv, VALUE str)
{
    int i;

    for (i=0; i&lt;argc; i++) {
    VALUE tmp = rb_check_string_type(argv[i]);
    if (NIL_P(tmp)) continue;
    rb_enc_check(str, tmp);
    if (RSTRING_LEN(str) &lt; RSTRING_LEN(tmp)) continue;
    if (memcmp(RSTRING_PTR(str), RSTRING_PTR(tmp), RSTRING_LEN(tmp)) == 0)
        return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="strip-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>strip</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with leading and trailing whitespace
removed.
</p>
<pre class="code">
   &quot;    hello    &quot;.strip   #=&gt; &quot;hello&quot;
   &quot;\tgoodbye\r\n&quot;.strip   #=&gt; &quot;goodbye&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.strip   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with leading and trailing whitespace removed.
 *
 *     &quot;    hello    &quot;.strip   #=&gt; &quot;hello&quot;
 *     &quot;\tgoodbye\r\n&quot;.strip   #=&gt; &quot;goodbye&quot;
 */

static VALUE
rb_str_strip(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_strip_bang(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="strip!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>strip!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Removes leading and trailing whitespace from <em>str</em>. Returns
<tt>nil</tt> if <em>str</em> was not altered.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.strip!   -&gt; str or nil
 *
 *  Removes leading and trailing whitespace from &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; was not altered.
 */

static VALUE
rb_str_strip_bang(VALUE str)
{
    VALUE l = rb_str_lstrip_bang(str);
    VALUE r = rb_str_rstrip_bang(str);

    if (NIL_P(l) &amp;&amp; NIL_P(r)) return Qnil;
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sub-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>sub</strong>(pattern, replacement) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>sub</strong>(pattern, hash) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>sub</strong>(pattern) {|match| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with the <em>first</em> occurrence of
<em>pattern</em> substituted for the second argument. The <em>pattern</em>
is typically a <tt>Regexp</tt>; if given as a <tt>String</tt>, any regular
expression metacharacters it contains will be interpreted literally, e.g.
<tt>'\\d'</tt> will match a backlash followed by &#8216;d&#8217;, instead
of a digit.
</p>
<p>
If <em>replacement</em> is a <tt>String</tt> it will be substituted for the
matched text. It may contain back-references to the pattern&#8217;s capture
groups of the form <tt>\\d</tt>, where <em>d</em> is a group number, or
<tt>\\k&lt;n&gt;</tt>, where <em>n</em> is a group name. If it is a
double-quoted string, both back-references must be preceded by an
additional backslash. However, within <em>replacement</em> the special
match variables, such as <tt>&amp;$</tt>, will not refer to the current
match.
</p>
<p>
If the second argument is a <tt>Hash</tt>, and the matched text is one of
its keys, the corresponding value is the replacement string.
</p>
<p>
In the block form, the current match string is passed in as a parameter,
and variables such as <tt>$1</tt>, <tt>$2</tt>, <tt>$`</tt>,
<tt>$&amp;</tt>, and <tt>$'</tt> will be set appropriately. The value
returned by the block will be substituted for the match on each call.
</p>
<p>
The result inherits any tainting in the original string or any supplied
replacement string.
</p>
<pre class="code">
   &quot;hello&quot;.sub(/[aeiou]/, '*')                  #=&gt; &quot;h*llo&quot;
   &quot;hello&quot;.sub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; &quot;h&lt;e&gt;llo&quot;
   &quot;hello&quot;.sub(/./) {|s| s.ord.to_s + ' ' }     #=&gt; &quot;104 ello&quot;
   &quot;hello&quot;.sub(/(?&lt;foo&gt;[aeiou])/, '*\k&lt;foo&gt;*')  #=&gt; &quot;h*e*llo&quot;
   'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)
    #=&gt; &quot;Is /bin/bash your preferred shell?&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>sub</strong>(pattern, replacement) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>sub</strong>(pattern, hash) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>sub</strong>(pattern) {|match| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>match</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.sub(pattern, replacement)         -&gt; new_str
 *     str.sub(pattern, hash)                -&gt; new_str
 *     str.sub(pattern) {|match| block }     -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with the &lt;em&gt;first&lt;/em&gt; occurrence of
 *  &lt;i&gt;pattern&lt;/i&gt; substituted for the second argument. The &lt;i&gt;pattern&lt;/i&gt; is
 *  typically a &lt;code&gt;Regexp&lt;/code&gt;; if given as a &lt;code&gt;String&lt;/code&gt;, any
 *  regular expression metacharacters it contains will be interpreted
 *  literally, e.g. &lt;code&gt;'\\\d'&lt;/code&gt; will match a backlash followed by 'd',
 *  instead of a digit.
 *
 *  If &lt;i&gt;replacement&lt;/i&gt; is a &lt;code&gt;String&lt;/code&gt; it will be substituted for
 *  the matched text. It may contain back-references to the pattern's capture
 *  groups of the form &lt;code&gt;\\\d&lt;/code&gt;, where &lt;i&gt;d&lt;/i&gt; is a group number, or
 *  &lt;code&gt;\\\k&lt;n&gt;&lt;/code&gt;, where &lt;i&gt;n&lt;/i&gt; is a group name. If it is a
 *  double-quoted string, both back-references must be preceded by an
 *  additional backslash. However, within &lt;i&gt;replacement&lt;/i&gt; the special match
 *  variables, such as &lt;code&gt;&amp;$&lt;/code&gt;, will not refer to the current match.
 *
 *  If the second argument is a &lt;code&gt;Hash&lt;/code&gt;, and the matched text is one
 *  of its keys, the corresponding value is the replacement string.
 *
 *  In the block form, the current match string is passed in as a parameter,
 *  and variables such as &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt;,
 *  &lt;code&gt;$&amp;&lt;/code&gt;, and &lt;code&gt;$'&lt;/code&gt; will be set appropriately. The value
 *  returned by the block will be substituted for the match on each call.
 *
 *  The result inherits any tainting in the original string or any supplied
 *  replacement string.
 *
 *     &quot;hello&quot;.sub(/[aeiou]/, '*')                  #=&gt; &quot;h*llo&quot;
 *     &quot;hello&quot;.sub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; &quot;h&lt;e&gt;llo&quot;
 *     &quot;hello&quot;.sub(/./) {|s| s.ord.to_s + ' ' }     #=&gt; &quot;104 ello&quot;
 *     &quot;hello&quot;.sub(/(?&lt;foo&gt;[aeiou])/, '*\k&lt;foo&gt;*')  #=&gt; &quot;h*e*llo&quot;
 *     'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)
 *      #=&gt; &quot;Is /bin/bash your preferred shell?&quot;
 */

static VALUE
rb_str_sub(int argc, VALUE *argv, VALUE str)
{
    str = rb_str_dup(str);
    rb_str_sub_bang(argc, argv, str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sub!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>sub!</strong>(pattern, replacement) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>sub!</strong>(pattern) {|match| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Performs the substitutions of <tt>String#sub</tt> in place, returning
<em>str</em>, or <tt>nil</tt> if no substitutions were performed.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>sub!</strong>(pattern, replacement) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>sub!</strong>(pattern) {|match| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>match</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.sub!(pattern, replacement)          -&gt; str or nil
 *     str.sub!(pattern) {|match| block }      -&gt; str or nil
 *
 *  Performs the substitutions of &lt;code&gt;String#sub&lt;/code&gt; in place,
 *  returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no substitutions were
 *  performed.
 */

static VALUE
rb_str_sub_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE pat, repl, hash = Qnil;
    int iter = 0;
    int tainted = 0;
    int untrusted = 0;
    long plen;

    if (argc == 1 &amp;&amp; rb_block_given_p()) {
    iter = 1;
    }
    else if (argc == 2) {
    repl = argv[1];
    hash = rb_check_convert_type(argv[1], T_HASH, &quot;Hash&quot;, &quot;to_hash&quot;);
    if (NIL_P(hash)) {
        StringValue(repl);
    }
    if (OBJ_TAINTED(repl)) tainted = 1;
    if (OBJ_UNTRUSTED(repl)) untrusted = 1;
    }
    else {
    rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1..2)&quot;, argc);
    }

    pat = get_pat(argv[0], 1);
    str_modifiable(str);
    if (rb_reg_search(pat, str, 0, 0) &gt;= 0) {
    rb_encoding *enc;
    int cr = ENC_CODERANGE(str);
    VALUE match = rb_backref_get();
    struct re_registers *regs = RMATCH_REGS(match);
    long beg0 = BEG(0);
    long end0 = END(0);
    char *p, *rp;
    long len, rlen;

    if (iter || !NIL_P(hash)) {
        p = RSTRING_PTR(str); len = RSTRING_LEN(str);

            if (iter) {
                repl = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
            }
            else {
                repl = rb_hash_aref(hash, rb_str_subseq(str, beg0, end0 - beg0));
                repl = rb_obj_as_string(repl);
            }
        str_mod_check(str, p, len);
        str_frozen_check(str);
    }
    else {
        repl = rb_reg_regsub(repl, str, regs, pat);
    }
        enc = rb_enc_compatible(str, repl);
        if (!enc) {
            rb_encoding *str_enc = STR_ENC_GET(str);
        p = RSTRING_PTR(str); len = RSTRING_LEN(str);
        if (coderange_scan(p, beg0, str_enc) != ENC_CODERANGE_7BIT ||
        coderange_scan(p+end0, len-end0, str_enc) != ENC_CODERANGE_7BIT) {
                rb_raise(rb_eEncCompatError, &quot;incompatible character encodings: %s and %s&quot;,
             rb_enc_name(str_enc),
             rb_enc_name(STR_ENC_GET(repl)));
            }
            enc = STR_ENC_GET(repl);
        }
    rb_str_modify(str);
    rb_enc_associate(str, enc);
    if (OBJ_TAINTED(repl)) tainted = 1;
    if (OBJ_UNTRUSTED(repl)) untrusted = 1;
    if (ENC_CODERANGE_UNKNOWN &lt; cr &amp;&amp; cr &lt; ENC_CODERANGE_BROKEN) {
        int cr2 = ENC_CODERANGE(repl);
            if (cr2 == ENC_CODERANGE_BROKEN ||
                (cr == ENC_CODERANGE_VALID &amp;&amp; cr2 == ENC_CODERANGE_7BIT))
                cr = ENC_CODERANGE_UNKNOWN;
            else
                cr = cr2;
    }
    plen = end0 - beg0;
    rp = RSTRING_PTR(repl); rlen = RSTRING_LEN(repl);
    len = RSTRING_LEN(str);
    if (rlen &gt; plen) {
        RESIZE_CAPA(str, len + rlen - plen);
    }
    p = RSTRING_PTR(str);
    if (rlen != plen) {
        memmove(p + beg0 + rlen, p + beg0 + plen, len - beg0 - plen);
    }
    memcpy(p + beg0, rp, rlen);
    len += rlen - plen;
    STR_SET_LEN(str, len);
    RSTRING_PTR(str)[len] = '\0';
    ENC_CODERANGE_SET(str, cr);
    if (tainted) OBJ_TAINT(str);
    if (untrusted) OBJ_UNTRUST(str);

    return str;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="succ-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the successor to <em>str</em>. The successor is calculated by
incrementing characters starting from the rightmost alphanumeric (or the
rightmost character if there are no alphanumerics) in the string.
Incrementing a digit always results in another digit, and incrementing a
letter results in another letter of the same case. Incrementing
nonalphanumerics uses the underlying character set&#8217;s collating
sequence.
</p>
<p>
If the increment generates a ``carry,&#8217;&#8217; the character to the
left of it is incremented. This process repeats until there is no carry,
adding an additional character if necessary.
</p>
<pre class="code">
   &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
   &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
   &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
   &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
   &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
   &quot;***&quot;.succ         #=&gt; &quot;**+&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.succ   -&gt; new_str
 *     str.next   -&gt; new_str
 *
 *  Returns the successor to &lt;i&gt;str&lt;/i&gt;. The successor is calculated by
 *  incrementing characters starting from the rightmost alphanumeric (or
 *  the rightmost character if there are no alphanumerics) in the
 *  string. Incrementing a digit always results in another digit, and
 *  incrementing a letter results in another letter of the same case.
 *  Incrementing nonalphanumerics uses the underlying character set's
 *  collating sequence.
 *
 *  If the increment generates a ``carry,'' the character to the left of
 *  it is incremented. This process repeats until there is no carry,
 *  adding an additional character if necessary.
 *
 *     &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
 *     &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
 *     &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
 *     &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
 *     &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
 *     &quot;***&quot;.succ         #=&gt; &quot;**+&quot;
 */

VALUE
rb_str_succ(VALUE orig)
{
    rb_encoding *enc;
    VALUE str;
    char *sbeg, *s, *e, *last_alnum = 0;
    int c = -1;
    long l;
    char carry[ONIGENC_CODE_TO_MBC_MAXLEN] = &quot;\1&quot;;
    long carry_pos = 0, carry_len = 1;
    enum neighbor_char neighbor = NEIGHBOR_FOUND;

    str = rb_str_new5(orig, RSTRING_PTR(orig), RSTRING_LEN(orig));
    rb_enc_cr_str_copy_for_substr(str, orig);
    OBJ_INFECT(str, orig);
    if (RSTRING_LEN(str) == 0) return str;

    enc = STR_ENC_GET(orig);
    sbeg = RSTRING_PTR(str);
    s = e = sbeg + RSTRING_LEN(str);

    while ((s = rb_enc_prev_char(sbeg, s, e, enc)) != 0) {
    if (neighbor == NEIGHBOR_NOT_CHAR &amp;&amp; last_alnum) {
        if (ISALPHA(*last_alnum) ? ISDIGIT(*s) :
        ISDIGIT(*last_alnum) ? ISALPHA(*s) : 0) {
        s = last_alnum;
        break;
        }
    }
    if ((l = rb_enc_precise_mbclen(s, e, enc)) &lt;= 0) continue;
        neighbor = enc_succ_alnum_char(s, l, enc, carry);
        switch (neighbor) {
      case NEIGHBOR_NOT_CHAR:
        continue;
      case NEIGHBOR_FOUND:
        return str;
      case NEIGHBOR_WRAPPED:
        last_alnum = s;
        break;
    }
        c = 1;
        carry_pos = s - sbeg;
        carry_len = l;
    }
    if (c == -1) {      /* str contains no alnum */
    s = e;
    while ((s = rb_enc_prev_char(sbeg, s, e, enc)) != 0) {
            enum neighbor_char neighbor;
            if ((l = rb_enc_precise_mbclen(s, e, enc)) &lt;= 0) continue;
            neighbor = enc_succ_char(s, l, enc);
            if (neighbor == NEIGHBOR_FOUND)
                return str;
            if (rb_enc_precise_mbclen(s, s+l, enc) != l) {
                /* wrapped to \0...\0.  search next valid char. */
                enc_succ_char(s, l, enc);
            }
            if (!rb_enc_asciicompat(enc)) {
                MEMCPY(carry, s, char, l);
                carry_len = l;
            }
            carry_pos = s - sbeg;
    }
    }
    RESIZE_CAPA(str, RSTRING_LEN(str) + carry_len);
    s = RSTRING_PTR(str) + carry_pos;
    memmove(s + carry_len, s, RSTRING_LEN(str) - carry_pos);
    memmove(s, carry, carry_len);
    STR_SET_LEN(str, RSTRING_LEN(str) + carry_len);
    RSTRING_PTR(str)[RSTRING_LEN(str)] = '\0';
    rb_enc_str_coderange(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="succ!-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ!</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next!</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equivalent to <tt>String#succ</tt>, but modifies the receiver in place.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>succ!</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>next!</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.succ!   -&gt; str
 *     str.next!   -&gt; str
 *
 *  Equivalent to &lt;code&gt;String#succ&lt;/code&gt;, but modifies the receiver in
 *  place.
 */

static VALUE
rb_str_succ_bang(VALUE str)
{
    rb_str_shared_replace(str, rb_str_succ(str));

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sum-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>sum</strong>(n = 16) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a basic <em>n</em>-bit checksum of the characters in <em>str</em>,
where <em>n</em> is the optional <tt>Fixnum</tt> parameter, defaulting to
16. The result is simply the sum of the binary value of each character in
<em>str</em> modulo <tt>2**n - 1</tt>. This is not a particularly good
checksum.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.sum(n=16)   -&gt; integer
 *
 *  Returns a basic &lt;em&gt;n&lt;/em&gt;-bit checksum of the characters in &lt;i&gt;str&lt;/i&gt;,
 *  where &lt;em&gt;n&lt;/em&gt; is the optional &lt;code&gt;Fixnum&lt;/code&gt; parameter, defaulting
 *  to 16. The result is simply the sum of the binary value of each character in
 *  &lt;i&gt;str&lt;/i&gt; modulo &lt;code&gt;2**n - 1&lt;/code&gt;. This is not a particularly good
 *  checksum.
 */

static VALUE
rb_str_sum(int argc, VALUE *argv, VALUE str)
{
    VALUE vbits;
    int bits;
    char *ptr, *p, *pend;
    long len;
    VALUE sum = INT2FIX(0);
    unsigned long sum0 = 0;

    if (argc == 0) {
    bits = 16;
    }
    else {
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;vbits);
    bits = NUM2INT(vbits);
    }
    ptr = p = RSTRING_PTR(str);
    len = RSTRING_LEN(str);
    pend = p + len;

    while (p &lt; pend) {
        if (FIXNUM_MAX - UCHAR_MAX &lt; sum0) {
            sum = rb_funcall(sum, '+', 1, LONG2FIX(sum0));
            str_mod_check(str, ptr, len);
            sum0 = 0;
        }
        sum0 += (unsigned char)*p;
        p++;
    }

    if (bits == 0) {
        if (sum0) {
            sum = rb_funcall(sum, '+', 1, LONG2FIX(sum0));
        }
    }
    else {
        if (sum == INT2FIX(0)) {
            if (bits &lt; (int)sizeof(long)*CHAR_BIT) {
                sum0 &amp;= (((unsigned long)1)&lt;&lt;bits)-1;
            }
            sum = LONG2FIX(sum0);
        }
        else {
            VALUE mod;

            if (sum0) {
                sum = rb_funcall(sum, '+', 1, LONG2FIX(sum0));
            }

            mod = rb_funcall(INT2FIX(1), rb_intern(&quot;&lt;&lt;&quot;), 1, INT2FIX(bits));
            mod = rb_funcall(mod, '-', 1, INT2FIX(1));
            sum = rb_funcall(sum, '&amp;', 1, mod);
        }
    }
    return sum;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="swapcase-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>swapcase</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with uppercase alphabetic characters
converted to lowercase and lowercase characters converted to uppercase.
Note: case conversion is effective only in ASCII region.
</p>
<pre class="code">
   &quot;Hello&quot;.swapcase          #=&gt; &quot;hELLO&quot;
   &quot;cYbEr_PuNk11&quot;.swapcase   #=&gt; &quot;CyBeR_pUnK11&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.swapcase   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with uppercase alphabetic characters converted
 *  to lowercase and lowercase characters converted to uppercase.
 *  Note: case conversion is effective only in ASCII region.
 *
 *     &quot;Hello&quot;.swapcase          #=&gt; &quot;hELLO&quot;
 *     &quot;cYbEr_PuNk11&quot;.swapcase   #=&gt; &quot;CyBeR_pUnK11&quot;
 */

static VALUE
rb_str_swapcase(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_swapcase_bang(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="swapcase!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>swapcase!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Equivalent to <tt>String#swapcase</tt>, but modifies the receiver in place,
returning <em>str</em>, or <tt>nil</tt> if no changes were made. Note: case
conversion is effective only in ASCII region.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
*     str.swapcase!   -&gt; str or nil
 *
 *  Equivalent to &lt;code&gt;String#swapcase&lt;/code&gt;, but modifies the receiver in
 *  place, returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no changes were made.
 *  Note: case conversion is effective only in ASCII region.
 */

static VALUE
rb_str_swapcase_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *send;
    int modify = 0;
    int n;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    rb_str_check_dummy_enc(enc);
    s = RSTRING_PTR(str); send = RSTRING_END(str);
    while (s &lt; send) {
    unsigned int c = rb_enc_codepoint_len(s, send, &amp;n, enc);

    if (rb_enc_isupper(c, enc)) {
        /* assuming toupper returns codepoint with same size */
        rb_enc_mbcput(rb_enc_tolower(c, enc), s, enc);
        modify = 1;
    }
    else if (rb_enc_islower(c, enc)) {
        /* assuming tolower returns codepoint with same size */
        rb_enc_mbcput(rb_enc_toupper(c, enc), s, enc);
        modify = 1;
    }
    s += n;
    }

    if (modify) return str;
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_c-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_c</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a complex which denotes the string form.  The parser ignores
leading whitespaces and trailing garbage.  Any digit sequences can be
separated by an underscore.  Returns zero for null or garbage string.
</p>
<p>
For example:
</p>
<pre class="code">
   '9'.to_c           #=&gt; (9+0i)
   '2.5'.to_c         #=&gt; (2.5+0i)
   '2.5/1'.to_c       #=&gt; ((5/2)+0i)
   '-3/2'.to_c        #=&gt; ((-3/2)+0i)
   '-i'.to_c          #=&gt; (0-1i)
   '45i'.to_c         #=&gt; (0+45i)
   '3-4i'.to_c        #=&gt; (3-4i)
   '-4e2-4e-2i'.to_c  #=&gt; (-400.0-0.04i)
   '-0.0-0.0i'.to_c   #=&gt; (-0.0-0.0i)
   '1/2+3/4i'.to_c    #=&gt; ((1/2)+(3/4)*i)
   'ruby'.to_c        #=&gt; (0+0i)</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'complex.c'</span>

/*
 * call-seq:
 *    str.to_c  -&gt;  complex
 *
 * Returns a complex which denotes the string form.  The parser
 * ignores leading whitespaces and trailing garbage.  Any digit
 * sequences can be separated by an underscore.  Returns zero for null
 * or garbage string.
 *
 * For example:
 *
 *    '9'.to_c           #=&gt; (9+0i)
 *    '2.5'.to_c         #=&gt; (2.5+0i)
 *    '2.5/1'.to_c       #=&gt; ((5/2)+0i)
 *    '-3/2'.to_c        #=&gt; ((-3/2)+0i)
 *    '-i'.to_c          #=&gt; (0-1i)
 *    '45i'.to_c         #=&gt; (0+45i)
 *    '3-4i'.to_c        #=&gt; (3-4i)
 *    '-4e2-4e-2i'.to_c  #=&gt; (-400.0-0.04i)
 *    '-0.0-0.0i'.to_c   #=&gt; (-0.0-0.0i)
 *    '1/2+3/4i'.to_c    #=&gt; ((1/2)+(3/4)*i)
 *    'ruby'.to_c        #=&gt; (0+0i)
 */
static VALUE
string_to_c(VALUE self)
{
    VALUE s, a, backref;

    backref = rb_backref_get();
    rb_match_busy(backref);

    s = f_gsub(self, underscores_pat, an_underscore);
    a = string_to_c_internal(s);

    rb_backref_set(backref);

    if (!NIL_P(RARRAY_PTR(a)[0]))
    return RARRAY_PTR(a)[0];
    return rb_complex_new1(INT2FIX(0));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_f-instance_method">
  
    - (<tt><span class='object_link'><a href="Float.html" title="Float (class)">Float</a></span></tt>) <strong>to_f</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the result of interpreting leading characters in <em>str</em> as a
floating point number. Extraneous characters past the end of a valid number
are ignored. If there is not a valid number at the start of <em>str</em>,
<tt>0.0</tt> is returned. This method never raises an exception.
</p>
<pre class="code">
   &quot;123.45e1&quot;.to_f        #=&gt; 1234.5
   &quot;45.67 degrees&quot;.to_f   #=&gt; 45.67
   &quot;thx1138&quot;.to_f         #=&gt; 0.0</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Float.html" title="Float (class)">Float</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.to_f   -&gt; float
 *
 *  Returns the result of interpreting leading characters in &lt;i&gt;str&lt;/i&gt; as a
 *  floating point number. Extraneous characters past the end of a valid number
 *  are ignored. If there is not a valid number at the start of &lt;i&gt;str&lt;/i&gt;,
 *  &lt;code&gt;0.0&lt;/code&gt; is returned. This method never raises an exception.
 *
 *     &quot;123.45e1&quot;.to_f        #=&gt; 1234.5
 *     &quot;45.67 degrees&quot;.to_f   #=&gt; 45.67
 *     &quot;thx1138&quot;.to_f         #=&gt; 0.0
 */

static VALUE
rb_str_to_f(VALUE str)
{
    return DBL2NUM(rb_str_to_dbl(str, FALSE));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_i-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>to_i</strong>(base = 10) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the result of interpreting leading characters in <em>str</em> as an
integer base <em>base</em> (between 2 and 36). Extraneous characters past
the end of a valid number are ignored. If there is not a valid number at
the start of <em>str</em>, <tt>0</tt> is returned. This method never raises
an exception.
</p>
<pre class="code">
   &quot;12345&quot;.to_i             #=&gt; 12345
   &quot;99 red balloons&quot;.to_i   #=&gt; 99
   &quot;0a&quot;.to_i                #=&gt; 0
   &quot;0a&quot;.to_i(16)            #=&gt; 10
   &quot;hello&quot;.to_i             #=&gt; 0
   &quot;1100101&quot;.to_i(2)        #=&gt; 101
   &quot;1100101&quot;.to_i(8)        #=&gt; 294977
   &quot;1100101&quot;.to_i(10)       #=&gt; 1100101
   &quot;1100101&quot;.to_i(16)       #=&gt; 17826049</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.to_i(base=10)   -&gt; integer
 *
 *  Returns the result of interpreting leading characters in &lt;i&gt;str&lt;/i&gt; as an
 *  integer base &lt;i&gt;base&lt;/i&gt; (between 2 and 36). Extraneous characters past the
 *  end of a valid number are ignored. If there is not a valid number at the
 *  start of &lt;i&gt;str&lt;/i&gt;, &lt;code&gt;0&lt;/code&gt; is returned. This method never raises an
 *  exception.
 *
 *     &quot;12345&quot;.to_i             #=&gt; 12345
 *     &quot;99 red balloons&quot;.to_i   #=&gt; 99
 *     &quot;0a&quot;.to_i                #=&gt; 0
 *     &quot;0a&quot;.to_i(16)            #=&gt; 10
 *     &quot;hello&quot;.to_i             #=&gt; 0
 *     &quot;1100101&quot;.to_i(2)        #=&gt; 101
 *     &quot;1100101&quot;.to_i(8)        #=&gt; 294977
 *     &quot;1100101&quot;.to_i(10)       #=&gt; 1100101
 *     &quot;1100101&quot;.to_i(16)       #=&gt; 17826049
 */

static VALUE
rb_str_to_i(int argc, VALUE *argv, VALUE str)
{
    int base;

    if (argc == 0) base = 10;
    else {
    VALUE b;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;b);
    base = NUM2INT(b);
    }
    if (base &lt; 0) {
    rb_raise(rb_eArgError, &quot;invalid radix %d&quot;, base);
    }
    return rb_str_to_inum(str, base, FALSE);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_r-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_r</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a rational which denotes the string form.  The parser ignores
leading whitespaces and trailing garbage.  Any digit sequences can be
separated by an underscore.  Returns zero for null or garbage string.
</p>
<p>
NOTE: &#8216;0.3&#8217;.to_r isn&#8217;t the same as 0.3.to_r.  The former
is equivalent to &#8216;3/10&#8217;.to_r, but the latter isn&#8217;t so.
</p>
<p>
For example:
</p>
<pre class="code">
   '  2  '.to_r       #=&gt; (2/1)
   '300/2'.to_r       #=&gt; (150/1)
   '-9.2'.to_r        #=&gt; (-46/5)
   '-9.2e2'.to_r      #=&gt; (-920/1)
   '1_234_567'.to_r   #=&gt; (1234567/1)
   '21 june 09'.to_r  #=&gt; (21/1)
   '21/06/09'.to_r    #=&gt; (7/2)
   'bwv 1079'.to_r    #=&gt; (0/1)</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'rational.c'</span>

/*
 * call-seq:
 *    str.to_r  -&gt;  rational
 *
 * Returns a rational which denotes the string form.  The parser
 * ignores leading whitespaces and trailing garbage.  Any digit
 * sequences can be separated by an underscore.  Returns zero for null
 * or garbage string.
 *
 * NOTE: '0.3'.to_r isn't the same as 0.3.to_r.  The former is
 * equivalent to '3/10'.to_r, but the latter isn't so.
 *
 * For example:
 *
 *    '  2  '.to_r       #=&gt; (2/1)
 *    '300/2'.to_r       #=&gt; (150/1)
 *    '-9.2'.to_r        #=&gt; (-46/5)
 *    '-9.2e2'.to_r      #=&gt; (-920/1)
 *    '1_234_567'.to_r   #=&gt; (1234567/1)
 *    '21 june 09'.to_r  #=&gt; (21/1)
 *    '21/06/09'.to_r    #=&gt; (7/2)
 *    'bwv 1079'.to_r    #=&gt; (0/1)
 */
static VALUE
string_to_r(VALUE self)
{
    VALUE s, a, backref;

    backref = rb_backref_get();
    rb_match_busy(backref);

    s = f_gsub(self, underscores_pat, an_underscore);
    a = string_to_r_internal(s);

    rb_backref_set(backref);

    if (!NIL_P(RARRAY_PTR(a)[0]))
    return RARRAY_PTR(a)[0];
    return rb_rational_new1(INT2FIX(0));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_s-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_str</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the receiver.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_str</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.to_s     -&gt; str
 *     str.to_str   -&gt; str
 *
 *  Returns the receiver.
 */

static VALUE
rb_str_to_s(VALUE str)
{
    if (rb_obj_class(str) != rb_cString) {
    return str_duplicate(rb_cString, str);
    }
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_str-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_str</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the receiver.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_s</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>to_str</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.to_s     -&gt; str
 *     str.to_str   -&gt; str
 *
 *  Returns the receiver.
 */

static VALUE
rb_str_to_s(VALUE str)
{
    if (rb_obj_class(str) != rb_cString) {
    return str_duplicate(rb_cString, str);
    }
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_sym-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>intern</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>to_sym</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the <tt>Symbol</tt> corresponding to <em>str</em>, creating the
symbol if it did not previously exist. See <tt>Symbol#id2name</tt>.
</p>
<pre class="code">
   &quot;Koala&quot;.intern         #=&gt; :Koala
   s = 'cat'.to_sym       #=&gt; :cat
   s == :cat              #=&gt; true
   s = '@cat'.to_sym      #=&gt; :@cat
   s == :@cat             #=&gt; true
</pre>
<p>
This can also be used to create symbols that cannot be represented using
the <tt>:xxx</tt> notation.
</p>
<pre class="code">
   'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;</pre>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.intern   -&gt; symbol
 *     str.to_sym   -&gt; symbol
 *
 *  Returns the &lt;code&gt;Symbol&lt;/code&gt; corresponding to &lt;i&gt;str&lt;/i&gt;, creating the
 *  symbol if it did not previously exist. See &lt;code&gt;Symbol#id2name&lt;/code&gt;.
 *
 *     &quot;Koala&quot;.intern         #=&gt; :Koala
 *     s = 'cat'.to_sym       #=&gt; :cat
 *     s == :cat              #=&gt; true
 *     s = '@cat'.to_sym      #=&gt; :@cat
 *     s == :@cat             #=&gt; true
 *
 *  This can also be used to create symbols that cannot be represented using the
 *  &lt;code&gt;:xxx&lt;/code&gt; notation.
 *
 *     'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;
 */

VALUE
rb_str_intern(VALUE s)
{
    VALUE str = RB_GC_GUARD(s);
    ID id;

    id = rb_intern_str(str);
    return ID2SYM(id);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tr-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>tr</strong>(from_str, to_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with the characters in <em>from_str</em>
replaced by the corresponding characters in <em>to_str</em>. If
<em>to_str</em> is shorter than <em>from_str</em>, it is padded with its
last character. Both strings may use the c1--c2 notation to denote
ranges of characters, and <em>from_str</em> may start with a <tt>^</tt>,
which denotes all characters except those listed.
</p>
<pre class="code">
   &quot;hello&quot;.tr('aeiou', '*')    #=&gt; &quot;h*ll*&quot;
   &quot;hello&quot;.tr('^aeiou', '*')   #=&gt; &quot;*e**o&quot;
   &quot;hello&quot;.tr('el', 'ip')      #=&gt; &quot;hippo&quot;
   &quot;hello&quot;.tr('a-y', 'b-z')    #=&gt; &quot;ifmmp&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.tr(from_str, to_str)   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with the characters in &lt;i&gt;from_str&lt;/i&gt; replaced
 *  by the corresponding characters in &lt;i&gt;to_str&lt;/i&gt;. If &lt;i&gt;to_str&lt;/i&gt; is
 *  shorter than &lt;i&gt;from_str&lt;/i&gt;, it is padded with its last character. Both
 *  strings may use the c1--c2 notation to denote ranges of characters, and
 *  &lt;i&gt;from_str&lt;/i&gt; may start with a &lt;code&gt;^&lt;/code&gt;, which denotes all
 *  characters except those listed.
 *
 *     &quot;hello&quot;.tr('aeiou', '*')    #=&gt; &quot;h*ll*&quot;
 *     &quot;hello&quot;.tr('^aeiou', '*')   #=&gt; &quot;*e**o&quot;
 *     &quot;hello&quot;.tr('el', 'ip')      #=&gt; &quot;hippo&quot;
 *     &quot;hello&quot;.tr('a-y', 'b-z')    #=&gt; &quot;ifmmp&quot;
 */

static VALUE
rb_str_tr(VALUE str, VALUE src, VALUE repl)
{
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 0);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tr!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>tr!</strong>(from_str, to_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Translates <em>str</em> in place, using the same rules as
<tt>String#tr</tt>. Returns <em>str</em>, or <tt>nil</tt> if no changes
were made.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.tr!(from_str, to_str)   -&gt; str or nil
 *
 *  Translates &lt;i&gt;str&lt;/i&gt; in place, using the same rules as
 *  &lt;code&gt;String#tr&lt;/code&gt;. Returns &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no
 *  changes were made.
 */

static VALUE
rb_str_tr_bang(VALUE str, VALUE src, VALUE repl)
{
    return tr_trans(str, src, repl, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tr_s-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>tr_s</strong>(from_str, to_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Processes a copy of <em>str</em> as described under <tt>String#tr</tt>,
then removes duplicate characters in regions that were affected by the
translation.
</p>
<pre class="code">
   &quot;hello&quot;.tr_s('l', 'r')     #=&gt; &quot;hero&quot;
   &quot;hello&quot;.tr_s('el', '*')    #=&gt; &quot;h*o&quot;
   &quot;hello&quot;.tr_s('el', 'hx')   #=&gt; &quot;hhxo&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.tr_s(from_str, to_str)   -&gt; new_str
 *
 *  Processes a copy of &lt;i&gt;str&lt;/i&gt; as described under &lt;code&gt;String#tr&lt;/code&gt;,
 *  then removes duplicate characters in regions that were affected by the
 *  translation.
 *
 *     &quot;hello&quot;.tr_s('l', 'r')     #=&gt; &quot;hero&quot;
 *     &quot;hello&quot;.tr_s('el', '*')    #=&gt; &quot;h*o&quot;
 *     &quot;hello&quot;.tr_s('el', 'hx')   #=&gt; &quot;hhxo&quot;
 */

static VALUE
rb_str_tr_s(VALUE str, VALUE src, VALUE repl)
{
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 1);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tr_s!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>tr_s!</strong>(from_str, to_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Performs <tt>String#tr_s</tt> processing on <em>str</em> in place,
returning <em>str</em>, or <tt>nil</tt> if no changes were made.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.tr_s!(from_str, to_str)   -&gt; str or nil
 *
 *  Performs &lt;code&gt;String#tr_s&lt;/code&gt; processing on &lt;i&gt;str&lt;/i&gt; in place,
 *  returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no changes were made.
 */

static VALUE
rb_str_tr_s_bang(VALUE str, VALUE src, VALUE repl)
{
    return tr_trans(str, src, repl, 1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="unpack-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>unpack</strong>(format) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Decodes <em>str</em> (which may contain binary data) according to the
format string, returning an array of each value extracted. The format
string consists of a sequence of single-character directives, summarized in
the table at the end of this entry. Each directive may be followed by a
number, indicating the number of times to repeat with this directive. An
asterisk (``<tt>*</tt>&#8217;&#8217;) will use up all remaining elements.
The directives <tt>sSiIlL</tt> may each be followed by an underscore
(``<tt>_</tt>&#8217;&#8217;) or exclamation mark
(``<tt>!</tt>&#8217;&#8217;) to use the underlying platform&#8217;s native
size for the specified type; otherwise, it uses a platform-independent
consistent size. Spaces are ignored in the format string. See also
<tt>Array#pack</tt>.
</p>
<pre class="code">
   &quot;abc \0\0abc \0\0&quot;.unpack('A6Z6')   #=&gt; [&quot;abc&quot;, &quot;abc &quot;]
   &quot;abc \0\0&quot;.unpack('a3a3')           #=&gt; [&quot;abc&quot;, &quot; \000\000&quot;]
   &quot;abc \0abc \0&quot;.unpack('Z*Z*')       #=&gt; [&quot;abc &quot;, &quot;abc &quot;]
   &quot;aa&quot;.unpack('b8B8')                 #=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]
   &quot;aaa&quot;.unpack('h2H2c')               #=&gt; [&quot;16&quot;, &quot;61&quot;, 97]
   &quot;\xfe\xff\xfe\xff&quot;.unpack('sS')     #=&gt; [-2, 65534]
   &quot;now=20is&quot;.unpack('M*')             #=&gt; [&quot;now is&quot;]
   &quot;whole&quot;.unpack('xax2aX2aX1aX2a')    #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
</pre>
<p>
This table summarizes the various formats and the Ruby classes returned by
each.
</p>
<pre class="code">
 Integer      |         |
 Directive    | Returns | Meaning
 -----------------------------------------------------------------
    C         | Integer | 8-bit unsigned integer (unsigned char)
    S         | Integer | 16-bit unsigned integer, native endian (uint16_t)
    L         | Integer | 32-bit unsigned integer, native endian (uint32_t)
    Q         | Integer | 64-bit unsigned integer, native endian (uint64_t)
              |         |
    c         | Integer | 8-bit signed integer (signed char)
    s         | Integer | 16-bit signed integer, native endian (int16_t)
    l         | Integer | 32-bit signed integer, native endian (int32_t)
    q         | Integer | 64-bit signed integer, native endian (int64_t)
              |         |
    S_, S!    | Integer | unsigned short, native endian
    I, I_, I! | Integer | unsigned int, native endian
    L_, L!    | Integer | unsigned long, native endian
              |         |
    s_, s!    | Integer | signed short, native endian
    i, i_, i! | Integer | signed int, native endian
    l_, l!    | Integer | signed long, native endian
              |         |
    n         | Integer | 16-bit unsigned integer, network (big-endian) byte order
    N         | Integer | 32-bit unsigned integer, network (big-endian) byte order
    v         | Integer | 16-bit unsigned integer, VAX (little-endian) byte order
    V         | Integer | 32-bit unsigned integer, VAX (little-endian) byte order
              |         |
    U         | Integer | UTF-8 character
    w         | Integer | BER-compressed integer (see Array.pack)

 Float        |         |
 Directive    | Returns | Meaning
 -----------------------------------------------------------------
    D, d      | Float   | double-precision float, native format
    F, f      | Float   | single-precision float, native format
    E         | Float   | double-precision float, little-endian byte order
    e         | Float   | single-precision float, little-endian byte order
    G         | Float   | double-precision float, network (big-endian) byte order
    g         | Float   | single-precision float, network (big-endian) byte order

 String       |         |
 Directive    | Returns | Meaning
 -----------------------------------------------------------------
    A         | String  | arbitrary binary string (remove trailing nulls and ASCII spaces)
    a         | String  | arbitrary binary string
    Z         | String  | null-terminated string
    B         | String  | bit string (MSB first)
    b         | String  | bit string (LSB first)
    H         | String  | hex string (high nibble first)
    h         | String  | hex string (low nibble first)
    u         | String  | UU-encoded string
    M         | String  | quoted-printable, MIME encoding (see RFC2045)
    m         | String  | base64 encoded string (RFC 2045) (default)
              |         | base64 encoded string (RFC 4648) if followed by 0
    P         | String  | pointer to a structure (fixed-length string)
    p         | String  | pointer to a null-terminated string

 Misc.        |         |
 Directive    | Returns | Meaning
 -----------------------------------------------------------------
    @         | ---     | skip to the offset given by the length argument
    X         | ---     | skip backward one byte
    x         | ---     | skip forward one byte</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'pack.c'</span>

/*
 *  call-seq:
 *     str.unpack(format)    -&gt;  anArray
 *
 *  Decodes &lt;i&gt;str&lt;/i&gt; (which may contain binary data) according to the
 *  format string, returning an array of each value extracted. The
 *  format string consists of a sequence of single-character directives,
 *  summarized in the table at the end of this entry.
 *  Each directive may be followed
 *  by a number, indicating the number of times to repeat with this
 *  directive. An asterisk (``&lt;code&gt;*&lt;/code&gt;'') will use up all
 *  remaining elements. The directives &lt;code&gt;sSiIlL&lt;/code&gt; may each be
 *  followed by an underscore (``&lt;code&gt;_&lt;/code&gt;'') or
 *  exclamation mark (``&lt;code&gt;!&lt;/code&gt;'') to use the underlying
 *  platform's native size for the specified type; otherwise, it uses a
 *  platform-independent consistent size. Spaces are ignored in the
 *  format string. See also &lt;code&gt;Array#pack&lt;/code&gt;.
 *
 *     &quot;abc \0\0abc \0\0&quot;.unpack('A6Z6')   #=&gt; [&quot;abc&quot;, &quot;abc &quot;]
 *     &quot;abc \0\0&quot;.unpack('a3a3')           #=&gt; [&quot;abc&quot;, &quot; \000\000&quot;]
 *     &quot;abc \0abc \0&quot;.unpack('Z*Z*')       #=&gt; [&quot;abc &quot;, &quot;abc &quot;]
 *     &quot;aa&quot;.unpack('b8B8')                 #=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]
 *     &quot;aaa&quot;.unpack('h2H2c')               #=&gt; [&quot;16&quot;, &quot;61&quot;, 97]
 *     &quot;\xfe\xff\xfe\xff&quot;.unpack('sS')     #=&gt; [-2, 65534]
 *     &quot;now=20is&quot;.unpack('M*')             #=&gt; [&quot;now is&quot;]
 *     &quot;whole&quot;.unpack('xax2aX2aX1aX2a')    #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
 *
 *  This table summarizes the various formats and the Ruby classes
 *  returned by each.
 *
 *   Integer      |         |
 *   Directive    | Returns | Meaning
 *   -----------------------------------------------------------------
 *      C         | Integer | 8-bit unsigned integer (unsigned char)
 *      S         | Integer | 16-bit unsigned integer, native endian (uint16_t)
 *      L         | Integer | 32-bit unsigned integer, native endian (uint32_t)
 *      Q         | Integer | 64-bit unsigned integer, native endian (uint64_t)
 *                |         |
 *      c         | Integer | 8-bit signed integer (signed char)
 *      s         | Integer | 16-bit signed integer, native endian (int16_t)
 *      l         | Integer | 32-bit signed integer, native endian (int32_t)
 *      q         | Integer | 64-bit signed integer, native endian (int64_t)
 *                |         |
 *      S_, S!    | Integer | unsigned short, native endian
 *      I, I_, I! | Integer | unsigned int, native endian
 *      L_, L!    | Integer | unsigned long, native endian
 *                |         |
 *      s_, s!    | Integer | signed short, native endian
 *      i, i_, i! | Integer | signed int, native endian
 *      l_, l!    | Integer | signed long, native endian
 *                |         |
 *      n         | Integer | 16-bit unsigned integer, network (big-endian) byte order
 *      N         | Integer | 32-bit unsigned integer, network (big-endian) byte order
 *      v         | Integer | 16-bit unsigned integer, VAX (little-endian) byte order
 *      V         | Integer | 32-bit unsigned integer, VAX (little-endian) byte order
 *                |         |
 *      U         | Integer | UTF-8 character
 *      w         | Integer | BER-compressed integer (see Array.pack)
 *                
 *   Float        |         |
 *   Directive    | Returns | Meaning
 *   -----------------------------------------------------------------
 *      D, d      | Float   | double-precision float, native format
 *      F, f      | Float   | single-precision float, native format
 *      E         | Float   | double-precision float, little-endian byte order
 *      e         | Float   | single-precision float, little-endian byte order
 *      G         | Float   | double-precision float, network (big-endian) byte order
 *      g         | Float   | single-precision float, network (big-endian) byte order
 *                
 *   String       |         |
 *   Directive    | Returns | Meaning
 *   -----------------------------------------------------------------
 *      A         | String  | arbitrary binary string (remove trailing nulls and ASCII spaces)
 *      a         | String  | arbitrary binary string
 *      Z         | String  | null-terminated string
 *      B         | String  | bit string (MSB first)
 *      b         | String  | bit string (LSB first)
 *      H         | String  | hex string (high nibble first)
 *      h         | String  | hex string (low nibble first)
 *      u         | String  | UU-encoded string
 *      M         | String  | quoted-printable, MIME encoding (see RFC2045)
 *      m         | String  | base64 encoded string (RFC 2045) (default)
 *                |         | base64 encoded string (RFC 4648) if followed by 0
 *      P         | String  | pointer to a structure (fixed-length string)
 *      p         | String  | pointer to a null-terminated string
 *                
 *   Misc.        |         |
 *   Directive    | Returns | Meaning
 *   -----------------------------------------------------------------
 *      @         | ---     | skip to the offset given by the length argument
 *      X         | ---     | skip backward one byte
 *      x         | ---     | skip forward one byte
 */

static VALUE
pack_unpack(VALUE str, VALUE fmt)
{
    static const char hexdigits[] = &quot;0123456789abcdef&quot;;
    char *s, *send;
    char *p, *pend;
    VALUE ary;
    char type;
    long len, tmp_len;
    int star;
#ifdef NATINT_PACK
    int natint;         /* native integer */
#endif
    int block_p = rb_block_given_p();
    int signed_p, integer_size, bigendian_p;
#define UNPACK_PUSH(item) do {\
    VALUE item_val = (item);\
    if (block_p) {\
        rb_yield(item_val);\
    }\
    else {\
        rb_ary_push(ary, item_val);\
    }\
    } while (0)

    StringValue(str);
    StringValue(fmt);
    s = RSTRING_PTR(str);
    send = s + RSTRING_LEN(str);
    p = RSTRING_PTR(fmt);
    pend = p + RSTRING_LEN(fmt);

    ary = block_p ? Qnil : rb_ary_new();
    while (p &lt; pend) {
    type = *p++;
#ifdef NATINT_PACK
    natint = 0;
#endif

    if (ISSPACE(type)) continue;
    if (type == '#') {
        while ((p &lt; pend) &amp;&amp; (*p != '\n')) {
        p++;
        }
        continue;
    }
    star = 0;
    if (*p == '_' || *p == '!') {
        static const char natstr[] = &quot;sSiIlL&quot;;

        if (strchr(natstr, type)) {
#ifdef NATINT_PACK
        natint = 1;
#endif
        p++;
        }
        else {
        rb_raise(rb_eArgError, &quot;'%c' allowed only after types %s&quot;, *p, natstr);
        }
    }
    if (p &gt;= pend)
        len = 1;
    else if (*p == '*') {
        star = 1;
        len = send - s;
        p++;
    }
    else if (ISDIGIT(*p)) {
        errno = 0;
        len = STRTOUL(p, (char**)&amp;p, 10);
        if (errno) {
        rb_raise(rb_eRangeError, &quot;pack length too big&quot;);
        }
    }
    else {
        len = (type != '@');
    }

    switch (type) {
      case '%':
        rb_raise(rb_eArgError, &quot;%% is not supported&quot;);
        break;

      case 'A':
        if (len &gt; send - s) len = send - s;
        {
        long end = len;
        char *t = s + len - 1;

        while (t &gt;= s) {
            if (*t != ' ' &amp;&amp; *t != '\0') break;
            t--; len--;
        }
        UNPACK_PUSH(infected_str_new(s, len, str));
        s += end;
        }
        break;

      case 'Z':
        {
        char *t = s;

        if (len &gt; send-s) len = send-s;
        while (t &lt; s+len &amp;&amp; *t) t++;
        UNPACK_PUSH(infected_str_new(s, t-s, str));
        if (t &lt; send) t++;
        s = star ? t : s+len;
        }
        break;

      case 'a':
        if (len &gt; send - s) len = send - s;
        UNPACK_PUSH(infected_str_new(s, len, str));
        s += len;
        break;

      case 'b':
        {
        VALUE bitstr;
        char *t;
        int bits;
        long i;

        if (p[-1] == '*' || len &gt; (send - s) * 8)
            len = (send - s) * 8;
        bits = 0;
        UNPACK_PUSH(bitstr = rb_str_new(0, len));
        t = RSTRING_PTR(bitstr);
        for (i=0; i&lt;len; i++) {
            if (i &amp; 7) bits &gt;&gt;= 1;
            else bits = *s++;
            *t++ = (bits &amp; 1) ? '1' : '0';
        }
        }
        break;

      case 'B':
        {
        VALUE bitstr;
        char *t;
        int bits;
        long i;

        if (p[-1] == '*' || len &gt; (send - s) * 8)
            len = (send - s) * 8;
        bits = 0;
        UNPACK_PUSH(bitstr = rb_str_new(0, len));
        t = RSTRING_PTR(bitstr);
        for (i=0; i&lt;len; i++) {
            if (i &amp; 7) bits &lt;&lt;= 1;
            else bits = *s++;
            *t++ = (bits &amp; 128) ? '1' : '0';
        }
        }
        break;

      case 'h':
        {
        VALUE bitstr;
        char *t;
        int bits;
        long i;

        if (p[-1] == '*' || len &gt; (send - s) * 2)
            len = (send - s) * 2;
        bits = 0;
        UNPACK_PUSH(bitstr = rb_str_new(0, len));
        t = RSTRING_PTR(bitstr);
        for (i=0; i&lt;len; i++) {
            if (i &amp; 1)
            bits &gt;&gt;= 4;
            else
            bits = *s++;
            *t++ = hexdigits[bits &amp; 15];
        }
        }
        break;

      case 'H':
        {
        VALUE bitstr;
        char *t;
        int bits;
        long i;

        if (p[-1] == '*' || len &gt; (send - s) * 2)
            len = (send - s) * 2;
        bits = 0;
        UNPACK_PUSH(bitstr = rb_str_new(0, len));
        t = RSTRING_PTR(bitstr);
        for (i=0; i&lt;len; i++) {
            if (i &amp; 1)
            bits &lt;&lt;= 4;
            else
            bits = *s++;
            *t++ = hexdigits[(bits &gt;&gt; 4) &amp; 15];
        }
        }
        break;

      case 'c':
        PACK_LENGTH_ADJUST_SIZE(sizeof(char));
        while (len-- &gt; 0) {
                int c = *s++;
                if (c &gt; (char)127) c-=256;
        UNPACK_PUSH(INT2FIX(c));
        }
        PACK_ITEM_ADJUST();
        break;

      case 'C':
        PACK_LENGTH_ADJUST_SIZE(sizeof(unsigned char));
        while (len-- &gt; 0) {
        unsigned char c = *s++;
        UNPACK_PUSH(INT2FIX(c));
        }
        PACK_ITEM_ADJUST();
        break;

      case 's':
        signed_p = 1;
        integer_size = NATINT_LEN(short, 2);
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'S':
        signed_p = 0;
        integer_size = NATINT_LEN(short, 2);
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'i':
        signed_p = 1;
        integer_size = (int)sizeof(int);
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'I':
        signed_p = 0;
        integer_size = (int)sizeof(int);
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'l':
        signed_p = 1;
        integer_size = NATINT_LEN(long, 4);
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'L':
        signed_p = 0;
        integer_size = NATINT_LEN(long, 4);
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'q':
        signed_p = 1;
        integer_size = QUAD_SIZE;
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'Q':
        signed_p = 0;
        integer_size = QUAD_SIZE;
        bigendian_p = BIGENDIAN_P();
        goto unpack_integer;

      case 'n':
        signed_p = 0;
        integer_size = 2;
        bigendian_p = 1;
        goto unpack_integer;

      case 'N':
        signed_p = 0;
        integer_size = 4;
        bigendian_p = 1;
        goto unpack_integer;

      case 'v':
        signed_p = 0;
        integer_size = 2;
        bigendian_p = 0;
        goto unpack_integer;

      case 'V':
        signed_p = 0;
        integer_size = 4;
        bigendian_p = 0;
        goto unpack_integer;

      unpack_integer:
        switch (integer_size) {
#if defined(HAVE_INT16_T) &amp;&amp; !defined(FORCE_BIG_PACK)
          case SIZEOF_INT16_T:
        if (signed_p) {
            PACK_LENGTH_ADJUST_SIZE(sizeof(int16_t));
            while (len-- &gt; 0) {
            union {
                            int16_t i;
                            char a[sizeof(int16_t)];
                        } v;
            memcpy(v.a, s, sizeof(int16_t));
            if (bigendian_p != BIGENDIAN_P()) v.i = swap16(v.i);
            s += sizeof(int16_t);
            UNPACK_PUSH(INT2FIX(v.i));
            }
            PACK_ITEM_ADJUST();
        }
        else {
            PACK_LENGTH_ADJUST_SIZE(sizeof(uint16_t));
            while (len-- &gt; 0) {
            union {
                            uint16_t i;
                            char a[sizeof(uint16_t)];
                        } v;
            memcpy(v.a, s, sizeof(uint16_t));
            if (bigendian_p != BIGENDIAN_P()) v.i = swap16(v.i);
            s += sizeof(uint16_t);
            UNPACK_PUSH(INT2FIX(v.i));
            }
            PACK_ITEM_ADJUST();
        }
        break;
#endif

#if defined(HAVE_INT32_T) &amp;&amp; !defined(FORCE_BIG_PACK)
          case SIZEOF_INT32_T:
        if (signed_p) {
            PACK_LENGTH_ADJUST_SIZE(sizeof(int32_t));
            while (len-- &gt; 0) {
            union {
                            int32_t i;
                            char a[sizeof(int32_t)];
                        } v;
            memcpy(v.a, s, sizeof(int32_t));
            if (bigendian_p != BIGENDIAN_P()) v.i = swap32(v.i);
            s += sizeof(int32_t);
            UNPACK_PUSH(INT2NUM(v.i));
            }
            PACK_ITEM_ADJUST();
        }
        else {
            PACK_LENGTH_ADJUST_SIZE(sizeof(uint32_t));
            while (len-- &gt; 0) {
            union {
                            uint32_t i;
                            char a[sizeof(uint32_t)];
                        } v;
            memcpy(v.a, s, sizeof(uint32_t));
            if (bigendian_p != BIGENDIAN_P()) v.i = swap32(v.i);
            s += sizeof(uint32_t);
            UNPACK_PUSH(UINT2NUM(v.i));
            }
            PACK_ITEM_ADJUST();
        }
        break;
#endif

#if defined(HAVE_INT64_T) &amp;&amp; !defined(FORCE_BIG_PACK)
          case SIZEOF_INT64_T:
        if (signed_p) {
            PACK_LENGTH_ADJUST_SIZE(sizeof(int64_t));
            while (len-- &gt; 0) {
            union {
                            int64_t i;
                            char a[sizeof(int64_t)];
                        } v;
            memcpy(v.a, s, sizeof(int64_t));
            if (bigendian_p != BIGENDIAN_P()) v.i = swap64(v.i);
            s += sizeof(int64_t);
            UNPACK_PUSH(INT64toNUM(v.i));
            }
            PACK_ITEM_ADJUST();
        }
        else {
            PACK_LENGTH_ADJUST_SIZE(sizeof(uint64_t));
            while (len-- &gt; 0) {
            union {
                            uint64_t i;
                            char a[sizeof(uint64_t)];
                        } v;
            memcpy(v.a, s, sizeof(uint64_t));
            if (bigendian_p != BIGENDIAN_P()) v.i = swap64(v.i);
            s += sizeof(uint64_t);
            UNPACK_PUSH(UINT64toNUM(v.i));
            }
            PACK_ITEM_ADJUST();
        }
        break;
#endif

              default:
                if (integer_size &gt; MAX_INTEGER_PACK_SIZE)
                    rb_bug(&quot;unexpected intger size for pack: %d&quot;, integer_size);
                PACK_LENGTH_ADJUST_SIZE(integer_size);
                while (len-- &gt; 0) {
                    union {
                        unsigned long i[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG)/SIZEOF_LONG];
                        char a[(MAX_INTEGER_PACK_SIZE+SIZEOF_LONG)/SIZEOF_LONG*SIZEOF_LONG];
                    } v;
                    int num_longs = (integer_size+SIZEOF_LONG)/SIZEOF_LONG;
                    int i;

                    if (signed_p &amp;&amp; (signed char)s[bigendian_p ? 0 : (integer_size-1)] &lt; 0)
                        memset(v.a, 0xff, sizeof(long)*num_longs);
                    else
                        memset(v.a, 0, sizeof(long)*num_longs);
                    if (bigendian_p)
                        memcpy(v.a + sizeof(long)*num_longs - integer_size, s, integer_size);
                    else
                        memcpy(v.a, s, integer_size);
                    if (bigendian_p) {
                        for (i = 0; i &lt; num_longs/2; i++) {
                            unsigned long t = v.i[i];
                            v.i[i] = v.i[num_longs-1-i];
                            v.i[num_longs-1-i] = t;
                        }
                    }
                    if (bigendian_p != BIGENDIAN_P()) {
                        for (i = 0; i &lt; num_longs; i++)
                            v.i[i] = swapl(v.i[i]);
                    }
                    s += integer_size;
                    UNPACK_PUSH(rb_big_unpack(v.i, num_longs));
                }
                PACK_ITEM_ADJUST();
        break;
        }
            break;

      case 'f':
      case 'F':
        PACK_LENGTH_ADJUST_SIZE(sizeof(float));
        while (len-- &gt; 0) {
        float tmp;
        memcpy(&amp;tmp, s, sizeof(float));
        s += sizeof(float);
        UNPACK_PUSH(DBL2NUM((double)tmp));
        }
        PACK_ITEM_ADJUST();
        break;

      case 'e':
        PACK_LENGTH_ADJUST_SIZE(sizeof(float));
        while (len-- &gt; 0) {
            float tmp;
        FLOAT_CONVWITH(ftmp);

        memcpy(&amp;tmp, s, sizeof(float));
        s += sizeof(float);
        tmp = VTOHF(tmp,ftmp);
        UNPACK_PUSH(DBL2NUM((double)tmp));
        }
        PACK_ITEM_ADJUST();
        break;

      case 'E':
        PACK_LENGTH_ADJUST_SIZE(sizeof(double));
        while (len-- &gt; 0) {
        double tmp;
        DOUBLE_CONVWITH(dtmp);

        memcpy(&amp;tmp, s, sizeof(double));
        s += sizeof(double);
        tmp = VTOHD(tmp,dtmp);
        UNPACK_PUSH(DBL2NUM(tmp));
        }
        PACK_ITEM_ADJUST();
        break;

      case 'D':
      case 'd':
        PACK_LENGTH_ADJUST_SIZE(sizeof(double));
        while (len-- &gt; 0) {
        double tmp;
        memcpy(&amp;tmp, s, sizeof(double));
        s += sizeof(double);
        UNPACK_PUSH(DBL2NUM(tmp));
        }
        PACK_ITEM_ADJUST();
        break;

      case 'g':
        PACK_LENGTH_ADJUST_SIZE(sizeof(float));
        while (len-- &gt; 0) {
            float tmp;
        FLOAT_CONVWITH(ftmp;)

        memcpy(&amp;tmp, s, sizeof(float));
        s += sizeof(float);
        tmp = NTOHF(tmp,ftmp);
        UNPACK_PUSH(DBL2NUM((double)tmp));
        }
        PACK_ITEM_ADJUST();
        break;

      case 'G':
        PACK_LENGTH_ADJUST_SIZE(sizeof(double));
        while (len-- &gt; 0) {
        double tmp;
        DOUBLE_CONVWITH(dtmp);

        memcpy(&amp;tmp, s, sizeof(double));
        s += sizeof(double);
        tmp = NTOHD(tmp,dtmp);
        UNPACK_PUSH(DBL2NUM(tmp));
        }
        PACK_ITEM_ADJUST();
        break;

      case 'U':
        if (len &gt; send - s) len = send - s;
        while (len &gt; 0 &amp;&amp; s &lt; send) {
        long alen = send - s;
        unsigned long l;

        l = utf8_to_uv(s, &amp;alen);
        s += alen; len--;
        UNPACK_PUSH(ULONG2NUM(l));
        }
        break;

      case 'u':
        {
        VALUE buf = infected_str_new(0, (send - s)*3/4, str);
        char *ptr = RSTRING_PTR(buf);
        long total = 0;

        while (s &lt; send &amp;&amp; *s &gt; ' ' &amp;&amp; *s &lt; 'a') {
            long a,b,c,d;
            char hunk[4];

            hunk[3] = '\0';
            len = (*s++ - ' ') &amp; 077;
            total += len;
            if (total &gt; RSTRING_LEN(buf)) {
            len -= total - RSTRING_LEN(buf);
            total = RSTRING_LEN(buf);
            }

            while (len &gt; 0) {
            long mlen = len &gt; 3 ? 3 : len;

            if (s &lt; send &amp;&amp; *s &gt;= ' ')
                a = (*s++ - ' ') &amp; 077;
            else
                a = 0;
            if (s &lt; send &amp;&amp; *s &gt;= ' ')
                b = (*s++ - ' ') &amp; 077;
            else
                b = 0;
            if (s &lt; send &amp;&amp; *s &gt;= ' ')
                c = (*s++ - ' ') &amp; 077;
            else
                c = 0;
            if (s &lt; send &amp;&amp; *s &gt;= ' ')
                d = (*s++ - ' ') &amp; 077;
            else
                d = 0;
            hunk[0] = (char)(a &lt;&lt; 2 | b &gt;&gt; 4);
            hunk[1] = (char)(b &lt;&lt; 4 | c &gt;&gt; 2);
            hunk[2] = (char)(c &lt;&lt; 6 | d);
            memcpy(ptr, hunk, mlen);
            ptr += mlen;
            len -= mlen;
            }
            if (*s == '\r') s++;
            if (*s == '\n') s++;
            else if (s &lt; send &amp;&amp; (s+1 == send || s[1] == '\n'))
            s += 2;  /* possible checksum byte */
        }

        rb_str_set_len(buf, total);
        UNPACK_PUSH(buf);
        }
        break;

      case 'm':
        {
        VALUE buf = infected_str_new(0, (send - s)*3/4, str);
        char *ptr = RSTRING_PTR(buf);
        int a = -1,b = -1,c = 0,d = 0;
        static signed char b64_xtable[256];

        if (b64_xtable['/'] &lt;= 0) {
            int i;

            for (i = 0; i &lt; 256; i++) {
            b64_xtable[i] = -1;
            }
            for (i = 0; i &lt; 64; i++) {
            b64_xtable[(unsigned char)b64_table[i]] = i;
            }
        }
        if (len == 0) {
            while (s &lt; send) {
            a = b = c = d = -1;
            a = b64_xtable[(unsigned char)*s++];
            if (s &gt;= send || a == -1) rb_raise(rb_eArgError, &quot;invalid base64&quot;);
            b = b64_xtable[(unsigned char)*s++];
            if (s &gt;= send || b == -1) rb_raise(rb_eArgError, &quot;invalid base64&quot;);
            if (*s == '=') {
                if (s + 2 == send &amp;&amp; *(s + 1) == '=') break;
                rb_raise(rb_eArgError, &quot;invalid base64&quot;);
            }
            c = b64_xtable[(unsigned char)*s++];
            if (s &gt;= send || c == -1) rb_raise(rb_eArgError, &quot;invalid base64&quot;);
            if (s + 1 == send &amp;&amp; *s == '=') break;
            d = b64_xtable[(unsigned char)*s++];
            if (d == -1) rb_raise(rb_eArgError, &quot;invalid base64&quot;);
            *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
            *ptr++ = b &lt;&lt; 4 | c &gt;&gt; 2;
            *ptr++ = c &lt;&lt; 6 | d;
            }
            if (c == -1) {
            *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
            if (b &amp; 0xf) rb_raise(rb_eArgError, &quot;invalid base64&quot;);
            }
            else if (d == -1) {
            *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
            *ptr++ = b &lt;&lt; 4 | c &gt;&gt; 2;
            if (c &amp; 0x3) rb_raise(rb_eArgError, &quot;invalid base64&quot;);
            }
        }
        else {
            while (s &lt; send) {
            a = b = c = d = -1;
            while ((a = b64_xtable[(unsigned char)*s]) == -1 &amp;&amp; s &lt; send) {s++;}
            if (s &gt;= send) break;
            s++;
            while ((b = b64_xtable[(unsigned char)*s]) == -1 &amp;&amp; s &lt; send) {s++;}
            if (s &gt;= send) break;
            s++;
            while ((c = b64_xtable[(unsigned char)*s]) == -1 &amp;&amp; s &lt; send) {if (*s == '=') break; s++;}
            if (*s == '=' || s &gt;= send) break;
            s++;
            while ((d = b64_xtable[(unsigned char)*s]) == -1 &amp;&amp; s &lt; send) {if (*s == '=') break; s++;}
            if (*s == '=' || s &gt;= send) break;
            s++;
            *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
            *ptr++ = b &lt;&lt; 4 | c &gt;&gt; 2;
            *ptr++ = c &lt;&lt; 6 | d;
            }
            if (a != -1 &amp;&amp; b != -1) {
            if (c == -1 &amp;&amp; *s == '=')
                *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
            else if (c != -1 &amp;&amp; *s == '=') {
                *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
                *ptr++ = b &lt;&lt; 4 | c &gt;&gt; 2;
            }
            }
        }
        rb_str_set_len(buf, ptr - RSTRING_PTR(buf));
        UNPACK_PUSH(buf);
        }
        break;

      case 'M':
        {
        VALUE buf = infected_str_new(0, send - s, str);
        char *ptr = RSTRING_PTR(buf);
        int c1, c2;

        while (s &lt; send) {
            if (*s == '=') {
            if (++s == send) break;
                       if (s+1 &lt; send &amp;&amp; *s == '\r' &amp;&amp; *(s+1) == '\n')
                         s++;
            if (*s != '\n') {
                if ((c1 = hex2num(*s)) == -1) break;
                if (++s == send) break;
                if ((c2 = hex2num(*s)) == -1) break;
                *ptr++ = c1 &lt;&lt; 4 | c2;
            }
            }
            else {
            *ptr++ = *s;
            }
            s++;
        }
        rb_str_set_len(buf, ptr - RSTRING_PTR(buf));
        ENCODING_CODERANGE_SET(buf, rb_usascii_encindex(), ENC_CODERANGE_7BIT);
        UNPACK_PUSH(buf);
        }
        break;

      case '@':
        if (len &gt; RSTRING_LEN(str))
        rb_raise(rb_eArgError, &quot;@ outside of string&quot;);
        s = RSTRING_PTR(str) + len;
        break;

      case 'X':
        if (len &gt; s - RSTRING_PTR(str))
        rb_raise(rb_eArgError, &quot;X outside of string&quot;);
        s -= len;
        break;

      case 'x':
        if (len &gt; send - s)
        rb_raise(rb_eArgError, &quot;x outside of string&quot;);
        s += len;
        break;

      case 'P':
        if (sizeof(char *) &lt;= (size_t)(send - s)) {
        VALUE tmp = Qnil;
        char *t;

        memcpy(&amp;t, s, sizeof(char *));
        s += sizeof(char *);

        if (t) {
            VALUE a, *p, *pend;

            if (!(a = rb_str_associated(str))) {
            rb_raise(rb_eArgError, &quot;no associated pointer&quot;);
            }
            p = RARRAY_PTR(a);
            pend = p + RARRAY_LEN(a);
            while (p &lt; pend) {
            if (TYPE(*p) == T_STRING &amp;&amp; RSTRING_PTR(*p) == t) {
                if (len &lt; RSTRING_LEN(*p)) {
                tmp = rb_tainted_str_new(t, len);
                rb_str_associate(tmp, a);
                }
                else {
                tmp = *p;
                }
                break;
            }
            p++;
            }
            if (p == pend) {
            rb_raise(rb_eArgError, &quot;non associated pointer&quot;);
            }
        }
        UNPACK_PUSH(tmp);
        }
        break;

      case 'p':
        if (len &gt; (long)((send - s) / sizeof(char *)))
        len = (send - s) / sizeof(char *);
        while (len-- &gt; 0) {
        if ((size_t)(send - s) &lt; sizeof(char *))
            break;
        else {
            VALUE tmp = Qnil;
            char *t;

            memcpy(&amp;t, s, sizeof(char *));
            s += sizeof(char *);

            if (t) {
            VALUE a, *p, *pend;

            if (!(a = rb_str_associated(str))) {
                rb_raise(rb_eArgError, &quot;no associated pointer&quot;);
            }
            p = RARRAY_PTR(a);
            pend = p + RARRAY_LEN(a);
            while (p &lt; pend) {
                if (TYPE(*p) == T_STRING &amp;&amp; RSTRING_PTR(*p) == t) {
                tmp = *p;
                break;
                }
                p++;
            }
            if (p == pend) {
                rb_raise(rb_eArgError, &quot;non associated pointer&quot;);
            }
            }
            UNPACK_PUSH(tmp);
        }
        }
        break;

      case 'w':
        {
        unsigned long ul = 0;
        unsigned long ulmask = 0xfeUL &lt;&lt; ((sizeof(unsigned long) - 1) * 8);

        while (len &gt; 0 &amp;&amp; s &lt; send) {
            ul &lt;&lt;= 7;
            ul |= (*s &amp; 0x7f);
            if (!(*s++ &amp; 0x80)) {
            UNPACK_PUSH(ULONG2NUM(ul));
            len--;
            ul = 0;
            }
            else if (ul &amp; ulmask) {
            VALUE big = rb_uint2big(ul);
            VALUE big128 = rb_uint2big(128);
            while (s &lt; send) {
                big = rb_big_mul(big, big128);
                big = rb_big_plus(big, rb_uint2big(*s &amp; 0x7f));
                if (!(*s++ &amp; 0x80)) {
                UNPACK_PUSH(big);
                len--;
                ul = 0;
                break;
                }
            }
            }
        }
        }
        break;

      default:
        break;
    }
    }

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="upcase-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>upcase</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a copy of <em>str</em> with all lowercase letters replaced with
their uppercase counterparts. The operation is locale
insensitive--only characters ``a&#8217;&#8217; to ``z&#8217;&#8217;
are affected. Note: case replacement is effective only in ASCII region.
</p>
<pre class="code">
   &quot;hEllO&quot;.upcase   #=&gt; &quot;HELLO&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.upcase   -&gt; new_str
 *
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with all lowercase letters replaced with their
 *  uppercase counterparts. The operation is locale insensitive---only
 *  characters ``a'' to ``z'' are affected.
 *  Note: case replacement is effective only in ASCII region.
 *
 *     &quot;hEllO&quot;.upcase   #=&gt; &quot;HELLO&quot;
 */

static VALUE
rb_str_upcase(VALUE str)
{
    str = rb_str_dup(str);
    rb_str_upcase_bang(str);
    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="upcase!-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>upcase!</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Upcases the contents of <em>str</em>, returning <tt>nil</tt> if no changes
were made. Note: case replacement is effective only in ASCII region.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.upcase!   -&gt; str or nil
 *
 *  Upcases the contents of &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if no changes
 *  were made.
 *  Note: case replacement is effective only in ASCII region.
 */

static VALUE
rb_str_upcase_bang(VALUE str)
{
    rb_encoding *enc;
    char *s, *send;
    int modify = 0;
    int n;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    rb_str_check_dummy_enc(enc);
    s = RSTRING_PTR(str); send = RSTRING_END(str);
    if (single_byte_optimizable(str)) {
    while (s &lt; send) {
        unsigned int c = *(unsigned char*)s;

        if (rb_enc_isascii(c, enc) &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z') {
        *s = 'A' + (c - 'a');
        modify = 1;
        }
        s++;
    }
    }
    else {
    int ascompat = rb_enc_asciicompat(enc);

    while (s &lt; send) {
        unsigned int c;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
        if (rb_enc_isascii(c, enc) &amp;&amp; 'a' &lt;= c &amp;&amp; c &lt;= 'z') {
            *s = 'A' + (c - 'a');
            modify = 1;
        }
        s++;
        }
        else {
        c = rb_enc_codepoint_len(s, send, &amp;n, enc);
        if (rb_enc_islower(c, enc)) {
            /* assuming toupper returns codepoint with same size */
            rb_enc_mbcput(rb_enc_toupper(c, enc), s, enc);
            modify = 1;
        }
        s += n;
        }
    }
    }

    if (modify) return str;
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="upto-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>upto</strong>(other_str, exclusive = false) {|s| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>upto</strong>(other_str, exclusive = false) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Iterates through successive values, starting at <em>str</em> and ending at
<em>other_str</em> inclusive, passing each value in turn to the block. The
<tt>String#succ</tt> method is used to generate each value.  If optional
second argument exclusive is omitted or is false, the last value will be
included; otherwise it will be excluded.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   &quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, ' ' }
   for s in &quot;a8&quot;..&quot;b6&quot;
     print s, ' '
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   a8 a9 b0 b1 b2 b3 b4 b5 b6
   a8 a9 b0 b1 b2 b3 b4 b5 b6
</pre>
<p>
If <em>str</em> and <em>other_str</em> contains only ascii numeric
characters, both are recognized as decimal numbers. In addition, the width
of string (e.g. leading zeros) is handled appropriately.
</p>
<pre class="code">
   &quot;9&quot;.upto(&quot;11&quot;).to_a   #=&gt; [&quot;9&quot;, &quot;10&quot;, &quot;11&quot;]
   &quot;25&quot;.upto(&quot;5&quot;).to_a   #=&gt; []
   &quot;07&quot;.upto(&quot;11&quot;).to_a  #=&gt; [&quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>) <strong>upto</strong>(other_str, exclusive = false) {|s| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>s</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.upto(other_str, exclusive=false) {|s| block }   -&gt; str
 *     str.upto(other_str, exclusive=false)                -&gt; an_enumerator
 *
 *  Iterates through successive values, starting at &lt;i&gt;str&lt;/i&gt; and
 *  ending at &lt;i&gt;other_str&lt;/i&gt; inclusive, passing each value in turn to
 *  the block. The &lt;code&gt;String#succ&lt;/code&gt; method is used to generate
 *  each value.  If optional second argument exclusive is omitted or is false,
 *  the last value will be included; otherwise it will be excluded.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     &quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, ' ' }
 *     for s in &quot;a8&quot;..&quot;b6&quot;
 *       print s, ' '
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     a8 a9 b0 b1 b2 b3 b4 b5 b6
 *     a8 a9 b0 b1 b2 b3 b4 b5 b6
 *
 *  If &lt;i&gt;str&lt;/i&gt; and &lt;i&gt;other_str&lt;/i&gt; contains only ascii numeric characters,
 *  both are recognized as decimal numbers. In addition, the width of
 *  string (e.g. leading zeros) is handled appropriately.
 *
 *     &quot;9&quot;.upto(&quot;11&quot;).to_a   #=&gt; [&quot;9&quot;, &quot;10&quot;, &quot;11&quot;]
 *     &quot;25&quot;.upto(&quot;5&quot;).to_a   #=&gt; []
 *     &quot;07&quot;.upto(&quot;11&quot;).to_a  #=&gt; [&quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;]
 */

static VALUE
rb_str_upto(int argc, VALUE *argv, VALUE beg)
{
    VALUE end, exclusive;
    VALUE current, after_end;
    ID succ;
    int n, excl, ascii;
    rb_encoding *enc;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;end, &amp;exclusive);
    RETURN_ENUMERATOR(beg, argc, argv);
    excl = RTEST(exclusive);
    CONST_ID(succ, &quot;succ&quot;);
    StringValue(end);
    enc = rb_enc_check(beg, end);
    ascii = (is_ascii_string(beg) &amp;&amp; is_ascii_string(end));
    /* single character */
    if (RSTRING_LEN(beg) == 1 &amp;&amp; RSTRING_LEN(end) == 1 &amp;&amp; ascii) {
    char c = RSTRING_PTR(beg)[0];
    char e = RSTRING_PTR(end)[0];

    if (c &gt; e || (excl &amp;&amp; c == e)) return beg;
    for (;;) {
        rb_yield(rb_enc_str_new(&amp;c, 1, enc));
        if (!excl &amp;&amp; c == e) break;
        c++;
        if (excl &amp;&amp; c == e) break;
    }
    return beg;
    }
    /* both edges are all digits */
    if (ascii &amp;&amp; ISDIGIT(RSTRING_PTR(beg)[0]) &amp;&amp; ISDIGIT(RSTRING_PTR(end)[0])) {
    char *s, *send;
    VALUE b, e;
    int width;

    s = RSTRING_PTR(beg); send = RSTRING_END(beg);
    width = rb_long2int(send - s);
    while (s &lt; send) {
        if (!ISDIGIT(*s)) goto no_digits;
        s++;
    }
    s = RSTRING_PTR(end); send = RSTRING_END(end);
    while (s &lt; send) {
        if (!ISDIGIT(*s)) goto no_digits;
        s++;
    }
    b = rb_str_to_inum(beg, 10, FALSE);
    e = rb_str_to_inum(end, 10, FALSE);
    if (FIXNUM_P(b) &amp;&amp; FIXNUM_P(e)) {
        long bi = FIX2LONG(b);
        long ei = FIX2LONG(e);
        rb_encoding *usascii = rb_usascii_encoding();

        while (bi &lt;= ei) {
        if (excl &amp;&amp; bi == ei) break;
        rb_yield(rb_enc_sprintf(usascii, &quot;%.*ld&quot;, width, bi));
        bi++;
        }
    }
    else {
        ID op = excl ? '&lt;' : rb_intern(&quot;&lt;=&quot;);
        VALUE args[2], fmt = rb_obj_freeze(rb_usascii_str_new_cstr(&quot;%.*d&quot;));

        args[0] = INT2FIX(width);
        while (rb_funcall(b, op, 1, e)) {
        args[1] = b;
        rb_yield(rb_str_format(numberof(args), args, fmt));
        b = rb_funcall(b, succ, 0, 0);
        }
    }
    return beg;
    }
    /* normal case */
  no_digits:
    n = rb_str_cmp(beg, end);
    if (n &gt; 0 || (excl &amp;&amp; n == 0)) return beg;

    after_end = rb_funcall(end, succ, 0, 0);
    current = rb_str_dup(beg);
    while (!rb_str_equal(current, after_end)) {
    VALUE next = Qnil;
    if (excl || !rb_str_equal(current, end))
        next = rb_funcall(current, succ, 0, 0);
    rb_yield(current);
    if (NIL_P(next)) break;
    current = next;
    StringValue(current);
    if (excl &amp;&amp; rb_str_equal(current, end)) break;
    if (RSTRING_LEN(current) &gt; RSTRING_LEN(end) || RSTRING_LEN(current) == 0)
        break;
    }

    return beg;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="valid_encoding?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>valid_encoding?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true for a string which encoded correctly.
</p>
<pre class="code">
  &quot;\xc2\xa1&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?  #=&gt; true
  &quot;\xc2&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      #=&gt; false
  &quot;\x80&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'string.c'</span>

/*
 *  call-seq:
 *     str.valid_encoding?  -&gt; true or false
 *
 *  Returns true for a string which encoded correctly.
 *
 *    &quot;\xc2\xa1&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?  #=&gt; true
 *    &quot;\xc2&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      #=&gt; false
 *    &quot;\x80&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      #=&gt; false
 */

static VALUE
rb_str_valid_encoding_p(VALUE str)
{
    int cr = rb_enc_str_coderange(str);

    return cr == ENC_CODERANGE_BROKEN ? Qfalse : Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:06:05 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>