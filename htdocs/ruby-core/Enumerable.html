<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Module: Enumerable</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (E)</a> &raquo; 
    
    
    <span class="title">Enumerable</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Module: Enumerable
  
  
  
</h1>

<dl class="box">
  
  
    
  
    
  
  
    <dt class="r1">Included in:</dt>
    <dd class="r1"><span class='object_link'><a href="ARGF.html" title="ARGF (class)">ARGF</a></span>, <span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span>, <span class='object_link'><a href="Dir.html" title="Dir (class)">Dir</a></span>, <span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span>, <span class='object_link'><a href="Enumerator/Generator.html" title="Enumerator::Generator (class)">Enumerator::Generator</a></span>, <span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span>, <span class='object_link'><a href="IO.html" title="IO (class)">IO</a></span>, <span class='object_link'><a href="Struct.html" title="Struct (class)">Struct</a></span></dd>
    
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">enum.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
The <tt>Enumerable</tt> mixin provides collection classes with several
traversal and searching methods, and with the ability to sort. The class
must provide a method <tt>each</tt>, which yields successive members of the
collection. If <tt>Enumerable#max</tt>, <tt>#min</tt>, or <tt>#sort</tt> is
used, the objects in the collection must also implement a meaningful
<tt>&lt;=&gt;</tt> operator, as these methods rely on an ordering between
members of the collection.
</p>


  </div>
</div>
<div class="tags">
  
</div>


  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#all%3F-instance_method" title="#all? (instance method)">- (Boolean) <strong>all?</strong> {|obj| ... }</a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes each element of the collection to the given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#any%3F-instance_method" title="#any? (instance method)">- (Boolean) <strong>any?</strong> {|obj| ... }</a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes each element of the collection to the given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chunk-instance_method" title="#chunk (instance method)">- (Object) <strong>chunk</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates an enumerator for each chunked elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#collect-instance_method" title="#collect (instance method)">- (Object) <strong>collect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#collect_concat-instance_method" title="#collect_concat (instance method)">- (Object) <strong>collect_concat</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#count-instance_method" title="#count (instance method)">- (Object) <strong>count</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the number of items in <em>enum</em>, where #size is called if it
responds to it, otherwise the items are counted through enumeration.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cycle-instance_method" title="#cycle (instance method)">- (Object) <strong>cycle</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Calls <em>block</em> for each element of <em>enum</em> repeatedly
<em>n</em> times or forever if none or <tt>nil</tt> is given.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#detect-instance_method" title="#detect (instance method)">- (Object) <strong>detect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes each entry in <em>enum</em> to <em>block</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#drop-instance_method" title="#drop (instance method)">- (Array) <strong>drop</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Drops first n elements from <em>enum</em>, and returns rest elements in an
array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#drop_while-instance_method" title="#drop_while (instance method)">- (Object) <strong>drop_while</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Drops elements up to, but not including, the first element for which the
block returns <tt>nil</tt> or <tt>false</tt> and returns an array
containing the remaining elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_cons-instance_method" title="#each_cons (instance method)">- (Object) <strong>each_cons</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Iterates the given block for each array of consecutive <n> elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_entry-instance_method" title="#each_entry (instance method)">- (Object) <strong>each_entry</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Calls <em>block</em> once for each element in <tt>self</tt>, passing that
element as a parameter, converting multiple values from yield to an array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_slice-instance_method" title="#each_slice (instance method)">- (Object) <strong>each_slice</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Iterates the given block for each slice of <n> elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_with_index-instance_method" title="#each_with_index (instance method)">- (Object) <strong>each_with_index</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Calls <em>block</em> with two arguments, the item and its index, for each
item in <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_with_object-instance_method" title="#each_with_object (instance method)">- (Object) <strong>each_with_object</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Iterates the given block for each element with an arbitrary object given,
and returns the initially given object.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#entries-instance_method" title="#entries (instance method)">- (Object) <strong>entries</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array containing the items in <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#find-instance_method" title="#find (instance method)">- (Object) <strong>find</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes each entry in <em>enum</em> to <em>block</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#find_all-instance_method" title="#find_all (instance method)">- (Object) <strong>find_all</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <tt>false</tt> (see also <tt>Enumerable#reject</tt>).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#find_index-instance_method" title="#find_index (instance method)">- (Object) <strong>find_index</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Compares each entry in <em>enum</em> with <em>value</em> or passes to
<em>block</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#first-instance_method" title="#first (instance method)">- (Object) <strong>first</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the first element, or the first <tt>n</tt> elements, of the
enumerable.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flat_map-instance_method" title="#flat_map (instance method)">- (Object) <strong>flat_map</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#grep-instance_method" title="#grep (instance method)">- (Object) <strong>grep</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array of every element in <em>enum</em> for which <tt>Pattern
=== element</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#group_by-instance_method" title="#group_by (instance method)">- (Object) <strong>group_by</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a hash, which keys are evaluated result from the block, and values
are arrays of elements in <em>enum</em> corresponding to the key.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#include%3F-instance_method" title="#include? (instance method)">- (Object) <strong>include?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if any member of <em>enum</em> equals <em>obj</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inject-instance_method" title="#inject (instance method)">- (Object) <strong>inject</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
enum.reduce(initial, sym) -> obj.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#map-instance_method" title="#map (instance method)">- (Object) <strong>map</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max-instance_method" title="#max (instance method)">- (Object) <strong>max</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the object in <em>enum</em> with the maximum value.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#max_by-instance_method" title="#max_by (instance method)">- (Object) <strong>max_by</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the object in <em>enum</em> that gives the maximum value from the
given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#member%3F-instance_method" title="#member? (instance method)">- (Object) <strong>member?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if any member of <em>enum</em> equals <em>obj</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min-instance_method" title="#min (instance method)">- (Object) <strong>min</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the object in <em>enum</em> with the minimum value.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#min_by-instance_method" title="#min_by (instance method)">- (Object) <strong>min_by</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the object in <em>enum</em> that gives the minimum value from the
given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax-instance_method" title="#minmax (instance method)">- (Object) <strong>minmax</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns two elements array which contains the minimum and the maximum value
in the enumerable.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#minmax_by-instance_method" title="#minmax_by (instance method)">- (Object) <strong>minmax_by</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns two elements array array containing the objects in <em>enum</em>
that gives the minimum and maximum values respectively from the given
block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#none%3F-instance_method" title="#none? (instance method)">- (Boolean) <strong>none?</strong> {|obj| ... }</a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes each element of the collection to the given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#one%3F-instance_method" title="#one? (instance method)">- (Boolean) <strong>one?</strong> {|obj| ... }</a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes each element of the collection to the given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#partition-instance_method" title="#partition (instance method)">- (Object) <strong>partition</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns two arrays, the first containing the elements of <em>enum</em> for
which the block evaluates to true, the second containing the rest.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reduce-instance_method" title="#reduce (instance method)">- (Object) <strong>reduce</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
enum.reduce(initial, sym) -> obj.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reject-instance_method" title="#reject (instance method)">- (Object) <strong>reject</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array for all elements of <em>enum</em> for which <em>block</em>
is false (see also <tt>Enumerable#find_all</tt>).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reverse_each-instance_method" title="#reverse_each (instance method)">- (Object) <strong>reverse_each</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Builds a temporary array and traverses that array in reverse order.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select-instance_method" title="#select (instance method)">- (Object) <strong>select</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <tt>false</tt> (see also <tt>Enumerable#reject</tt>).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#slice_before-instance_method" title="#slice_before (instance method)">- (Object) <strong>slice_before</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Creates an enumerator for each chunked elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sort-instance_method" title="#sort (instance method)">- (Object) <strong>sort</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array containing the items in <em>enum</em> sorted, either
according to their own <tt>&lt;=&gt;</tt> method, or by using the results
of the supplied block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sort_by-instance_method" title="#sort_by (instance method)">- (Object) <strong>sort_by</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sorts <em>enum</em> using a set of keys generated by mapping the values in
<em>enum</em> through the given block.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#take-instance_method" title="#take (instance method)">- (Array) <strong>take</strong>(n) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns first n elements from <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#take_while-instance_method" title="#take_while (instance method)">- (Object) <strong>take_while</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes elements to the block until the block returns <tt>nil</tt> or
<tt>false</tt>, then stops iterating and returns an array of all prior
elements.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_a-instance_method" title="#to_a (instance method)">- (Object) <strong>to_a</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an array containing the items in <em>enum</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#zip-instance_method" title="#zip (instance method)">- (Object) <strong>zip</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Takes one element from <em>enum</em> and merges corresponding elements from
each <em>args</em>.
</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="all?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>all?</strong> {|obj| ... }
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block never returns <tt>false</tt> or
<tt>nil</tt>. If the block is not given, Ruby adds an implicit block of
<tt>{|obj| obj}</tt> (that is <tt>all?</tt> will return <tt>true</tt> only
if none of the collection members are <tt>false</tt> or <tt>nil</tt>.)
</p>
<pre class="code">
   %w{ant bear cat}.all? {|word| word.length &gt;= 3}   #=&gt; true
   %w{ant bear cat}.all? {|word| word.length &gt;= 4}   #=&gt; false
   [ nil, true, 99 ].all?                            #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.all? [{|obj| block } ]   -&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block never returns
 *  &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. If the block is not given,
 *  Ruby adds an implicit block of &lt;code&gt;{|obj| obj}&lt;/code&gt; (that is
 *  &lt;code&gt;all?&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; only if none of the
 *  collection members are &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.)
 *
 *     %w{ant bear cat}.all? {|word| word.length &gt;= 3}   #=&gt; true
 *     %w{ant bear cat}.all? {|word| word.length &gt;= 4}   #=&gt; false
 *     [ nil, true, 99 ].all?                            #=&gt; false
 *
 */

static VALUE
enum_all(VALUE obj)
{
    VALUE result = Qtrue;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(all), (VALUE)&amp;result);
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="any?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>any?</strong> {|obj| ... }
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block ever returns a value other than
<tt>false</tt> or <tt>nil</tt>. If the block is not given, Ruby adds an
implicit block of <tt>{|obj| obj}</tt> (that is <tt>any?</tt> will return
<tt>true</tt> if at least one of the collection members is not
<tt>false</tt> or <tt>nil</tt>.
</p>
<pre class="code">
   %w{ant bear cat}.any? {|word| word.length &gt;= 3}   #=&gt; true
   %w{ant bear cat}.any? {|word| word.length &gt;= 4}   #=&gt; true
   [ nil, true, 99 ].any?                            #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.any? [{|obj| block } ]   -&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block ever returns a value other
 *  than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. If the block is not
 *  given, Ruby adds an implicit block of &lt;code&gt;{|obj| obj}&lt;/code&gt; (that
 *  is &lt;code&gt;any?&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; if at least one
 *  of the collection members is not &lt;code&gt;false&lt;/code&gt; or
 *  &lt;code&gt;nil&lt;/code&gt;.
 *
 *     %w{ant bear cat}.any? {|word| word.length &gt;= 3}   #=&gt; true
 *     %w{ant bear cat}.any? {|word| word.length &gt;= 4}   #=&gt; true
 *     [ nil, true, 99 ].any?                            #=&gt; true
 *
 */

static VALUE
enum_any(VALUE obj)
{
    VALUE result = Qfalse;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(any), (VALUE)&amp;result);
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chunk-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chunk</strong> {|elt| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chunk</strong>(initial_state) {|elt, state| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates an enumerator for each chunked elements. The consecutive elements
which have same block value are chunked.
</p>
<p>
The result enumerator yields the block value and an array of chunked
elements. So &#8220;each&#8221; method can be called as follows.
</p>
<pre class="code">
  enum.chunk {|elt| key }.each {|key, ary| ... }
  enum.chunk(initial_state) {|elt, state| key }.each {|key, ary| ... }
</pre>
<p>
For example, consecutive even numbers and odd numbers can be splitted as
follows.
</p>
<pre class="code">
  [3,1,4,1,5,9,2,6,5,3,5].chunk {|n|
    n.even?
  }.each {|even, ary|
    p [even, ary]
  }
  #=&gt; [false, [3, 1]]
  #   [true, [4]]
  #   [false, [1, 5, 9]]
  #   [true, [2, 6]]
  #   [false, [5, 3, 5]]
</pre>
<p>
This method is especially useful for sorted series of elements. The
following example counts words for each initial letter.
</p>
<pre class="code">
  open(&quot;/usr/share/dict/words&quot;, &quot;r:iso-8859-1&quot;) {|f|
    f.chunk {|line| line.ord }.each {|ch, lines| p [ch.chr, lines.length] }
  }
  #=&gt; [&quot;\n&quot;, 1]
  #   [&quot;A&quot;, 1327]
  #   [&quot;B&quot;, 1372]
  #   [&quot;C&quot;, 1507]
  #   [&quot;D&quot;, 791]
  #   ...
</pre>
<p>
The following key values has special meaning:
</p>
<ul>
<li><p>
nil and :_separator specifies that the elements are dropped.
</p>
</li>
<li><p>
:_alone specifies that the element should be chunked as a singleton.
</p>
</li>
</ul>
<p>
Other symbols which begins an underscore are reserved.
</p>
<p>
nil and :_separator can be used to ignore some elements. For example, the
sequence of hyphens in svn log can be eliminated as follows.
</p>
<pre class="code">
  sep = &quot;-&quot;*72 + &quot;\n&quot;
  IO.popen(&quot;svn log README&quot;) {|f|
    f.chunk {|line|
      line != sep || nil
    }.each {|_, lines|
      pp lines
    }
  }
  #=&gt; [&quot;r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n&quot;,
  #    &quot;\n&quot;,
  #    &quot;* README, README.ja: Update the portability section.\n&quot;,
  #    &quot;\n&quot;]
  #   [&quot;r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n&quot;,
  #    &quot;\n&quot;,
  #    &quot;* README, README.ja: Add a note about default C flags.\n&quot;,
  #    &quot;\n&quot;]
  #   ...
</pre>
<p>
paragraphs separated by empty lines can be parsed as follows.
</p>
<pre class="code">
  File.foreach(&quot;README&quot;).chunk {|line|
    /\A\s*\z/ !~ line || nil
  }.each {|_, lines|
    pp lines
  }
</pre>
<p>
:_alone can be used to pass through bunch of elements. For example, sort
consecutive lines formed as Foo#bar and pass other lines, chunk can be used
as follows.
</p>
<pre class="code">
  pat = /\A[A-Z][A-Za-z0-9_]+\#/
  open(filename) {|f|
    f.chunk {|line| pat =~ line ? $&amp; : :_alone }.each {|key, lines|
      if key != :_alone
        print lines.sort.join('')
      else
        print lines.join('')
      end
    }
  }
</pre>
<p>
If the block needs to maintain state over multiple elements,
<em>initial_state</em> argument can be used. If non-nil value is given, it
is duplicated for each &#8220;each&#8221; method invocation of the
enumerator. The duplicated object is passed to 2nd argument of the block
for &#8220;chunk&#8221; method.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chunk</strong> {|elt| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>elt</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chunk</strong>(initial_state) {|elt, state| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>elt</tt>, <tt>state</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.chunk {|elt| ... }                       -&gt; an_enumerator
 *     enum.chunk(initial_state) {|elt, state| ... } -&gt; an_enumerator
 *
 *  Creates an enumerator for each chunked elements.
 *  The consecutive elements which have same block value are chunked.
 *
 *  The result enumerator yields the block value and an array of chunked elements.
 *  So &quot;each&quot; method can be called as follows.
 *
 *    enum.chunk {|elt| key }.each {|key, ary| ... }
 *    enum.chunk(initial_state) {|elt, state| key }.each {|key, ary| ... }
 *
 *  For example, consecutive even numbers and odd numbers can be
 *  splitted as follows.
 *
 *    [3,1,4,1,5,9,2,6,5,3,5].chunk {|n|
 *      n.even?
 *    }.each {|even, ary|
 *      p [even, ary]
 *    }
 *    #=&gt; [false, [3, 1]]
 *    #   [true, [4]]
 *    #   [false, [1, 5, 9]]
 *    #   [true, [2, 6]]
 *    #   [false, [5, 3, 5]]
 *
 *  This method is especially useful for sorted series of elements.
 *  The following example counts words for each initial letter.
 *
 *    open(&quot;/usr/share/dict/words&quot;, &quot;r:iso-8859-1&quot;) {|f|
 *      f.chunk {|line| line.ord }.each {|ch, lines| p [ch.chr, lines.length] }
 *    }
 *    #=&gt; [&quot;\n&quot;, 1]
 *    #   [&quot;A&quot;, 1327]
 *    #   [&quot;B&quot;, 1372]
 *    #   [&quot;C&quot;, 1507]
 *    #   [&quot;D&quot;, 791]
 *    #   ...
 *
 *  The following key values has special meaning:
 *  - nil and :_separator specifies that the elements are dropped.
 *  - :_alone specifies that the element should be chunked as a singleton.
 *  Other symbols which begins an underscore are reserved.
 *
 *  nil and :_separator can be used to ignore some elements.
 *  For example, the sequence of hyphens in svn log can be eliminated as follows.
 *
 *    sep = &quot;-&quot;*72 + &quot;\n&quot;
 *    IO.popen(&quot;svn log README&quot;) {|f|
 *      f.chunk {|line|
 *        line != sep || nil
 *      }.each {|_, lines|
 *        pp lines
 *      }
 *    }
 *    #=&gt; [&quot;r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n&quot;,
 *    #    &quot;\n&quot;,
 *    #    &quot;* README, README.ja: Update the portability section.\n&quot;,
 *    #    &quot;\n&quot;]
 *    #   [&quot;r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n&quot;,
 *    #    &quot;\n&quot;,
 *    #    &quot;* README, README.ja: Add a note about default C flags.\n&quot;,
 *    #    &quot;\n&quot;]
 *    #   ...
 *
 *  paragraphs separated by empty lines can be parsed as follows.
 *
 *    File.foreach(&quot;README&quot;).chunk {|line|
 *      /\A\s*\z/ !~ line || nil
 *    }.each {|_, lines|
 *      pp lines
 *    }
 *
 *  :_alone can be used to pass through bunch of elements.
 *  For example, sort consecutive lines formed as Foo#bar and
 *  pass other lines, chunk can be used as follows.
 *
 *    pat = /\A[A-Z][A-Za-z0-9_]+\#/
 *    open(filename) {|f|
 *      f.chunk {|line| pat =~ line ? $&amp; : :_alone }.each {|key, lines|
 *        if key != :_alone
 *          print lines.sort.join('')
 *        else
 *          print lines.join('')
 *        end
 *      }
 *    }
 *
 *  If the block needs to maintain state over multiple elements,
 *  _initial_state_ argument can be used.
 *  If non-nil value is given,
 *  it is duplicated for each &quot;each&quot; method invocation of the enumerator.
 *  The duplicated object is passed to 2nd argument of the block for &quot;chunk&quot; method.
 *
 */
static VALUE
enum_chunk(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE initial_state;
    VALUE enumerator;

    if(!rb_block_given_p())
    rb_raise(rb_eArgError, &quot;no block given&quot;);
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;initial_state);

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_enumerable&quot;), enumerable);
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_categorize&quot;), rb_block_proc());
    rb_ivar_set(enumerator, rb_intern(&quot;chunk_initial_state&quot;), initial_state);
    rb_block_call(enumerator, rb_intern(&quot;initialize&quot;), 0, 0, chunk_i, enumerator);
    return enumerator;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="collect-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>map</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..4).collect {|i| i*i }   #=&gt; [1, 4, 9, 16]
   (1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>map</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.collect {| obj | block }  -&gt; array
 *     enum.map     {| obj | block }  -&gt; array
 *     enum.collect                   -&gt; an_enumerator
 *     enum.map                       -&gt; an_enumerator
 *
 *  Returns a new array with the results of running &lt;em&gt;block&lt;/em&gt; once
 *  for every element in &lt;i&gt;enum&lt;/i&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     (1..4).collect {|i| i*i }   #=&gt; [1, 4, 9, 16]
 *     (1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]
 *
 */

static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="collect_concat-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>flat_map</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect_concat</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>flat_map</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect_concat</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   [[1,2],[3,4]].flat_map {|i| i }   #=&gt; [1, 2, 3, 4]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>flat_map</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect_concat</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.flat_map       {| obj | block }  -&gt; array
 *     enum.collect_concat {| obj | block }  -&gt; array
 *     enum.flat_map                         -&gt; an_enumerator
 *     enum.collect_concat                   -&gt; an_enumerator
 *
 *  Returns a new array with the concatenated results of running
 *  &lt;em&gt;block&lt;/em&gt; once for every element in &lt;i&gt;enum&lt;/i&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     [[1,2],[3,4]].flat_map {|i| i }   #=&gt; [1, 2, 3, 4]
 *
 */

static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="count-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong>(item) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> {|obj| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the number of items in <em>enum</em>, where #size is called if it
responds to it, otherwise the items are counted through enumeration.  If an
argument is given, counts the number of items in <em>enum</em>, for which
equals to <em>item</em>.  If a block is given, counts the number of
elements yielding a true value.
</p>
<pre class="code">
   ary = [1, 2, 4, 2]
   ary.count             #=&gt; 4
   ary.count(2)          #=&gt; 2
   ary.count{|x|x%2==0}  #=&gt; 3</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong>(item) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>count</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.count                   -&gt; int
 *     enum.count(item)             -&gt; int
 *     enum.count {| obj | block }  -&gt; int
 *
 *  Returns the number of items in &lt;i&gt;enum&lt;/i&gt;, where #size is called
 *  if it responds to it, otherwise the items are counted through
 *  enumeration.  If an argument is given, counts the number of items
 *  in &lt;i&gt;enum&lt;/i&gt;, for which equals to &lt;i&gt;item&lt;/i&gt;.  If a block is
 *  given, counts the number of elements yielding a true value.
 *
 *     ary = [1, 2, 4, 2]
 *     ary.count             #=&gt; 4
 *     ary.count(2)          #=&gt; 2
 *     ary.count{|x|x%2==0}  #=&gt; 3
 *
 */

static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];  /* [count, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
    if (rb_block_given_p()) {
        func = count_iter_i;
    }
    else {
        func = count_all_i;
    }
    }
    else {
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[1]);
    if (rb_block_given_p()) {
        rb_warn(&quot;given block not used&quot;);
    }
        func = count_i;
    }

    memo[0] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)&amp;memo);
    return INT2NUM(memo[0]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="cycle-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>cycle</strong>(n = nil) {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>cycle</strong>(n = nil) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Calls <em>block</em> for each element of <em>enum</em> repeatedly
<em>n</em> times or forever if none or <tt>nil</tt> is given.  If a
non-positive number is given or the collection is empty, does nothing. 
Returns <tt>nil</tt> if the loop has finished without getting interrupted.
</p>
<p>
Enumerable#cycle saves elements in an internal array so changes to
<em>enum</em> after the first pass have no effect.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
   a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>cycle</strong>(n = nil) {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.cycle(n=nil) {|obj| block }   -&gt;  nil
 *     enum.cycle(n=nil)                  -&gt;  an_enumerator
 *
 *  Calls &lt;i&gt;block&lt;/i&gt; for each element of &lt;i&gt;enum&lt;/i&gt; repeatedly _n_
 *  times or forever if none or +nil+ is given.  If a non-positive
 *  number is given or the collection is empty, does nothing.  Returns
 *  +nil+ if the loop has finished without getting interrupted.
 *
 *  Enumerable#cycle saves elements in an internal array so changes
 *  to &lt;i&gt;enum&lt;/i&gt; after the first pass have no effect.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
 *     a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.
 *
 */

static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(obj, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC(ary)-&gt;klass = 0;
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            rb_yield(RARRAY_PTR(ary)[i]);
        }
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="detect-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>detect</strong>(ifnone = nil) {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>find</strong>(ifnone = nil) {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>detect</strong>(ifnone = nil) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>find</strong>(ifnone = nil) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<tt>nil</tt> otherwise.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>detect</strong>(ifnone = nil) {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>find</strong>(ifnone = nil) {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.detect(ifnone = nil) {| obj | block }  -&gt; obj or nil
 *     enum.find(ifnone = nil)   {| obj | block }  -&gt; obj or nil
 *     enum.detect(ifnone = nil)                   -&gt; an_enumerator
 *     enum.find(ifnone = nil)                     -&gt; an_enumerator
 *
 *  Passes each entry in &lt;i&gt;enum&lt;/i&gt; to &lt;em&gt;block&lt;/em&gt;. Returns the
 *  first for which &lt;em&gt;block&lt;/em&gt; is not false.  If no
 *  object matches, calls &lt;i&gt;ifnone&lt;/i&gt; and returns its result when it
 *  is specified, or returns &lt;code&gt;nil&lt;/code&gt; otherwise.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
 *     (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35
 *
 */

static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo = Qundef;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)&amp;memo);
    if (memo != Qundef) {
    return memo;
    }
    if (!NIL_P(if_none)) {
    return rb_funcall(if_none, rb_intern(&quot;call&quot;), 0, 0);
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="drop-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>drop</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Drops first n elements from <em>enum</em>, and returns rest elements in an
array.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.drop(3)             #=&gt; [4, 5, 0]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.drop(n)               -&gt; array
 *
 *  Drops first n elements from &lt;i&gt;enum&lt;/i&gt;, and returns rest elements
 *  in an array.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop(3)             #=&gt; [4, 5, 0]
 *
 */

static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
    rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    args[1] = len;
    args[0] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)args);
    return args[0];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="drop_while-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>drop_while</strong> {|arr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>drop_while</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Drops elements up to, but not including, the first element for which the
block returns <tt>nil</tt> or <tt>false</tt> and returns an array
containing the remaining elements.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.drop_while {|i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>drop_while</strong> {|arr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>arr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.drop_while {|arr| block }   -&gt; array
 *     enum.drop_while                  -&gt; an_enumerator
 *
 *  Drops elements up to, but not including, the first element for
 *  which the block returns +nil+ or +false+ and returns an array
 *  containing the remaining elements.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop_while {|i| i &lt; 3 }   #=&gt; [3, 4, 5, 0]
 *
 */

static VALUE
enum_drop_while(VALUE obj)
{
    VALUE args[2];

    RETURN_ENUMERATOR(obj, 0, 0);
    args[0] = rb_ary_new();
    args[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)args);
    return args[0];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_cons-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>each_cons</strong>(n) { ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_cons</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Iterates the given block for each array of consecutive <n> elements.  If no
block is given, returns an enumerator.
</p>
<p>
e.g.:
</p>
<pre class="code">
    (1..10).each_cons(3) {|a| p a}
    # outputs below
    [1, 2, 3]
    [2, 3, 4]
    [3, 4, 5]
    [4, 5, 6]
    [5, 6, 7]
    [6, 7, 8]
    [7, 8, 9]
    [8, 9, 10]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>each_cons</strong>(n) { ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'></span>
      
      
      
      
        
        <div class='inline'></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *    enum.each_cons(n) {...}   -&gt;  nil
 *    enum.each_cons(n)         -&gt;  an_enumerator
 *
 *  Iterates the given block for each array of consecutive &lt;n&gt;
 *  elements.  If no block is given, returns an enumerator.
 *
 *  e.g.:
 *      (1..10).each_cons(3) {|a| p a}
 *      # outputs below
 *      [1, 2, 3]
 *      [2, 3, 4]
 *      [3, 4, 5]
 *      [4, 5, 6]
 *      [5, 6, 7]
 *      [6, 7, 8]
 *      [7, 8, 9]
 *      [8, 9, 10]
 *
 */
static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE args[2];

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)args);

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_entry-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>) <strong>each_entry</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_entry</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Calls <em>block</em> once for each element in <tt>self</tt>, passing that
element as a parameter, converting multiple values from yield to an array.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   class Foo
     include Enumerable
     def each
       yield 1
       yield 1,2
     end
   end
   Foo.new.each_entry{|o| print o, &quot; -- &quot;}
</pre>
<p>
produces:
</p>
<pre class="code">
   1 -- [1, 2] --</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>) <strong>each_entry</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.each_entry {|obj| block}  -&gt; enum
 *     enum.each_entry                -&gt; an_enumerator
 *
 *  Calls &lt;i&gt;block&lt;/i&gt; once for each element in +self+, passing that
 *  element as a parameter, converting multiple values from yield to an
 *  array.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     class Foo
 *       include Enumerable
 *       def each
 *         yield 1
 *         yield 1,2
 *       end
 *     end
 *     Foo.new.each_entry{|o| print o, &quot; -- &quot;}
 *
 *  produces:
 *
 *     1 -- [1, 2] --
 */

static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_slice-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>each_slice</strong>(n) { ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_slice</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Iterates the given block for each slice of <n> elements.  If no block is
given, returns an enumerator.
</p>
<p>
e.g.:
</p>
<pre class="code">
    (1..10).each_slice(3) {|a| p a}
    # outputs below
    [1, 2, 3]
    [4, 5, 6]
    [7, 8, 9]
    [10]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>each_slice</strong>(n) { ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'></span>
      
      
      
      
        
        <div class='inline'></div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *    enum.each_slice(n) {...}  -&gt;  nil
 *    enum.each_slice(n)        -&gt;  an_enumerator
 *
 *  Iterates the given block for each slice of &lt;n&gt; elements.  If no
 *  block is given, returns an enumerator.
 *
 *  e.g.:
 *      (1..10).each_slice(3) {|a| p a}
 *      # outputs below
 *      [1, 2, 3]
 *      [4, 5, 6]
 *      [7, 8, 9]
 *      [10]
 *
 */
static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE args[2], ary;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid slice size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)args);

    ary = args[0];
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_with_index-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>) <strong>each_with_index</strong>(*args) {|obj, i| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_with_index</strong>(*args) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Calls <em>block</em> with two arguments, the item and its index, for each
item in <em>enum</em>.  Given arguments are passed through to #each().
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   hash = Hash.new
   %w(cat dog wombat).each_with_index {|item, index|
     hash[item] = index
   }
   hash   #=&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>) <strong>each_with_index</strong>(*args) {|obj, i| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>, <tt>i</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.each_with_index(*args) {|obj, i| block }   -&gt;  enum
 *     enum.each_with_index(*args)                     -&gt;  an_enumerator
 *
 *  Calls &lt;em&gt;block&lt;/em&gt; with two arguments, the item and its index,
 *  for each item in &lt;i&gt;enum&lt;/i&gt;.  Given arguments are passed through
 *  to #each().
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     hash = Hash.new
 *     %w(cat dog wombat).each_with_index {|item, index|
 *       hash[item] = index
 *     }
 *     hash   #=&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}
 *
 */

static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    long memo;

    RETURN_ENUMERATOR(obj, argc, argv);

    memo = 0;
    rb_block_call(obj, id_each, argc, argv, each_with_index_i, (VALUE)&amp;memo);
    return obj;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_with_object-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_with_object</strong>(obj) {|(*args), memo_obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_with_object</strong>(obj) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Iterates the given block for each element with an arbitrary object given,
and returns the initially given object.
</p>
<p>
If no block is given, returns an enumerator.
</p>
<p>
e.g.:
</p>
<pre class="code">
    evens = (1..10).each_with_object([]) {|i, a| a &lt;&lt; i*2 }
    #=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_with_object</strong>(obj) {|(*args), memo_obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>(*args)</tt>, <tt>memo_obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *    enum.each_with_object(obj) {|(*args), memo_obj| ... }  -&gt;  obj
 *    enum.each_with_object(obj)                             -&gt;  an_enumerator
 *
 *  Iterates the given block for each element with an arbitrary
 *  object given, and returns the initially given object.
 *
 *  If no block is given, returns an enumerator.
 *
 *  e.g.:
 *      evens = (1..10).each_with_object([]) {|i, a| a &lt;&lt; i*2 }
 *      #=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
 *
 */
static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_ENUMERATOR(obj, 1, &amp;memo);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="entries-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>to_a</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>entries</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array containing the items in <em>enum</em>.
</p>
<pre class="code">
   (1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
   { 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>to_a</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>entries</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.to_a      -&gt;    array
 *     enum.entries   -&gt;    array
 *
 *  Returns an array containing the items in &lt;i&gt;enum&lt;/i&gt;.
 *
 *     (1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
 *     { 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]
 */
static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="find-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>detect</strong>(ifnone = nil) {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>find</strong>(ifnone = nil) {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>detect</strong>(ifnone = nil) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>find</strong>(ifnone = nil) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes each entry in <em>enum</em> to <em>block</em>. Returns the first for
which <em>block</em> is not false.  If no object matches, calls
<em>ifnone</em> and returns its result when it is specified, or returns
<tt>nil</tt> otherwise.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>detect</strong>(ifnone = nil) {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>find</strong>(ifnone = nil) {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.detect(ifnone = nil) {| obj | block }  -&gt; obj or nil
 *     enum.find(ifnone = nil)   {| obj | block }  -&gt; obj or nil
 *     enum.detect(ifnone = nil)                   -&gt; an_enumerator
 *     enum.find(ifnone = nil)                     -&gt; an_enumerator
 *
 *  Passes each entry in &lt;i&gt;enum&lt;/i&gt; to &lt;em&gt;block&lt;/em&gt;. Returns the
 *  first for which &lt;em&gt;block&lt;/em&gt; is not false.  If no
 *  object matches, calls &lt;i&gt;ifnone&lt;/i&gt; and returns its result when it
 *  is specified, or returns &lt;code&gt;nil&lt;/code&gt; otherwise.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
 *     (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35
 *
 */

static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo = Qundef;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_block_call(obj, id_each, 0, 0, find_i, (VALUE)&amp;memo);
    if (memo != Qundef) {
    return memo;
    }
    if (!NIL_P(if_none)) {
    return rb_funcall(if_none, rb_intern(&quot;call&quot;), 0, 0);
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="find_all-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>find_all</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>select</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>find_all</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>select</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <tt>false</tt> (see also <tt>Enumerable#reject</tt>).
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..10).find_all {|i|  i % 3 == 0 }   #=&gt; [3, 6, 9]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>find_all</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>select</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.find_all {| obj | block }  -&gt; array
 *     enum.select   {| obj | block }  -&gt; array
 *     enum.find_all                   -&gt; an_enumerator
 *     enum.select                     -&gt; an_enumerator
 *
 *  Returns an array containing all elements of &lt;i&gt;enum&lt;/i&gt; for which
 *  &lt;em&gt;block&lt;/em&gt; is not &lt;code&gt;false&lt;/code&gt; (see also
 *  &lt;code&gt;Enumerable#reject&lt;/code&gt;).
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *
 *     (1..10).find_all {|i|  i % 3 == 0 }   #=&gt; [3, 6, 9]
 *
 */

static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="find_index-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>find_index</strong>(value) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>find_index</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>find_index</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Compares each entry in <em>enum</em> with <em>value</em> or passes to
<em>block</em>.  Returns the index for the first for which the evaluated
value is non-false.  If no object matches, returns <tt>nil</tt>
</p>
<p>
If neither block nor argument is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
   (1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 34
   (1..100).find_index(50)                                #=&gt; 49</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>find_index</strong>(value) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt><sup>?</sup>) <strong>find_index</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.find_index(value)            -&gt; int or nil
 *     enum.find_index {| obj | block }  -&gt; int or nil
 *     enum.find_index                   -&gt; an_enumerator
 *
 *  Compares each entry in &lt;i&gt;enum&lt;/i&gt; with &lt;em&gt;value&lt;/em&gt; or passes
 *  to &lt;em&gt;block&lt;/em&gt;.  Returns the index for the first for which the
 *  evaluated value is non-false.  If no object matches, returns
 *  &lt;code&gt;nil&lt;/code&gt;
 *
 *  If neither block nor argument is given, an enumerator is returned instead.
 *
 *     (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
 *     (1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 34
 *     (1..100).find_index(50)                                #=&gt; 49
 *
 */

static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[3];  /* [return value, current index, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[2]);
    if (rb_block_given_p()) {
        rb_warn(&quot;given block not used&quot;);
    }
        func = find_index_i;
    }

    memo[0] = Qnil;
    memo[1] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo[0];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="first-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>first</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>first</strong>(n) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the first element, or the first <tt>n</tt> elements, of the
enumerable. If the enumerable is empty, the first form returns
<tt>nil</tt>, and the second form returns an empty array.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt><sup>?</sup>) <strong>first</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>first</strong>(n) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.first       -&gt;  obj or nil
 *     enum.first(n)    -&gt;  an_array
 *
 *  Returns the first element, or the first +n+ elements, of the enumerable.
 *  If the enumerable is empty, the first form returns &lt;code&gt;nil&lt;/code&gt;, and the
 *  second form returns an empty array.
 *
 */

static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    VALUE n, params[2];

    if (argc == 0) {
    params[0] = params[1] = Qnil;
    }
    else {
    long len;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
    len = NUM2LONG(n);
    if (len == 0) return rb_ary_new2(0);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative length&quot;);
    }
    params[0] = len;
    params[1] = rb_ary_new2(len);
    }
    rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)params);

    return params[1];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="flat_map-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>flat_map</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect_concat</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>flat_map</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect_concat</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array with the concatenated results of running <em>block</em>
once for every element in <em>enum</em>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   [[1,2],[3,4]].flat_map {|i| i }   #=&gt; [1, 2, 3, 4]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>flat_map</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect_concat</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.flat_map       {| obj | block }  -&gt; array
 *     enum.collect_concat {| obj | block }  -&gt; array
 *     enum.flat_map                         -&gt; an_enumerator
 *     enum.collect_concat                   -&gt; an_enumerator
 *
 *  Returns a new array with the concatenated results of running
 *  &lt;em&gt;block&lt;/em&gt; once for every element in &lt;i&gt;enum&lt;/i&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     [[1,2],[3,4]].flat_map {|i| i }   #=&gt; [1, 2, 3, 4]
 *
 */

static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="grep-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>grep</strong>(pattern) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>grep</strong>(pattern) {|obj| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array of every element in <em>enum</em> for which <tt>Pattern
=== element</tt>. If the optional <em>block</em> is supplied, each matching
element is passed to it, and the block&#8217;s result is stored in the
output array.
</p>
<pre class="code">
   (1..100).grep 38..44   #=&gt; [38, 39, 40, 41, 42, 43, 44]
   c = IO.constants
   c.grep(/SEEK/)         #=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]
   res = c.grep(/SEEK/) {|v| IO.const_get(v) }
   res                    #=&gt; [0, 1, 2]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>grep</strong>(pattern) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>grep</strong>(pattern) {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.grep(pattern)                   -&gt; array
 *     enum.grep(pattern) {| obj | block }  -&gt; array
 *
 *  Returns an array of every element in &lt;i&gt;enum&lt;/i&gt; for which
 *  &lt;code&gt;Pattern === element&lt;/code&gt;. If the optional &lt;em&gt;block&lt;/em&gt; is
 *  supplied, each matching element is passed to it, and the block's
 *  result is stored in the output array.
 *
 *     (1..100).grep 38..44   #=&gt; [38, 39, 40, 41, 42, 43, 44]
 *     c = IO.constants
 *     c.grep(/SEEK/)         #=&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]
 *     res = c.grep(/SEEK/) {|v| IO.const_get(v) }
 *     res                    #=&gt; [0, 1, 2]
 *
 */

static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    VALUE ary = rb_ary_new();
    VALUE arg[2];

    arg[0] = pat;
    arg[1] = ary;

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)arg);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="group_by-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span></tt>) <strong>group_by</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>group_by</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a hash, which keys are evaluated result from the block, and values
are arrays of elements in <em>enum</em> corresponding to the key.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..6).group_by {|i| i%3}   #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span></tt>) <strong>group_by</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">Hash</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.group_by {| obj | block }  -&gt; a_hash
 *     enum.group_by                   -&gt; an_enumerator
 *
 *  Returns a hash, which keys are evaluated result from the
 *  block, and values are arrays of elements in &lt;i&gt;enum&lt;/i&gt;
 *  corresponding to the key.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     (1..6).group_by {|i| i%3}   #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}
 *
 */

static VALUE
enum_group_by(VALUE obj)
{
    VALUE hash;

    RETURN_ENUMERATOR(obj, 0, 0);

    hash = rb_hash_new();
    rb_block_call(obj, id_each, 0, 0, group_by_i, hash);
    OBJ_INFECT(hash, obj);

    return hash;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="include?-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>include?</strong>(obj) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>member?</strong>(obj) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if any member of <em>enum</em> equals <em>obj</em>.
Equality is tested using <tt>==</tt>.
</p>
<pre class="code">
   IO.constants.include? :SEEK_SET          #=&gt; true
   IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>include?</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>member?</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.include?(obj)     -&gt; true or false
 *     enum.member?(obj)      -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if any member of &lt;i&gt;enum&lt;/i&gt; equals
 *  &lt;i&gt;obj&lt;/i&gt;. Equality is tested using &lt;code&gt;==&lt;/code&gt;.
 *
 *     IO.constants.include? :SEEK_SET          #=&gt; true
 *     IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false
 *
 */

static VALUE
enum_member(VALUE obj, VALUE val)
{
    VALUE memo[2];

    memo[0] = val;
    memo[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo[1];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inject-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial, sym) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(sym) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial) {|memo, obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong> {|memo, obj| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
enum.reduce(initial, sym) -> obj
</p>
<pre class="code">
   enum.reduce(sym)          -&gt; obj
   enum.reduce(initial) {| memo, obj | block }  -&gt; obj
   enum.reduce          {| memo, obj | block }  -&gt; obj
</pre>
<p>
Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.
</p>
<p>
If you specify a block, then for each element in <em>enum<i> the block is
passed an accumulator value (<i>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value fo the method.
</p>
<p>
If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then uses the first element of collection is used as the
initial value of <em>memo</em>.
</p>
<p>
Examples:
</p>
<pre class="code">
   # Sum some numbers
   (5..10).reduce(:+)                            #=&gt; 45
   # Same using a block and inject
   (5..10).inject {|sum, n| sum + n }            #=&gt; 45
   # Multiply some numbers
   (5..10).reduce(1, :*)                         #=&gt; 151200
   # Same using a block
   (5..10).inject(1) {|product, n| product * n } #=&gt; 151200
   # find the longest word
   longest = %w{ cat sheep bear }.inject do |memo,word|
      memo.length &gt; word.length ? memo : word
   end
   longest                                       #=&gt; &quot;sheep&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial, sym) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(sym) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial) {|memo, obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>memo</tt>, <tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong> {|memo, obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>memo</tt>, <tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.inject(initial, sym) -&gt; obj
 *     enum.inject(sym)          -&gt; obj
 *     enum.inject(initial) {| memo, obj | block }  -&gt; obj
 *     enum.inject          {| memo, obj | block }  -&gt; obj
 *
 *     enum.reduce(initial, sym) -&gt; obj
 *     enum.reduce(sym)          -&gt; obj
 *     enum.reduce(initial) {| memo, obj | block }  -&gt; obj
 *     enum.reduce          {| memo, obj | block }  -&gt; obj
 *
 *  Combines all elements of &lt;i&gt;enum&lt;/i&gt; by applying a binary
 *  operation, specified by a block or a symbol that names a
 *  method or operator.
 *
 *  If you specify a block, then for each element in &lt;i&gt;enum&lt;i&gt;
 *  the block is passed an accumulator value (&lt;i&gt;memo&lt;/i&gt;) and the element.
 *  If you specify a symbol instead, then each element in the collection
 *  will be passed to the named method of &lt;i&gt;memo&lt;/i&gt;.
 *  In either case, the result becomes the new value for &lt;i&gt;memo&lt;/i&gt;.
 *  At the end of the iteration, the final value of &lt;i&gt;memo&lt;/i&gt; is the
 *  return value fo the method.
 *
 *  If you do not explicitly specify an &lt;i&gt;initial&lt;/i&gt; value for &lt;i&gt;memo&lt;/i&gt;,
 *  then uses the first element of collection is used as the initial value
 *  of &lt;i&gt;memo&lt;/i&gt;.
 *
 *  Examples:
 *
 *     # Sum some numbers
 *     (5..10).reduce(:+)                            #=&gt; 45
 *     # Same using a block and inject
 *     (5..10).inject {|sum, n| sum + n }            #=&gt; 45
 *     # Multiply some numbers
 *     (5..10).reduce(1, :*)                         #=&gt; 151200
 *     # Same using a block
 *     (5..10).inject(1) {|product, n| product * n } #=&gt; 151200
 *     # find the longest word
 *     longest = %w{ cat sheep bear }.inject do |memo,word|
 *        memo.length &gt; word.length ? memo : word
 *     end
 *     longest                                       #=&gt; &quot;sheep&quot;
 *
 */
static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];
    VALUE (*iter)(VALUE, VALUE, int, VALUE*) = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
    memo[0] = Qundef;
    break;
      case 1:
    if (rb_block_given_p()) {
        break;
    }
    memo[1] = (VALUE)rb_to_id(memo[0]);
    memo[0] = Qundef;
    iter = inject_op_i;
    break;
      case 2:
    if (rb_block_given_p()) {
        rb_warning(&quot;given block not used&quot;);
    }
    memo[1] = (VALUE)rb_to_id(memo[1]);
    iter = inject_op_i;
    break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="map-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>map</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>collect</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>map</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new array with the results of running <em>block</em> once for
every element in <em>enum</em>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..4).collect {|i| i*i }   #=&gt; [1, 4, 9, 16]
   (1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>collect</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>map</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.collect {| obj | block }  -&gt; array
 *     enum.map     {| obj | block }  -&gt; array
 *     enum.collect                   -&gt; an_enumerator
 *     enum.map                       -&gt; an_enumerator
 *
 *  Returns a new array with the results of running &lt;em&gt;block&lt;/em&gt; once
 *  for every element in &lt;i&gt;enum&lt;/i&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     (1..4).collect {|i| i*i }   #=&gt; [1, 4, 9, 16]
 *     (1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]
 *
 */

static VALUE
enum_collect(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, collect_i, ary);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="max-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>max</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>max</strong> {|a, b| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the object in <em>enum</em> with the maximum value. The first form
assumes all objects implement <tt>Comparable</tt>; the second uses the
block to return <em>a <=> b</em>.
</p>
<pre class="code">
   a = %w(albatross dog horse)
   a.max                                  #=&gt; &quot;horse&quot;
   a.max {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;albatross&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>max</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>max</strong> {|a, b| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>a</tt>, <tt>b</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.max                   -&gt; obj
 *     enum.max {|a,b| block }    -&gt; obj
 *
 *  Returns the object in _enum_ with the maximum value. The
 *  first form assumes all objects implement &lt;code&gt;Comparable&lt;/code&gt;;
 *  the second uses the block to return &lt;em&gt;a &lt;=&gt; b&lt;/em&gt;.
 *
 *     a = %w(albatross dog horse)
 *     a.max                                  #=&gt; &quot;horse&quot;
 *     a.max {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;albatross&quot;
 */

static VALUE
enum_max(VALUE obj)
{
    VALUE result = Qundef;

    if (rb_block_given_p()) {
    rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)&amp;result);
    }
    else {
    rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)&amp;result);
    }
    if (result == Qundef) return Qnil;
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="max_by-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>max_by</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>max_by</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the object in <em>enum</em> that gives the maximum value from the
given block.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = %w(albatross dog horse)
   a.max_by {|x| x.length }   #=&gt; &quot;albatross&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>max_by</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.max_by {|obj| block }   -&gt; obj
 *     enum.max_by                  -&gt; an_enumerator
 *
 *  Returns the object in &lt;i&gt;enum&lt;/i&gt; that gives the maximum
 *  value from the given block.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = %w(albatross dog horse)
 *     a.max_by {|x| x.length }   #=&gt; &quot;albatross&quot;
 */

static VALUE
enum_max_by(VALUE obj)
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo[1];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="member?-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>include?</strong>(obj) </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>member?</strong>(obj) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if any member of <em>enum</em> equals <em>obj</em>.
Equality is tested using <tt>==</tt>.
</p>
<pre class="code">
   IO.constants.include? :SEEK_SET          #=&gt; true
   IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>include?</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>member?</strong>(obj) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.include?(obj)     -&gt; true or false
 *     enum.member?(obj)      -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if any member of &lt;i&gt;enum&lt;/i&gt; equals
 *  &lt;i&gt;obj&lt;/i&gt;. Equality is tested using &lt;code&gt;==&lt;/code&gt;.
 *
 *     IO.constants.include? :SEEK_SET          #=&gt; true
 *     IO.constants.include? :SEEK_NO_FURTHER   #=&gt; false
 *
 */

static VALUE
enum_member(VALUE obj, VALUE val)
{
    VALUE memo[2];

    memo[0] = val;
    memo[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, member_i, (VALUE)memo);
    return memo[1];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="min-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>min</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>min</strong> {|a, b| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the object in <em>enum</em> with the minimum value. The first form
assumes all objects implement <tt>Comparable</tt>; the second uses the
block to return <em>a <=> b</em>.
</p>
<pre class="code">
   a = %w(albatross dog horse)
   a.min                                  #=&gt; &quot;albatross&quot;
   a.min {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;dog&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>min</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>min</strong> {|a, b| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>a</tt>, <tt>b</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.min                    -&gt; obj
 *     enum.min {| a,b | block }   -&gt; obj
 *
 *  Returns the object in &lt;i&gt;enum&lt;/i&gt; with the minimum value. The
 *  first form assumes all objects implement &lt;code&gt;Comparable&lt;/code&gt;;
 *  the second uses the block to return &lt;em&gt;a &lt;=&gt; b&lt;/em&gt;.
 *
 *     a = %w(albatross dog horse)
 *     a.min                                  #=&gt; &quot;albatross&quot;
 *     a.min {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;dog&quot;
 */

static VALUE
enum_min(VALUE obj)
{
    VALUE result = Qundef;

    if (rb_block_given_p()) {
    rb_block_call(obj, id_each, 0, 0, min_ii, (VALUE)&amp;result);
    }
    else {
    rb_block_call(obj, id_each, 0, 0, min_i, (VALUE)&amp;result);
    }
    if (result == Qundef) return Qnil;
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="min_by-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>min_by</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>min_by</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the object in <em>enum</em> that gives the minimum value from the
given block.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = %w(albatross dog horse)
   a.min_by {|x| x.length }   #=&gt; &quot;dog&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>min_by</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.min_by {|obj| block }   -&gt; obj
 *     enum.min_by                  -&gt; an_enumerator
 *
 *  Returns the object in &lt;i&gt;enum&lt;/i&gt; that gives the minimum
 *  value from the given block.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = %w(albatross dog horse)
 *     a.min_by {|x| x.length }   #=&gt; &quot;dog&quot;
 */

static VALUE
enum_min_by(VALUE obj)
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo[1];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="minmax-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>minmax</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>minmax</strong> {|a, b| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns two elements array which contains the minimum and the maximum value
in the enumerable.  The first form assumes all objects implement
<tt>Comparable</tt>; the second uses the block to return <em>a <=> b</em>.
</p>
<pre class="code">
   a = %w(albatross dog horse)
   a.minmax                                  #=&gt; [&quot;albatross&quot;, &quot;horse&quot;]
   a.minmax {|a,b| a.length &lt;=&gt; b.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>minmax</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>minmax</strong> {|a, b| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>a</tt>, <tt>b</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.minmax                   -&gt; [min,max]
 *     enum.minmax {|a,b| block }    -&gt; [min,max]
 *
 *  Returns two elements array which contains the minimum and the
 *  maximum value in the enumerable.  The first form assumes all
 *  objects implement &lt;code&gt;Comparable&lt;/code&gt;; the second uses the
 *  block to return &lt;em&gt;a &lt;=&gt; b&lt;/em&gt;.
 *
 *     a = %w(albatross dog horse)
 *     a.minmax                                  #=&gt; [&quot;albatross&quot;, &quot;horse&quot;]
 *     a.minmax {|a,b| a.length &lt;=&gt; b.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]
 */

static VALUE
enum_minmax(VALUE obj)
{
    struct minmax_t memo;
    VALUE ary = rb_ary_new3(2, Qnil, Qnil);

    memo.min = Qundef;
    memo.last = Qundef;
    if (rb_block_given_p()) {
    rb_block_call(obj, id_each, 0, 0, minmax_ii, (VALUE)&amp;memo);
        if (memo.last != Qundef)
            minmax_ii_update(memo.last, memo.last, &amp;memo);
    }
    else {
    rb_block_call(obj, id_each, 0, 0, minmax_i, (VALUE)&amp;memo);
        if (memo.last != Qundef)
            minmax_i_update(memo.last, memo.last, &amp;memo);
    }
    if (memo.min != Qundef) {
        rb_ary_store(ary, 0, memo.min);
        rb_ary_store(ary, 1, memo.max);
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="minmax_by-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>minmax_by</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>minmax_by</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns two elements array array containing the objects in <em>enum</em>
that gives the minimum and maximum values respectively from the given
block.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = %w(albatross dog horse)
   a.minmax_by {|x| x.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>minmax_by</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.minmax_by {|obj| block }   -&gt; [min, max]
 *     enum.minmax_by                  -&gt; an_enumerator
 *
 *  Returns two elements array array containing the objects in
 *  &lt;i&gt;enum&lt;/i&gt; that gives the minimum and maximum values respectively
 *  from the given block.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = %w(albatross dog horse)
 *     a.minmax_by {|x| x.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]
 */

static VALUE
enum_minmax_by(VALUE obj)
{
    struct minmax_by_t memo;

    RETURN_ENUMERATOR(obj, 0, 0);

    memo.min_bv = Qundef;
    memo.max_bv = Qundef;
    memo.min = Qnil;
    memo.max = Qnil;
    memo.last_bv = Qundef;
    memo.last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, (VALUE)&amp;memo);
    if (memo.last_bv != Qundef)
        minmax_by_i_update(memo.last_bv, memo.last_bv, memo.last, memo.last, &amp;memo);
    return rb_assoc_new(memo.min, memo.max);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="none?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>none?</strong> {|obj| ... }
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block never returns <tt>true</tt> for all
elements. If the block is not given, <tt>none?</tt> will return
<tt>true</tt> only if none of the collection members is true.
</p>
<pre class="code">
   %w{ant bear cat}.none? {|word| word.length == 5}  #=&gt; true
   %w{ant bear cat}.none? {|word| word.length &gt;= 4}  #=&gt; false
   [].none?                                          #=&gt; true
   [nil].none?                                       #=&gt; true
   [nil,false].none?                                 #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.none? [{|obj| block }]   -&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block never returns &lt;code&gt;true&lt;/code&gt;
 *  for all elements. If the block is not given, &lt;code&gt;none?&lt;/code&gt; will return
 *  &lt;code&gt;true&lt;/code&gt; only if none of the collection members is true.
 *
 *     %w{ant bear cat}.none? {|word| word.length == 5}  #=&gt; true
 *     %w{ant bear cat}.none? {|word| word.length &gt;= 4}  #=&gt; false
 *     [].none?                                          #=&gt; true
 *     [nil].none?                                       #=&gt; true
 *     [nil,false].none?                                 #=&gt; true
 */
static VALUE
enum_none(VALUE obj)
{
    VALUE result = Qtrue;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(none), (VALUE)&amp;result);
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="one?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>one?</strong> {|obj| ... }
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes each element of the collection to the given block. The method
returns <tt>true</tt> if the block returns <tt>true</tt> exactly once. If
the block is not given, <tt>one?</tt> will return <tt>true</tt> only if
exactly one of the collection members is true.
</p>
<pre class="code">
   %w{ant bear cat}.one? {|word| word.length == 4}   #=&gt; true
   %w{ant bear cat}.one? {|word| word.length &gt; 4}    #=&gt; false
   %w{ant bear cat}.one? {|word| word.length &lt; 4}    #=&gt; false
   [ nil, true, 99 ].one?                            #=&gt; false
   [ nil, true, false ].one?                         #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.one? [{|obj| block }]   -&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block returns &lt;code&gt;true&lt;/code&gt;
 *  exactly once. If the block is not given, &lt;code&gt;one?&lt;/code&gt; will return
 *  &lt;code&gt;true&lt;/code&gt; only if exactly one of the collection members is
 *  true.
 *
 *     %w{ant bear cat}.one? {|word| word.length == 4}   #=&gt; true
 *     %w{ant bear cat}.one? {|word| word.length &gt; 4}    #=&gt; false
 *     %w{ant bear cat}.one? {|word| word.length &lt; 4}    #=&gt; false
 *     [ nil, true, 99 ].one?                            #=&gt; false
 *     [ nil, true, false ].one?                         #=&gt; true
 *
 */

static VALUE
enum_one(VALUE obj)
{
    VALUE result = Qundef;

    rb_block_call(obj, id_each, 0, 0, ENUMFUNC(one), (VALUE)&amp;result);
    if (result == Qundef) return Qfalse;
    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="partition-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>partition</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>partition</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns two arrays, the first containing the elements of <em>enum</em> for
which the block evaluates to true, the second containing the rest.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..6).partition {|i| (i&amp;1).zero?}   #=&gt; [[2, 4, 6], [1, 3, 5]]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>partition</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.partition {| obj | block }  -&gt; [ true_array, false_array ]
 *     enum.partition                   -&gt; an_enumerator
 *
 *  Returns two arrays, the first containing the elements of
 *  &lt;i&gt;enum&lt;/i&gt; for which the block evaluates to true, the second
 *  containing the rest.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     (1..6).partition {|i| (i&amp;1).zero?}   #=&gt; [[2, 4, 6], [1, 3, 5]]
 *
 */

static VALUE
enum_partition(VALUE obj)
{
    VALUE ary[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    ary[0] = rb_ary_new();
    ary[1] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)ary);

    return rb_assoc_new(ary[0], ary[1]);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reduce-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial, sym) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(sym) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial) {|memo, obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong> {|memo, obj| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
enum.reduce(initial, sym) -> obj
</p>
<pre class="code">
   enum.reduce(sym)          -&gt; obj
   enum.reduce(initial) {| memo, obj | block }  -&gt; obj
   enum.reduce          {| memo, obj | block }  -&gt; obj
</pre>
<p>
Combines all elements of <em>enum</em> by applying a binary operation,
specified by a block or a symbol that names a method or operator.
</p>
<p>
If you specify a block, then for each element in <em>enum<i> the block is
passed an accumulator value (<i>memo</em>) and the element. If you specify
a symbol instead, then each element in the collection will be passed to the
named method of <em>memo</em>. In either case, the result becomes the new
value for <em>memo</em>. At the end of the iteration, the final value of
<em>memo</em> is the return value fo the method.
</p>
<p>
If you do not explicitly specify an <em>initial</em> value for
<em>memo</em>, then uses the first element of collection is used as the
initial value of <em>memo</em>.
</p>
<p>
Examples:
</p>
<pre class="code">
   # Sum some numbers
   (5..10).reduce(:+)                            #=&gt; 45
   # Same using a block and inject
   (5..10).inject {|sum, n| sum + n }            #=&gt; 45
   # Multiply some numbers
   (5..10).reduce(1, :*)                         #=&gt; 151200
   # Same using a block
   (5..10).inject(1) {|product, n| product * n } #=&gt; 151200
   # find the longest word
   longest = %w{ cat sheep bear }.inject do |memo,word|
      memo.length &gt; word.length ? memo : word
   end
   longest                                       #=&gt; &quot;sheep&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial, sym) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(sym) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong>(initial) {|memo, obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>memo</tt>, <tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>inject</strong> {|memo, obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>memo</tt>, <tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.inject(initial, sym) -&gt; obj
 *     enum.inject(sym)          -&gt; obj
 *     enum.inject(initial) {| memo, obj | block }  -&gt; obj
 *     enum.inject          {| memo, obj | block }  -&gt; obj
 *
 *     enum.reduce(initial, sym) -&gt; obj
 *     enum.reduce(sym)          -&gt; obj
 *     enum.reduce(initial) {| memo, obj | block }  -&gt; obj
 *     enum.reduce          {| memo, obj | block }  -&gt; obj
 *
 *  Combines all elements of &lt;i&gt;enum&lt;/i&gt; by applying a binary
 *  operation, specified by a block or a symbol that names a
 *  method or operator.
 *
 *  If you specify a block, then for each element in &lt;i&gt;enum&lt;i&gt;
 *  the block is passed an accumulator value (&lt;i&gt;memo&lt;/i&gt;) and the element.
 *  If you specify a symbol instead, then each element in the collection
 *  will be passed to the named method of &lt;i&gt;memo&lt;/i&gt;.
 *  In either case, the result becomes the new value for &lt;i&gt;memo&lt;/i&gt;.
 *  At the end of the iteration, the final value of &lt;i&gt;memo&lt;/i&gt; is the
 *  return value fo the method.
 *
 *  If you do not explicitly specify an &lt;i&gt;initial&lt;/i&gt; value for &lt;i&gt;memo&lt;/i&gt;,
 *  then uses the first element of collection is used as the initial value
 *  of &lt;i&gt;memo&lt;/i&gt;.
 *
 *  Examples:
 *
 *     # Sum some numbers
 *     (5..10).reduce(:+)                            #=&gt; 45
 *     # Same using a block and inject
 *     (5..10).inject {|sum, n| sum + n }            #=&gt; 45
 *     # Multiply some numbers
 *     (5..10).reduce(1, :*)                         #=&gt; 151200
 *     # Same using a block
 *     (5..10).inject(1) {|product, n| product * n } #=&gt; 151200
 *     # find the longest word
 *     longest = %w{ cat sheep bear }.inject do |memo,word|
 *        memo.length &gt; word.length ? memo : word
 *     end
 *     longest                                       #=&gt; &quot;sheep&quot;
 *
 */
static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo[2];
    VALUE (*iter)(VALUE, VALUE, int, VALUE*) = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
    memo[0] = Qundef;
    break;
      case 1:
    if (rb_block_given_p()) {
        break;
    }
    memo[1] = (VALUE)rb_to_id(memo[0]);
    memo[0] = Qundef;
    iter = inject_op_i;
    break;
      case 2:
    if (rb_block_given_p()) {
        rb_warning(&quot;given block not used&quot;);
    }
    memo[1] = (VALUE)rb_to_id(memo[1]);
    iter = inject_op_i;
    break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reject-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>reject</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reject</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array for all elements of <em>enum</em> for which <em>block</em>
is false (see also <tt>Enumerable#find_all</tt>).
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..10).reject {|i|  i % 3 == 0 }   #=&gt; [1, 2, 4, 5, 7, 8, 10]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>reject</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.reject {| obj | block }  -&gt; array
 *     enum.reject                   -&gt; an_enumerator
 *
 *  Returns an array for all elements of &lt;i&gt;enum&lt;/i&gt; for which
 *  &lt;em&gt;block&lt;/em&gt; is false (see also &lt;code&gt;Enumerable#find_all&lt;/code&gt;).
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     (1..10).reject {|i|  i % 3 == 0 }   #=&gt; [1, 2, 4, 5, 7, 8, 10]
 *
 */

static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reverse_each-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>) <strong>reverse_each</strong>(*args) {|item| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>reverse_each</strong>(*args) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Builds a temporary array and traverses that array in reverse order.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>) <strong>reverse_each</strong>(*args) {|item| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>item</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Enumerator.html" title="Enumerator (class)">Enumerator</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.reverse_each(*args) {|item| block }   -&gt;  enum
 *     enum.reverse_each(*args)                   -&gt;  an_enumerator
 *
 *  Builds a temporary array and traverses that array in reverse order.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 */

static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_ENUMERATOR(obj, argc, argv);

    ary = enum_to_a(argc, argv, obj);

    for (i = RARRAY_LEN(ary); --i &gt;= 0; ) {
    rb_yield(RARRAY_PTR(ary)[i]);
    }

    return obj;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="select-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>find_all</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>select</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>find_all</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>select</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array containing all elements of <em>enum</em> for which
<em>block</em> is not <tt>false</tt> (see also <tt>Enumerable#reject</tt>).
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   (1..10).find_all {|i|  i % 3 == 0 }   #=&gt; [3, 6, 9]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>find_all</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>select</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.find_all {| obj | block }  -&gt; array
 *     enum.select   {| obj | block }  -&gt; array
 *     enum.find_all                   -&gt; an_enumerator
 *     enum.select                     -&gt; an_enumerator
 *
 *  Returns an array containing all elements of &lt;i&gt;enum&lt;/i&gt; for which
 *  &lt;em&gt;block&lt;/em&gt; is not &lt;code&gt;false&lt;/code&gt; (see also
 *  &lt;code&gt;Enumerable#reject&lt;/code&gt;).
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *
 *     (1..10).find_all {|i|  i % 3 == 0 }   #=&gt; [3, 6, 9]
 *
 */

static VALUE
enum_find_all(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, find_all_i, ary);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="slice_before-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>slice_before</strong>(pattern) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>slice_before</strong> {|elt| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>slice_before</strong>(initial_state) {|elt, state| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Creates an enumerator for each chunked elements. The beginnings of chunks
are defined by <em>pattern</em> and the block. If <em>pattern</em> ===
<em>elt</em> returns true or the block returns true for the element, the
element is beginning of a chunk.
</p>
<p>
The === and block is called from the first element to the last element of
<em>enum</em>. The result for the first element is ignored.
</p>
<p>
The result enumerator yields the chunked elements as an array for
<tt>each</tt> method. <tt>each</tt> method can be called as follows.
</p>
<pre class="code">
  enum.slice_before(pattern).each {|ary| ... }
  enum.slice_before {|elt| bool }.each {|ary| ... }
  enum.slice_before(initial_state) {|elt, state| bool }.each {|ary| ... }
</pre>
<p>
Other methods of Enumerator class and Enumerable module, such as map, etc.,
are also usable.
</p>
<p>
For example, iteration over ChangeLog entries can be implemented as
follows.
</p>
<pre class="code">
  # iterate over ChangeLog entries.
  open(&quot;ChangeLog&quot;) {|f|
    f.slice_before(/\A\S/).each {|e| pp e}
  }

  # same as above.  block is used instead of pattern argument.
  open(&quot;ChangeLog&quot;) {|f|
    f.slice_before {|line| /\A\S/ === line }.each {|e| pp e}
  }
</pre>
<p>
&#8220;svn proplist -R&#8221; produces multiline output for each file. They
can be chunked as follows:
</p>
<pre class="code">
  IO.popen([{&quot;LC_ALL&quot;=&gt;&quot;C&quot;}, &quot;svn&quot;, &quot;proplist&quot;, &quot;-R&quot;]) {|f|
    f.lines.slice_before(/\AProp/).each {|lines| p lines }
  }
  #=&gt; [&quot;Properties on '.':\n&quot;, &quot;  svn:ignore\n&quot;, &quot;  svk:merge\n&quot;]
  #   [&quot;Properties on 'goruby.c':\n&quot;, &quot;  svn:eol-style\n&quot;]
  #   [&quot;Properties on 'complex.c':\n&quot;, &quot;  svn:mime-type\n&quot;, &quot;  svn:eol-style\n&quot;]
  #   [&quot;Properties on 'regparse.c':\n&quot;, &quot;  svn:eol-style\n&quot;]
  #   ...
</pre>
<p>
If the block needs to maintain state over multiple elements, local
variables can be used. For example, three or more consecutive increasing
numbers can be squashed as follows:
</p>
<pre class="code">
  a = [0,2,3,4,6,7,9]
  prev = a[0]
  p a.slice_before {|e|
    prev, prev2 = e, prev
    prev2 + 1 != e
  }.map {|es|
    es.length &lt;= 2 ? es.join(&quot;,&quot;) : &quot;#{es.first}-#{es.last}&quot;
  }.join(&quot;,&quot;)
  #=&gt; &quot;0,2-4,6,7,9&quot;
</pre>
<p>
However local variables are not appropriate to maintain state if the result
enumerator is used twice or more. In such case, the last state of the 1st
<tt>each</tt> is used in 2nd <tt>each</tt>. <em>initial_state</em> argument
can be used to avoid this problem. If non-nil value is given as
<em>initial_state</em>, it is duplicated for each &#8220;each&#8221; method
invocation of the enumerator. The duplicated object is passed to 2nd
argument of the block for <tt>slice_before</tt> method.
</p>
<pre class="code">
  # word wrapping.
  # this assumes all characters have same width.
  def wordwrap(words, maxwidth)
    # if cols is a local variable, 2nd &quot;each&quot; may start with non-zero cols.
    words.slice_before(cols: 0) {|w, h|
      h[:cols] += 1 if h[:cols] != 0
      h[:cols] += w.length
      if maxwidth &lt; h[:cols]
        h[:cols] = w.length
        true
      else
        false
      end
    }
  end
  text = (1..20).to_a.join(&quot; &quot;)
  enum = wordwrap(text.split(/\s+/), 10)
  puts &quot;-&quot;*10
  enum.each {|ws| puts ws.join(&quot; &quot;) }
  puts &quot;-&quot;*10
  #=&gt; ----------
  #   1 2 3 4 5
  #   6 7 8 9 10
  #   11 12 13
  #   14 15 16
  #   17 18 19
  #   20
  #   ----------
</pre>
<p>
mbox contains series of mails which start with Unix From line. So each mail
can be extracted by slice before Unix From line.
</p>
<pre class="code">
  # parse mbox
  open(&quot;mbox&quot;) {|f|
    f.slice_before {|line|
      line.start_with? &quot;From &quot;
    }.each {|mail|
      unix_from = mail.shift
      i = mail.index(&quot;\n&quot;)
      header = mail[0...i]
      body = mail[(i+1)..-1]
      body.pop if body.last == &quot;\n&quot;
      fields = header.slice_before {|line| !&quot; \t&quot;.include?(line[0]) }.to_a
      p unix_from
      pp fields
      pp body
    }
  }

  # split mails in mbox (slice before Unix From line after an empty line)
  open(&quot;mbox&quot;) {|f|
    f.slice_before(emp: true) {|line,h|
      prevemp = h[:emp]
      h[:emp] = line == &quot;\n&quot;
      prevemp &amp;&amp; line.start_with?(&quot;From &quot;)
    }.each {|mail|
      mail.pop if mail.last == &quot;\n&quot;
      pp mail
    }
  }</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>slice_before</strong> {|elt| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>elt</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>slice_before</strong>(initial_state) {|elt, state| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>elt</tt>, <tt>state</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.slice_before(pattern)                            -&gt; an_enumerator
 *     enum.slice_before {|elt| bool }                       -&gt; an_enumerator
 *     enum.slice_before(initial_state) {|elt, state| bool } -&gt; an_enumerator
 *
 *  Creates an enumerator for each chunked elements.
 *  The beginnings of chunks are defined by _pattern_ and the block.
 *  If _pattern_ === _elt_ returns true or
 *  the block returns true for the element,
 *  the element is beginning of a chunk.
 *
 *  The === and block is called from the first element to the last element
 *  of _enum_.
 *  The result for the first element is ignored.
 *
 *  The result enumerator yields the chunked elements as an array for +each+
 *  method.
 *  +each+ method can be called as follows.
 *
 *    enum.slice_before(pattern).each {|ary| ... }
 *    enum.slice_before {|elt| bool }.each {|ary| ... }
 *    enum.slice_before(initial_state) {|elt, state| bool }.each {|ary| ... }
 *
 *  Other methods of Enumerator class and Enumerable module,
 *  such as map, etc., are also usable.
 *
 *  For example, iteration over ChangeLog entries can be implemented as
 *  follows.
 *
 *    # iterate over ChangeLog entries.
 *    open(&quot;ChangeLog&quot;) {|f|
 *      f.slice_before(/\A\S/).each {|e| pp e}
 *    }
 *
 *    # same as above.  block is used instead of pattern argument.
 *    open(&quot;ChangeLog&quot;) {|f|
 *      f.slice_before {|line| /\A\S/ === line }.each {|e| pp e}
 *    }
 *
 * &quot;svn proplist -R&quot; produces multiline output for each file.
 * They can be chunked as follows:
 *
 *    IO.popen([{&quot;LC_ALL&quot;=&gt;&quot;C&quot;}, &quot;svn&quot;, &quot;proplist&quot;, &quot;-R&quot;]) {|f|
 *      f.lines.slice_before(/\AProp/).each {|lines| p lines }
 *    }
 *    #=&gt; [&quot;Properties on '.':\n&quot;, &quot;  svn:ignore\n&quot;, &quot;  svk:merge\n&quot;]
 *    #   [&quot;Properties on 'goruby.c':\n&quot;, &quot;  svn:eol-style\n&quot;]
 *    #   [&quot;Properties on 'complex.c':\n&quot;, &quot;  svn:mime-type\n&quot;, &quot;  svn:eol-style\n&quot;]
 *    #   [&quot;Properties on 'regparse.c':\n&quot;, &quot;  svn:eol-style\n&quot;]
 *    #   ...
 *
 *  If the block needs to maintain state over multiple elements,
 *  local variables can be used.
 *  For example, three or more consecutive increasing numbers can be squashed
 *  as follows:
 *
 *    a = [0,2,3,4,6,7,9]
 *    prev = a[0]
 *    p a.slice_before {|e|
 *      prev, prev2 = e, prev
 *      prev2 + 1 != e
 *    }.map {|es|
 *      es.length &lt;= 2 ? es.join(&quot;,&quot;) : &quot;#{es.first}-#{es.last}&quot;
 *    }.join(&quot;,&quot;)
 *    #=&gt; &quot;0,2-4,6,7,9&quot;
 *
 *  However local variables are not appropriate to maintain state
 *  if the result enumerator is used twice or more.
 *  In such case, the last state of the 1st +each+ is used in 2nd +each+.
 *  _initial_state_ argument can be used to avoid this problem.
 *  If non-nil value is given as _initial_state_,
 *  it is duplicated for each &quot;each&quot; method invocation of the enumerator.
 *  The duplicated object is passed to 2nd argument of the block for
 *  +slice_before+ method.
 *
 *    # word wrapping.
 *    # this assumes all characters have same width.
 *    def wordwrap(words, maxwidth)
 *      # if cols is a local variable, 2nd &quot;each&quot; may start with non-zero cols.
 *      words.slice_before(cols: 0) {|w, h|
 *        h[:cols] += 1 if h[:cols] != 0
 *        h[:cols] += w.length
 *        if maxwidth &lt; h[:cols]
 *          h[:cols] = w.length
 *          true
 *        else
 *          false
 *        end
 *      }
 *    end
 *    text = (1..20).to_a.join(&quot; &quot;)
 *    enum = wordwrap(text.split(/\s+/), 10)
 *    puts &quot;-&quot;*10
 *    enum.each {|ws| puts ws.join(&quot; &quot;) }
 *    puts &quot;-&quot;*10
 *    #=&gt; ----------
 *    #   1 2 3 4 5
 *    #   6 7 8 9 10
 *    #   11 12 13
 *    #   14 15 16
 *    #   17 18 19
 *    #   20
 *    #   ----------
 *
 * mbox contains series of mails which start with Unix From line.
 * So each mail can be extracted by slice before Unix From line.
 *
 *    # parse mbox
 *    open(&quot;mbox&quot;) {|f|
 *      f.slice_before {|line|
 *        line.start_with? &quot;From &quot;
 *      }.each {|mail|
 *        unix_from = mail.shift
 *        i = mail.index(&quot;\n&quot;)
 *        header = mail[0...i]
 *        body = mail[(i+1)..-1]
 *        body.pop if body.last == &quot;\n&quot;
 *        fields = header.slice_before {|line| !&quot; \t&quot;.include?(line[0]) }.to_a
 *        p unix_from
 *        pp fields
 *        pp body
 *      }
 *    }
 *
 *    # split mails in mbox (slice before Unix From line after an empty line)
 *    open(&quot;mbox&quot;) {|f|
 *      f.slice_before(emp: true) {|line,h|
 *        prevemp = h[:emp]
 *        h[:emp] = line == &quot;\n&quot;
 *        prevemp &amp;&amp; line.start_with?(&quot;From &quot;)
 *      }.each {|mail|
 *        mail.pop if mail.last == &quot;\n&quot;
 *        pp mail
 *      }
 *    }
 *
 */
static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        VALUE initial_state;
        rb_scan_args(argc, argv, &quot;01&quot;, &amp;initial_state);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pred&quot;), rb_block_proc());
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_initial_state&quot;), initial_state);
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, &quot;1&quot;, &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_sep_pat&quot;), sep_pat);
    }
    rb_ivar_set(enumerator, rb_intern(&quot;slicebefore_enumerable&quot;), enumerable);
    rb_block_call(enumerator, rb_intern(&quot;initialize&quot;), 0, 0, slicebefore_i, enumerator);
    return enumerator;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sort-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>sort</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>sort</strong> {|a, b| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array containing the items in <em>enum</em> sorted, either
according to their own <tt>&lt;=&gt;</tt> method, or by using the results
of the supplied block. The block should return -1, 0, or +1 depending on
the comparison between <em>a</em> and <em>b</em>. As of Ruby 1.8, the
method <tt>Enumerable#sort_by</tt> implements a built-in Schwartzian
Transform, useful when key computation or comparison is expensive.
</p>
<pre class="code">
   %w(rhea kea flea).sort         #=&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]
   (1..10).sort {|a,b| b &lt;=&gt; a}   #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>sort</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>sort</strong> {|a, b| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>a</tt>, <tt>b</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.sort                     -&gt; array
 *     enum.sort {| a, b | block }   -&gt; array
 *
 *  Returns an array containing the items in &lt;i&gt;enum&lt;/i&gt; sorted,
 *  either according to their own &lt;code&gt;&lt;=&gt;&lt;/code&gt; method, or by using
 *  the results of the supplied block. The block should return -1, 0, or
 *  +1 depending on the comparison between &lt;i&gt;a&lt;/i&gt; and &lt;i&gt;b&lt;/i&gt;. As of
 *  Ruby 1.8, the method &lt;code&gt;Enumerable#sort_by&lt;/code&gt; implements a
 *  built-in Schwartzian Transform, useful when key computation or
 *  comparison is expensive.
 *
 *     %w(rhea kea flea).sort         #=&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]
 *     (1..10).sort {|a,b| b &lt;=&gt; a}   #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
 */

static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort(enum_to_a(0, 0, obj));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sort_by-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>sort_by</strong> {|obj| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>sort_by</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sorts <em>enum</em> using a set of keys generated by mapping the values in
<em>enum</em> through the given block.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   %w{ apple pear fig }.sort_by {|word| word.length}
                 #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]
</pre>
<p>
The current implementation of <tt>sort_by</tt> generates an array of tuples
containing the original collection element and the mapped value. This makes
<tt>sort_by</tt> fairly expensive when the keysets are simple
</p>
<pre class="code">
   require 'benchmark'

   a = (1..100000).map {rand(100000)}

   Benchmark.bm(10) do |b|
     b.report(&quot;Sort&quot;)    { a.sort }
     b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   user     system      total        real
   Sort        0.180000   0.000000   0.180000 (  0.175469)
   Sort by     1.980000   0.040000   2.020000 (  2.013586)
</pre>
<p>
However, consider the case where comparing the keys is a non-trivial
operation. The following code sorts some files on modification time using
the basic <tt>sort</tt> method.
</p>
<pre class="code">
   files = Dir[&quot;*&quot;]
   sorted = files.sort {|a,b| File.new(a).mtime &lt;=&gt; File.new(b).mtime}
   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
</pre>
<p>
This sort is inefficient: it generates two new <tt>File</tt> objects during
every comparison. A slightly better technique is to use the
<tt>Kernel#test</tt> method to generate the modification times directly.
</p>
<pre class="code">
   files = Dir[&quot;*&quot;]
   sorted = files.sort { |a,b|
     test(?M, a) &lt;=&gt; test(?M, b)
   }
   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
</pre>
<p>
This still generates many unnecessary <tt>Time</tt> objects. A more
efficient technique is to cache the sort keys (modification times in this
case) before the sort. Perl users often call this approach a Schwartzian
Transform, after Randal Schwartz. We construct a temporary array, where
each element is an array containing our sort key along with the filename.
We sort this array, and then extract the filename from the result.
</p>
<pre class="code">
   sorted = Dir[&quot;*&quot;].collect { |f|
      [test(?M, f), f]
   }.sort.collect { |f| f[1] }
   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
</pre>
<p>
This is exactly what <tt>sort_by</tt> does internally.
</p>
<pre class="code">
   sorted = Dir[&quot;*&quot;].sort_by {|f| test(?M, f)}
   sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>sort_by</strong> {|obj| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>obj</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.sort_by {| obj | block }    -&gt; array
 *     enum.sort_by                     -&gt; an_enumerator
 *
 *  Sorts &lt;i&gt;enum&lt;/i&gt; using a set of keys generated by mapping the
 *  values in &lt;i&gt;enum&lt;/i&gt; through the given block.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     %w{ apple pear fig }.sort_by {|word| word.length}
 *                   #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]
 *
 *  The current implementation of &lt;code&gt;sort_by&lt;/code&gt; generates an
 *  array of tuples containing the original collection element and the
 *  mapped value. This makes &lt;code&gt;sort_by&lt;/code&gt; fairly expensive when
 *  the keysets are simple
 *
 *     require 'benchmark'
 *
 *     a = (1..100000).map {rand(100000)}
 *
 *     Benchmark.bm(10) do |b|
 *       b.report(&quot;Sort&quot;)    { a.sort }
 *       b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     user     system      total        real
 *     Sort        0.180000   0.000000   0.180000 (  0.175469)
 *     Sort by     1.980000   0.040000   2.020000 (  2.013586)
 *
 *  However, consider the case where comparing the keys is a non-trivial
 *  operation. The following code sorts some files on modification time
 *  using the basic &lt;code&gt;sort&lt;/code&gt; method.
 *
 *     files = Dir[&quot;*&quot;]
 *     sorted = files.sort {|a,b| File.new(a).mtime &lt;=&gt; File.new(b).mtime}
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *
 *  This sort is inefficient: it generates two new &lt;code&gt;File&lt;/code&gt;
 *  objects during every comparison. A slightly better technique is to
 *  use the &lt;code&gt;Kernel#test&lt;/code&gt; method to generate the modification
 *  times directly.
 *
 *     files = Dir[&quot;*&quot;]
 *     sorted = files.sort { |a,b|
 *       test(?M, a) &lt;=&gt; test(?M, b)
 *     }
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *
 *  This still generates many unnecessary &lt;code&gt;Time&lt;/code&gt; objects. A
 *  more efficient technique is to cache the sort keys (modification
 *  times in this case) before the sort. Perl users often call this
 *  approach a Schwartzian Transform, after Randal Schwartz. We
 *  construct a temporary array, where each element is an array
 *  containing our sort key along with the filename. We sort this array,
 *  and then extract the filename from the result.
 *
 *     sorted = Dir[&quot;*&quot;].collect { |f|
 *        [test(?M, f), f]
 *     }.sort.collect { |f| f[1] }
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *
 *  This is exactly what &lt;code&gt;sort_by&lt;/code&gt; does internally.
 *
 *     sorted = Dir[&quot;*&quot;].sort_by {|f| test(?M, f)}
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 */

static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_ENUMERATOR(obj, 0, 0);

    if (TYPE(obj) == T_ARRAY) {
    ary  = rb_ary_new2(RARRAY_LEN(obj));
    }
    else {
    ary = rb_ary_new();
    }
    RBASIC(ary)-&gt;klass = 0;
    rb_block_call(obj, id_each, 0, 0, sort_by_i, ary);
    if (RARRAY_LEN(ary) &gt; 1) {
    ruby_qsort(RARRAY_PTR(ary), RARRAY_LEN(ary), sizeof(VALUE),
           sort_by_cmp, (void *)ary);
    }
    if (RBASIC(ary)-&gt;klass) {
    rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
    RARRAY_PTR(ary)[i] = RNODE(RARRAY_PTR(ary)[i])-&gt;u2.value;
    }
    RBASIC(ary)-&gt;klass = rb_cArray;
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="take-instance_method">
  
    - (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>take</strong>(n) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns first n elements from <em>enum</em>.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.take(3)             #=&gt; [1, 2, 3]</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.take(n)               -&gt; array
 *
 *  Returns first n elements from &lt;i&gt;enum&lt;/i&gt;.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take(3)             #=&gt; [1, 2, 3]
 *
 */

static VALUE
enum_take(VALUE obj, VALUE n)
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
    rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    if (len == 0) return rb_ary_new2(0);
    args[0] = rb_ary_new();
    args[1] = len;
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)args);
    return args[0];
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="take_while-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>take_while</strong> {|arr| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>take_while</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes elements to the block until the block returns <tt>nil</tt> or
<tt>false</tt>, then stops iterating and returns an array of all prior
elements.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   a = [1, 2, 3, 4, 5, 0]
   a.take_while {|i| i &lt; 3 }   #=&gt; [1, 2]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>take_while</strong> {|arr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>arr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.take_while {|arr| block }   -&gt; array
 *     enum.take_while                  -&gt; an_enumerator
 *
 *  Passes elements to the block until the block returns +nil+ or +false+,
 *  then stops iterating and returns an array of all prior elements.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take_while {|i| i &lt; 3 }   #=&gt; [1, 2]
 *
 */

static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, (VALUE)&amp;ary);
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_a-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>to_a</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>entries</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an array containing the items in <em>enum</em>.
</p>
<pre class="code">
   (1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
   { 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>to_a</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>entries</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.to_a      -&gt;    array
 *     enum.entries   -&gt;    array
 *
 *  Returns an array containing the items in &lt;i&gt;enum&lt;/i&gt;.
 *
 *     (1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
 *     { 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]
 */
static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);
    OBJ_INFECT(ary, obj);

    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="zip-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>zip</strong>(arg, ...) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>zip</strong>(arg, ...) {|arr| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Takes one element from <em>enum</em> and merges corresponding elements from
each <em>args</em>.  This generates a sequence of <em>n</em>-element
arrays, where <em>n</em> is one more than the count of arguments.  The
length of the resulting sequence will be <tt>enum#size&lt;/code.  If the
size of any argument is less than &lt;code&gt;enum#size</tt>, <tt>nil</tt>
values are supplied. If a block is given, it is invoked for each output
array, otherwise an array of arrays is returned.
</p>
<pre class="code">
   a = [ 4, 5, 6 ]
   b = [ 7, 8, 9 ]

   [1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
   [1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
   a.zip([1,2],[8])       #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>zip</strong>(arg, ...) {|arr| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>arr</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'enum.c'</span>

/*
 *  call-seq:
 *     enum.zip(arg, ...)                   -&gt; an_array_of_array
 *     enum.zip(arg, ...) {|arr| block }    -&gt; nil
 *
 *  Takes one element from &lt;i&gt;enum&lt;/i&gt; and merges corresponding
 *  elements from each &lt;i&gt;args&lt;/i&gt;.  This generates a sequence of
 *  &lt;em&gt;n&lt;/em&gt;-element arrays, where &lt;em&gt;n&lt;/em&gt; is one more than the
 *  count of arguments.  The length of the resulting sequence will be
 *  &lt;code&gt;enum#size&lt;/code.  If the size of any argument is less than
 *  &lt;code&gt;enum#size&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; values are supplied. If
 *  a block is given, it is invoked for each output array, otherwise
 *  an array of arrays is returned.
 *
 *     a = [ 4, 5, 6 ]
 *     b = [ 7, 8, 9 ]
 *
 *     [1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
 *     [1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
 *     a.zip([1,2],[8])       #=&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]
 *
 */

static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    NODE *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
    VALUE ary = rb_check_array_type(argv[i]);
    if (NIL_P(ary)) {
        allary = FALSE;
        break;
    }
    argv[i] = ary;
    }
    if (!allary) {
    CONST_ID(conv, &quot;to_enum&quot;);
    for (i=0; i&lt;argc; i++) {
        argv[i] = rb_funcall(argv[i], conv, 1, ID2SYM(id_each));
    }
    }
    if (!rb_block_given_p()) {
    result = rb_ary_new();
    }
    /* use NODE_DOT2 as memo(v, v, -) */
    memo = rb_node_newnode(NODE_DOT2, result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:05:59 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>