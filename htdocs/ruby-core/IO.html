<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta name="Content-Type" content="text/html; charset=utf-8" />
<title>Class: IO</title>
<link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="_index.html">Index (I)</a> &raquo; 
    
    
    <span class="title">IO</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: IO
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">IO</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
      <dt class="r2">Includes:</dt>
      <dd class="r2"><span class='object_link'><a href="Enumerable.html" title="Enumerable (module)">Enumerable</a></span></dd>
      
    
  
  
  
    <dt class="r1 last">Defined in:</dt>
    <dd class="r1 last">io.c</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
Class <tt>IO</tt> is the basis for all input and output in Ruby. An I/O
stream may be <em>duplexed</em> (that is, bidirectional), and so may use
more than one native operating system stream.
</p>
<p>
Many of the examples in this section use class <tt>File</tt>, the only
standard subclass of <tt>IO</tt>. The two classes are closely associated.
</p>
<p>
As used in this section, <em>portname</em> may take any of the following
forms.
</p>
<ul>
<li><p>
A plain string represents a filename suitable for the underlying operating
system.
</p>
</li>
<li><p>
A string starting with ``<tt>|</tt>&#8217;&#8217; indicates a subprocess.
The remainder of the string following the ``<tt>|</tt>&#8217;&#8217; is
invoked as a process with appropriate input/output channels connected to
it.
</p>
</li>
<li><p>
A string equal to ``<tt>|-</tt>&#8217;&#8217; will create another Ruby
instance as a subprocess.
</p>
</li>
</ul>
<p>
Ruby will convert pathnames between different operating system conventions
if possible. For instance, on a Windows system the filename
``<tt>/gumby/ruby/test.rb</tt>&#8217;&#8217; will be opened as
``<tt>\gumby\ruby\test.rb</tt>&#8217;&#8217;. When specifying a
Windows-style filename in a Ruby string, remember to escape the
backslashes:
</p>
<pre class="code">
   <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>c:\\gumby\\ruby\\test.rb</span><span class='tstring_end'>&quot;</span></span>
</pre>
<p>
Our examples here will use the Unix-style forward slashes;
<tt>File::SEPARATOR</tt> can be used to get the platform-specific separator
character.
</p>
<p>
I/O ports may be opened in any one of several different modes, which are
shown in this section as <em>mode</em>. The mode may either be a Fixnum or
a String. If numeric, it should be one of the operating system specific
constants (O_RDONLY, O_WRONLY, O_RDWR, O_APPEND and so on). See man open(2)
for more information.
</p>
<p>
If the mode is given as a String, it must be one of the values listed in
the following table.
</p>
<pre class="code">
  Mode |  Meaning
  -----+--------------------------------------------------------
  &quot;r&quot;  |  Read-only, starts at beginning of file  (default mode).
  -----+--------------------------------------------------------
  &quot;r+&quot; |  Read-write, starts at beginning of file.
  -----+--------------------------------------------------------
  &quot;w&quot;  |  Write-only, truncates existing file
       |  to zero length or creates a new file for writing.
  -----+--------------------------------------------------------
  &quot;w+&quot; |  Read-write, truncates existing file to zero length
       |  or creates a new file for reading and writing.
  -----+--------------------------------------------------------
  &quot;a&quot;  |  Write-only, starts at end of file if file exists,
       |  otherwise creates a new file for writing.
  -----+--------------------------------------------------------
  &quot;a+&quot; |  Read-write, starts at end of file if file exists,
       |  otherwise creates a new file for reading and
       |  writing.
  -----+--------------------------------------------------------
   &quot;b&quot; |  Binary file mode (may appear with
       |  any of the key letters listed above).
       |  Suppresses EOL &lt;-&gt; CRLF conversion on Windows. And
       |  sets external encoding to ASCII-8BIT unless explicitly
       |  specified.
  -----+--------------------------------------------------------
   &quot;t&quot; |  Text file mode (may appear with
       |  any of the key letters listed above except &quot;b&quot;).
</pre>
<p>
The global constant ARGF (also accessible as $<) provides an IO-like stream
which allows access to all files mentioned on the command line (or STDIN if
no files are mentioned). ARGF provides the methods <tt>#path</tt> and
<tt>#filename</tt> to access the name of the file currently being read.
</p>


  </div>
</div>
<div class="tags">
  
</div><div id="subclasses">
  <h2>Direct Known Subclasses</h2>
  <p class="children"><span class='object_link'><a href="File.html" title="File (class)">File</a></span></p>
</div>


  
  
  
  

  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#binread-class_method" title="binread (class method)">+ (String) <strong>binread</strong>(name, [length [, offset]]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Opens the file, optionally seeks to the given <em>offset</em>, then returns
<em>length</em> bytes (defaulting to the rest of the file).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#copy_stream-class_method" title="copy_stream (class method)">+ (Object) <strong>copy_stream</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
IO.copy_stream copies <em>src</em> to <em>dst</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#for_fd-class_method" title="for_fd (class method)">+ (IO) <strong>for_fd</strong>(fd, mode[, opt]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Synonym for <tt>IO.new</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#foreach-class_method" title="foreach (class method)">+ (Object) <strong>foreach</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Executes the block for every line in the named I/O port, where lines are
separated by <em>sep</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#new-class_method" title="new (class method)">+ (Object) <strong>new</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#open-class_method" title="open (class method)">+ (Object) <strong>open</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
With no associated block, <tt>open</tt> is a synonym for <tt>IO.new</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pipe-class_method" title="pipe (class method)">+ (Object) <strong>pipe</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
IO.pipe(&#8230;) {|read_io, write_io| &#8230; }.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#popen-class_method" title="popen (class method)">+ (Object) <strong>popen</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Runs the specified command as a subprocess; the subprocess&#8217;s standard
input and output will be connected to the returned <tt>IO</tt> object.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read-class_method" title="read (class method)">+ (Object) <strong>read</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Opens the file, optionally seeks to the given <em>offset</em>, then returns
<em>length</em> bytes (defaulting to the rest of the file).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#readlines-class_method" title="readlines (class method)">+ (Object) <strong>readlines</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads the entire file specified by <em>name</em> as individual lines, and
returns those lines in an array.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#select-class_method" title="select (class method)">+ (Object) <strong>select</strong>(read_array) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
[, error_array
</p>
<pre class="code">
             [, timeout]]] )-&gt; array  or  nil
</pre>
<p>
See <tt>Kernel#select</tt>..
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sysopen-class_method" title="sysopen (class method)">+ (Fixnum) <strong>sysopen</strong>(path, [mode, [perm]]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Opens the given path, returning the underlying file descriptor as a
<tt>Fixnum</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_convert-class_method" title="try_convert (class method)">+ (IO<sup>?</sup>) <strong>try_convert</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Try to convert <em>obj</em> into an IO, using to_io method.
</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#%3C%3C-instance_method" title="#&lt;&lt; (instance method)">- (IO) <strong>&lt;&lt;</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
String Output--Writes <em>obj</em> to <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#autoclose%3D-instance_method" title="#autoclose= (instance method)">- (Boolean) <strong>autoclose=</strong>(bool) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets auto-close flag.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#autoclose%3F-instance_method" title="#autoclose? (instance method)">- (Boolean) <strong>autoclose?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if the underlying file descriptor of <em>ios</em>
will be closed automatically at its finalization, otherwise <tt>false</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#binmode-instance_method" title="#binmode (instance method)">- (IO) <strong>binmode</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Puts <em>ios</em> into binary mode.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#binmode%3F-instance_method" title="#binmode? (instance method)">- (Boolean) <strong>binmode?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <em>ios</em> is binmode.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#bytes-instance_method" title="#bytes (instance method)">- (Object) <strong>bytes</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
ios.each_byte {|byte| block }  -> ios.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#chars-instance_method" title="#chars (instance method)">- (Object) <strong>chars</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
ios.each_char {|c| block }  -> ios.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close-instance_method" title="#close (instance method)">- (nil) <strong>close</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Closes <em>ios</em> and flushes any pending writes to the operating system.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_on_exec%3D-instance_method" title="#close_on_exec= (instance method)">- (Boolean) <strong>close_on_exec=</strong>(bool) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets a close-on-exec flag.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_on_exec%3F-instance_method" title="#close_on_exec? (instance method)">- (Boolean) <strong>close_on_exec?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <em>ios</em> will be closed on exec.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_read-instance_method" title="#close_read (instance method)">- (nil) <strong>close_read</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Closes the read end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#close_write-instance_method" title="#close_write (instance method)">- (nil) <strong>close_write</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Closes the write end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#closed%3F-instance_method" title="#closed? (instance method)">- (Boolean) <strong>closed?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <em>ios</em> is completely closed (for duplex
streams, both reader and writer), <tt>false</tt> otherwise.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#codepoints-instance_method" title="#codepoints (instance method)">- (Object) <strong>codepoints</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes the <tt>Integer</tt> ordinal of each character in <em>ios</em>,
passing the codepoint as an argument.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each-instance_method" title="#each (instance method)">- (Object) <strong>each</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
ios.each_line(sep=$/) {|line| block }    -> ios.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_byte-instance_method" title="#each_byte (instance method)">- (Object) <strong>each_byte</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
ios.each_byte {|byte| block }  -> ios.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_char-instance_method" title="#each_char (instance method)">- (Object) <strong>each_char</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
ios.each_char {|c| block }  -> ios.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_codepoint-instance_method" title="#each_codepoint (instance method)">- (Object) <strong>each_codepoint</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Passes the <tt>Integer</tt> ordinal of each character in <em>ios</em>,
passing the codepoint as an argument.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#each_line-instance_method" title="#each_line (instance method)">- (Object) <strong>each_line</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
ios.each_line(sep=$/) {|line| block }    -> ios.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eof-instance_method" title="#eof (instance method)">- (Object) <strong>eof</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true if <em>ios</em> is at end of file that means there are no more
data to read.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eof%3F-instance_method" title="#eof? (instance method)">- (Object) <strong>eof?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns true if <em>ios</em> is at end of file that means there are no more
data to read.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#external_encoding-instance_method" title="#external_encoding (instance method)">- (Encoding) <strong>external_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the Encoding object that represents the encoding of the file.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fcntl-instance_method" title="#fcntl (instance method)">- (Integer) <strong>fcntl</strong>(integer_cmd, arg) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Provides a mechanism for issuing low-level commands to control or query
file-oriented I/O streams.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fdatasync-instance_method" title="#fdatasync (instance method)">- (0<sup>?</sup>) <strong>fdatasync</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Immediately writes all buffered data in <em>ios</em> to disk.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fileno-instance_method" title="#fileno (instance method)">- (Object) <strong>fileno</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns an integer representing the numeric file descriptor for
<em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#flush-instance_method" title="#flush (instance method)">- (IO) <strong>flush</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Flushes any buffered data within <em>ios</em> to the underlying operating
system (note that this is Ruby internal buffering only; the OS may buffer
the data as well).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fsync-instance_method" title="#fsync (instance method)">- (0<sup>?</sup>) <strong>fsync</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Immediately writes all buffered data in <em>ios</em> to disk.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getbyte-instance_method" title="#getbyte (instance method)">- (Fixnum<sup>?</sup>) <strong>getbyte</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Gets the next 8-bit byte (0..255) from <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#getc-instance_method" title="#getc (instance method)">- (String<sup>?</sup>) <strong>getc</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads a one-character string from <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#gets-instance_method" title="#gets (instance method)">- (Object) <strong>gets</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads the next ``line&#8217;&#8217; from the I/O stream; lines are
separated by <em>sep</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#new-instance_method" title="#new (instance method)">- (IO) <strong>new</strong>(fd[, mode][, opt]) </a>
    

    
  </span>
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a new <tt>IO</tt> object (a stream) for the given <tt>IO</tt>
object or integer file descriptor and mode string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize_copy-instance_method" title="#initialize_copy (instance method)">- (Object) <strong>initialize_copy</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
:nodoc:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">- (String) <strong>inspect</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Return a string describing this IO object.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#internal_encoding-instance_method" title="#internal_encoding (instance method)">- (Encoding) <strong>internal_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the Encoding of the internal string if conversion is specified.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ioctl-instance_method" title="#ioctl (instance method)">- (Integer) <strong>ioctl</strong>(integer_cmd, arg) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Provides a mechanism for issuing low-level commands to control or query I/O
devices.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#isatty-instance_method" title="#isatty (instance method)">- (Object) <strong>isatty</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <em>ios</em> is associated with a terminal device
(tty), <tt>false</tt> otherwise.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lineno-instance_method" title="#lineno (instance method)">- (Integer) <strong>lineno</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the current line number in <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lineno%3D-instance_method" title="#lineno= (instance method)">- (Integer) <strong>lineno=</strong>(integer) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Manually sets the current line number to the given value.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#lines-instance_method" title="#lines (instance method)">- (Object) <strong>lines</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
ios.each_line(sep=$/) {|line| block }    -> ios.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pid-instance_method" title="#pid (instance method)">- (Fixnum) <strong>pid</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the process ID of a child process associated with <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pos-instance_method" title="#pos (instance method)">- (Object) <strong>pos</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the current offset (in bytes) of <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#pos%3D-instance_method" title="#pos= (instance method)">- (Integer) <strong>pos=</strong>(integer) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Seeks to the given position (in bytes) in <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#print-instance_method" title="#print (instance method)">- (Object) <strong>print</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Writes the given object(s) to <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#printf-instance_method" title="#printf (instance method)">- (nil) <strong>printf</strong>(format_string[, obj, ...]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Formats and writes to <em>ios</em>, converting parameters under control of
the format string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#putc-instance_method" title="#putc (instance method)">- (Object) <strong>putc</strong>(obj) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
If <em>obj</em> is <tt>Numeric</tt>, write the character whose code is the
least-significant byte of <em>obj</em>, otherwise write the first byte of
the string representation of <em>obj</em> to <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#puts-instance_method" title="#puts (instance method)">- (nil) <strong>puts</strong>(obj, ...) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Writes the given objects to <em>ios</em> as with <tt>IO#print</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read-instance_method" title="#read (instance method)">- (String<sup>?</sup>) <strong>read</strong>([length [, buffer]]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads <em>length</em> bytes from the I/O stream.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_nonblock-instance_method" title="#read_nonblock (instance method)">- (Object) <strong>read_nonblock</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads at most <em>maxlen</em> bytes from <em>ios</em> using the read(2)
system call after O_NONBLOCK is set for the underlying file descriptor.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#readbyte-instance_method" title="#readbyte (instance method)">- (Fixnum) <strong>readbyte</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads a byte as with <tt>IO#getbyte</tt>, but raises an <tt>EOFError</tt>
on end of file.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#readchar-instance_method" title="#readchar (instance method)">- (String) <strong>readchar</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads a one-character string from <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#readline-instance_method" title="#readline (instance method)">- (Object) <strong>readline</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads a line as with <tt>IO#gets</tt>, but raises an <tt>EOFError</tt> on
end of file.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#readlines-instance_method" title="#readlines (instance method)">- (Object) <strong>readlines</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads all of the lines in <em>ios</em>, and returns them in
<em>anArray</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#readpartial-instance_method" title="#readpartial (instance method)">- (Object) <strong>readpartial</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads at most <em>maxlen</em> bytes from the I/O stream.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#reopen-instance_method" title="#reopen (instance method)">- (Object) <strong>reopen</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reassociates <em>ios</em> with the I/O stream given in <em>other_IO</em> or
to a new stream opened on <em>path</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#rewind-instance_method" title="#rewind (instance method)">- (0) <strong>rewind</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Positions <em>ios</em> to the beginning of input, resetting <tt>lineno</tt>
to zero.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#seek-instance_method" title="#seek (instance method)">- (0) <strong>seek</strong>(amount, whence = IO::SEEK_SET) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Seeks to a given offset <em>anInteger</em> in the stream according to the
value of <em>whence</em>:.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#set_encoding-instance_method" title="#set_encoding (instance method)">- (Object) <strong>set_encoding</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
If single argument is specified, read string from io is tagged with the
encoding specified.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#stat-instance_method" title="#stat (instance method)">- (Object) <strong>stat</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns status information for <em>ios</em> as an object of type
<tt>File::Stat</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sync-instance_method" title="#sync (instance method)">- (Boolean) <strong>sync</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the current ``sync mode&#8217;&#8217; of <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sync%3D-instance_method" title="#sync= (instance method)">- (Boolean) <strong>sync=</strong>(boolean) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Sets the ``sync mode&#8217;&#8217; to <tt>true</tt> or <tt>false</tt>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sysread-instance_method" title="#sysread (instance method)">- (String) <strong>sysread</strong>(integer[, outbuf]) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads <em>integer</em> bytes from <em>ios</em> using a low-level read and
returns them as a string.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#sysseek-instance_method" title="#sysseek (instance method)">- (Integer) <strong>sysseek</strong>(offset, whence = IO::SEEK_SET) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Seeks to a given <em>offset</em> in the stream according to the value of
<em>whence</em> (see <tt>IO#seek</tt> for values of <em>whence</em>).
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#syswrite-instance_method" title="#syswrite (instance method)">- (Integer) <strong>syswrite</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Writes the given string to <em>ios</em> using a low-level write.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tell-instance_method" title="#tell (instance method)">- (Object) <strong>tell</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns the current offset (in bytes) of <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_io-instance_method" title="#to_io (instance method)">- (IO) <strong>to_io</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#tty%3F-instance_method" title="#tty? (instance method)">- (Object) <strong>tty?</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns <tt>true</tt> if <em>ios</em> is associated with a terminal device
(tty), <tt>false</tt> otherwise.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ungetbyte-instance_method" title="#ungetbyte (instance method)">- (Object) <strong>ungetbyte</strong> </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Pushes back bytes (passed as a parameter) onto <em>ios</em>, such that a
subsequent buffered read will return it.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#ungetc-instance_method" title="#ungetc (instance method)">- (nil) <strong>ungetc</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Pushes back one character (passed as a parameter) onto <em>ios</em>, such
that a subsequent buffered character read will return it.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write-instance_method" title="#write (instance method)">- (Integer) <strong>write</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Writes the given string to <em>ios</em>.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#write_nonblock-instance_method" title="#write_nonblock (instance method)">- (Integer) <strong>write_nonblock</strong>(string) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Writes the given string to <em>ios</em> using the write(2) system call
after O_NONBLOCK is set for the underlying file descriptor.
</p>
</div></span>
  
</li>

      
    </ul>
  


  
  
  
  
  
  
  
  <h3 class="inherited">Methods included from <span class='object_link'><a href="Enumerable.html" title="Enumerable (module)">Enumerable</a></span></h3>
  <p class="inherited"><span class='object_link'><a href="Enumerable.html#all%3F-instance_method" title="Enumerable#all? (method)">#all?</a></span>, <span class='object_link'><a href="Enumerable.html#any%3F-instance_method" title="Enumerable#any? (method)">#any?</a></span>, <span class='object_link'><a href="Enumerable.html#chunk-instance_method" title="Enumerable#chunk (method)">#chunk</a></span>, <span class='object_link'><a href="Enumerable.html#collect-instance_method" title="Enumerable#collect (method)">#collect</a></span>, <span class='object_link'><a href="Enumerable.html#collect_concat-instance_method" title="Enumerable#collect_concat (method)">#collect_concat</a></span>, <span class='object_link'><a href="Enumerable.html#count-instance_method" title="Enumerable#count (method)">#count</a></span>, <span class='object_link'><a href="Enumerable.html#cycle-instance_method" title="Enumerable#cycle (method)">#cycle</a></span>, <span class='object_link'><a href="Enumerable.html#detect-instance_method" title="Enumerable#detect (method)">#detect</a></span>, <span class='object_link'><a href="Enumerable.html#drop-instance_method" title="Enumerable#drop (method)">#drop</a></span>, <span class='object_link'><a href="Enumerable.html#drop_while-instance_method" title="Enumerable#drop_while (method)">#drop_while</a></span>, <span class='object_link'><a href="Enumerable.html#each_cons-instance_method" title="Enumerable#each_cons (method)">#each_cons</a></span>, <span class='object_link'><a href="Enumerable.html#each_entry-instance_method" title="Enumerable#each_entry (method)">#each_entry</a></span>, <span class='object_link'><a href="Enumerable.html#each_slice-instance_method" title="Enumerable#each_slice (method)">#each_slice</a></span>, <span class='object_link'><a href="Enumerable.html#each_with_index-instance_method" title="Enumerable#each_with_index (method)">#each_with_index</a></span>, <span class='object_link'><a href="Enumerable.html#each_with_object-instance_method" title="Enumerable#each_with_object (method)">#each_with_object</a></span>, <span class='object_link'><a href="Enumerable.html#entries-instance_method" title="Enumerable#entries (method)">#entries</a></span>, <span class='object_link'><a href="Enumerable.html#find-instance_method" title="Enumerable#find (method)">#find</a></span>, <span class='object_link'><a href="Enumerable.html#find_all-instance_method" title="Enumerable#find_all (method)">#find_all</a></span>, <span class='object_link'><a href="Enumerable.html#find_index-instance_method" title="Enumerable#find_index (method)">#find_index</a></span>, <span class='object_link'><a href="Enumerable.html#first-instance_method" title="Enumerable#first (method)">#first</a></span>, <span class='object_link'><a href="Enumerable.html#flat_map-instance_method" title="Enumerable#flat_map (method)">#flat_map</a></span>, <span class='object_link'><a href="Enumerable.html#grep-instance_method" title="Enumerable#grep (method)">#grep</a></span>, <span class='object_link'><a href="Enumerable.html#group_by-instance_method" title="Enumerable#group_by (method)">#group_by</a></span>, <span class='object_link'><a href="Enumerable.html#include%3F-instance_method" title="Enumerable#include? (method)">#include?</a></span>, <span class='object_link'><a href="Enumerable.html#inject-instance_method" title="Enumerable#inject (method)">#inject</a></span>, <span class='object_link'><a href="Enumerable.html#map-instance_method" title="Enumerable#map (method)">#map</a></span>, <span class='object_link'><a href="Enumerable.html#max-instance_method" title="Enumerable#max (method)">#max</a></span>, <span class='object_link'><a href="Enumerable.html#max_by-instance_method" title="Enumerable#max_by (method)">#max_by</a></span>, <span class='object_link'><a href="Enumerable.html#member%3F-instance_method" title="Enumerable#member? (method)">#member?</a></span>, <span class='object_link'><a href="Enumerable.html#min-instance_method" title="Enumerable#min (method)">#min</a></span>, <span class='object_link'><a href="Enumerable.html#min_by-instance_method" title="Enumerable#min_by (method)">#min_by</a></span>, <span class='object_link'><a href="Enumerable.html#minmax-instance_method" title="Enumerable#minmax (method)">#minmax</a></span>, <span class='object_link'><a href="Enumerable.html#minmax_by-instance_method" title="Enumerable#minmax_by (method)">#minmax_by</a></span>, <span class='object_link'><a href="Enumerable.html#none%3F-instance_method" title="Enumerable#none? (method)">#none?</a></span>, <span class='object_link'><a href="Enumerable.html#one%3F-instance_method" title="Enumerable#one? (method)">#one?</a></span>, <span class='object_link'><a href="Enumerable.html#partition-instance_method" title="Enumerable#partition (method)">#partition</a></span>, <span class='object_link'><a href="Enumerable.html#reduce-instance_method" title="Enumerable#reduce (method)">#reduce</a></span>, <span class='object_link'><a href="Enumerable.html#reject-instance_method" title="Enumerable#reject (method)">#reject</a></span>, <span class='object_link'><a href="Enumerable.html#reverse_each-instance_method" title="Enumerable#reverse_each (method)">#reverse_each</a></span>, <span class='object_link'><a href="Enumerable.html#select-instance_method" title="Enumerable#select (method)">#select</a></span>, <span class='object_link'><a href="Enumerable.html#slice_before-instance_method" title="Enumerable#slice_before (method)">#slice_before</a></span>, <span class='object_link'><a href="Enumerable.html#sort-instance_method" title="Enumerable#sort (method)">#sort</a></span>, <span class='object_link'><a href="Enumerable.html#sort_by-instance_method" title="Enumerable#sort_by (method)">#sort_by</a></span>, <span class='object_link'><a href="Enumerable.html#take-instance_method" title="Enumerable#take (method)">#take</a></span>, <span class='object_link'><a href="Enumerable.html#take_while-instance_method" title="Enumerable#take_while (method)">#take_while</a></span>, <span class='object_link'><a href="Enumerable.html#to_a-instance_method" title="Enumerable#to_a (method)">#to_a</a></span>, <span class='object_link'><a href="Enumerable.html#zip-instance_method" title="Enumerable#zip (method)">#zip</a></span></p>
<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <p class="signature first" id="initialize-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>new</strong>(fd[, mode][, opt]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a new <tt>IO</tt> object (a stream) for the given <tt>IO</tt>
object or integer file descriptor and mode string. See also
<tt>IO.sysopen</tt> and <tt>IO.for_fd</tt>.
</p>
<h3>Parameters</h3>
<table>
<tr><td valign="top">fd</td><td><p>
numeric file descriptor
</p>
</td></tr>
<tr><td valign="top">mode</td><td><p>
file mode. a string or an integer
</p>
</td></tr>
<tr><td valign="top">opt</td><td><p>
hash for specifying mode by name.
</p>
</td></tr>
</table>
<h4>Mode</h4>
<p>
When <tt>mode</tt> is an integer it must be combination of the modes
defined in <tt>File::Constants</tt>.
</p>
<p>
When <tt>mode</tt> is a string it must be in one of the following forms:
</p>
<ul>
<li><p>
&#8220;fmode&#8221;,
</p>
</li>
<li><p>
&#8220;fmode:extern&#8221;,
</p>
</li>
<li><p>
&#8220;fmode:extern:intern&#8221;.
</p>
</li>
</ul>
<p>
<tt>extern</tt> is the external encoding name for the IO. <tt>intern</tt>
is the internal encoding. <tt>fmode</tt> must be combination of the
directives. See the description of class <tt>IO</tt> for a description of
the directives.
</p>
<p>
When the mode of original IO is read only, the mode cannot be changed to be
writable.  Similarly, the mode cannot be changed from write only to
readable. If such a wrong change is directed, timing where the error
actually occurs is different according to the platform.
</p>
<h4>Options</h4>
<p>
<tt>opt</tt> can have the following keys
</p>
<table>
<tr><td valign="top">:mode </td><td><p>
same as <tt>mode</tt> parameter
</p>
</td></tr>
<tr><td valign="top">:external_encoding </td><td><p>
external encoding for the IO. &#8220;-&#8221; is a synonym for the default
external encoding.
</p>
</td></tr>
<tr><td valign="top">:internal_encoding </td><td><p>
internal encoding for the IO. &#8220;-&#8221; is a synonym for the default
internal encoding. If the value is nil no conversion occurs.
</p>
</td></tr>
<tr><td valign="top">:encoding </td><td><p>
specifies external and internal encodings as &#8220;extern:intern&#8221;.
</p>
</td></tr>
<tr><td valign="top">:textmode </td><td><p>
If the value is truth value, same as &#8220;t&#8221; in argument
<tt>mode</tt>.
</p>
</td></tr>
<tr><td valign="top">:binmode </td><td><p>
If the value is truth value, same as &#8220;b&#8221; in argument
<tt>mode</tt>.
</p>
</td></tr>
<tr><td valign="top">:autoclose </td><td><p>
If the value is <tt>false</tt>, the <em>fd</em> will be kept open after
this <tt>IO</tt> instance gets finalized.
</p>
</td></tr>
</table>
<p>
Also <tt>opt</tt> can have same keys in <tt>String#encode</tt> for
controlling conversion between the external encoding and the internal
encoding.
</p>
<h3>Example1</h3>
<pre class="code">
   fd = IO.sysopen(&quot;/dev/tty&quot;, &quot;w&quot;)
   a = IO.new(fd,&quot;w&quot;)
   $stderr.puts &quot;Hello&quot;
   a.puts &quot;World&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   Hello
   World
</pre>
<h3>Example2</h3>
<pre class="code">
   require 'fcntl'

   fd = STDERR.fcntl(Fcntl::F_DUPFD)
   io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)
   io.puts &quot;Hello, World!&quot;

   fd = STDERR.fcntl(Fcntl::F_DUPFD)
   io = IO.new(fd, mode: 'w', cr_newline: true, external_encoding: Encoding::UTF_16LE)
   io.puts &quot;Hello, World!&quot;
</pre>
<p>
both of above print &#8220;Hello, World!&#8221; in UTF-16LE to standard
error output with converting EOL generated by <tt>puts</tt> to CR.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.new(fd [, mode] [, opt])   -&gt; io
 *
 *  Returns a new &lt;code&gt;IO&lt;/code&gt; object (a stream) for the given
 *  &lt;code&gt;IO&lt;/code&gt; object or integer file descriptor and mode
 *  string. See also &lt;code&gt;IO.sysopen&lt;/code&gt; and
 *  &lt;code&gt;IO.for_fd&lt;/code&gt;.
 *
 *  === Parameters
 *  fd:: numeric file descriptor
 *  mode:: file mode. a string or an integer
 *  opt:: hash for specifying mode by name.
 *
 *  ==== Mode
 *  When &lt;code&gt;mode&lt;/code&gt; is an integer it must be combination of
 *  the modes defined in &lt;code&gt;File::Constants&lt;/code&gt;.
 *
 *  When &lt;code&gt;mode&lt;/code&gt; is a string it must be in one of the
 *  following forms:
 *  - &quot;fmode&quot;,
 *  - &quot;fmode:extern&quot;,
 *  - &quot;fmode:extern:intern&quot;.
 *  &lt;code&gt;extern&lt;/code&gt; is the external encoding name for the IO.
 *  &lt;code&gt;intern&lt;/code&gt; is the internal encoding.
 *  &lt;code&gt;fmode&lt;/code&gt; must be combination of the directives. See
 *  the description of class +IO+ for a description of the directives.
 *
 *  When the mode of original IO is read only, the mode cannot be changed to
 *  be writable.  Similarly, the mode cannot be changed from write only to
 *  readable.
 *  If such a wrong change is directed, timing where the error actually occurs
 *  is different according to the platform.
 *
 *  ==== Options
 *  &lt;code&gt;opt&lt;/code&gt; can have the following keys
 *  :mode ::
 *    same as &lt;code&gt;mode&lt;/code&gt; parameter
 *  :external_encoding ::
 *    external encoding for the IO. &quot;-&quot; is a
 *    synonym for the default external encoding.
 *  :internal_encoding ::
 *    internal encoding for the IO.
 *    &quot;-&quot; is a synonym for the default internal encoding.
 *    If the value is nil no conversion occurs.
 *  :encoding ::
 *    specifies external and internal encodings as &quot;extern:intern&quot;.
 *  :textmode ::
 *    If the value is truth value, same as &quot;t&quot; in argument &lt;code&gt;mode&lt;/code&gt;.
 *  :binmode ::
 *    If the value is truth value, same as &quot;b&quot; in argument &lt;code&gt;mode&lt;/code&gt;.
 *  :autoclose ::
 *    If the value is +false+, the _fd_ will be kept open after this
 *    +IO+ instance gets finalized.
 *
 *  Also &lt;code&gt;opt&lt;/code&gt; can have same keys in &lt;code&gt;String#encode&lt;/code&gt; for
 *  controlling conversion between the external encoding and the internal encoding.
 *
 *  === Example1
 *
 *     fd = IO.sysopen(&quot;/dev/tty&quot;, &quot;w&quot;)
 *     a = IO.new(fd,&quot;w&quot;)
 *     $stderr.puts &quot;Hello&quot;
 *     a.puts &quot;World&quot;
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Hello
 *     World
 *
 *  === Example2
 *
 *     require 'fcntl'
 *
 *     fd = STDERR.fcntl(Fcntl::F_DUPFD)
 *     io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)
 *     io.puts &quot;Hello, World!&quot;
 *
 *     fd = STDERR.fcntl(Fcntl::F_DUPFD)
 *     io = IO.new(fd, mode: 'w', cr_newline: true, external_encoding: Encoding::UTF_16LE)
 *     io.puts &quot;Hello, World!&quot;
 *
 *  both of above print &quot;Hello, World!&quot; in UTF-16LE to standard error output with
 *  converting EOL generated by &lt;code&gt;puts&lt;/code&gt; to CR.
 */

static VALUE
rb_io_initialize(int argc, VALUE *argv, VALUE io)
{
    VALUE fnum, vmode;
    rb_io_t *fp;
    int fd, fmode, oflags = O_RDONLY;
    convconfig_t convconfig;
    VALUE opt;
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    int ofmode;
#else
    struct stat st;
#endif

    rb_secure(4);

    opt = pop_last_hash(&amp;argc, argv);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;fnum, &amp;vmode);
    rb_io_extract_modeenc(&amp;vmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);

    fd = NUM2INT(fnum);
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    oflags = fcntl(fd, F_GETFL);
    if (oflags == -1) rb_sys_fail(0);
#else
    if (fstat(fd, &amp;st) == -1) rb_sys_fail(0);
#endif
    UPDATE_MAXFD(fd);
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
    ofmode = rb_io_oflags_fmode(oflags);
    if (NIL_P(vmode)) {
    fmode = ofmode;
    }
    else if ((~ofmode &amp; fmode) &amp; FMODE_READWRITE) {
    VALUE error = INT2FIX(EINVAL);
    rb_exc_raise(rb_class_new_instance(1, &amp;error, rb_eSystemCallError));
    }
#endif
    if (!NIL_P(opt) &amp;&amp; rb_hash_aref(opt, sym_autoclose) == Qfalse) {
    fmode |= FMODE_PREP;
    }
    MakeOpenFile(io, fp);
    fp-&gt;fd = fd;
    fp-&gt;mode = fmode;
    fp-&gt;encs = convconfig;
    clear_codeconv(fp);
    io_check_tty(fp);
    if (fileno(stdin) == fd)
    fp-&gt;stdio_file = stdin;
    else if (fileno(stdout) == fd)
    fp-&gt;stdio_file = stdout;
    else if (fileno(stderr) == fd)
    fp-&gt;stdio_file = stderr;

    if (fmode &amp; FMODE_SETENC_BY_BOM) io_set_encoding_by_bom(io);
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="binread-class_method">
  
    + (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>binread</strong>(name, [length [, offset]]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Opens the file, optionally seeks to the given <em>offset</em>, then returns
<em>length</em> bytes (defaulting to the rest of the file).
<tt>binread</tt> ensures the file is closed before returning. The open mode
would be &#8220;rb:ASCII-8BIT&#8221;.
</p>
<pre class="code">
   IO.binread(&quot;testfile&quot;)           #=&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;
   IO.binread(&quot;testfile&quot;, 20)       #=&gt; &quot;This is line one\nThi&quot;
   IO.binread(&quot;testfile&quot;, 20, 10)   #=&gt; &quot;ne one\nThis is line &quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.binread(name, [length [, offset]] )   -&gt; string
 *
 *  Opens the file, optionally seeks to the given &lt;i&gt;offset&lt;/i&gt;, then returns
 *  &lt;i&gt;length&lt;/i&gt; bytes (defaulting to the rest of the file).
 *  &lt;code&gt;binread&lt;/code&gt; ensures the file is closed before returning.
 *  The open mode would be &quot;rb:ASCII-8BIT&quot;.
 *
 *     IO.binread(&quot;testfile&quot;)           #=&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;
 *     IO.binread(&quot;testfile&quot;, 20)       #=&gt; &quot;This is line one\nThi&quot;
 *     IO.binread(&quot;testfile&quot;, 20, 10)   #=&gt; &quot;ne one\nThis is line &quot;
 */

static VALUE
rb_io_s_binread(int argc, VALUE *argv, VALUE io)
{
    VALUE offset;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, &quot;12&quot;, NULL, NULL, &amp;offset);
    FilePathValue(argv[0]);
    arg.io = rb_io_open(argv[0], rb_str_new_cstr(&quot;rb:ASCII-8BIT&quot;), Qnil, Qnil);
    if (NIL_P(arg.io)) return Qnil;
    arg.argv = argv+1;
    arg.argc = (argc &gt; 1) ? 1 : 0;
    if (!NIL_P(offset)) {
    rb_io_seek(arg.io, offset, SEEK_SET);
    }
    return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="copy_stream-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>copy_stream</strong>(src, dst) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>copy_stream</strong>(src, dst, copy_length) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>copy_stream</strong>(src, dst, copy_length, src_offset) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
IO.copy_stream copies <em>src</em> to <em>dst</em>. <em>src</em> and
<em>dst</em> is either a filename or an IO.
</p>
<p>
This method returns the number of bytes copied.
</p>
<p>
If optional arguments are not given, the start position of the copy is the
beginning of the filename or the current file offset of the IO. The end
position of the copy is the end of file.
</p>
<p>
If <em>copy_length</em> is given, No more than <em>copy_length</em> bytes
are copied.
</p>
<p>
If <em>src_offset</em> is given, it specifies the start position of the
copy.
</p>
<p>
When <em>src_offset</em> is specified and <em>src</em> is an IO,
IO.copy_stream doesn&#8217;t move the current file offset.
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.copy_stream(src, dst)
 *     IO.copy_stream(src, dst, copy_length)
 *     IO.copy_stream(src, dst, copy_length, src_offset)
 *
 *  IO.copy_stream copies &lt;i&gt;src&lt;/i&gt; to &lt;i&gt;dst&lt;/i&gt;.
 *  &lt;i&gt;src&lt;/i&gt; and &lt;i&gt;dst&lt;/i&gt; is either a filename or an IO.
 *
 *  This method returns the number of bytes copied.
 *
 *  If optional arguments are not given,
 *  the start position of the copy is
 *  the beginning of the filename or
 *  the current file offset of the IO.
 *  The end position of the copy is the end of file.
 *
 *  If &lt;i&gt;copy_length&lt;/i&gt; is given,
 *  No more than &lt;i&gt;copy_length&lt;/i&gt; bytes are copied.
 *
 *  If &lt;i&gt;src_offset&lt;/i&gt; is given,
 *  it specifies the start position of the copy.
 *
 *  When &lt;i&gt;src_offset&lt;/i&gt; is specified and
 *  &lt;i&gt;src&lt;/i&gt; is an IO,
 *  IO.copy_stream doesn't move the current file offset.
 *
 */
static VALUE
rb_io_s_copy_stream(int argc, VALUE *argv, VALUE io)
{
    VALUE src, dst, length, src_offset;
    struct copy_stream_struct st;

    MEMZERO(&amp;st, struct copy_stream_struct, 1);

    rb_scan_args(argc, argv, &quot;22&quot;, &amp;src, &amp;dst, &amp;length, &amp;src_offset);

    st.src = src;
    st.dst = dst;

    if (NIL_P(length))
        st.copy_length = (off_t)-1;
    else
        st.copy_length = NUM2OFFT(length);

    if (NIL_P(src_offset))
        st.src_offset = (off_t)-1;
    else
        st.src_offset = NUM2OFFT(src_offset);

    rb_ensure(copy_stream_body, (VALUE)&amp;st, copy_stream_finalize, (VALUE)&amp;st);

    return OFFT2NUM(st.total);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="for_fd-class_method">
  
    + (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>for_fd</strong>(fd, mode[, opt]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Synonym for <tt>IO.new</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.for_fd(fd, mode [, opt])    -&gt; io
 *
 *  Synonym for &lt;code&gt;IO.new&lt;/code&gt;.
 *
 */

static VALUE
rb_io_s_for_fd(int argc, VALUE *argv, VALUE klass)
{
    VALUE io = rb_obj_alloc(klass);
    rb_io_initialize(argc, argv, io);
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="foreach-class_method">
  
    
      <span class="overload">+ (<tt>nil</tt>) <strong>foreach</strong>(name, sep = $/[, open_args]) {|line| ... }</span>
    
      <span class="overload">+ (<tt>nil</tt>) <strong>foreach</strong>(name, limit[, open_args]) {|line| ... }</span>
    
      <span class="overload">+ (<tt>nil</tt>) <strong>foreach</strong>(name, sep, limit[, open_args]) {|line| ... }</span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>foreach</strong>(...) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Executes the block for every line in the named I/O port, where lines are
separated by <em>sep</em>.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   IO.foreach(&quot;testfile&quot;) {|x| print &quot;GOT &quot;, x }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   GOT This is line one
   GOT This is line two
   GOT This is line three
   GOT And so on...
</pre>
<p>
If the last argument is a hash, it&#8217;s the keyword argument to open.
See <tt>IO.read</tt> for detail.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt>nil</tt>) <strong>foreach</strong>(name, sep = $/[, open_args]) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt>nil</tt>) <strong>foreach</strong>(name, limit[, open_args]) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt>nil</tt>) <strong>foreach</strong>(name, sep, limit[, open_args]) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.foreach(name, sep=$/ [, open_args]) {|line| block }     -&gt; nil
 *     IO.foreach(name, limit [, open_args]) {|line| block }      -&gt; nil
 *     IO.foreach(name, sep, limit [, open_args]) {|line| block } -&gt; nil
 *     IO.foreach(...)                                            -&gt; an_enumerator
 *
 *  Executes the block for every line in the named I/O port, where lines
 *  are separated by &lt;em&gt;sep&lt;/em&gt;.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     IO.foreach(&quot;testfile&quot;) {|x| print &quot;GOT &quot;, x }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     GOT This is line one
 *     GOT This is line two
 *     GOT This is line three
 *     GOT And so on...
 *
 *  If the last argument is a hash, it's the keyword argument to open.
 *  See &lt;code&gt;IO.read&lt;/code&gt; for detail.
 *
 */

static VALUE
rb_io_s_foreach(int argc, VALUE *argv, VALUE self)
{
    struct foreach_arg arg;

    rb_scan_args(argc, argv, &quot;13&quot;, NULL, NULL, NULL, NULL);
    RETURN_ENUMERATOR(self, argc, argv);
    open_key_args(argc, argv, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    return rb_ensure(io_s_foreach, (VALUE)&amp;arg, rb_io_close, arg.io);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="new-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>new</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/* :nodoc: */
static VALUE
rb_io_s_new(int argc, VALUE *argv, VALUE klass)
{
    if (rb_block_given_p()) {
    const char *cname = rb_class2name(klass);

    rb_warn(&quot;%s::new() does not take block; use %s::open() instead&quot;,
        cname, cname);
    }
    return rb_class_new_instance(argc, argv, klass);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="open-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>open</strong>(fd, mode_string = &quot;r&quot;[, opt]) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>open</strong>(fd, mode_string = &quot;r&quot;[, opt]) {|io| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
With no associated block, <tt>open</tt> is a synonym for <tt>IO.new</tt>.
If the optional code block is given, it will be passed <em>io</em> as an
argument, and the IO object will automatically be closed when the block
terminates. In this instance, <tt>IO.open</tt> returns the value of the
block.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>open</strong>(fd, mode_string = &quot;r&quot;[, opt]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>open</strong>(fd, mode_string = &quot;r&quot;[, opt]) {|io| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>io</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  Document-method: IO::open
 *
 *  call-seq:
 *     IO.open(fd, mode_string=&quot;r&quot; [, opt] )               -&gt; io
 *     IO.open(fd, mode_string=&quot;r&quot; [, opt] ) {|io| block } -&gt; obj
 *
 *  With no associated block, &lt;code&gt;open&lt;/code&gt; is a synonym for
 *  &lt;code&gt;IO.new&lt;/code&gt;. If the optional code block is given, it will
 *  be passed &lt;i&gt;io&lt;/i&gt; as an argument, and the IO object will
 *  automatically be closed when the block terminates. In this instance,
 *  &lt;code&gt;IO.open&lt;/code&gt; returns the value of the block.
 *
 */

static VALUE
rb_io_s_open(int argc, VALUE *argv, VALUE klass)
{
    VALUE io = rb_class_new_instance(argc, argv, klass);

    if (rb_block_given_p()) {
    return rb_ensure(rb_yield, io, io_close, io);
    }

    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pipe-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong> </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong>(ext_enc) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong>(&quot;ext_enc:int_enc&quot;[, opt]) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong>(ext_enc, int_enc[, opt]) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
IO.pipe(&#8230;) {|read_io, write_io| &#8230; }
</p>
<p>
Creates a pair of pipe endpoints (connected to each other) and returns them
as a two-element array of <tt>IO</tt> objects: <tt>[</tt> <em>read_io</em>,
<em>write_io</em> <tt>]</tt>.
</p>
<p>
If a block is given, the block is called and returns the value of the
block. <em>read_io</em> and <em>write_io</em> are sent to the block as
arguments. If read_io and write_io are not closed when the block exits,
they are closed. i.e. closing read_io and/or write_io doesn&#8217;t cause
an error.
</p>
<p>
Not available on all platforms.
</p>
<p>
If an encoding (encoding name or encoding object) is specified as an
optional argument, read string from pipe is tagged with the encoding
specified. If the argument is a colon separated two encoding names
&#8220;A:B&#8221;, the read string is converted from encoding A (external
encoding) to encoding B (internal encoding), then tagged with B. If two
optional arguments are specified, those must be encoding objects or
encoding names, and the first one is the external encoding, and the second
one is the internal encoding. If the external encoding and the internal
encoding is specified, optional hash argument specify the conversion
option.
</p>
<p>
In the example below, the two processes close the ends of the pipe that
they are not using. This is not just a cosmetic nicety. The read end of a
pipe will not generate an end of file condition if there are any writers
with the pipe still open. In the case of the parent process, the
<tt>rd.read</tt> will never return if it does not first issue a
<tt>wr.close</tt>.
</p>
<pre class="code">
   rd, wr = IO.pipe

   if fork
     wr.close
     puts &quot;Parent got: &lt;#{rd.read}&gt;&quot;
     rd.close
     Process.wait
   else
     rd.close
     puts &quot;Sending message to parent&quot;
     wr.write &quot;Hi Dad&quot;
     wr.close
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   Sending message to parent
   Parent got: &lt;Hi Dad&gt;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong>(ext_enc) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong>(&quot;ext_enc:int_enc&quot;[, opt]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>pipe</strong>(ext_enc, int_enc[, opt]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.pipe                             -&gt;  [read_io, write_io]
 *     IO.pipe(ext_enc)                    -&gt;  [read_io, write_io]
 *     IO.pipe(&quot;ext_enc:int_enc&quot; [, opt])  -&gt;  [read_io, write_io]
 *     IO.pipe(ext_enc, int_enc [, opt])   -&gt;  [read_io, write_io]
 *
 *     IO.pipe(...) {|read_io, write_io| ... }
 *
 *  Creates a pair of pipe endpoints (connected to each other) and
 *  returns them as a two-element array of &lt;code&gt;IO&lt;/code&gt; objects:
 *  &lt;code&gt;[&lt;/code&gt; &lt;i&gt;read_io&lt;/i&gt;, &lt;i&gt;write_io&lt;/i&gt; &lt;code&gt;]&lt;/code&gt;.
 *
 *  If a block is given, the block is called and
 *  returns the value of the block.
 *  &lt;i&gt;read_io&lt;/i&gt; and &lt;i&gt;write_io&lt;/i&gt; are sent to the block as arguments.
 *  If read_io and write_io are not closed when the block exits, they are closed.
 *  i.e. closing read_io and/or write_io doesn't cause an error.
 *
 *  Not available on all platforms.
 *
 *  If an encoding (encoding name or encoding object) is specified as an optional argument,
 *  read string from pipe is tagged with the encoding specified.
 *  If the argument is a colon separated two encoding names &quot;A:B&quot;,
 *  the read string is converted from encoding A (external encoding)
 *  to encoding B (internal encoding), then tagged with B.
 *  If two optional arguments are specified, those must be
 *  encoding objects or encoding names,
 *  and the first one is the external encoding,
 *  and the second one is the internal encoding.
 *  If the external encoding and the internal encoding is specified,
 *  optional hash argument specify the conversion option.
 *
 *  In the example below, the two processes close the ends of the pipe
 *  that they are not using. This is not just a cosmetic nicety. The
 *  read end of a pipe will not generate an end of file condition if
 *  there are any writers with the pipe still open. In the case of the
 *  parent process, the &lt;code&gt;rd.read&lt;/code&gt; will never return if it
 *  does not first issue a &lt;code&gt;wr.close&lt;/code&gt;.
 *
 *     rd, wr = IO.pipe
 *
 *     if fork
 *       wr.close
 *       puts &quot;Parent got: &lt;#{rd.read}&gt;&quot;
 *       rd.close
 *       Process.wait
 *     else
 *       rd.close
 *       puts &quot;Sending message to parent&quot;
 *       wr.write &quot;Hi Dad&quot;
 *       wr.close
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Sending message to parent
 *     Parent got: &lt;Hi Dad&gt;
 */

static VALUE
rb_io_s_pipe(int argc, VALUE *argv, VALUE klass)
{
    int pipes[2], state;
    VALUE r, w, args[3], v1, v2;
    VALUE opt;
    rb_io_t *fptr, *fptr2;
    int fmode = 0;
    VALUE ret;

    opt = pop_last_hash(&amp;argc, argv);
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;v1, &amp;v2);
    if (rb_pipe(pipes) == -1)
        rb_sys_fail(0);

    args[0] = klass;
    args[1] = INT2NUM(pipes[0]);
    args[2] = INT2FIX(O_RDONLY);
    r = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
    close(pipes[0]);
    close(pipes[1]);
    rb_jump_tag(state);
    }
    GetOpenFile(r, fptr);
    io_encoding_set(fptr, v1, v2, opt);
    args[1] = INT2NUM(pipes[1]);
    args[2] = INT2FIX(O_WRONLY);
    w = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
    close(pipes[1]);
    if (!NIL_P(r)) rb_io_close(r);
    rb_jump_tag(state);
    }
    GetOpenFile(w, fptr2);
    rb_io_synchronized(fptr2);

    extract_binmode(opt, &amp;fmode);
    fptr-&gt;mode |= fmode;
    fptr2-&gt;mode |= fmode;

    ret = rb_assoc_new(r, w);
    if (rb_block_given_p()) {
    VALUE rw[2];
    rw[0] = r;
    rw[1] = w;
    return rb_ensure(rb_yield, ret, pipe_pair_close, (VALUE)rw);
    }
    return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="popen-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>popen</strong>(cmd, mode = &quot;r&quot;[, opt]) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>popen</strong>(cmd, mode = &quot;r&quot;[, opt]) {|io| ... }</span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Runs the specified command as a subprocess; the subprocess&#8217;s standard
input and output will be connected to the returned <tt>IO</tt> object.
</p>
<p>
The PID of the started process can be obtained by IO#pid method.
</p>
<p>
<em>cmd</em> is a string or an array as follows.
</p>
<pre class="code">
  cmd:
    &quot;-&quot;                                      : fork
    commandline                              : command line string which is passed to a shell
    [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)
    [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)
  (env and opts are optional.)
</pre>
<p>
If <em>cmd</em> is a <tt>String</tt> ``<tt>-</tt>&#8217;&#8217;, then a new
instance of Ruby is started as the subprocess.
</p>
<p>
If <em>cmd</em> is an <tt>Array</tt> of <tt>String</tt>, then it will be
used as the subprocess&#8217;s <tt>argv</tt> bypassing a shell. The array
can contains a hash at first for environments and a hash at last for
options similar to <tt>spawn</tt>.
</p>
<p>
The default mode for the new file object is ``r&#8217;&#8217;, but
<em>mode</em> may be set to any of the modes listed in the description for
class IO. The last argument <em>opt</em> qualifies <em>mode</em>.
</p>
<pre class="code">
  # set IO encoding
  IO.popen(&quot;nkf -e filename&quot;, :external_encoding=&gt;&quot;EUC-JP&quot;) {|nkf_io|
    euc_jp_string = nkf_io.read
  }

  # merge standard output and standard error using
  # spawn option.  See the document of Kernel.spawn.
  IO.popen([&quot;ls&quot;, &quot;/&quot;, :err=&gt;[:child, :out]]) {|ls_io|
    ls_result_with_error = ls_io.read
  }
</pre>
<p>
Raises exceptions which <tt>IO.pipe</tt> and <tt>Kernel.spawn</tt> raise.
</p>
<p>
If a block is given, Ruby will run the command as a child connected to Ruby
with a pipe. Ruby&#8217;s end of the pipe will be passed as a parameter to
the block. At the end of block, Ruby close the pipe and sets <tt>$?</tt>.
In this case <tt>IO.popen</tt> returns the value of the block.
</p>
<p>
If a block is given with a <em>cmd</em> of ``<tt>-</tt>&#8217;&#8217;, the
block will be run in two separate processes: once in the parent, and once
in a child. The parent process will be passed the pipe object as a
parameter to the block, the child version of the block will be passed
<tt>nil</tt>, and the child&#8217;s standard in and standard out will be
connected to the parent through the pipe. Not available on all platforms.
</p>
<pre class="code">
   f = IO.popen(&quot;uname&quot;)
   p f.readlines
   f.close
   puts &quot;Parent is #{Process.pid}&quot;
   IO.popen(&quot;date&quot;) { |f| puts f.gets }
   IO.popen(&quot;-&quot;) {|f| $stderr.puts &quot;#{Process.pid} is here, f is #{f.inspect}&quot;}
   p $?
   IO.popen(%w&quot;sed -e s|^|&lt;foo&gt;| -e s&amp;$&amp;;zot;&amp;&quot;, &quot;r+&quot;) {|f|
     f.puts &quot;bar&quot;; f.close_write; puts f.gets
   }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   [&quot;Linux\n&quot;]
   Parent is 21346
   Thu Jan 15 22:41:19 JST 2009
   21346 is here, f is #&lt;IO:fd 3&gt;
   21352 is here, f is nil
   #&lt;Process::Status: pid 21352 exit 0&gt;
   &lt;foo&gt;bar;zot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>popen</strong>(cmd, mode = &quot;r&quot;[, opt]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>popen</strong>(cmd, mode = &quot;r&quot;[, opt]) {|io| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>io</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.popen(cmd, mode=&quot;r&quot; [, opt])               -&gt; io
 *     IO.popen(cmd, mode=&quot;r&quot; [, opt]) {|io| block } -&gt; obj
 *
 *  Runs the specified command as a subprocess; the subprocess's
 *  standard input and output will be connected to the returned
 *  &lt;code&gt;IO&lt;/code&gt; object.
 *
 *  The PID of the started process can be obtained by IO#pid method.
 *
 *  _cmd_ is a string or an array as follows.
 *
 *    cmd:
 *      &quot;-&quot;                                      : fork
 *      commandline                              : command line string which is passed to a shell
 *      [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)
 *      [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)
 *    (env and opts are optional.)
 *
 *  If _cmd_ is a +String+ ``&lt;code&gt;-&lt;/code&gt;'',
 *  then a new instance of Ruby is started as the subprocess.
 *
 *  If &lt;i&gt;cmd&lt;/i&gt; is an +Array+ of +String+,
 *  then it will be used as the subprocess's +argv+ bypassing a shell.
 *  The array can contains a hash at first for environments and
 *  a hash at last for options similar to &lt;code&gt;spawn&lt;/code&gt;.
 *
 *  The default mode for the new file object is ``r'',
 *  but &lt;i&gt;mode&lt;/i&gt; may be set to any of the modes listed in the description for class IO.
 *  The last argument &lt;i&gt;opt&lt;/i&gt; qualifies &lt;i&gt;mode&lt;/i&gt;.
 *
 *    # set IO encoding
 *    IO.popen(&quot;nkf -e filename&quot;, :external_encoding=&gt;&quot;EUC-JP&quot;) {|nkf_io|
 *      euc_jp_string = nkf_io.read
 *    }
 *
 *    # merge standard output and standard error using
 *    # spawn option.  See the document of Kernel.spawn.
 *    IO.popen([&quot;ls&quot;, &quot;/&quot;, :err=&gt;[:child, :out]]) {|ls_io|
 *      ls_result_with_error = ls_io.read
 *    }
 *
 *  Raises exceptions which &lt;code&gt;IO.pipe&lt;/code&gt; and
 *  &lt;code&gt;Kernel.spawn&lt;/code&gt; raise.
 *
 *  If a block is given, Ruby will run the command as a child connected
 *  to Ruby with a pipe. Ruby's end of the pipe will be passed as a
 *  parameter to the block.
 *  At the end of block, Ruby close the pipe and sets &lt;code&gt;$?&lt;/code&gt;.
 *  In this case &lt;code&gt;IO.popen&lt;/code&gt; returns
 *  the value of the block.
 *
 *  If a block is given with a _cmd_ of ``&lt;code&gt;-&lt;/code&gt;'',
 *  the block will be run in two separate processes: once in the parent,
 *  and once in a child. The parent process will be passed the pipe
 *  object as a parameter to the block, the child version of the block
 *  will be passed &lt;code&gt;nil&lt;/code&gt;, and the child's standard in and
 *  standard out will be connected to the parent through the pipe. Not
 *  available on all platforms.
 *
 *     f = IO.popen(&quot;uname&quot;)
 *     p f.readlines
 *     f.close
 *     puts &quot;Parent is #{Process.pid}&quot;
 *     IO.popen(&quot;date&quot;) { |f| puts f.gets }
 *     IO.popen(&quot;-&quot;) {|f| $stderr.puts &quot;#{Process.pid} is here, f is #{f.inspect}&quot;}
 *     p $?
 *     IO.popen(%w&quot;sed -e s|^|&lt;foo&gt;| -e s&amp;$&amp;;zot;&amp;&quot;, &quot;r+&quot;) {|f|
 *       f.puts &quot;bar&quot;; f.close_write; puts f.gets
 *     }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     [&quot;Linux\n&quot;]
 *     Parent is 21346
 *     Thu Jan 15 22:41:19 JST 2009
 *     21346 is here, f is #&lt;IO:fd 3&gt;
 *     21352 is here, f is nil
 *     #&lt;Process::Status: pid 21352 exit 0&gt;
 *     &lt;foo&gt;bar;zot;
 */

static VALUE
rb_io_s_popen(int argc, VALUE *argv, VALUE klass)
{
    const char *modestr;
    VALUE pname, pmode, port, tmp, opt;
    int oflags, fmode;
    convconfig_t convconfig;

    opt = pop_last_hash(&amp;argc, argv);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pname, &amp;pmode);

    rb_io_extract_modeenc(&amp;pmode, 0, opt, &amp;oflags, &amp;fmode, &amp;convconfig);
    modestr = rb_io_oflags_modestr(oflags);

    tmp = rb_check_array_type(pname);
    if (!NIL_P(tmp)) {
    long len = RARRAY_LEN(tmp);
#if SIZEOF_LONG &gt; SIZEOF_INT
    if (len &gt; INT_MAX) {
        rb_raise(rb_eArgError, &quot;too many arguments&quot;);
    }
#endif
    tmp = rb_ary_dup(tmp);
    RBASIC(tmp)-&gt;klass = 0;
    port = pipe_open_v((int)len, RARRAY_PTR(tmp), modestr, fmode, &amp;convconfig);
    rb_ary_clear(tmp);
    }
    else {
    SafeStringValue(pname);
    port = pipe_open_s(pname, modestr, fmode, &amp;convconfig);
    }
    if (NIL_P(port)) {
    /* child */
    if (rb_block_given_p()) {
        rb_yield(Qnil);
            rb_io_flush(rb_stdout);
            rb_io_flush(rb_stderr);
        _exit(0);
    }
    return Qnil;
    }
    RBASIC(port)-&gt;klass = klass;
    if (rb_block_given_p()) {
    return rb_ensure(rb_yield, port, io_close, port);
    }
    return port;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>read</strong>(name, [length [, offset]]) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>read</strong>(name, [length [, offset]], open_args) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Opens the file, optionally seeks to the given <em>offset</em>, then returns
<em>length</em> bytes (defaulting to the rest of the file). <tt>read</tt>
ensures the file is closed before returning.
</p>
<p>
If the last argument is a hash, it specifies option for internal open(). 
The key would be the following.  open_args: is exclusive to others.
</p>
<pre class="code">
 encoding: string or encoding

  specifies encoding of the read string.  encoding will be ignored
  if length is specified.

 mode: string

  specifies mode argument for open().  it should start with &quot;r&quot;
  otherwise it would cause error.

 open_args: array of strings

  specifies arguments for open() as an array.

   IO.read(&quot;testfile&quot;)           #=&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;
   IO.read(&quot;testfile&quot;, 20)       #=&gt; &quot;This is line one\nThi&quot;
   IO.read(&quot;testfile&quot;, 20, 10)   #=&gt; &quot;ne one\nThis is line &quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>read</strong>(name, [length [, offset]]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>read</strong>(name, [length [, offset]], open_args) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.read(name, [length [, offset]] )   -&gt; string
 *     IO.read(name, [length [, offset]], open_args)   -&gt; string
 *
 *  Opens the file, optionally seeks to the given &lt;i&gt;offset&lt;/i&gt;, then returns
 *  &lt;i&gt;length&lt;/i&gt; bytes (defaulting to the rest of the file).
 *  &lt;code&gt;read&lt;/code&gt; ensures the file is closed before returning.
 *
 *  If the last argument is a hash, it specifies option for internal
 *  open().  The key would be the following.  open_args: is exclusive
 *  to others.
 *
 *   encoding: string or encoding
 *
 *    specifies encoding of the read string.  encoding will be ignored
 *    if length is specified.
 *
 *   mode: string
 *
 *    specifies mode argument for open().  it should start with &quot;r&quot;
 *    otherwise it would cause error.
 *
 *   open_args: array of strings
 *
 *    specifies arguments for open() as an array.
 *
 *     IO.read(&quot;testfile&quot;)           #=&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;
 *     IO.read(&quot;testfile&quot;, 20)       #=&gt; &quot;This is line one\nThi&quot;
 *     IO.read(&quot;testfile&quot;, 20, 10)   #=&gt; &quot;ne one\nThis is line &quot;
 */

static VALUE
rb_io_s_read(int argc, VALUE *argv, VALUE io)
{
    VALUE offset;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, &quot;13&quot;, NULL, NULL, &amp;offset, NULL);
    open_key_args(argc, argv, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    if (!NIL_P(offset)) {
    struct seek_arg sarg;
    int state = 0;
    sarg.io = arg.io;
    sarg.offset = offset;
    sarg.mode = SEEK_SET;
    rb_protect(seek_before_access, (VALUE)&amp;sarg, &amp;state);
    if (state) {
        rb_io_close(arg.io);
        rb_jump_tag(state);
    }
    if (arg.argc == 2) arg.argc = 1;
    }
    return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="readlines-class_method">
  
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(name, sep = $/[, open_args]) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(name, limit[, open_args]) </span>
    
      <span class="overload">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(name, sep, limit[, open_args]) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads the entire file specified by <em>name</em> as individual lines, and
returns those lines in an array. Lines are separated by <em>sep</em>.
</p>
<pre class="code">
   a = IO.readlines(&quot;testfile&quot;)
   a[0]   #=&gt; &quot;This is line one\n&quot;
</pre>
<p>
If the last argument is a hash, it&#8217;s the keyword argument to open.
See <tt>IO.read</tt> for detail.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(name, sep = $/[, open_args]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(name, limit[, open_args]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">+ (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(name, sep, limit[, open_args]) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.readlines(name, sep=$/ [, open_args])     -&gt; array
 *     IO.readlines(name, limit [, open_args])      -&gt; array
 *     IO.readlines(name, sep, limit [, open_args]) -&gt; array
 *
 *  Reads the entire file specified by &lt;i&gt;name&lt;/i&gt; as individual
 *  lines, and returns those lines in an array. Lines are separated by
 *  &lt;i&gt;sep&lt;/i&gt;.
 *
 *     a = IO.readlines(&quot;testfile&quot;)
 *     a[0]   #=&gt; &quot;This is line one\n&quot;
 *
 *  If the last argument is a hash, it's the keyword argument to open.
 *  See &lt;code&gt;IO.read&lt;/code&gt; for detail.
 *
 */

static VALUE
rb_io_s_readlines(int argc, VALUE *argv, VALUE io)
{
    struct foreach_arg arg;

    rb_scan_args(argc, argv, &quot;13&quot;, NULL, NULL, NULL, NULL);
    open_key_args(argc, argv, &amp;arg);
    if (NIL_P(arg.io)) return Qnil;
    return rb_ensure(io_s_readlines, (VALUE)&amp;arg, rb_io_close, arg.io);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="select-class_method">
  
    + (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>select</strong>(read_array) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
[, error_array
</p>
<pre class="code">
             [, timeout]]] )-&gt; array  or  nil
</pre>
<p>
See <tt>Kernel#select</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.select(read_array
 *               [, write_array
 *               [, error_array
 *               [, timeout]]] )-&gt; array  or  nil
 *
 *  See &lt;code&gt;Kernel#select&lt;/code&gt;.
 */

static VALUE
rb_f_select(int argc, VALUE *argv, VALUE obj)
{
    VALUE timeout;
    struct select_args args;
    struct timeval timerec;
    int i;

    rb_scan_args(argc, argv, &quot;13&quot;, &amp;args.read, &amp;args.write, &amp;args.except, &amp;timeout);
    if (NIL_P(timeout)) {
    args.timeout = 0;
    }
    else {
    timerec = rb_time_interval(timeout);
    args.timeout = &amp;timerec;
    }

    for (i = 0; i &lt; numberof(args.fdsets); ++i)
    rb_fd_init(&amp;args.fdsets[i]);

#ifdef HAVE_RB_FD_INIT
    return rb_ensure(select_call, (VALUE)&amp;args, select_end, (VALUE)&amp;args);
#else
    return select_internal(args.read, args.write, args.except,
               args.timeout, args.fdsets);
#endif

}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sysopen-class_method">
  
    + (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>sysopen</strong>(path, [mode, [perm]]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Opens the given path, returning the underlying file descriptor as a
<tt>Fixnum</tt>.
</p>
<pre class="code">
   IO.sysopen(&quot;testfile&quot;)   #=&gt; 3</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.sysopen(path, [mode, [perm]])  -&gt; fixnum
 *
 *  Opens the given path, returning the underlying file descriptor as a
 *  &lt;code&gt;Fixnum&lt;/code&gt;.
 *
 *     IO.sysopen(&quot;testfile&quot;)   #=&gt; 3
 *
 */

static VALUE
rb_io_s_sysopen(int argc, VALUE *argv)
{
    VALUE fname, vmode, vperm;
    VALUE intmode;
    int oflags, fd;
    mode_t perm;

    rb_scan_args(argc, argv, &quot;12&quot;, &amp;fname, &amp;vmode, &amp;vperm);
    FilePathValue(fname);

    if (NIL_P(vmode))
        oflags = O_RDONLY;
    else if (!NIL_P(intmode = rb_check_to_integer(vmode, &quot;to_int&quot;)))
        oflags = NUM2INT(intmode);
    else {
    SafeStringValue(vmode);
    oflags = rb_io_modestr_oflags(StringValueCStr(vmode));
    }
    if (NIL_P(vperm)) perm = 0666;
    else              perm = NUM2UINT(vperm);

    RB_GC_GUARD(fname) = rb_str_new4(fname);
    fd = rb_sysopen(fname, oflags, perm);
    return INT2NUM(fd);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="try_convert-class_method">
  
    + (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt><sup>?</sup>) <strong>try_convert</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Try to convert <em>obj</em> into an IO, using to_io method. Returns
converted IO or nil if <em>obj</em> cannot be converted for any reason.
</p>
<pre class="code">
   IO.try_convert(STDOUT)     #=&gt; STDOUT
   IO.try_convert(&quot;STDOUT&quot;)   #=&gt; nil

   require 'zlib'
   f = open(&quot;/tmp/zz.gz&quot;)       #=&gt; #&lt;File:/tmp/zz.gz&gt;
   z = Zlib::GzipReader.open(f) #=&gt; #&lt;Zlib::GzipReader:0x81d8744&gt;
   IO.try_convert(z)            #=&gt; #&lt;File:/tmp/zz.gz&gt;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     IO.try_convert(obj)  -&gt;  io or nil
 *
 *  Try to convert &lt;i&gt;obj&lt;/i&gt; into an IO, using to_io method.
 *  Returns converted IO or nil if &lt;i&gt;obj&lt;/i&gt; cannot be converted
 *  for any reason.
 *
 *     IO.try_convert(STDOUT)     #=&gt; STDOUT
 *     IO.try_convert(&quot;STDOUT&quot;)   #=&gt; nil
 *
 *     require 'zlib'
 *     f = open(&quot;/tmp/zz.gz&quot;)       #=&gt; #&lt;File:/tmp/zz.gz&gt;
 *     z = Zlib::GzipReader.open(f) #=&gt; #&lt;Zlib::GzipReader:0x81d8744&gt;
 *     IO.try_convert(z)            #=&gt; #&lt;File:/tmp/zz.gz&gt;
 *
 */
static VALUE
rb_io_s_try_convert(VALUE dummy, VALUE io)
{
    return rb_io_check_io(io);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="<<-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>&lt;&lt;</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
String Output--Writes <em>obj</em> to <em>ios</em>. <em>obj</em> will
be converted to a string using <tt>to_s</tt>.
</p>
<pre class="code">
   $stdout &lt;&lt; &quot;Hello &quot; &lt;&lt; &quot;world!\n&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   Hello world!</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios &lt;&lt; obj     -&gt; ios
 *
 *  String Output---Writes &lt;i&gt;obj&lt;/i&gt; to &lt;em&gt;ios&lt;/em&gt;.
 *  &lt;i&gt;obj&lt;/i&gt; will be converted to a string using
 *  &lt;code&gt;to_s&lt;/code&gt;.
 *
 *     $stdout &lt;&lt; &quot;Hello &quot; &lt;&lt; &quot;world!\n&quot;
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Hello world!
 */


VALUE
rb_io_addstr(VALUE io, VALUE str)
{
    rb_io_write(io, str);
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="autoclose=-instance_method">
  
    - (<tt>Boolean</tt>) <strong>autoclose=</strong>(bool) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets auto-close flag.
</p>
<pre class="code">
   f = open(&quot;/dev/null&quot;)
   IO.for_fd(f.fileno)
   # ...
   f.gets # may cause IOError

   f = open(&quot;/dev/null&quot;)
   IO.for_fd(f.fileno).autoclose = true
   # ...
   f.gets # won't cause IOError</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     io.autoclose = bool    -&gt; true or false
 *
 *  Sets auto-close flag.
 *
 *     f = open(&quot;/dev/null&quot;)
 *     IO.for_fd(f.fileno)
 *     # ...
 *     f.gets # may cause IOError
 *
 *     f = open(&quot;/dev/null&quot;)
 *     IO.for_fd(f.fileno).autoclose = true
 *     # ...
 *     f.gets # won't cause IOError
 */

static VALUE
rb_io_set_autoclose(VALUE io, VALUE autoclose)
{
    rb_io_t *fptr;
    rb_secure(4);
    GetOpenFile(io, fptr);
    if (!RTEST(autoclose))
    fptr-&gt;mode |= FMODE_PREP;
    else
    fptr-&gt;mode &amp;= ~FMODE_PREP;
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="autoclose?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>autoclose?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if the underlying file descriptor of <em>ios</em>
will be closed automatically at its finalization, otherwise <tt>false</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.autoclose?   -&gt; true or false
 *
 *  Returns +true+ if the underlying file descriptor of _ios_ will be
 *  closed automatically at its finalization, otherwise +false+.
 */

static VALUE
rb_io_autoclose_p(VALUE io)
{
    rb_io_t *fptr;
    rb_secure(4);
    GetOpenFile(io, fptr);
    return (fptr-&gt;mode &amp; FMODE_PREP) ? Qfalse : Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="binmode-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>binmode</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Puts <em>ios</em> into binary mode. Once a stream is in binary mode, it
cannot be reset to nonbinary mode.
</p>
<ul>
<li><p>
newline conversion disabled
</p>
</li>
<li><p>
encoding conversion disabled
</p>
</li>
<li><p>
content is treated as ASCII-8BIT
</p>
</li>
</ul>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.binmode    -&gt; ios
 *
 *  Puts &lt;em&gt;ios&lt;/em&gt; into binary mode.
 *  Once a stream is in binary mode, it cannot be reset to nonbinary mode.
 *
 *  - newline conversion disabled
 *  - encoding conversion disabled
 *  - content is treated as ASCII-8BIT
 *
 */

static VALUE
rb_io_binmode_m(VALUE io)
{
    VALUE write_io;

    rb_io_ascii8bit_binmode(io);

    write_io = GetWriteIO(io);
    if (write_io != io)
        rb_io_ascii8bit_binmode(write_io);
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="binmode?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>binmode?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <em>ios</em> is binmode.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.binmode?    -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;ios&lt;/em&gt; is binmode.
 */
static VALUE
rb_io_binmode_p(VALUE io)
{
    rb_io_t *fptr;
    GetOpenFile(io, fptr);
    return fptr-&gt;mode &amp; FMODE_BINMODE ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="bytes-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>bytes</strong> {|byte| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>bytes</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
ios.each_byte {|byte| block }  -> ios
</p>
<pre class="code">
   ios.each_byte                  -&gt; an_enumerator
</pre>
<p>
Calls the given block once for each byte (0..255) in <em>ios</em>, passing
the byte as an argument. The stream must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   checksum = 0
   f.each_byte {|x| checksum ^= x }   #=&gt; #&lt;File:testfile&gt;
   checksum                           #=&gt; 12</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>bytes</strong> {|byte| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>byte</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.bytes {|byte| block }      -&gt; ios
 *     ios.bytes                      -&gt; an_enumerator
 *
 *     ios.each_byte {|byte| block }  -&gt; ios
 *     ios.each_byte                  -&gt; an_enumerator
 *
 *  Calls the given block once for each byte (0..255) in &lt;em&gt;ios&lt;/em&gt;,
 *  passing the byte as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     checksum = 0
 *     f.each_byte {|x| checksum ^= x }   #=&gt; #&lt;File:testfile&gt;
 *     checksum                           #=&gt; 12
 */

static VALUE
rb_io_each_byte(VALUE io)
{
    rb_io_t *fptr;
    char *p, *e;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);

    for (;;) {
    p = fptr-&gt;rbuf+fptr-&gt;rbuf_off;
    e = p + fptr-&gt;rbuf_len;
    while (p &lt; e) {
        fptr-&gt;rbuf_off++;
        fptr-&gt;rbuf_len--;
        rb_yield(INT2FIX(*p &amp; 0xff));
        p++;
        errno = 0;
    }
    rb_io_check_byte_readable(fptr);
    READ_CHECK(fptr);
    if (io_fillbuf(fptr) &lt; 0) {
        break;
    }
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="chars-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>chars</strong> {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chars</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
ios.each_char {|c| block }  -> ios
</p>
<pre class="code">
   ios.each_char               -&gt; an_enumerator
</pre>
<p>
Calls the given block once for each character in <em>ios</em>, passing the
character as an argument. The stream must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.each_char {|c| print c, ' ' }   #=&gt; #&lt;File:testfile&gt;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>chars</strong> {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.chars {|c| block }      -&gt; ios
 *     ios.chars                   -&gt; an_enumerator
 *
 *     ios.each_char {|c| block }  -&gt; ios
 *     ios.each_char               -&gt; an_enumerator
 *
 *  Calls the given block once for each character in &lt;em&gt;ios&lt;/em&gt;,
 *  passing the character as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.each_char {|c| print c, ' ' }   #=&gt; #&lt;File:testfile&gt;
 */

static VALUE
rb_io_each_char(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    VALUE c;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    enc = io_input_encoding(fptr);
    READ_CHECK(fptr);
    while (!NIL_P(c = io_getc(fptr, enc))) {
        rb_yield(c);
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="close-instance_method">
  
    - (<tt>nil</tt>) <strong>close</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Closes <em>ios</em> and flushes any pending writes to the operating system.
The stream is unavailable for any further data operations; an
<tt>IOError</tt> is raised if such an attempt is made. I/O streams are
automatically closed when they are claimed by the garbage collector.
</p>
<p>
If <em>ios</em> is opened by <tt>IO.popen</tt>, <tt>close</tt> sets
<tt>$?</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.close   -&gt; nil
 *
 *  Closes &lt;em&gt;ios&lt;/em&gt; and flushes any pending writes to the operating
 *  system. The stream is unavailable for any further data operations;
 *  an &lt;code&gt;IOError&lt;/code&gt; is raised if such an attempt is made. I/O
 *  streams are automatically closed when they are claimed by the
 *  garbage collector.
 *
 *  If &lt;em&gt;ios&lt;/em&gt; is opened by &lt;code&gt;IO.popen&lt;/code&gt;,
 *  &lt;code&gt;close&lt;/code&gt; sets &lt;code&gt;$?&lt;/code&gt;.
 */

static VALUE
rb_io_close_m(VALUE io)
{
    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_UNTRUSTED(io)) {
    rb_raise(rb_eSecurityError, &quot;Insecure: can't close&quot;);
    }
    rb_io_check_closed(RFILE(io)-&gt;fptr);
    rb_io_close(io);
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="close_on_exec=-instance_method">
  
    - (<tt>Boolean</tt>) <strong>close_on_exec=</strong>(bool) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets a close-on-exec flag.
</p>
<pre class="code">
   f = open(&quot;/dev/null&quot;)
   f.close_on_exec = true
   system(&quot;cat&quot;, &quot;/proc/self/fd/#{f.fileno}&quot;) # cat: /proc/self/fd/3: No such file or directory
   f.closed?                #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.close_on_exec = bool    -&gt; true or false
 *
 *  Sets a close-on-exec flag.
 *
 *     f = open(&quot;/dev/null&quot;)
 *     f.close_on_exec = true
 *     system(&quot;cat&quot;, &quot;/proc/self/fd/#{f.fileno}&quot;) # cat: /proc/self/fd/3: No such file or directory
 *     f.closed?                #=&gt; false
 */

static VALUE
rb_io_set_close_on_exec(VALUE io, VALUE arg)
{
    int flag = RTEST(arg) ? FD_CLOEXEC : 0;
    rb_io_t *fptr;
    VALUE write_io;
    int fd, ret;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        GetOpenFile(write_io, fptr);
        if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
            if ((ret = fcntl(fptr-&gt;fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
            if ((ret &amp; FD_CLOEXEC) != flag) {
                ret = (ret &amp; ~FD_CLOEXEC) | flag;
                ret = fcntl(fd, F_SETFD, ret);
                if (ret == -1) rb_sys_fail_path(fptr-&gt;pathv);
            }
        }

    }

    GetOpenFile(io, fptr);
    if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
        if ((ret &amp; FD_CLOEXEC) != flag) {
            ret = (ret &amp; ~FD_CLOEXEC) | flag;
            ret = fcntl(fd, F_SETFD, ret);
            if (ret == -1) rb_sys_fail_path(fptr-&gt;pathv);
        }
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="close_on_exec?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>close_on_exec?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <em>ios</em> will be closed on exec.
</p>
<pre class="code">
   f = open(&quot;/dev/null&quot;)
   f.close_on_exec?                 #=&gt; false
   f.close_on_exec = true
   f.close_on_exec?                 #=&gt; true
   f.close_on_exec = false
   f.close_on_exec?                 #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.close_on_exec?   -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;ios&lt;/em&gt; will be closed on exec.
 *
 *     f = open(&quot;/dev/null&quot;)
 *     f.close_on_exec?                 #=&gt; false
 *     f.close_on_exec = true
 *     f.close_on_exec?                 #=&gt; true
 *     f.close_on_exec = false
 *     f.close_on_exec?                 #=&gt; false
 */

static VALUE
rb_io_close_on_exec_p(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;
    int fd, ret;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        GetOpenFile(write_io, fptr);
        if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
            if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
            if (!(ret &amp; FD_CLOEXEC)) return Qfalse;
        }
    }

    GetOpenFile(io, fptr);
    if (fptr &amp;&amp; 0 &lt;= (fd = fptr-&gt;fd)) {
        if ((ret = fcntl(fd, F_GETFD)) == -1) rb_sys_fail_path(fptr-&gt;pathv);
        if (!(ret &amp; FD_CLOEXEC)) return Qfalse;
    }
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="close_read-instance_method">
  
    - (<tt>nil</tt>) <strong>close_read</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Closes the read end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe). Will raise an <tt>IOError</tt> if
the stream is not duplexed.
</p>
<pre class="code">
   f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
   f.close_read
   f.readlines
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   prog.rb:3:in `readlines': not opened for reading (IOError)
    from prog.rb:3</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.close_read    -&gt; nil
 *
 *  Closes the read end of a duplex I/O stream (i.e., one that contains
 *  both a read and a write stream, such as a pipe). Will raise an
 *  &lt;code&gt;IOError&lt;/code&gt; if the stream is not duplexed.
 *
 *     f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
 *     f.close_read
 *     f.readlines
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     prog.rb:3:in `readlines': not opened for reading (IOError)
 *      from prog.rb:3
 */

static VALUE
rb_io_close_read(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_UNTRUSTED(io)) {
    rb_raise(rb_eSecurityError, &quot;Insecure: can't close&quot;);
    }
    GetOpenFile(io, fptr);
    if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {
#ifndef SHUT_RD
# define SHUT_RD 0
#endif
        if (shutdown(fptr-&gt;fd, SHUT_RD) &lt; 0)
            rb_sys_fail_path(fptr-&gt;pathv);
        fptr-&gt;mode &amp;= ~FMODE_READABLE;
        if (!(fptr-&gt;mode &amp; FMODE_WRITABLE))
            return rb_io_close(io);
        return Qnil;
    }

    write_io = GetWriteIO(io);
    if (io != write_io) {
    rb_io_t *wfptr;
        rb_io_fptr_cleanup(fptr, FALSE);
    GetOpenFile(write_io, wfptr);
        RFILE(io)-&gt;fptr = wfptr;
        RFILE(write_io)-&gt;fptr = NULL;
        rb_io_fptr_finalize(fptr);
        return Qnil;
    }

    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
    rb_raise(rb_eIOError, &quot;closing non-duplex IO for reading&quot;);
    }
    return rb_io_close(io);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="close_write-instance_method">
  
    - (<tt>nil</tt>) <strong>close_write</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Closes the write end of a duplex I/O stream (i.e., one that contains both a
read and a write stream, such as a pipe). Will raise an <tt>IOError</tt> if
the stream is not duplexed.
</p>
<pre class="code">
   f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
   f.close_write
   f.print &quot;nowhere&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   prog.rb:3:in `write': not opened for writing (IOError)
    from prog.rb:3:in `print'
    from prog.rb:3</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.close_write   -&gt; nil
 *
 *  Closes the write end of a duplex I/O stream (i.e., one that contains
 *  both a read and a write stream, such as a pipe). Will raise an
 *  &lt;code&gt;IOError&lt;/code&gt; if the stream is not duplexed.
 *
 *     f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
 *     f.close_write
 *     f.print &quot;nowhere&quot;
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     prog.rb:3:in `write': not opened for writing (IOError)
 *      from prog.rb:3:in `print'
 *      from prog.rb:3
 */

static VALUE
rb_io_close_write(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_UNTRUSTED(io)) {
    rb_raise(rb_eSecurityError, &quot;Insecure: can't close&quot;);
    }
    write_io = GetWriteIO(io);
    GetOpenFile(write_io, fptr);
    if (is_socket(fptr-&gt;fd, fptr-&gt;pathv)) {
#ifndef SHUT_WR
# define SHUT_WR 1
#endif
        if (shutdown(fptr-&gt;fd, SHUT_WR) &lt; 0)
            rb_sys_fail_path(fptr-&gt;pathv);
        fptr-&gt;mode &amp;= ~FMODE_WRITABLE;
        if (!(fptr-&gt;mode &amp; FMODE_READABLE))
        return rb_io_close(write_io);
        return Qnil;
    }

    if (fptr-&gt;mode &amp; FMODE_READABLE) {
    rb_raise(rb_eIOError, &quot;closing non-duplex IO for writing&quot;);
    }

    rb_io_close(write_io);
    if (io != write_io) {
    GetOpenFile(io, fptr);
    fptr-&gt;tied_io_for_writing = 0;
    fptr-&gt;mode &amp;= ~FMODE_DUPLEX;
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="closed?-instance_method">
  
    - (<tt>Boolean</tt>) <strong>closed?</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <em>ios</em> is completely closed (for duplex
streams, both reader and writer), <tt>false</tt> otherwise.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.close         #=&gt; nil
   f.closed?       #=&gt; true
   f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
   f.close_write   #=&gt; nil
   f.closed?       #=&gt; false
   f.close_read    #=&gt; nil
   f.closed?       #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.closed?    -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;ios&lt;/em&gt; is completely closed (for
 *  duplex streams, both reader and writer), &lt;code&gt;false&lt;/code&gt;
 *  otherwise.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.close         #=&gt; nil
 *     f.closed?       #=&gt; true
 *     f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
 *     f.close_write   #=&gt; nil
 *     f.closed?       #=&gt; false
 *     f.close_read    #=&gt; nil
 *     f.closed?       #=&gt; true
 */


static VALUE
rb_io_closed(VALUE io)
{
    rb_io_t *fptr;
    VALUE write_io;
    rb_io_t *write_fptr;

    write_io = GetWriteIO(io);
    if (io != write_io) {
        write_fptr = RFILE(write_io)-&gt;fptr;
        if (write_fptr &amp;&amp; 0 &lt;= write_fptr-&gt;fd) {
            return Qfalse;
        }
    }

    fptr = RFILE(io)-&gt;fptr;
    rb_io_check_initialized(fptr);
    return 0 &lt;= fptr-&gt;fd ? Qfalse : Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="codepoints-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each_codepoint</strong> {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>codepoints</strong> {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_codepoint</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>codepoints</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes the <tt>Integer</tt> ordinal of each character in <em>ios</em>,
passing the codepoint as an argument. The stream must be opened for reading
or an <tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each_codepoint</strong> {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>codepoints</strong> {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.each_codepoint {|c| block }  -&gt; ios
 *     ios.codepoints     {|c| block }  -&gt; ios
 *     ios.each_codepoint               -&gt; an_enumerator
 *     ios.codepoints                   -&gt; an_enumerator
 *
 *  Passes the &lt;code&gt;Integer&lt;/code&gt; ordinal of each character in &lt;i&gt;ios&lt;/i&gt;,
 *  passing the codepoint as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 */

static VALUE
rb_io_each_codepoint(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    unsigned int c;
    int r, n;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    READ_CHECK(fptr);
    if (NEED_READCONV(fptr)) {
    for (;;) {
        make_readconv(fptr, 0);
        for (;;) {
        if (fptr-&gt;cbuf_len) {
            if (fptr-&gt;encs.enc)
            r = rb_enc_precise_mbclen(fptr-&gt;cbuf+fptr-&gt;cbuf_off,
                          fptr-&gt;cbuf+fptr-&gt;cbuf_off+fptr-&gt;cbuf_len,
                          fptr-&gt;encs.enc);
            else
            r = ONIGENC_CONSTRUCT_MBCLEN_CHARFOUND(1);
            if (!MBCLEN_NEEDMORE_P(r))
            break;
            if (fptr-&gt;cbuf_len == fptr-&gt;cbuf_capa) {
            rb_raise(rb_eIOError, &quot;too long character&quot;);
            }
        }
        if (more_char(fptr) == MORE_CHAR_FINISHED) {
                    clear_readconv(fptr);
            /* ignore an incomplete character before EOF */
            return io;
        }
        }
        if (MBCLEN_INVALID_P(r)) {
        rb_raise(rb_eArgError, &quot;invalid byte sequence in %s&quot;,
             rb_enc_name(fptr-&gt;encs.enc));
        }
        n = MBCLEN_CHARFOUND_LEN(r);
        if (fptr-&gt;encs.enc) {
        c = rb_enc_codepoint(fptr-&gt;cbuf+fptr-&gt;cbuf_off,
                     fptr-&gt;cbuf+fptr-&gt;cbuf_off+fptr-&gt;cbuf_len,
                     fptr-&gt;encs.enc);
        }
        else {
        c = (unsigned char)fptr-&gt;cbuf[fptr-&gt;cbuf_off];
        }
        fptr-&gt;cbuf_off += n;
        fptr-&gt;cbuf_len -= n;
        rb_yield(UINT2NUM(c));
    }
    }
    enc = io_input_encoding(fptr);
    for (;;) {
    if (io_fillbuf(fptr) &lt; 0) {
        return io;
    }
    r = rb_enc_precise_mbclen(fptr-&gt;rbuf+fptr-&gt;rbuf_off,
                  fptr-&gt;rbuf+fptr-&gt;rbuf_off+fptr-&gt;rbuf_len, enc);
    if (MBCLEN_CHARFOUND_P(r) &amp;&amp;
        (n = MBCLEN_CHARFOUND_LEN(r)) &lt;= fptr-&gt;rbuf_len) {
        c = rb_enc_codepoint(fptr-&gt;rbuf+fptr-&gt;rbuf_off,
                 fptr-&gt;rbuf+fptr-&gt;rbuf_off+fptr-&gt;rbuf_len, enc);
        fptr-&gt;rbuf_off += n;
        fptr-&gt;rbuf_len -= n;
        rb_yield(UINT2NUM(c));
    }
    else if (MBCLEN_INVALID_P(r)) {
        rb_raise(rb_eArgError, &quot;invalid byte sequence in %s&quot;, rb_enc_name(enc));
    }
    else {
        continue;
    }
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep = $/) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(limit) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep, limit) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each</strong>(...) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
ios.each_line(sep=$/) {|line| block }    -> ios
</p>
<pre class="code">
   ios.each_line(limit) {|line| block }     -&gt; ios
   ios.each_line(sep,limit) {|line| block } -&gt; ios
   ios.each_line(...)                       -&gt; an_enumerator

   ios.lines(sep=$/) {|line| block }        -&gt; ios
   ios.lines(limit) {|line| block }         -&gt; ios
   ios.lines(sep,limit) {|line| block }     -&gt; ios
   ios.lines(...)                           -&gt; an_enumerator
</pre>
<p>
Executes the block for every line in <em>ios</em>, where lines are
separated by <em>sep</em>. <em>ios</em> must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   1: This is line one
   2: This is line two
   3: This is line three
   4: And so on...</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep = $/) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(limit) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep, limit) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.each(sep=$/) {|line| block }         -&gt; ios
 *     ios.each(limit) {|line| block }          -&gt; ios
 *     ios.each(sep,limit) {|line| block }      -&gt; ios
 *     ios.each(...)                            -&gt; an_enumerator
 *
 *     ios.each_line(sep=$/) {|line| block }    -&gt; ios
 *     ios.each_line(limit) {|line| block }     -&gt; ios
 *     ios.each_line(sep,limit) {|line| block } -&gt; ios
 *     ios.each_line(...)                       -&gt; an_enumerator
 *
 *     ios.lines(sep=$/) {|line| block }        -&gt; ios
 *     ios.lines(limit) {|line| block }         -&gt; ios
 *     ios.lines(sep,limit) {|line| block }     -&gt; ios
 *     ios.lines(...)                           -&gt; an_enumerator
 *
 *  Executes the block for every line in &lt;em&gt;ios&lt;/em&gt;, where lines are
 *  separated by &lt;i&gt;sep&lt;/i&gt;. &lt;em&gt;ios&lt;/em&gt; must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     1: This is line one
 *     2: This is line two
 *     3: This is line three
 *     4: And so on...
 */

static VALUE
rb_io_each_line(int argc, VALUE *argv, VALUE io)
{
    VALUE str, rs;
    long limit;

    RETURN_ENUMERATOR(io, argc, argv);
    prepare_getline_args(argc, argv, &amp;rs, &amp;limit, io);
    while (!NIL_P(str = rb_io_getline_1(rs, limit, io))) {
    rb_yield(str);
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_byte-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>bytes</strong> {|byte| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>bytes</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
ios.each_byte {|byte| block }  -> ios
</p>
<pre class="code">
   ios.each_byte                  -&gt; an_enumerator
</pre>
<p>
Calls the given block once for each byte (0..255) in <em>ios</em>, passing
the byte as an argument. The stream must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   checksum = 0
   f.each_byte {|x| checksum ^= x }   #=&gt; #&lt;File:testfile&gt;
   checksum                           #=&gt; 12</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>bytes</strong> {|byte| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>byte</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.bytes {|byte| block }      -&gt; ios
 *     ios.bytes                      -&gt; an_enumerator
 *
 *     ios.each_byte {|byte| block }  -&gt; ios
 *     ios.each_byte                  -&gt; an_enumerator
 *
 *  Calls the given block once for each byte (0..255) in &lt;em&gt;ios&lt;/em&gt;,
 *  passing the byte as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     checksum = 0
 *     f.each_byte {|x| checksum ^= x }   #=&gt; #&lt;File:testfile&gt;
 *     checksum                           #=&gt; 12
 */

static VALUE
rb_io_each_byte(VALUE io)
{
    rb_io_t *fptr;
    char *p, *e;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);

    for (;;) {
    p = fptr-&gt;rbuf+fptr-&gt;rbuf_off;
    e = p + fptr-&gt;rbuf_len;
    while (p &lt; e) {
        fptr-&gt;rbuf_off++;
        fptr-&gt;rbuf_len--;
        rb_yield(INT2FIX(*p &amp; 0xff));
        p++;
        errno = 0;
    }
    rb_io_check_byte_readable(fptr);
    READ_CHECK(fptr);
    if (io_fillbuf(fptr) &lt; 0) {
        break;
    }
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_char-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>chars</strong> {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>chars</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
ios.each_char {|c| block }  -> ios
</p>
<pre class="code">
   ios.each_char               -&gt; an_enumerator
</pre>
<p>
Calls the given block once for each character in <em>ios</em>, passing the
character as an argument. The stream must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.each_char {|c| print c, ' ' }   #=&gt; #&lt;File:testfile&gt;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>chars</strong> {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.chars {|c| block }      -&gt; ios
 *     ios.chars                   -&gt; an_enumerator
 *
 *     ios.each_char {|c| block }  -&gt; ios
 *     ios.each_char               -&gt; an_enumerator
 *
 *  Calls the given block once for each character in &lt;em&gt;ios&lt;/em&gt;,
 *  passing the character as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.each_char {|c| print c, ' ' }   #=&gt; #&lt;File:testfile&gt;
 */

static VALUE
rb_io_each_char(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    VALUE c;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    enc = io_input_encoding(fptr);
    READ_CHECK(fptr);
    while (!NIL_P(c = io_getc(fptr, enc))) {
        rb_yield(c);
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_codepoint-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each_codepoint</strong> {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>codepoints</strong> {|c| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each_codepoint</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>codepoints</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Passes the <tt>Integer</tt> ordinal of each character in <em>ios</em>,
passing the codepoint as an argument. The stream must be opened for reading
or an <tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each_codepoint</strong> {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>codepoints</strong> {|c| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>c</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.each_codepoint {|c| block }  -&gt; ios
 *     ios.codepoints     {|c| block }  -&gt; ios
 *     ios.each_codepoint               -&gt; an_enumerator
 *     ios.codepoints                   -&gt; an_enumerator
 *
 *  Passes the &lt;code&gt;Integer&lt;/code&gt; ordinal of each character in &lt;i&gt;ios&lt;/i&gt;,
 *  passing the codepoint as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 */

static VALUE
rb_io_each_codepoint(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;
    unsigned int c;
    int r, n;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    READ_CHECK(fptr);
    if (NEED_READCONV(fptr)) {
    for (;;) {
        make_readconv(fptr, 0);
        for (;;) {
        if (fptr-&gt;cbuf_len) {
            if (fptr-&gt;encs.enc)
            r = rb_enc_precise_mbclen(fptr-&gt;cbuf+fptr-&gt;cbuf_off,
                          fptr-&gt;cbuf+fptr-&gt;cbuf_off+fptr-&gt;cbuf_len,
                          fptr-&gt;encs.enc);
            else
            r = ONIGENC_CONSTRUCT_MBCLEN_CHARFOUND(1);
            if (!MBCLEN_NEEDMORE_P(r))
            break;
            if (fptr-&gt;cbuf_len == fptr-&gt;cbuf_capa) {
            rb_raise(rb_eIOError, &quot;too long character&quot;);
            }
        }
        if (more_char(fptr) == MORE_CHAR_FINISHED) {
                    clear_readconv(fptr);
            /* ignore an incomplete character before EOF */
            return io;
        }
        }
        if (MBCLEN_INVALID_P(r)) {
        rb_raise(rb_eArgError, &quot;invalid byte sequence in %s&quot;,
             rb_enc_name(fptr-&gt;encs.enc));
        }
        n = MBCLEN_CHARFOUND_LEN(r);
        if (fptr-&gt;encs.enc) {
        c = rb_enc_codepoint(fptr-&gt;cbuf+fptr-&gt;cbuf_off,
                     fptr-&gt;cbuf+fptr-&gt;cbuf_off+fptr-&gt;cbuf_len,
                     fptr-&gt;encs.enc);
        }
        else {
        c = (unsigned char)fptr-&gt;cbuf[fptr-&gt;cbuf_off];
        }
        fptr-&gt;cbuf_off += n;
        fptr-&gt;cbuf_len -= n;
        rb_yield(UINT2NUM(c));
    }
    }
    enc = io_input_encoding(fptr);
    for (;;) {
    if (io_fillbuf(fptr) &lt; 0) {
        return io;
    }
    r = rb_enc_precise_mbclen(fptr-&gt;rbuf+fptr-&gt;rbuf_off,
                  fptr-&gt;rbuf+fptr-&gt;rbuf_off+fptr-&gt;rbuf_len, enc);
    if (MBCLEN_CHARFOUND_P(r) &amp;&amp;
        (n = MBCLEN_CHARFOUND_LEN(r)) &lt;= fptr-&gt;rbuf_len) {
        c = rb_enc_codepoint(fptr-&gt;rbuf+fptr-&gt;rbuf_off,
                 fptr-&gt;rbuf+fptr-&gt;rbuf_off+fptr-&gt;rbuf_len, enc);
        fptr-&gt;rbuf_off += n;
        fptr-&gt;rbuf_len -= n;
        rb_yield(UINT2NUM(c));
    }
    else if (MBCLEN_INVALID_P(r)) {
        rb_raise(rb_eArgError, &quot;invalid byte sequence in %s&quot;, rb_enc_name(enc));
    }
    else {
        continue;
    }
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="each_line-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep = $/) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(limit) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep, limit) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each</strong>(...) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
ios.each_line(sep=$/) {|line| block }    -> ios
</p>
<pre class="code">
   ios.each_line(limit) {|line| block }     -&gt; ios
   ios.each_line(sep,limit) {|line| block } -&gt; ios
   ios.each_line(...)                       -&gt; an_enumerator

   ios.lines(sep=$/) {|line| block }        -&gt; ios
   ios.lines(limit) {|line| block }         -&gt; ios
   ios.lines(sep,limit) {|line| block }     -&gt; ios
   ios.lines(...)                           -&gt; an_enumerator
</pre>
<p>
Executes the block for every line in <em>ios</em>, where lines are
separated by <em>sep</em>. <em>ios</em> must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   1: This is line one
   2: This is line two
   3: This is line three
   4: And so on...</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep = $/) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(limit) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep, limit) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.each(sep=$/) {|line| block }         -&gt; ios
 *     ios.each(limit) {|line| block }          -&gt; ios
 *     ios.each(sep,limit) {|line| block }      -&gt; ios
 *     ios.each(...)                            -&gt; an_enumerator
 *
 *     ios.each_line(sep=$/) {|line| block }    -&gt; ios
 *     ios.each_line(limit) {|line| block }     -&gt; ios
 *     ios.each_line(sep,limit) {|line| block } -&gt; ios
 *     ios.each_line(...)                       -&gt; an_enumerator
 *
 *     ios.lines(sep=$/) {|line| block }        -&gt; ios
 *     ios.lines(limit) {|line| block }         -&gt; ios
 *     ios.lines(sep,limit) {|line| block }     -&gt; ios
 *     ios.lines(...)                           -&gt; an_enumerator
 *
 *  Executes the block for every line in &lt;em&gt;ios&lt;/em&gt;, where lines are
 *  separated by &lt;i&gt;sep&lt;/i&gt;. &lt;em&gt;ios&lt;/em&gt; must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     1: This is line one
 *     2: This is line two
 *     3: This is line three
 *     4: And so on...
 */

static VALUE
rb_io_each_line(int argc, VALUE *argv, VALUE io)
{
    VALUE str, rs;
    long limit;

    RETURN_ENUMERATOR(io, argc, argv);
    prepare_getline_args(argc, argv, &amp;rs, &amp;limit, io);
    while (!NIL_P(str = rb_io_getline_1(rs, limit, io))) {
    rb_yield(str);
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eof-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eof</strong> </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eof?</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true if <em>ios</em> is at end of file that means there are no more
data to read. The stream must be opened for reading or an <tt>IOError</tt>
will be raised.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   dummy = f.readlines
   f.eof   #=&gt; true
</pre>
<p>
If <em>ios</em> is a stream such as pipe or socket, <tt>IO#eof?</tt> blocks
until the other end sends some data or closes it.
</p>
<pre class="code">
   r, w = IO.pipe
   Thread.new { sleep 1; w.close }
   r.eof?  #=&gt; true after 1 second blocking

   r, w = IO.pipe
   Thread.new { sleep 1; w.puts &quot;a&quot; }
   r.eof?  #=&gt; false after 1 second blocking

   r, w = IO.pipe
   r.eof?  # blocks forever
</pre>
<p>
Note that <tt>IO#eof?</tt> reads data to the input byte buffer. So
<tt>IO#sysread</tt> may not behave as you intend with <tt>IO#eof?</tt>,
unless you call <tt>IO#rewind</tt> first (which is not available for some
streams).
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eof</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eof?</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.eof     -&gt; true or false
 *     ios.eof?    -&gt; true or false
 *
 *  Returns true if &lt;em&gt;ios&lt;/em&gt; is at end of file that means
 *  there are no more data to read.
 *  The stream must be opened for reading or an &lt;code&gt;IOError&lt;/code&gt; will be
 *  raised.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     dummy = f.readlines
 *     f.eof   #=&gt; true
 *
 *  If &lt;em&gt;ios&lt;/em&gt; is a stream such as pipe or socket, &lt;code&gt;IO#eof?&lt;/code&gt;
 *  blocks until the other end sends some data or closes it.
 *
 *     r, w = IO.pipe
 *     Thread.new { sleep 1; w.close }
 *     r.eof?  #=&gt; true after 1 second blocking
 *
 *     r, w = IO.pipe
 *     Thread.new { sleep 1; w.puts &quot;a&quot; }
 *     r.eof?  #=&gt; false after 1 second blocking
 *
 *     r, w = IO.pipe
 *     r.eof?  # blocks forever
 *
 *  Note that &lt;code&gt;IO#eof?&lt;/code&gt; reads data to the input byte buffer.
 *  So &lt;code&gt;IO#sysread&lt;/code&gt; may not behave as you intend with
 *  &lt;code&gt;IO#eof?&lt;/code&gt;, unless you call &lt;code&gt;IO#rewind&lt;/code&gt;
 *  first (which is not available for some streams).
 */

VALUE
rb_io_eof(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    if (READ_CHAR_PENDING(fptr)) return Qfalse;
    if (READ_DATA_PENDING(fptr)) return Qfalse;
    READ_CHECK(fptr);
    if (io_fillbuf(fptr) &lt; 0) {
    return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="eof?-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eof</strong> </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>eof?</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns true if <em>ios</em> is at end of file that means there are no more
data to read. The stream must be opened for reading or an <tt>IOError</tt>
will be raised.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   dummy = f.readlines
   f.eof   #=&gt; true
</pre>
<p>
If <em>ios</em> is a stream such as pipe or socket, <tt>IO#eof?</tt> blocks
until the other end sends some data or closes it.
</p>
<pre class="code">
   r, w = IO.pipe
   Thread.new { sleep 1; w.close }
   r.eof?  #=&gt; true after 1 second blocking

   r, w = IO.pipe
   Thread.new { sleep 1; w.puts &quot;a&quot; }
   r.eof?  #=&gt; false after 1 second blocking

   r, w = IO.pipe
   r.eof?  # blocks forever
</pre>
<p>
Note that <tt>IO#eof?</tt> reads data to the input byte buffer. So
<tt>IO#sysread</tt> may not behave as you intend with <tt>IO#eof?</tt>,
unless you call <tt>IO#rewind</tt> first (which is not available for some
streams).
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eof</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>eof?</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.eof     -&gt; true or false
 *     ios.eof?    -&gt; true or false
 *
 *  Returns true if &lt;em&gt;ios&lt;/em&gt; is at end of file that means
 *  there are no more data to read.
 *  The stream must be opened for reading or an &lt;code&gt;IOError&lt;/code&gt; will be
 *  raised.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     dummy = f.readlines
 *     f.eof   #=&gt; true
 *
 *  If &lt;em&gt;ios&lt;/em&gt; is a stream such as pipe or socket, &lt;code&gt;IO#eof?&lt;/code&gt;
 *  blocks until the other end sends some data or closes it.
 *
 *     r, w = IO.pipe
 *     Thread.new { sleep 1; w.close }
 *     r.eof?  #=&gt; true after 1 second blocking
 *
 *     r, w = IO.pipe
 *     Thread.new { sleep 1; w.puts &quot;a&quot; }
 *     r.eof?  #=&gt; false after 1 second blocking
 *
 *     r, w = IO.pipe
 *     r.eof?  # blocks forever
 *
 *  Note that &lt;code&gt;IO#eof?&lt;/code&gt; reads data to the input byte buffer.
 *  So &lt;code&gt;IO#sysread&lt;/code&gt; may not behave as you intend with
 *  &lt;code&gt;IO#eof?&lt;/code&gt;, unless you call &lt;code&gt;IO#rewind&lt;/code&gt;
 *  first (which is not available for some streams).
 */

VALUE
rb_io_eof(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    if (READ_CHAR_PENDING(fptr)) return Qfalse;
    if (READ_DATA_PENDING(fptr)) return Qfalse;
    READ_CHECK(fptr);
    if (io_fillbuf(fptr) &lt; 0) {
    return Qtrue;
    }
    return Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="external_encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt>) <strong>external_encoding</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the Encoding object that represents the encoding of the file. If io
is write mode and no encoding is specified, returns <tt>nil</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     io.external_encoding   -&gt; encoding
 *
 *  Returns the Encoding object that represents the encoding of the file.
 *  If io is write mode and no encoding is specified, returns &lt;code&gt;nil&lt;/code&gt;.
 */

static VALUE
rb_io_external_encoding(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (fptr-&gt;encs.enc2) {
    return rb_enc_from_encoding(fptr-&gt;encs.enc2);
    }
    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
    if (fptr-&gt;encs.enc)
        return rb_enc_from_encoding(fptr-&gt;encs.enc);
    return Qnil;
    }
    return rb_enc_from_encoding(io_read_encoding(fptr));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fcntl-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>fcntl</strong>(integer_cmd, arg) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Provides a mechanism for issuing low-level commands to control or query
file-oriented I/O streams. Arguments and results are platform dependent. If
<em>arg</em> is a number, its value is passed directly. If it is a string,
it is interpreted as a binary sequence of bytes (<tt>Array#pack</tt> might
be a useful way to build this string). On Unix platforms, see
<tt>fcntl(2)</tt> for details. Not implemented on all platforms.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.fcntl(integer_cmd, arg)    -&gt; integer
 *
 *  Provides a mechanism for issuing low-level commands to control or
 *  query file-oriented I/O streams. Arguments and results are platform
 *  dependent. If &lt;i&gt;arg&lt;/i&gt; is a number, its value is passed
 *  directly. If it is a string, it is interpreted as a binary sequence
 *  of bytes (&lt;code&gt;Array#pack&lt;/code&gt; might be a useful way to build this
 *  string). On Unix platforms, see &lt;code&gt;fcntl(2)&lt;/code&gt; for details.
 *  Not implemented on all platforms.
 */

static VALUE
rb_io_fcntl(int argc, VALUE *argv, VALUE io)
{
    VALUE req, arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;req, &amp;arg);
    return rb_io_ctl(io, req, arg, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fdatasync-instance_method">
  
    - (<tt>0</tt><sup>?</sup>) <strong>fdatasync</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Immediately writes all buffered data in <em>ios</em> to disk.
</p>
<p>
<tt>NotImplementedError</tt> is raised if the underlying operating system
does not support <em>fdatasync(2)</em>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.fdatasync   -&gt; 0 or nil
 *
 *  Immediately writes all buffered data in &lt;em&gt;ios&lt;/em&gt; to disk.
 *
 *  &lt;code&gt;NotImplementedError&lt;/code&gt; is raised
 *  if the underlying operating system does not support &lt;em&gt;fdatasync(2)&lt;/em&gt;.
 */

static VALUE
rb_io_fdatasync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    if (io_fflush(fptr) &lt; 0)
        rb_sys_fail(0);
    if (fdatasync(fptr-&gt;fd) &lt; 0)
    rb_sys_fail_path(fptr-&gt;pathv);
    return INT2FIX(0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fileno-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>fileno</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>to_i</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns an integer representing the numeric file descriptor for
<em>ios</em>.
</p>
<pre class="code">
   $stdin.fileno    #=&gt; 0
   $stdout.fileno   #=&gt; 1</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>fileno</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>to_i</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.fileno    -&gt; fixnum
 *     ios.to_i      -&gt; fixnum
 *
 *  Returns an integer representing the numeric file descriptor for
 *  &lt;em&gt;ios&lt;/em&gt;.
 *
 *     $stdin.fileno    #=&gt; 0
 *     $stdout.fileno   #=&gt; 1
 */

static VALUE
rb_io_fileno(VALUE io)
{
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = fptr-&gt;fd;
    return INT2FIX(fd);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="flush-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>flush</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Flushes any buffered data within <em>ios</em> to the underlying operating
system (note that this is Ruby internal buffering only; the OS may buffer
the data as well).
</p>
<pre class="code">
   $stdout.print &quot;no newline&quot;
   $stdout.flush
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   no newline</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.flush    -&gt; ios
 *
 *  Flushes any buffered data within &lt;em&gt;ios&lt;/em&gt; to the underlying
 *  operating system (note that this is Ruby internal buffering only;
 *  the OS may buffer the data as well).
 *
 *     $stdout.print &quot;no newline&quot;
 *     $stdout.flush
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     no newline
 */

VALUE
rb_io_flush(VALUE io)
{
    rb_io_t *fptr;

    if (TYPE(io) != T_FILE) {
        return rb_funcall(io, id_flush, 0);
    }

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        if (io_fflush(fptr) &lt; 0)
            rb_sys_fail(0);
#ifdef _WIN32
    fsync(fptr-&gt;fd);
#endif
    }
    if (fptr-&gt;mode &amp; FMODE_READABLE) {
        io_unread(fptr);
    }

    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="fsync-instance_method">
  
    - (<tt>0</tt><sup>?</sup>) <strong>fsync</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Immediately writes all buffered data in <em>ios</em> to disk. Note that
<tt>fsync</tt> differs from using <tt>IO#sync=</tt>. The latter ensures
that data is flushed from Ruby&#8217;s buffers, but doesn&#8217;t not
guarantee that the underlying operating system actually writes it to disk.
</p>
<p>
<tt>NotImplementedError</tt> is raised if the underlying operating system
does not support <em>fsync(2)</em>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.fsync   -&gt; 0 or nil
 *
 *  Immediately writes all buffered data in &lt;em&gt;ios&lt;/em&gt; to disk.
 *  Note that &lt;code&gt;fsync&lt;/code&gt; differs from
 *  using &lt;code&gt;IO#sync=&lt;/code&gt;. The latter ensures that data is flushed
 *  from Ruby's buffers, but doesn't not guarantee that the underlying
 *  operating system actually writes it to disk.
 *
 *  &lt;code&gt;NotImplementedError&lt;/code&gt; is raised
 *  if the underlying operating system does not support &lt;em&gt;fsync(2)&lt;/em&gt;.
 */

static VALUE
rb_io_fsync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);

    if (io_fflush(fptr) &lt; 0)
        rb_sys_fail(0);
    if (fsync(fptr-&gt;fd) &lt; 0)
    rb_sys_fail_path(fptr-&gt;pathv);
    return INT2FIX(0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getbyte-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt><sup>?</sup>) <strong>getbyte</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Gets the next 8-bit byte (0..255) from <em>ios</em>. Returns <tt>nil</tt>
if called at end of file.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.getbyte   #=&gt; 84
   f.getbyte   #=&gt; 104</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.getbyte   -&gt; fixnum or nil
 *
 *  Gets the next 8-bit byte (0..255) from &lt;em&gt;ios&lt;/em&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if called at end of file.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.getbyte   #=&gt; 84
 *     f.getbyte   #=&gt; 104
 */

VALUE
rb_io_getbyte(VALUE io)
{
    rb_io_t *fptr;
    int c;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    READ_CHECK(fptr);
    if (fptr-&gt;fd == 0 &amp;&amp; (fptr-&gt;mode &amp; FMODE_TTY) &amp;&amp; TYPE(rb_stdout) == T_FILE) {
        rb_io_t *ofp;
        GetOpenFile(rb_stdout, ofp);
        if (ofp-&gt;mode &amp; FMODE_TTY) {
            rb_io_flush(rb_stdout);
        }
    }
    if (io_fillbuf(fptr) &lt; 0) {
    return Qnil;
    }
    fptr-&gt;rbuf_off++;
    fptr-&gt;rbuf_len--;
    c = (unsigned char)fptr-&gt;rbuf[fptr-&gt;rbuf_off-1];
    return INT2FIX(c &amp; 0xff);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="getc-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>getc</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads a one-character string from <em>ios</em>. Returns <tt>nil</tt> if
called at end of file.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.getc   #=&gt; &quot;h&quot;
   f.getc   #=&gt; &quot;e&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.getc   -&gt; string or nil
 *
 *  Reads a one-character string from &lt;em&gt;ios&lt;/em&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if called at end of file.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.getc   #=&gt; &quot;h&quot;
 *     f.getc   #=&gt; &quot;e&quot;
 */

static VALUE
rb_io_getc(VALUE io)
{
    rb_io_t *fptr;
    rb_encoding *enc;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);

    enc = io_input_encoding(fptr);
    READ_CHECK(fptr);
    return io_getc(fptr, enc);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="gets-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gets</strong>(sep = $/) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gets</strong>(limit) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gets</strong>(sep, limit) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads the next ``line&#8217;&#8217; from the I/O stream; lines are
separated by <em>sep</em>. A separator of <tt>nil</tt> reads the entire
contents, and a zero-length separator reads the input a paragraph at a time
(two successive newlines in the input separate paragraphs). The stream must
be opened for reading or an <tt>IOError</tt> will be raised. The line read
in will be returned and also assigned to <tt>$_</tt>. Returns <tt>nil</tt>
if called at end of file.  If the first argument is an integer, or optional
second argument is given, the returning string would not be longer than the
given value in bytes.
</p>
<pre class="code">
   File.new(&quot;testfile&quot;).gets   #=&gt; &quot;This is line one\n&quot;
   $_                          #=&gt; &quot;This is line one\n&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gets</strong>(sep = $/) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gets</strong>(limit) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>gets</strong>(sep, limit) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.gets(sep=$/)     -&gt; string or nil
 *     ios.gets(limit)      -&gt; string or nil
 *     ios.gets(sep, limit) -&gt; string or nil
 *
 *  Reads the next ``line'' from the I/O stream; lines are separated by
 *  &lt;i&gt;sep&lt;/i&gt;. A separator of &lt;code&gt;nil&lt;/code&gt; reads the entire
 *  contents, and a zero-length separator reads the input a paragraph at
 *  a time (two successive newlines in the input separate paragraphs).
 *  The stream must be opened for reading or an &lt;code&gt;IOError&lt;/code&gt;
 *  will be raised. The line read in will be returned and also assigned
 *  to &lt;code&gt;$_&lt;/code&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if called at end of
 *  file.  If the first argument is an integer, or optional second
 *  argument is given, the returning string would not be longer than the
 *  given value in bytes.
 *
 *     File.new(&quot;testfile&quot;).gets   #=&gt; &quot;This is line one\n&quot;
 *     $_                          #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_io_gets_m(int argc, VALUE *argv, VALUE io)
{
    VALUE str;

    str = rb_io_getline(argc, argv, io);
    rb_lastline_set(str);

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="initialize_copy-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>initialize_copy</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
:nodoc:
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/* :nodoc: */
static VALUE
rb_io_init_copy(VALUE dest, VALUE io)
{
    rb_io_t *fptr, *orig;
    int fd;
    VALUE write_io;
    off_t pos;

    io = rb_io_get_io(io);
    if (dest == io) return dest;
    GetOpenFile(io, orig);
    MakeOpenFile(dest, fptr);

    rb_io_flush(io);

    /* copy rb_io_t structure */
    fptr-&gt;mode = orig-&gt;mode &amp; ~FMODE_PREP;
    fptr-&gt;encs = orig-&gt;encs;
    fptr-&gt;pid = orig-&gt;pid;
    fptr-&gt;lineno = orig-&gt;lineno;
    if (!NIL_P(orig-&gt;pathv)) fptr-&gt;pathv = orig-&gt;pathv;
    fptr-&gt;finalize = orig-&gt;finalize;
#if defined (__CYGWIN__) || !defined(HAVE_FORK)
    if (fptr-&gt;finalize == pipe_finalize)
    pipe_add_fptr(fptr);
#endif

    fd = ruby_dup(orig-&gt;fd);
    fptr-&gt;fd = fd;
    pos = io_tell(orig);
    if (0 &lt;= pos)
        io_seek(fptr, pos, SEEK_SET);
    if (fptr-&gt;mode &amp; FMODE_BINMODE) {
    rb_io_binmode(dest);
    }

    write_io = GetWriteIO(io);
    if (io != write_io) {
        write_io = rb_obj_dup(write_io);
        fptr-&gt;tied_io_for_writing = write_io;
        rb_ivar_set(dest, rb_intern(&quot;@tied_io_for_writing&quot;), write_io);
    }

    return dest;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="inspect-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>inspect</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Return a string describing this IO object.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 * call-seq:
 *   ios.inspect   -&gt; string
 *
 * Return a string describing this IO object.
 */

static VALUE
rb_io_inspect(VALUE obj)
{
    rb_io_t *fptr;
    const char *cname;
    char fd_desc[4+sizeof(int)*3];
    const char *path;
    const char *st = &quot;&quot;;

    fptr = RFILE(rb_io_taint_check(obj))-&gt;fptr;
    if (!fptr) return rb_any_to_s(obj);
    cname = rb_obj_classname(obj);
    if (NIL_P(fptr-&gt;pathv)) {
        if (fptr-&gt;fd &lt; 0) {
            path = &quot;&quot;;
            st = &quot;(closed)&quot;;
        }
        else {
            snprintf(fd_desc, sizeof(fd_desc), &quot;fd %d&quot;, fptr-&gt;fd);
            path = fd_desc;
        }
    }
    else {
        path = RSTRING_PTR(fptr-&gt;pathv);
        if (fptr-&gt;fd &lt; 0) {
            st = &quot; (closed)&quot;;
        }
    }
    return rb_sprintf(&quot;#&lt;%s:%s%s&gt;&quot;, cname, path, st);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="internal_encoding-instance_method">
  
    - (<tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt>) <strong>internal_encoding</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the Encoding of the internal string if conversion is specified. 
Otherwise returns nil.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     io.internal_encoding   -&gt; encoding
 *
 *  Returns the Encoding of the internal string if conversion is
 *  specified.  Otherwise returns nil.
 */

static VALUE
rb_io_internal_encoding(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!fptr-&gt;encs.enc2) return Qnil;
    return rb_enc_from_encoding(io_read_encoding(fptr));
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ioctl-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>ioctl</strong>(integer_cmd, arg) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Provides a mechanism for issuing low-level commands to control or query I/O
devices. Arguments and results are platform dependent. If <em>arg</em> is a
number, its value is passed directly. If it is a string, it is interpreted
as a binary sequence of bytes. On Unix platforms, see <tt>ioctl(2)</tt> for
details. Not implemented on all platforms.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.ioctl(integer_cmd, arg)    -&gt; integer
 *
 *  Provides a mechanism for issuing low-level commands to control or
 *  query I/O devices. Arguments and results are platform dependent. If
 *  &lt;i&gt;arg&lt;/i&gt; is a number, its value is passed directly. If it is a
 *  string, it is interpreted as a binary sequence of bytes. On Unix
 *  platforms, see &lt;code&gt;ioctl(2)&lt;/code&gt; for details. Not implemented on
 *  all platforms.
 */

static VALUE
rb_io_ioctl(int argc, VALUE *argv, VALUE io)
{
    VALUE req, arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;req, &amp;arg);
    return rb_io_ctl(io, req, arg, 1);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="isatty-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>isatty</strong> </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>tty?</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <em>ios</em> is associated with a terminal device
(tty), <tt>false</tt> otherwise.
</p>
<pre class="code">
   File.new(&quot;testfile&quot;).isatty   #=&gt; false
   File.new(&quot;/dev/tty&quot;).isatty   #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>isatty</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>tty?</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.isatty   -&gt; true or false
 *     ios.tty?     -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;ios&lt;/em&gt; is associated with a
 *  terminal device (tty), &lt;code&gt;false&lt;/code&gt; otherwise.
 *
 *     File.new(&quot;testfile&quot;).isatty   #=&gt; false
 *     File.new(&quot;/dev/tty&quot;).isatty   #=&gt; true
 */

static VALUE
rb_io_isatty(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (isatty(fptr-&gt;fd) == 0)
    return Qfalse;
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lineno-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>lineno</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the current line number in <em>ios</em>. The stream must be opened
for reading. <tt>lineno</tt> counts the number of times <tt>gets</tt> is
called, rather than the number of newlines encountered. The two values will
differ if <tt>gets</tt> is called with a separator other than newline. See
also the <tt>$.</tt> variable.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.lineno   #=&gt; 0
   f.gets     #=&gt; &quot;This is line one\n&quot;
   f.lineno   #=&gt; 1
   f.gets     #=&gt; &quot;This is line two\n&quot;
   f.lineno   #=&gt; 2</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.lineno    -&gt; integer
 *
 *  Returns the current line number in &lt;em&gt;ios&lt;/em&gt;. The stream must be
 *  opened for reading. &lt;code&gt;lineno&lt;/code&gt; counts the number of times
 *  &lt;code&gt;gets&lt;/code&gt; is called, rather than the number of newlines
 *  encountered. The two values will differ if &lt;code&gt;gets&lt;/code&gt; is
 *  called with a separator other than newline. See also the
 *  &lt;code&gt;$.&lt;/code&gt; variable.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.lineno   #=&gt; 0
 *     f.gets     #=&gt; &quot;This is line one\n&quot;
 *     f.lineno   #=&gt; 1
 *     f.gets     #=&gt; &quot;This is line two\n&quot;
 *     f.lineno   #=&gt; 2
 */

static VALUE
rb_io_lineno(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    return INT2NUM(fptr-&gt;lineno);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lineno=-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>lineno=</strong>(integer) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Manually sets the current line number to the given value. <tt>$.</tt> is
updated only on the next read.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.gets                     #=&gt; &quot;This is line one\n&quot;
   $.                         #=&gt; 1
   f.lineno = 1000
   f.lineno                   #=&gt; 1000
   $.                         #=&gt; 1         # lineno of last read
   f.gets                     #=&gt; &quot;This is line two\n&quot;
   $.                         #=&gt; 1001      # lineno of last read</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.lineno = integer    -&gt; integer
 *
 *  Manually sets the current line number to the given value.
 *  &lt;code&gt;$.&lt;/code&gt; is updated only on the next read.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.gets                     #=&gt; &quot;This is line one\n&quot;
 *     $.                         #=&gt; 1
 *     f.lineno = 1000
 *     f.lineno                   #=&gt; 1000
 *     $.                         #=&gt; 1         # lineno of last read
 *     f.gets                     #=&gt; &quot;This is line two\n&quot;
 *     $.                         #=&gt; 1001      # lineno of last read
 */

static VALUE
rb_io_set_lineno(VALUE io, VALUE lineno)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    fptr-&gt;lineno = NUM2INT(lineno);
    return lineno;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="lines-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep = $/) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(limit) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep, limit) {|line| ... }</span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>each</strong>(...) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
ios.each_line(sep=$/) {|line| block }    -> ios
</p>
<pre class="code">
   ios.each_line(limit) {|line| block }     -&gt; ios
   ios.each_line(sep,limit) {|line| block } -&gt; ios
   ios.each_line(...)                       -&gt; an_enumerator

   ios.lines(sep=$/) {|line| block }        -&gt; ios
   ios.lines(limit) {|line| block }         -&gt; ios
   ios.lines(sep,limit) {|line| block }     -&gt; ios
   ios.lines(...)                           -&gt; an_enumerator
</pre>
<p>
Executes the block for every line in <em>ios</em>, where lines are
separated by <em>sep</em>. <em>ios</em> must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<p>
If no block is given, an enumerator is returned instead.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   1: This is line one
   2: This is line two
   3: This is line three
   4: And so on...</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep = $/) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(limit) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>each</strong>(sep, limit) {|line| ... }</span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Yields:</h3>
<ul class="yield">
  
    <li>
      
        <span class='type'>(<tt>line</tt>)</span>
      
      
      
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.each(sep=$/) {|line| block }         -&gt; ios
 *     ios.each(limit) {|line| block }          -&gt; ios
 *     ios.each(sep,limit) {|line| block }      -&gt; ios
 *     ios.each(...)                            -&gt; an_enumerator
 *
 *     ios.each_line(sep=$/) {|line| block }    -&gt; ios
 *     ios.each_line(limit) {|line| block }     -&gt; ios
 *     ios.each_line(sep,limit) {|line| block } -&gt; ios
 *     ios.each_line(...)                       -&gt; an_enumerator
 *
 *     ios.lines(sep=$/) {|line| block }        -&gt; ios
 *     ios.lines(limit) {|line| block }         -&gt; ios
 *     ios.lines(sep,limit) {|line| block }     -&gt; ios
 *     ios.lines(...)                           -&gt; an_enumerator
 *
 *  Executes the block for every line in &lt;em&gt;ios&lt;/em&gt;, where lines are
 *  separated by &lt;i&gt;sep&lt;/i&gt;. &lt;em&gt;ios&lt;/em&gt; must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *  If no block is given, an enumerator is returned instead.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     1: This is line one
 *     2: This is line two
 *     3: This is line three
 *     4: And so on...
 */

static VALUE
rb_io_each_line(int argc, VALUE *argv, VALUE io)
{
    VALUE str, rs;
    long limit;

    RETURN_ENUMERATOR(io, argc, argv);
    prepare_getline_args(argc, argv, &amp;rs, &amp;limit, io);
    while (!NIL_P(str = rb_io_getline_1(rs, limit, io))) {
    rb_yield(str);
    }
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pid-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>pid</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the process ID of a child process associated with <em>ios</em>.
This will be set by <tt>IO.popen</tt>.
</p>
<pre class="code">
   pipe = IO.popen(&quot;-&quot;)
   if pipe
     $stderr.puts &quot;In parent, child pid is #{pipe.pid}&quot;
   else
     $stderr.puts &quot;In child, pid is #{$$}&quot;
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   In child, pid is 26209
   In parent, child pid is 26209</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.pid    -&gt; fixnum
 *
 *  Returns the process ID of a child process associated with
 *  &lt;em&gt;ios&lt;/em&gt;. This will be set by &lt;code&gt;IO.popen&lt;/code&gt;.
 *
 *     pipe = IO.popen(&quot;-&quot;)
 *     if pipe
 *       $stderr.puts &quot;In parent, child pid is #{pipe.pid}&quot;
 *     else
 *       $stderr.puts &quot;In child, pid is #{$$}&quot;
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     In child, pid is 26209
 *     In parent, child pid is 26209
 */

static VALUE
rb_io_pid(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!fptr-&gt;pid)
    return Qnil;
    return PIDT2NUM(fptr-&gt;pid);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pos-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>pos</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>tell</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the current offset (in bytes) of <em>ios</em>.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.pos    #=&gt; 0
   f.gets   #=&gt; &quot;This is line one\n&quot;
   f.pos    #=&gt; 17</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>pos</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>tell</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.pos     -&gt; integer
 *     ios.tell    -&gt; integer
 *
 *  Returns the current offset (in bytes) of &lt;em&gt;ios&lt;/em&gt;.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.pos    #=&gt; 0
 *     f.gets   #=&gt; &quot;This is line one\n&quot;
 *     f.pos    #=&gt; 17
 */

static VALUE
rb_io_tell(VALUE io)
{
    rb_io_t *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_tell(fptr);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    pos -= fptr-&gt;rbuf_len;
    return OFFT2NUM(pos);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="pos=-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>pos=</strong>(integer) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Seeks to the given position (in bytes) in <em>ios</em>.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.pos = 17
   f.gets   #=&gt; &quot;This is line two\n&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.pos = integer    -&gt; integer
 *
 *  Seeks to the given position (in bytes) in &lt;em&gt;ios&lt;/em&gt;.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.pos = 17
 *     f.gets   #=&gt; &quot;This is line two\n&quot;
 */

static VALUE
rb_io_set_pos(VALUE io, VALUE offset)
{
    rb_io_t *fptr;
    off_t pos;

    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    pos = io_seek(fptr, pos, SEEK_SET);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

    return OFFT2NUM(pos);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="print-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>print</strong> </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>print</strong>(obj, ...) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Writes the given object(s) to <em>ios</em>. The stream must be opened for
writing. If the output field separator (<tt>$,</tt>) is not <tt>nil</tt>,
it will be inserted between each object. If the output record separator
(<tt>$\</tt>) is not <tt>nil</tt>, it will be appended to the output. If no
arguments are given, prints <tt>$_</tt>. Objects that aren&#8217;t strings
will be converted by calling their <tt>to_s</tt> method. With no argument,
prints the contents of the variable <tt>$_</tt>. Returns <tt>nil</tt>.
</p>
<pre class="code">
   $stdout.print(&quot;This is &quot;, 100, &quot; percent.\n&quot;)
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   This is 100 percent.</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>print</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>print</strong>(obj, ...) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.print()             -&gt; nil
 *     ios.print(obj, ...)     -&gt; nil
 *
 *  Writes the given object(s) to &lt;em&gt;ios&lt;/em&gt;. The stream must be
 *  opened for writing. If the output field separator (&lt;code&gt;$,&lt;/code&gt;)
 *  is not &lt;code&gt;nil&lt;/code&gt;, it will be inserted between each object.
 *  If the output record separator (&lt;code&gt;$\\&lt;/code&gt;)
 *  is not &lt;code&gt;nil&lt;/code&gt;, it will be appended to the output. If no
 *  arguments are given, prints &lt;code&gt;$_&lt;/code&gt;. Objects that aren't
 *  strings will be converted by calling their &lt;code&gt;to_s&lt;/code&gt; method.
 *  With no argument, prints the contents of the variable &lt;code&gt;$_&lt;/code&gt;.
 *  Returns &lt;code&gt;nil&lt;/code&gt;.
 *
 *     $stdout.print(&quot;This is &quot;, 100, &quot; percent.\n&quot;)
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     This is 100 percent.
 */

VALUE
rb_io_print(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print `$_' */
    if (argc == 0) {
    argc = 1;
    line = rb_lastline_get();
    argv = &amp;line;
    }
    for (i=0; i&lt;argc; i++) {
    if (!NIL_P(rb_output_fs) &amp;&amp; i&gt;0) {
        rb_io_write(out, rb_output_fs);
    }
    rb_io_write(out, argv[i]);
    }
    if (argc &gt; 0 &amp;&amp; !NIL_P(rb_output_rs)) {
    rb_io_write(out, rb_output_rs);
    }

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="printf-instance_method">
  
    - (<tt>nil</tt>) <strong>printf</strong>(format_string[, obj, ...]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Formats and writes to <em>ios</em>, converting parameters under control of
the format string. See <tt>Kernel#sprintf</tt> for details.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.printf(format_string [, obj, ...] )   -&gt; nil
 *
 *  Formats and writes to &lt;em&gt;ios&lt;/em&gt;, converting parameters under
 *  control of the format string. See &lt;code&gt;Kernel#sprintf&lt;/code&gt;
 *  for details.
 */

VALUE
rb_io_printf(int argc, VALUE *argv, VALUE out)
{
    rb_io_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="putc-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>putc</strong>(obj) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
If <em>obj</em> is <tt>Numeric</tt>, write the character whose code is the
least-significant byte of <em>obj</em>, otherwise write the first byte of
the string representation of <em>obj</em> to <em>ios</em>. Note: This
method is not safe for use with multi-byte characters as it will truncate
them.
</p>
<pre class="code">
   $stdout.putc &quot;A&quot;
   $stdout.putc 65
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   AA</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.putc(obj)    -&gt; obj
 *
 *  If &lt;i&gt;obj&lt;/i&gt; is &lt;code&gt;Numeric&lt;/code&gt;, write the character whose code is
 *  the least-significant byte of &lt;i&gt;obj&lt;/i&gt;, otherwise write the first byte
 *  of the string representation of &lt;i&gt;obj&lt;/i&gt; to &lt;em&gt;ios&lt;/em&gt;. Note: This
 *  method is not safe for use with multi-byte characters as it will truncate
 *  them.
 *
 *     $stdout.putc &quot;A&quot;
 *     $stdout.putc 65
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     AA
 */

static VALUE
rb_io_putc(VALUE io, VALUE ch)
{
    char c = NUM2CHR(ch);

    rb_io_write(io, rb_str_new(&amp;c, 1));
    return ch;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="puts-instance_method">
  
    - (<tt>nil</tt>) <strong>puts</strong>(obj, ...) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Writes the given objects to <em>ios</em> as with <tt>IO#print</tt>. Writes
a record separator (typically a newline) after any that do not already end
with a newline sequence. If called with an array argument, writes each
element on a new line. If called without arguments, outputs a single record
separator.
</p>
<pre class="code">
   $stdout.puts(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;)
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   this
   is
   a
   test</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.puts(obj, ...)    -&gt; nil
 *
 *  Writes the given objects to &lt;em&gt;ios&lt;/em&gt; as with
 *  &lt;code&gt;IO#print&lt;/code&gt;. Writes a record separator (typically a
 *  newline) after any that do not already end with a newline sequence.
 *  If called with an array argument, writes each element on a new line.
 *  If called without arguments, outputs a single record separator.
 *
 *     $stdout.puts(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;)
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     this
 *     is
 *     a
 *     test
 */

VALUE
rb_io_puts(int argc, VALUE *argv, VALUE out)
{
    int i;
    VALUE line;

    /* if no argument given, print newline. */
    if (argc == 0) {
    rb_io_write(out, rb_default_rs);
    return Qnil;
    }
    for (i=0; i&lt;argc; i++) {
    if (TYPE(argv[i]) == T_STRING) {
        line = argv[i];
        goto string;
    }
    line = rb_check_array_type(argv[i]);
    if (!NIL_P(line)) {
        rb_exec_recursive(io_puts_ary, line, out);
        continue;
    }
    line = rb_obj_as_string(argv[i]);
      string:
    rb_io_write(out, line);
    if (RSTRING_LEN(line) == 0 ||
            RSTRING_PTR(line)[RSTRING_LEN(line)-1] != '\n') {
        rb_io_write(out, rb_default_rs);
    }
    }

    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt><sup>?</sup>) <strong>read</strong>([length [, buffer]]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads <em>length</em> bytes from the I/O stream.
</p>
<p>
<em>length</em> must be a non-negative integer or <tt>nil</tt>.
</p>
<p>
If <em>length</em> is a positive integer, it try to read <em>length</em>
bytes without any conversion (binary mode). It returns <tt>nil</tt> or a
string whose length is 1 to <em>length</em> bytes. <tt>nil</tt> means it
met EOF at beginning. The 1 to <em>length</em>-1 bytes string means it met
EOF after reading the result. The <em>length</em> bytes string means it
doesn&#8217;t meet EOF. The resulted string is always ASCII-8BIT encoding.
</p>
<p>
If <em>length</em> is omitted or is <tt>nil</tt>, it reads until EOF and
the encoding conversion is applied. It returns a string even if EOF is met
at beginning.
</p>
<p>
If <em>length</em> is zero, it returns <tt>&quot;&quot;</tt>.
</p>
<p>
If the optional <em>buffer</em> argument is present, it must reference a
String, which will receive the data.
</p>
<p>
At end of file, it returns <tt>nil</tt> or <tt>&quot;&quot;</tt> depend on
<em>length</em>. <tt><em>ios</em>.read()</tt> and
<tt><em>ios</em>.read(nil)</tt> returns <tt>&quot;&quot;</tt>.
<tt><em>ios</em>.read(<em>positive-integer</em>)</tt> returns <tt>nil</tt>.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.read(16)   #=&gt; &quot;This is line one&quot;

   # reads whole file
   open(&quot;file&quot;) {|f|
     data = f.read # This returns a string even if the file is empty.
     ...
   }

   # iterate over fixed length records.
   open(&quot;fixed-record-file&quot;) {|f|
     while record = f.read(256)
       ...
     end
   }

   # iterate over variable length records.
   # record is prefixed by 32-bit length.
   open(&quot;variable-record-file&quot;) {|f|
     while len = f.read(4)
       len = len.unpack(&quot;N&quot;)[0] # 32-bit length
       record = f.read(len) # This returns a string even if len is 0.
     end
   }
</pre>
<p>
Note that this method behaves like fread() function in C. If you need the
behavior like read(2) system call, consider readpartial, read_nonblock and
sysread.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.read([length [, buffer]])    -&gt; string, buffer, or nil
 *
 *  Reads &lt;i&gt;length&lt;/i&gt; bytes from the I/O stream.
 *
 *  &lt;i&gt;length&lt;/i&gt; must be a non-negative integer or &lt;code&gt;nil&lt;/code&gt;.
 *
 *  If &lt;i&gt;length&lt;/i&gt; is a positive integer,
 *  it try to read &lt;i&gt;length&lt;/i&gt; bytes without any conversion (binary mode).
 *  It returns &lt;code&gt;nil&lt;/code&gt; or a string whose length is 1 to &lt;i&gt;length&lt;/i&gt; bytes.
 *  &lt;code&gt;nil&lt;/code&gt; means it met EOF at beginning.
 *  The 1 to &lt;i&gt;length&lt;/i&gt;-1 bytes string means it met EOF after reading the result.
 *  The &lt;i&gt;length&lt;/i&gt; bytes string means it doesn't meet EOF.
 *  The resulted string is always ASCII-8BIT encoding.
 *
 *  If &lt;i&gt;length&lt;/i&gt; is omitted or is &lt;code&gt;nil&lt;/code&gt;,
 *  it reads until EOF and the encoding conversion is applied.
 *  It returns a string even if EOF is met at beginning.
 *
 *  If &lt;i&gt;length&lt;/i&gt; is zero, it returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.
 *
 *  If the optional &lt;i&gt;buffer&lt;/i&gt; argument is present, it must reference
 *  a String, which will receive the data.
 *
 *  At end of file, it returns &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt;
 *  depend on &lt;i&gt;length&lt;/i&gt;.
 *  &lt;code&gt;&lt;i&gt;ios&lt;/i&gt;.read()&lt;/code&gt; and
 *  &lt;code&gt;&lt;i&gt;ios&lt;/i&gt;.read(nil)&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.
 *  &lt;code&gt;&lt;i&gt;ios&lt;/i&gt;.read(&lt;i&gt;positive-integer&lt;/i&gt;)&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt;.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.read(16)   #=&gt; &quot;This is line one&quot;
 *
 *     # reads whole file
 *     open(&quot;file&quot;) {|f|
 *       data = f.read # This returns a string even if the file is empty.
 *       ...
 *     }
 *
 *     # iterate over fixed length records.
 *     open(&quot;fixed-record-file&quot;) {|f|
 *       while record = f.read(256)
 *         ...
 *       end
 *     }
 *
 *     # iterate over variable length records.
 *     # record is prefixed by 32-bit length.
 *     open(&quot;variable-record-file&quot;) {|f|
 *       while len = f.read(4)
 *         len = len.unpack(&quot;N&quot;)[0] # 32-bit length
 *         record = f.read(len) # This returns a string even if len is 0.
 *       end
 *     }
 *
 *  Note that this method behaves like fread() function in C.
 *  If you need the behavior like read(2) system call,
 *  consider readpartial, read_nonblock and sysread.
 */

static VALUE
io_read(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr;
    long n, len;
    VALUE length, str;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;length, &amp;str);

    if (NIL_P(length)) {
    if (!NIL_P(str)) StringValue(str);
    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    return read_all(fptr, remain_size(fptr), str);
    }
    len = NUM2LONG(length);
    if (len &lt; 0) {
    rb_raise(rb_eArgError, &quot;negative length %ld given&quot;, len);
    }

    if (NIL_P(str)) {
    str = rb_str_new(0, len);
    }
    else {
    StringValue(str);
    rb_str_modify(str);
    rb_str_resize(str,len);
    }

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    if (len == 0) return str;

    READ_CHECK(fptr);
    n = io_fread(str, 0, fptr);
    if (n == 0) {
    if (fptr-&gt;fd &lt; 0) return Qnil;
        rb_str_resize(str, 0);
        return Qnil;
    }
    rb_str_resize(str, n);
    OBJ_TAINT(str);

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_nonblock-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>read_nonblock</strong>(maxlen) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>read_nonblock</strong>(maxlen, outbuf) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads at most <em>maxlen</em> bytes from <em>ios</em> using the read(2)
system call after O_NONBLOCK is set for the underlying file descriptor.
</p>
<p>
If the optional <em>outbuf</em> argument is present, it must reference a
String, which will receive the data.
</p>
<p>
read_nonblock just calls the read(2) system call. It causes all errors the
read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The
caller should care such errors.
</p>
<p>
If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions
for retrying read_nonblock.
</p>
<p>
read_nonblock causes EOFError on EOF.
</p>
<p>
If the read byte buffer is not empty, read_nonblock reads from the buffer
like readpartial. In this case, the read(2) system call is not called.
</p>
<p>
When read_nonblock raises an exception kind of IO::WaitReadable,
read_nonblock should not be called until io is readable for avoiding busy
loop. This can be done as follows.
</p>
<pre class="code">
  # emulates blocking read (readpartial).
  begin
    result = io.read_nonblock(maxlen)
  rescue IO::WaitReadable
    IO.select([io])
    retry
  end
</pre>
<p>
Although IO#read_nonblock doesn&#8217;t raise IO::WaitWritable.
OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable. If IO and SSL
should be used polymorphically, IO::WaitWritable should be rescued too. See
the document of OpenSSL::Buffering#read_nonblock for sample code.
</p>
<p>
Note that this method is identical to readpartial except the non-blocking
flag is set.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>read_nonblock</strong>(maxlen) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.read_nonblock(maxlen)              -&gt; string
 *     ios.read_nonblock(maxlen, outbuf)      -&gt; outbuf
 *
 *  Reads at most &lt;i&gt;maxlen&lt;/i&gt; bytes from &lt;em&gt;ios&lt;/em&gt; using
 *  the read(2) system call after O_NONBLOCK is set for
 *  the underlying file descriptor.
 *
 *  If the optional &lt;i&gt;outbuf&lt;/i&gt; argument is present,
 *  it must reference a String, which will receive the data.
 *
 *  read_nonblock just calls the read(2) system call.
 *  It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc.
 *  The caller should care such errors.
 *
 *  If the exception is Errno::EWOULDBLOCK or Errno::AGAIN,
 *  it is extended by IO::WaitReadable.
 *  So IO::WaitReadable can be used to rescue the exceptions for retrying read_nonblock.
 *
 *  read_nonblock causes EOFError on EOF.
 *
 *  If the read byte buffer is not empty,
 *  read_nonblock reads from the buffer like readpartial.
 *  In this case, the read(2) system call is not called.
 *
 *  When read_nonblock raises an exception kind of IO::WaitReadable,
 *  read_nonblock should not be called
 *  until io is readable for avoiding busy loop.
 *  This can be done as follows.
 *
 *    # emulates blocking read (readpartial).
 *    begin
 *      result = io.read_nonblock(maxlen)
 *    rescue IO::WaitReadable
 *      IO.select([io])
 *      retry
 *    end
 *
 *  Although IO#read_nonblock doesn't raise IO::WaitWritable.
 *  OpenSSL::Buffering#read_nonblock can raise IO::WaitWritable.
 *  If IO and SSL should be used polymorphically,
 *  IO::WaitWritable should be rescued too.
 *  See the document of OpenSSL::Buffering#read_nonblock for sample code.
 *
 *  Note that this method is identical to readpartial
 *  except the non-blocking flag is set.
 */

static VALUE
io_read_nonblock(int argc, VALUE *argv, VALUE io)
{
    VALUE ret;

    ret = io_getpartial(argc, argv, io, 1);
    if (NIL_P(ret))
        rb_eof_error();
    else
        return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="readbyte-instance_method">
  
    - (<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>) <strong>readbyte</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads a byte as with <tt>IO#getbyte</tt>, but raises an <tt>EOFError</tt>
on end of file.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Fixnum.html" title="Fixnum (class)">Fixnum</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.readbyte   -&gt; fixnum
 *
 *  Reads a byte as with &lt;code&gt;IO#getbyte&lt;/code&gt;, but raises an
 *  &lt;code&gt;EOFError&lt;/code&gt; on end of file.
 */

static VALUE
rb_io_readbyte(VALUE io)
{
    VALUE c = rb_io_getbyte(io);

    if (NIL_P(c)) {
    rb_eof_error();
    }
    return c;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="readchar-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readchar</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads a one-character string from <em>ios</em>. Raises an <tt>EOFError</tt>
on end of file.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.readchar   #=&gt; &quot;h&quot;
   f.readchar   #=&gt; &quot;e&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.readchar   -&gt; string
 *
 *  Reads a one-character string from &lt;em&gt;ios&lt;/em&gt;. Raises an
 *  &lt;code&gt;EOFError&lt;/code&gt; on end of file.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.readchar   #=&gt; &quot;h&quot;
 *     f.readchar   #=&gt; &quot;e&quot;
 */

static VALUE
rb_io_readchar(VALUE io)
{
    VALUE c = rb_io_getc(io);

    if (NIL_P(c)) {
    rb_eof_error();
    }
    return c;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="readline-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readline</strong>(sep = $/) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readline</strong>(limit) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readline</strong>(sep, limit) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads a line as with <tt>IO#gets</tt>, but raises an <tt>EOFError</tt> on
end of file.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readline</strong>(sep = $/) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readline</strong>(limit) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readline</strong>(sep, limit) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.readline(sep=$/)     -&gt; string
 *     ios.readline(limit)      -&gt; string
 *     ios.readline(sep, limit) -&gt; string
 *
 *  Reads a line as with &lt;code&gt;IO#gets&lt;/code&gt;, but raises an
 *  &lt;code&gt;EOFError&lt;/code&gt; on end of file.
 */

static VALUE
rb_io_readline(int argc, VALUE *argv, VALUE io)
{
    VALUE line = rb_io_gets_m(argc, argv, io);

    if (NIL_P(line)) {
    rb_eof_error();
    }
    return line;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="readlines-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(sep = $/) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(limit) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(sep, limit) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads all of the lines in <em>ios</em>, and returns them in
<em>anArray</em>. Lines are separated by the optional <em>sep</em>. If
<em>sep</em> is <tt>nil</tt>, the rest of the stream is returned as a
single record.  If the first argument is an integer, or optional second
argument is given, the returning string would not be longer than the given
value in bytes. The stream must be opened for reading or an
<tt>IOError</tt> will be raised.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.readlines[0]   #=&gt; &quot;This is line one\n&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(sep = $/) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(limit) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>) <strong>readlines</strong>(sep, limit) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">Array</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.readlines(sep=$/)     -&gt; array
 *     ios.readlines(limit)      -&gt; array
 *     ios.readlines(sep, limit) -&gt; array
 *
 *  Reads all of the lines in &lt;em&gt;ios&lt;/em&gt;, and returns them in
 *  &lt;i&gt;anArray&lt;/i&gt;. Lines are separated by the optional &lt;i&gt;sep&lt;/i&gt;. If
 *  &lt;i&gt;sep&lt;/i&gt; is &lt;code&gt;nil&lt;/code&gt;, the rest of the stream is returned
 *  as a single record.  If the first argument is an integer, or
 *  optional second argument is given, the returning string would not be
 *  longer than the given value in bytes. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.readlines[0]   #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_io_readlines(int argc, VALUE *argv, VALUE io)
{
    VALUE line, ary, rs;
    long limit;

    prepare_getline_args(argc, argv, &amp;rs, &amp;limit, io);
    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_getline_1(rs, limit, io))) {
    rb_ary_push(ary, line);
    }
    return ary;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="readpartial-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readpartial</strong>(maxlen) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>readpartial</strong>(maxlen, outbuf) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads at most <em>maxlen</em> bytes from the I/O stream. It blocks only if
<em>ios</em> has no data immediately available. It doesn&#8217;t block if
some data available. If the optional <em>outbuf</em> argument is present,
it must reference a String, which will receive the data. It raises
<tt>EOFError</tt> on end of file.
</p>
<p>
readpartial is designed for streams such as pipe, socket, tty, etc. It
blocks only when no data immediately available. This means that it blocks
only when following all conditions hold.
</p>
<ul>
<li><p>
the byte buffer in the IO object is empty.
</p>
</li>
<li><p>
the content of the stream is empty.
</p>
</li>
<li><p>
the stream is not reached to EOF.
</p>
</li>
</ul>
<p>
When readpartial blocks, it waits data or EOF on the stream. If some data
is reached, readpartial returns with the data. If EOF is reached,
readpartial raises EOFError.
</p>
<p>
When readpartial doesn&#8217;t blocks, it returns or raises immediately. If
the byte buffer is not empty, it returns the data in the buffer. Otherwise
if the stream has some content, it returns the data in the stream.
Otherwise if the stream is reached to EOF, it raises EOFError.
</p>
<pre class="code">
   r, w = IO.pipe           #               buffer          pipe content
   w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;.
   r.readpartial(4096)      #=&gt; &quot;abc&quot;       &quot;&quot;              &quot;&quot;
   r.readpartial(4096)      # blocks because buffer and pipe is empty.

   r, w = IO.pipe           #               buffer          pipe content
   w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;
   w.close                  #               &quot;&quot;              &quot;abc&quot; EOF
   r.readpartial(4096)      #=&gt; &quot;abc&quot;       &quot;&quot;              EOF
   r.readpartial(4096)      # raises EOFError

   r, w = IO.pipe           #               buffer          pipe content
   w &lt;&lt; &quot;abc\ndef\n&quot;        #               &quot;&quot;              &quot;abc\ndef\n&quot;
   r.gets                   #=&gt; &quot;abc\n&quot;     &quot;def\n&quot;         &quot;&quot;
   w &lt;&lt; &quot;ghi\n&quot;             #               &quot;def\n&quot;         &quot;ghi\n&quot;
   r.readpartial(4096)      #=&gt; &quot;def\n&quot;     &quot;&quot;              &quot;ghi\n&quot;
   r.readpartial(4096)      #=&gt; &quot;ghi\n&quot;     &quot;&quot;              &quot;&quot;
</pre>
<p>
Note that readpartial behaves similar to sysread. The differences are:
</p>
<ul>
<li><p>
If the byte buffer is not empty, read from the byte buffer instead of
&#8220;sysread for buffered IO (IOError)&#8221;.
</p>
</li>
<li><p>
It doesn&#8217;t cause Errno::EWOULDBLOCK and Errno::EINTR.  When
readpartial meets EWOULDBLOCK and EINTR by read system call, readpartial
retry the system call.
</p>
</li>
</ul>
<p>
The later means that readpartial is nonblocking-flag insensitive. It blocks
on the situation IO#sysread causes Errno::EWOULDBLOCK as if the fd is
blocking mode.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>readpartial</strong>(maxlen) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.readpartial(maxlen)              -&gt; string
 *     ios.readpartial(maxlen, outbuf)      -&gt; outbuf
 *
 *  Reads at most &lt;i&gt;maxlen&lt;/i&gt; bytes from the I/O stream.
 *  It blocks only if &lt;em&gt;ios&lt;/em&gt; has no data immediately available.
 *  It doesn't block if some data available.
 *  If the optional &lt;i&gt;outbuf&lt;/i&gt; argument is present,
 *  it must reference a String, which will receive the data.
 *  It raises &lt;code&gt;EOFError&lt;/code&gt; on end of file.
 *
 *  readpartial is designed for streams such as pipe, socket, tty, etc.
 *  It blocks only when no data immediately available.
 *  This means that it blocks only when following all conditions hold.
 *  * the byte buffer in the IO object is empty.
 *  * the content of the stream is empty.
 *  * the stream is not reached to EOF.
 *
 *  When readpartial blocks, it waits data or EOF on the stream.
 *  If some data is reached, readpartial returns with the data.
 *  If EOF is reached, readpartial raises EOFError.
 *
 *  When readpartial doesn't blocks, it returns or raises immediately.
 *  If the byte buffer is not empty, it returns the data in the buffer.
 *  Otherwise if the stream has some content,
 *  it returns the data in the stream.
 *  Otherwise if the stream is reached to EOF, it raises EOFError.
 *
 *     r, w = IO.pipe           #               buffer          pipe content
 *     w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;.
 *     r.readpartial(4096)      #=&gt; &quot;abc&quot;       &quot;&quot;              &quot;&quot;
 *     r.readpartial(4096)      # blocks because buffer and pipe is empty.
 *
 *     r, w = IO.pipe           #               buffer          pipe content
 *     w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;
 *     w.close                  #               &quot;&quot;              &quot;abc&quot; EOF
 *     r.readpartial(4096)      #=&gt; &quot;abc&quot;       &quot;&quot;              EOF
 *     r.readpartial(4096)      # raises EOFError
 *
 *     r, w = IO.pipe           #               buffer          pipe content
 *     w &lt;&lt; &quot;abc\ndef\n&quot;        #               &quot;&quot;              &quot;abc\ndef\n&quot;
 *     r.gets                   #=&gt; &quot;abc\n&quot;     &quot;def\n&quot;         &quot;&quot;
 *     w &lt;&lt; &quot;ghi\n&quot;             #               &quot;def\n&quot;         &quot;ghi\n&quot;
 *     r.readpartial(4096)      #=&gt; &quot;def\n&quot;     &quot;&quot;              &quot;ghi\n&quot;
 *     r.readpartial(4096)      #=&gt; &quot;ghi\n&quot;     &quot;&quot;              &quot;&quot;
 *
 *  Note that readpartial behaves similar to sysread.
 *  The differences are:
 *  * If the byte buffer is not empty, read from the byte buffer instead of &quot;sysread for buffered IO (IOError)&quot;.
 *  * It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial meets EWOULDBLOCK and EINTR by read system call, readpartial retry the system call.
 *
 *  The later means that readpartial is nonblocking-flag insensitive.
 *  It blocks on the situation IO#sysread causes Errno::EWOULDBLOCK as if the fd is blocking mode.
 *
 */

static VALUE
io_readpartial(int argc, VALUE *argv, VALUE io)
{
    VALUE ret;

    ret = io_getpartial(argc, argv, io, 0);
    if (NIL_P(ret))
        rb_eof_error();
    else
        return ret;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="reopen-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>reopen</strong>(other_IO) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>reopen</strong>(path, mode_str) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reassociates <em>ios</em> with the I/O stream given in <em>other_IO</em> or
to a new stream opened on <em>path</em>. This may dynamically change the
actual class of this stream.
</p>
<pre class="code">
   f1 = File.new(&quot;testfile&quot;)
   f2 = File.new(&quot;testfile&quot;)
   f2.readlines[0]   #=&gt; &quot;This is line one\n&quot;
   f2.reopen(f1)     #=&gt; #&lt;File:testfile&gt;
   f2.readlines[0]   #=&gt; &quot;This is line one\n&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>reopen</strong>(other_IO) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>reopen</strong>(path, mode_str) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.reopen(other_IO)         -&gt; ios
 *     ios.reopen(path, mode_str)   -&gt; ios
 *
 *  Reassociates &lt;em&gt;ios&lt;/em&gt; with the I/O stream given in
 *  &lt;i&gt;other_IO&lt;/i&gt; or to a new stream opened on &lt;i&gt;path&lt;/i&gt;. This may
 *  dynamically change the actual class of this stream.
 *
 *     f1 = File.new(&quot;testfile&quot;)
 *     f2 = File.new(&quot;testfile&quot;)
 *     f2.readlines[0]   #=&gt; &quot;This is line one\n&quot;
 *     f2.reopen(f1)     #=&gt; #&lt;File:testfile&gt;
 *     f2.readlines[0]   #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_io_reopen(int argc, VALUE *argv, VALUE file)
{
    VALUE fname, nmode;
    int oflags;
    rb_io_t *fptr;

    rb_secure(4);
    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;fname, &amp;nmode) == 1) {
    VALUE tmp = rb_io_check_io(fname);
    if (!NIL_P(tmp)) {
        return io_reopen(file, tmp);
    }
    }

    FilePathValue(fname);
    rb_io_taint_check(file);
    fptr = RFILE(file)-&gt;fptr;
    if (!fptr) {
    fptr = RFILE(file)-&gt;fptr = ALLOC(rb_io_t);
    MEMZERO(fptr, rb_io_t, 1);
    }

    if (!NIL_P(nmode)) {
    int fmode = rb_io_modestr_fmode(StringValueCStr(nmode));
    if (IS_PREP_STDIO(fptr) &amp;&amp;
            ((fptr-&gt;mode &amp; FMODE_READWRITE) &amp; (fmode &amp; FMODE_READWRITE)) !=
            (fptr-&gt;mode &amp; FMODE_READWRITE)) {
        rb_raise(rb_eArgError,
             &quot;%s can't change access mode from \&quot;%s\&quot; to \&quot;%s\&quot;&quot;,
             PREP_STDIO_NAME(fptr), rb_io_fmode_modestr(fptr-&gt;mode),
             rb_io_fmode_modestr(fmode));
    }
    fptr-&gt;mode = fmode;
    rb_io_mode_enc(fptr, StringValueCStr(nmode));
        fptr-&gt;encs.ecflags = 0;
        fptr-&gt;encs.ecopts = Qnil;
    }

    fptr-&gt;pathv = rb_str_new_frozen(fname);
    oflags = rb_io_fmode_oflags(fptr-&gt;mode);
    if (fptr-&gt;fd &lt; 0) {
        fptr-&gt;fd = rb_sysopen(fptr-&gt;pathv, oflags, 0666);
    fptr-&gt;stdio_file = 0;
    return file;
    }

    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
        if (io_fflush(fptr) &lt; 0)
            rb_sys_fail(0);
    }
    fptr-&gt;rbuf_off = fptr-&gt;rbuf_len = 0;

    if (fptr-&gt;stdio_file) {
        if (freopen(RSTRING_PTR(fptr-&gt;pathv), rb_io_oflags_modestr(oflags), fptr-&gt;stdio_file) == 0) {
            rb_sys_fail_path(fptr-&gt;pathv);
        }
        fptr-&gt;fd = fileno(fptr-&gt;stdio_file);
#ifdef USE_SETVBUF
        if (setvbuf(fptr-&gt;stdio_file, NULL, _IOFBF, 0) != 0)
            rb_warn(&quot;setvbuf() can't be honoured for %s&quot;, RSTRING_PTR(fptr-&gt;pathv));
#endif
    }
    else {
        if (close(fptr-&gt;fd) &lt; 0)
            rb_sys_fail_path(fptr-&gt;pathv);
        fptr-&gt;fd = -1;
        fptr-&gt;fd = rb_sysopen(fptr-&gt;pathv, oflags, 0666);
    }

    return file;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="rewind-instance_method">
  
    - (<tt>0</tt>) <strong>rewind</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Positions <em>ios</em> to the beginning of input, resetting <tt>lineno</tt>
to zero.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.readline   #=&gt; &quot;This is line one\n&quot;
   f.rewind     #=&gt; 0
   f.lineno     #=&gt; 0
   f.readline   #=&gt; &quot;This is line one\n&quot;
</pre>
<p>
Note that it cannot be used with streams such as pipes, ttys, and sockets.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.rewind    -&gt; 0
 *
 *  Positions &lt;em&gt;ios&lt;/em&gt; to the beginning of input, resetting
 *  &lt;code&gt;lineno&lt;/code&gt; to zero.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.readline   #=&gt; &quot;This is line one\n&quot;
 *     f.rewind     #=&gt; 0
 *     f.lineno     #=&gt; 0
 *     f.readline   #=&gt; &quot;This is line one\n&quot;
 *
 *  Note that it cannot be used with streams such as pipes, ttys, and sockets.
 */

static VALUE
rb_io_rewind(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (io_seek(fptr, 0L, 0) &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    if (io == ARGF.current_file) {
    ARGF.lineno -= fptr-&gt;lineno;
    }
    fptr-&gt;lineno = 0;
    if (fptr-&gt;readconv) {
    clear_readconv(fptr);
    }

    return INT2FIX(0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="seek-instance_method">
  
    - (<tt>0</tt>) <strong>seek</strong>(amount, whence = IO::SEEK_SET) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Seeks to a given offset <em>anInteger</em> in the stream according to the
value of <em>whence</em>:
</p>
<pre class="code">
  IO::SEEK_CUR  | Seeks to _amount_ plus current position
  --------------+----------------------------------------------------
  IO::SEEK_END  | Seeks to _amount_ plus end of stream (you probably
                | want a negative value for _amount_)
  --------------+----------------------------------------------------
  IO::SEEK_SET  | Seeks to the absolute location given by _amount_
</pre>
<p>
Example:
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.seek(-13, IO::SEEK_END)   #=&gt; 0
   f.readline                  #=&gt; &quot;And so on...\n&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>0</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.seek(amount, whence=IO::SEEK_SET)  -&gt;  0
 *
 *  Seeks to a given offset &lt;i&gt;anInteger&lt;/i&gt; in the stream according to
 *  the value of &lt;i&gt;whence&lt;/i&gt;:
 *
 *    IO::SEEK_CUR  | Seeks to _amount_ plus current position
 *    --------------+----------------------------------------------------
 *    IO::SEEK_END  | Seeks to _amount_ plus end of stream (you probably
 *                  | want a negative value for _amount_)
 *    --------------+----------------------------------------------------
 *    IO::SEEK_SET  | Seeks to the absolute location given by _amount_
 *
 *  Example:
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.seek(-13, IO::SEEK_END)   #=&gt; 0
 *     f.readline                  #=&gt; &quot;And so on...\n&quot;
 */

static VALUE
rb_io_seek_m(int argc, VALUE *argv, VALUE io)
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;offset, &amp;ptrname) == 2) {
    whence = NUM2INT(ptrname);
    }

    return rb_io_seek(io, offset, whence);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="set_encoding-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(ext_enc) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(&quot;ext_enc:int_enc&quot;) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(ext_enc, int_enc) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(&quot;ext_enc:int_enc&quot;, opt) </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(ext_enc, int_enc, opt) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
If single argument is specified, read string from io is tagged with the
encoding specified.  If encoding is a colon separated two encoding names
&#8220;A:B&#8221;, the read string is converted from encoding A (external
encoding) to encoding B (internal encoding), then tagged with B.  If two
arguments are specified, those must be encoding objects or encoding names,
and the first one is the external encoding, and the second one is the
internal encoding. If the external encoding and the internal encoding is
specified, optional hash argument specify the conversion option.
</p>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(ext_enc) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(&quot;ext_enc:int_enc&quot;) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(ext_enc, int_enc) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(&quot;ext_enc:int_enc&quot;, opt) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>set_encoding</strong>(ext_enc, int_enc, opt) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     io.set_encoding(ext_enc)                -&gt; io
 *     io.set_encoding(&quot;ext_enc:int_enc&quot;)      -&gt; io
 *     io.set_encoding(ext_enc, int_enc)       -&gt; io
 *     io.set_encoding(&quot;ext_enc:int_enc&quot;, opt) -&gt; io
 *     io.set_encoding(ext_enc, int_enc, opt)  -&gt; io
 *
 *  If single argument is specified, read string from io is tagged
 *  with the encoding specified.  If encoding is a colon separated two
 *  encoding names &quot;A:B&quot;, the read string is converted from encoding A
 *  (external encoding) to encoding B (internal encoding), then tagged
 *  with B.  If two arguments are specified, those must be encoding
 *  objects or encoding names, and the first one is the external encoding, and the
 *  second one is the internal encoding.
 *  If the external encoding and the internal encoding is specified,
 *  optional hash argument specify the conversion option.
 */

static VALUE
rb_io_set_encoding(int argc, VALUE *argv, VALUE io)
{
    rb_io_t *fptr;
    VALUE v1, v2, opt;

    opt = pop_last_hash(&amp;argc, argv);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;v1, &amp;v2);
    GetOpenFile(io, fptr);
    io_encoding_set(fptr, v1, v2, opt);
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="stat-instance_method">
  
    - (<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>) <strong>stat</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns status information for <em>ios</em> as an object of type
<tt>File::Stat</tt>.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   s = f.stat
   &quot;%o&quot; % s.mode   #=&gt; &quot;100644&quot;
   s.blksize       #=&gt; 4096
   s.atime         #=&gt; Wed Apr 09 08:53:54 CDT 2003</pre>


  </div>
</div>
<div class="tags">
  
  

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'file.c'</span>

/*
 *  call-seq:
 *     ios.stat    -&gt; stat
 *
 *  Returns status information for &lt;em&gt;ios&lt;/em&gt; as an object of type
 *  &lt;code&gt;File::Stat&lt;/code&gt;.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     s = f.stat
 *     &quot;%o&quot; % s.mode   #=&gt; &quot;100644&quot;
 *     s.blksize       #=&gt; 4096
 *     s.atime         #=&gt; Wed Apr 09 08:53:54 CDT 2003
 *
 */

static VALUE
rb_io_stat(VALUE obj)
{
    rb_io_t *fptr;
    struct stat st;

#define rb_sys_fail_path(path) rb_sys_fail(NIL_P(path) ? 0 : RSTRING_PTR(path))
    GetOpenFile(obj, fptr);
    if (fstat(fptr-&gt;fd, &amp;st) == -1) {
    rb_sys_fail_path(fptr-&gt;pathv);
    }
    return stat_new(&amp;st);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sync-instance_method">
  
    - (<tt>Boolean</tt>) <strong>sync</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the current ``sync mode&#8217;&#8217; of <em>ios</em>. When sync
mode is true, all output is immediately flushed to the underlying operating
system and is not buffered by Ruby internally. See also <tt>IO#fsync</tt>.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.sync   #=&gt; false</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.sync    -&gt; true or false
 *
 *  Returns the current ``sync mode'' of &lt;em&gt;ios&lt;/em&gt;. When sync mode is
 *  true, all output is immediately flushed to the underlying operating
 *  system and is not buffered by Ruby internally. See also
 *  &lt;code&gt;IO#fsync&lt;/code&gt;.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.sync   #=&gt; false
 */

static VALUE
rb_io_sync(VALUE io)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    return (fptr-&gt;mode &amp; FMODE_SYNC) ? Qtrue : Qfalse;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sync=-instance_method">
  
    - (<tt>Boolean</tt>) <strong>sync=</strong>(boolean) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Sets the ``sync mode&#8217;&#8217; to <tt>true</tt> or <tt>false</tt>. When
sync mode is true, all output is immediately flushed to the underlying
operating system and is not buffered internally. Returns the new state. See
also <tt>IO#fsync</tt>.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.sync = true
</pre>
<p>
<em>(produces no output)</em>
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.sync = boolean   -&gt; boolean
 *
 *  Sets the ``sync mode'' to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
 *  When sync mode is true, all output is immediately flushed to the
 *  underlying operating system and is not buffered internally. Returns
 *  the new state. See also &lt;code&gt;IO#fsync&lt;/code&gt;.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.sync = true
 *
 *  &lt;em&gt;(produces no output)&lt;/em&gt;
 */

static VALUE
rb_io_set_sync(VALUE io, VALUE sync)
{
    rb_io_t *fptr;

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    if (RTEST(sync)) {
    fptr-&gt;mode |= FMODE_SYNC;
    }
    else {
    fptr-&gt;mode &amp;= ~FMODE_SYNC;
    }
    return sync;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sysread-instance_method">
  
    - (<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>) <strong>sysread</strong>(integer[, outbuf]) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads <em>integer</em> bytes from <em>ios</em> using a low-level read and
returns them as a string. Do not mix with other methods that read from
<em>ios</em> or you may get unpredictable results. If the optional
<em>outbuf</em> argument is present, it must reference a String, which will
receive the data. Raises <tt>SystemCallError</tt> on error and
<tt>EOFError</tt> at end of file.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.sysread(16)   #=&gt; &quot;This is line one&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.sysread(integer[, outbuf])    -&gt; string
 *
 *  Reads &lt;i&gt;integer&lt;/i&gt; bytes from &lt;em&gt;ios&lt;/em&gt; using a low-level
 *  read and returns them as a string. Do not mix with other methods
 *  that read from &lt;em&gt;ios&lt;/em&gt; or you may get unpredictable results.
 *  If the optional &lt;i&gt;outbuf&lt;/i&gt; argument is present, it must reference
 *  a String, which will receive the data.
 *  Raises &lt;code&gt;SystemCallError&lt;/code&gt; on error and
 *  &lt;code&gt;EOFError&lt;/code&gt; at end of file.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.sysread(16)   #=&gt; &quot;This is line one&quot;
 */

static VALUE
rb_io_sysread(int argc, VALUE *argv, VALUE io)
{
    VALUE len, str;
    rb_io_t *fptr;
    long n, ilen;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;len, &amp;str);
    ilen = NUM2LONG(len);

    if (NIL_P(str)) {
    str = rb_str_new(0, ilen);
    }
    else {
    StringValue(str);
    rb_str_modify(str);
    rb_str_resize(str, ilen);
    }
    if (ilen == 0) return str;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);

    if (READ_DATA_BUFFERED(fptr)) {
    rb_raise(rb_eIOError, &quot;sysread for buffered IO&quot;);
    }

    n = fptr-&gt;fd;
    rb_thread_wait_fd(fptr-&gt;fd);
    rb_io_check_closed(fptr);

    rb_str_locktmp(str);
    n = rb_read_internal(fptr-&gt;fd, RSTRING_PTR(str), ilen);
    rb_str_unlocktmp(str);

    if (n == -1) {
    rb_sys_fail_path(fptr-&gt;pathv);
    }
    rb_str_set_len(str, n);
    if (n == 0 &amp;&amp; ilen &gt; 0) {
    rb_eof_error();
    }
    rb_str_resize(str, n);
    OBJ_TAINT(str);

    return str;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="sysseek-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>sysseek</strong>(offset, whence = IO::SEEK_SET) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Seeks to a given <em>offset</em> in the stream according to the value of
<em>whence</em> (see <tt>IO#seek</tt> for values of <em>whence</em>).
Returns the new offset into the file.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.sysseek(-13, IO::SEEK_END)   #=&gt; 53
   f.sysread(10)                  #=&gt; &quot;And so on.&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.sysseek(offset, whence=IO::SEEK_SET)   -&gt; integer
 *
 *  Seeks to a given &lt;i&gt;offset&lt;/i&gt; in the stream according to the value
 *  of &lt;i&gt;whence&lt;/i&gt; (see &lt;code&gt;IO#seek&lt;/code&gt; for values of
 *  &lt;i&gt;whence&lt;/i&gt;). Returns the new offset into the file.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.sysseek(-13, IO::SEEK_END)   #=&gt; 53
 *     f.sysread(10)                  #=&gt; &quot;And so on.&quot;
 */

static VALUE
rb_io_sysseek(int argc, VALUE *argv, VALUE io)
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;
    rb_io_t *fptr;
    off_t pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;offset, &amp;ptrname) == 2) {
    whence = NUM2INT(ptrname);
    }
    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    if ((fptr-&gt;mode &amp; FMODE_READABLE) &amp;&amp;
        (READ_DATA_BUFFERED(fptr) || READ_CHAR_PENDING(fptr))) {
    rb_raise(rb_eIOError, &quot;sysseek for buffered IO&quot;);
    }
    if ((fptr-&gt;mode &amp; FMODE_WRITABLE) &amp;&amp; fptr-&gt;wbuf_len) {
    rb_warn(&quot;sysseek for buffered IO&quot;);
    }
    errno = 0;
    pos = lseek(fptr-&gt;fd, pos, whence);
    if (pos == -1 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);

    return OFFT2NUM(pos);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="syswrite-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>syswrite</strong>(string) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Writes the given string to <em>ios</em> using a low-level write. Returns
the number of bytes written. Do not mix with other methods that write to
<em>ios</em> or you may get unpredictable results. Raises
<tt>SystemCallError</tt> on error.
</p>
<pre class="code">
   f = File.new(&quot;out&quot;, &quot;w&quot;)
   f.syswrite(&quot;ABCDEF&quot;)   #=&gt; 6</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.syswrite(string)   -&gt; integer
 *
 *  Writes the given string to &lt;em&gt;ios&lt;/em&gt; using a low-level write.
 *  Returns the number of bytes written. Do not mix with other methods
 *  that write to &lt;em&gt;ios&lt;/em&gt; or you may get unpredictable results.
 *  Raises &lt;code&gt;SystemCallError&lt;/code&gt; on error.
 *
 *     f = File.new(&quot;out&quot;, &quot;w&quot;)
 *     f.syswrite(&quot;ABCDEF&quot;)   #=&gt; 6
 */

static VALUE
rb_io_syswrite(VALUE io, VALUE str)
{
    rb_io_t *fptr;
    long n;

    rb_secure(4);
    if (TYPE(str) != T_STRING)
    str = rb_obj_as_string(str);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);

    if (fptr-&gt;wbuf_len) {
    rb_warn(&quot;syswrite for buffered IO&quot;);
    }
    if (!rb_thread_fd_writable(fptr-&gt;fd)) {
        rb_io_check_closed(fptr);
    }

    n = write(fptr-&gt;fd, RSTRING_PTR(str), RSTRING_LEN(str));

    if (n == -1) rb_sys_fail_path(fptr-&gt;pathv);

    return LONG2FIX(n);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tell-instance_method">
  
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>pos</strong> </span>
    
      <span class="overload">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>tell</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns the current offset (in bytes) of <em>ios</em>.
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)
   f.pos    #=&gt; 0
   f.gets   #=&gt; &quot;This is line one\n&quot;
   f.pos    #=&gt; 17</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>pos</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>tell</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.pos     -&gt; integer
 *     ios.tell    -&gt; integer
 *
 *  Returns the current offset (in bytes) of &lt;em&gt;ios&lt;/em&gt;.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.pos    #=&gt; 0
 *     f.gets   #=&gt; &quot;This is line one\n&quot;
 *     f.pos    #=&gt; 17
 */

static VALUE
rb_io_tell(VALUE io)
{
    rb_io_t *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_tell(fptr);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail_path(fptr-&gt;pathv);
    pos -= fptr-&gt;rbuf_len;
    return OFFT2NUM(pos);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="to_io-instance_method">
  
    - (<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>) <strong>to_io</strong> 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <em>ios</em>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="IO (class)">IO</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.to_io  -&gt;  ios
 *
 *  Returns &lt;em&gt;ios&lt;/em&gt;.
 */

static VALUE
rb_io_to_io(VALUE io)
{
    return io;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="tty?-instance_method">
  
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>isatty</strong> </span>
    
      <span class="overload">- (<tt>Boolean</tt>) <strong>tty?</strong> </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns <tt>true</tt> if <em>ios</em> is associated with a terminal device
(tty), <tt>false</tt> otherwise.
</p>
<pre class="code">
   File.new(&quot;testfile&quot;).isatty   #=&gt; false
   File.new(&quot;/dev/tty&quot;).isatty   #=&gt; true</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>isatty</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>Boolean</tt>) <strong>tty?</strong> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.isatty   -&gt; true or false
 *     ios.tty?     -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;ios&lt;/em&gt; is associated with a
 *  terminal device (tty), &lt;code&gt;false&lt;/code&gt; otherwise.
 *
 *     File.new(&quot;testfile&quot;).isatty   #=&gt; false
 *     File.new(&quot;/dev/tty&quot;).isatty   #=&gt; true
 */

static VALUE
rb_io_isatty(VALUE io)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (isatty(fptr-&gt;fd) == 0)
    return Qfalse;
    return Qtrue;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ungetbyte-instance_method">
  
    
      <span class="overload">- (<tt>nil</tt>) <strong>ungetbyte</strong>(string) </span>
    
      <span class="overload">- (<tt>nil</tt>) <strong>ungetbyte</strong>(integer) </span>
    
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Pushes back bytes (passed as a parameter) onto <em>ios</em>, such that a
subsequent buffered read will return it. Only one byte may be pushed back
before a subsequent read operation (that is, you will be able to read only
the last of several bytes that have been pushed back). Has no effect with
unbuffered reads (such as <tt>IO#sysread</tt>).
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)   #=&gt; #&lt;File:testfile&gt;
   b = f.getbyte              #=&gt; 0x38
   f.ungetbyte(b)             #=&gt; nil
   f.getbyte                  #=&gt; 0x38</pre>


  </div>
</div>
<div class="tags">
  
  <h3>Overloads:</h3>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>ungetbyte</strong>(string) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">- (<tt>nil</tt>) <strong>ungetbyte</strong>(integer) </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.ungetbyte(string)   -&gt; nil
 *     ios.ungetbyte(integer)   -&gt; nil
 *
 *  Pushes back bytes (passed as a parameter) onto &lt;em&gt;ios&lt;/em&gt;,
 *  such that a subsequent buffered read will return it. Only one byte
 *  may be pushed back before a subsequent read operation (that is,
 *  you will be able to read only the last of several bytes that have been pushed
 *  back). Has no effect with unbuffered reads (such as &lt;code&gt;IO#sysread&lt;/code&gt;).
 *
 *     f = File.new(&quot;testfile&quot;)   #=&gt; #&lt;File:testfile&gt;
 *     b = f.getbyte              #=&gt; 0x38
 *     f.ungetbyte(b)             #=&gt; nil
 *     f.getbyte                  #=&gt; 0x38
 */

VALUE
rb_io_ungetbyte(VALUE io, VALUE b)
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_byte_readable(fptr);
    if (NIL_P(b)) return Qnil;
    if (FIXNUM_P(b)) {
    char cc = FIX2INT(b);
    b = rb_str_new(&amp;cc, 1);
    }
    else {
    SafeStringValue(b);
    }
    io_ungetbyte(b, fptr);
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="ungetc-instance_method">
  
    - (<tt>nil</tt>) <strong>ungetc</strong>(string) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Pushes back one character (passed as a parameter) onto <em>ios</em>, such
that a subsequent buffered character read will return it. Only one
character may be pushed back before a subsequent read operation (that is,
you will be able to read only the last of several characters that have been
pushed back). Has no effect with unbuffered reads (such as
<tt>IO#sysread</tt>).
</p>
<pre class="code">
   f = File.new(&quot;testfile&quot;)   #=&gt; #&lt;File:testfile&gt;
   c = f.getc                 #=&gt; &quot;8&quot;
   f.ungetc(c)                #=&gt; nil
   f.getc                     #=&gt; &quot;8&quot;</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>nil</tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.ungetc(string)   -&gt; nil
 *
 *  Pushes back one character (passed as a parameter) onto &lt;em&gt;ios&lt;/em&gt;,
 *  such that a subsequent buffered character read will return it. Only one character
 *  may be pushed back before a subsequent read operation (that is,
 *  you will be able to read only the last of several characters that have been pushed
 *  back). Has no effect with unbuffered reads (such as &lt;code&gt;IO#sysread&lt;/code&gt;).
 *
 *     f = File.new(&quot;testfile&quot;)   #=&gt; #&lt;File:testfile&gt;
 *     c = f.getc                 #=&gt; &quot;8&quot;
 *     f.ungetc(c)                #=&gt; nil
 *     f.getc                     #=&gt; &quot;8&quot;
 */

VALUE
rb_io_ungetc(VALUE io, VALUE c)
{
    rb_io_t *fptr;
    long len;

    GetOpenFile(io, fptr);
    rb_io_check_char_readable(fptr);
    if (NIL_P(c)) return Qnil;
    if (FIXNUM_P(c)) {
    int cc = FIX2INT(c);
    rb_encoding *enc = io_read_encoding(fptr);
    char buf[16];

    c = rb_str_new(buf, rb_enc_mbcput(cc, buf, enc));
    }
    else {
    SafeStringValue(c);
    }
    if (NEED_READCONV(fptr)) {
        len = RSTRING_LEN(c);
#if SIZEOF_LONG &gt; SIZEOF_INT
    if (len &gt; INT_MAX)
        rb_raise(rb_eIOError, &quot;ungetc failed&quot;);
#endif
        make_readconv(fptr, (int)len);
        if (fptr-&gt;cbuf_capa - fptr-&gt;cbuf_len &lt; len)
            rb_raise(rb_eIOError, &quot;ungetc failed&quot;);
        if (fptr-&gt;cbuf_off &lt; len) {
            MEMMOVE(fptr-&gt;cbuf+fptr-&gt;cbuf_capa-fptr-&gt;cbuf_len,
                    fptr-&gt;cbuf+fptr-&gt;cbuf_off,
                    char, fptr-&gt;cbuf_len);
            fptr-&gt;cbuf_off = fptr-&gt;cbuf_capa-fptr-&gt;cbuf_len;
        }
        fptr-&gt;cbuf_off -= (int)len;
        fptr-&gt;cbuf_len += (int)len;
        MEMMOVE(fptr-&gt;cbuf+fptr-&gt;cbuf_off, RSTRING_PTR(c), char, len);
    }
    else {
        io_ungetbyte(c, fptr);
    }
    return Qnil;
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>write</strong>(string) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Writes the given string to <em>ios</em>. The stream must be opened for
writing. If the argument is not a string, it will be converted to a string
using <tt>to_s</tt>. Returns the number of bytes written.
</p>
<pre class="code">
   count = $stdout.write( &quot;This is a test\n&quot; )
   puts &quot;That was #{count} bytes of data&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre class="code">
   This is a test
   That was 15 bytes of data</pre>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.write(string)    -&gt; integer
 *
 *  Writes the given string to &lt;em&gt;ios&lt;/em&gt;. The stream must be opened
 *  for writing. If the argument is not a string, it will be converted
 *  to a string using &lt;code&gt;to_s&lt;/code&gt;. Returns the number of bytes
 *  written.
 *
 *     count = $stdout.write( &quot;This is a test\n&quot; )
 *     puts &quot;That was #{count} bytes of data&quot;
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     This is a test
 *     That was 15 bytes of data
 */

static VALUE
io_write_m(VALUE io, VALUE str)
{
    return io_write(io, str, 0);
}</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="write_nonblock-instance_method">
  
    - (<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>) <strong>write_nonblock</strong>(string) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Writes the given string to <em>ios</em> using the write(2) system call
after O_NONBLOCK is set for the underlying file descriptor.
</p>
<p>
It returns the number of bytes written.
</p>
<p>
write_nonblock just calls the write(2) system call. It causes all errors
the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The
result may also be smaller than string.length (partial write). The caller
should care such errors and partial write.
</p>
<p>
If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by
IO::WaitWritable. So IO::WaitWritable can be used to rescue the exceptions
for retrying write_nonblock.
</p>
<pre class="code">
  # Creates a pipe.
  r, w = IO.pipe

  # write_nonblock writes only 65536 bytes and return 65536.
  # (The pipe size is 65536 bytes on this environment.)
  s = &quot;a&quot; * 100000
  p w.write_nonblock(s)     #=&gt; 65536

  # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).
  p w.write_nonblock(&quot;b&quot;)   # Resource temporarily unavailable (Errno::EAGAIN)
</pre>
<p>
If the write buffer is not empty, it is flushed at first.
</p>
<p>
When write_nonblock raises an exception kind of IO::WaitWritable,
write_nonblock should not be called until io is writable for avoiding busy
loop. This can be done as follows.
</p>
<pre class="code">
  begin
    result = io.write_nonblock(string)
  rescue IO::WaitWritable, Errno::EINTR
    IO.select(nil, [io])
    retry
  end
</pre>
<p>
Note that this doesn&#8217;t guarantee to write all data in string. The
length written is reported as result and it should be checked later.
</p>
<p>
On some platforms such as Windows, write_nonblock is not supported
according to the kind of the IO object. In such cases, write_nonblock
raises <tt>Errno::EBADF</tt>.
</p>


  </div>
</div>
<div class="tags">
  
  <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
      
    </li>
  
</ul>

</div>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'io.c'</span>

/*
 *  call-seq:
 *     ios.write_nonblock(string)   -&gt; integer
 *
 *  Writes the given string to &lt;em&gt;ios&lt;/em&gt; using
 *  the write(2) system call after O_NONBLOCK is set for
 *  the underlying file descriptor.
 *
 *  It returns the number of bytes written.
 *
 *  write_nonblock just calls the write(2) system call.
 *  It causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc.
 *  The result may also be smaller than string.length (partial write).
 *  The caller should care such errors and partial write.
 *
 *  If the exception is Errno::EWOULDBLOCK or Errno::AGAIN,
 *  it is extended by IO::WaitWritable.
 *  So IO::WaitWritable can be used to rescue the exceptions for retrying write_nonblock.
 *
 *    # Creates a pipe.
 *    r, w = IO.pipe
 *
 *    # write_nonblock writes only 65536 bytes and return 65536.
 *    # (The pipe size is 65536 bytes on this environment.)
 *    s = &quot;a&quot; * 100000
 *    p w.write_nonblock(s)     #=&gt; 65536
 *
 *    # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).
 *    p w.write_nonblock(&quot;b&quot;)   # Resource temporarily unavailable (Errno::EAGAIN)
 *
 *  If the write buffer is not empty, it is flushed at first.
 *
 *  When write_nonblock raises an exception kind of IO::WaitWritable,
 *  write_nonblock should not be called
 *  until io is writable for avoiding busy loop.
 *  This can be done as follows.
 *
 *    begin
 *      result = io.write_nonblock(string)
 *    rescue IO::WaitWritable, Errno::EINTR
 *      IO.select(nil, [io])
 *      retry
 *    end
 *
 *  Note that this doesn't guarantee to write all data in string.
 *  The length written is reported as result and it should be checked later.
 *
 *  On some platforms such as Windows, write_nonblock is not supported
 *  according to the kind of the IO object.
 *  In such cases, write_nonblock raises &lt;code&gt;Errno::EBADF&lt;/code&gt;.
 *
 */

static VALUE
rb_io_write_nonblock(VALUE io, VALUE str)
{
    rb_io_t *fptr;
    long n;

    rb_secure(4);
    if (TYPE(str) != T_STRING)
    str = rb_obj_as_string(str);

    io = GetWriteIO(io);
    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);

    if (io_fflush(fptr) &lt; 0)
        rb_sys_fail(0);

    rb_io_set_nonblock(fptr);
    n = write(fptr-&gt;fd, RSTRING_PTR(str), RSTRING_LEN(str));

    if (n == -1) {
        if (errno == EWOULDBLOCK || errno == EAGAIN)
            rb_mod_sys_fail(rb_mWaitWritable, &quot;write would block&quot;);
        rb_sys_fail_path(fptr-&gt;pathv);
    }

    return LONG2FIX(n);
}</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Thu Oct 14 00:06:12 2010 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.1 (ruby-1.9.2).
</div>

  </body>
</html>