  <div id="fileHeader">
    <h1>ruby.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/ruby.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 05:39:57 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  ruby.c -

  $Author: knu $
  $Date: 2008-06-06 19:39:57 +0900 (Fri, 06 Jun 2008) $
  created at: Tue Aug 10 12:47:31 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#if defined _WIN32 || defined __CYGWIN__
#include &lt;windows.h&gt;
#endif
#if defined __CYGWIN__
#include &lt;sys/cygwin.h&gt;
#endif
#ifdef _WIN32_WCE
#include &lt;winsock.h&gt;
#include &quot;wince.h&quot;
#endif
#include &quot;ruby.h&quot;
#include &quot;dln.h&quot;
#include &quot;node.h&quot;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;ctype.h&gt;

#ifdef __hpux
#include &lt;sys/pstat.h&gt;
#endif

#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif

#ifndef HAVE_STRING_H
char *strchr _((const char*,const char));
char *strrchr _((const char*,const char));
char *strstr _((const char*,const char*));
#endif

#include &quot;util.h&quot;

#ifndef HAVE_STDLIB_H
char *getenv();
#endif

VALUE ruby_debug = Qfalse;
VALUE ruby_verbose = Qfalse;
static int sflag = 0;
static int xflag = 0;
extern int ruby_yydebug;

char *ruby_inplace_mode = Qfalse;

static void load_stdin _((void));
static void load_file _((const char *, int));
static void forbid_setid _((const char *));

static VALUE do_loop = Qfalse, do_print = Qfalse;
static VALUE do_check = Qfalse, do_line = Qfalse;
static VALUE do_split = Qfalse;

static const char *script;

static int origargc;
static char **origargv;

static void
usage(name)
    const char *name;
{
    /* This message really ought to be max 23 lines.
     * Removed -h because the user already knows that option. Others? */

    static const char *const usage_msg[] = {
&quot;-0[octal]       specify record separator (\\0, if no argument)&quot;,
&quot;-a              autosplit mode with -n or -p (splits $_ into $F)&quot;,
&quot;-c              check syntax only&quot;,
&quot;-Cdirectory     cd to directory, before executing your script&quot;,
&quot;-d              set debugging flags (set $DEBUG to true)&quot;,
&quot;-e 'command'    one line of script. Several -e's allowed. Omit [programfile]&quot;,
&quot;-Fpattern       split() pattern for autosplit (-a)&quot;,
&quot;-i[extension]   edit ARGV files in place (make backup if extension supplied)&quot;,
&quot;-Idirectory     specify $LOAD_PATH directory (may be used more than once)&quot;,
&quot;-Kkcode         specifies KANJI (Japanese) code-set&quot;,
&quot;-l              enable line ending processing&quot;,
&quot;-n              assume 'while gets(); ... end' loop around your script&quot;,
&quot;-p              assume loop like -n but print line also like sed&quot;,
&quot;-rlibrary       require the library, before executing your script&quot;,
&quot;-s              enable some switch parsing for switches after script name&quot;,
&quot;-S              look for the script using PATH environment variable&quot;,
&quot;-T[level]       turn on tainting checks&quot;,
&quot;-v              print version number, then turn on verbose mode&quot;,
&quot;-w              turn warnings on for your script&quot;,
&quot;-W[level]       set warning level; 0=silence, 1=medium, 2=verbose (default)&quot;,
&quot;-x[directory]   strip off text before #!ruby line and perhaps cd to directory&quot;,
&quot;--copyright     print the copyright&quot;,
&quot;--version       print the version&quot;,
NULL
};
    const char *const *p = usage_msg;

    printf(&quot;Usage: %s [switches] [--] [programfile] [arguments]\n&quot;, name);
    while (*p)
	printf(&quot;  %s\n&quot;, *p++);
}

extern VALUE rb_load_path;

#ifndef CharNext		/* defined as CharNext[AW] on Windows. */
#define CharNext(p) ((p) + mblen(p, RUBY_MBCHAR_MAXSIZE))
#endif

#if defined DOSISH || defined __CYGWIN__
static inline void
translate_char(char *p, int from, int to)
{
    while (*p) {
	if ((unsigned char)*p == from)
	    *p = to;
	p = CharNext(p);
    }
}
#endif

#if defined _WIN32 || defined __CYGWIN__ || defined __DJGPP__
static VALUE
rubylib_mangled_path(const char *s, unsigned int l)
{
    static char *newp, *oldp;
    static int newl, oldl, notfound;
    char *ptr;
    VALUE ret;

    if (!newp &amp;&amp; !notfound) {
	newp = getenv(&quot;RUBYLIB_PREFIX&quot;);
	if (newp) {
	    oldp = newp = strdup(newp);
	    while (*newp &amp;&amp; !ISSPACE(*newp) &amp;&amp; *newp != ';') {
		newp = CharNext(newp);	/* Skip digits. */
	    }
	    oldl = newp - oldp;
	    while (*newp &amp;&amp; (ISSPACE(*newp) || *newp == ';')) {
		newp = CharNext(newp);	/* Skip whitespace. */
	    }
	    newl = strlen(newp);
	    if (newl == 0 || oldl == 0) {
		rb_fatal(&quot;malformed RUBYLIB_PREFIX&quot;);
	    }
	    translate_char(newp, '\\', '/');
	}
	else {
	    notfound = 1;
	}
    }
    if (!newp || l &lt; oldl || strncasecmp(oldp, s, oldl) != 0) {
	return rb_str_new(s, l);
    }
    ret = rb_str_new(0, l + newl - oldl);
    ptr = RSTRING_PTR(ret);
    memcpy(ptr, newp, newl);
    memcpy(ptr + newl, s + oldl, l - oldl);
    ptr[l + newl - oldl] = 0;
    return ret;
}

static VALUE
rubylib_mangled_path2(const char *s)
{
    return rubylib_mangled_path(s, strlen(s));
}
#else
#define rubylib_mangled_path rb_str_new
#define rubylib_mangled_path2 rb_str_new2
#endif

static void push_include _((const char *path));

static void
push_include(path)
    const char *path;
{
    const char sep = PATH_SEP_CHAR;
    const char *p, *s;

    p = path;
    while (*p) {
	while (*p == sep)
	    p++;
	if (!*p) break;
	for (s = p; *s &amp;&amp; *s != sep; s = CharNext(s));
	rb_ary_push(rb_load_path, rubylib_mangled_path(p, s - p));
	p = s;
    }
}

#ifdef __CYGWIN__
static void
push_include_cygwin(const char *path)
{
    const char *p, *s;
    char rubylib[FILENAME_MAX];
    VALUE buf = 0;

    p = path;
    while (*p) {
	unsigned int len;
	while (*p == ';')
	    p++;
	if (!*p) break;
	for (s = p; *s &amp;&amp; *s != ';'; s = CharNext(s));
	len = s - p;
	if (*s) {
	    if (!buf) {
		buf = rb_str_new(p, len);
		p = RSTRING_PTR(buf);
	    }
	    else {
		rb_str_resize(buf, len);
		p = strncpy(RSTRING_PTR(buf), p, len);
	    }
	}
	if (cygwin_conv_to_posix_path(p, rubylib) == 0)
	    p = rubylib;
	push_include(p);
	if (!*s) break;
	p = s + 1;
    }
}

#define push_include push_include_cygwin
#endif

void
ruby_incpush(path)
    const char *path;
{
    if (path == 0)
	return;
    push_include(path);
}

#if defined DOSISH || defined __CYGWIN__
#define LOAD_RELATIVE 1
#endif

void
ruby_init_loadpath()
{
#if defined LOAD_RELATIVE
    char libpath[FILENAME_MAX+1];
    char *p;
    int rest;
#if defined _WIN32 || defined __CYGWIN__
    HMODULE libruby = NULL;
    MEMORY_BASIC_INFORMATION m;

#ifndef _WIN32_WCE
    memset(&amp;m, 0, sizeof(m));
    if (VirtualQuery(ruby_init_loadpath, &amp;m, sizeof(m)) &amp;&amp; m.State == MEM_COMMIT)
	libruby = (HMODULE)m.AllocationBase;
#endif
    GetModuleFileName(libruby, libpath, sizeof libpath);
#elif defined(DJGPP)
    extern char *__dos_argv0;
    strncpy(libpath, __dos_argv0, FILENAME_MAX);
#elif defined(__human68k__)
    extern char **_argv;
    strncpy(libpath, _argv[0], FILENAME_MAX);
#elif defined(__EMX__)
    _execname(libpath, FILENAME_MAX);
#endif

    libpath[FILENAME_MAX] = '\0';
#if defined DOSISH
    translate_char(libpath, '\\', '/');
#elif defined __CYGWIN__
    {
	char rubylib[FILENAME_MAX];
	cygwin_conv_to_posix_path(libpath, rubylib);
	strncpy(libpath, rubylib, sizeof(libpath));
    }
#endif
    p = strrchr(libpath, '/');
    if (p) {
	*p = 0;
	if (p - libpath &gt; 3 &amp;&amp; !strcasecmp(p - 4, &quot;/bin&quot;)) {
	    p -= 4;
	    *p = 0;
	}
    }
    else {
	strcpy(libpath, &quot;.&quot;);
	p = libpath + 1;
    }

    rest = FILENAME_MAX - (p - libpath);

#define RUBY_RELATIVE(path) (strncpy(p, (path), rest), libpath)
#else
#define RUBY_RELATIVE(path) (path)
#endif
#define incpush(path) rb_ary_push(rb_load_path, rubylib_mangled_path2(path))

    if (rb_safe_level() == 0) {
	ruby_incpush(getenv(&quot;RUBYLIB&quot;));
    }

#ifdef RUBY_SEARCH_PATH
    incpush(RUBY_RELATIVE(RUBY_SEARCH_PATH));
#endif

    incpush(RUBY_RELATIVE(RUBY_SITE_LIB2));
#ifdef RUBY_SITE_THIN_ARCHLIB
    incpush(RUBY_RELATIVE(RUBY_SITE_THIN_ARCHLIB));
#endif
    incpush(RUBY_RELATIVE(RUBY_SITE_ARCHLIB));
    incpush(RUBY_RELATIVE(RUBY_SITE_LIB));

    incpush(RUBY_RELATIVE(RUBY_VENDOR_LIB2));
#ifdef RUBY_VENDOR_THIN_ARCHLIB
    incpush(RUBY_RELATIVE(RUBY_VENDOR_THIN_ARCHLIB));
#endif
    incpush(RUBY_RELATIVE(RUBY_VENDOR_ARCHLIB));
    incpush(RUBY_RELATIVE(RUBY_VENDOR_LIB));

    incpush(RUBY_RELATIVE(RUBY_LIB));
#ifdef RUBY_THIN_ARCHLIB
    incpush(RUBY_RELATIVE(RUBY_THIN_ARCHLIB));
#endif
    incpush(RUBY_RELATIVE(RUBY_ARCHLIB));

    if (rb_safe_level() == 0) {
	incpush(&quot;.&quot;);
    }
}

struct req_list {
    char *name;
    struct req_list *next;
};
static struct req_list req_list_head, *req_list_last = &amp;req_list_head;

static void
add_modules(mod)
    const char *mod;
{
    struct req_list *list;

    list = ALLOC(struct req_list);
    list-&gt;name = ALLOC_N(char, strlen(mod)+1);
    strcpy(list-&gt;name, mod);
    list-&gt;next = 0;
    req_list_last-&gt;next = list;
    req_list_last = list;
}

extern void Init_ext _((void));

static void
require_libraries()
{
    extern NODE *ruby_eval_tree;
    extern NODE *ruby_eval_tree_begin;
    NODE *save[3];
    struct req_list *list = req_list_head.next;
    struct req_list *tmp;

    save[0] = ruby_eval_tree;
    save[1] = ruby_eval_tree_begin;
    save[2] = NEW_NEWLINE(0);
    ruby_eval_tree = ruby_eval_tree_begin = 0;
    ruby_current_node = 0;
    Init_ext();		/* should be called here for some reason :-( */
    ruby_current_node = save[2];
    ruby_set_current_source();
    req_list_last = 0;
    while (list) {
	int state;

	ruby_current_node = 0;
	rb_protect((VALUE (*)(VALUE))rb_require, (VALUE)list-&gt;name, &amp;state);
	if (state) rb_jump_tag(state);
	tmp = list-&gt;next;
	free(list-&gt;name);
	free(list);
	list = tmp;
	ruby_current_node = save[2];
	ruby_set_current_source();
    }
    req_list_head.next = 0;
    ruby_eval_tree = save[0];
    ruby_eval_tree_begin = save[1];
    rb_gc_force_recycle((VALUE)save[2]);
    ruby_current_node = 0;
}

static void
process_sflag()
{
    if (sflag) {
	long n;
	VALUE *args;

	n = RARRAY(rb_argv)-&gt;len;
	args = RARRAY(rb_argv)-&gt;ptr;
	while (n &gt; 0) {
	    VALUE v = *args++;
	    char *s = StringValuePtr(v);
	    char *p;
	    int hyphen = Qfalse;

	    if (s[0] != '-') break;
	    n--;
	    if (s[1] == '-' &amp;&amp; s[2] == '\0') break;

	    v = Qtrue;
	    /* check if valid name before replacing - with _ */
	    for (p = s + 1; *p; p++) {
		if (*p == '=') {
		    *p++ = '\0';
		    v = rb_str_new2(p);
		    break;
		}
		if (*p == '-') {
		    hyphen = Qtrue;
		}
		else if (*p != '_' &amp;&amp; !ISALNUM(*p)) {
		    VALUE name_error[2];
		    name_error[0] = rb_str_new2(&quot;invalid name for global variable - &quot;);
		    if (!(p = strchr(p, '='))) {
			rb_str_cat2(name_error[0], s);
		    }
		    else {
			rb_str_cat(name_error[0], s, p - s);
		    }
		    name_error[1] = args[-1];
		    rb_exc_raise(rb_class_new_instance(2, name_error, rb_eNameError));
		}
	    }
	    s[0] = '$';
	    if (hyphen) {
		for (p = s + 1; *p; ++p) {
		    if (*p == '-') *p = '_';
		}
	    }
	    rb_gv_set(s, v);
	}
	n = RARRAY(rb_argv)-&gt;len - n;
	while (n--) {
	    rb_ary_shift(rb_argv);
	}
    }
    sflag = 0;
}

static void proc_options _((int argc, char **argv));

static char*
moreswitches(s)
    char *s;
{
    int argc; char *argv[3];
    char *p = s;

    argc = 2; argv[0] = argv[2] = 0;
    while (*s &amp;&amp; !ISSPACE(*s))
	s++;
    argv[1] = ALLOCA_N(char, s-p+2);
    argv[1][0] = '-';
    strncpy(argv[1]+1, p, s-p);
    argv[1][s-p+1] = '\0';
    proc_options(argc, argv);
    while (*s &amp;&amp; ISSPACE(*s))
	s++;
    return s;
}

static void
proc_options(argc, argv)
    int argc;
    char **argv;
{
    char *argv0 = argv[0];
    int do_search;
    char *s;
    NODE *volatile script_node = 0;

    int version = 0;
    int copyright = 0;
    int verbose = 0;
    VALUE e_script = Qfalse;

    if (argc == 0) return;

    do_search = Qfalse;

    for (argc--,argv++; argc &gt; 0; argc--,argv++) {
	if (argv[0][0] != '-' || !argv[0][1]) break;

	s = argv[0]+1;
      reswitch:
	switch (*s) {
	  case 'a':
	    do_split = Qtrue;
	    s++;
	    goto reswitch;

	  case 'p':
	    do_print = Qtrue;
	    /* through */
	  case 'n':
	    do_loop = Qtrue;
	    s++;
	    goto reswitch;

	  case 'd':
	    ruby_debug = Qtrue;
	    ruby_verbose = Qtrue;
	    s++;
	    goto reswitch;

	  case 'y':
	    ruby_yydebug = 1;
	    s++;
	    goto reswitch;

	  case 'v':
	    if (argv0 == 0 || verbose) {
		s++;
		goto reswitch;
	    }
	    ruby_show_version();
	    verbose = 1;
	  case 'w':
	    ruby_verbose = Qtrue;
	    s++;
	    goto reswitch;

	  case 'W':
	    {
		int numlen;
		int v = 2;	/* -W as -W2 */

		if (*++s) {
		    v = scan_oct(s, 1, &amp;numlen);
		    if (numlen == 0) v = 1;
		    s += numlen;
		}
		switch (v) {
		  case 0:
		    ruby_verbose = Qnil; break;
		  case 1:
		    ruby_verbose = Qfalse; break;
		  default:
		    ruby_verbose = Qtrue; break;
		}
	    }
	    goto reswitch;

	  case 'c':
	    do_check = Qtrue;
	    s++;
	    goto reswitch;

	  case 's':
	    forbid_setid(&quot;-s&quot;);
	    sflag = 1;
	    s++;
	    goto reswitch;

	  case 'h':
	    usage(origargv[0]);
	    exit(0);

	  case 'l':
	    do_line = Qtrue;
	    rb_output_rs = rb_rs;
	    s++;
	    goto reswitch;

	  case 'S':
	    forbid_setid(&quot;-S&quot;);
	    do_search = Qtrue;
	    s++;
	    goto reswitch;

	  case 'e':
	    forbid_setid(&quot;-e&quot;);
	    if (!*++s) {
		s = argv[1];
		argc--,argv++;
	    }
	    if (!s) {
		fprintf(stderr, &quot;%s: no code specified for -e\n&quot;, origargv[0]);
		exit(2);
	    }
	    if (!e_script) {
		e_script = rb_str_new(0,0);
		if (script == 0) script = &quot;-e&quot;;
	    }
	    rb_str_cat2(e_script, s);
	    rb_str_cat2(e_script, &quot;\n&quot;);
	    break;

	  case 'r':
	    forbid_setid(&quot;-r&quot;);
	    if (*++s) {
		add_modules(s);
	    }
	    else if (argv[1]) {
		add_modules(argv[1]);
		argc--,argv++;
	    }
	    break;

	  case 'i':
	    forbid_setid(&quot;-i&quot;);
	    if (ruby_inplace_mode) free(ruby_inplace_mode);
	    ruby_inplace_mode = strdup(s+1);
	    break;

	  case 'x':
	    xflag = Qtrue;
	    s++;
	    if (*s &amp;&amp; chdir(s) &lt; 0) {
		rb_fatal(&quot;Can't chdir to %s&quot;, s);
	    }
	    break;

	  case 'C':
	  case 'X':
	    s++;
	    if (!*s) {
		s = argv[1];
		argc--,argv++;
	    }
	    if (!s || !*s) {
		rb_fatal(&quot;Can't chdir&quot;);
	    }
	    if (chdir(s) &lt; 0) {
		rb_fatal(&quot;Can't chdir to %s&quot;, s);
	    }
	    break;

	  case 'F':
	    if (*++s) {
		rb_fs = rb_reg_new(s, strlen(s), 0);
	    }
	    break;

	  case 'K':
	    if (*++s) {
		rb_set_kcode(s);
		s++;
	    }
	    goto reswitch;

	  case 'T':
	    {
		int numlen;
		int v = 1;

		if (*++s) {
		    v = scan_oct(s, 2, &amp;numlen);
		    if (numlen == 0) v = 1;
		    s += numlen;
		}
		rb_set_safe_level(v);
	    }
	    goto reswitch;

	  case 'I':
	    forbid_setid(&quot;-I&quot;);
	    if (*++s)
		ruby_incpush(s);
	    else if (argv[1]) {
		ruby_incpush(argv[1]);
		argc--,argv++;
	    }
	    break;

	  case '0':
	    {
		int numlen;
		int v;
		char c;

		v = scan_oct(s, 4, &amp;numlen);
		s += numlen;
		if (v &gt; 0377) rb_rs = Qnil;
		else if (v == 0 &amp;&amp; numlen &gt;= 2) {
		    rb_rs = rb_str_new2(&quot;\n\n&quot;);
		}
		else {
		    c = v &amp; 0xff;
		    rb_rs = rb_str_new(&amp;c, 1);
		}
	    }
	    goto reswitch;

	  case '-':
	    if (!s[1] || (s[1] == '\r' &amp;&amp; !s[2])) {
		argc--,argv++;
		goto switch_end;
	    }
	    s++;
	    if (strcmp(&quot;copyright&quot;, s) == 0)
		copyright = 1;
	    else if (strcmp(&quot;debug&quot;, s) == 0) {
		ruby_debug = Qtrue;
                ruby_verbose = Qtrue;
            }
	    else if (strcmp(&quot;version&quot;, s) == 0)
		version = 1;
	    else if (strcmp(&quot;verbose&quot;, s) == 0) {
		verbose = 1;
		ruby_verbose = Qtrue;
	    }
	    else if (strcmp(&quot;yydebug&quot;, s) == 0)
		ruby_yydebug = 1;
	    else if (strcmp(&quot;help&quot;, s) == 0) {
		usage(origargv[0]);
		exit(0);
	    }
	    else {
		fprintf(stderr, &quot;%s: invalid option --%s  (-h will show valid options)\n&quot;,
			origargv[0], s);
		exit(2);
	    }
	    break;

	  case '\r':
	    if (!s[1]) break;

	  default:
	    {
		const char *format;
		if (ISPRINT(*s)) {
		    format = &quot;%s: invalid option -%c  (-h will show valid options)\n&quot;;
		}
		else {
		    format = &quot;%s: invalid option -\\%03o  (-h will show valid options)\n&quot;;
		}
		fprintf(stderr, format, origargv[0], (int)(unsigned char)*s);
	    }
	    exit(2);

	  case 0:
	    break;
	}
    }

  switch_end:
    if (argv0 == 0) return;

    if (rb_safe_level() == 0 &amp;&amp; (s = getenv(&quot;RUBYOPT&quot;))) {
	while (ISSPACE(*s)) s++;
	if (*s == 'T' || (*s == '-' &amp;&amp; *(s+1) == 'T')) {
	    int numlen;
	    int v = 1;

	    if (*s != 'T') ++s;
	    if (*++s) {
		v = scan_oct(s, 2, &amp;numlen);
		if (numlen == 0) v = 1;
	    }
	    rb_set_safe_level(v);
	}
	else {
	    while (s &amp;&amp; *s) {
		if (*s == '-') {
		    s++;
		    if (ISSPACE(*s)) {
			do {s++;} while (ISSPACE(*s));
			continue;
		    }
		}
		if (!*s) break;
		if (!strchr(&quot;IdvwWrK&quot;, *s))
		    rb_raise(rb_eRuntimeError, &quot;illegal switch in RUBYOPT: -%c&quot;, *s);
		s = moreswitches(s);
	    }
	}
    }

    if (version) {
	ruby_show_version();
	exit(0);
    }
    if (copyright) {
	ruby_show_copyright();
    }

    if (rb_safe_level() &gt;= 4) {
	OBJ_TAINT(rb_argv);
	OBJ_TAINT(rb_load_path);
    }

    if (!e_script) {
	if (argc == 0) {	/* no more args */
	    if (verbose) exit(0);
	    script = &quot;-&quot;;
	}
	else {
	    script = argv[0];
#if defined DOSISH || defined __CYGWIN__
	    translate_char(argv[0], '\\', '/');
#endif
	    if (script[0] == '\0') {
		script = &quot;-&quot;;
	    }
	    else if (do_search) {
		char *path = getenv(&quot;RUBYPATH&quot;);

		script = 0;
		if (path) {
		    script = dln_find_file(argv[0], path);
		}
		if (!script) {
		    script = dln_find_file(argv[0], getenv(PATH_ENV));
		}
		if (!script) script = argv[0];
		script = ruby_sourcefile = rb_source_filename(script);
		script_node = NEW_NEWLINE(0);
#if defined DOSISH || defined __CYGWIN__
		translate_char(ruby_sourcefile, '\\', '/');
#endif
	    }
	    argc--; argv++;
	}
    }

    ruby_script(script);
    ruby_set_argv(argc, argv);
    process_sflag();

    ruby_init_loadpath();
    ruby_sourcefile = rb_source_filename(argv0);
    if (e_script) {
	require_libraries();
	rb_compile_string(script, e_script, 1);
    }
    else if (strlen(script) == 1 &amp;&amp; script[0] == '-') {
	load_stdin();
    }
    else {
	load_file(script, 1);
    }

    process_sflag();
    xflag = 0;

    if (rb_safe_level() &gt;= 4) {
	FL_UNSET(rb_argv, FL_TAINT);
	FL_UNSET(rb_load_path, FL_TAINT);
    }
}

extern int ruby__end__seen;

static void
load_file(fname, script)
    const char *fname;
    int script;
{
    extern VALUE rb_stdin;
    VALUE f;
    int line_start = 1;

    if (!fname) rb_load_fail(fname);
    if (strcmp(fname, &quot;-&quot;) == 0) {
	f = rb_stdin;
    }
    else {
	FILE *fp = fopen(fname, &quot;r&quot;);

	if (fp == NULL) {
	    rb_load_fail(fname);
	}
	fclose(fp);

	f = rb_file_open(fname, &quot;r&quot;);
#if defined DOSISH || defined __CYGWIN__
	{
	    char *ext = strrchr(fname, '.');
	    if (ext &amp;&amp; strcasecmp(ext, &quot;.exe&quot;) == 0)
		rb_io_binmode(f);
	}
#endif
    }

    if (script) {
	VALUE c = 1;		/* something not nil */
	VALUE line;
	char *p;

	if (xflag) {
	    forbid_setid(&quot;-x&quot;);
	    xflag = Qfalse;
	    while (!NIL_P(line = rb_io_gets(f))) {
		line_start++;
		if (RSTRING(line)-&gt;len &gt; 2
		    &amp;&amp; RSTRING(line)-&gt;ptr[0] == '#'
		    &amp;&amp; RSTRING(line)-&gt;ptr[1] == '!') {
		    if ((p = strstr(RSTRING(line)-&gt;ptr, &quot;ruby&quot;)) != 0) {
			goto start_read;
		    }
		}
	    }
	    rb_raise(rb_eLoadError, &quot;no Ruby script found in input&quot;);
	}

	c = rb_io_getc(f);
	if (c == INT2FIX('#')) {
	    line = rb_io_gets(f);
	    if (NIL_P(line)) return;
	    line_start++;

	    if (RSTRING(line)-&gt;len &gt; 2 &amp;&amp; RSTRING(line)-&gt;ptr[0] == '!') {
		if ((p = strstr(RSTRING(line)-&gt;ptr, &quot;ruby&quot;)) == 0) {
		    /* not ruby script, kick the program */
		    char **argv;
		    char *path;
		    char *pend = RSTRING(line)-&gt;ptr + RSTRING(line)-&gt;len;

		    p = RSTRING(line)-&gt;ptr + 1;	/* skip `#!' */
		    if (pend[-1] == '\n') pend--; /* chomp line */
		    if (pend[-1] == '\r') pend--;
		    *pend = '\0';
		    while (p &lt; pend &amp;&amp; ISSPACE(*p))
			p++;
		    path = p;	/* interpreter path */
		    while (p &lt; pend &amp;&amp; !ISSPACE(*p))
			p++;
		    *p++ = '\0';
		    if (p &lt; pend) {
			argv = ALLOCA_N(char*, origargc+3);
			argv[1] = p;
			MEMCPY(argv+2, origargv+1, char*, origargc);
		    }
		    else {
			argv = origargv;
		    }
		    argv[0] = path;
		    execv(path, argv);

		    ruby_sourcefile = rb_source_filename(fname);
		    ruby_sourceline = 1;
		    rb_fatal(&quot;Can't exec %s&quot;, path);
		}

	      start_read:
		p += 4;
		RSTRING(line)-&gt;ptr[RSTRING(line)-&gt;len-1] = '\0';
		if (RSTRING(line)-&gt;ptr[RSTRING(line)-&gt;len-2] == '\r')
		    RSTRING(line)-&gt;ptr[RSTRING(line)-&gt;len-2] = '\0';
		if ((p = strstr(p, &quot; -&quot;)) != 0) {
		    p++;	/* skip space before `-' */
		    while (*p == '-') {
			p = moreswitches(p+1);
		    }
		}
	    }
	}
	else if (!NIL_P(c)) {
	    rb_io_ungetc(f, c);
	}
	require_libraries();	/* Why here? unnatural */
	if (NIL_P(c)) return;
    }
    rb_compile_file(fname, f, line_start);
    if (script &amp;&amp; ruby__end__seen) {
	rb_define_global_const(&quot;DATA&quot;, f);
    }
    else if (f != rb_stdin) {
	rb_io_close(f);
    }

    if (ruby_parser_stack_on_heap()) {
        rb_gc();
    }
}

void
rb_load_file(fname)
    const char *fname;
{
    load_file(fname, 0);
}

static void
load_stdin()
{
    forbid_setid(&quot;program input from stdin&quot;);
    load_file(&quot;-&quot;, 1);
}

VALUE rb_progname;
VALUE rb_argv;
VALUE rb_argv0;

#if defined(PSTAT_SETCMD) || defined(HAVE_SETPROCTITLE)
#elif defined(_WIN32)
#elif defined(HAVE_SETENV) &amp;&amp; defined(HAVE_UNSETENV)
#else
#define USE_ENVSPACE_FOR_ARG0
#endif

#ifdef USE_ENVSPACE_FOR_ARG0
static struct {
    char *begin, *end;
} envspace;
extern char **environ;

static void
set_arg0space()
{
    char *s;
    int i;

    if (!environ || (s = environ[0]) == NULL) return;
    envspace.begin = s;
    s += strlen(s);
    for (i = 1; environ[i]; i++) {
	if (environ[i] == s + 1) {
	    s++;
	    s += strlen(s);	/* this one is ok too */
	}
    }
    envspace.end = s;
}
#else
#define set_arg0space() ((void)0)
#endif

static void
set_arg0(val, id)
    VALUE val;
    ID id;
{
    char *s;
    long i;
#if !defined(PSTAT_SETCMD) &amp;&amp; !defined(HAVE_SETPROCTITLE)
    static int len;
#endif

    if (origargv == 0) rb_raise(rb_eRuntimeError, &quot;$0 not initialized&quot;);
    StringValue(val);
    s = RSTRING(val)-&gt;ptr;
    i = RSTRING(val)-&gt;len;
#if defined(PSTAT_SETCMD)
    if (i &gt;= PST_CLEN) {
	union pstun j;
	j.pst_command = s;
	i = PST_CLEN;
	RSTRING(val)-&gt;len = i;
	*(s + i) = '\0';
	pstat(PSTAT_SETCMD, j, PST_CLEN, 0, 0);
    }
    else {
	union pstun j;
	j.pst_command = s;
	pstat(PSTAT_SETCMD, j, i, 0, 0);
    }
    rb_progname = rb_tainted_str_new(s, i);
#elif defined(HAVE_SETPROCTITLE)
    setproctitle(&quot;%.*s&quot;, (int)i, s);
    rb_progname = rb_tainted_str_new(s, i);
#else
    if (len == 0) {
	char *s = origargv[0];
	int i;

	s += strlen(s);
	/* See if all the arguments are contiguous in memory */
	for (i = 1; i &lt; origargc; i++) {
	    if (origargv[i] == s + 1) {
		s++;
		s += strlen(s);	/* this one is ok too */
	    }
	    else {
		break;
	    }
	}
#if defined(USE_ENVSPACE_FOR_ARG0)
	if (s + 1 == envspace.begin) {
	    s = envspace.end;
	    ruby_setenv(&quot;&quot;, NULL); /* duplicate environ vars */
	}
#endif
	len = s - origargv[0];
    }

    if (i &gt;= len) {
	i = len;
    }
    memcpy(origargv[0], s, i);
    s = origargv[0] + i;
    *s = '\0';
    if (++i &lt; len) memset(s + 1, ' ', len - i);
    for (i = 1; i &lt; origargc; i++)
	origargv[i] = s;
    rb_progname = rb_tainted_str_new2(origargv[0]);
#endif
}

void
ruby_script(name)
    const char *name;
{
    if (name) {
	rb_progname = rb_tainted_str_new2(name);
	ruby_sourcefile = rb_source_filename(name);
    }
}

static int uid, euid, gid, egid;

static void
init_ids()
{
    uid = (int)getuid();
    euid = (int)geteuid();
    gid = (int)getgid();
    egid = (int)getegid();
#ifdef VMS
    uid |= gid &lt;&lt; 16;
    euid |= egid &lt;&lt; 16;
#endif
    if (uid &amp;&amp; (euid != uid || egid != gid)) {
	rb_set_safe_level(1);
    }
}

static void
forbid_setid(s)
    const char *s;
{
    if (euid != uid)
        rb_raise(rb_eSecurityError, &quot;no %s allowed while running setuid&quot;, s);
    if (egid != gid)
        rb_raise(rb_eSecurityError, &quot;no %s allowed while running setgid&quot;, s);
    if (rb_safe_level() &gt; 0)
        rb_raise(rb_eSecurityError, &quot;no %s allowed in tainted mode&quot;, s);
}

static void
verbose_setter(val, id, variable)
    VALUE val;
    ID id;
    VALUE *variable;
{
    ruby_verbose = RTEST(val) ? Qtrue : val;
}

void
ruby_prog_init()
{
    init_ids();

    ruby_sourcefile = rb_source_filename(&quot;ruby&quot;);
    rb_define_hooked_variable(&quot;$VERBOSE&quot;, &amp;ruby_verbose, 0, verbose_setter);
    rb_define_hooked_variable(&quot;$-v&quot;, &amp;ruby_verbose, 0, verbose_setter);
    rb_define_hooked_variable(&quot;$-w&quot;, &amp;ruby_verbose, 0, verbose_setter);
    rb_define_variable(&quot;$DEBUG&quot;, &amp;ruby_debug);
    rb_define_variable(&quot;$-d&quot;, &amp;ruby_debug);
    rb_define_readonly_variable(&quot;$-p&quot;, &amp;do_print);
    rb_define_readonly_variable(&quot;$-l&quot;, &amp;do_line);

    rb_define_hooked_variable(&quot;$0&quot;, &amp;rb_progname, 0, set_arg0);
    rb_define_hooked_variable(&quot;$PROGRAM_NAME&quot;, &amp;rb_progname, 0, set_arg0);

    rb_define_readonly_variable(&quot;$*&quot;, &amp;rb_argv);
    rb_argv = rb_ary_new();
    rb_define_global_const(&quot;ARGV&quot;, rb_argv);
    rb_define_readonly_variable(&quot;$-a&quot;, &amp;do_split);
    rb_global_variable(&amp;rb_argv0);

#ifdef MSDOS
    /*
     * There is no way we can refer to them from ruby, so close them to save
     * space.
     */
    (void)fclose(stdaux);
    (void)fclose(stdprn);
#endif
}

void
ruby_set_argv(argc, argv)
    int argc;
    char **argv;
{
    int i;

#if defined(USE_DLN_A_OUT)
    if (origargv) dln_argv0 = origargv[0];
    else          dln_argv0 = argv[0];
#endif
    rb_ary_clear(rb_argv);
    for (i=0; i &lt; argc; i++) {
	VALUE arg = rb_tainted_str_new2(argv[i]);

	OBJ_FREEZE(arg);
	rb_ary_push(rb_argv, arg);
    }
}

void
ruby_process_options(argc, argv)
    int argc;
    char **argv;
{
    origargc = argc; origargv = argv;

    ruby_script(argv[0]);	/* for the time being */
    rb_argv0 = rb_progname;
#if defined(USE_DLN_A_OUT)
    dln_argv0 = argv[0];
#endif
    set_arg0space();
    proc_options(argc, argv);

    if (do_check &amp;&amp; ruby_nerrs == 0) {
	printf(&quot;Syntax OK\n&quot;);
	exit(0);
    }
    if (do_print) {
	rb_parser_append_print();
    }
    if (do_loop) {
	rb_parser_while_loop(do_line, do_split);
    }
}
</pre>
    </div>