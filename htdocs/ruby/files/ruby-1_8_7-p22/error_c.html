  <div id="fileHeader">
    <h1>error.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/error.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat May 31 08:37:06 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  error.c -

  $Author: knu $
  $Date: 2008-05-31 22:37:06 +0900 (Sat, 31 May 2008) $
  created at: Mon Aug  9 16:11:34 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;env.h&quot;
#include &quot;st.h&quot;

#include &lt;stdio.h&gt;
#ifdef HAVE_STDARG_PROTOTYPES
#include &lt;stdarg.h&gt;
#define va_init_list(a,b) va_start(a,b)
#else
#include &lt;varargs.h&gt;
#define va_init_list(a,b) va_start(a)
#endif
#ifdef HAVE_STDLIB_H
#include &lt;stdlib.h&gt;
#endif
#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

extern const char *ruby_description;

int ruby_nerrs;

static int
err_position(buf, len)
    char *buf;
    long len;
{
    ruby_set_current_source();
    if (!ruby_sourcefile) {
	return 0;
    }
    else if (ruby_sourceline == 0) {
	return snprintf(buf, len, &quot;%s: &quot;, ruby_sourcefile);
    }
    else {
	return snprintf(buf, len, &quot;%s:%d: &quot;, ruby_sourcefile, ruby_sourceline);
    }
}

static void
err_snprintf(buf, len, fmt, args)
    char *buf;
    long len;
    const char *fmt;
    va_list args;
{
    long n;

    n = err_position(buf, len);
    if (len &gt; n) {
	vsnprintf((char*)buf+n, len-n, fmt, args);
    }
}

static void err_append _((const char*));
static void
err_print(fmt, args)
    const char *fmt;
    va_list args;
{
    char buf[BUFSIZ];

    err_snprintf(buf, BUFSIZ, fmt, args);
    err_append(buf);
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_compile_error(const char *fmt, ...)
#else
rb_compile_error(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;

    va_init_list(args, fmt);
    err_print(fmt, args);
    va_end(args);
    ruby_nerrs++;
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_compile_error_append(const char *fmt, ...)
#else
rb_compile_error_append(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    err_append(buf);
}

static void
warn_print(fmt, args)
    const char *fmt;
    va_list args;
{
    char buf[BUFSIZ];
    int len;

    err_snprintf(buf, BUFSIZ, fmt, args);
    len = strlen(buf);
    buf[len++] = '\n';
    rb_write_error2(buf, len);
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_warn(const char *fmt, ...)
#else
rb_warn(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    char buf[BUFSIZ];
    va_list args;

    if (NIL_P(ruby_verbose)) return;

    snprintf(buf, BUFSIZ, &quot;warning: %s&quot;, fmt);

    va_init_list(args, fmt);
    warn_print(buf, args);
    va_end(args);
}

/* rb_warning() reports only in verbose mode */
void
#ifdef HAVE_STDARG_PROTOTYPES
rb_warning(const char *fmt, ...)
#else
rb_warning(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    char buf[BUFSIZ];
    va_list args;

    if (!RTEST(ruby_verbose)) return;

    snprintf(buf, BUFSIZ, &quot;warning: %s&quot;, fmt);

    va_init_list(args, fmt);
    warn_print(buf, args);
    va_end(args);
}

/*
 * call-seq:
 *    warn(msg)   =&gt; nil
 *
 * Display the given message (followed by a newline) on STDERR unless
 * warnings are disabled (for example with the &lt;code&gt;-W0&lt;/code&gt; flag).
 */

static VALUE
rb_warn_m(self, mesg)
    VALUE self, mesg;
{
    if (!NIL_P(ruby_verbose)) {
	rb_io_write(rb_stderr, mesg);
	rb_io_write(rb_stderr, rb_default_rs);
    }
    return Qnil;
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_bug(const char *fmt, ...)
#else
rb_bug(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    char buf[BUFSIZ];
    va_list args;
    FILE *out = stderr;
    int len = err_position(buf, BUFSIZ);

    if (fwrite(buf, 1, len, out) == len ||
	fwrite(buf, 1, len, (out = stdout)) == len) {
	fputs(&quot;[BUG] &quot;, out);
	va_init_list(args, fmt);
	vfprintf(out, fmt, args);
	va_end(args);
	fprintf(out, &quot;\n%s\n\n&quot;, ruby_description);
    }
    abort();
}

static struct types {
    int type;
    const char *name;
} builtin_types[] = {
    {T_NIL,	&quot;nil&quot;},
    {T_OBJECT,	&quot;Object&quot;},
    {T_CLASS,	&quot;Class&quot;},
    {T_ICLASS,	&quot;iClass&quot;},	/* internal use: mixed-in module holder */
    {T_MODULE,	&quot;Module&quot;},
    {T_FLOAT,	&quot;Float&quot;},
    {T_STRING,	&quot;String&quot;},
    {T_REGEXP,	&quot;Regexp&quot;},
    {T_ARRAY,	&quot;Array&quot;},
    {T_FIXNUM,	&quot;Fixnum&quot;},
    {T_HASH,	&quot;Hash&quot;},
    {T_STRUCT,	&quot;Struct&quot;},
    {T_BIGNUM,	&quot;Bignum&quot;},
    {T_FILE,	&quot;File&quot;},
    {T_TRUE,	&quot;true&quot;},
    {T_FALSE,	&quot;false&quot;},
    {T_SYMBOL,	&quot;Symbol&quot;},	/* :symbol */
    {T_DATA,	&quot;Data&quot;},	/* internal use: wrapped C pointers */
    {T_MATCH,	&quot;MatchData&quot;},	/* data of $~ */
    {T_VARMAP,	&quot;Varmap&quot;},	/* internal use: dynamic variables */
    {T_SCOPE,	&quot;Scope&quot;},	/* internal use: variable scope */
    {T_NODE,	&quot;Node&quot;},	/* internal use: syntax tree node */
    {T_UNDEF,	&quot;undef&quot;},	/* internal use: #undef; should not happen */
    {-1,	0}
};

void
rb_check_type(x, t)
    VALUE x;
    int t;
{
    struct types *type = builtin_types;

    if (x == Qundef) {
	rb_bug(&quot;undef leaked to the Ruby space&quot;);
    }

    if (TYPE(x) != t) {
	while (type-&gt;type &gt;= 0) {
	    if (type-&gt;type == t) {
		const char *etype;

		if (NIL_P(x)) {
		    etype = &quot;nil&quot;;
		}
		else if (FIXNUM_P(x)) {
		    etype = &quot;Fixnum&quot;;
		}
		else if (SYMBOL_P(x)) {
		    etype = &quot;Symbol&quot;;
		}
		else if (rb_special_const_p(x)) {
		    etype = RSTRING(rb_obj_as_string(x))-&gt;ptr;
		}
		else {
		    etype = rb_obj_classname(x);
		}
		rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected %s)&quot;,
			 etype, type-&gt;name);
	    }
	    type++;
	}
	rb_bug(&quot;unknown type 0x%x&quot;, t);
    }
}

/* exception classes */
#include &lt;errno.h&gt;

VALUE rb_eException;
VALUE rb_eSystemExit;
VALUE rb_eInterrupt;
VALUE rb_eSignal;
VALUE rb_eFatal;
VALUE rb_eStandardError;
VALUE rb_eRuntimeError;
VALUE rb_eTypeError;
VALUE rb_eArgError;
VALUE rb_eIndexError;
VALUE rb_eRangeError;
VALUE rb_eNameError;
VALUE rb_eNoMethodError;
VALUE rb_eSecurityError;
VALUE rb_eNotImpError;
VALUE rb_eNoMemError;
VALUE rb_cNameErrorMesg;

VALUE rb_eScriptError;
VALUE rb_eSyntaxError;
VALUE rb_eLoadError;

VALUE rb_eSystemCallError;
VALUE rb_mErrno;

VALUE
rb_exc_new(etype, ptr, len)
    VALUE etype;
    const char *ptr;
    long len;
{
    return rb_funcall(etype, rb_intern(&quot;new&quot;), 1, rb_str_new(ptr, len));
}

VALUE
rb_exc_new2(etype, s)
    VALUE etype;
    const char *s;
{
    return rb_exc_new(etype, s, strlen(s));
}

VALUE
rb_exc_new3(etype, str)
    VALUE etype, str;
{
    StringValue(str);
    return rb_exc_new(etype, RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len);
}

/*
 * call-seq:
 *    Exception.new(msg = nil)   =&gt;  exception
 *
 *  Construct a new Exception object, optionally passing in 
 *  a message.
 */

static VALUE
exc_initialize(argc, argv, exc)
    int argc;
    VALUE *argv;
    VALUE exc;
{
    VALUE arg;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;arg);
    rb_iv_set(exc, &quot;mesg&quot;, arg);
    rb_iv_set(exc, &quot;bt&quot;, Qnil);

    return exc;
}

/*
 *  Document-method: exception
 *
 *  call-seq:
 *     exc.exception(string) -&gt; an_exception or exc
 *  
 *  With no argument, or if the argument is the same as the receiver,
 *  return the receiver. Otherwise, create a new
 *  exception object of the same class as the receiver, but with a
 *  message equal to &lt;code&gt;string.to_str&lt;/code&gt;.
 *     
 */

static VALUE
exc_exception(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE exc;

    if (argc == 0) return self;
    if (argc == 1 &amp;&amp; self == argv[0]) return self;
    exc = rb_obj_clone(self);
    exc_initialize(argc, argv, exc);

    return exc;
}

/*
 * call-seq:
 *   exception.to_s   =&gt;  string
 *
 * Returns exception's message (or the name of the exception if
 * no message is set).
 */

static VALUE
exc_to_s(exc)
    VALUE exc;
{
    VALUE mesg = rb_attr_get(exc, rb_intern(&quot;mesg&quot;));

    if (NIL_P(mesg)) return rb_class_name(CLASS_OF(exc));
    if (OBJ_TAINTED(exc)) OBJ_TAINT(mesg);
    return mesg;
}

/*
 * call-seq:
 *   exception.message   =&gt;  string
 *   exception.to_str    =&gt;  string
 *
 * Returns the result of invoking &lt;code&gt;exception.to_s&lt;/code&gt;.
 * Normally this returns the exception's message or name. By
 * supplying a to_str method, exceptions are agreeing to
 * be used where Strings are expected.
 */

static VALUE
exc_to_str(exc)
    VALUE exc;
{
    return rb_funcall(exc, rb_intern(&quot;to_s&quot;), 0, 0);
}

/*
 * call-seq:
 *   exception.inspect   =&gt; string
 *
 * Return this exception's class name an message
 */

static VALUE
exc_inspect(exc)
    VALUE exc;
{
    VALUE str, klass;

    klass = CLASS_OF(exc);
    exc = rb_obj_as_string(exc);
    if (RSTRING(exc)-&gt;len == 0) {
	return rb_str_dup(rb_class_name(klass));
    }

    str = rb_str_buf_new2(&quot;#&lt;&quot;);
    klass = rb_class_name(klass);
    rb_str_buf_append(str, klass);
    rb_str_buf_cat(str, &quot;: &quot;, 2);
    rb_str_buf_append(str, exc);
    rb_str_buf_cat(str, &quot;&gt;&quot;, 1);

    return str;
}

/*
 *  call-seq:
 *     exception.backtrace    =&gt; array
 *  
 *  Returns any backtrace associated with the exception. The backtrace
 *  is an array of strings, each containing either ``filename:lineNo: in
 *  `method''' or ``filename:lineNo.''
 *     
 *     def a
 *       raise &quot;boom&quot;
 *     end
 *     
 *     def b
 *       a()
 *     end
 *     
 *     begin
 *       b()
 *     rescue =&gt; detail
 *       print detail.backtrace.join(&quot;\n&quot;)
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     prog.rb:2:in `a'
 *     prog.rb:6:in `b'
 *     prog.rb:10
*/

static VALUE
exc_backtrace(exc)
    VALUE exc;
{
    static ID bt;

    if (!bt) bt = rb_intern(&quot;bt&quot;);
    return rb_attr_get(exc, bt);
}

VALUE
rb_check_backtrace(bt)
    VALUE bt;
{
    long i;
    static const char err[] = &quot;backtrace must be Array of String&quot;;

    if (!NIL_P(bt)) {
	int t = TYPE(bt);

	if (t == T_STRING) return rb_ary_new3(1, bt);
	if (t != T_ARRAY) {
	    rb_raise(rb_eTypeError, err);
	}
	for (i=0;i&lt;RARRAY(bt)-&gt;len;i++) {
	    if (TYPE(RARRAY(bt)-&gt;ptr[i]) != T_STRING) {
		rb_raise(rb_eTypeError, err);
	    }
	}
    }
    return bt;
}

/*
 *  call-seq:
 *     exc.set_backtrace(array)   =&gt;  array
 *  
 *  Sets the backtrace information associated with &lt;i&gt;exc&lt;/i&gt;. The
 *  argument must be an array of &lt;code&gt;String&lt;/code&gt; objects in the
 *  format described in &lt;code&gt;Exception#backtrace&lt;/code&gt;.
 *     
 */

static VALUE
exc_set_backtrace(exc, bt)
    VALUE exc;
    VALUE bt;
{
    return rb_iv_set(exc, &quot;bt&quot;, rb_check_backtrace(bt));
}

/*
 * call-seq:
 *   SystemExit.new(status=0)   =&gt; system_exit
 *
 * Create a new +SystemExit+ exception with the given status.
 */

static VALUE
exit_initialize(argc, argv, exc)
    int argc;
    VALUE *argv;
    VALUE exc;
{
    VALUE status = INT2FIX(EXIT_SUCCESS);
    if (argc &gt; 0 &amp;&amp; FIXNUM_P(argv[0])) {
	status = *argv++;
	--argc;
    }
    rb_call_super(argc, argv);
    rb_iv_set(exc, &quot;status&quot;, status);
    return exc;
}


/*
 * call-seq:
 *   system_exit.status   =&gt; fixnum
 *
 * Return the status value associated with this system exit.
 */

static VALUE
exit_status(exc)
    VALUE exc;
{
    return rb_attr_get(exc, rb_intern(&quot;status&quot;));
}


/*
 * call-seq:
 *   system_exit.success?  =&gt; true or false
 *
 * Returns +true+ if exiting successful, +false+ if not.
 */

static VALUE
exit_success_p(exc)
    VALUE exc;
{
    VALUE status = rb_attr_get(exc, rb_intern(&quot;status&quot;));
    if (NIL_P(status)) return Qtrue;
    if (status == INT2FIX(EXIT_SUCCESS)) return Qtrue;
    return Qfalse;
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_name_error(ID id, const char *fmt, ...)
#else
rb_name_error(id, fmt, va_alist)
    ID id;
    const char *fmt;
    va_dcl
#endif
{
    VALUE exc, argv[2];
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);

    argv[0] = rb_str_new2(buf);
    argv[1] = ID2SYM(id);
    exc = rb_class_new_instance(2, argv, rb_eNameError);
    rb_exc_raise(exc);
}

/*
 * call-seq:
 *   NameError.new(msg [, name])  =&gt; name_error
 *
 * Construct a new NameError exception. If given the &lt;i&gt;name&lt;/i&gt;
 * parameter may subsequently be examined using the &lt;code&gt;NameError.name&lt;/code&gt;
 * method.
 */

static VALUE
name_err_initialize(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE name;

    name = (argc &gt; 1) ? argv[--argc] : Qnil;
    rb_call_super(argc, argv);
    rb_iv_set(self, &quot;name&quot;, name);
    return self;
}

/*
 *  call-seq:
 *    name_error.name    =&gt;  string or nil
 *
 *  Return the name associated with this NameError exception.
 */

static VALUE
name_err_name(self)
    VALUE self;
{
    return rb_attr_get(self, rb_intern(&quot;name&quot;));
}

/*
 * call-seq:
 *  name_error.to_s   =&gt; string
 *
 * Produce a nicely-formated string representing the +NameError+.
 */

static VALUE
name_err_to_s(exc)
    VALUE exc;
{
    VALUE mesg = rb_attr_get(exc, rb_intern(&quot;mesg&quot;)), str = mesg;

    if (NIL_P(mesg)) return rb_class_name(CLASS_OF(exc));
    StringValue(str);
    if (str != mesg) {
	rb_iv_set(exc, &quot;mesg&quot;, mesg = str);
    }
    if (OBJ_TAINTED(exc)) OBJ_TAINT(mesg);
    return mesg;
}

/*
 * call-seq:
 *   NoMethodError.new(msg, name [, args])  =&gt; no_method_error
 *
 * Construct a NoMethodError exception for a method of the given name
 * called with the given arguments. The name may be accessed using
 * the &lt;code&gt;#name&lt;/code&gt; method on the resulting object, and the
 * arguments using the &lt;code&gt;#args&lt;/code&gt; method.
 */

static VALUE
nometh_err_initialize(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE args = (argc &gt; 2) ? argv[--argc] : Qnil;
    name_err_initialize(argc, argv, self);
    rb_iv_set(self, &quot;args&quot;, args);
    return self;
}

/* :nodoc: */
static void
name_err_mesg_mark(ptr)
    VALUE *ptr;
{
    rb_gc_mark_locations(ptr, ptr+3);
}

/* :nodoc: */
static VALUE
name_err_mesg_new(obj, mesg, recv, method)
    VALUE obj, mesg, recv, method;
{
    VALUE *ptr = ALLOC_N(VALUE, 3);

    ptr[0] = mesg;
    ptr[1] = recv;
    ptr[2] = method;
    return Data_Wrap_Struct(rb_cNameErrorMesg, name_err_mesg_mark, -1, ptr);
}

/* :nodoc: */
static VALUE
name_err_mesg_to_str(obj)
    VALUE obj;
{
    VALUE *ptr, mesg;
    Data_Get_Struct(obj, VALUE, ptr);

    mesg = ptr[0];
    if (NIL_P(mesg)) return Qnil;
    else {
	const char *desc = 0;
	VALUE d = 0, args[3];

	obj = ptr[1];
	switch (TYPE(obj)) {
	  case T_NIL:
	    desc = &quot;nil&quot;;
	    break;
	  case T_TRUE:
	    desc = &quot;true&quot;;
	    break;
	  case T_FALSE:
	    desc = &quot;false&quot;;
	    break;
	  default:
	    d = rb_protect(rb_inspect, obj, 0);
	    if (NIL_P(d) || RSTRING(d)-&gt;len &gt; 65) {
		d = rb_any_to_s(obj);
	    }
	    desc = RSTRING(d)-&gt;ptr;
	    break;
	}
	if (desc &amp;&amp; desc[0] != '#') {
	    d = rb_str_new2(desc);
	    rb_str_cat2(d, &quot;:&quot;);
	    rb_str_cat2(d, rb_obj_classname(obj));
	}
	args[0] = mesg;
	args[1] = ptr[2];
	args[2] = d;
	mesg = rb_f_sprintf(3, args);
    }
    if (OBJ_TAINTED(obj)) OBJ_TAINT(mesg);
    return mesg;
}

/* :nodoc: */
static VALUE
name_err_mesg_load(klass, str)
    VALUE klass, str;
{
    return str;
}

/*
 * call-seq:
 *   no_method_error.args  =&gt; obj
 *
 * Return the arguments passed in as the third parameter to
 * the constructor.
 */

static VALUE
nometh_err_args(self)
    VALUE self;
{
    return rb_attr_get(self, rb_intern(&quot;args&quot;));
}

void
rb_invalid_str(str, type)
    const char *str, *type;
{
    VALUE s = rb_str_inspect(rb_str_new2(str));

    rb_raise(rb_eArgError, &quot;invalid value for %s: %s&quot;, type, RSTRING(s)-&gt;ptr);
}

/* 
 *  Document-module: Errno
 *
 *  Ruby exception objects are subclasses of &lt;code&gt;Exception&lt;/code&gt;.
 *  However, operating systems typically report errors using plain
 *  integers. Module &lt;code&gt;Errno&lt;/code&gt; is created dynamically to map
 *  these operating system errors to Ruby classes, with each error
 *  number generating its own subclass of &lt;code&gt;SystemCallError&lt;/code&gt;.
 *  As the subclass is created in module &lt;code&gt;Errno&lt;/code&gt;, its name
 *  will start &lt;code&gt;Errno::&lt;/code&gt;.
 *     
 *  The names of the &lt;code&gt;Errno::&lt;/code&gt; classes depend on
 *  the environment in which Ruby runs. On a typical Unix or Windows
 *  platform, there are &lt;code&gt;Errno&lt;/code&gt; classes such as
 *  &lt;code&gt;Errno::EACCES&lt;/code&gt;, &lt;code&gt;Errno::EAGAIN&lt;/code&gt;,
 *  &lt;code&gt;Errno::EINTR&lt;/code&gt;, and so on.
 *     
 *  The integer operating system error number corresponding to a
 *  particular error is available as the class constant
 *  &lt;code&gt;Errno::&lt;/code&gt;&lt;em&gt;error&lt;/em&gt;&lt;code&gt;::Errno&lt;/code&gt;.
 *     
 *     Errno::EACCES::Errno   #=&gt; 13
 *     Errno::EAGAIN::Errno   #=&gt; 11
 *     Errno::EINTR::Errno    #=&gt; 4
 *     
 *  The full list of operating system errors on your particular platform
 *  are available as the constants of &lt;code&gt;Errno&lt;/code&gt;.
 *
 *     Errno.constants   #=&gt; E2BIG, EACCES, EADDRINUSE, EADDRNOTAVAIL, ...
 */

static st_table *syserr_tbl;

static VALUE
set_syserr(n, name)
    int n;
    const char *name;
{
    VALUE error;

    if (!st_lookup(syserr_tbl, n, &amp;error)) {
	error = rb_define_class_under(rb_mErrno, name, rb_eSystemCallError);
	rb_define_const(error, &quot;Errno&quot;, INT2NUM(n));
	st_add_direct(syserr_tbl, n, error);
    }
    else {
	rb_define_const(rb_mErrno, name, error);
    }
    return error;
}

static VALUE
get_syserr(n)
    int n;
{
    VALUE error;

    if (!st_lookup(syserr_tbl, n, &amp;error)) {
	char name[8];	/* some Windows' errno have 5 digits. */

	snprintf(name, sizeof(name), &quot;E%03d&quot;, n);
	error = set_syserr(n, name);
    }
    return error;
}

/*
 * call-seq:
 *   SystemCallError.new(msg, errno)  =&gt; system_call_error_subclass
 *
 * If _errno_ corresponds to a known system error code, constructs
 * the appropriate &lt;code&gt;Errno&lt;/code&gt; class for that error, otherwise
 * constructs a generic &lt;code&gt;SystemCallError&lt;/code&gt; object. The
 * error number is subsequently available via the &lt;code&gt;errno&lt;/code&gt;
 * method.
 */

static VALUE
syserr_initialize(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
#if !defined(_WIN32) &amp;&amp; !defined(__VMS)
    char *strerror();
#endif
    const char *err;
    VALUE mesg, error;
    VALUE klass = rb_obj_class(self);

    if (klass == rb_eSystemCallError) {
	rb_scan_args(argc, argv, &quot;11&quot;, &amp;mesg, &amp;error);
	if (argc == 1 &amp;&amp; FIXNUM_P(mesg)) {
	    error = mesg; mesg = Qnil;
	}
	if (!NIL_P(error) &amp;&amp; st_lookup(syserr_tbl, NUM2LONG(error), &amp;klass)) {
	    /* change class */
	    if (TYPE(self) != T_OBJECT) { /* insurance to avoid type crash */
		rb_raise(rb_eTypeError, &quot;invalid instance type&quot;);
	    }
	    RBASIC(self)-&gt;klass = klass;
	}
    }
    else {
	rb_scan_args(argc, argv, &quot;01&quot;, &amp;mesg);
	error = rb_const_get(klass, rb_intern(&quot;Errno&quot;));
    }
    if (!NIL_P(error)) err = strerror(NUM2LONG(error));
    else err = &quot;unknown error&quot;;
    if (!NIL_P(mesg)) {
	VALUE str = mesg;
	size_t len;

	StringValue(str);
	len = strlen(err)+RSTRING(str)-&gt;len+3;
	mesg = rb_str_new(0, len);
	snprintf(RSTRING(mesg)-&gt;ptr, len+1, &quot;%s - %.*s&quot;, err,
		(int)RSTRING(str)-&gt;len, RSTRING(str)-&gt;ptr);
	rb_str_resize(mesg, strlen(RSTRING(mesg)-&gt;ptr));
    }
    else {
	mesg = rb_str_new2(err);
    }
    rb_call_super(1, &amp;mesg);
    rb_iv_set(self, &quot;errno&quot;, error);
    return self;
}

/*
 * call-seq:
 *   system_call_error.errno   =&gt; fixnum
 *
 * Return this SystemCallError's error number.
 */

static VALUE
syserr_errno(self)
    VALUE self;
{
    return rb_attr_get(self, rb_intern(&quot;errno&quot;));
}

/*
 * call-seq:
 *   system_call_error === other  =&gt; true or false
 *
 * Return +true+ if the receiver is a generic +SystemCallError+, or
 * if the error numbers _self_ and _other_ are the same.
 */


static VALUE
syserr_eqq(self, exc)
    VALUE self, exc;
{
    VALUE num, e;
    ID en = rb_intern(&quot;errno&quot;);

    if (!rb_obj_is_kind_of(exc, rb_eSystemCallError)) {
	if (!rb_respond_to(exc, en)) return Qfalse;
    }
    else if (self == rb_eSystemCallError) return Qtrue;

    num = rb_attr_get(exc, en);
    if (NIL_P(num)) {
	num = rb_funcall(exc, en, 0, 0);
    }
    e = rb_const_get(self, rb_intern(&quot;Errno&quot;));
    if (FIXNUM_P(num) ? num == e : rb_equal(num, e))
	return Qtrue;
    return Qfalse;
}

/*
 *  Descendents of class &lt;code&gt;Exception&lt;/code&gt; are used to communicate
 *  between &lt;code&gt;raise&lt;/code&gt; methods and &lt;code&gt;rescue&lt;/code&gt;
 *  statements in &lt;code&gt;begin/end&lt;/code&gt; blocks. &lt;code&gt;Exception&lt;/code&gt;
 *  objects carry information about the exception---its type (the
 *  exception's class name), an optional descriptive string, and
 *  optional traceback information. Programs may subclass 
 *  &lt;code&gt;Exception&lt;/code&gt; to add additional information.
 */

void
Init_Exception()
{
    rb_eException   = rb_define_class(&quot;Exception&quot;, rb_cObject);
    rb_define_singleton_method(rb_eException, &quot;exception&quot;, rb_class_new_instance, -1);
    rb_define_method(rb_eException, &quot;exception&quot;, exc_exception, -1);
    rb_define_method(rb_eException, &quot;initialize&quot;, exc_initialize, -1);
    rb_define_method(rb_eException, &quot;to_s&quot;, exc_to_s, 0);
    rb_define_method(rb_eException, &quot;to_str&quot;, exc_to_str, 0);
    rb_define_method(rb_eException, &quot;message&quot;, exc_to_str, 0);
    rb_define_method(rb_eException, &quot;inspect&quot;, exc_inspect, 0);
    rb_define_method(rb_eException, &quot;backtrace&quot;, exc_backtrace, 0);
    rb_define_method(rb_eException, &quot;set_backtrace&quot;, exc_set_backtrace, 1);

    rb_eSystemExit  = rb_define_class(&quot;SystemExit&quot;, rb_eException);
    rb_define_method(rb_eSystemExit, &quot;initialize&quot;, exit_initialize, -1);
    rb_define_method(rb_eSystemExit, &quot;status&quot;, exit_status, 0);
    rb_define_method(rb_eSystemExit, &quot;success?&quot;, exit_success_p, 0);

    rb_eFatal  	    = rb_define_class(&quot;fatal&quot;, rb_eException);
    rb_eSignal      = rb_define_class(&quot;SignalException&quot;, rb_eException);
    rb_eInterrupt   = rb_define_class(&quot;Interrupt&quot;, rb_eSignal);

    rb_eStandardError = rb_define_class(&quot;StandardError&quot;, rb_eException);
    rb_eTypeError     = rb_define_class(&quot;TypeError&quot;, rb_eStandardError);
    rb_eArgError      = rb_define_class(&quot;ArgumentError&quot;, rb_eStandardError);
    rb_eIndexError    = rb_define_class(&quot;IndexError&quot;, rb_eStandardError);
    rb_eRangeError    = rb_define_class(&quot;RangeError&quot;, rb_eStandardError);
    rb_eNameError     = rb_define_class(&quot;NameError&quot;, rb_eStandardError);
    rb_define_method(rb_eNameError, &quot;initialize&quot;, name_err_initialize, -1);
    rb_define_method(rb_eNameError, &quot;name&quot;, name_err_name, 0);
    rb_define_method(rb_eNameError, &quot;to_s&quot;, name_err_to_s, 0);
    rb_cNameErrorMesg = rb_define_class_under(rb_eNameError, &quot;message&quot;, rb_cData);
    rb_define_singleton_method(rb_cNameErrorMesg, &quot;!&quot;, name_err_mesg_new, 3);
    rb_define_method(rb_cNameErrorMesg, &quot;to_str&quot;, name_err_mesg_to_str, 0);
    rb_define_method(rb_cNameErrorMesg, &quot;_dump&quot;, name_err_mesg_to_str, 1);
    rb_define_singleton_method(rb_cNameErrorMesg, &quot;_load&quot;, name_err_mesg_load, 1);
    rb_eNoMethodError = rb_define_class(&quot;NoMethodError&quot;, rb_eNameError);
    rb_define_method(rb_eNoMethodError, &quot;initialize&quot;, nometh_err_initialize, -1);
    rb_define_method(rb_eNoMethodError, &quot;args&quot;, nometh_err_args, 0);

    rb_eScriptError = rb_define_class(&quot;ScriptError&quot;, rb_eException);
    rb_eSyntaxError = rb_define_class(&quot;SyntaxError&quot;, rb_eScriptError);
    rb_eLoadError   = rb_define_class(&quot;LoadError&quot;, rb_eScriptError);
    rb_eNotImpError = rb_define_class(&quot;NotImplementedError&quot;, rb_eScriptError);

    rb_eRuntimeError = rb_define_class(&quot;RuntimeError&quot;, rb_eStandardError);
    rb_eSecurityError = rb_define_class(&quot;SecurityError&quot;, rb_eStandardError);
    rb_eNoMemError = rb_define_class(&quot;NoMemoryError&quot;, rb_eException);

    syserr_tbl = st_init_numtable();
    rb_eSystemCallError = rb_define_class(&quot;SystemCallError&quot;, rb_eStandardError);
    rb_define_method(rb_eSystemCallError, &quot;initialize&quot;, syserr_initialize, -1);
    rb_define_method(rb_eSystemCallError, &quot;errno&quot;, syserr_errno, 0);
    rb_define_singleton_method(rb_eSystemCallError, &quot;===&quot;, syserr_eqq, 1);

    rb_mErrno = rb_define_module(&quot;Errno&quot;);

    rb_define_global_function(&quot;warn&quot;, rb_warn_m, 1);
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_raise(VALUE exc, const char *fmt, ...)
#else
rb_raise(exc, fmt, va_alist)
    VALUE exc;
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args,fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(exc, buf));
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_loaderror(const char *fmt, ...)
#else
rb_loaderror(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);
    rb_exc_raise(rb_exc_new2(rb_eLoadError, buf));
}

void
rb_notimplement()
{
    rb_raise(rb_eNotImpError,
	     &quot;%s() function is unimplemented on this machine&quot;,
	     rb_id2name(ruby_frame-&gt;last_func));
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_fatal(const char *fmt, ...)
#else
rb_fatal(fmt, va_alist)
    const char *fmt;
    va_dcl
#endif
{
    va_list args;
    char buf[BUFSIZ];

    va_init_list(args, fmt);
    vsnprintf(buf, BUFSIZ, fmt, args);
    va_end(args);

    ruby_in_eval = 0;
    rb_exc_fatal(rb_exc_new2(rb_eFatal, buf));
}

void
rb_sys_fail(mesg)
    const char *mesg;
{
    int n = errno;
    VALUE arg;

    errno = 0;
    if (n == 0) {
	rb_bug(&quot;rb_sys_fail(%s) - errno == 0&quot;, mesg ? mesg : &quot;&quot;);
    }

    arg = mesg ? rb_str_new2(mesg) : Qnil;
    rb_exc_raise(rb_class_new_instance(1, &amp;arg, get_syserr(n)));
}

void
#ifdef HAVE_STDARG_PROTOTYPES
rb_sys_warning(const char *fmt, ...)
#else
rb_sys_warning(fmt, va_alist)
     const char *fmt;
     va_dcl
#endif
{
     char buf[BUFSIZ];
     va_list args;
     int errno_save;
     
     errno_save = errno;

     if (!RTEST(ruby_verbose)) return;

     snprintf(buf, BUFSIZ, &quot;warning: %s&quot;, fmt);
     snprintf(buf+strlen(buf), BUFSIZ-strlen(buf), &quot;: %s&quot;, strerror(errno_save));
     
     va_init_list(args, fmt);
     warn_print(buf, args);
     va_end(args);
     errno = errno_save;
}

void
rb_load_fail(path)
    const char *path;
{
    rb_loaderror(&quot;%s -- %s&quot;, strerror(errno), path);
}

void
rb_error_frozen(what)
    const char *what;
{
    rb_raise(rb_eTypeError, &quot;can't modify frozen %s&quot;, what);
}

void
rb_check_frozen(obj)
    VALUE obj;
{
    if (OBJ_FROZEN(obj)) rb_error_frozen(rb_obj_classname(obj));
}

void
Init_syserr()
{
#ifdef EPERM
    set_syserr(EPERM, &quot;EPERM&quot;);
#endif
#ifdef ENOENT
    set_syserr(ENOENT, &quot;ENOENT&quot;);
#endif
#ifdef ESRCH
    set_syserr(ESRCH, &quot;ESRCH&quot;);
#endif
#ifdef EINTR
    set_syserr(EINTR, &quot;EINTR&quot;);
#endif
#ifdef EIO
    set_syserr(EIO, &quot;EIO&quot;);
#endif
#ifdef ENXIO
    set_syserr(ENXIO, &quot;ENXIO&quot;);
#endif
#ifdef E2BIG
    set_syserr(E2BIG, &quot;E2BIG&quot;);
#endif
#ifdef ENOEXEC
    set_syserr(ENOEXEC, &quot;ENOEXEC&quot;);
#endif
#ifdef EBADF
    set_syserr(EBADF, &quot;EBADF&quot;);
#endif
#ifdef ECHILD
    set_syserr(ECHILD, &quot;ECHILD&quot;);
#endif
#ifdef EAGAIN
    set_syserr(EAGAIN, &quot;EAGAIN&quot;);
#endif
#ifdef ENOMEM
    set_syserr(ENOMEM, &quot;ENOMEM&quot;);
#endif
#ifdef EACCES
    set_syserr(EACCES, &quot;EACCES&quot;);
#endif
#ifdef EFAULT
    set_syserr(EFAULT, &quot;EFAULT&quot;);
#endif
#ifdef ENOTBLK
    set_syserr(ENOTBLK, &quot;ENOTBLK&quot;);
#endif
#ifdef EBUSY
    set_syserr(EBUSY, &quot;EBUSY&quot;);
#endif
#ifdef EEXIST
    set_syserr(EEXIST, &quot;EEXIST&quot;);
#endif
#ifdef EXDEV
    set_syserr(EXDEV, &quot;EXDEV&quot;);
#endif
#ifdef ENODEV
    set_syserr(ENODEV, &quot;ENODEV&quot;);
#endif
#ifdef ENOTDIR
    set_syserr(ENOTDIR, &quot;ENOTDIR&quot;);
#endif
#ifdef EISDIR
    set_syserr(EISDIR, &quot;EISDIR&quot;);
#endif
#ifdef EINVAL
    set_syserr(EINVAL, &quot;EINVAL&quot;);
#endif
#ifdef ENFILE
    set_syserr(ENFILE, &quot;ENFILE&quot;);
#endif
#ifdef EMFILE
    set_syserr(EMFILE, &quot;EMFILE&quot;);
#endif
#ifdef ENOTTY
    set_syserr(ENOTTY, &quot;ENOTTY&quot;);
#endif
#ifdef ETXTBSY
    set_syserr(ETXTBSY, &quot;ETXTBSY&quot;);
#endif
#ifdef EFBIG
    set_syserr(EFBIG, &quot;EFBIG&quot;);
#endif
#ifdef ENOSPC
    set_syserr(ENOSPC, &quot;ENOSPC&quot;);
#endif
#ifdef ESPIPE
    set_syserr(ESPIPE, &quot;ESPIPE&quot;);
#endif
#ifdef EROFS
    set_syserr(EROFS, &quot;EROFS&quot;);
#endif
#ifdef EMLINK
    set_syserr(EMLINK, &quot;EMLINK&quot;);
#endif
#ifdef EPIPE
    set_syserr(EPIPE, &quot;EPIPE&quot;);
#endif
#ifdef EDOM
    set_syserr(EDOM, &quot;EDOM&quot;);
#endif
#ifdef ERANGE
    set_syserr(ERANGE, &quot;ERANGE&quot;);
#endif
#ifdef EDEADLK
    set_syserr(EDEADLK, &quot;EDEADLK&quot;);
#endif
#ifdef ENAMETOOLONG
    set_syserr(ENAMETOOLONG, &quot;ENAMETOOLONG&quot;);
#endif
#ifdef ENOLCK
    set_syserr(ENOLCK, &quot;ENOLCK&quot;);
#endif
#ifdef ENOSYS
    set_syserr(ENOSYS, &quot;ENOSYS&quot;);
#endif
#ifdef ENOTEMPTY
    set_syserr(ENOTEMPTY, &quot;ENOTEMPTY&quot;);
#endif
#ifdef ELOOP
    set_syserr(ELOOP, &quot;ELOOP&quot;);
#endif
#ifdef EWOULDBLOCK
    set_syserr(EWOULDBLOCK, &quot;EWOULDBLOCK&quot;);
#endif
#ifdef ENOMSG
    set_syserr(ENOMSG, &quot;ENOMSG&quot;);
#endif
#ifdef EIDRM
    set_syserr(EIDRM, &quot;EIDRM&quot;);
#endif
#ifdef ECHRNG
    set_syserr(ECHRNG, &quot;ECHRNG&quot;);
#endif
#ifdef EL2NSYNC
    set_syserr(EL2NSYNC, &quot;EL2NSYNC&quot;);
#endif
#ifdef EL3HLT
    set_syserr(EL3HLT, &quot;EL3HLT&quot;);
#endif
#ifdef EL3RST
    set_syserr(EL3RST, &quot;EL3RST&quot;);
#endif
#ifdef ELNRNG
    set_syserr(ELNRNG, &quot;ELNRNG&quot;);
#endif
#ifdef EUNATCH
    set_syserr(EUNATCH, &quot;EUNATCH&quot;);
#endif
#ifdef ENOCSI
    set_syserr(ENOCSI, &quot;ENOCSI&quot;);
#endif
#ifdef EL2HLT
    set_syserr(EL2HLT, &quot;EL2HLT&quot;);
#endif
#ifdef EBADE
    set_syserr(EBADE, &quot;EBADE&quot;);
#endif
#ifdef EBADR
    set_syserr(EBADR, &quot;EBADR&quot;);
#endif
#ifdef EXFULL
    set_syserr(EXFULL, &quot;EXFULL&quot;);
#endif
#ifdef ENOANO
    set_syserr(ENOANO, &quot;ENOANO&quot;);
#endif
#ifdef EBADRQC
    set_syserr(EBADRQC, &quot;EBADRQC&quot;);
#endif
#ifdef EBADSLT
    set_syserr(EBADSLT, &quot;EBADSLT&quot;);
#endif
#ifdef EDEADLOCK
    set_syserr(EDEADLOCK, &quot;EDEADLOCK&quot;);
#endif
#ifdef EBFONT
    set_syserr(EBFONT, &quot;EBFONT&quot;);
#endif
#ifdef ENOSTR
    set_syserr(ENOSTR, &quot;ENOSTR&quot;);
#endif
#ifdef ENODATA
    set_syserr(ENODATA, &quot;ENODATA&quot;);
#endif
#ifdef ETIME
    set_syserr(ETIME, &quot;ETIME&quot;);
#endif
#ifdef ENOSR
    set_syserr(ENOSR, &quot;ENOSR&quot;);
#endif
#ifdef ENONET
    set_syserr(ENONET, &quot;ENONET&quot;);
#endif
#ifdef ENOPKG
    set_syserr(ENOPKG, &quot;ENOPKG&quot;);
#endif
#ifdef EREMOTE
    set_syserr(EREMOTE, &quot;EREMOTE&quot;);
#endif
#ifdef ENOLINK
    set_syserr(ENOLINK, &quot;ENOLINK&quot;);
#endif
#ifdef EADV
    set_syserr(EADV, &quot;EADV&quot;);
#endif
#ifdef ESRMNT
    set_syserr(ESRMNT, &quot;ESRMNT&quot;);
#endif
#ifdef ECOMM
    set_syserr(ECOMM, &quot;ECOMM&quot;);
#endif
#ifdef EPROTO
    set_syserr(EPROTO, &quot;EPROTO&quot;);
#endif
#ifdef EMULTIHOP
    set_syserr(EMULTIHOP, &quot;EMULTIHOP&quot;);
#endif
#ifdef EDOTDOT
    set_syserr(EDOTDOT, &quot;EDOTDOT&quot;);
#endif
#ifdef EBADMSG
    set_syserr(EBADMSG, &quot;EBADMSG&quot;);
#endif
#ifdef EOVERFLOW
    set_syserr(EOVERFLOW, &quot;EOVERFLOW&quot;);
#endif
#ifdef ENOTUNIQ
    set_syserr(ENOTUNIQ, &quot;ENOTUNIQ&quot;);
#endif
#ifdef EBADFD
    set_syserr(EBADFD, &quot;EBADFD&quot;);
#endif
#ifdef EREMCHG
    set_syserr(EREMCHG, &quot;EREMCHG&quot;);
#endif
#ifdef ELIBACC
    set_syserr(ELIBACC, &quot;ELIBACC&quot;);
#endif
#ifdef ELIBBAD
    set_syserr(ELIBBAD, &quot;ELIBBAD&quot;);
#endif
#ifdef ELIBSCN
    set_syserr(ELIBSCN, &quot;ELIBSCN&quot;);
#endif
#ifdef ELIBMAX
    set_syserr(ELIBMAX, &quot;ELIBMAX&quot;);
#endif
#ifdef ELIBEXEC
    set_syserr(ELIBEXEC, &quot;ELIBEXEC&quot;);
#endif
#ifdef EILSEQ
    set_syserr(EILSEQ, &quot;EILSEQ&quot;);
#endif
#ifdef ERESTART
    set_syserr(ERESTART, &quot;ERESTART&quot;);
#endif
#ifdef ESTRPIPE
    set_syserr(ESTRPIPE, &quot;ESTRPIPE&quot;);
#endif
#ifdef EUSERS
    set_syserr(EUSERS, &quot;EUSERS&quot;);
#endif
#ifdef ENOTSOCK
    set_syserr(ENOTSOCK, &quot;ENOTSOCK&quot;);
#endif
#ifdef EDESTADDRREQ
    set_syserr(EDESTADDRREQ, &quot;EDESTADDRREQ&quot;);
#endif
#ifdef EMSGSIZE
    set_syserr(EMSGSIZE, &quot;EMSGSIZE&quot;);
#endif
#ifdef EPROTOTYPE
    set_syserr(EPROTOTYPE, &quot;EPROTOTYPE&quot;);
#endif
#ifdef ENOPROTOOPT
    set_syserr(ENOPROTOOPT, &quot;ENOPROTOOPT&quot;);
#endif
#ifdef EPROTONOSUPPORT
    set_syserr(EPROTONOSUPPORT, &quot;EPROTONOSUPPORT&quot;);
#endif
#ifdef ESOCKTNOSUPPORT
    set_syserr(ESOCKTNOSUPPORT, &quot;ESOCKTNOSUPPORT&quot;);
#endif
#ifdef EOPNOTSUPP
    set_syserr(EOPNOTSUPP, &quot;EOPNOTSUPP&quot;);
#endif
#ifdef EPFNOSUPPORT
    set_syserr(EPFNOSUPPORT, &quot;EPFNOSUPPORT&quot;);
#endif
#ifdef EAFNOSUPPORT
    set_syserr(EAFNOSUPPORT, &quot;EAFNOSUPPORT&quot;);
#endif
#ifdef EADDRINUSE
    set_syserr(EADDRINUSE, &quot;EADDRINUSE&quot;);
#endif
#ifdef EADDRNOTAVAIL
    set_syserr(EADDRNOTAVAIL, &quot;EADDRNOTAVAIL&quot;);
#endif
#ifdef ENETDOWN
    set_syserr(ENETDOWN, &quot;ENETDOWN&quot;);
#endif
#ifdef ENETUNREACH
    set_syserr(ENETUNREACH, &quot;ENETUNREACH&quot;);
#endif
#ifdef ENETRESET
    set_syserr(ENETRESET, &quot;ENETRESET&quot;);
#endif
#ifdef ECONNABORTED
    set_syserr(ECONNABORTED, &quot;ECONNABORTED&quot;);
#endif
#ifdef ECONNRESET
    set_syserr(ECONNRESET, &quot;ECONNRESET&quot;);
#endif
#ifdef ENOBUFS
    set_syserr(ENOBUFS, &quot;ENOBUFS&quot;);
#endif
#ifdef EISCONN
    set_syserr(EISCONN, &quot;EISCONN&quot;);
#endif
#ifdef ENOTCONN
    set_syserr(ENOTCONN, &quot;ENOTCONN&quot;);
#endif
#ifdef ESHUTDOWN
    set_syserr(ESHUTDOWN, &quot;ESHUTDOWN&quot;);
#endif
#ifdef ETOOMANYREFS
    set_syserr(ETOOMANYREFS, &quot;ETOOMANYREFS&quot;);
#endif
#ifdef ETIMEDOUT
    set_syserr(ETIMEDOUT, &quot;ETIMEDOUT&quot;);
#endif
#ifdef ECONNREFUSED
    set_syserr(ECONNREFUSED, &quot;ECONNREFUSED&quot;);
#endif
#ifdef EHOSTDOWN
    set_syserr(EHOSTDOWN, &quot;EHOSTDOWN&quot;);
#endif
#ifdef EHOSTUNREACH
    set_syserr(EHOSTUNREACH, &quot;EHOSTUNREACH&quot;);
#endif
#ifdef EALREADY
    set_syserr(EALREADY, &quot;EALREADY&quot;);
#endif
#ifdef EINPROGRESS
    set_syserr(EINPROGRESS, &quot;EINPROGRESS&quot;);
#endif
#ifdef ESTALE
    set_syserr(ESTALE, &quot;ESTALE&quot;);
#endif
#ifdef EUCLEAN
    set_syserr(EUCLEAN, &quot;EUCLEAN&quot;);
#endif
#ifdef ENOTNAM
    set_syserr(ENOTNAM, &quot;ENOTNAM&quot;);
#endif
#ifdef ENAVAIL
    set_syserr(ENAVAIL, &quot;ENAVAIL&quot;);
#endif
#ifdef EISNAM
    set_syserr(EISNAM, &quot;EISNAM&quot;);
#endif
#ifdef EREMOTEIO
    set_syserr(EREMOTEIO, &quot;EREMOTEIO&quot;);
#endif
#ifdef EDQUOT
    set_syserr(EDQUOT, &quot;EDQUOT&quot;);
#endif
}

static void
err_append(s)
    const char *s;
{
    extern VALUE ruby_errinfo;

    if (ruby_in_eval) {
	if (NIL_P(ruby_errinfo)) {
	    ruby_errinfo = rb_exc_new2(rb_eSyntaxError, s);
	}
	else {
	    VALUE str = rb_obj_as_string(ruby_errinfo);

	    rb_str_cat2(str, &quot;\n&quot;);
	    rb_str_cat2(str, s);
	    ruby_errinfo = rb_exc_new3(rb_eSyntaxError, str);
	}
    }
    else {
	rb_write_error(s);
	rb_write_error(&quot;\n&quot;);
    }
}
</pre>
    </div>