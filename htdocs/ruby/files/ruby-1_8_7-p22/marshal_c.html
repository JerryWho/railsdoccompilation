  <div id="fileHeader">
    <h1>marshal.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/marshal.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 05:39:57 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  marshal.c -

  $Author: knu $
  $Date: 2008-06-06 19:39:57 +0900 (Fri, 06 Jun 2008) $
  created at: Thu Apr 27 16:30:01 JST 1995

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;rubyio.h&quot;
#include &quot;st.h&quot;
#include &quot;util.h&quot;

#include &lt;math.h&gt;
#ifdef HAVE_FLOAT_H
#include &lt;float.h&gt;
#endif
#ifdef HAVE_IEEEFP_H
#include &lt;ieeefp.h&gt;
#endif

#define BITSPERSHORT (2*CHAR_BIT)
#define SHORTMASK ((1&lt;&lt;BITSPERSHORT)-1)
#define SHORTDN(x) RSHIFT(x,BITSPERSHORT)

#if SIZEOF_SHORT == SIZEOF_BDIGITS
#define SHORTLEN(x) (x)
#else
static int
shortlen(len, ds)
    long len;
    BDIGIT *ds;
{
    BDIGIT num;
    int offset = 0;

    num = ds[len-1];
    while (num) {
	num = SHORTDN(num);
	offset++;
    }
    return (len - 1)*sizeof(BDIGIT)/2 + offset;
}
#define SHORTLEN(x) shortlen((x),d)
#endif

#define MARSHAL_MAJOR   4
#define MARSHAL_MINOR   8

#define TYPE_NIL	'0'
#define TYPE_TRUE	'T'
#define TYPE_FALSE	'F'
#define TYPE_FIXNUM	'i'

#define TYPE_EXTENDED	'e'
#define TYPE_UCLASS	'C'
#define TYPE_OBJECT	'o'
#define TYPE_DATA       'd'
#define TYPE_USERDEF	'u'
#define TYPE_USRMARSHAL	'U'
#define TYPE_FLOAT	'f'
#define TYPE_BIGNUM	'l'
#define TYPE_STRING	'&quot;'
#define TYPE_REGEXP	'/'
#define TYPE_ARRAY	'['
#define TYPE_HASH	'{'
#define TYPE_HASH_DEF	'}'
#define TYPE_STRUCT	'S'
#define TYPE_MODULE_OLD	'M'
#define TYPE_CLASS	'c'
#define TYPE_MODULE	'm'

#define TYPE_SYMBOL	':'
#define TYPE_SYMLINK	';'

#define TYPE_IVAR	'I'
#define TYPE_LINK	'@'

static ID s_dump, s_load, s_mdump, s_mload;
static ID s_dump_data, s_load_data, s_alloc, s_call;
static ID s_getc, s_read, s_write, s_binmode;

static void
reentrant_check(obj, sym)
    VALUE obj;
    ID sym;
{
    if (obj &amp;&amp; RBASIC(obj)-&gt;klass) {
        rb_raise(rb_eRuntimeError, &quot;%s reentered&quot;, rb_id2name(sym));
    }
}

struct dump_arg {
    VALUE obj;
    VALUE str, dest;
    st_table *symbols;
    st_table *data;
    int taint;
};

struct dump_call_arg {
    VALUE obj;
    struct dump_arg *arg;
    int limit;
};

static VALUE
class2path(klass)
    VALUE klass;
{
    VALUE path = rb_class_path(klass);
    char *n = RSTRING(path)-&gt;ptr;

    if (n[0] == '#') {
	rb_raise(rb_eTypeError, &quot;can't dump anonymous %s %s&quot;,
		 (TYPE(klass) == T_CLASS ? &quot;class&quot; : &quot;module&quot;),
		 n);
    }
    if (rb_path2class(n) != rb_class_real(klass)) {
	rb_raise(rb_eTypeError, &quot;%s can't be referred&quot;, n);
    }
    return path;
}

static void w_long _((long, struct dump_arg*));

static void
w_nbyte(s, n, arg)
    const char *s;
    int n;
    struct dump_arg *arg;
{
    VALUE buf = arg-&gt;str;
    rb_str_buf_cat(buf, s, n);
    if (arg-&gt;dest &amp;&amp; RSTRING(buf)-&gt;len &gt;= BUFSIZ) {
	if (arg-&gt;taint) OBJ_TAINT(buf);
	rb_io_write(arg-&gt;dest, buf);
	rb_str_resize(buf, 0);
    }
}

static void
w_byte(c, arg)
    char c;
    struct dump_arg *arg;
{
    w_nbyte(&amp;c, 1, arg);
}

static void
w_bytes(s, n, arg)
    const char *s;
    int n;
    struct dump_arg *arg;
{
    w_long(n, arg);
    w_nbyte(s, n, arg);
}

static void
w_short(x, arg)
    int x;
    struct dump_arg *arg;
{
    w_byte((x &gt;&gt; 0) &amp; 0xff, arg);
    w_byte((x &gt;&gt; 8) &amp; 0xff, arg);
}

static void
w_long(x, arg)
    long x;
    struct dump_arg *arg;
{
    char buf[sizeof(long)+1];
    int i, len = 0;

#if SIZEOF_LONG &gt; 4
    if (!(RSHIFT(x, 31) == 0 || RSHIFT(x, 31) == -1)) {
	/* big long does not fit in 4 bytes */
	rb_raise(rb_eTypeError, &quot;long too big to dump&quot;);
    }
#endif

    if (x == 0) {
	w_byte(0, arg);
	return;
    }
    if (0 &lt; x &amp;&amp; x &lt; 123) {
	w_byte(x + 5, arg);
	return;
    }
    if (-124 &lt; x &amp;&amp; x &lt; 0) {
	w_byte((x - 5)&amp;0xff, arg);
	return;
    }
    for (i=1;i&lt;sizeof(long)+1;i++) {
	buf[i] = x &amp; 0xff;
	x = RSHIFT(x,8);
	if (x == 0) {
	    buf[0] = i;
	    break;
	}
	if (x == -1) {
	    buf[0] = -i;
	    break;
	}
    }
    len = i;
    for (i=0;i&lt;=len;i++) {
	w_byte(buf[i], arg);
    }
}

#ifdef DBL_MANT_DIG
#define DECIMAL_MANT (53-16)	/* from IEEE754 double precision */

#if DBL_MANT_DIG &gt; 32
#define MANT_BITS 32
#elif DBL_MANT_DIG &gt; 24
#define MANT_BITS 24
#elif DBL_MANT_DIG &gt; 16
#define MANT_BITS 16
#else
#define MANT_BITS 8
#endif

static int
save_mantissa(d, buf)
    double d;
    char *buf;
{
    int e, i = 0;
    unsigned long m;
    double n;

    d = modf(ldexp(frexp(fabs(d), &amp;e), DECIMAL_MANT), &amp;d);
    if (d &gt; 0) {
	buf[i++] = 0;
	do {
	    d = modf(ldexp(d, MANT_BITS), &amp;n);
	    m = (unsigned long)n;
#if MANT_BITS &gt; 24
	    buf[i++] = m &gt;&gt; 24;
#endif
#if MANT_BITS &gt; 16
	    buf[i++] = m &gt;&gt; 16;
#endif
#if MANT_BITS &gt; 8
	    buf[i++] = m &gt;&gt; 8;
#endif
	    buf[i++] = m;
	} while (d &gt; 0);
	while (!buf[i - 1]) --i;
    }
    return i;
}

static double
load_mantissa(d, buf, len)
    double d;
    const char *buf;
    int len;
{
    if (--len &gt; 0 &amp;&amp; !*buf++) {	/* binary mantissa mark */
	int e, s = d &lt; 0, dig = 0;
	unsigned long m;

	modf(ldexp(frexp(fabs(d), &amp;e), DECIMAL_MANT), &amp;d);
	do {
	    m = 0;
	    switch (len) {
	      default: m = *buf++ &amp; 0xff;
#if MANT_BITS &gt; 24
	      case 3: m = (m &lt;&lt; 8) | (*buf++ &amp; 0xff);
#endif
#if MANT_BITS &gt; 16
	      case 2: m = (m &lt;&lt; 8) | (*buf++ &amp; 0xff);
#endif
#if MANT_BITS &gt; 8
	      case 1: m = (m &lt;&lt; 8) | (*buf++ &amp; 0xff);
#endif
	    }
	    dig -= len &lt; MANT_BITS / 8 ? 8 * (unsigned)len : MANT_BITS;
	    d += ldexp((double)m, dig);
	} while ((len -= MANT_BITS / 8) &gt; 0);
	d = ldexp(d, e - DECIMAL_MANT);
	if (s) d = -d;
    }
    return d;
}
#else
#define load_mantissa(d, buf, len) (d)
#define save_mantissa(d, buf) 0
#endif

#ifdef DBL_DIG
#define FLOAT_DIG (DBL_DIG+2)
#else
#define FLOAT_DIG 17
#endif

static void
w_float(d, arg)
    double d;
    struct dump_arg *arg;
{
    char buf[100];

    if (isinf(d)) {
	if (d &lt; 0) strcpy(buf, &quot;-inf&quot;);
	else       strcpy(buf, &quot;inf&quot;);
    }
    else if (isnan(d)) {
	strcpy(buf, &quot;nan&quot;);
    }
    else if (d == 0.0) {
	if (1.0/d &lt; 0) strcpy(buf, &quot;-0&quot;);
	else           strcpy(buf, &quot;0&quot;);
    }
    else {
	int len;

	/* xxx: should not use system's sprintf(3) */
	sprintf(buf, &quot;%.*g&quot;, FLOAT_DIG, d);
	len = strlen(buf);
	w_bytes(buf, len + save_mantissa(d, buf + len), arg);
	return;
    }
    w_bytes(buf, strlen(buf), arg);
}

static void
w_symbol(id, arg)
    ID id;
    struct dump_arg *arg;
{
    const char *sym = rb_id2name(id);
    st_data_t num;

    if (st_lookup(arg-&gt;symbols, id, &amp;num)) {
	w_byte(TYPE_SYMLINK, arg);
	w_long((long)num, arg);
    }
    else {
	w_byte(TYPE_SYMBOL, arg);
	w_bytes(sym, strlen(sym), arg);
	st_add_direct(arg-&gt;symbols, id, arg-&gt;symbols-&gt;num_entries);
    }
}

static void
w_unique(s, arg)
    const char *s;
    struct dump_arg *arg;
{
    if (s[0] == '#') {
	rb_raise(rb_eTypeError, &quot;can't dump anonymous class %s&quot;, s);
    }
    w_symbol(rb_intern(s), arg);
}

static void w_object _((VALUE,struct dump_arg*,int));

static int
hash_each(key, value, arg)
    VALUE key, value;
    struct dump_call_arg *arg;
{
    w_object(key, arg-&gt;arg, arg-&gt;limit);
    w_object(value, arg-&gt;arg, arg-&gt;limit);
    return ST_CONTINUE;
}

static void
w_extended(klass, arg, check)
    VALUE klass;
    struct dump_arg *arg;
    int check;
{
    const char *path;

    if (check &amp;&amp; FL_TEST(klass, FL_SINGLETON)) {
	if (RCLASS(klass)-&gt;m_tbl-&gt;num_entries ||
	    (RCLASS(klass)-&gt;iv_tbl &amp;&amp; RCLASS(klass)-&gt;iv_tbl-&gt;num_entries &gt; 1)) {
	    rb_raise(rb_eTypeError, &quot;singleton can't be dumped&quot;);
	}
	klass = RCLASS(klass)-&gt;super;
    }
    while (BUILTIN_TYPE(klass) == T_ICLASS) {
	path = rb_class2name(RBASIC(klass)-&gt;klass);
	w_byte(TYPE_EXTENDED, arg);
	w_unique(path, arg);
	klass = RCLASS(klass)-&gt;super;
    }
}

static void
w_class(type, obj, arg, check)
    int type;
    VALUE obj;
    struct dump_arg *arg;
    int check;
{
    char *path;

    VALUE klass = CLASS_OF(obj);
    w_extended(klass, arg, check);
    w_byte(type, arg);
    path = RSTRING(class2path(rb_class_real(klass)))-&gt;ptr;
    w_unique(path, arg);
}

static void
w_uclass(obj, base_klass, arg)
    VALUE obj, base_klass;
    struct dump_arg *arg;
{
    VALUE klass = CLASS_OF(obj);

    w_extended(klass, arg, Qtrue);
    klass = rb_class_real(klass);
    if (klass != base_klass) {
	w_byte(TYPE_UCLASS, arg);
	w_unique(RSTRING(class2path(klass))-&gt;ptr, arg);
    }
}

static int
w_obj_each(id, value, arg)
    ID id;
    VALUE value;
    struct dump_call_arg *arg;
{
    w_symbol(id, arg-&gt;arg);
    w_object(value, arg-&gt;arg, arg-&gt;limit);
    return ST_CONTINUE;
}

static void
w_ivar(tbl, arg)
    st_table *tbl;
    struct dump_call_arg *arg;
{
    if (tbl) {
	w_long(tbl-&gt;num_entries, arg-&gt;arg);
	st_foreach_safe(tbl, w_obj_each, (st_data_t)arg);
    }
    else {
	w_long(0, arg-&gt;arg);
    }
}

static void
w_object(obj, arg, limit)
    VALUE obj;
    struct dump_arg *arg;
    int limit;
{
    struct dump_call_arg c_arg;
    st_table *ivtbl = 0;
    st_data_t num;

    if (limit == 0) {
	rb_raise(rb_eArgError, &quot;exceed depth limit&quot;);
    }

    limit--;
    c_arg.limit = limit;
    c_arg.arg = arg;

    if (st_lookup(arg-&gt;data, obj, &amp;num)) {
	w_byte(TYPE_LINK, arg);
	w_long((long)num, arg);
	return;
    }

    if ((ivtbl = rb_generic_ivar_table(obj)) != 0) {
	w_byte(TYPE_IVAR, arg);
    }
    if (obj == Qnil) {
	w_byte(TYPE_NIL, arg);
    }
    else if (obj == Qtrue) {
	w_byte(TYPE_TRUE, arg);
    }
    else if (obj == Qfalse) {
	w_byte(TYPE_FALSE, arg);
    }
    else if (FIXNUM_P(obj)) {
#if SIZEOF_LONG &lt;= 4
	w_byte(TYPE_FIXNUM, arg);
	w_long(FIX2INT(obj), arg);
#else
	if (RSHIFT((long)obj, 31) == 0 || RSHIFT((long)obj, 31) == -1) {
	    w_byte(TYPE_FIXNUM, arg);
	    w_long(FIX2LONG(obj), arg);
	}
	else {
	    w_object(rb_int2big(FIX2LONG(obj)), arg, limit);
	}
#endif
    }
    else if (SYMBOL_P(obj)) {
	w_symbol(SYM2ID(obj), arg);
    }
    else {
	if (OBJ_TAINTED(obj)) arg-&gt;taint = Qtrue;

	st_add_direct(arg-&gt;data, obj, arg-&gt;data-&gt;num_entries);
	if (rb_obj_respond_to(obj, s_mdump, Qtrue)) {
	    volatile VALUE v;

	    v = rb_funcall(obj, s_mdump, 0, 0);
	    reentrant_check(arg-&gt;str, s_mdump);
	    w_class(TYPE_USRMARSHAL, obj, arg, Qfalse);
	    w_object(v, arg, limit);
	    if (ivtbl) w_ivar(0, &amp;c_arg);
	    return;
	}
	if (rb_obj_respond_to(obj, s_dump, Qtrue)) {
	    VALUE v;

	    v = rb_funcall(obj, s_dump, 1, INT2NUM(limit));
	    reentrant_check(arg-&gt;str, s_dump);
	    if (TYPE(v) != T_STRING) {
		rb_raise(rb_eTypeError, &quot;_dump() must return string&quot;);
	    }
	    if (!ivtbl &amp;&amp; (ivtbl = rb_generic_ivar_table(v))) {
		w_byte(TYPE_IVAR, arg);
	    }
	    w_class(TYPE_USERDEF, obj, arg, Qfalse);
	    w_bytes(RSTRING(v)-&gt;ptr, RSTRING(v)-&gt;len, arg);
	    if (ivtbl) {
		w_ivar(ivtbl, &amp;c_arg);
	    }
	    return;
	}

	switch (BUILTIN_TYPE(obj)) {
	  case T_CLASS:
	    if (FL_TEST(obj, FL_SINGLETON)) {
		rb_raise(rb_eTypeError, &quot;singleton class can't be dumped&quot;);
	    }
	    w_byte(TYPE_CLASS, arg);
	    {
		VALUE path = class2path(obj);
		w_bytes(RSTRING(path)-&gt;ptr, RSTRING(path)-&gt;len, arg);
	    }
	    break;

	  case T_MODULE:
	    w_byte(TYPE_MODULE, arg);
	    {
		VALUE path = class2path(obj);
		w_bytes(RSTRING(path)-&gt;ptr, RSTRING(path)-&gt;len, arg);
	    }
	    break;

	  case T_FLOAT:
	    w_byte(TYPE_FLOAT, arg);
	    w_float(RFLOAT(obj)-&gt;value, arg);
	    break;

	  case T_BIGNUM:
	    w_byte(TYPE_BIGNUM, arg);
	    {
		char sign = RBIGNUM(obj)-&gt;sign ? '+' : '-';
		long len = RBIGNUM(obj)-&gt;len;
		BDIGIT *d = RBIGNUM(obj)-&gt;digits;

		w_byte(sign, arg);
		w_long(SHORTLEN(len), arg); /* w_short? */
		while (len--) {
#if SIZEOF_BDIGITS &gt; SIZEOF_SHORT
		    BDIGIT num = *d;
		    int i;

		    for (i=0; i&lt;SIZEOF_BDIGITS; i+=SIZEOF_SHORT) {
			w_short(num &amp; SHORTMASK, arg);
			num = SHORTDN(num);
			if (len == 0 &amp;&amp; num == 0) break;
		    }
#else
		    w_short(*d, arg);
#endif
		    d++;
		}
	    }
	    break;

	  case T_STRING:
	    w_uclass(obj, rb_cString, arg);
	    w_byte(TYPE_STRING, arg);
	    w_bytes(RSTRING(obj)-&gt;ptr, RSTRING(obj)-&gt;len, arg);
	    break;

	  case T_REGEXP:
	    w_uclass(obj, rb_cRegexp, arg);
	    w_byte(TYPE_REGEXP, arg);
	    w_bytes(RREGEXP(obj)-&gt;str, RREGEXP(obj)-&gt;len, arg);
	    w_byte(rb_reg_options(obj), arg);
	    break;

	  case T_ARRAY:
	    w_uclass(obj, rb_cArray, arg);
	    w_byte(TYPE_ARRAY, arg);
	    {
		long len = RARRAY(obj)-&gt;len;
		VALUE *ptr = RARRAY(obj)-&gt;ptr;

		w_long(len, arg);
		while (len--) {
		    w_object(*ptr, arg, limit);
		    ptr++;
		}
	    }
	    break;

	  case T_HASH:
	    w_uclass(obj, rb_cHash, arg);
	    if (NIL_P(RHASH(obj)-&gt;ifnone)) {
		w_byte(TYPE_HASH, arg);
	    }
	    else if (FL_TEST(obj, FL_USER2)) {
		/* FL_USER2 means HASH_PROC_DEFAULT (see hash.c) */
		rb_raise(rb_eTypeError, &quot;can't dump hash with default proc&quot;);
	    }
	    else {
		w_byte(TYPE_HASH_DEF, arg);
	    }
	    w_long(RHASH(obj)-&gt;tbl-&gt;num_entries, arg);
	    rb_hash_foreach(obj, hash_each, (st_data_t)&amp;c_arg);
	    if (!NIL_P(RHASH(obj)-&gt;ifnone)) {
		w_object(RHASH(obj)-&gt;ifnone, arg, limit);
	    }
	    break;

	  case T_STRUCT:
	    w_class(TYPE_STRUCT, obj, arg, Qtrue);
	    {
		long len = RSTRUCT(obj)-&gt;len;
		VALUE mem;
		long i;

		w_long(len, arg);
		mem = rb_struct_members(obj);
		for (i=0; i&lt;len; i++) {
		    w_symbol(SYM2ID(RARRAY(mem)-&gt;ptr[i]), arg);
		    w_object(RSTRUCT(obj)-&gt;ptr[i], arg, limit);
		}
	    }
	    break;

	  case T_OBJECT:
	    w_class(TYPE_OBJECT, obj, arg, Qtrue);
	    w_ivar(ROBJECT(obj)-&gt;iv_tbl, &amp;c_arg);
	    break;

	  case T_DATA:
	    {
		VALUE v;

		if (!rb_obj_respond_to(obj, s_dump_data, Qtrue)) {
		    rb_raise(rb_eTypeError,
			     &quot;no marshal_dump is defined for class %s&quot;,
			     rb_obj_classname(obj));
		}
		v = rb_funcall(obj, s_dump_data, 0);
		reentrant_check(arg-&gt;str, s_dump_data);
		w_class(TYPE_DATA, obj, arg, Qtrue);
		w_object(v, arg, limit);
	    }
	    break;

	  default:
	    rb_raise(rb_eTypeError, &quot;can't dump %s&quot;,
		     rb_obj_classname(obj));
	    break;
	}
    }
    if (ivtbl) {
	w_ivar(ivtbl, &amp;c_arg);
    }
}

static VALUE
dump(arg)
    struct dump_call_arg *arg;
{
    w_object(arg-&gt;obj, arg-&gt;arg, arg-&gt;limit);
    if (arg-&gt;arg-&gt;dest) {
	rb_io_write(arg-&gt;arg-&gt;dest, arg-&gt;arg-&gt;str);
	rb_str_resize(arg-&gt;arg-&gt;str, 0);
    }
    return 0;
}

static VALUE
dump_ensure(arg)
    struct dump_arg *arg;
{
    if (RBASIC(arg-&gt;str)-&gt;klass) return 0; /* ignore reentrant */
    st_free_table(arg-&gt;symbols);
    st_free_table(arg-&gt;data);
    if (arg-&gt;taint) {
	OBJ_TAINT(arg-&gt;str);
    }

    return 0;
}

/*
 * call-seq:
 *      dump( obj [, anIO] , limit=--1 ) =&gt; anIO
 *
 * Serializes obj and all descendent objects. If anIO is
 * specified, the serialized data will be written to it, otherwise the
 * data will be returned as a String. If limit is specified, the
 * traversal of subobjects will be limited to that depth. If limit is
 * negative, no checking of depth will be performed.
 *
 *     class Klass
 *       def initialize(str)
 *         @str = str
 *       end
 *       def sayHello
 *         @str
 *       end
 *     end
 *
 * (produces no output)
 *
 *     o = Klass.new(&quot;hello\n&quot;)
 *     data = Marshal.dump(o)
 *     obj = Marshal.load(data)
 *     obj.sayHello   #=&gt; &quot;hello\n&quot;
 */
static VALUE
marshal_dump(argc, argv)
    int argc;
    VALUE* argv;
{
    VALUE obj, port, a1, a2;
    int limit = -1;
    struct dump_arg arg;
    struct dump_call_arg c_arg;

    port = Qnil;
    rb_scan_args(argc, argv, &quot;12&quot;, &amp;obj, &amp;a1, &amp;a2);
    if (argc == 3) {
	if (!NIL_P(a2)) limit = NUM2INT(a2);
	if (NIL_P(a1)) goto type_error;
	port = a1;
    }
    else if (argc == 2) {
	if (FIXNUM_P(a1)) limit = FIX2INT(a1);
	else if (NIL_P(a1)) goto type_error;
	else port = a1;
    }
    arg.dest = 0;
    arg.str = rb_str_buf_new(0);
    RBASIC(arg.str)-&gt;klass = 0;
    if (!NIL_P(port)) {
	if (!rb_obj_respond_to(port, s_write, Qtrue)) {
	  type_error:
	    rb_raise(rb_eTypeError, &quot;instance of IO needed&quot;);
	}
	arg.dest = port;
	if (rb_obj_respond_to(port, s_binmode, Qtrue)) {
	    rb_funcall2(port, s_binmode, 0, 0);
	    reentrant_check(arg.str, s_dump_data);
	}
    }
    else {
	port = arg.str;
    }

    arg.symbols = st_init_numtable();
    arg.data    = st_init_numtable();
    arg.taint   = Qfalse;
    c_arg.obj   = obj;
    c_arg.arg   = &amp;arg;
    c_arg.limit = limit;

    w_byte(MARSHAL_MAJOR, &amp;arg);
    w_byte(MARSHAL_MINOR, &amp;arg);

    rb_ensure(dump, (VALUE)&amp;c_arg, dump_ensure, (VALUE)&amp;arg);
    RBASIC(arg.str)-&gt;klass = rb_cString;

    return port;
}

struct load_arg {
    VALUE src;
    long offset;
    st_table *symbols;
    VALUE data;
    VALUE proc;
    int taint;
};

static VALUE r_object _((struct load_arg *arg));

static int
r_byte(arg)
    struct load_arg *arg;
{
    int c;

    if (TYPE(arg-&gt;src) == T_STRING) {
	if (RSTRING(arg-&gt;src)-&gt;len &gt; arg-&gt;offset) {
	    c = (unsigned char)RSTRING(arg-&gt;src)-&gt;ptr[arg-&gt;offset++];
	}
	else {
	    rb_raise(rb_eArgError, &quot;marshal data too short&quot;);
	}
    }
    else {
	VALUE src = arg-&gt;src;
	VALUE v = rb_funcall2(src, s_getc, 0, 0);
	reentrant_check(arg-&gt;data, s_getc);
	if (NIL_P(v)) rb_eof_error();
	c = (unsigned char)FIX2INT(v);
    }
    return c;
}

static void
long_toobig(size)
    int size;
{
    rb_raise(rb_eTypeError, &quot;long too big for this architecture (size %d, given %d)&quot;,
	     sizeof(long), size);
}

#undef SIGN_EXTEND_CHAR
#if __STDC__
# define SIGN_EXTEND_CHAR(c) ((signed char)(c))
#else  /* not __STDC__ */
/* As in Harbison and Steele.  */
# define SIGN_EXTEND_CHAR(c) ((((unsigned char)(c)) ^ 128) - 128)
#endif

static long
r_long(arg)
    struct load_arg *arg;
{
    register long x;
    int c = SIGN_EXTEND_CHAR(r_byte(arg));
    long i;

    if (c == 0) return 0;
    if (c &gt; 0) {
	if (4 &lt; c &amp;&amp; c &lt; 128) {
	    return c - 5;
	}
	if (c &gt; sizeof(long)) long_toobig(c);
	x = 0;
	for (i=0;i&lt;c;i++) {
	    x |= (long)r_byte(arg) &lt;&lt; (8*i);
	}
    }
    else {
	if (-129 &lt; c &amp;&amp; c &lt; -4) {
	    return c + 5;
	}
	c = -c;
	if (c &gt; sizeof(long)) long_toobig(c);
	x = -1;
	for (i=0;i&lt;c;i++) {
	    x &amp;= ~((long)0xff &lt;&lt; (8*i));
	    x |= (long)r_byte(arg) &lt;&lt; (8*i);
	}
    }
    return x;
}

#define r_bytes(arg) r_bytes0(r_long(arg), (arg))

static VALUE
r_bytes0(len, arg)
    long len;
    struct load_arg *arg;
{
    VALUE str;

    if (len == 0) return rb_str_new(0, 0);
    if (TYPE(arg-&gt;src) == T_STRING) {
	if (RSTRING(arg-&gt;src)-&gt;len - arg-&gt;offset &gt;= len) {
	    str = rb_str_new(RSTRING(arg-&gt;src)-&gt;ptr+arg-&gt;offset, len);
	    arg-&gt;offset += len;
	}
	else {
	  too_short:
	    rb_raise(rb_eArgError, &quot;marshal data too short&quot;);
	}
    }
    else {
	VALUE src = arg-&gt;src;
	VALUE n = LONG2NUM(len);
	str = rb_funcall2(src, s_read, 1, &amp;n);
	reentrant_check(arg-&gt;data, s_read);
	if (NIL_P(str)) goto too_short;
	StringValue(str);
	if (RSTRING(str)-&gt;len != len) goto too_short;
	if (OBJ_TAINTED(str)) arg-&gt;taint = Qtrue;
    }
    return str;
}

static ID
r_symlink(arg)
    struct load_arg *arg;
{
    ID id;
    long num = r_long(arg);

    if (st_lookup(arg-&gt;symbols, num, &amp;id)) {
	return id;
    }
    rb_raise(rb_eArgError, &quot;bad symbol&quot;);
}

static ID
r_symreal(arg)
    struct load_arg *arg;
{
    ID id;

    id = rb_intern(RSTRING(r_bytes(arg))-&gt;ptr);
    st_insert(arg-&gt;symbols, arg-&gt;symbols-&gt;num_entries, id);

    return id;
}

static ID
r_symbol(arg)
    struct load_arg *arg;
{
    if (r_byte(arg) == TYPE_SYMLINK) {
	return r_symlink(arg);
    }
    return r_symreal(arg);
}

static const char*
r_unique(arg)
    struct load_arg *arg;
{
    return rb_id2name(r_symbol(arg));
}

static VALUE
r_string(arg)
    struct load_arg *arg;
{
    return r_bytes(arg);
}

static VALUE
r_entry(v, arg)
    VALUE v;
    struct load_arg *arg;
{
    rb_hash_aset(arg-&gt;data, INT2FIX(RHASH(arg-&gt;data)-&gt;tbl-&gt;num_entries), v);
    if (arg-&gt;taint) OBJ_TAINT(v);
    return v;
}

static void
r_ivar(obj, arg)
    VALUE obj;
    struct load_arg *arg;
{
    long len;

    len = r_long(arg);
    if (len &gt; 0) {
	while (len--) {
	    ID id = r_symbol(arg);
	    VALUE val = r_object(arg);
	    rb_ivar_set(obj, id, val);
	}
    }
}

static VALUE
path2class(path)
    const char *path;
{
    VALUE v = rb_path2class(path);

    if (TYPE(v) != T_CLASS) {
	rb_raise(rb_eArgError, &quot;%s does not refer class&quot;, path);
    }
    return v;
}

static VALUE
path2module(path)
    const char *path;
{
    VALUE v = rb_path2class(path);

    if (TYPE(v) != T_MODULE) {
	rb_raise(rb_eArgError, &quot;%s does not refer module&quot;, path);
    }
    return v;
}

static VALUE
r_object0(arg, proc, ivp, extmod)
    struct load_arg *arg;
    VALUE proc;
    int *ivp;
    VALUE extmod;
{
    VALUE v = Qnil;
    int type = r_byte(arg);
    long id;

    switch (type) {
      case TYPE_LINK:
	id = r_long(arg);
	v = rb_hash_aref(arg-&gt;data, LONG2FIX(id));
	if (NIL_P(v)) {
	    rb_raise(rb_eArgError, &quot;dump format error (unlinked)&quot;);
	}
	return v;

      case TYPE_IVAR:
        {
	    int ivar = Qtrue;

	    v = r_object0(arg, 0, &amp;ivar, extmod);
	    if (ivar) r_ivar(v, arg);
	}
	break;

      case TYPE_EXTENDED:
	{
	    VALUE m = path2module(r_unique(arg));

            if (NIL_P(extmod)) extmod = rb_ary_new2(0);
            rb_ary_push(extmod, m);

	    v = r_object0(arg, 0, 0, extmod);
            while (RARRAY(extmod)-&gt;len &gt; 0) {
                m = rb_ary_pop(extmod);
                rb_extend_object(v, m);
            }
	}
	break;

      case TYPE_UCLASS:
	{
	    VALUE c = path2class(r_unique(arg));

	    if (FL_TEST(c, FL_SINGLETON)) {
		rb_raise(rb_eTypeError, &quot;singleton can't be loaded&quot;);
	    }
	    v = r_object0(arg, 0, 0, extmod);
	    if (rb_special_const_p(v) || TYPE(v) == T_OBJECT || TYPE(v) == T_CLASS) {
	      format_error:
		rb_raise(rb_eArgError, &quot;dump format error (user class)&quot;);
	    }
	    if (TYPE(v) == T_MODULE || !RTEST(rb_class_inherited_p(c, RBASIC(v)-&gt;klass))) {
		VALUE tmp = rb_obj_alloc(c);

		if (TYPE(v) != TYPE(tmp)) goto format_error;
	    }
	    RBASIC(v)-&gt;klass = c;
	}
	break;

      case TYPE_NIL:
	v = Qnil;
	break;

      case TYPE_TRUE:
	v = Qtrue;
	break;

      case TYPE_FALSE:
	v = Qfalse;
	break;

      case TYPE_FIXNUM:
	{
	    long i = r_long(arg);
	    v = LONG2FIX(i);
	}
	break;

      case TYPE_FLOAT:
	{
	    double d, t = 0.0;
	    VALUE str = r_bytes(arg);
	    const char *ptr = RSTRING(str)-&gt;ptr;

	    if (strcmp(ptr, &quot;nan&quot;) == 0) {
		d = t / t;
	    }
	    else if (strcmp(ptr, &quot;inf&quot;) == 0) {
		d = 1.0 / t;
	    }
	    else if (strcmp(ptr, &quot;-inf&quot;) == 0) {
		d = -1.0 / t;
	    }
	    else {
		char *e;
		d = strtod(ptr, &amp;e);
		d = load_mantissa(d, e, RSTRING(str)-&gt;len - (e - ptr));
	    }
	    v = rb_float_new(d);
	    r_entry(v, arg);
	}
	break;

      case TYPE_BIGNUM:
	{
	    long len;
	    BDIGIT *digits;
	    volatile VALUE data;

	    NEWOBJ(big, struct RBignum);
	    OBJSETUP(big, rb_cBignum, T_BIGNUM);
	    big-&gt;sign = (r_byte(arg) == '+');
	    len = r_long(arg);
	    data = r_bytes0(len * 2, arg);
#if SIZEOF_BDIGITS == SIZEOF_SHORT
	    big-&gt;len = len;
#else
	    big-&gt;len = (len + 1) * 2 / sizeof(BDIGIT);
#endif
	    big-&gt;digits = digits = ALLOC_N(BDIGIT, big-&gt;len);
	    MEMCPY(digits, RSTRING(data)-&gt;ptr, char, len * 2);
#if SIZEOF_BDIGITS &gt; SIZEOF_SHORT
	    MEMZERO((char *)digits + len * 2, char,
		    big-&gt;len * sizeof(BDIGIT) - len * 2);
#endif
	    len = big-&gt;len;
	    while (len &gt; 0) {
		unsigned char *p = (unsigned char *)digits;
		BDIGIT num = 0;
#if SIZEOF_BDIGITS &gt; SIZEOF_SHORT
		int shift = 0;
		int i;

		for (i=0; i&lt;SIZEOF_BDIGITS; i++) {
		    num |= (int)p[i] &lt;&lt; shift;
		    shift += 8;
		}
#else
		num = p[0] | (p[1] &lt;&lt; 8);
#endif
		*digits++ = num;
		len--;
	    }
	    v = rb_big_norm((VALUE)big);
	    r_entry(v, arg);
	}
	break;

      case TYPE_STRING:
	v = r_entry(r_string(arg), arg);
	break;

      case TYPE_REGEXP:
	{
	    volatile VALUE str = r_bytes(arg);
	    int options = r_byte(arg);
	    v = r_entry(rb_reg_new(RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len, options), arg);
	}
	break;

      case TYPE_ARRAY:
	{
	    volatile long len = r_long(arg); /* gcc 2.7.2.3 -O2 bug?? */

	    v = rb_ary_new2(len);
	    r_entry(v, arg);
	    while (len--) {
		rb_ary_push(v, r_object(arg));
	    }
	}
	break;

      case TYPE_HASH:
      case TYPE_HASH_DEF:
	{
	    long len = r_long(arg);

	    v = rb_hash_new();
	    r_entry(v, arg);
	    while (len--) {
		VALUE key = r_object(arg);
		VALUE value = r_object(arg);
		rb_hash_aset(v, key, value);
	    }
	    if (type == TYPE_HASH_DEF) {
		RHASH(v)-&gt;ifnone = r_object(arg);
	    }
	}
	break;

      case TYPE_STRUCT:
	{
	    VALUE klass, mem, values;
	    volatile long i;	/* gcc 2.7.2.3 -O2 bug?? */
	    long len;
	    ID slot;

	    klass = path2class(r_unique(arg));
	    mem = rb_struct_s_members(klass);
	    len = r_long(arg);

	    values = rb_ary_new2(len);
	    for (i=0; i&lt;len; i++) {
		rb_ary_push(values, Qnil);
	    }
	    v = rb_struct_alloc(klass, values);
	    r_entry(v, arg);
	    for (i=0; i&lt;len; i++) {
		slot = r_symbol(arg);

		if (RARRAY(mem)-&gt;ptr[i] != ID2SYM(slot)) {
		    rb_raise(rb_eTypeError, &quot;struct %s not compatible (:%s for :%s)&quot;,
			     rb_class2name(klass),
			     rb_id2name(slot),
			     rb_id2name(SYM2ID(RARRAY(mem)-&gt;ptr[i])));
		}
		rb_struct_aset(v, LONG2FIX(i), r_object(arg));
	    }
	}
	break;

      case TYPE_USERDEF:
        {
	    VALUE klass = path2class(r_unique(arg));
	    VALUE data;

	    if (!rb_obj_respond_to(klass, s_load, Qtrue)) {
		rb_raise(rb_eTypeError, &quot;class %s needs to have method `_load'&quot;,
			 rb_class2name(klass));
	    }
	    data = r_string(arg);
	    if (ivp) {
		r_ivar(data, arg);
		*ivp = Qfalse;
	    }
	    v = rb_funcall(klass, s_load, 1, data);
	    reentrant_check(arg-&gt;data, s_load);
	    r_entry(v, arg);
	}
        break;

      case TYPE_USRMARSHAL:
        {
	    VALUE klass = path2class(r_unique(arg));
	    VALUE data;

	    v = rb_obj_alloc(klass);
            if (! NIL_P(extmod)) {
                while (RARRAY(extmod)-&gt;len &gt; 0) {
                    VALUE m = rb_ary_pop(extmod);
                    rb_extend_object(v, m);
                }
            }
	    if (!rb_obj_respond_to(v, s_mload, Qtrue)) {
		rb_raise(rb_eTypeError, &quot;instance of %s needs to have method `marshal_load'&quot;,
			 rb_class2name(klass));
	    }
	    r_entry(v, arg);
	    data = r_object(arg);
	    rb_funcall(v, s_mload, 1, data);
	    reentrant_check(arg-&gt;data, s_mload);
	}
        break;

      case TYPE_OBJECT:
	{
	    VALUE klass = path2class(r_unique(arg));

	    v = rb_obj_alloc(klass);
	    if (TYPE(v) != T_OBJECT) {
		rb_raise(rb_eArgError, &quot;dump format error&quot;);
	    }
	    r_entry(v, arg);
	    r_ivar(v, arg);
	}
	break;

      case TYPE_DATA:
       {
           VALUE klass = path2class(r_unique(arg));
           if (rb_obj_respond_to(klass, s_alloc, Qtrue)) {
	       static int warn = Qtrue;
	       if (warn) {
		   rb_warn(&quot;define `allocate' instead of `_alloc'&quot;);
		   warn = Qfalse;
	       }
	       v = rb_funcall(klass, s_alloc, 0);
	       reentrant_check(arg-&gt;data, s_alloc);
           }
	   else {
	       v = rb_obj_alloc(klass);
	   }
           if (TYPE(v) != T_DATA) {
               rb_raise(rb_eArgError, &quot;dump format error&quot;);
           }
           r_entry(v, arg);
           if (!rb_obj_respond_to(v, s_load_data, Qtrue)) {
               rb_raise(rb_eTypeError,
                        &quot;class %s needs to have instance method `_load_data'&quot;,
                        rb_class2name(klass));
           }
           rb_funcall(v, s_load_data, 1, r_object0(arg, 0, 0, extmod));
	   reentrant_check(arg-&gt;data, s_load_data);
       }
       break;

      case TYPE_MODULE_OLD:
        {
	    volatile VALUE str = r_bytes(arg);

	    v = rb_path2class(RSTRING(str)-&gt;ptr);
	    r_entry(v, arg);
	}
	break;

      case TYPE_CLASS:
        {
	    volatile VALUE str = r_bytes(arg);

	    v = path2class(RSTRING(str)-&gt;ptr);
	    r_entry(v, arg);
	}
	break;

      case TYPE_MODULE:
        {
	    volatile VALUE str = r_bytes(arg);

	    v = path2module(RSTRING(str)-&gt;ptr);
	    r_entry(v, arg);
	}
	break;

      case TYPE_SYMBOL:
	v = ID2SYM(r_symreal(arg));
	break;

      case TYPE_SYMLINK:
	return ID2SYM(r_symlink(arg));

      default:
	rb_raise(rb_eArgError, &quot;dump format error(0x%x)&quot;, type);
	break;
    }
    if (proc) {
	rb_funcall(proc, s_call, 1, v);
	reentrant_check(arg-&gt;data, s_call);
    }
    return v;
}

static VALUE
r_object(arg)
    struct load_arg *arg;
{
    return r_object0(arg, arg-&gt;proc, 0, Qnil);
}

static VALUE
load(arg)
    struct load_arg *arg;
{
    return r_object(arg);
}

static VALUE
load_ensure(arg)
    struct load_arg *arg;
{
    if (RBASIC(arg-&gt;data)-&gt;klass) return 0; /* ignore reentrant */
    st_free_table(arg-&gt;symbols);
    return 0;
}

/*
 * call-seq:
 *     load( source [, proc] ) =&gt; obj
 *     restore( source [, proc] ) =&gt; obj
 * 
 * Returns the result of converting the serialized data in source into a
 * Ruby object (possibly with associated subordinate objects). source
 * may be either an instance of IO or an object that responds to
 * to_str. If proc is specified, it will be passed each object as it
 * is deserialized.
 */
static VALUE
marshal_load(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE port, proc;
    int major, minor;
    VALUE v;
    struct load_arg arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;port, &amp;proc);
    v = rb_check_string_type(port);
    if (!NIL_P(v)) {
	arg.taint = OBJ_TAINTED(port); /* original taintedness */
	port = v;
    }
    else if (rb_obj_respond_to(port, s_getc, Qtrue) &amp;&amp; rb_obj_respond_to(port, s_read, Qtrue)) {
	if (rb_obj_respond_to(port, s_binmode, Qtrue)) {
	    rb_funcall2(port, s_binmode, 0, 0);
	}
	arg.taint = Qtrue;
    }
    else {
	rb_raise(rb_eTypeError, &quot;instance of IO needed&quot;);
    }
    arg.src = port;
    arg.offset = 0;
    arg.data = 0;

    major = r_byte(&amp;arg);
    minor = r_byte(&amp;arg);
    if (major != MARSHAL_MAJOR || minor &gt; MARSHAL_MINOR) {
	rb_raise(rb_eTypeError, &quot;incompatible marshal file format (can't be read)\n\
\tformat version %d.%d required; %d.%d given&quot;,
		 MARSHAL_MAJOR, MARSHAL_MINOR, major, minor);
    }
    if (RTEST(ruby_verbose) &amp;&amp; minor != MARSHAL_MINOR) {
	rb_warn(&quot;incompatible marshal file format (can be read)\n\
\tformat version %d.%d required; %d.%d given&quot;,
		MARSHAL_MAJOR, MARSHAL_MINOR, major, minor);
    }

    arg.symbols = st_init_numtable();
    arg.data   = rb_hash_new();
    RBASIC(arg.data)-&gt;klass = 0;
    if (NIL_P(proc)) arg.proc = 0;
    else             arg.proc = proc;
    v = rb_ensure(load, (VALUE)&amp;arg, load_ensure, (VALUE)&amp;arg);
    RBASIC(arg.data)-&gt;klass = rb_cHash;

    return v;
}

/*
 * The marshaling library converts collections of Ruby objects into a
 * byte stream, allowing them to be stored outside the currently
 * active script. This data may subsequently be read and the original
 * objects reconstituted.
 * Marshaled data has major and minor version numbers stored along
 * with the object information. In normal use, marshaling can only
 * load data written with the same major version number and an equal
 * or lower minor version number. If Ruby's ``verbose'' flag is set
 * (normally using -d, -v, -w, or --verbose) the major and minor
 * numbers must match exactly. Marshal versioning is independent of
 * Ruby's version numbers. You can extract the version by reading the
 * first two bytes of marshaled data.
 *
 *     str = Marshal.dump(&quot;thing&quot;)
 *     RUBY_VERSION   #=&gt; &quot;1.8.0&quot;
 *     str[0]         #=&gt; 4
 *     str[1]         #=&gt; 8
 *
 * Some objects cannot be dumped: if the objects to be dumped include
 * bindings, procedure or method objects, instances of class IO, or
 * singleton objects, a TypeError will be raised.
 * If your class has special serialization needs (for example, if you
 * want to serialize in some specific format), or if it contains
 * objects that would otherwise not be serializable, you can implement
 * your own serialization strategy by defining two methods, _dump and
 * _load:
 * The instance method _dump should return a String object containing
 * all the information necessary to reconstitute objects of this class
 * and all referenced objects up to a maximum depth given as an integer
 * parameter (a value of -1 implies that you should disable depth checking).
 * The class method _load should take a String and return an object of this class.
 */
void
Init_marshal()
{
    VALUE rb_mMarshal = rb_define_module(&quot;Marshal&quot;);

    s_dump = rb_intern(&quot;_dump&quot;);
    s_load = rb_intern(&quot;_load&quot;);
    s_mdump = rb_intern(&quot;marshal_dump&quot;);
    s_mload = rb_intern(&quot;marshal_load&quot;);
    s_dump_data = rb_intern(&quot;_dump_data&quot;);
    s_load_data = rb_intern(&quot;_load_data&quot;);
    s_alloc = rb_intern(&quot;_alloc&quot;);
    s_call = rb_intern(&quot;call&quot;);
    s_getc = rb_intern(&quot;getc&quot;);
    s_read = rb_intern(&quot;read&quot;);
    s_write = rb_intern(&quot;write&quot;);
    s_binmode = rb_intern(&quot;binmode&quot;);

    rb_define_module_function(rb_mMarshal, &quot;dump&quot;, marshal_dump, -1);
    rb_define_module_function(rb_mMarshal, &quot;load&quot;, marshal_load, -1);
    rb_define_module_function(rb_mMarshal, &quot;restore&quot;, marshal_load, -1);

    rb_define_const(rb_mMarshal, &quot;MAJOR_VERSION&quot;, INT2FIX(MARSHAL_MAJOR));
    rb_define_const(rb_mMarshal, &quot;MINOR_VERSION&quot;, INT2FIX(MARSHAL_MINOR));
}

VALUE
rb_marshal_dump(obj, port)
    VALUE obj, port;
{
    int argc = 1;
    VALUE argv[2];

    argv[0] = obj;
    argv[1] = port;
    if (!NIL_P(port)) argc = 2;
    return marshal_dump(argc, argv);
}

VALUE
rb_marshal_load(port)
    VALUE port;
{
    return marshal_load(1, &amp;port);
}
</pre>
    </div>