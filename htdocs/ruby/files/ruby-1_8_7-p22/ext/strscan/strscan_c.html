  <div id="fileHeader">
    <h1>strscan.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/ext/strscan/strscan.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/*
    $Id: strscan.c 11708 2007-02-12 23:01:19Z shyouhei $

    Copyright (c) 1999-2006 Minero Aoki

    This program is free software.
    You can distribute/modify this program under the terms of
    the Ruby License. For details, see the file COPYING.
*/

#include &quot;ruby.h&quot;
#include &quot;re.h&quot;

#define STRSCAN_VERSION &quot;0.7.0&quot;

/* =======================================================================
                         Data Type Definitions
   ======================================================================= */

static VALUE StringScanner;
static VALUE ScanError;

struct strscanner
{
    /* multi-purpose flags */
    unsigned long flags;
#define FLAG_MATCHED (1 &lt;&lt; 0)

    /* the string to scan */
    VALUE str;
    
    /* scan pointers */
    long prev;   /* legal only when MATCHED_P(s) */
    long curr;   /* always legal */

    /* the regexp register; legal only when MATCHED_P(s) */
    struct re_registers regs;
};

#define MATCHED_P(s)          ((s)-&gt;flags &amp; FLAG_MATCHED)
#define MATCHED(s)             (s)-&gt;flags |= FLAG_MATCHED
#define CLEAR_MATCH_STATUS(s)  (s)-&gt;flags &amp;= ~FLAG_MATCHED

#define S_PBEG(s)  (RSTRING((s)-&gt;str)-&gt;ptr)
#define S_LEN(s)  (RSTRING((s)-&gt;str)-&gt;len)
#define S_PEND(s)  (S_PBEG(s) + S_LEN(s))
#define CURPTR(s) (S_PBEG(s) + (s)-&gt;curr)
#define S_RESTLEN(s) (S_LEN(s) - (s)-&gt;curr)

#define EOS_P(s) ((s)-&gt;curr &gt;= RSTRING(p-&gt;str)-&gt;len)

#define GET_SCANNER(obj,var) do {\
    Data_Get_Struct(obj, struct strscanner, var);\
    if (NIL_P(var-&gt;str)) rb_raise(rb_eArgError, &quot;uninitialized StringScanner object&quot;);\
} while (0)

/* =======================================================================
                            Function Prototypes
   ======================================================================= */

static VALUE infect _((VALUE str, struct strscanner *p));
static VALUE extract_range _((struct strscanner *p, long beg_i, long end_i));
static VALUE extract_beg_len _((struct strscanner *p, long beg_i, long len));

static void check_strscan _((VALUE obj));
static void strscan_mark _((struct strscanner *p));
static void strscan_free _((struct strscanner *p));
static VALUE strscan_s_allocate _((VALUE klass));
static VALUE strscan_initialize _((int argc, VALUE *argv, VALUE self));
static VALUE strscan_init_copy _((VALUE vself, VALUE vorig));

static VALUE strscan_s_mustc _((VALUE self));
static VALUE strscan_terminate _((VALUE self));
static VALUE strscan_clear _((VALUE self));
static VALUE strscan_get_string _((VALUE self));
static VALUE strscan_set_string _((VALUE self, VALUE str));
static VALUE strscan_concat _((VALUE self, VALUE str));
static VALUE strscan_get_pos _((VALUE self));
static VALUE strscan_set_pos _((VALUE self, VALUE pos));
static VALUE strscan_do_scan _((VALUE self, VALUE regex,
                                int succptr, int getstr, int headonly));
static VALUE strscan_scan _((VALUE self, VALUE re));
static VALUE strscan_match_p _((VALUE self, VALUE re));
static VALUE strscan_skip _((VALUE self, VALUE re));
static VALUE strscan_check _((VALUE self, VALUE re));
static VALUE strscan_scan_full _((VALUE self, VALUE re,
                                  VALUE succp, VALUE getp));
static VALUE strscan_scan_until _((VALUE self, VALUE re));
static VALUE strscan_skip_until _((VALUE self, VALUE re));
static VALUE strscan_check_until _((VALUE self, VALUE re));
static VALUE strscan_search_full _((VALUE self, VALUE re,
                                    VALUE succp, VALUE getp));
static void adjust_registers_to_matched _((struct strscanner *p));
static VALUE strscan_getch _((VALUE self));
static VALUE strscan_get_byte _((VALUE self));
static VALUE strscan_getbyte _((VALUE self));
static VALUE strscan_peek _((VALUE self, VALUE len));
static VALUE strscan_peep _((VALUE self, VALUE len));
static VALUE strscan_unscan _((VALUE self));
static VALUE strscan_bol_p _((VALUE self));
static VALUE strscan_eos_p _((VALUE self));
static VALUE strscan_empty_p _((VALUE self));
static VALUE strscan_rest_p _((VALUE self));
static VALUE strscan_matched_p _((VALUE self));
static VALUE strscan_matched _((VALUE self));
static VALUE strscan_matched_size _((VALUE self));
static VALUE strscan_aref _((VALUE self, VALUE idx));
static VALUE strscan_pre_match _((VALUE self));
static VALUE strscan_post_match _((VALUE self));
static VALUE strscan_rest _((VALUE self));
static VALUE strscan_rest_size _((VALUE self));

static VALUE strscan_inspect _((VALUE self));
static VALUE inspect1 _((struct strscanner *p));
static VALUE inspect2 _((struct strscanner *p));

/* =======================================================================
                                   Utils
   ======================================================================= */

static VALUE
infect(VALUE str, struct strscanner *p)
{
    OBJ_INFECT(str, p-&gt;str);
    return str;
}

static VALUE
extract_range(struct strscanner *p, long beg_i, long end_i)
{
    if (beg_i &gt; S_LEN(p)) return Qnil;
    if (end_i &gt; S_LEN(p))
        end_i = S_LEN(p);
    return infect(rb_str_new(S_PBEG(p) + beg_i, end_i - beg_i), p);
}

static VALUE
extract_beg_len(struct strscanner *p, long beg_i, long len)
{
    if (beg_i &gt; S_LEN(p)) return Qnil;
    if (beg_i + len &gt; S_LEN(p))
        len = S_LEN(p) - beg_i;
    return infect(rb_str_new(S_PBEG(p) + beg_i, len), p);
}

/* =======================================================================
                               Constructor
   ======================================================================= */

static void
strscan_mark(struct strscanner *p)
{
    rb_gc_mark(p-&gt;str);
}

static void
strscan_free(struct strscanner *p)
{
    re_free_registers(&amp;(p-&gt;regs));
    free(p);
}

static VALUE
strscan_s_allocate(VALUE klass)
{
    struct strscanner *p;
    
    p = ALLOC(struct strscanner);
    MEMZERO(p, struct strscanner, 1);
    CLEAR_MATCH_STATUS(p);
    MEMZERO(&amp;(p-&gt;regs), struct re_registers, 1);
    p-&gt;str = Qnil;
    return Data_Wrap_Struct(klass, strscan_mark, strscan_free, p);
}

/*
 * call-seq: StringScanner.new(string, dup = false)
 *
 * Creates a new StringScanner object to scan over the given +string+.
 * +dup+ argument is obsolete and not used now.
 */
static VALUE
strscan_initialize(int argc, VALUE *argv, VALUE self)
{
    struct strscanner *p;
    VALUE str, need_dup;

    Data_Get_Struct(self, struct strscanner, p);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;need_dup);
    StringValue(str);
    p-&gt;str = str;

    return self;
}

static void
check_strscan(VALUE obj)
{
    if (TYPE(obj) != T_DATA || RDATA(obj)-&gt;dmark != (RUBY_DATA_FUNC)strscan_mark) {
        rb_raise(rb_eTypeError,
                 &quot;wrong argument type %s (expected StringScanner)&quot;,
                 rb_obj_classname(obj));
    }
}

/*
 * call-seq:
 *   dup
 *   clone
 *
 * Duplicates a StringScanner object.
 */
static VALUE
strscan_init_copy(VALUE vself, VALUE vorig)
{
    struct strscanner *self, *orig;

    Data_Get_Struct(vself, struct strscanner, self);
    check_strscan(vorig);
    Data_Get_Struct(vorig, struct strscanner, orig);
    if (self != orig) {
        self-&gt;flags = orig-&gt;flags;
        self-&gt;str = orig-&gt;str;
        self-&gt;prev = orig-&gt;prev;
        self-&gt;curr = orig-&gt;curr;
        re_copy_registers(&amp;self-&gt;regs, &amp;orig-&gt;regs);
    }
    return vself;
}

/* =======================================================================
                          Instance Methods
   ======================================================================= */

/*
 * call-seq: StringScanner.must_C_version
 *
 * This method is defined for backward compatibility.
 */
static VALUE
strscan_s_mustc(VALUE self)
{
    return self;
}

/*
 * Reset the scan pointer (index 0) and clear matching data.
 */
static VALUE
strscan_reset(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    p-&gt;curr = 0;
    CLEAR_MATCH_STATUS(p);
    return self;
}

/*
 * call-seq:
 *   terminate
 *   clear
 *
 * Set the scan pointer to the end of the string and clear matching data.
 */
static VALUE
strscan_terminate(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    p-&gt;curr = S_LEN(p);
    CLEAR_MATCH_STATUS(p);
    return self;
}

/*
 * Equivalent to #terminate.
 * This method is obsolete; use #terminate instead.
 */
static VALUE
strscan_clear(VALUE self)
{
    rb_warning(&quot;StringScanner#clear is obsolete; use #terminate instead&quot;);
    return strscan_terminate(self);
}

/*
 * Returns the string being scanned.
 */
static VALUE
strscan_get_string(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return p-&gt;str;
}

/*
 * call-seq: string=(str)
 *
 * Changes the string being scanned to +str+ and resets the scanner.
 * Returns +str+.
 */
static VALUE
strscan_set_string(VALUE self, VALUE str)
{
    struct strscanner *p;

    Data_Get_Struct(self, struct strscanner, p);
    StringValue(str);
    p-&gt;str = rb_str_dup(str);
    rb_obj_freeze(p-&gt;str);
    p-&gt;curr = 0;
    CLEAR_MATCH_STATUS(p);
    return str;
}

/*
 * call-seq:
 *   concat(str)
 *   &lt;&lt;(str)
 *
 * Appends +str+ to the string being scanned.
 * This method does not affect scan pointer.
 *
 *   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)
 *   s.scan(/Fri /)
 *   s &lt;&lt; &quot; +1000 GMT&quot;
 *   s.string            # -&gt; &quot;Fri Dec 12 1975 14:39 +1000 GMT&quot;
 *   s.scan(/Dec/)       # -&gt; &quot;Dec&quot;
 */
static VALUE
strscan_concat(VALUE self, VALUE str)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    StringValue(str);
    rb_str_append(p-&gt;str, str);
    return self;
}

/*
 * Returns the position of the scan pointer.  In the 'reset' position, this
 * value is zero.  In the 'terminated' position (i.e. the string is exhausted),
 * this value is the length of the string.
 *
 * In short, it's a 0-based index into the string.
 *
 *   s = StringScanner.new('test string')
 *   s.pos               # -&gt; 0
 *   s.scan_until /str/  # -&gt; &quot;test str&quot;
 *   s.pos               # -&gt; 8
 *   s.terminate         # -&gt; #&lt;StringScanner fin&gt;
 *   s.pos               # -&gt; 11
 */
static VALUE
strscan_get_pos(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return INT2FIX(p-&gt;curr);
}

/*
 * call-seq: pos=(n)
 *
 * Modify the scan pointer.
 *
 *   s = StringScanner.new('test string')
 *   s.pos = 7            # -&gt; 7
 *   s.rest               # -&gt; &quot;ring&quot;
 */
static VALUE
strscan_set_pos(VALUE self, VALUE v)
{
    struct strscanner *p;
    long i;

    GET_SCANNER(self, p);
    i = NUM2INT(v);
    if (i &lt; 0) i += S_LEN(p);
    if (i &lt; 0) rb_raise(rb_eRangeError, &quot;index out of range&quot;);
    if (i &gt; S_LEN(p)) rb_raise(rb_eRangeError, &quot;index out of range&quot;);
    p-&gt;curr = i;
    return INT2NUM(i);
}

static VALUE
strscan_do_scan(VALUE self, VALUE regex, int succptr, int getstr, int headonly)
{
    struct strscanner *p;
    int ret;

    Check_Type(regex, T_REGEXP);
    GET_SCANNER(self, p);

    CLEAR_MATCH_STATUS(p);
    if (S_RESTLEN(p) &lt; 0) {
        return Qnil;
    }
    rb_kcode_set_option(regex);
    if (headonly) {
        ret = re_match(RREGEXP(regex)-&gt;ptr,
                       CURPTR(p), S_RESTLEN(p),
                       0,
                       &amp;(p-&gt;regs));
    }
    else {
        ret = re_search(RREGEXP(regex)-&gt;ptr,
                        CURPTR(p), S_RESTLEN(p),
                        0,
                        S_RESTLEN(p),
                        &amp;(p-&gt;regs));
    }
    rb_kcode_reset_option();

    if (ret == -2) rb_raise(ScanError, &quot;regexp buffer overflow&quot;);
    if (ret &lt; 0) {
        /* not matched */
        return Qnil;
    }

    MATCHED(p);
    p-&gt;prev = p-&gt;curr;
    if (succptr) {
        p-&gt;curr += p-&gt;regs.end[0];
    }
    if (getstr) {
        return extract_beg_len(p, p-&gt;prev, p-&gt;regs.end[0]);
    }
    else {
        return INT2FIX(p-&gt;regs.end[0]);
    }
}

/*
 * call-seq: scan(pattern) =&gt; String
 *
 * Tries to match with +pattern+ at the current position. If there's a match,
 * the scanner advances the &quot;scan pointer&quot; and returns the matched string.
 * Otherwise, the scanner returns +nil+.
 *
 *   s = StringScanner.new('test string')
 *   p s.scan(/\w+/)   # -&gt; &quot;test&quot;
 *   p s.scan(/\w+/)   # -&gt; nil
 *   p s.scan(/\s+/)   # -&gt; &quot; &quot;
 *   p s.scan(/\w+/)   # -&gt; &quot;string&quot;
 *   p s.scan(/./)     # -&gt; nil
 *
 */
static VALUE
strscan_scan(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 1, 1);
}

/*
 * call-seq: match?(pattern)
 *
 * Tests whether the given +pattern+ is matched from the current scan pointer.
 * Returns the length of the match, or +nil+.  The scan pointer is not advanced.
 *
 *   s = StringScanner.new('test string')
 *   p s.match?(/\w+/)   # -&gt; 4
 *   p s.match?(/\w+/)   # -&gt; 4
 *   p s.match?(/\s+/)   # -&gt; nil
 */
static VALUE
strscan_match_p(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 0, 1);
}

/*
 * call-seq: skip(pattern)
 *
 * Attempts to skip over the given +pattern+ beginning with the scan pointer.
 * If it matches, the scan pointer is advanced to the end of the match, and the
 * length of the match is returned.  Otherwise, +nil+ is returned.
 *
 * It's similar to #scan, but without returning the matched string.
 *
 *   s = StringScanner.new('test string')
 *   p s.skip(/\w+/)   # -&gt; 4
 *   p s.skip(/\w+/)   # -&gt; nil
 *   p s.skip(/\s+/)   # -&gt; 1
 *   p s.skip(/\w+/)   # -&gt; 6
 *   p s.skip(/./)     # -&gt; nil
 *
 */
static VALUE
strscan_skip(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 0, 1);
}

/*
 * call-seq: check(pattern)
 *
 * This returns the value that #scan would return, without advancing the scan
 * pointer.  The match register is affected, though.
 *
 *   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)
 *   s.check /Fri/               # -&gt; &quot;Fri&quot;
 *   s.pos                       # -&gt; 0
 *   s.matched                   # -&gt; &quot;Fri&quot;
 *   s.check /12/                # -&gt; nil
 *   s.matched                   # -&gt; nil
 *
 * Mnemonic: it &quot;checks&quot; to see whether a #scan will return a value.
 */
static VALUE
strscan_check(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 1, 1);
}

/*
 * call-seq: scan_full(pattern, return_string_p, advance_pointer_p)
 *
 * Tests whether the given +pattern+ is matched from the current scan pointer.
 * Returns the matched string if +return_string_p+ is true.
 * Advances the scan pointer if +advance_pointer_p+ is true.
 * The match register is affected.
 *
 * &quot;full&quot; means &quot;#scan with full parameters&quot;.
 */
static VALUE
strscan_scan_full(VALUE self, VALUE re, VALUE s, VALUE f)
{
    return strscan_do_scan(self, re, RTEST(s), RTEST(f), 1);
}


/*
 * call-seq: scan_until(pattern)
 *
 * Scans the string _until_ the +pattern+ is matched.  Returns the substring up
 * to and including the end of the match, advancing the scan pointer to that
 * location. If there is no match, +nil+ is returned.
 *
 *   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)
 *   s.scan_until(/1/)        # -&gt; &quot;Fri Dec 1&quot;
 *   s.pre_match              # -&gt; &quot;Fri Dec &quot;
 *   s.scan_until(/XYZ/)      # -&gt; nil
 */
static VALUE
strscan_scan_until(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 1, 0);
}

/*
 * call-seq: exist?(pattern)
 *
 * Looks _ahead_ to see if the +pattern+ exists _anywhere_ in the string,
 * without advancing the scan pointer.  This predicates whether a #scan_until
 * will return a value.
 *
 *   s = StringScanner.new('test string')
 *   s.exist? /s/            # -&gt; 3
 *   s.scan /test/           # -&gt; &quot;test&quot;
 *   s.exist? /s/            # -&gt; 6
 *   s.exist? /e/            # -&gt; nil
 */
static VALUE
strscan_exist_p(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 0, 0);
}

/*
 * call-seq: skip_until(pattern)
 *
 * Advances the scan pointer until +pattern+ is matched and consumed.  Returns
 * the number of bytes advanced, or +nil+ if no match was found.
 *
 * Look ahead to match +pattern+, and advance the scan pointer to the _end_
 * of the match.  Return the number of characters advanced, or +nil+ if the
 * match was unsuccessful.
 *
 * It's similar to #scan_until, but without returning the intervening string.
 *
 *   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)
 *   s.skip_until /12/           # -&gt; 10
 *   s                           # 
 */
static VALUE
strscan_skip_until(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 0, 0);
}

/*
 * call-seq: check_until(pattern)
 *
 * This returns the value that #scan_until would return, without advancing the
 * scan pointer.  The match register is affected, though.
 *
 *   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)
 *   s.check_until /12/          # -&gt; &quot;Fri Dec 12&quot;
 *   s.pos                       # -&gt; 0
 *   s.matched                   # -&gt; 12
 *
 * Mnemonic: it &quot;checks&quot; to see whether a #scan_until will return a value.
 */
static VALUE
strscan_check_until(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 1, 0);
}

/*
 * call-seq: search_full(pattern, return_string_p, advance_pointer_p)
 *
 * Scans the string _until_ the +pattern+ is matched.
 * Returns the matched string if +return_string_p+ is true, otherwise
 * returns the number of bytes advanced.
 * Advances the scan pointer if +advance_pointer_p+, otherwise not.
 * This method does affect the match register.
 */
static VALUE
strscan_search_full(VALUE self, VALUE re, VALUE s, VALUE f)
{
    return strscan_do_scan(self, re, RTEST(s), RTEST(f), 0);
}

/* DANGEROUS; need to synchronize with regex.c */
static void
adjust_registers_to_matched(struct strscanner *p)
{
    if (p-&gt;regs.allocated == 0) {
        p-&gt;regs.beg = ALLOC_N(int, RE_NREGS);
        p-&gt;regs.end = ALLOC_N(int, RE_NREGS);
        p-&gt;regs.allocated = RE_NREGS;
    }
    p-&gt;regs.num_regs = 1;
    p-&gt;regs.beg[0] = 0;
    p-&gt;regs.end[0] = p-&gt;curr - p-&gt;prev;
}

/*
 * Scans one character and returns it.
 * This method is multi-byte character sensitive.
 * See also #get_byte.
 *
 *   s = StringScanner.new('ab')
 *   s.getch           # =&gt; &quot;a&quot;
 *   s.getch           # =&gt; &quot;b&quot;
 *   s.getch           # =&gt; nil
 *
 *   $KCODE = 'EUC'
 *   s = StringScanner.new(&quot;\244\242&quot;)
 *   s.getch           # =&gt; &quot;\244\242&quot;   # Japanese hira-kana &quot;A&quot; in EUC-JP
 *   s.getch           # =&gt; nil
 */
static VALUE
strscan_getch(VALUE self)
{
    struct strscanner *p;
    long len;

    GET_SCANNER(self, p);
    CLEAR_MATCH_STATUS(p);
    if (EOS_P(p))
        return Qnil;
    len = mbclen(*CURPTR(p));
    if (p-&gt;curr + len &gt; S_LEN(p)) {
        len = S_LEN(p) - p-&gt;curr;
    }
    p-&gt;prev = p-&gt;curr;
    p-&gt;curr += len;
    MATCHED(p);
    adjust_registers_to_matched(p);
    return extract_range(p, p-&gt;prev + p-&gt;regs.beg[0],
                            p-&gt;prev + p-&gt;regs.end[0]);
}

/*
 * Scans one byte and returns it.
 * This method is NOT multi-byte character sensitive.
 * See also #getch.
 *
 *   s = StringScanner.new('ab')
 *   s.get_byte         # =&gt; &quot;a&quot;
 *   s.get_byte         # =&gt; &quot;b&quot;
 *   s.get_byte         # =&gt; nil
 *
 *   s = StringScanner.new(&quot;\244\242&quot;)
 *   s.get_byte         # =&gt; &quot;\244&quot;
 *   s.get_byte         # =&gt; &quot;\242&quot;
 *   s.get_byte         # =&gt; nil
 */
static VALUE
strscan_get_byte(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    CLEAR_MATCH_STATUS(p);
    if (EOS_P(p)) {
        return Qnil;
    }
    p-&gt;prev = p-&gt;curr;
    p-&gt;curr++;
    MATCHED(p);
    adjust_registers_to_matched(p);
    return extract_range(p, p-&gt;prev + p-&gt;regs.beg[0],
                            p-&gt;prev + p-&gt;regs.end[0]);
}

/*
 * Equivalent to #get_byte.
 * This method is obsolete; use #get_byte instead.
 */
static VALUE
strscan_getbyte(VALUE self)
{
    rb_warning(&quot;StringScanner#getbyte is obsolete; use #get_byte instead&quot;);
    return strscan_get_byte(self);
}

/*
 * call-seq: peek(len)
 *
 * Extracts a string corresponding to &lt;tt&gt;string[pos,len]&lt;/tt&gt;, without
 * advancing the scan pointer.
 *
 *   s = StringScanner.new('test string')
 *   s.peek(7)          # =&gt; &quot;test st&quot;
 *   s.peek(7)          # =&gt; &quot;test st&quot;
 *
 */
static VALUE
strscan_peek(VALUE self, VALUE vlen)
{
    struct strscanner *p;
    long len;

    GET_SCANNER(self, p);
    len = NUM2LONG(vlen);
    if (EOS_P(p)) {
        return infect(rb_str_new(&quot;&quot;, 0), p);
    }
    if (p-&gt;curr + len &gt; S_LEN(p)) {
        len = S_LEN(p) - p-&gt;curr;
    }
    return extract_beg_len(p, p-&gt;curr, len);
}

/*
 * Equivalent to #peek.
 * This method is obsolete; use #peek instead.
 */
static VALUE
strscan_peep(VALUE self, VALUE vlen)
{
    rb_warning(&quot;StringScanner#peep is obsolete; use #peek instead&quot;);
    return strscan_peek(self, vlen);
}

/*
 * Set the scan pointer to the previous position.  Only one previous position is
 * remembered, and it changes with each scanning operation.
 *
 *   s = StringScanner.new('test string')
 *   s.scan(/\w+/)        # =&gt; &quot;test&quot;
 *   s.unscan
 *   s.scan(/../)         # =&gt; &quot;te&quot;
 *   s.scan(/\d/)         # =&gt; nil
 *   s.unscan             # ScanError: unscan failed: previous match had failed
 */
static VALUE
strscan_unscan(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) {
        rb_raise(ScanError, &quot;unscan failed: previous match had failed&quot;);
    }
    p-&gt;curr = p-&gt;prev;
    CLEAR_MATCH_STATUS(p);
    return self;
}

/*
 * Returns +true+ iff the scan pointer is at the beginning of the line.
 *
 *   s = StringScanner.new(&quot;test\ntest\n&quot;)
 *   s.bol?           # =&gt; true
 *   s.scan(/te/)
 *   s.bol?           # =&gt; false
 *   s.scan(/st\n/)
 *   s.bol?           # =&gt; true
 *   s.terminate
 *   s.bol?           # =&gt; true
 */
static VALUE
strscan_bol_p(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (CURPTR(p) &gt; S_PEND(p)) return Qnil;
    if (p-&gt;curr == 0) return Qtrue;
    return (*(CURPTR(p) - 1) == '\n') ? Qtrue : Qfalse;
}

/*
 * Returns +true+ if the scan pointer is at the end of the string.
 *
 *   s = StringScanner.new('test string')
 *   p s.eos?          # =&gt; false
 *   s.scan(/test/)
 *   p s.eos?          # =&gt; false
 *   s.terminate
 *   p s.eos?          # =&gt; true
 */
static VALUE
strscan_eos_p(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return EOS_P(p) ? Qtrue : Qfalse;
}

/*
 * Equivalent to #eos?.
 * This method is obsolete, use #eos? instead.
 */
static VALUE
strscan_empty_p(VALUE self)
{
    rb_warning(&quot;StringScanner#empty? is obsolete; use #eos? instead&quot;);
    return strscan_eos_p(self);
}

/*
 * Returns true iff there is more data in the string.  See #eos?.
 * This method is obsolete; use #eos? instead.
 *
 *   s = StringScanner.new('test string')
 *   s.eos?              # These two
 *   s.rest?             # are opposites.
 */
static VALUE
strscan_rest_p(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return EOS_P(p) ? Qfalse : Qtrue;
}

/*
 * Returns +true+ iff the last match was successful.
 *
 *   s = StringScanner.new('test string')
 *   s.match?(/\w+/)     # =&gt; 4
 *   s.matched?          # =&gt; true
 *   s.match?(/\d+/)     # =&gt; nil
 *   s.matched?          # =&gt; false
 */
static VALUE
strscan_matched_p(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return MATCHED_P(p) ? Qtrue : Qfalse;
}

/*
 * Returns the last matched string.
 * 
 *   s = StringScanner.new('test string')
 *   s.match?(/\w+/)     # -&gt; 4
 *   s.matched           # -&gt; &quot;test&quot;
 */
static VALUE
strscan_matched(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;

    return extract_range(p, p-&gt;prev + p-&gt;regs.beg[0],
                            p-&gt;prev + p-&gt;regs.end[0]);
}

/*
 * Returns the size of the most recent match (see #matched), or +nil+ if there
 * was no recent match.
 *
 *   s = StringScanner.new('test string')
 *   s.check /\w+/           # -&gt; &quot;test&quot;
 *   s.matched_size          # -&gt; 4
 *   s.check /\d+/           # -&gt; nil
 *   s.matched_size          # -&gt; nil
 */
static VALUE
strscan_matched_size(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;

    return INT2NUM(p-&gt;regs.end[0] - p-&gt;regs.beg[0]);
}

/*
 * Equivalent to #matched_size.
 * This method is obsolete; use #matched_size instead.
 */
static VALUE
strscan_matchedsize(VALUE self)
{
    rb_warning(&quot;StringScanner#matchedsize is obsolete; use #matched_size instead&quot;);
    return strscan_matched_size(self);
}

/*
 * call-seq: [](n)
 *
 * Return the n-th subgroup in the most recent match.
 *
 *   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)
 *   s.scan(/(\w+) (\w+) (\d+) /)       # -&gt; &quot;Fri Dec 12 &quot;
 *   s[0]                               # -&gt; &quot;Fri Dec 12 &quot;
 *   s[1]                               # -&gt; &quot;Fri&quot;
 *   s[2]                               # -&gt; &quot;Dec&quot;
 *   s[3]                               # -&gt; &quot;12&quot;
 *   s.post_match                       # -&gt; &quot;1975 14:39&quot;
 *   s.pre_match                        # -&gt; &quot;&quot;
 */
static VALUE
strscan_aref(VALUE self, VALUE idx)
{
    struct strscanner *p;
    long i;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p))        return Qnil;
    
    i = NUM2LONG(idx);
    if (i &lt; 0)
        i += p-&gt;regs.num_regs;
    if (i &lt; 0)                 return Qnil;
    if (i &gt;= p-&gt;regs.num_regs) return Qnil;
    if (p-&gt;regs.beg[i] == -1)  return Qnil;

    return extract_range(p, p-&gt;prev + p-&gt;regs.beg[i],
                            p-&gt;prev + p-&gt;regs.end[i]);
}

/*
 * Return the &lt;i&gt;&lt;b&gt;pre&lt;/b&gt;-match&lt;/i&gt; (in the regular expression sense) of the last scan.
 *
 *   s = StringScanner.new('test string')
 *   s.scan(/\w+/)           # -&gt; &quot;test&quot;
 *   s.scan(/\s+/)           # -&gt; &quot; &quot;
 *   s.pre_match             # -&gt; &quot;test&quot;
 *   s.post_match            # -&gt; &quot;string&quot;
 */
static VALUE
strscan_pre_match(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;

    return extract_range(p, 0, p-&gt;prev + p-&gt;regs.beg[0]);
}

/*
 * Return the &lt;i&gt;&lt;b&gt;post&lt;/b&gt;-match&lt;/i&gt; (in the regular expression sense) of the last scan.
 *
 *   s = StringScanner.new('test string')
 *   s.scan(/\w+/)           # -&gt; &quot;test&quot;
 *   s.scan(/\s+/)           # -&gt; &quot; &quot;
 *   s.pre_match             # -&gt; &quot;test&quot;
 *   s.post_match            # -&gt; &quot;string&quot;
 */
static VALUE
strscan_post_match(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;

    return extract_range(p, p-&gt;prev + p-&gt;regs.end[0], S_LEN(p));
}

/*
 * Returns the &quot;rest&quot; of the string (i.e. everything after the scan pointer).
 * If there is no more data (eos? = true), it returns &lt;tt&gt;&quot;&quot;&lt;/tt&gt;.
 */
static VALUE
strscan_rest(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (EOS_P(p)) {
        return infect(rb_str_new(&quot;&quot;, 0), p);
    }
    return extract_range(p, p-&gt;curr, S_LEN(p));
}

/*
 * &lt;tt&gt;s.rest_size&lt;/tt&gt; is equivalent to &lt;tt&gt;s.rest.size&lt;/tt&gt;.
 */
static VALUE
strscan_rest_size(VALUE self)
{
    struct strscanner *p;
    long i;

    GET_SCANNER(self, p);
    if (EOS_P(p)) {
        return INT2FIX(0);
    }

    i = S_LEN(p) - p-&gt;curr;
    return INT2FIX(i);
}

/*
 * &lt;tt&gt;s.restsize&lt;/tt&gt; is equivalent to &lt;tt&gt;s.rest_size&lt;/tt&gt;.
 * This method is obsolete; use #rest_size instead.
 */
static VALUE
strscan_restsize(VALUE self)
{
    rb_warning(&quot;StringScanner#restsize is obsolete; use #rest_size instead&quot;);
    return strscan_rest_size(self);
}

#define INSPECT_LENGTH 5
#define BUFSIZE 256

/*
 * Returns a string that represents the StringScanner object, showing:
 * - the current position
 * - the size of the string
 * - the characters surrounding the scan pointer
 *
 *   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)
 *   s.inspect            # -&gt; '#&lt;StringScanner 0/21 @ &quot;Fri D...&quot;&gt;'
 *   s.scan_until /12/    # -&gt; &quot;Fri Dec 12&quot;
 *   s.inspect            # -&gt; '#&lt;StringScanner 10/21 &quot;...ec 12&quot; @ &quot; 1975...&quot;&gt;'
 */
static VALUE
strscan_inspect(VALUE self)
{
    struct strscanner *p;
    char buf[BUFSIZE];
    long len;
    VALUE a, b;

    Data_Get_Struct(self, struct strscanner, p);
    if (NIL_P(p-&gt;str)) {
        len = snprintf(buf, BUFSIZE, &quot;#&lt;%s (uninitialized)&gt;&quot;,
                       rb_class2name(CLASS_OF(self)));
        return infect(rb_str_new(buf, len), p);
    }
    if (EOS_P(p)) {
        len = snprintf(buf, BUFSIZE, &quot;#&lt;%s fin&gt;&quot;,
                       rb_class2name(CLASS_OF(self)));
        return infect(rb_str_new(buf, len), p);
    }
    if (p-&gt;curr == 0) {
        b = inspect2(p);
        len = snprintf(buf, BUFSIZE, &quot;#&lt;%s %ld/%ld @ %s&gt;&quot;,
                       rb_class2name(CLASS_OF(self)),
                       p-&gt;curr, S_LEN(p),
                       RSTRING(b)-&gt;ptr);
        return infect(rb_str_new(buf, len), p);
    }
    a = inspect1(p);
    b = inspect2(p);
    len = snprintf(buf, BUFSIZE, &quot;#&lt;%s %ld/%ld %s @ %s&gt;&quot;,
                   rb_class2name(CLASS_OF(self)),
                   p-&gt;curr, S_LEN(p),
                   RSTRING(a)-&gt;ptr,
                   RSTRING(b)-&gt;ptr);
    return infect(rb_str_new(buf, len), p);
}

static VALUE
inspect1(struct strscanner *p)
{
    char buf[BUFSIZE];
    char *bp = buf;
    long len;

    if (p-&gt;curr == 0) return rb_str_new2(&quot;&quot;);
    if (p-&gt;curr &gt; INSPECT_LENGTH) {
        strcpy(bp, &quot;...&quot;); bp += 3;
        len = INSPECT_LENGTH;
    }
    else {
        len = p-&gt;curr;
    }
    memcpy(bp, CURPTR(p) - len, len); bp += len;
    return rb_str_dump(rb_str_new(buf, bp - buf));
}

static VALUE
inspect2(struct strscanner *p)
{
    char buf[BUFSIZE];
    char *bp = buf;
    long len;

    if (EOS_P(p)) return rb_str_new2(&quot;&quot;);
    len = S_LEN(p) - p-&gt;curr;
    if (len &gt; INSPECT_LENGTH) {
        len = INSPECT_LENGTH;
        memcpy(bp, CURPTR(p), len); bp += len;
        strcpy(bp, &quot;...&quot;); bp += 3;
    }
    else {
        memcpy(bp, CURPTR(p), len); bp += len;
    }
    return rb_str_dump(rb_str_new(buf, bp - buf));
}

/* =======================================================================
                              Ruby Interface
   ======================================================================= */

/*
 * Document-class: StringScanner
 * 
 * StringScanner provides for lexical scanning operations on a String.  Here is
 * an example of its usage:
 *
 *   s = StringScanner.new('This is an example string')
 *   s.eos?               # -&gt; false
 *   
 *   p s.scan(/\w+/)      # -&gt; &quot;This&quot;
 *   p s.scan(/\w+/)      # -&gt; nil
 *   p s.scan(/\s+/)      # -&gt; &quot; &quot;
 *   p s.scan(/\s+/)      # -&gt; nil
 *   p s.scan(/\w+/)      # -&gt; &quot;is&quot;
 *   s.eos?               # -&gt; false
 *   
 *   p s.scan(/\s+/)      # -&gt; &quot; &quot;
 *   p s.scan(/\w+/)      # -&gt; &quot;an&quot;
 *   p s.scan(/\s+/)      # -&gt; &quot; &quot;
 *   p s.scan(/\w+/)      # -&gt; &quot;example&quot;
 *   p s.scan(/\s+/)      # -&gt; &quot; &quot;
 *   p s.scan(/\w+/)      # -&gt; &quot;string&quot;
 *   s.eos?               # -&gt; true
 *   
 *   p s.scan(/\s+/)      # -&gt; nil
 *   p s.scan(/\w+/)      # -&gt; nil
 *
 * Scanning a string means remembering the position of a &lt;i&gt;scan pointer&lt;/i&gt;,
 * which is just an index.  The point of scanning is to move forward a bit at
 * a time, so matches are sought after the scan pointer; usually immediately
 * after it.
 *
 * Given the string &quot;test string&quot;, here are the pertinent scan pointer
 * positions:
 *
 *     t e s t   s t r i n g
 *   0 1 2 ...             1
 *                         0
 *
 * When you #scan for a pattern (a regular expression), the match must occur
 * at the character after the scan pointer.  If you use #scan_until, then the
 * match can occur anywhere after the scan pointer.  In both cases, the scan
 * pointer moves &lt;i&gt;just beyond&lt;/i&gt; the last character of the match, ready to
 * scan again from the next character onwards.  This is demonstrated by the
 * example above.
 *
 * == Method Categories
 *
 * There are other methods besides the plain scanners.  You can look ahead in
 * the string without actually scanning.  You can access the most recent match.
 * You can modify the string being scanned, reset or terminate the scanner,
 * find out or change the position of the scan pointer, skip ahead, and so on.
 * 
 * === Advancing the Scan Pointer
 *
 * - #getch
 * - #get_byte
 * - #scan
 * - #scan_until
 * - #skip
 * - #skip_until
 *
 * === Looking Ahead
 *
 * - #check
 * - #check_until
 * - #exist?
 * - #match?
 * - #peek
 *
 * === Finding Where we Are
 *
 * - #beginning_of_line? (#bol?)
 * - #eos?
 * - #rest?
 * - #rest_size
 * - #pos
 *
 * === Setting Where we Are
 *
 * - #reset
 * - #terminate
 * - #pos=
 * 
 * === Match Data
 *
 * - #matched
 * - #matched?
 * - #matched_size
 * - []
 * - #pre_match
 * - #post_match
 *
 * === Miscellaneous
 *
 * - &lt;&lt;
 * - #concat
 * - #string
 * - #string=
 * - #unscan
 *
 * There are aliases to several of the methods.
 */
void
Init_strscan(void)
{
    ID id_scanerr = rb_intern(&quot;ScanError&quot;);
    VALUE tmp;

    StringScanner = rb_define_class(&quot;StringScanner&quot;, rb_cObject);
    ScanError = rb_define_class_under(StringScanner, &quot;Error&quot;, rb_eStandardError);
    if (!rb_const_defined(rb_cObject, id_scanerr)) {
	rb_const_set(rb_cObject, id_scanerr, ScanError);
    }
    tmp = rb_str_new2(STRSCAN_VERSION);
    rb_obj_freeze(tmp);
    rb_const_set(StringScanner, rb_intern(&quot;Version&quot;), tmp);
    tmp = rb_str_new2(&quot;$Id: strscan.c 11708 2007-02-12 23:01:19Z shyouhei $&quot;);
    rb_obj_freeze(tmp);
    rb_const_set(StringScanner, rb_intern(&quot;Id&quot;), tmp);
    
    rb_define_alloc_func(StringScanner, strscan_s_allocate);
    rb_define_private_method(StringScanner, &quot;initialize&quot;, strscan_initialize, -1);
    rb_define_private_method(StringScanner, &quot;initialize_copy&quot;, strscan_init_copy, 1);
    rb_define_singleton_method(StringScanner, &quot;must_C_version&quot;, strscan_s_mustc, 0);
    rb_define_method(StringScanner, &quot;reset&quot;,       strscan_reset,       0);
    rb_define_method(StringScanner, &quot;terminate&quot;,   strscan_terminate,   0);
    rb_define_method(StringScanner, &quot;clear&quot;,       strscan_clear,       0);
    rb_define_method(StringScanner, &quot;string&quot;,      strscan_get_string,  0);
    rb_define_method(StringScanner, &quot;string=&quot;,     strscan_set_string,  1);
    rb_define_method(StringScanner, &quot;concat&quot;,      strscan_concat,      1);
    rb_define_method(StringScanner, &quot;&lt;&lt;&quot;,          strscan_concat,      1);
    rb_define_method(StringScanner, &quot;pos&quot;,         strscan_get_pos,     0);
    rb_define_method(StringScanner, &quot;pos=&quot;,        strscan_set_pos,     1);
    rb_define_method(StringScanner, &quot;pointer&quot;,     strscan_get_pos,     0);
    rb_define_method(StringScanner, &quot;pointer=&quot;,    strscan_set_pos,     1);

    rb_define_method(StringScanner, &quot;scan&quot;,        strscan_scan,        1);
    rb_define_method(StringScanner, &quot;skip&quot;,        strscan_skip,        1);
    rb_define_method(StringScanner, &quot;match?&quot;,      strscan_match_p,     1);
    rb_define_method(StringScanner, &quot;check&quot;,       strscan_check,       1);
    rb_define_method(StringScanner, &quot;scan_full&quot;,   strscan_scan_full,   3);

    rb_define_method(StringScanner, &quot;scan_until&quot;,  strscan_scan_until,  1);
    rb_define_method(StringScanner, &quot;skip_until&quot;,  strscan_skip_until,  1);
    rb_define_method(StringScanner, &quot;exist?&quot;,      strscan_exist_p,     1);
    rb_define_method(StringScanner, &quot;check_until&quot;, strscan_check_until, 1);
    rb_define_method(StringScanner, &quot;search_full&quot;, strscan_search_full, 3);

    rb_define_method(StringScanner, &quot;getch&quot;,       strscan_getch,       0);
    rb_define_method(StringScanner, &quot;get_byte&quot;,    strscan_get_byte,    0);
    rb_define_method(StringScanner, &quot;getbyte&quot;,     strscan_getbyte,     0);
    rb_define_method(StringScanner, &quot;peek&quot;,        strscan_peek,        1);
    rb_define_method(StringScanner, &quot;peep&quot;,        strscan_peep,        1);

    rb_define_method(StringScanner, &quot;unscan&quot;,      strscan_unscan,      0);

    rb_define_method(StringScanner, &quot;beginning_of_line?&quot;, strscan_bol_p, 0);
    rb_alias(StringScanner, rb_intern(&quot;bol?&quot;), rb_intern(&quot;beginning_of_line?&quot;));
    rb_define_method(StringScanner, &quot;eos?&quot;,        strscan_eos_p,       0);
    rb_define_method(StringScanner, &quot;empty?&quot;,      strscan_empty_p,     0);
    rb_define_method(StringScanner, &quot;rest?&quot;,       strscan_rest_p,      0);

    rb_define_method(StringScanner, &quot;matched?&quot;,    strscan_matched_p,   0);
    rb_define_method(StringScanner, &quot;matched&quot;,     strscan_matched,     0);
    rb_define_method(StringScanner, &quot;matched_size&quot;, strscan_matched_size, 0);
    rb_define_method(StringScanner, &quot;matchedsize&quot;, strscan_matchedsize, 0);
    rb_define_method(StringScanner, &quot;[]&quot;,          strscan_aref,        1);
    rb_define_method(StringScanner, &quot;pre_match&quot;,   strscan_pre_match,   0);
    rb_define_method(StringScanner, &quot;post_match&quot;,  strscan_post_match,  0);

    rb_define_method(StringScanner, &quot;rest&quot;,        strscan_rest,        0);
    rb_define_method(StringScanner, &quot;rest_size&quot;,   strscan_rest_size,   0);
    rb_define_method(StringScanner, &quot;restsize&quot;,    strscan_restsize,    0);

    rb_define_method(StringScanner, &quot;inspect&quot;,     strscan_inspect,     0);
}
</pre>
    </div>