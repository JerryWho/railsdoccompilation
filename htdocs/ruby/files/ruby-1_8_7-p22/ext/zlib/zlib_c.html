  <div id="fileHeader">
    <h1>zlib.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/ext/zlib/zlib.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jun 08 13:28:37 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/*
 * zlib.c - An interface for zlib.
 *
 *   Copyright (C) UENO Katsuhiro 2000-2003
 *
 * $Id: zlib.c 17033 2008-06-08 18:28:37Z knu $
 */

#include &lt;ruby.h&gt;
#include &lt;zlib.h&gt;
#include &lt;time.h&gt;

#define RUBY_ZLIB_VERSION  &quot;0.6.0&quot;


#define OBJ_IS_FREED(val)  (RBASIC(val)-&gt;flags == 0)

#ifndef GZIP_SUPPORT
#define GZIP_SUPPORT  1
#endif

/* from zutil.h */
#ifndef DEF_MEM_LEVEL
#if MAX_MEM_LEVEL &gt;= 8
#define DEF_MEM_LEVEL  8
#else
#define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
#endif


/*--------- Prototypes --------*/

static NORETURN(void raise_zlib_error _((int, const char *)));
static VALUE rb_zlib_version _((VALUE));
static VALUE do_checksum _((int, VALUE*, uLong (*) _((uLong, const Bytef*, uInt))));
static VALUE rb_zlib_adler32 _((int, VALUE*, VALUE));
static VALUE rb_zlib_crc32 _((int, VALUE*, VALUE));
static VALUE rb_zlib_crc_table _((VALUE));
static voidpf zlib_mem_alloc _((voidpf, uInt, uInt));
static void zlib_mem_free _((voidpf, voidpf));
static void finalizer_warn _((const char*));

struct zstream;
struct zstream_funcs;
static void zstream_init _((struct zstream*, const struct zstream_funcs *));
static void zstream_expand_buffer _((struct zstream*));
static void zstream_expand_buffer_into _((struct zstream*, int));
static void zstream_append_buffer _((struct zstream*, const char*, int));
static VALUE zstream_detach_buffer _((struct zstream*));
static VALUE zstream_shift_buffer _((struct zstream*, int));
static void zstream_buffer_ungetc _((struct zstream*, int));
static void zstream_append_input _((struct zstream*, const char*, unsigned int));
static void zstream_discard_input _((struct zstream*, unsigned int));
static void zstream_reset_input _((struct zstream*));
static void zstream_passthrough_input _((struct zstream*));
static VALUE zstream_detach_input _((struct zstream*));
static void zstream_reset _((struct zstream*));
static VALUE zstream_end _((struct zstream*));
static void zstream_run _((struct zstream*, Bytef*, uInt, int));
static VALUE zstream_sync _((struct zstream*, Bytef*, uInt));
static void zstream_mark _((struct zstream*));
static void zstream_free _((struct zstream*));
static VALUE zstream_new _((VALUE, const struct zstream_funcs*));
static struct zstream *get_zstream _((VALUE));
static void zstream_finalize _((struct zstream*));

static VALUE rb_zstream_end _((VALUE));
static VALUE rb_zstream_reset _((VALUE));
static VALUE rb_zstream_finish _((VALUE));
static VALUE rb_zstream_flush_next_in _((VALUE));
static VALUE rb_zstream_flush_next_out _((VALUE));
static VALUE rb_zstream_avail_out _((VALUE));
static VALUE rb_zstream_set_avail_out _((VALUE, VALUE));
static VALUE rb_zstream_avail_in _((VALUE));
static VALUE rb_zstream_total_in _((VALUE));
static VALUE rb_zstream_total_out _((VALUE));
static VALUE rb_zstream_data_type _((VALUE));
static VALUE rb_zstream_adler _((VALUE));
static VALUE rb_zstream_finished_p _((VALUE));
static VALUE rb_zstream_closed_p _((VALUE));

static VALUE rb_deflate_s_allocate _((VALUE));
static VALUE rb_deflate_initialize _((int, VALUE*, VALUE));
static VALUE rb_deflate_init_copy _((VALUE, VALUE));
static VALUE deflate_run _((VALUE));
static VALUE rb_deflate_s_deflate _((int, VALUE*, VALUE));
static void do_deflate _((struct zstream*, VALUE, int));
static VALUE rb_deflate_deflate _((int, VALUE*, VALUE));
static VALUE rb_deflate_addstr _((VALUE, VALUE));
static VALUE rb_deflate_flush _((int, VALUE*, VALUE));
static VALUE rb_deflate_params _((VALUE, VALUE, VALUE));
static VALUE rb_deflate_set_dictionary _((VALUE, VALUE));

static VALUE inflate_run _((VALUE));
static VALUE rb_inflate_s_allocate _((VALUE));
static VALUE rb_inflate_initialize _((int, VALUE*, VALUE));
static VALUE rb_inflate_s_inflate _((VALUE, VALUE));
static void do_inflate _((struct zstream*, VALUE));
static VALUE rb_inflate_inflate _((VALUE, VALUE));
static VALUE rb_inflate_addstr _((VALUE, VALUE));
static VALUE rb_inflate_sync _((VALUE, VALUE));
static VALUE rb_inflate_sync_point_p _((VALUE));
static VALUE rb_inflate_set_dictionary _((VALUE, VALUE));

#if GZIP_SUPPORT
struct gzfile;
static void gzfile_mark _((struct gzfile*));
static void gzfile_free _((struct gzfile*));
static VALUE gzfile_new _((VALUE, const struct zstream_funcs*, void (*) _((struct gzfile*))));
static void gzfile_reset _((struct gzfile*));
static void gzfile_close _((struct gzfile*, int));
static void gzfile_write_raw _((struct gzfile*));
static VALUE gzfile_read_raw _((struct gzfile*));
static int gzfile_read_raw_ensure _((struct gzfile*, int));
static char *gzfile_read_raw_until_zero _((struct gzfile*, long));
static unsigned int gzfile_get16 _((const unsigned char*));
static unsigned long gzfile_get32 _((const unsigned char*));
static void gzfile_set32 _((unsigned long n, unsigned char*));
static void gzfile_make_header _((struct gzfile*));
static void gzfile_make_footer _((struct gzfile*));
static void gzfile_read_header _((struct gzfile*));
static void gzfile_check_footer _((struct gzfile*));
static void gzfile_write _((struct gzfile*, Bytef*, uInt));
static long gzfile_read_more _((struct gzfile*));
static void gzfile_calc_crc _((struct gzfile*, VALUE));
static VALUE gzfile_read _((struct gzfile*, int));
static VALUE gzfile_read_all _((struct gzfile*));
static void gzfile_ungetc _((struct gzfile*, int));
static VALUE gzfile_writer_end_run _((VALUE));
static void gzfile_writer_end _((struct gzfile*));
static VALUE gzfile_reader_end_run _((VALUE));
static void gzfile_reader_end _((struct gzfile*));
static void gzfile_reader_rewind _((struct gzfile*));
static VALUE gzfile_reader_get_unused _((struct gzfile*));
static struct gzfile *get_gzfile _((VALUE));
static VALUE gzfile_ensure_close _((VALUE));
static VALUE rb_gzfile_s_wrap _((int, VALUE*, VALUE));
static VALUE gzfile_s_open _((int, VALUE*, VALUE, const char*));

static VALUE rb_gzfile_to_io _((VALUE));
static VALUE rb_gzfile_crc _((VALUE));
static VALUE rb_gzfile_mtime _((VALUE));
static VALUE rb_gzfile_level _((VALUE));
static VALUE rb_gzfile_os_code _((VALUE));
static VALUE rb_gzfile_orig_name _((VALUE));
static VALUE rb_gzfile_comment _((VALUE));
static VALUE rb_gzfile_lineno _((VALUE));
static VALUE rb_gzfile_set_lineno _((VALUE, VALUE));
static VALUE rb_gzfile_set_mtime _((VALUE, VALUE));
static VALUE rb_gzfile_set_orig_name _((VALUE, VALUE));
static VALUE rb_gzfile_set_comment _((VALUE, VALUE));
static VALUE rb_gzfile_close _((VALUE));
static VALUE rb_gzfile_finish _((VALUE));
static VALUE rb_gzfile_closed_p _((VALUE));
static VALUE rb_gzfile_eof_p _((VALUE));
static VALUE rb_gzfile_sync _((VALUE));
static VALUE rb_gzfile_set_sync _((VALUE, VALUE));
static VALUE rb_gzfile_total_in _((VALUE));
static VALUE rb_gzfile_total_out _((VALUE));

static VALUE rb_gzwriter_s_allocate _((VALUE));
static VALUE rb_gzwriter_s_open _((int, VALUE*, VALUE));
static VALUE rb_gzwriter_initialize _((int, VALUE*, VALUE));
static VALUE rb_gzwriter_flush _((int, VALUE*, VALUE));
static VALUE rb_gzwriter_write _((VALUE, VALUE));
static VALUE rb_gzwriter_putc _((VALUE, VALUE));

static VALUE rb_gzreader_s_allocate _((VALUE));
static VALUE rb_gzreader_s_open _((int, VALUE*, VALUE));
static VALUE rb_gzreader_initialize _((VALUE, VALUE));
static VALUE rb_gzreader_rewind _((VALUE));
static VALUE rb_gzreader_unused _((VALUE));
static VALUE rb_gzreader_read _((int, VALUE*, VALUE));
static VALUE rb_gzreader_getc _((VALUE));
static VALUE rb_gzreader_readchar _((VALUE));
static VALUE rb_gzreader_each_byte _((VALUE));
static VALUE rb_gzreader_ungetc _((VALUE, VALUE));
static void gzreader_skip_linebreaks _((struct gzfile*));
static VALUE gzreader_gets _((int, VALUE*, VALUE));
static VALUE rb_gzreader_gets _((int, VALUE*, VALUE));
static VALUE rb_gzreader_readline _((int, VALUE*, VALUE));
static VALUE rb_gzreader_each _((int, VALUE*, VALUE));
static VALUE rb_gzreader_readlines _((int, VALUE*, VALUE));
#endif /* GZIP_SUPPORT */


void Init_zlib _((void));



/*--------- Exceptions --------*/

static VALUE cZError, cStreamEnd, cNeedDict;
static VALUE cStreamError, cDataError, cMemError, cBufError, cVersionError;

static void
raise_zlib_error(err, msg)
    int err;
    const char *msg;
{
    VALUE exc;

    if (!msg) {
	msg = zError(err);
    }

    switch(err) {
      case Z_STREAM_END:
	exc = rb_exc_new2(cStreamEnd, msg);
	break;
      case Z_NEED_DICT:
	exc = rb_exc_new2(cNeedDict, msg);
	break;
      case Z_STREAM_ERROR:
	exc = rb_exc_new2(cStreamError, msg);
	break;
      case Z_DATA_ERROR:
	exc = rb_exc_new2(cDataError, msg);
	break;
      case Z_BUF_ERROR:
	exc = rb_exc_new2(cBufError, msg);
	break;
      case Z_VERSION_ERROR:
	exc = rb_exc_new2(cVersionError, msg);
	break;
      case Z_MEM_ERROR:
	exc = rb_exc_new2(cMemError, msg);
	break;
      case Z_ERRNO:
	rb_sys_fail(msg);
	/* no return */
      default:
      {
	  char buf[BUFSIZ];
	  snprintf(buf, BUFSIZ, &quot;unknown zlib error %d: %s&quot;, err, msg);
	  exc = rb_exc_new2(cZError, buf);
      }
    }

    rb_exc_raise(exc);
}


/*--- Warning (in finalizer) ---*/

static void
finalizer_warn(msg)
    const char *msg;
{
    fprintf(stderr, &quot;zlib(finalizer): %s\n&quot;, msg);
}


/*-------- module Zlib --------*/

/*
 * Returns the string which represents the version of zlib library.
 */
static VALUE
rb_zlib_version(klass)
    VALUE klass;
{
    VALUE str;

    str = rb_str_new2(zlibVersion());
    OBJ_TAINT(str);  /* for safe */
    return str;
}

static VALUE
do_checksum(argc, argv, func)
    int argc;
    VALUE *argv;
    uLong (*func) _((uLong, const Bytef *, uInt));
{
    VALUE str, vsum;
    unsigned long sum;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;vsum);

    if (!NIL_P(vsum)) {
	sum = NUM2ULONG(vsum);
    }
    else if (NIL_P(str)) {
	sum = 0;
    }
    else {
	sum = func(0, Z_NULL, 0);
    }

    if (NIL_P(str)) {
	sum = func(sum, Z_NULL, 0);
    }
    else {
	StringValue(str);
	sum = func(sum, RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len);
    }
    return rb_uint2inum(sum);
}

/*
 * call-seq: Zlib.adler32(string, adler)
 *
 * Calculates Alder-32 checksum for +string+, and returns updated value of
 * +adler+. If +string+ is omitted, it returns the Adler-32 initial value. If
 * +adler+ is omitted, it assumes that the initial value is given to +adler+.
 *
 * FIXME: expression.
 */
static VALUE
rb_zlib_adler32(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return do_checksum(argc, argv, adler32);
}

/*
 * call-seq: Zlib.crc32(string, adler)
 *
 * Calculates CRC checksum for +string+, and returns updated value of +crc+. If
 * +string+ is omitted, it returns the CRC initial value. If +crc+ is omitted, it
 * assumes that the initial value is given to +crc+.
 *
 * FIXME: expression.
 */
static VALUE
rb_zlib_crc32(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return do_checksum(argc, argv, crc32);
}

/*
 * Returns the table for calculating CRC checksum as an array.
 */
static VALUE
rb_zlib_crc_table(obj)
    VALUE obj;
{
    const unsigned long *crctbl;
    VALUE dst;
    int i;

    crctbl = get_crc_table();
    dst = rb_ary_new2(256);

    for (i = 0; i &lt; 256; i++) {
	rb_ary_push(dst, rb_uint2inum(crctbl[i]));
    }
    return dst;
}



/*-------- zstream - internal APIs --------*/

struct zstream {
    unsigned long flags;
    VALUE buf;
    long buf_filled;
    VALUE input;
    z_stream stream;
    const struct zstream_funcs {
	int (*reset) _((z_streamp));
	int (*end) _((z_streamp));
	int (*run) _((z_streamp, int));
    } *func;
};

#define ZSTREAM_FLAG_READY      0x1
#define ZSTREAM_FLAG_IN_STREAM  0x2
#define ZSTREAM_FLAG_FINISHED   0x4
#define ZSTREAM_FLAG_CLOSING    0x8
#define ZSTREAM_FLAG_UNUSED     0x10

#define ZSTREAM_READY(z)       ((z)-&gt;flags |= ZSTREAM_FLAG_READY)
#define ZSTREAM_IS_READY(z)    ((z)-&gt;flags &amp; ZSTREAM_FLAG_READY)
#define ZSTREAM_IS_FINISHED(z) ((z)-&gt;flags &amp; ZSTREAM_FLAG_FINISHED)
#define ZSTREAM_IS_CLOSING(z)  ((z)-&gt;flags &amp; ZSTREAM_FLAG_CLOSING)

/* I think that more better value should be found,
   but I gave up finding it. B) */
#define ZSTREAM_INITIAL_BUFSIZE       1024
#define ZSTREAM_AVAIL_OUT_STEP_MAX   16384
#define ZSTREAM_AVAIL_OUT_STEP_MIN    2048

static const struct zstream_funcs deflate_funcs = {
    deflateReset, deflateEnd, deflate,
};

static const struct zstream_funcs inflate_funcs = {
    inflateReset, inflateEnd, inflate,
};


static voidpf
zlib_mem_alloc(opaque, items, size)
    voidpf opaque;
    uInt items, size;
{
    return xmalloc(items * size);
}

static void
zlib_mem_free(opaque, address)
    voidpf opaque, address;
{
    free(address);
}

static void
zstream_init(z, func)
    struct zstream *z;
    const struct zstream_funcs *func;
{
    z-&gt;flags = 0;
    z-&gt;buf = Qnil;
    z-&gt;buf_filled = 0;
    z-&gt;input = Qnil;
    z-&gt;stream.zalloc = zlib_mem_alloc;
    z-&gt;stream.zfree = zlib_mem_free;
    z-&gt;stream.opaque = Z_NULL;
    z-&gt;stream.msg = Z_NULL;
    z-&gt;stream.next_in = Z_NULL;
    z-&gt;stream.avail_in = 0;
    z-&gt;stream.next_out = Z_NULL;
    z-&gt;stream.avail_out = 0;
    z-&gt;func = func;
}

#define zstream_init_deflate(z)   zstream_init((z), &amp;deflate_funcs)
#define zstream_init_inflate(z)   zstream_init((z), &amp;inflate_funcs)

static void
zstream_expand_buffer(z)
    struct zstream *z;
{
    long inc;

    if (NIL_P(z-&gt;buf)) {
	    /* I uses rb_str_new here not rb_str_buf_new because
	       rb_str_buf_new makes a zero-length string. */
	z-&gt;buf = rb_str_new(0, ZSTREAM_INITIAL_BUFSIZE);
	z-&gt;buf_filled = 0;
	z-&gt;stream.next_out = RSTRING(z-&gt;buf)-&gt;ptr;
	z-&gt;stream.avail_out = ZSTREAM_INITIAL_BUFSIZE;
	RBASIC(z-&gt;buf)-&gt;klass = 0;
	return;
    }

    if (RSTRING(z-&gt;buf)-&gt;len - z-&gt;buf_filled &gt;= ZSTREAM_AVAIL_OUT_STEP_MAX) {
	/* to keep other threads from freezing */
	z-&gt;stream.avail_out = ZSTREAM_AVAIL_OUT_STEP_MAX;
    }
    else {
	inc = z-&gt;buf_filled / 2;
	if (inc &lt; ZSTREAM_AVAIL_OUT_STEP_MIN) {
	    inc = ZSTREAM_AVAIL_OUT_STEP_MIN;
	}
	rb_str_resize(z-&gt;buf, z-&gt;buf_filled + inc);
	z-&gt;stream.avail_out = (inc &lt; ZSTREAM_AVAIL_OUT_STEP_MAX) ?
	    inc : ZSTREAM_AVAIL_OUT_STEP_MAX;
    }
    z-&gt;stream.next_out = RSTRING(z-&gt;buf)-&gt;ptr + z-&gt;buf_filled;
}

static void
zstream_expand_buffer_into(z, size)
    struct zstream *z;
    int size;
{
    if (NIL_P(z-&gt;buf)) {
	/* I uses rb_str_new here not rb_str_buf_new because
	   rb_str_buf_new makes a zero-length string. */
	z-&gt;buf = rb_str_new(0, size);
	z-&gt;buf_filled = 0;
	z-&gt;stream.next_out = RSTRING(z-&gt;buf)-&gt;ptr;
	z-&gt;stream.avail_out = size;
	RBASIC(z-&gt;buf)-&gt;klass = 0;
    }
    else if (z-&gt;stream.avail_out != size) {
	rb_str_resize(z-&gt;buf, z-&gt;buf_filled + size);
	z-&gt;stream.next_out = RSTRING(z-&gt;buf)-&gt;ptr + z-&gt;buf_filled;
	z-&gt;stream.avail_out = size;
    }
}

static void
zstream_append_buffer(z, src, len)
    struct zstream *z;
    const char *src;
    int len;
{
    if (NIL_P(z-&gt;buf)) {
	z-&gt;buf = rb_str_buf_new(len);
	rb_str_buf_cat(z-&gt;buf, src, len);
	z-&gt;buf_filled = len;
	z-&gt;stream.next_out = RSTRING(z-&gt;buf)-&gt;ptr;
	z-&gt;stream.avail_out = 0;
	RBASIC(z-&gt;buf)-&gt;klass = 0;
	return;
    }

    if (RSTRING(z-&gt;buf)-&gt;len &lt; z-&gt;buf_filled + len) {
	rb_str_resize(z-&gt;buf, z-&gt;buf_filled + len);
	z-&gt;stream.avail_out = 0;
    }
    else {
	if (z-&gt;stream.avail_out &gt;= len) {
	    z-&gt;stream.avail_out -= len;
	}
	else {
	    z-&gt;stream.avail_out = 0;
	}
    }
    memcpy(RSTRING(z-&gt;buf)-&gt;ptr + z-&gt;buf_filled, src, len);
    z-&gt;buf_filled += len;
    z-&gt;stream.next_out = RSTRING(z-&gt;buf)-&gt;ptr + z-&gt;buf_filled;
}

#define zstream_append_buffer2(z,v) \
    zstream_append_buffer((z),RSTRING(v)-&gt;ptr,RSTRING(v)-&gt;len)

static VALUE
zstream_detach_buffer(z)
    struct zstream *z;
{
    VALUE dst;

    if (NIL_P(z-&gt;buf)) {
	dst = rb_str_new(0, 0);
    }
    else {
	dst = z-&gt;buf;
	rb_str_resize(dst, z-&gt;buf_filled);
	RBASIC(dst)-&gt;klass = rb_cString;
    }

    z-&gt;buf = Qnil;
    z-&gt;buf_filled = 0;
    z-&gt;stream.next_out = 0;
    z-&gt;stream.avail_out = 0;
    return dst;
}

static VALUE
zstream_shift_buffer(z, len)
    struct zstream *z;
    int len;
{
    VALUE dst;

    if (z-&gt;buf_filled &lt;= len) {
	return zstream_detach_buffer(z);
    }

    dst = rb_str_substr(z-&gt;buf, 0, len);
    RBASIC(dst)-&gt;klass = rb_cString;
    z-&gt;buf_filled -= len;
    memmove(RSTRING(z-&gt;buf)-&gt;ptr, RSTRING(z-&gt;buf)-&gt;ptr + len,
	    z-&gt;buf_filled);
    z-&gt;stream.next_out = RSTRING(z-&gt;buf)-&gt;ptr + z-&gt;buf_filled;
    z-&gt;stream.avail_out = RSTRING(z-&gt;buf)-&gt;len - z-&gt;buf_filled;
    if (z-&gt;stream.avail_out &gt; ZSTREAM_AVAIL_OUT_STEP_MAX) {
	z-&gt;stream.avail_out = ZSTREAM_AVAIL_OUT_STEP_MAX;
    }

    return dst;
}

static void
zstream_buffer_ungetc(z, c)
    struct zstream *z;
    int c;
{
    if (NIL_P(z-&gt;buf) || RSTRING(z-&gt;buf)-&gt;len - z-&gt;buf_filled == 0) {
	zstream_expand_buffer(z);
    }

    memmove(RSTRING(z-&gt;buf)-&gt;ptr + 1, RSTRING(z-&gt;buf)-&gt;ptr, z-&gt;buf_filled);
    RSTRING(z-&gt;buf)-&gt;ptr[0] = (char)c;
    z-&gt;buf_filled++;
    if (z-&gt;stream.avail_out &gt; 0) {
	z-&gt;stream.next_out++;
	z-&gt;stream.avail_out--;
    }
}

static void
zstream_append_input(z, src, len)
    struct zstream *z;
    const char *src;
    unsigned int len;
{
    if (len &lt;= 0) return;

    if (NIL_P(z-&gt;input)) {
	z-&gt;input = rb_str_buf_new(len);
	rb_str_buf_cat(z-&gt;input, src, len);
	RBASIC(z-&gt;input)-&gt;klass = 0;
    }
    else {
	rb_str_buf_cat(z-&gt;input, src, len);
    }
}

#define zstream_append_input2(z,v)\
    zstream_append_input((z), RSTRING(v)-&gt;ptr, RSTRING(v)-&gt;len)

static void
zstream_discard_input(z, len)
    struct zstream *z;
    unsigned int len;
{
    if (NIL_P(z-&gt;input) || RSTRING(z-&gt;input)-&gt;len &lt;= len) {
	z-&gt;input = Qnil;
    }
    else {
	memmove(RSTRING(z-&gt;input)-&gt;ptr, RSTRING(z-&gt;input)-&gt;ptr + len,
		RSTRING(z-&gt;input)-&gt;len - len);
	rb_str_resize(z-&gt;input, RSTRING(z-&gt;input)-&gt;len - len);
    }
}

static void
zstream_reset_input(z)
    struct zstream *z;
{
    z-&gt;input = Qnil;
}

static void
zstream_passthrough_input(z)
    struct zstream *z;
{
    if (!NIL_P(z-&gt;input)) {
	zstream_append_buffer2(z, z-&gt;input);
	z-&gt;input = Qnil;
    }
}

static VALUE
zstream_detach_input(z)
    struct zstream *z;
{
    VALUE dst;

    if (NIL_P(z-&gt;input)) {
	dst = rb_str_new(0, 0);
    }
    else {
	dst = z-&gt;input;
	RBASIC(dst)-&gt;klass = rb_cString;
    }
    z-&gt;input = Qnil;
    return dst;
}

static void
zstream_reset(z)
    struct zstream *z;
{
    int err;

    err = z-&gt;func-&gt;reset(&amp;z-&gt;stream);
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }
    z-&gt;flags = ZSTREAM_FLAG_READY;
    z-&gt;buf = Qnil;
    z-&gt;buf_filled = 0;
    z-&gt;stream.next_out = 0;
    z-&gt;stream.avail_out = 0;
    zstream_reset_input(z);
}

static VALUE
zstream_end(z)
    struct zstream *z;
{
    int err;

    if (!ZSTREAM_IS_READY(z)) {
	rb_warning(&quot;attempt to close uninitialized zstream; ignored.&quot;);
	return Qnil;
    }
    if (z-&gt;flags &amp; ZSTREAM_FLAG_IN_STREAM) {
	rb_warning(&quot;attempt to close unfinished zstream; reset forced.&quot;);
	zstream_reset(z);
    }

    zstream_reset_input(z);
    err = z-&gt;func-&gt;end(&amp;z-&gt;stream);
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }
    z-&gt;flags = 0;
    return Qnil;
}

static void
zstream_run(z, src, len, flush)
    struct zstream *z;
    Bytef *src;
    uInt len;
    int flush;
{
    uInt n;
    int err;
    volatile VALUE guard;

    if (NIL_P(z-&gt;input) &amp;&amp; len == 0) {
	z-&gt;stream.next_in = &quot;&quot;;
	z-&gt;stream.avail_in = 0;
    }
    else {
	zstream_append_input(z, src, len);
	z-&gt;stream.next_in = RSTRING(z-&gt;input)-&gt;ptr;
	z-&gt;stream.avail_in = RSTRING(z-&gt;input)-&gt;len;
	/* keep reference to `z-&gt;input' so as not to be garbage collected
	   after zstream_reset_input() and prevent `z-&gt;stream.next_in'
	   from dangling. */
	guard = z-&gt;input;
    }

    if (z-&gt;stream.avail_out == 0) {
	zstream_expand_buffer(z);
    }

    for (;;) {
	n = z-&gt;stream.avail_out;
	err = z-&gt;func-&gt;run(&amp;z-&gt;stream, flush);
	z-&gt;buf_filled += n - z-&gt;stream.avail_out;
	rb_thread_schedule();

	if (err == Z_STREAM_END) {
	    z-&gt;flags &amp;= ~ZSTREAM_FLAG_IN_STREAM;
	    z-&gt;flags |= ZSTREAM_FLAG_FINISHED;
	    break;
	}
	if (err != Z_OK) {
	    if (flush != Z_FINISH &amp;&amp; err == Z_BUF_ERROR
		&amp;&amp; z-&gt;stream.avail_out &gt; 0) {
		z-&gt;flags |= ZSTREAM_FLAG_IN_STREAM;
		break;
	    }
	    zstream_reset_input(z);
	    if (z-&gt;stream.avail_in &gt; 0) {
		zstream_append_input(z, z-&gt;stream.next_in, z-&gt;stream.avail_in);
	    }
	    raise_zlib_error(err, z-&gt;stream.msg);
	}
	if (z-&gt;stream.avail_out &gt; 0) {
	    z-&gt;flags |= ZSTREAM_FLAG_IN_STREAM;
	    break;
	}
	zstream_expand_buffer(z);
    }

    zstream_reset_input(z);
    if (z-&gt;stream.avail_in &gt; 0) {
	zstream_append_input(z, z-&gt;stream.next_in, z-&gt;stream.avail_in);
        guard = Qnil; /* prevent tail call to make guard effective */
    }
}

static VALUE
zstream_sync(z, src, len)
    struct zstream *z;
    Bytef *src;
    uInt len;
{
    VALUE rest;
    int err;

    if (!NIL_P(z-&gt;input)) {
	z-&gt;stream.next_in = RSTRING(z-&gt;input)-&gt;ptr;
	z-&gt;stream.avail_in = RSTRING(z-&gt;input)-&gt;len;
	err = inflateSync(&amp;z-&gt;stream);
	if (err == Z_OK) {
	    zstream_discard_input(z,
				  RSTRING(z-&gt;input)-&gt;len - z-&gt;stream.avail_in);
	    zstream_append_input(z, src, len);
	    return Qtrue;
	}
	zstream_reset_input(z);
	if (err != Z_DATA_ERROR) {
	    rest = rb_str_new(z-&gt;stream.next_in, z-&gt;stream.avail_in);
	    raise_zlib_error(err, z-&gt;stream.msg);
	}
    }

    if (len &lt;= 0) return Qfalse;

    z-&gt;stream.next_in = src;
    z-&gt;stream.avail_in = len;
    err = inflateSync(&amp;z-&gt;stream);
    if (err == Z_OK) {
	zstream_append_input(z, z-&gt;stream.next_in, z-&gt;stream.avail_in);
	return Qtrue;
    }
    if (err != Z_DATA_ERROR) {
	rest = rb_str_new(z-&gt;stream.next_in, z-&gt;stream.avail_in);
	raise_zlib_error(err, z-&gt;stream.msg);
    }
    return Qfalse;
}

static void
zstream_mark(z)
    struct zstream *z;
{
    rb_gc_mark(z-&gt;buf);
    rb_gc_mark(z-&gt;input);
}

static void
zstream_finalize(z)
    struct zstream *z;
{
    int err = z-&gt;func-&gt;end(&amp;z-&gt;stream);
    if (err == Z_STREAM_ERROR)
	finalizer_warn(&quot;the stream state was inconsistent.&quot;);
    if (err == Z_DATA_ERROR)
	finalizer_warn(&quot;the stream was freed prematurely.&quot;);
}

static void
zstream_free(z)
    struct zstream *z;
{
    if (ZSTREAM_IS_READY(z)) {
	zstream_finalize(z);
    }
    free(z);
}

static VALUE
zstream_new(klass, funcs)
    VALUE klass;
    const struct zstream_funcs *funcs;
{
    VALUE obj;
    struct zstream *z;

    obj = Data_Make_Struct(klass, struct zstream,
			   zstream_mark, zstream_free, z);
    zstream_init(z, funcs);
    return obj;
}

#define zstream_deflate_new(klass)  zstream_new((klass), &amp;deflate_funcs)
#define zstream_inflate_new(klass)  zstream_new((klass), &amp;inflate_funcs)

static struct zstream *
get_zstream(obj)
    VALUE obj;
{
    struct zstream *z;

    Data_Get_Struct(obj, struct zstream, z);
    if (!ZSTREAM_IS_READY(z)) {
	rb_raise(cZError, &quot;stream is not ready&quot;);
    }
    return z;
}


/* ------------------------------------------------------------------------- */

/*
 * Document-class: Zlib::ZStream
 *
 * Zlib::ZStream is the abstract class for the stream which handles the
 * compressed data. The operations are defined in the subclasses:
 * Zlib::Deflate for compression, and Zlib::Inflate for decompression.
 *
 * An instance of Zlib::ZStream has one stream (struct zstream in the source)
 * and two variable-length buffers which associated to the input (next_in) of
 * the stream and the output (next_out) of the stream. In this document,
 * &quot;input buffer&quot; means the buffer for input, and &quot;output buffer&quot; means the
 * buffer for output.
 *
 * Data input into an instance of Zlib::ZStream are temporally stored into
 * the end of input buffer, and then data in input buffer are processed from
 * the beginning of the buffer until no more output from the stream is
 * produced (i.e. until avail_out &gt; 0 after processing).  During processing,
 * output buffer is allocated and expanded automatically to hold all output
 * data.
 *
 * Some particular instance methods consume the data in output buffer and
 * return them as a String.
 *
 * Here is an ascii art for describing above:
 *
 *    +================ an instance of Zlib::ZStream ================+
 *    ||                                                            ||
 *    ||     +--------+          +-------+          +--------+      ||
 *    ||  +--| output |&lt;---------|zstream|&lt;---------| input  |&lt;--+  ||
 *    ||  |  | buffer |  next_out+-------+next_in   | buffer |   |  ||
 *    ||  |  +--------+                             +--------+   |  ||
 *    ||  |                                                      |  ||
 *    +===|======================================================|===+
 *        |                                                      |
 *        v                                                      |
 *    &quot;output data&quot;                                         &quot;input data&quot;
 *
 * If an error occurs during processing input buffer, an exception which is a
 * subclass of Zlib::Error is raised.  At that time, both input and output
 * buffer keep their conditions at the time when the error occurs.
 *
 * == Method Catalogue
 *
 * Many of the methods in this class are fairly low-level and unlikely to be
 * of interest to users.  In fact, users are unlikely to use this class
 * directly; rather they will be interested in Zlib::Inflate and
 * Zlib::Deflate.
 *
 * The higher level methods are listed below.
 *
 * - #total_in
 * - #total_out
 * - #data_type
 * - #adler
 * - #reset
 * - #finish
 * - #finished?
 * - #close
 * - #closed?
 */

/*
 * Closes the stream. All operations on the closed stream will raise an
 * exception.
 */
static VALUE
rb_zstream_end(obj)
    VALUE obj;
{
    zstream_end(get_zstream(obj));
    return Qnil;
}

/*
 * Resets and initializes the stream. All data in both input and output buffer
 * are discarded.
 */
static VALUE
rb_zstream_reset(obj)
    VALUE obj;
{
    zstream_reset(get_zstream(obj));
    return Qnil;
}

/*
 * Finishes the stream and flushes output buffer. See Zlib::Deflate#finish and
 * Zlib::Inflate#finish for details of this behavior.
 */
static VALUE
rb_zstream_finish(obj)
    VALUE obj;
{
    struct zstream *z = get_zstream(obj);
    VALUE dst;

    zstream_run(z, &quot;&quot;, 0, Z_FINISH);
    dst = zstream_detach_buffer(z);

    OBJ_INFECT(dst, obj);
    return dst;
}

/*
 * Flushes input buffer and returns all data in that buffer.
 */
static VALUE
rb_zstream_flush_next_in(obj)
    VALUE obj;
{
    struct zstream *z;
    VALUE dst;

    Data_Get_Struct(obj, struct zstream, z);
    dst = zstream_detach_input(z);
    OBJ_INFECT(dst, obj);
    return dst;
}

/*
 * Flushes output buffer and returns all data in that buffer.
 */
static VALUE
rb_zstream_flush_next_out(obj)
    VALUE obj;
{
    struct zstream *z;
    VALUE dst;

    Data_Get_Struct(obj, struct zstream, z);
    dst = zstream_detach_buffer(z);
    OBJ_INFECT(dst, obj);
    return dst;
}

/*
 * Returns number of bytes of free spaces in output buffer.  Because the free
 * space is allocated automatically, this method returns 0 normally.
 */
static VALUE
rb_zstream_avail_out(obj)
    VALUE obj;
{
    struct zstream *z;
    Data_Get_Struct(obj, struct zstream, z);
    return rb_uint2inum(z-&gt;stream.avail_out);
}

/*
 * Allocates +size+ bytes of free space in the output buffer. If there are more
 * than +size+ bytes already in the buffer, the buffer is truncated. Because 
 * free space is allocated automatically, you usually don't need to use this
 * method.
 */
static VALUE
rb_zstream_set_avail_out(obj, size)
    VALUE obj, size;
{
    struct zstream *z = get_zstream(obj);

    Check_Type(size, T_FIXNUM);
    zstream_expand_buffer_into(z, FIX2INT(size));
    return size;
}

/*
 * Returns bytes of data in the input buffer. Normally, returns 0.
 */
static VALUE
rb_zstream_avail_in(obj)
    VALUE obj;
{
    struct zstream *z;
    Data_Get_Struct(obj, struct zstream, z);
    return INT2FIX(NIL_P(z-&gt;input) ? 0 : (int)(RSTRING(z-&gt;input)-&gt;len));
}

/*
 * Returns the total bytes of the input data to the stream.  FIXME
 */
static VALUE
rb_zstream_total_in(obj)
    VALUE obj;
{
    return rb_uint2inum(get_zstream(obj)-&gt;stream.total_in);
}

/*
 * Returns the total bytes of the output data from the stream.  FIXME
 */
static VALUE
rb_zstream_total_out(obj)
    VALUE obj;
{
    return rb_uint2inum(get_zstream(obj)-&gt;stream.total_out);
}

/*
 * Guesses the type of the data which have been inputed into the stream. The
 * returned value is either &lt;tt&gt;Zlib::BINARY&lt;/tt&gt;, &lt;tt&gt;Zlib::ASCII&lt;/tt&gt;, or
 * &lt;tt&gt;Zlib::UNKNOWN&lt;/tt&gt;.
 */
static VALUE
rb_zstream_data_type(obj)
    VALUE obj;
{
    return INT2FIX(get_zstream(obj)-&gt;stream.data_type);
}

/*
 * Returns the adler-32 checksum.
 */
static VALUE
rb_zstream_adler(obj)
    VALUE obj;
{
	return rb_uint2inum(get_zstream(obj)-&gt;stream.adler);
}

/*
 * Returns true if the stream is finished.
 */
static VALUE
rb_zstream_finished_p(obj)
    VALUE obj;
{
    return ZSTREAM_IS_FINISHED(get_zstream(obj)) ? Qtrue : Qfalse;
}

/*
 * Returns true if the stream is closed.
 */
static VALUE
rb_zstream_closed_p(obj)
    VALUE obj;
{
    struct zstream *z;
    Data_Get_Struct(obj, struct zstream, z);
    return ZSTREAM_IS_READY(z) ? Qfalse : Qtrue;
}


/* ------------------------------------------------------------------------- */

/*
 * Document-class: Zlib::Deflate
 *
 * Zlib::Deflate is the class for compressing data.  See Zlib::Stream for more
 * information.
 */

#define FIXNUMARG(val, ifnil) \
    (NIL_P((val)) ? (ifnil) \
    : ((void)Check_Type((val), T_FIXNUM), FIX2INT((val))))

#define ARG_LEVEL(val)     FIXNUMARG((val), Z_DEFAULT_COMPRESSION)
#define ARG_WBITS(val)     FIXNUMARG((val), MAX_WBITS)
#define ARG_MEMLEVEL(val)  FIXNUMARG((val), DEF_MEM_LEVEL)
#define ARG_STRATEGY(val)  FIXNUMARG((val), Z_DEFAULT_STRATEGY)
#define ARG_FLUSH(val)     FIXNUMARG((val), Z_NO_FLUSH)


static VALUE
rb_deflate_s_allocate(klass)
    VALUE klass;
{
    return zstream_deflate_new(klass);
}

/*
 * call-seq: Zlib::Deflate.new(level=nil, windowBits=nil, memlevel=nil, strategy=nil)
 *
 * Creates a new deflate stream for compression. See zlib.h for details of
 * each argument. If an argument is nil, the default value of that argument is
 * used.
 *
 * TODO: document better!
 */
static VALUE
rb_deflate_initialize(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct zstream *z;
    VALUE level, wbits, memlevel, strategy;
    int err;

    rb_scan_args(argc, argv, &quot;04&quot;, &amp;level, &amp;wbits, &amp;memlevel, &amp;strategy);
    Data_Get_Struct(obj, struct zstream, z);

    err = deflateInit2(&amp;z-&gt;stream, ARG_LEVEL(level), Z_DEFLATED,
		       ARG_WBITS(wbits), ARG_MEMLEVEL(memlevel),
		       ARG_STRATEGY(strategy));
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }
    ZSTREAM_READY(z);

    return obj;
}

/*
 * Duplicates the deflate stream.
 */
static VALUE
rb_deflate_init_copy(self, orig)
    VALUE self, orig;
{
    struct zstream *z1, *z2;
    int err;

    Data_Get_Struct(self, struct zstream, z1);
    z2 = get_zstream(orig);

    err = deflateCopy(&amp;z1-&gt;stream, &amp;z2-&gt;stream);
    if (err != Z_OK) {
	raise_zlib_error(err, 0);
    }
    z1-&gt;input = NIL_P(z2-&gt;input) ? Qnil : rb_str_dup(z2-&gt;input);
    z1-&gt;buf   = NIL_P(z2-&gt;buf)   ? Qnil : rb_str_dup(z2-&gt;buf);
    z1-&gt;buf_filled = z2-&gt;buf_filled;
    z1-&gt;flags = z2-&gt;flags;

    return self;
}

static VALUE
deflate_run(args)
    VALUE args;
{
    struct zstream *z = (struct zstream *)((VALUE *)args)[0];
    VALUE src = ((VALUE *)args)[1];

    zstream_run(z, RSTRING(src)-&gt;ptr, RSTRING(src)-&gt;len, Z_FINISH);
    return zstream_detach_buffer(z);
}

/*
 * call-seq: Zlib::Deflate.deflate(string[, level])
 *
 * Compresses the given +string+. Valid values of level are
 * &lt;tt&gt;Zlib::NO_COMPRESSION&lt;/tt&gt;, &lt;tt&gt;Zlib::BEST_SPEED&lt;/tt&gt;,
 * &lt;tt&gt;Zlib::BEST_COMPRESSION&lt;/tt&gt;, &lt;tt&gt;Zlib::DEFAULT_COMPRESSION&lt;/tt&gt;, and an
 * integer from 0 to 9.
 *
 * This method is almost equivalent to the following code:
 *
 *   def deflate(string, level)
 *     z = Zlib::Deflate.new(level)
 *     dst = z.deflate(string, Zlib::FINISH)
 *     z.close
 *     dst
 *   end
 *
 * TODO: what's default value of +level+?
 *
 */
static VALUE
rb_deflate_s_deflate(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    struct zstream z;
    VALUE src, level, dst, args[2];
    int err, lev;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;src, &amp;level);

    lev = ARG_LEVEL(level);
    StringValue(src);
    zstream_init_deflate(&amp;z);
    err = deflateInit(&amp;z.stream, lev);
    if (err != Z_OK) {
	raise_zlib_error(err, z.stream.msg);
    }
    ZSTREAM_READY(&amp;z);

    args[0] = (VALUE)&amp;z;
    args[1] = src;
    dst = rb_ensure(deflate_run, (VALUE)args, zstream_end, (VALUE)&amp;z);

    OBJ_INFECT(dst, src);
    return dst;
}

static void
do_deflate(z, src, flush)
    struct zstream *z;
    VALUE src;
    int flush;
{
    if (NIL_P(src)) {
	zstream_run(z, &quot;&quot;, 0, Z_FINISH);
	return;
    }
    StringValue(src);
    if (flush != Z_NO_FLUSH || RSTRING(src)-&gt;len &gt; 0) { /* prevent BUF_ERROR */
	zstream_run(z, RSTRING(src)-&gt;ptr, RSTRING(src)-&gt;len, flush);
    }
}

/*
 * call-seq: deflate(string[, flush])
 *
 * Inputs +string+ into the deflate stream and returns the output from the
 * stream.  On calling this method, both the input and the output buffers of
 * the stream are flushed. If +string+ is nil, this method finishes the
 * stream, just like Zlib::ZStream#finish.
 *
 * The value of +flush+ should be either &lt;tt&gt;Zlib::NO_FLUSH&lt;/tt&gt;,
 * &lt;tt&gt;Zlib::SYNC_FLUSH&lt;/tt&gt;, &lt;tt&gt;Zlib::FULL_FLUSH&lt;/tt&gt;, or
 * &lt;tt&gt;Zlib::FINISH&lt;/tt&gt;. See zlib.h for details.
 *
 * TODO: document better!
 */
static VALUE
rb_deflate_deflate(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct zstream *z = get_zstream(obj);
    VALUE src, flush, dst;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;src, &amp;flush);
    OBJ_INFECT(obj, src);
    do_deflate(z, src, ARG_FLUSH(flush));
    dst = zstream_detach_buffer(z);

    OBJ_INFECT(dst, obj);
    return dst;
}

/*
 * call-seq: &lt;&lt; string
 *
 * Inputs +string+ into the deflate stream just like Zlib::Deflate#deflate, but
 * returns the Zlib::Deflate object itself.  The output from the stream is
 * preserved in output buffer.
 */
static VALUE
rb_deflate_addstr(obj, src)
    VALUE obj, src;
{
    OBJ_INFECT(obj, src);
    do_deflate(get_zstream(obj), src, Z_NO_FLUSH);
    return obj;
}

/*
 * call-seq: flush(flush)
 *
 * This method is equivalent to &lt;tt&gt;deflate('', flush)&lt;/tt&gt;.  If flush is omitted,
 * &lt;tt&gt;Zlib::SYNC_FLUSH&lt;/tt&gt; is used as flush.  This method is just provided
 * to improve the readability of your Ruby program.
 *
 * TODO: document better!
 */
static VALUE
rb_deflate_flush(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct zstream *z = get_zstream(obj);
    VALUE v_flush, dst;
    int flush;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;v_flush);
    flush = FIXNUMARG(v_flush, Z_SYNC_FLUSH);
    if (flush != Z_NO_FLUSH) {  /* prevent Z_BUF_ERROR */
	zstream_run(z, &quot;&quot;, 0, flush);
    }
    dst = zstream_detach_buffer(z);

    OBJ_INFECT(dst, obj);
    return dst;
}

/*
 * call-seq: params(level, strategy)
 * 
 * Changes the parameters of the deflate stream. See zlib.h for details. The
 * output from the stream by changing the params is preserved in output
 * buffer.
 *
 * TODO: document better!
 */
static VALUE
rb_deflate_params(obj, v_level, v_strategy)
    VALUE obj, v_level, v_strategy;
{
    struct zstream *z = get_zstream(obj);
    int level, strategy;
    int err;

    level = ARG_LEVEL(v_level);
    strategy = ARG_STRATEGY(v_strategy);

    err = deflateParams(&amp;z-&gt;stream, level, strategy);
    while (err == Z_BUF_ERROR) {
	rb_warning(&quot;deflateParams() returned Z_BUF_ERROR&quot;);
	zstream_expand_buffer(z);
	err = deflateParams(&amp;z-&gt;stream, level, strategy);
    }
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }

    return Qnil;
}

/*
 * call-seq: set_dictionary(string)
 *
 * Sets the preset dictionary and returns +string+. This method is available
 * just only after Zlib::Deflate.new or Zlib::ZStream#reset method was called.
 * See zlib.h for details.
 *
 * TODO: document better!
 */
static VALUE
rb_deflate_set_dictionary(obj, dic)
    VALUE obj, dic;
{
    struct zstream *z = get_zstream(obj);
    VALUE src = dic;
    int err;

    OBJ_INFECT(obj, dic);
    StringValue(src);
    err = deflateSetDictionary(&amp;z-&gt;stream,
			       RSTRING(src)-&gt;ptr, RSTRING(src)-&gt;len);
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }

    return dic;
}


/* ------------------------------------------------------------------------- */

/*
 * Document-class: Zlib::Inflate
 *
 * Zlib:Inflate is the class for decompressing compressed data.  Unlike
 * Zlib::Deflate, an instance of this class is not able to duplicate (clone,
 * dup) itself.
 */



static VALUE
rb_inflate_s_allocate(klass)
    VALUE klass;
{
    return zstream_inflate_new(klass);
}

/*
 * call-seq: Zlib::Inflate.new(window_bits)
 *
 * Creates a new inflate stream for decompression. See zlib.h for details
 * of the argument.  If +window_bits+ is +nil+, the default value is used.
 *
 * TODO: document better!
 */
static VALUE
rb_inflate_initialize(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct zstream *z;
    VALUE wbits;
    int err;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;wbits);
    Data_Get_Struct(obj, struct zstream, z);

    err = inflateInit2(&amp;z-&gt;stream, ARG_WBITS(wbits));
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }
    ZSTREAM_READY(z);

    return obj;
}

static VALUE
inflate_run(args)
    VALUE args;
{
    struct zstream *z = (struct zstream *)((VALUE *)args)[0];
    VALUE src = ((VALUE *)args)[1];

    zstream_run(z, RSTRING(src)-&gt;ptr, RSTRING(src)-&gt;len, Z_SYNC_FLUSH);
    zstream_run(z, &quot;&quot;, 0, Z_FINISH);  /* for checking errors */
    return zstream_detach_buffer(z);
}

/*
 * call-seq: Zlib::Inflate.inflate(string)
 *
 * Decompresses +string+. Raises a Zlib::NeedDict exception if a preset
 * dictionary is needed for decompression.
 *
 * This method is almost equivalent to the following code:
 *
 *   def inflate(string)
 *     zstream = Zlib::Inflate.new
 *     buf = zstream.inflate(string)
 *     zstream.finish
 *     zstream.close
 *     buf
 *   end
 *
 */
static VALUE
rb_inflate_s_inflate(obj, src)
    VALUE obj, src;
{
    struct zstream z;
    VALUE dst, args[2];
    int err;

    StringValue(src);
    zstream_init_inflate(&amp;z);
    err = inflateInit(&amp;z.stream);
    if (err != Z_OK) {
	raise_zlib_error(err, z.stream.msg);
    }
    ZSTREAM_READY(&amp;z);

    args[0] = (VALUE)&amp;z;
    args[1] = src;
    dst = rb_ensure(inflate_run, (VALUE)args, zstream_end, (VALUE)&amp;z);

    OBJ_INFECT(dst, src);
    return dst;
}

static void
do_inflate(z, src)
    struct zstream *z;
    VALUE src;
{
    if (NIL_P(src)) {
	zstream_run(z, &quot;&quot;, 0, Z_FINISH);
	return;
    }
    StringValue(src);
    if (RSTRING(src)-&gt;len &gt; 0) { /* prevent Z_BUF_ERROR */
	zstream_run(z, RSTRING(src)-&gt;ptr, RSTRING(src)-&gt;len, Z_SYNC_FLUSH);
    }
}

/*
 * call-seq: inflate(string)
 *
 * Inputs +string+ into the inflate stream and returns the output from the
 * stream.  Calling this method, both the input and the output buffer of the
 * stream are flushed.  If string is +nil+, this method finishes the stream,
 * just like Zlib::ZStream#finish.
 *
 * Raises a Zlib::NeedDict exception if a preset dictionary is needed to
 * decompress.  Set the dictionary by Zlib::Inflate#set_dictionary and then
 * call this method again with an empty string.  (&lt;i&gt;???&lt;/i&gt;)
 *
 * TODO: document better!
 */
static VALUE
rb_inflate_inflate(obj, src)
    VALUE obj, src;
{
    struct zstream *z = get_zstream(obj);
    VALUE dst;

    OBJ_INFECT(obj, src);

    if (ZSTREAM_IS_FINISHED(z)) {
	if (NIL_P(src)) {
	    dst = zstream_detach_buffer(z);
	}
	else {
	    StringValue(src);
	    zstream_append_buffer2(z, src);
	    dst = rb_str_new(0, 0);
	}
    }
    else {
	do_inflate(z, src);
	dst = zstream_detach_buffer(z);
	if (ZSTREAM_IS_FINISHED(z)) {
	    zstream_passthrough_input(z);
	}
    }

    OBJ_INFECT(dst, obj);
    return dst;
}

/*
 * call-seq: &lt;&lt; string
 *
 * Inputs +string+ into the inflate stream just like Zlib::Inflate#inflate, but
 * returns the Zlib::Inflate object itself.  The output from the stream is
 * preserved in output buffer.
 */
static VALUE
rb_inflate_addstr(obj, src)
    VALUE obj, src;
{
    struct zstream *z = get_zstream(obj);

    OBJ_INFECT(obj, src);

    if (ZSTREAM_IS_FINISHED(z)) {
	if (!NIL_P(src)) {
	    StringValue(src);
	    zstream_append_buffer2(z, src);
	}
    }
    else {
	do_inflate(z, src);
	if (ZSTREAM_IS_FINISHED(z)) {
	    zstream_passthrough_input(z);
	}
    }

    return obj;
}

/*
 * call-seq: sync(string)
 *
 * Inputs +string+ into the end of input buffer and skips data until a full
 * flush point can be found.  If the point is found in the buffer, this method
 * flushes the buffer and returns false.  Otherwise it returns +true+ and the
 * following data of full flush point is preserved in the buffer.
 */
static VALUE
rb_inflate_sync(obj, src)
    VALUE obj, src;
{
    struct zstream *z = get_zstream(obj);

    OBJ_INFECT(obj, src);
    StringValue(src);
    return zstream_sync(z, RSTRING(src)-&gt;ptr, RSTRING(src)-&gt;len);
}

/*
 * Quoted verbatim from original documentation:
 *
 *   What is this?
 *
 * &lt;tt&gt;:)&lt;/tt&gt;
 */
static VALUE
rb_inflate_sync_point_p(obj)
    VALUE obj;
{
    struct zstream *z = get_zstream(obj);
    int err;

    err = inflateSyncPoint(&amp;z-&gt;stream);
    if (err == 1) {
	return Qtrue;
    }
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }
    return Qfalse;
}

/*
 * Sets the preset dictionary and returns +string+.  This method is available just
 * only after a Zlib::NeedDict exception was raised.  See zlib.h for details.
 *
 * TODO: document better!
 */
static VALUE
rb_inflate_set_dictionary(obj, dic)
    VALUE obj, dic;
{
    struct zstream *z = get_zstream(obj);
    VALUE src = dic;
    int err;

    OBJ_INFECT(obj, dic);
    StringValue(src);
    err = inflateSetDictionary(&amp;z-&gt;stream,
			       RSTRING(src)-&gt;ptr, RSTRING(src)-&gt;len);
    if (err != Z_OK) {
	raise_zlib_error(err, z-&gt;stream.msg);
    }

    return dic;
}



#if GZIP_SUPPORT

/* NOTE: Features for gzip files of Ruby/zlib are written from scratch
 *       and using undocumented feature of zlib, negative wbits.
 *       I don't think gzFile APIs of zlib are good for Ruby.
 */

/*------- .gz file header --------*/

#define GZ_MAGIC1             0x1f
#define GZ_MAGIC2             0x8b
#define GZ_METHOD_DEFLATE     8
#define GZ_FLAG_MULTIPART     0x2
#define GZ_FLAG_EXTRA         0x4
#define GZ_FLAG_ORIG_NAME     0x8
#define GZ_FLAG_COMMENT       0x10
#define GZ_FLAG_ENCRYPT       0x20
#define GZ_FLAG_UNKNOWN_MASK  0xc0

#define GZ_EXTRAFLAG_FAST     0x4
#define GZ_EXTRAFLAG_SLOW     0x2

/* from zutil.h */
#define OS_MSDOS    0x00
#define OS_AMIGA    0x01
#define OS_VMS      0x02
#define OS_UNIX     0x03
#define OS_ATARI    0x05
#define OS_OS2      0x06
#define OS_MACOS    0x07
#define OS_TOPS20   0x0a
#define OS_WIN32    0x0b

#define OS_VMCMS    0x04
#define OS_ZSYSTEM  0x08
#define OS_CPM      0x09
#define OS_QDOS     0x0c
#define OS_RISCOS   0x0d
#define OS_UNKNOWN  0xff

#ifndef OS_CODE
#define OS_CODE  OS_UNIX
#endif

static ID id_write, id_read, id_flush, id_seek, id_close;
static VALUE cGzError, cNoFooter, cCRCError, cLengthError;



/*-------- gzfile internal APIs --------*/

struct gzfile {
    struct zstream z;
    VALUE io;
    int level;
    time_t mtime;       /* for header */
    int os_code;        /* for header */
    VALUE orig_name;    /* for header; must be a String */
    VALUE comment;      /* for header; must be a String */
    unsigned long crc;
    int lineno;
    int ungetc;
    void (*end)(struct gzfile *);
};

#define GZFILE_FLAG_SYNC             ZSTREAM_FLAG_UNUSED
#define GZFILE_FLAG_HEADER_FINISHED  (ZSTREAM_FLAG_UNUSED &lt;&lt; 1)
#define GZFILE_FLAG_FOOTER_FINISHED  (ZSTREAM_FLAG_UNUSED &lt;&lt; 2)

#define GZFILE_IS_FINISHED(gz) \
    (ZSTREAM_IS_FINISHED(&amp;gz-&gt;z) &amp;&amp; (gz)-&gt;z.buf_filled == 0)

#define GZFILE_READ_SIZE  2048


static void
gzfile_mark(gz)
    struct gzfile *gz;
{
    rb_gc_mark(gz-&gt;io);
    rb_gc_mark(gz-&gt;orig_name);
    rb_gc_mark(gz-&gt;comment);
    zstream_mark(&amp;gz-&gt;z);
}

static void
gzfile_free(gz)
    struct gzfile *gz;
{
    struct zstream *z = &amp;gz-&gt;z;

    if (ZSTREAM_IS_READY(z)) {
	if (z-&gt;func == &amp;deflate_funcs) {
	    finalizer_warn(&quot;Zlib::GzipWriter object must be closed explicitly.&quot;);
	}
	zstream_finalize(z);
    }
    free(gz);
}

static VALUE
gzfile_new(klass, funcs, endfunc)
    VALUE klass;
    const struct zstream_funcs *funcs;
    void (*endfunc) _((struct gzfile *));
{
    VALUE obj;
    struct gzfile *gz;

    obj = Data_Make_Struct(klass, struct gzfile, gzfile_mark, gzfile_free, gz);
    zstream_init(&amp;gz-&gt;z, funcs);
    gz-&gt;io = Qnil;
    gz-&gt;level = 0;
    gz-&gt;mtime = 0;
    gz-&gt;os_code = OS_CODE;
    gz-&gt;orig_name = Qnil;
    gz-&gt;comment = Qnil;
    gz-&gt;crc = crc32(0, Z_NULL, 0);
    gz-&gt;lineno = 0;
    gz-&gt;ungetc = 0;
    gz-&gt;end = endfunc;

    return obj;
}

#define gzfile_writer_new(gz) gzfile_new((gz),&amp;deflate_funcs,gzfile_writer_end)
#define gzfile_reader_new(gz) gzfile_new((gz),&amp;inflate_funcs,gzfile_reader_end)

static void
gzfile_reset(gz)
    struct gzfile *gz;
{
    zstream_reset(&amp;gz-&gt;z);
    gz-&gt;crc = crc32(0, Z_NULL, 0);
    gz-&gt;lineno = 0;
    gz-&gt;ungetc = 0;
}

static void
gzfile_close(gz, closeflag)
    struct gzfile *gz;
    int closeflag;
{
    VALUE io = gz-&gt;io;

    gz-&gt;end(gz);
    gz-&gt;io = Qnil;
    gz-&gt;orig_name = Qnil;
    gz-&gt;comment = Qnil;
    if (closeflag &amp;&amp; rb_respond_to(io, id_close)) {
	rb_funcall(io, id_close, 0);
    }
}

static void
gzfile_write_raw(gz)
    struct gzfile *gz;
{
    VALUE str;

    if (gz-&gt;z.buf_filled &gt; 0) {
	str = zstream_detach_buffer(&amp;gz-&gt;z);
	OBJ_TAINT(str);  /* for safe */
	rb_funcall(gz-&gt;io, id_write, 1, str);
	if ((gz-&gt;z.flags &amp; GZFILE_FLAG_SYNC)
	    &amp;&amp; rb_respond_to(gz-&gt;io, id_flush))
	    rb_funcall(gz-&gt;io, id_flush, 0);
    }
}

static VALUE
gzfile_read_raw(gz)
    struct gzfile *gz;
{
    VALUE str;

    str = rb_funcall(gz-&gt;io, id_read, 1, INT2FIX(GZFILE_READ_SIZE));
    if (!NIL_P(str)) {
	Check_Type(str, T_STRING);
    }
    return str;
}

static int
gzfile_read_raw_ensure(gz, size)
    struct gzfile *gz;
    int size;
{
    VALUE str;

    while (NIL_P(gz-&gt;z.input) || RSTRING(gz-&gt;z.input)-&gt;len &lt; size) {
	str = gzfile_read_raw(gz);
	if (NIL_P(str)) return Qfalse;
	zstream_append_input2(&amp;gz-&gt;z, str);
    }
    return Qtrue;
}

static char *
gzfile_read_raw_until_zero(gz, offset)
    struct gzfile *gz;
    long offset;
{
    VALUE str;
    char *p;

    for (;;) {
	p = memchr(RSTRING(gz-&gt;z.input)-&gt;ptr + offset, '\0',
		   RSTRING(gz-&gt;z.input)-&gt;len - offset);
	if (p) break;
	str = gzfile_read_raw(gz);
	if (NIL_P(str)) {
	    rb_raise(cGzError, &quot;unexpected end of file&quot;);
	}
	offset = RSTRING(gz-&gt;z.input)-&gt;len;
	zstream_append_input2(&amp;gz-&gt;z, str);
    }
    return p;
}

static unsigned int
gzfile_get16(src)
    const unsigned char *src;
{
    unsigned int n;
    n  = *(src++) &amp; 0xff;
    n |= (*(src++) &amp; 0xff) &lt;&lt; 8;
    return n;
}

static unsigned long
gzfile_get32(src)
    const unsigned char *src;
{
    unsigned long n;
    n  = *(src++) &amp; 0xff;
    n |= (*(src++) &amp; 0xff) &lt;&lt; 8;
    n |= (*(src++) &amp; 0xff) &lt;&lt; 16;
    n |= (*(src++) &amp; 0xffU) &lt;&lt; 24;
    return n;
}

static void
gzfile_set32(n, dst)
    unsigned long n;
    unsigned char *dst;
{
    *(dst++) = n &amp; 0xff;
    *(dst++) = (n &gt;&gt; 8) &amp; 0xff;
    *(dst++) = (n &gt;&gt; 16) &amp; 0xff;
    *dst     = (n &gt;&gt; 24) &amp; 0xff;
}

static void
gzfile_make_header(gz)
    struct gzfile *gz;
{
    unsigned char buf[10];  /* the size of gzip header */
    unsigned char flags = 0, extraflags = 0;

    if (!NIL_P(gz-&gt;orig_name)) {
	flags |= GZ_FLAG_ORIG_NAME;
    }
    if (!NIL_P(gz-&gt;comment)) {
	flags |= GZ_FLAG_COMMENT;
    }
    if (gz-&gt;mtime == 0) {
	gz-&gt;mtime = time(0);
    }

    if (gz-&gt;level == Z_BEST_SPEED) {
	extraflags |= GZ_EXTRAFLAG_FAST;
    }
    else if (gz-&gt;level == Z_BEST_COMPRESSION) {
	extraflags |= GZ_EXTRAFLAG_SLOW;
    }

    buf[0] = GZ_MAGIC1;
    buf[1] = GZ_MAGIC2;
    buf[2] = GZ_METHOD_DEFLATE;
    buf[3] = flags;
    gzfile_set32(gz-&gt;mtime, &amp;buf[4]);
    buf[8] = extraflags;
    buf[9] = gz-&gt;os_code;
    zstream_append_buffer(&amp;gz-&gt;z, buf, sizeof(buf));

    if (!NIL_P(gz-&gt;orig_name)) {
	zstream_append_buffer2(&amp;gz-&gt;z, gz-&gt;orig_name);
	zstream_append_buffer(&amp;gz-&gt;z, &quot;\0&quot;, 1);
    }
    if (!NIL_P(gz-&gt;comment)) {
	zstream_append_buffer2(&amp;gz-&gt;z, gz-&gt;comment);
	zstream_append_buffer(&amp;gz-&gt;z, &quot;\0&quot;, 1);
    }

    gz-&gt;z.flags |= GZFILE_FLAG_HEADER_FINISHED;
}

static void
gzfile_make_footer(gz)
    struct gzfile *gz;
{
    unsigned char buf[8];  /* 8 is the size of gzip footer */

    gzfile_set32(gz-&gt;crc, buf);
    gzfile_set32(gz-&gt;z.stream.total_in, &amp;buf[4]);
    zstream_append_buffer(&amp;gz-&gt;z, buf, sizeof(buf));
    gz-&gt;z.flags |= GZFILE_FLAG_FOOTER_FINISHED;
}

static void
gzfile_read_header(gz)
    struct gzfile *gz;
{
    const unsigned char *head;
    long len;
    char flags, *p;

    if (!gzfile_read_raw_ensure(gz, 10)) {  /* 10 is the size of gzip header */
	rb_raise(cGzError, &quot;not in gzip format&quot;);
    }

    head = RSTRING(gz-&gt;z.input)-&gt;ptr;

    if (head[0] != GZ_MAGIC1 || head[1] != GZ_MAGIC2) {
	rb_raise(cGzError, &quot;not in gzip format&quot;);
    }
    if (head[2] != GZ_METHOD_DEFLATE) {
	rb_raise(cGzError, &quot;unsupported compression method %d&quot;, head[2]);
    }

    flags = head[3];
    if (flags &amp; GZ_FLAG_MULTIPART) {
	rb_raise(cGzError, &quot;multi-part gzip file is not supported&quot;);
    }
    else if (flags &amp; GZ_FLAG_ENCRYPT) {
	rb_raise(cGzError, &quot;encrypted gzip file is not supported&quot;);
    }
    else if (flags &amp; GZ_FLAG_UNKNOWN_MASK) {
	rb_raise(cGzError, &quot;unknown flags 0x%02x&quot;, flags);
    }

    if (head[8] &amp; GZ_EXTRAFLAG_FAST) {
	gz-&gt;level = Z_BEST_SPEED;
    }
    else if (head[8] &amp; GZ_EXTRAFLAG_SLOW) {
	gz-&gt;level = Z_BEST_COMPRESSION;
    }
    else {
	gz-&gt;level = Z_DEFAULT_COMPRESSION;
    }

    gz-&gt;mtime = gzfile_get32(&amp;head[4]);
    gz-&gt;os_code = head[9];
    zstream_discard_input(&amp;gz-&gt;z, 10);

    if (flags &amp; GZ_FLAG_EXTRA) {
	if (!gzfile_read_raw_ensure(gz, 2)) {
	    rb_raise(cGzError, &quot;unexpected end of file&quot;);
	}
	len = gzfile_get16(RSTRING(gz-&gt;z.input)-&gt;ptr);
	if (!gzfile_read_raw_ensure(gz, 2 + len)) {
	    rb_raise(cGzError, &quot;unexpected end of file&quot;);
	}
	zstream_discard_input(&amp;gz-&gt;z, 2 + len);
    }
    if (flags &amp; GZ_FLAG_ORIG_NAME) {
	p = gzfile_read_raw_until_zero(gz, 0);
	len = p - RSTRING(gz-&gt;z.input)-&gt;ptr;
	gz-&gt;orig_name = rb_str_new(RSTRING(gz-&gt;z.input)-&gt;ptr, len);
	OBJ_TAINT(gz-&gt;orig_name);  /* for safe */
	zstream_discard_input(&amp;gz-&gt;z, len + 1);
    }
    if (flags &amp; GZ_FLAG_COMMENT) {
	p = gzfile_read_raw_until_zero(gz, 0);
	len = p - RSTRING(gz-&gt;z.input)-&gt;ptr;
	gz-&gt;comment = rb_str_new(RSTRING(gz-&gt;z.input)-&gt;ptr, len);
	OBJ_TAINT(gz-&gt;comment);  /* for safe */
	zstream_discard_input(&amp;gz-&gt;z, len + 1);
    }

    if (gz-&gt;z.input != Qnil &amp;&amp; RSTRING(gz-&gt;z.input)-&gt;len &gt; 0) {
	zstream_run(&amp;gz-&gt;z, 0, 0, Z_SYNC_FLUSH);
    }
}

static void
gzfile_check_footer(gz)
    struct gzfile *gz;
{
    unsigned long crc, length;

    gz-&gt;z.flags |= GZFILE_FLAG_FOOTER_FINISHED;

    if (!gzfile_read_raw_ensure(gz, 8)) { /* 8 is the size of gzip footer */
	rb_raise(cNoFooter, &quot;footer is not found&quot;);
    }

    crc = gzfile_get32(RSTRING(gz-&gt;z.input)-&gt;ptr);
    length = gzfile_get32(RSTRING(gz-&gt;z.input)-&gt;ptr + 4);

    gz-&gt;z.stream.total_in += 8;  /* to rewind correctly */
    zstream_discard_input(&amp;gz-&gt;z, 8);

    if (gz-&gt;crc != crc) {
	rb_raise(cCRCError, &quot;invalid compressed data -- crc error&quot;);
    }
    if (gz-&gt;z.stream.total_out != length) {
	rb_raise(cLengthError, &quot;invalid compressed data -- length error&quot;);
    }
}

static void
gzfile_write(gz, str, len)
    struct gzfile *gz;
    Bytef *str;
    uInt len;
{
    if (!(gz-&gt;z.flags &amp; GZFILE_FLAG_HEADER_FINISHED)) {
	gzfile_make_header(gz);
    }

    if (len &gt; 0 || (gz-&gt;z.flags &amp; GZFILE_FLAG_SYNC)) {
	gz-&gt;crc = crc32(gz-&gt;crc, str, len);
	zstream_run(&amp;gz-&gt;z, str, len, (gz-&gt;z.flags &amp; GZFILE_FLAG_SYNC)
		    ? Z_SYNC_FLUSH : Z_NO_FLUSH);
    }
    gzfile_write_raw(gz);
}

static long
gzfile_read_more(gz)
    struct gzfile *gz;
{
    volatile VALUE str;

    while (!ZSTREAM_IS_FINISHED(&amp;gz-&gt;z)) {
	str = gzfile_read_raw(gz);
	if (NIL_P(str)) {
	    if (!ZSTREAM_IS_FINISHED(&amp;gz-&gt;z)) {
		rb_raise(cGzError, &quot;unexpected end of file&quot;);
	    }
	    break;
	}
	if (RSTRING(str)-&gt;len &gt; 0) { /* prevent Z_BUF_ERROR */
	    zstream_run(&amp;gz-&gt;z, RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len,
			Z_SYNC_FLUSH);
	}
	if (gz-&gt;z.buf_filled &gt; 0) break;
    }
    return gz-&gt;z.buf_filled;
}

static void
gzfile_calc_crc(gz, str)
    struct gzfile *gz;
    VALUE str;
{
    if (RSTRING(str)-&gt;len &lt;= gz-&gt;ungetc) {
	gz-&gt;ungetc -= RSTRING(str)-&gt;len;
    }
    else {
	gz-&gt;crc = crc32(gz-&gt;crc, RSTRING(str)-&gt;ptr + gz-&gt;ungetc,
			RSTRING(str)-&gt;len - gz-&gt;ungetc);
	gz-&gt;ungetc = 0;
    }
}

static VALUE
gzfile_read(gz, len)
    struct gzfile *gz;
    int len;
{
    VALUE dst;

    if (len &lt; 0)
        rb_raise(rb_eArgError, &quot;negative length %d given&quot;, len);
    if (len == 0)
	return rb_str_new(0, 0);
    while (!ZSTREAM_IS_FINISHED(&amp;gz-&gt;z) &amp;&amp; gz-&gt;z.buf_filled &lt; len) {
	gzfile_read_more(gz);
    }
    if (GZFILE_IS_FINISHED(gz)) {
	if (!(gz-&gt;z.flags &amp; GZFILE_FLAG_FOOTER_FINISHED)) {
	    gzfile_check_footer(gz);
	}
	return Qnil;
    }

    dst = zstream_shift_buffer(&amp;gz-&gt;z, len);
    gzfile_calc_crc(gz, dst);

    OBJ_TAINT(dst);  /* for safe */
    return dst;
}

static VALUE
gzfile_read_all(gz)
    struct gzfile *gz;
{
    VALUE dst;

    while (!ZSTREAM_IS_FINISHED(&amp;gz-&gt;z)) {
	gzfile_read_more(gz);
    }
    if (GZFILE_IS_FINISHED(gz)) {
	if (!(gz-&gt;z.flags &amp; GZFILE_FLAG_FOOTER_FINISHED)) {
	    gzfile_check_footer(gz);
	}
	return rb_str_new(0, 0);
    }

    dst = zstream_detach_buffer(&amp;gz-&gt;z);
    gzfile_calc_crc(gz, dst);

    OBJ_TAINT(dst);  /* for safe */
    return dst;
}

static void
gzfile_ungetc(gz, c)
    struct gzfile *gz;
    int c;
{
    zstream_buffer_ungetc(&amp;gz-&gt;z, c);
    gz-&gt;ungetc++;
}

static VALUE
gzfile_writer_end_run(arg)
    VALUE arg;
{
    struct gzfile *gz = (struct gzfile *)arg;

    if (!(gz-&gt;z.flags &amp; GZFILE_FLAG_HEADER_FINISHED)) {
	gzfile_make_header(gz);
    }

    zstream_run(&amp;gz-&gt;z, &quot;&quot;, 0, Z_FINISH);
    gzfile_make_footer(gz);
    gzfile_write_raw(gz);

    return Qnil;
}

static void
gzfile_writer_end(gz)
    struct gzfile *gz;
{
    if (ZSTREAM_IS_CLOSING(&amp;gz-&gt;z)) return;
    gz-&gt;z.flags |= ZSTREAM_FLAG_CLOSING;

    rb_ensure(gzfile_writer_end_run, (VALUE)gz, zstream_end, (VALUE)&amp;gz-&gt;z);
}

static VALUE
gzfile_reader_end_run(arg)
    VALUE arg;
{
    struct gzfile *gz = (struct gzfile *)arg;

    if (GZFILE_IS_FINISHED(gz)
	&amp;&amp; !(gz-&gt;z.flags &amp; GZFILE_FLAG_FOOTER_FINISHED)) {
	gzfile_check_footer(gz);
    }

    return Qnil;
}

static void
gzfile_reader_end(gz)
    struct gzfile *gz;
{
    if (ZSTREAM_IS_CLOSING(&amp;gz-&gt;z)) return;
    gz-&gt;z.flags |= ZSTREAM_FLAG_CLOSING;

    rb_ensure(gzfile_reader_end_run, (VALUE)gz, zstream_end, (VALUE)&amp;gz-&gt;z);
}

static void
gzfile_reader_rewind(gz)
    struct gzfile *gz;
{
    long n;

    n = gz-&gt;z.stream.total_in;
    if (!NIL_P(gz-&gt;z.input)) {
	n += RSTRING(gz-&gt;z.input)-&gt;len;
    }

    rb_funcall(gz-&gt;io, id_seek, 2, rb_int2inum(-n), INT2FIX(1));
    gzfile_reset(gz);
}

static VALUE
gzfile_reader_get_unused(gz)
    struct gzfile *gz;
{
    VALUE str;

    if (!ZSTREAM_IS_READY(&amp;gz-&gt;z)) return Qnil;
    if (!GZFILE_IS_FINISHED(gz)) return Qnil;
    if (!(gz-&gt;z.flags &amp; GZFILE_FLAG_FOOTER_FINISHED)) {
	gzfile_check_footer(gz);
    }
    if (NIL_P(gz-&gt;z.input)) return Qnil;

    str = rb_str_dup(gz-&gt;z.input);
    OBJ_TAINT(str);  /* for safe */
    return str;
}

static struct gzfile *
get_gzfile(obj)
    VALUE obj;
{
    struct gzfile *gz;

    Data_Get_Struct(obj, struct gzfile, gz);
    if (!ZSTREAM_IS_READY(&amp;gz-&gt;z)) {
	rb_raise(cGzError, &quot;closed gzip stream&quot;);
    }
    return gz;
}


/* ------------------------------------------------------------------------- */

/*
 * Document-class: Zlib::GzipFile
 *
 * Zlib::GzipFile is an abstract class for handling a gzip formatted
 * compressed file. The operations are defined in the subclasses,
 * Zlib::GzipReader for reading, and Zlib::GzipWriter for writing.
 *
 * GzipReader should be used by associating an IO, or IO-like, object.
 */


static VALUE
gzfile_ensure_close(obj)
    VALUE obj;
{
    struct gzfile *gz;

    Data_Get_Struct(obj, struct gzfile, gz);
    if (ZSTREAM_IS_READY(&amp;gz-&gt;z)) {
	gzfile_close(gz, 1);
    }
    return Qnil;
}

/*
 * See Zlib::GzipReader#wrap and Zlib::GzipWriter#wrap.
 */
static VALUE
rb_gzfile_s_wrap(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE obj = rb_class_new_instance(argc, argv, klass);

    if (rb_block_given_p()) {
	return rb_ensure(rb_yield, obj, gzfile_ensure_close, obj);
    }
    else {
	return obj;
    }
}

/*
 * See Zlib::GzipReader#open and Zlib::GzipWriter#open.
 */
static VALUE
gzfile_s_open(argc, argv, klass, mode)
    int argc;
    VALUE *argv;
    VALUE klass;
    const char *mode;
{
    VALUE io, filename;

    if (argc &lt; 1) {
	rb_raise(rb_eArgError, &quot;wrong number of arguments (0 for 1)&quot;);
    }
    filename = argv[0];
    SafeStringValue(filename);
    io = rb_file_open(RSTRING(filename)-&gt;ptr, mode);

    argv[0] = io;
    return rb_gzfile_s_wrap(argc, argv, klass);
}

/*
 * Same as IO.
 */
static VALUE
rb_gzfile_to_io(obj)
    VALUE obj;
{
    return get_gzfile(obj)-&gt;io;
}

/*
 * Returns CRC value of the uncompressed data.
 */
static VALUE
rb_gzfile_crc(obj)
    VALUE obj;
{
    return rb_uint2inum(get_gzfile(obj)-&gt;crc);
}

/*
 * Returns last modification time recorded in the gzip file header.
 */
static VALUE
rb_gzfile_mtime(obj)
    VALUE obj;
{
    return rb_time_new(get_gzfile(obj)-&gt;mtime, (time_t)0);
}

/*
 * Returns compression level.
 */
static VALUE
rb_gzfile_level(obj)
    VALUE obj;
{
    return INT2FIX(get_gzfile(obj)-&gt;level);
}

/*
 * Returns OS code number recorded in the gzip file header.
 */
static VALUE
rb_gzfile_os_code(obj)
    VALUE obj;
{
    return INT2FIX(get_gzfile(obj)-&gt;os_code);
}

/*
 * Returns original filename recorded in the gzip file header, or +nil+ if
 * original filename is not present.
 */
static VALUE
rb_gzfile_orig_name(obj)
    VALUE obj;
{
    VALUE str = get_gzfile(obj)-&gt;orig_name;
    if (!NIL_P(str)) {
	str = rb_str_dup(str);
    }
    OBJ_TAINT(str);  /* for safe */
    return str;
}

/*
 * Returns comments recorded in the gzip file header, or nil if the comments
 * is not present.
 */
static VALUE
rb_gzfile_comment(obj)
    VALUE obj;
{
    VALUE str = get_gzfile(obj)-&gt;comment;
    if (!NIL_P(str)) {
	str = rb_str_dup(str);
    }
    OBJ_TAINT(str);  /* for safe */
    return str;
}

/*
 * ???
 */
static VALUE
rb_gzfile_lineno(obj)
    VALUE obj;
{
    return INT2NUM(get_gzfile(obj)-&gt;lineno);
}

/*
 * ???
 */
static VALUE
rb_gzfile_set_lineno(obj, lineno)
    VALUE obj, lineno;
{
    struct gzfile *gz = get_gzfile(obj);
    gz-&gt;lineno = NUM2INT(lineno);
    return lineno;
}

/*
 * ???
 */
static VALUE
rb_gzfile_set_mtime(obj, mtime)
    VALUE obj, mtime;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE val;

    if (gz-&gt;z.flags &amp; GZFILE_FLAG_HEADER_FINISHED) {
	rb_raise(cGzError, &quot;header is already written&quot;);
    }

    if (FIXNUM_P(time)) {
	gz-&gt;mtime = FIX2INT(mtime);
    }
    else {
	val = rb_Integer(mtime);
	gz-&gt;mtime = FIXNUM_P(val) ? FIX2INT(val) : rb_big2ulong(val);
    }
    return mtime;
}

/*
 * ???
 */
static VALUE
rb_gzfile_set_orig_name(obj, str)
    VALUE obj, str;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE s;
    char *p;

    if (gz-&gt;z.flags &amp; GZFILE_FLAG_HEADER_FINISHED) {
	rb_raise(cGzError, &quot;header is already written&quot;);
    }
    s = rb_str_dup(rb_str_to_str(str));
    p = memchr(RSTRING(s)-&gt;ptr, '\0', RSTRING(s)-&gt;len);
    if (p) {
	rb_str_resize(s, p - RSTRING(s)-&gt;ptr);
    }
    gz-&gt;orig_name = s;
    return str;
}

/*
 * ???
 */
static VALUE
rb_gzfile_set_comment(obj, str)
    VALUE obj, str;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE s;
    char *p;

    if (gz-&gt;z.flags &amp; GZFILE_FLAG_HEADER_FINISHED) {
	rb_raise(cGzError, &quot;header is already written&quot;);
    }
    s = rb_str_dup(rb_str_to_str(str));
    p = memchr(RSTRING(s)-&gt;ptr, '\0', RSTRING(s)-&gt;len);
    if (p) {
	rb_str_resize(s, p - RSTRING(s)-&gt;ptr);
    }
    gz-&gt;comment = s;
    return str;
}

/*
 * Closes the GzipFile object. This method calls close method of the
 * associated IO object. Returns the associated IO object.
 */
static VALUE
rb_gzfile_close(obj)
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE io;

    io = gz-&gt;io;
    gzfile_close(gz, 1);
    return io;
}

/*
 * Closes the GzipFile object. Unlike Zlib::GzipFile#close, this method never
 * calls the close method of the associated IO object. Returns the associated IO
 * object.
 */
static VALUE
rb_gzfile_finish(obj)
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE io;

    io = gz-&gt;io;
    gzfile_close(gz, 0);
    return io;
}

/*
 * Same as IO.
 */
static VALUE
rb_gzfile_closed_p(obj)
    VALUE obj;
{
    struct gzfile *gz;
    Data_Get_Struct(obj, struct gzfile, gz);
    return NIL_P(gz-&gt;io) ? Qtrue : Qfalse;
}

/*
 * ???
 */
static VALUE
rb_gzfile_eof_p(obj)
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    return GZFILE_IS_FINISHED(gz) ? Qtrue : Qfalse;
}

/*
 * Same as IO.
 */
static VALUE
rb_gzfile_sync(obj)
    VALUE obj;
{
    return (get_gzfile(obj)-&gt;z.flags &amp; GZFILE_FLAG_SYNC) ? Qtrue : Qfalse;
}

/*
 * call-seq: sync = flag
 *
 * Same as IO.  If flag is +true+, the associated IO object must respond to the
 * +flush+ method.  While +sync+ mode is +true+, the compression ratio
 * decreases sharply.
 */
static VALUE
rb_gzfile_set_sync(obj, mode)
    VALUE obj, mode;
{
    struct gzfile *gz = get_gzfile(obj);

    if (RTEST(mode)) {
	gz-&gt;z.flags |= GZFILE_FLAG_SYNC;
    }
    else {
	gz-&gt;z.flags &amp;= ~GZFILE_FLAG_SYNC;
    }
    return mode;
}

/*
 * ???
 */
static VALUE
rb_gzfile_total_in(obj)
    VALUE obj;
{
    return rb_uint2inum(get_gzfile(obj)-&gt;z.stream.total_in);
}

/*
 * ???
 */
static VALUE
rb_gzfile_total_out(obj)
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    return rb_uint2inum(gz-&gt;z.stream.total_out - gz-&gt;z.buf_filled);
}


/* ------------------------------------------------------------------------- */

/*
 * Document-class: Zlib::GzipWriter
 *
 * Zlib::GzipWriter is a class for writing gzipped files.  GzipWriter should
 * be used with an instance of IO, or IO-like, object. 
 *
 * For example:
 *
 *   Zlib::GzipWriter.open('hoge.gz') do |gz|
 *     gz.write 'jugemu jugemu gokou no surikire...'
 *   end
 *
 *   File.open('hoge.gz', 'w') do |f|
 *     gz = Zlib::GzipWriter.new(f)
 *     gz.write 'jugemu jugemu gokou no surikire...'
 *     gz.close
 *   end
 *
 *   # TODO: test these.  Are they equivalent?  Can GzipWriter.new take a
 *   # block?
 *
 * NOTE: Due to the limitation of Ruby's finalizer, you must explicitly close
 * GzipWriter objects by Zlib::GzipWriter#close etc.  Otherwise, GzipWriter
 * will be not able to write the gzip footer and will generate a broken gzip
 * file.
 */

static VALUE
rb_gzwriter_s_allocate(klass)
    VALUE klass;
{
    return gzfile_writer_new(klass);
}

/*
 * call-seq: Zlib::GzipWriter.open(filename, level=nil, strategy=nil) { |gz| ... }
 *
 * Opens a file specified by +filename+ for writing gzip compressed data, and
 * returns a GzipWriter object associated with that file.  Further details of
 * this method are found in Zlib::GzipWriter.new and Zlib::GzipWriter#wrap.
 */
static VALUE
rb_gzwriter_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return gzfile_s_open(argc, argv, klass, &quot;wb&quot;);
}

/*
 * call-seq: Zlib::GzipWriter.new(io, level, strategy)
 *
 * Creates a GzipWriter object associated with +io+. +level+ and +strategy+
 * should be the same as the arguments of Zlib::Deflate.new.  The GzipWriter
 * object writes gzipped data to +io+.  At least, +io+ must respond to the
 * +write+ method that behaves same as write method in IO class.
 */
static VALUE
rb_gzwriter_initialize(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct gzfile *gz;
    VALUE io, level, strategy;
    int err;

    rb_scan_args(argc, argv, &quot;12&quot;, &amp;io, &amp;level, &amp;strategy);
    Data_Get_Struct(obj, struct gzfile, gz);

    /* this is undocumented feature of zlib */
    gz-&gt;level = ARG_LEVEL(level);
    err = deflateInit2(&amp;gz-&gt;z.stream, gz-&gt;level, Z_DEFLATED,
		       -MAX_WBITS, DEF_MEM_LEVEL, ARG_STRATEGY(strategy));
    if (err != Z_OK) {
	raise_zlib_error(err, gz-&gt;z.stream.msg);
    }
    gz-&gt;io = io;
    ZSTREAM_READY(&amp;gz-&gt;z);

    return obj;
}

/*
 * call-seq: flush(flush=nil)
 *
 * Flushes all the internal buffers of the GzipWriter object.  The meaning of
 * +flush+ is same as in Zlib::Deflate#deflate.  &lt;tt&gt;Zlib::SYNC_FLUSH&lt;/tt&gt; is used if
 * +flush+ is omitted.  It is no use giving flush &lt;tt&gt;Zlib::NO_FLUSH&lt;/tt&gt;.
 */
static VALUE
rb_gzwriter_flush(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE v_flush;
    int flush;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;v_flush);

    flush = FIXNUMARG(v_flush, Z_SYNC_FLUSH);
    if (flush != Z_NO_FLUSH) {  /* prevent Z_BUF_ERROR */
	zstream_run(&amp;gz-&gt;z, &quot;&quot;, 0, flush);
    }

    gzfile_write_raw(gz);
    if (rb_respond_to(gz-&gt;io, id_flush)) {
	rb_funcall(gz-&gt;io, id_flush, 0);
    }
    return obj;
}

/*
 * Same as IO.
 */
static VALUE
rb_gzwriter_write(obj, str)
    VALUE obj, str;
{
    struct gzfile *gz = get_gzfile(obj);

    if (TYPE(str) != T_STRING) {
	str = rb_obj_as_string(str);
    }
    gzfile_write(gz, RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len);
    return INT2FIX(RSTRING(str)-&gt;len);
}

/*
 * Same as IO.
 */
static VALUE
rb_gzwriter_putc(obj, ch)
    VALUE obj, ch;
{
    struct gzfile *gz = get_gzfile(obj);
    char c = NUM2CHR(ch);

    gzfile_write(gz, &amp;c, 1);
    return ch;
}



/*
 * Document-method: &lt;&lt;
 * Same as IO.
 */
#define rb_gzwriter_addstr  rb_io_addstr
/*
 * Document-method: printf
 * Same as IO.
 */
#define rb_gzwriter_printf  rb_io_printf
/*
 * Document-method: print
 * Same as IO.
 */
#define rb_gzwriter_print  rb_io_print
/*
 * Document-method: puts
 * Same as IO.
 */
#define rb_gzwriter_puts  rb_io_puts


/* ------------------------------------------------------------------------- */

/*
 * Document-class: Zlib::GzipReader
 *
 * Zlib::GzipReader is the class for reading a gzipped file.  GzipReader should
 * be used an IO, or -IO-lie, object.
 *
 *   Zlib::GzipReader.open('hoge.gz') {|gz|
 *     print gz.read
 *   }
 *
 *   File.open('hoge.gz') do |f|
 *     gz = Zlib::GzipReader.new(f)
 *     print gz.read
 *     gz.close
 *   end
 *
 *   # TODO: test these.  Are they equivalent?  Can GzipReader.new take a
 *   # block?
 *
 * == Method Catalogue
 *
 * The following methods in Zlib::GzipReader are just like their counterparts
 * in IO, but they raise Zlib::Error or Zlib::GzipFile::Error exception if an
 * error was found in the gzip file.
 * - #each
 * - #each_line
 * - #each_byte
 * - #gets
 * - #getc
 * - #lineno
 * - #lineno=
 * - #read
 * - #readchar
 * - #readline
 * - #readlines
 * - #ungetc
 *
 * Be careful of the footer of the gzip file. A gzip file has the checksum of
 * pre-compressed data in its footer. GzipReader checks all uncompressed data
 * against that checksum at the following cases, and if it fails, raises
 * &lt;tt&gt;Zlib::GzipFile::NoFooter&lt;/tt&gt;, &lt;tt&gt;Zlib::GzipFile::CRCError&lt;/tt&gt;, or
 * &lt;tt&gt;Zlib::GzipFile::LengthError&lt;/tt&gt; exception.
 *
 * - When an reading request is received beyond the end of file (the end of
 *   compressed data). That is, when Zlib::GzipReader#read,
 *   Zlib::GzipReader#gets, or some other methods for reading returns nil.
 * - When Zlib::GzipFile#close method is called after the object reaches the
 *   end of file.
 * - When Zlib::GzipReader#unused method is called after the object reaches
 *   the end of file.
 *
 * The rest of the methods are adequately described in their own
 * documentation.
 */

static VALUE
rb_gzreader_s_allocate(klass)
    VALUE klass;
{
    return gzfile_reader_new(klass);
}

/*
 * call-seq: Zlib::GzipReader.open(filename) {|gz| ... }
 *
 * Opens a file specified by +filename+ as a gzipped file, and returns a
 * GzipReader object associated with that file.  Further details of this method
 * are in Zlib::GzipReader.new and ZLib::GzipReader.wrap.
 */
static VALUE
rb_gzreader_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return gzfile_s_open(argc, argv, klass, &quot;rb&quot;);
}

/*
 * call-seq: Zlib::GzipReader.new(io)
 *
 * Creates a GzipReader object associated with +io+. The GzipReader object reads
 * gzipped data from +io+, and parses/decompresses them.  At least, +io+ must have
 * a +read+ method that behaves same as the +read+ method in IO class.
 *
 * If the gzip file header is incorrect, raises an Zlib::GzipFile::Error
 * exception.
 */
static VALUE
rb_gzreader_initialize(obj, io)
    VALUE obj, io;
{
    struct gzfile *gz;
    int err;

    Data_Get_Struct(obj, struct gzfile, gz);

    /* this is undocumented feature of zlib */
    err = inflateInit2(&amp;gz-&gt;z.stream, -MAX_WBITS);
    if (err != Z_OK) {
	raise_zlib_error(err, gz-&gt;z.stream.msg);
    }
    gz-&gt;io = io;
    ZSTREAM_READY(&amp;gz-&gt;z);
    gzfile_read_header(gz);

    return obj;
}

/*
 * Resets the position of the file pointer to the point created the GzipReader
 * object.  The associated IO object needs to respond to the +seek+ method.
 */
static VALUE
rb_gzreader_rewind(obj)
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    gzfile_reader_rewind(gz);
    return INT2FIX(0);
}

/*
 * Returns the rest of the data which had read for parsing gzip format, or
 * +nil+ if the whole gzip file is not parsed yet.
 */
static VALUE
rb_gzreader_unused(obj)
    VALUE obj;
{
    struct gzfile *gz;
    Data_Get_Struct(obj, struct gzfile, gz);
    return gzfile_reader_get_unused(gz);
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_read(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE vlen;
    int len;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;vlen);
    if (NIL_P(vlen)) {
	return gzfile_read_all(gz);
    }

    len = NUM2INT(vlen);
    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;negative length %d given&quot;, len);
    }
    return gzfile_read(gz, len);
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_getc(obj)
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    VALUE dst;

    dst = gzfile_read(gz, 1);
    if (!NIL_P(dst)) {
	dst = INT2FIX((unsigned int)(RSTRING(dst)-&gt;ptr[0]) &amp; 0xff);
    }
    return dst;
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_readchar(obj)
    VALUE obj;
{
    VALUE dst;
    dst = rb_gzreader_getc(obj);
    if (NIL_P(dst)) {
	rb_raise(rb_eEOFError, &quot;end of file reached&quot;);
    }
    return dst;
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_each_byte(obj)
    VALUE obj;
{
    VALUE c;
    while (!NIL_P(c = rb_gzreader_getc(obj))) {
	rb_yield(c);
    }
    return Qnil;
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_ungetc(obj, ch)
    VALUE obj, ch;
{
    struct gzfile *gz = get_gzfile(obj);
    gzfile_ungetc(gz, NUM2CHR(ch));
    return Qnil;
}

static void
gzreader_skip_linebreaks(gz)
    struct gzfile *gz;
{
    VALUE str;
    char *p;
    int n;

    while (gz-&gt;z.buf_filled == 0) {
	if (GZFILE_IS_FINISHED(gz)) return;
	gzfile_read_more(gz);
    }
    n = 0;
    p = RSTRING(gz-&gt;z.buf)-&gt;ptr;

    while (n++, *(p++) == '\n') {
	if (n &gt;= gz-&gt;z.buf_filled) {
	    str = zstream_detach_buffer(&amp;gz-&gt;z);
	    gzfile_calc_crc(gz, str);
	    while (gz-&gt;z.buf_filled == 0) {
		if (GZFILE_IS_FINISHED(gz)) return;
		gzfile_read_more(gz);
	    }
	    n = 0;
	    p = RSTRING(gz-&gt;z.buf)-&gt;ptr;
	}
    }

    str = zstream_shift_buffer(&amp;gz-&gt;z, n - 1);
    gzfile_calc_crc(gz, str);
}

static void
rscheck(rsptr, rslen, rs)
    char *rsptr;
    long rslen;
    VALUE rs;
{
    if (RSTRING(rs)-&gt;ptr != rsptr &amp;&amp; RSTRING(rs)-&gt;len != rslen)
	rb_raise(rb_eRuntimeError, &quot;rs modified&quot;);
}

static VALUE
gzreader_gets(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    struct gzfile *gz = get_gzfile(obj);
    volatile VALUE rs;
    VALUE dst;
    char *rsptr, *p, *res;
    long rslen, n;
    int rspara;

    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, &quot;1&quot;, &amp;rs);
	if (!NIL_P(rs)) {
	    Check_Type(rs, T_STRING);
	}
    }

    if (NIL_P(rs)) {
	dst = gzfile_read_all(gz);
	if (RSTRING(dst)-&gt;len != 0) gz-&gt;lineno++;
	else
		return Qnil;
	return dst;
    }

    if (RSTRING(rs)-&gt;len == 0) {
	rsptr = &quot;\n\n&quot;;
	rslen = 2;
	rspara = 1;
    } else {
	rsptr = RSTRING(rs)-&gt;ptr;
	rslen = RSTRING(rs)-&gt;len;
	rspara = 0;
    }

    if (rspara) {
	gzreader_skip_linebreaks(gz);
    }

    while (gz-&gt;z.buf_filled &lt; rslen) {
	if (ZSTREAM_IS_FINISHED(&amp;gz-&gt;z)) {
	    if (gz-&gt;z.buf_filled &gt; 0) gz-&gt;lineno++;
	    return gzfile_read(gz, rslen);
	}
	gzfile_read_more(gz);
    }

    p = RSTRING(gz-&gt;z.buf)-&gt;ptr;
    n = rslen;
    for (;;) {
	if (n &gt; gz-&gt;z.buf_filled) {
	    if (ZSTREAM_IS_FINISHED(&amp;gz-&gt;z)) break;
	    gzfile_read_more(gz);
	    p = RSTRING(gz-&gt;z.buf)-&gt;ptr + n - rslen;
	}
	if (!rspara) rscheck(rsptr, rslen, rs);
	res = memchr(p, rsptr[0], (gz-&gt;z.buf_filled - n + 1));
	if (!res) {
	    n = gz-&gt;z.buf_filled + 1;
	} else {
	    n += (long)(res - p);
	    p = res;
	    if (rslen == 1 || memcmp(p, rsptr, rslen) == 0) break;
	    p++, n++;
	}
    }

    gz-&gt;lineno++;
    dst = gzfile_read(gz, n);
    if (rspara) {
	gzreader_skip_linebreaks(gz);
    }

    return dst;
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_gets(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE dst;
    dst = gzreader_gets(argc, argv, obj);
    if (!NIL_P(dst)) {
	rb_lastline_set(dst);
    }
    return dst;
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_readline(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE dst;
    dst = rb_gzreader_gets(argc, argv, obj);
    if (NIL_P(dst)) {
	rb_raise(rb_eEOFError, &quot;end of file reached&quot;);
    }
    return dst;
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_each(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE str;
    while (!NIL_P(str = gzreader_gets(argc, argv, obj))) {
	rb_yield(str);
    }
    return obj;
}

/*
 * See Zlib::GzipReader documentation for a description.
 */
static VALUE
rb_gzreader_readlines(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE str, dst;
    dst = rb_ary_new();
    while (!NIL_P(str = gzreader_gets(argc, argv, obj))) {
	rb_ary_push(dst, str);
    }
    return dst;
}

#endif /* GZIP_SUPPORT */



/*
 * The Zlib module contains several classes for compressing and decompressing
 * streams, and for working with &quot;gzip&quot; files.
 *
 * == Classes
 *
 * Following are the classes that are most likely to be of interest to the
 * user:
 * Zlib::Inflate
 * Zlib::Deflate
 * Zlib::GzipReader
 * Zlib::GzipWriter
 *
 * There are two important base classes for the classes above: Zlib::ZStream
 * and Zlib::GzipFile.  Everything else is an error class.
 *
 * == Constants
 *
 * Here's a list.
 *
 *   Zlib::VERSION
 *       The Ruby/zlib version string.
 *
 *   Zlib::ZLIB_VERSION
 *       The string which represents the version of zlib.h.
 *
 *   Zlib::BINARY
 *   Zlib::ASCII
 *   Zlib::UNKNOWN
 *       The integers representing data types which Zlib::ZStream#data_type
 *       method returns.
 *
 *   Zlib::NO_COMPRESSION
 *   Zlib::BEST_SPEED
 *   Zlib::BEST_COMPRESSION
 *   Zlib::DEFAULT_COMPRESSION
 *       The integers representing compression levels which are an argument
 *       for Zlib::Deflate.new, Zlib::Deflate#deflate, and so on.
 *
 *   Zlib::FILTERED
 *   Zlib::HUFFMAN_ONLY
 *   Zlib::DEFAULT_STRATEGY
 *       The integers representing compression methods which are an argument
 *       for Zlib::Deflate.new and Zlib::Deflate#params.
 *
 *   Zlib::DEF_MEM_LEVEL
 *   Zlib::MAX_MEM_LEVEL
 *       The integers representing memory levels which are an argument for
 *       Zlib::Deflate.new, Zlib::Deflate#params, and so on.
 *
 *   Zlib::MAX_WBITS
 *       The default value of windowBits which is an argument for
 *       Zlib::Deflate.new and Zlib::Inflate.new.
 *
 *   Zlib::NO_FLUSH
 *   Zlib::SYNC_FLUSH
 *   Zlib::FULL_FLUSH
 *   Zlib::FINISH
 *       The integers to control the output of the deflate stream, which are
 *       an argument for Zlib::Deflate#deflate and so on.
 *
 *   Zlib::OS_CODE
 *   Zlib::OS_MSDOS
 *   Zlib::OS_AMIGA
 *   Zlib::OS_VMS
 *   Zlib::OS_UNIX
 *   Zlib::OS_VMCMS
 *   Zlib::OS_ATARI
 *   Zlib::OS_OS2
 *   Zlib::OS_MACOS
 *   Zlib::OS_ZSYSTEM
 *   Zlib::OS_CPM
 *   Zlib::OS_TOPS20
 *   Zlib::OS_WIN32
 *   Zlib::OS_QDOS
 *   Zlib::OS_RISCOS
 *   Zlib::OS_UNKNOWN
 *       The return values of Zlib::GzipFile#os_code method.
 */
void Init_zlib()
{
    VALUE mZlib, cZStream, cDeflate, cInflate;
#if GZIP_SUPPORT
    VALUE cGzipFile, cGzipWriter, cGzipReader;
#endif

    mZlib = rb_define_module(&quot;Zlib&quot;);

    cZError = rb_define_class_under(mZlib, &quot;Error&quot;, rb_eStandardError);
    cStreamEnd    = rb_define_class_under(mZlib, &quot;StreamEnd&quot;, cZError);
    cNeedDict     = rb_define_class_under(mZlib, &quot;NeedDict&quot;, cZError);
    cDataError    = rb_define_class_under(mZlib, &quot;DataError&quot;, cZError);
    cStreamError  = rb_define_class_under(mZlib, &quot;StreamError&quot;, cZError);
    cMemError     = rb_define_class_under(mZlib, &quot;MemError&quot;, cZError);
    cBufError     = rb_define_class_under(mZlib, &quot;BufError&quot;, cZError);
    cVersionError = rb_define_class_under(mZlib, &quot;VersionError&quot;, cZError);

    rb_define_module_function(mZlib, &quot;zlib_version&quot;, rb_zlib_version, 0);
    rb_define_module_function(mZlib, &quot;adler32&quot;, rb_zlib_adler32, -1);
    rb_define_module_function(mZlib, &quot;crc32&quot;, rb_zlib_crc32, -1);
    rb_define_module_function(mZlib, &quot;crc_table&quot;, rb_zlib_crc_table, 0);

    rb_define_const(mZlib, &quot;VERSION&quot;, rb_str_new2(RUBY_ZLIB_VERSION));
    rb_define_const(mZlib, &quot;ZLIB_VERSION&quot;, rb_str_new2(ZLIB_VERSION));

    cZStream = rb_define_class_under(mZlib, &quot;ZStream&quot;, rb_cObject);
    rb_undef_alloc_func(cZStream);
    rb_define_method(cZStream, &quot;avail_out&quot;, rb_zstream_avail_out, 0);
    rb_define_method(cZStream, &quot;avail_out=&quot;, rb_zstream_set_avail_out, 1);
    rb_define_method(cZStream, &quot;avail_in&quot;, rb_zstream_avail_in, 0);
    rb_define_method(cZStream, &quot;total_in&quot;, rb_zstream_total_in, 0);
    rb_define_method(cZStream, &quot;total_out&quot;, rb_zstream_total_out, 0);
    rb_define_method(cZStream, &quot;data_type&quot;, rb_zstream_data_type, 0);
    rb_define_method(cZStream, &quot;adler&quot;, rb_zstream_adler, 0);
    rb_define_method(cZStream, &quot;finished?&quot;, rb_zstream_finished_p, 0);
    rb_define_method(cZStream, &quot;stream_end?&quot;, rb_zstream_finished_p, 0);
    rb_define_method(cZStream, &quot;closed?&quot;, rb_zstream_closed_p, 0);
    rb_define_method(cZStream, &quot;ended?&quot;, rb_zstream_closed_p, 0);
    rb_define_method(cZStream, &quot;close&quot;, rb_zstream_end, 0);
    rb_define_method(cZStream, &quot;end&quot;, rb_zstream_end, 0);
    rb_define_method(cZStream, &quot;reset&quot;, rb_zstream_reset, 0);
    rb_define_method(cZStream, &quot;finish&quot;, rb_zstream_finish, 0);
    rb_define_method(cZStream, &quot;flush_next_in&quot;, rb_zstream_flush_next_in, 0);
    rb_define_method(cZStream, &quot;flush_next_out&quot;, rb_zstream_flush_next_out, 0);

    rb_define_const(mZlib, &quot;BINARY&quot;, INT2FIX(Z_BINARY));
    rb_define_const(mZlib, &quot;ASCII&quot;, INT2FIX(Z_ASCII));
    rb_define_const(mZlib, &quot;UNKNOWN&quot;, INT2FIX(Z_UNKNOWN));

    cDeflate = rb_define_class_under(mZlib, &quot;Deflate&quot;, cZStream);
    rb_define_singleton_method(cDeflate, &quot;deflate&quot;, rb_deflate_s_deflate, -1);
    rb_define_alloc_func(cDeflate, rb_deflate_s_allocate);
    rb_define_method(cDeflate, &quot;initialize&quot;, rb_deflate_initialize, -1);
    rb_define_method(cDeflate, &quot;initialize_copy&quot;, rb_deflate_init_copy, 1);
    rb_define_method(cDeflate, &quot;deflate&quot;, rb_deflate_deflate, -1);
    rb_define_method(cDeflate, &quot;&lt;&lt;&quot;, rb_deflate_addstr, 1);
    rb_define_method(cDeflate, &quot;flush&quot;, rb_deflate_flush, -1);
    rb_define_method(cDeflate, &quot;params&quot;, rb_deflate_params, 2);
    rb_define_method(cDeflate, &quot;set_dictionary&quot;, rb_deflate_set_dictionary, 1);

    cInflate = rb_define_class_under(mZlib, &quot;Inflate&quot;, cZStream);
    rb_define_singleton_method(cInflate, &quot;inflate&quot;, rb_inflate_s_inflate, 1);
    rb_define_alloc_func(cInflate, rb_inflate_s_allocate);
    rb_define_method(cInflate, &quot;initialize&quot;, rb_inflate_initialize, -1);
    rb_define_method(cInflate, &quot;inflate&quot;, rb_inflate_inflate, 1);
    rb_define_method(cInflate, &quot;&lt;&lt;&quot;, rb_inflate_addstr, 1);
    rb_define_method(cInflate, &quot;sync&quot;, rb_inflate_sync, 1);
    rb_define_method(cInflate, &quot;sync_point?&quot;, rb_inflate_sync_point_p, 0);
    rb_define_method(cInflate, &quot;set_dictionary&quot;, rb_inflate_set_dictionary, 1);

    rb_define_const(mZlib, &quot;NO_COMPRESSION&quot;, INT2FIX(Z_NO_COMPRESSION));
    rb_define_const(mZlib, &quot;BEST_SPEED&quot;, INT2FIX(Z_BEST_SPEED));
    rb_define_const(mZlib, &quot;BEST_COMPRESSION&quot;, INT2FIX(Z_BEST_COMPRESSION));
    rb_define_const(mZlib, &quot;DEFAULT_COMPRESSION&quot;,
		    INT2FIX(Z_DEFAULT_COMPRESSION));

    rb_define_const(mZlib, &quot;FILTERED&quot;, INT2FIX(Z_FILTERED));
    rb_define_const(mZlib, &quot;HUFFMAN_ONLY&quot;, INT2FIX(Z_HUFFMAN_ONLY));
    rb_define_const(mZlib, &quot;DEFAULT_STRATEGY&quot;, INT2FIX(Z_DEFAULT_STRATEGY));

    rb_define_const(mZlib, &quot;MAX_WBITS&quot;, INT2FIX(MAX_WBITS));
    rb_define_const(mZlib, &quot;DEF_MEM_LEVEL&quot;, INT2FIX(DEF_MEM_LEVEL));
    rb_define_const(mZlib, &quot;MAX_MEM_LEVEL&quot;, INT2FIX(MAX_MEM_LEVEL));

    rb_define_const(mZlib, &quot;NO_FLUSH&quot;, INT2FIX(Z_NO_FLUSH));
    rb_define_const(mZlib, &quot;SYNC_FLUSH&quot;, INT2FIX(Z_SYNC_FLUSH));
    rb_define_const(mZlib, &quot;FULL_FLUSH&quot;, INT2FIX(Z_FULL_FLUSH));
    rb_define_const(mZlib, &quot;FINISH&quot;, INT2FIX(Z_FINISH));

#if GZIP_SUPPORT
    id_write = rb_intern(&quot;write&quot;);
    id_read = rb_intern(&quot;read&quot;);
    id_flush = rb_intern(&quot;flush&quot;);
    id_seek = rb_intern(&quot;seek&quot;);
    id_close = rb_intern(&quot;close&quot;);

    cGzipFile = rb_define_class_under(mZlib, &quot;GzipFile&quot;, rb_cObject);
    cGzError = rb_define_class_under(cGzipFile, &quot;Error&quot;, cZError);

    cNoFooter = rb_define_class_under(cGzipFile, &quot;NoFooter&quot;, cGzError);
    cCRCError = rb_define_class_under(cGzipFile, &quot;CRCError&quot;, cGzError);
    cLengthError = rb_define_class_under(cGzipFile,&quot;LengthError&quot;,cGzError);

    cGzipWriter = rb_define_class_under(mZlib, &quot;GzipWriter&quot;, cGzipFile);
    cGzipReader = rb_define_class_under(mZlib, &quot;GzipReader&quot;, cGzipFile);
    rb_include_module(cGzipReader, rb_mEnumerable);

    rb_define_singleton_method(cGzipFile, &quot;wrap&quot;, rb_gzfile_s_wrap, -1);
    rb_undef_alloc_func(cGzipFile);
    rb_define_method(cGzipFile, &quot;to_io&quot;, rb_gzfile_to_io, 0);
    rb_define_method(cGzipFile, &quot;crc&quot;, rb_gzfile_crc, 0);
    rb_define_method(cGzipFile, &quot;mtime&quot;, rb_gzfile_mtime, 0);
    rb_define_method(cGzipFile, &quot;level&quot;, rb_gzfile_level, 0);
    rb_define_method(cGzipFile, &quot;os_code&quot;, rb_gzfile_os_code, 0);
    rb_define_method(cGzipFile, &quot;orig_name&quot;, rb_gzfile_orig_name, 0);
    rb_define_method(cGzipFile, &quot;comment&quot;, rb_gzfile_comment, 0);
    rb_define_method(cGzipReader, &quot;lineno&quot;, rb_gzfile_lineno, 0);
    rb_define_method(cGzipReader, &quot;lineno=&quot;, rb_gzfile_set_lineno, 1);
    rb_define_method(cGzipWriter, &quot;mtime=&quot;, rb_gzfile_set_mtime, 1);
    rb_define_method(cGzipWriter, &quot;orig_name=&quot;, rb_gzfile_set_orig_name,1);
    rb_define_method(cGzipWriter, &quot;comment=&quot;, rb_gzfile_set_comment, 1);
    rb_define_method(cGzipFile, &quot;close&quot;, rb_gzfile_close, 0);
    rb_define_method(cGzipFile, &quot;finish&quot;, rb_gzfile_finish, 0);
    rb_define_method(cGzipFile, &quot;closed?&quot;, rb_gzfile_closed_p, 0);
    rb_define_method(cGzipReader, &quot;eof&quot;, rb_gzfile_eof_p, 0);
    rb_define_method(cGzipReader, &quot;eof?&quot;, rb_gzfile_eof_p, 0);
    rb_define_method(cGzipFile, &quot;sync&quot;, rb_gzfile_sync, 0);
    rb_define_method(cGzipFile, &quot;sync=&quot;, rb_gzfile_set_sync, 1);
    rb_define_method(cGzipReader, &quot;pos&quot;, rb_gzfile_total_out, 0);
    rb_define_method(cGzipWriter, &quot;pos&quot;, rb_gzfile_total_in, 0);
    rb_define_method(cGzipReader, &quot;tell&quot;, rb_gzfile_total_out, 0);
    rb_define_method(cGzipWriter, &quot;tell&quot;, rb_gzfile_total_in, 0);

    rb_define_singleton_method(cGzipWriter, &quot;open&quot;, rb_gzwriter_s_open,-1);
    rb_define_alloc_func(cGzipWriter, rb_gzwriter_s_allocate);
    rb_define_method(cGzipWriter, &quot;initialize&quot;, rb_gzwriter_initialize,-1);
    rb_define_method(cGzipWriter, &quot;flush&quot;, rb_gzwriter_flush, -1);
    rb_define_method(cGzipWriter, &quot;write&quot;, rb_gzwriter_write, 1);
    rb_define_method(cGzipWriter, &quot;putc&quot;, rb_gzwriter_putc, 1);
    rb_define_method(cGzipWriter, &quot;&lt;&lt;&quot;, rb_gzwriter_addstr, 1);
    rb_define_method(cGzipWriter, &quot;printf&quot;, rb_gzwriter_printf, -1);
    rb_define_method(cGzipWriter, &quot;print&quot;, rb_gzwriter_print, -1);
    rb_define_method(cGzipWriter, &quot;puts&quot;, rb_gzwriter_puts, -1);

    rb_define_singleton_method(cGzipReader, &quot;open&quot;, rb_gzreader_s_open,-1);
    rb_define_alloc_func(cGzipReader, rb_gzreader_s_allocate);
    rb_define_method(cGzipReader, &quot;initialize&quot;, rb_gzreader_initialize, 1);
    rb_define_method(cGzipReader, &quot;rewind&quot;, rb_gzreader_rewind, 0);
    rb_define_method(cGzipReader, &quot;unused&quot;, rb_gzreader_unused, 0);
    rb_define_method(cGzipReader, &quot;read&quot;, rb_gzreader_read, -1);
    rb_define_method(cGzipReader, &quot;getc&quot;, rb_gzreader_getc, 0);
    rb_define_method(cGzipReader, &quot;readchar&quot;, rb_gzreader_readchar, 0);
    rb_define_method(cGzipReader, &quot;each_byte&quot;, rb_gzreader_each_byte, 0);
    rb_define_method(cGzipReader, &quot;ungetc&quot;, rb_gzreader_ungetc, 1);
    rb_define_method(cGzipReader, &quot;gets&quot;, rb_gzreader_gets, -1);
    rb_define_method(cGzipReader, &quot;readline&quot;, rb_gzreader_readline, -1);
    rb_define_method(cGzipReader, &quot;each&quot;, rb_gzreader_each, -1);
    rb_define_method(cGzipReader, &quot;each_line&quot;, rb_gzreader_each, -1);
    rb_define_method(cGzipReader, &quot;readlines&quot;, rb_gzreader_readlines, -1);

    rb_define_const(mZlib, &quot;OS_CODE&quot;, INT2FIX(OS_CODE));
    rb_define_const(mZlib, &quot;OS_MSDOS&quot;, INT2FIX(OS_MSDOS));
    rb_define_const(mZlib, &quot;OS_AMIGA&quot;, INT2FIX(OS_AMIGA));
    rb_define_const(mZlib, &quot;OS_VMS&quot;, INT2FIX(OS_VMS));
    rb_define_const(mZlib, &quot;OS_UNIX&quot;, INT2FIX(OS_UNIX));
    rb_define_const(mZlib, &quot;OS_ATARI&quot;, INT2FIX(OS_ATARI));
    rb_define_const(mZlib, &quot;OS_OS2&quot;, INT2FIX(OS_OS2));
    rb_define_const(mZlib, &quot;OS_MACOS&quot;, INT2FIX(OS_MACOS));
    rb_define_const(mZlib, &quot;OS_TOPS20&quot;, INT2FIX(OS_TOPS20));
    rb_define_const(mZlib, &quot;OS_WIN32&quot;, INT2FIX(OS_WIN32));

    rb_define_const(mZlib, &quot;OS_VMCMS&quot;, INT2FIX(OS_VMCMS));
    rb_define_const(mZlib, &quot;OS_ZSYSTEM&quot;, INT2FIX(OS_ZSYSTEM));
    rb_define_const(mZlib, &quot;OS_CPM&quot;, INT2FIX(OS_CPM));
    rb_define_const(mZlib, &quot;OS_QDOS&quot;, INT2FIX(OS_QDOS));
    rb_define_const(mZlib, &quot;OS_RISCOS&quot;, INT2FIX(OS_RISCOS));
    rb_define_const(mZlib, &quot;OS_UNKNOWN&quot;, INT2FIX(OS_UNKNOWN));

#endif /* GZIP_SUPPORT */
}

/* Document error classes. */

/*
 * Document-class: Zlib::Error
 *
 * The superclass for all exceptions raised by Ruby/zlib.
 *
 * The following exceptions are defined as subclasses of Zlib::Error. These
 * exceptions are raised when zlib library functions return with an error
 * status.
 *
 * - Zlib::StreamEnd
 * - Zlib::NeedDict
 * - Zlib::DataError
 * - Zlib::StreamError
 * - Zlib::MemError
 * - Zlib::BufError
 * - Zlib::VersionError
 *
 */

/*
 * Document-class: Zlib::GzipFile::Error
 *
 * Base class of errors that occur when processing GZIP files.
 */

/*
 * Document-class: Zlib::GzipFile::NoFooter
 *
 * Raised when gzip file footer is not found. 
 */

/*
 * Document-class: Zlib::GzipFile::CRCError
 *
 * Raised when the CRC checksum recorded in gzip file footer is not equivalent
 * to the CRC checksum of the actual uncompressed data. 
 */

/*
 * Document-class: Zlib::GzipFile::LengthError
 *
 * Raised when the data length recorded in the gzip file footer is not equivalent
 * to the length of the actual uncompressed data. 
 */


</pre>
    </div>