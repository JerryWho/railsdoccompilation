  <div id="fileHeader">
    <h1>olegen.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/ext/win32ole/sample/olegen.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#-----------------------------
# olegen.rb
# $Date: 2007-02-13 08:01:19 +0900 (Tue, 13 Feb 2007) $
# $Revision: 11708 $
#-----------------------------

require 'win32ole'

class WIN32COMGen
  def initialize(typelib)
    @typelib = typelib
    @reciever = &quot;&quot;
  end
  attr_reader :typelib

  def ole_classes(typelib)
    begin
      @ole = WIN32OLE.new(typelib)
      [@ole.ole_obj_help]
    rescue
      WIN32OLE_TYPE.ole_classes(typelib)
    end
  end

  def generate_args(method)
    args = []
    if method.size_opt_params &gt;= 0
      size_required_params = method.size_params - method.size_opt_params
    else
      size_required_params = method.size_params - 1
    end
    size_required_params.times do |i|
      if method.params[i] &amp;&amp; method.params[i].optional?
        args.push &quot;arg#{i}=nil&quot;
      else
        args.push &quot;arg#{i}&quot;
      end
    end
    if method.size_opt_params &gt;= 0
      method.size_opt_params.times do |i|
        args.push &quot;arg#{i + size_required_params}=nil&quot;
      end
    else
      args.push &quot;*arg&quot;
    end
    args.join(&quot;, &quot;)
  end

  def generate_argtype(typedetails)
    ts = ''
    typedetails.each do |t|
      case t
      when 'CARRAY', 'VOID', 'UINT', 'RESULT', 'DECIMAL', 'I8', 'UI8' 
#	  raise &quot;Sorry type\&quot;&quot; + t + &quot;\&quot; not supported&quot;
      ts &lt;&lt; &quot;\&quot;??? NOT SUPPORTED TYPE:`#{t}'\&quot;&quot;
      when 'USERDEFINED', 'Unknown Type 9'
        ts &lt;&lt; 'VT_DISPATCH'
        break;
      when 'SAFEARRAY'
        ts &lt;&lt; 'VT_ARRAY|'
      when 'PTR'
        ts &lt;&lt; 'VT_BYREF|'
      when 'INT'
        ts &lt;&lt; 'VT_I4'
      else
        if String === t
          ts &lt;&lt; 'VT_' + t
        end
      end
    end
    if ts.empty?
      ts = 'VT_VARIANT'
    elsif ts[-1] == ?|
	ts += 'VT_VARIANT'
    end
    ts
  end

  def generate_argtypes(method, proptypes)
    types = method.params.collect{|param|
      generate_argtype(param.ole_type_detail)
    }.join(&quot;, &quot;)
    if proptypes
      types += &quot;, &quot; if types.size &gt; 0 
      types += generate_argtype(proptypes)
    end
    types
  end

  def generate_method_body(method, disptype, types=nil)
    &quot;    ret = #{@reciever}#{disptype}(#{method.dispid}, [&quot; +
    generate_args(method).gsub(&quot;=nil&quot;, &quot;&quot;) +
    &quot;], [&quot; +
    generate_argtypes(method, types) +
    &quot;])\n&quot; +
    &quot;    @lastargs = WIN32OLE::ARGV\n&quot; +
    &quot;    ret&quot;
  end

  def generate_method_help(method, type = nil)
    str = &quot;  # &quot;  
    if type 
      str += type
    else
      str += method.return_type
    end
    str += &quot; #{method.name}&quot;
    if method.event?
      str += &quot; EVENT&quot;
      str += &quot; in #{method.event_interface}&quot;
    end
    if method.helpstring &amp;&amp; method.helpstring != &quot;&quot;
      str += &quot;\n  # &quot;
      str += method.helpstring
    end
    args_help = generate_method_args_help(method)
    if args_help
      str += &quot;\n&quot;
      str += args_help
    end
    str
  end

  def generate_method_args_help(method)
    args = []
    method.params.each_with_index {|param, i|
      h = &quot;  #   #{param.ole_type} arg#{i} --- #{param.name}&quot; 
      inout = []
      inout.push &quot;IN&quot; if param.input?
      inout.push &quot;OUT&quot; if param.output?
      h += &quot; [#{inout.join('/')}]&quot;
      h += &quot; ( = #{param.default})&quot; if param.default
      args.push h
    }
    if args.size &gt; 0
      args.join(&quot;\n&quot;)
    else
      nil
    end
  end

  def generate_method(method, disptype, io = STDOUT, types = nil)
    io.puts &quot;\n&quot;
    io.puts  generate_method_help(method)
    if method.invoke_kind == 'PROPERTYPUT'
      io.print &quot;  def #{method.name}=(&quot;
    else
      io.print &quot;  def #{method.name}(&quot;
    end
    io.print generate_args(method)
    io.puts &quot;)&quot;
    io.puts generate_method_body(method, disptype, types)
    io.puts &quot;  end&quot;
  end

  def generate_propputref_methods(klass, io = STDOUT)
    klass.ole_methods.select {|method|
      method.invoke_kind == 'PROPERTYPUTREF' &amp;&amp; method.visible?
    }.each do |method|
      generate_method(method, io)
    end
  end

  def generate_properties_with_args(klass, io = STDOUT)
    klass.ole_methods.select {|method|
      method.invoke_kind == 'PROPERTYGET' &amp;&amp;
      method.visible? &amp;&amp;
      method.size_params &gt; 0
    }.each do |method|
      types = method.return_type_detail 
      io.puts &quot;\n&quot;
      io.puts  generate_method_help(method, types[0])
      io.puts  &quot;  def #{method.name}&quot;
      if klass.ole_type == &quot;Class&quot;
        io.print &quot;    OLEProperty.new(@dispatch, #{method.dispid}, [&quot; 
      else
        io.print &quot;    OLEProperty.new(self, #{method.dispid}, [&quot; 
      end
      io.print generate_argtypes(method, nil)
      io.print &quot;], [&quot;
      io.print generate_argtypes(method, types)
      io.puts &quot;])&quot;
      io.puts  &quot;  end&quot;
    end
  end

  def generate_propput_methods(klass, io = STDOUT)
    klass.ole_methods.select {|method|
      method.invoke_kind == 'PROPERTYPUT' &amp;&amp; method.visible? &amp;&amp;
      method.size_params == 1
    }.each do |method|
      ms = klass.ole_methods.select {|m|
        m.invoke_kind == 'PROPERTYGET' &amp;&amp;
        m.dispid == method.dispid
      }
      types = []
      if ms.size == 1
        types = ms[0].return_type_detail
      end
      generate_method(method, '_setproperty', io, types)
    end
  end

  def generate_propget_methods(klass, io = STDOUT)
    klass.ole_methods.select {|method|
      method.invoke_kind == 'PROPERTYGET' &amp;&amp; method.visible? &amp;&amp;
      method.size_params == 0
    }.each do |method|
      generate_method(method, '_getproperty', io)
    end
  end

  def generate_func_methods(klass, io = STDOUT)
    klass.ole_methods.select {|method|
      method.invoke_kind == &quot;FUNC&quot; &amp;&amp; method.visible?
    }.each do |method|
      generate_method(method, '_invoke', io)
    end
  end

  def generate_methods(klass, io = STDOUT)
    generate_propget_methods(klass, io)
    generate_propput_methods(klass, io)
    generate_properties_with_args(klass, io)
    generate_func_methods(klass, io)
#   generate_propputref_methods(klass, io)
  end

  def generate_constants(klass, io = STDOUT)
    klass.variables.select {|v|
      v.visible? &amp;&amp; v.variable_kind == 'CONSTANT'
    }.each do |v|
      io.print &quot;  &quot;
      io.print v.name.sub(/^./){|c| c.upcase}
      io.print &quot; = &quot;
      io.puts  v.value
    end
  end

  def class_name(klass)
    klass_name = klass.name
    if klass.ole_type == &quot;Class&quot; &amp;&amp;
       klass.guid &amp;&amp;
       klass.progid
       klass_name = klass.progid.gsub(/\./, '_')
    end
    if /^[A-Z]/ !~ klass_name || Module.constants.include?(klass_name)
      klass_name = 'OLE' + klass_name
    end
    klass_name
  end

  def define_initialize(klass)
    &lt;&lt;STR

  def initialize(obj = nil)
    @clsid = &quot;#{klass.guid}&quot;
    @progid = &quot;#{klass.progid}&quot;
    if obj.nil?
      @dispatch = WIN32OLE.new @progid
    else
      @dispatch = obj
    end
  end
STR
  end

  def define_include
    &quot;  include WIN32OLE::VARIANT&quot;
  end

  def define_instance_variables
    &quot;  attr_reader :lastargs&quot;
  end

  def define_method_missing
    &lt;&lt;STR

  def method_missing(cmd, *arg)
    @dispatch.method_missing(cmd, *arg)
  end
STR
  end

  def define_class(klass, io = STDOUT)
    io.puts &quot;class #{class_name(klass)} # #{klass.name}&quot;
    io.puts define_include
    io.puts define_instance_variables
    io.puts &quot;  attr_reader :dispatch&quot;
    io.puts &quot;  attr_reader :clsid&quot;
    io.puts &quot;  attr_reader :progid&quot;
    io.puts define_initialize(klass)
    io.puts define_method_missing
  end

  def define_module(klass, io = STDOUT)
    io.puts &quot;module #{class_name(klass)}&quot;
    io.puts define_include
    io.puts define_instance_variables
  end

  def generate_class(klass, io = STDOUT)
    io.puts &quot;\n# #{klass.helpstring}&quot;
    if klass.ole_type == &quot;Class&quot; &amp;&amp;
       klass.guid &amp;&amp;
       klass.progid
      @reciever = &quot;@dispatch.&quot;
      define_class(klass, io)
    else
      @reciever = &quot;&quot;
      define_module(klass, io)
    end
    generate_constants(klass, io)
    generate_methods(klass, io)
    io.puts &quot;end&quot;
  end

  def generate(io = STDOUT)
    io.puts &quot;require 'win32ole'&quot;
    io.puts &quot;require 'win32ole/property'&quot;

    ole_classes(typelib).select{|klass|
      klass.visible? &amp;&amp;
      (klass.ole_type == &quot;Class&quot; || 
       klass.ole_type == &quot;Interface&quot; || 
       klass.ole_type == &quot;Dispatch&quot; ||
       klass.ole_type == &quot;Enum&quot;)
    }.each do |klass|
      generate_class(klass, io)
    end
    begin
      @ole.quit if @ole
    rescue 
    end
  end
end

require 'win32ole'
if __FILE__ == $0
  if ARGV.size == 0
    $stderr.puts &quot;usage: #{$0} Type Library [...]&quot;
    exit 1
  end
  ARGV.each do |typelib|
    comgen = WIN32COMGen.new(typelib)
    comgen.generate
  end
end
</pre>
    </div>