  <div id="fileHeader">
    <h1>socket.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/ext/socket/socket.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Apr 14 22:35:55 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/************************************************

  socket.c -

  $Author: nobu $
  $Date: 2008-04-15 12:35:55 +0900 (Tue, 15 Apr 2008) $
  created at: Thu Mar 31 12:21:29 JST 1994

  Copyright (C) 1993-2001 Yukihiro Matsumoto

************************************************/

#include &quot;ruby.h&quot;
#include &quot;rubyio.h&quot;
#include &quot;rubysig.h&quot;
#include &quot;util.h&quot;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;

#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif

#ifdef HAVE_SYS_UIO_H
#include &lt;sys/uio.h&gt;
#endif

#ifndef _WIN32
#if defined(__BEOS__)
# include &lt;net/socket.h&gt;
#else
# include &lt;sys/socket.h&gt;
# define pseudo_AF_FTIP pseudo_AF_RTIP	/* workaround for NetBSD and etc. */
#endif
#include &lt;netinet/in.h&gt;
#ifdef HAVE_NETINET_IN_SYSTM_H
# include &lt;netinet/in_systm.h&gt;
#endif
#ifdef HAVE_NETINET_TCP_H
# include &lt;netinet/tcp.h&gt;
#endif
#ifdef HAVE_NETINET_UDP_H
# include &lt;netinet/udp.h&gt;
#endif
#ifdef HAVE_ARPA_INET_H
# include &lt;arpa/inet.h&gt;
#endif
#include &lt;netdb.h&gt;
#endif
#include &lt;errno.h&gt;
#ifdef HAVE_SYS_UN_H
#include &lt;sys/un.h&gt;
#endif

#if defined(HAVE_FCNTL)
#ifdef HAVE_SYS_SELECT_H
#include &lt;sys/select.h&gt;
#endif
#ifdef HAVE_SYS_TYPES_H
#include &lt;sys/types.h&gt;
#endif
#ifdef HAVE_SYS_TIME_H
#include &lt;sys/time.h&gt;
#endif
#ifdef HAVE_FCNTL_H
#include &lt;fcntl.h&gt;
#endif
#endif
#ifndef EWOULDBLOCK
#define EWOULDBLOCK EAGAIN
#endif
#ifndef HAVE_GETADDRINFO
# include &quot;addrinfo.h&quot;
#endif
#include &quot;sockport.h&quot;

#if defined(__vms)
#include &lt;tcp.h&gt;
#endif

static int do_not_reverse_lookup = 0;

VALUE rb_cBasicSocket;
VALUE rb_cIPSocket;
VALUE rb_cTCPSocket;
VALUE rb_cTCPServer;
VALUE rb_cUDPSocket;
#ifdef AF_UNIX
VALUE rb_cUNIXSocket;
VALUE rb_cUNIXServer;
#endif
VALUE rb_cSocket;

static VALUE rb_eSocket;

#ifdef SOCKS
VALUE rb_cSOCKSSocket;
#ifdef SOCKS5
#include &lt;socks.h&gt;
#else
void SOCKSinit();
int Rconnect();
#endif
#endif

#define INET_CLIENT 0
#define INET_SERVER 1
#define INET_SOCKS  2

#ifndef HAVE_SOCKADDR_STORAGE
/*
 * RFC 2553: protocol-independent placeholder for socket addresses
 */
#define _SS_MAXSIZE	128
#define _SS_ALIGNSIZE	(sizeof(double))
#define _SS_PAD1SIZE	(_SS_ALIGNSIZE - sizeof(unsigned char) * 2)
#define _SS_PAD2SIZE	(_SS_MAXSIZE - sizeof(unsigned char) * 2 - \
				_SS_PAD1SIZE - _SS_ALIGNSIZE)

struct sockaddr_storage {
#ifdef HAVE_SA_LEN
	unsigned char ss_len;		/* address length */
	unsigned char ss_family;	/* address family */
#else
	unsigned short ss_family;
#endif
	char	__ss_pad1[_SS_PAD1SIZE];
	double	__ss_align;	/* force desired structure storage alignment */
	char	__ss_pad2[_SS_PAD2SIZE];
};
#endif

#if defined(INET6) &amp;&amp; (defined(LOOKUP_ORDER_HACK_INET) || defined(LOOKUP_ORDER_HACK_INET6))
#define LOOKUP_ORDERS		3
static int lookup_order_table[LOOKUP_ORDERS] = {
#if defined(LOOKUP_ORDER_HACK_INET)
    PF_INET, PF_INET6, PF_UNSPEC,
#elif defined(LOOKUP_ORDER_HACK_INET6)
    PF_INET6, PF_INET, PF_UNSPEC,
#else
    /* should not happen */
#endif
};

static int
ruby_getaddrinfo(nodename, servname, hints, res)
     char *nodename;
     char *servname;
     struct addrinfo *hints;
     struct addrinfo **res;
{
    struct addrinfo tmp_hints;
    int i, af, error;

    if (hints-&gt;ai_family != PF_UNSPEC) {
	return getaddrinfo(nodename, servname, hints, res);
    }

    for (i = 0; i &lt; LOOKUP_ORDERS; i++) {
	af = lookup_order_table[i];
	MEMCPY(&amp;tmp_hints, hints, struct addrinfo, 1);
	tmp_hints.ai_family = af;
	error = getaddrinfo(nodename, servname, &amp;tmp_hints, res);
	if (error) {
	    if (tmp_hints.ai_family == PF_UNSPEC) {
		break;
	    }
	}
	else {
	    break;
	}
    }

    return error;
}
#define getaddrinfo(node,serv,hints,res) ruby_getaddrinfo((node),(serv),(hints),(res))
#endif

#if defined(_AIX)
static int
ruby_getaddrinfo__aix(nodename, servname, hints, res)
     char *nodename;
     char *servname;
     struct addrinfo *hints;
     struct addrinfo **res;
{
    int error = getaddrinfo(nodename, servname, hints, res);
    struct addrinfo *r;
    if (error)
	return error;
    for (r = *res; r != NULL; r = r-&gt;ai_next) {
	if (r-&gt;ai_addr-&gt;sa_family == 0)
	    r-&gt;ai_addr-&gt;sa_family = r-&gt;ai_family;
	if (r-&gt;ai_addr-&gt;sa_len == 0)
	    r-&gt;ai_addr-&gt;sa_len = r-&gt;ai_addrlen;
    }
    return 0;
}
#undef getaddrinfo
#define getaddrinfo(node,serv,hints,res) ruby_getaddrinfo__aix((node),(serv),(hints),(res))
static int
ruby_getnameinfo__aix(sa, salen, host, hostlen, serv, servlen, flags)
     const struct sockaddr *sa;
     size_t salen;
     char *host;
     size_t hostlen;
     char *serv;
     size_t servlen;
     int flags;
{
  struct sockaddr_in6 *sa6;
  u_int32_t *a6;

  if (sa-&gt;sa_family == AF_INET6) {
    sa6 = (struct sockaddr_in6 *)sa;
    a6 = sa6-&gt;sin6_addr.u6_addr.u6_addr32;

    if (a6[0] == 0 &amp;&amp; a6[1] == 0 &amp;&amp; a6[2] == 0 &amp;&amp; a6[3] == 0) {
      strncpy(host, &quot;::&quot;, hostlen);
      snprintf(serv, servlen, &quot;%d&quot;, sa6-&gt;sin6_port);
      return 0;
    }
  }
  return getnameinfo(sa, salen, host, hostlen, serv, servlen, flags);
}
#undef getnameinfo
#define getnameinfo(sa, salen, host, hostlen, serv, servlen, flags) \
            ruby_getnameinfo__aix((sa), (salen), (host), (hostlen), (serv), (servlen), (flags))
#ifndef CMSG_SPACE
# define CMSG_SPACE(len) (_CMSG_ALIGN(sizeof(struct cmsghdr)) + _CMSG_ALIGN(len))
#endif
#ifndef CMSG_LEN
# define CMSG_LEN(len) (_CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))
#endif
#endif

#ifdef HAVE_CLOSESOCKET
#undef close
#define close closesocket
#endif

static VALUE
init_sock(sock, fd)
    VALUE sock;
    int fd;
{
    rb_io_t *fp;

    MakeOpenFile(sock, fp);
    fp-&gt;f = rb_fdopen(fd, &quot;r&quot;);
    fp-&gt;f2 = rb_fdopen(fd, &quot;w&quot;);
    fp-&gt;mode = FMODE_READWRITE;
    rb_io_synchronized(fp);

    return sock;
}

static VALUE
bsock_s_for_fd(klass, fd)
    VALUE klass, fd;
{
    rb_io_t *fptr;
    VALUE sock = init_sock(rb_obj_alloc(klass), NUM2INT(fd));

    GetOpenFile(sock, fptr);

    return sock;
}

static VALUE
bsock_shutdown(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE howto;
    int how;
    rb_io_t *fptr;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't shutdown socket&quot;);
    }
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;howto);
    if (howto == Qnil)
	how = 2;
    else {
	how = NUM2INT(howto);
	if (how &lt; 0 || 2 &lt; how) {
	    rb_raise(rb_eArgError, &quot;`how' should be either 0, 1, 2&quot;);
	}
    }
    GetOpenFile(sock, fptr);
    if (shutdown(fileno(fptr-&gt;f), how) == -1)
	rb_sys_fail(0);

    return INT2FIX(0);
}

static VALUE
bsock_close_read(sock)
    VALUE sock;
{
    rb_io_t *fptr;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't close socket&quot;);
    }
    GetOpenFile(sock, fptr);
    shutdown(fileno(fptr-&gt;f), 0);
    if (!(fptr-&gt;mode &amp; FMODE_WRITABLE)) {
	return rb_io_close(sock);
    }
    fptr-&gt;mode &amp;= ~FMODE_READABLE;

    return Qnil;
}

static VALUE
bsock_close_write(sock)
    VALUE sock;
{
    rb_io_t *fptr;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't close socket&quot;);
    }
    GetOpenFile(sock, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_READABLE)) {
	return rb_io_close(sock);
    }
    shutdown(fileno(fptr-&gt;f2), 1);
    fptr-&gt;mode &amp;= ~FMODE_WRITABLE;

    return Qnil;
}

/*
 * Document-method: setsockopt
 * call-seq: setsockopt(level, optname, optval)
 *
 * Sets a socket option. These are protocol and system specific, see your
 * local sytem documentation for details.
 *
 * === Parameters
 * * +level+ is an integer, usually one of the SOL_ constants such as
 *   Socket::SOL_SOCKET, or a protocol level.
 * * +optname+ is an integer, usually one of the SO_ constants, such
 *   as Socket::SO_REUSEADDR.
 * * +optval+ is the value of the option, it is passed to the underlying
 *   setsockopt() as a pointer to a certain number of bytes. How this is
 *   done depends on the type:
 *   - Fixnum: value is assigned to an int, and a pointer to the int is
 *     passed, with length of sizeof(int).
 *   - true or false: 1 or 0 (respectively) is assigned to an int, and the
 *     int is passed as for a Fixnum. Note that +false+ must be passed,
 *     not +nil+.
 *   - String: the string's data and length is passed to the socket.
 *
 * === Examples
 *
 * Some socket options are integers with boolean values, in this case
 * #setsockopt could be called like this:
 *   sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
 *
 * Some socket options are integers with numeric values, in this case
 * #setsockopt could be called like this:
 *   sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
 *
 * Option values may be structs. Passing them can be complex as it involves
 * examining your system headers to determine the correct definition. An
 * example is an +ip_mreq+, which may be defined in your system headers as:
 *   struct ip_mreq {
 *     struct  in_addr imr_multiaddr;
 *     struct  in_addr imr_interface;
 *   };
 * 
 * In this case #setsockopt could be called like this:
 *   optval =  IPAddr.new(&quot;224.0.0.251&quot;) + Socket::INADDR_ANY
 *   sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)
 *
*/
static VALUE
bsock_setsockopt(sock, lev, optname, val)
    VALUE sock, lev, optname, val;
{
    int level, option;
    rb_io_t *fptr;
    int i;
    char *v;
    int vlen;

    rb_secure(2);
    level = NUM2INT(lev);
    option = NUM2INT(optname);

    switch (TYPE(val)) {
      case T_FIXNUM:
	i = FIX2INT(val);
	goto numval;
      case T_FALSE:
	i = 0;
	goto numval;
      case T_TRUE:
	i = 1;
      numval:
	v = (char*)&amp;i; vlen = sizeof(i);
	break;
      default:
	StringValue(val);
	v = RSTRING(val)-&gt;ptr;
	vlen = RSTRING(val)-&gt;len;
	break;
    }

    GetOpenFile(sock, fptr);
    if (setsockopt(fileno(fptr-&gt;f), level, option, v, vlen) &lt; 0)
	rb_sys_fail(fptr-&gt;path);

    return INT2FIX(0);
}

/*
 * Document-method: getsockopt
 * call-seq: getsockopt(level, optname)
 *
 * Gets a socket option. These are protocol and system specific, see your
 * local sytem documentation for details. The option is returned as
 * a String with the data being the binary value of the socket option.
 *
 * === Parameters
 * * +level+ is an integer, usually one of the SOL_ constants such as
 *   Socket::SOL_SOCKET, or a protocol level.
 * * +optname+ is an integer, usually one of the SO_ constants, such
 *   as Socket::SO_REUSEADDR.
 *
 * === Examples
 *
 * Some socket options are integers with boolean values, in this case
 * #getsockopt could be called like this:
 *   optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
 *   optval = optval.unpack &quot;i&quot;
 *   reuseaddr = optval[0] == 0 ? false : true
 *
 * Some socket options are integers with numeric values, in this case
 * #getsockopt could be called like this:
 *   optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
 *   ipttl = optval.unpack(&quot;i&quot;)[0]
 *
 * Option values may be structs. Decoding them can be complex as it involves
 * examining your system headers to determine the correct definition. An
 * example is a +struct linger+, which may be defined in your system headers
 * as:
 *   struct linger {
 *     int l_onoff;
 *     int l_linger;
 *   };
 * 
 * In this case #getsockopt could be called like this:
 *   optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
 *   onoff, linger = optval.unpack &quot;ii&quot;
*/
static VALUE
bsock_getsockopt(sock, lev, optname)
    VALUE sock, lev, optname;
{
#if !defined(__BEOS__)
    int level, option;
    socklen_t len;
    char *buf;
    rb_io_t *fptr;

    level = NUM2INT(lev);
    option = NUM2INT(optname);
    len = 256;
    buf = ALLOCA_N(char,len);
    GetOpenFile(sock, fptr);

    GetOpenFile(sock, fptr);
    if (getsockopt(fileno(fptr-&gt;f), level, option, buf, &amp;len) &lt; 0)
	rb_sys_fail(fptr-&gt;path);

    return rb_str_new(buf, len);
#else
    rb_notimplement();
#endif
}

static VALUE
bsock_getsockname(sock)
    VALUE sock;
{
    char buf[1024];
    socklen_t len = sizeof buf;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fileno(fptr-&gt;f), (struct sockaddr*)buf, &amp;len) &lt; 0)
	rb_sys_fail(&quot;getsockname(2)&quot;);
    return rb_str_new(buf, len);
}

static VALUE
bsock_getpeername(sock)
    VALUE sock;
{
    char buf[1024];
    socklen_t len = sizeof buf;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fileno(fptr-&gt;f), (struct sockaddr*)buf, &amp;len) &lt; 0)
	rb_sys_fail(&quot;getpeername(2)&quot;);
    return rb_str_new(buf, len);
}

static VALUE
bsock_send(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE mesg, to;
    VALUE flags;
    rb_io_t *fptr;
    FILE *f;
    int fd, n;

    rb_secure(4);
    rb_scan_args(argc, argv, &quot;21&quot;, &amp;mesg, &amp;flags, &amp;to);

    StringValue(mesg);
    if (!NIL_P(to)) StringValue(to);
    GetOpenFile(sock, fptr);
    f = GetWriteFile(fptr);
    fd = fileno(f);
    rb_thread_fd_writable(fd);
  retry:
    if (!NIL_P(to)) {
        TRAP_BEG;
	n = sendto(fd, RSTRING(mesg)-&gt;ptr, RSTRING(mesg)-&gt;len, NUM2INT(flags),
		   (struct sockaddr*)RSTRING(to)-&gt;ptr, RSTRING(to)-&gt;len);
        TRAP_END;
    }
    else {
        TRAP_BEG;
	n = send(fd, RSTRING(mesg)-&gt;ptr, RSTRING(mesg)-&gt;len, NUM2INT(flags));
        TRAP_END;
    }
    if (n &lt; 0) {
	if (rb_io_wait_writable(fd)) {
	    goto retry;
	}
	rb_sys_fail(&quot;send(2)&quot;);
    }
    return INT2FIX(n);
}

static VALUE ipaddr _((struct sockaddr*));
#ifdef HAVE_SYS_UN_H
static VALUE unixaddr _((struct sockaddr_un*, socklen_t));
#endif

enum sock_recv_type {
    RECV_RECV,			/* BasicSocket#recv(no from) */
    RECV_IP,			/* IPSocket#recvfrom */
    RECV_UNIX,			/* UNIXSocket#recvfrom */
    RECV_SOCKET			/* Socket#recvfrom */
};

static VALUE
s_recvfrom(sock, argc, argv, from)
    VALUE sock;
    int argc;
    VALUE *argv;
    enum sock_recv_type from;
{
    rb_io_t *fptr;
    VALUE str;
    char buf[1024];
    socklen_t alen = sizeof buf;
    VALUE len, flg;
    long buflen;
    long slen;
    int fd, flags;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;len, &amp;flg);

    if (flg == Qnil) flags = 0;
    else             flags = NUM2INT(flg);
    buflen = NUM2INT(len);

    GetOpenFile(sock, fptr);
    if (rb_read_pending(fptr-&gt;f)) {
	rb_raise(rb_eIOError, &quot;recv for buffered IO&quot;);
    }
    fd = fileno(fptr-&gt;f);

    str = rb_tainted_str_new(0, buflen);

  retry:
    rb_str_locktmp(str);
    rb_thread_wait_fd(fd);
    TRAP_BEG;
    slen = recvfrom(fd, RSTRING(str)-&gt;ptr, buflen, flags, (struct sockaddr*)buf, &amp;alen);
    TRAP_END;
    rb_str_unlocktmp(str);

    if (slen &lt; 0) {
	if (rb_io_wait_readable(fd)) {
	    goto retry;
	}
	rb_sys_fail(&quot;recvfrom(2)&quot;);
    }
    if (slen &lt; RSTRING(str)-&gt;len) {
	RSTRING(str)-&gt;len = slen;
	RSTRING(str)-&gt;ptr[slen] = '\0';
    }
    rb_obj_taint(str);
    switch (from) {
      case RECV_RECV:
	return (VALUE)str;
      case RECV_IP:
#if 0
	if (alen != sizeof(struct sockaddr_in)) {
	    rb_raise(rb_eTypeError, &quot;sockaddr size differs - should not happen&quot;);
	}
#endif
	if (alen &amp;&amp; alen != sizeof(buf)) /* OSX doesn't return a 'from' result from recvfrom for connection-oriented sockets */
	    return rb_assoc_new(str, ipaddr((struct sockaddr*)buf));
	else
	    return rb_assoc_new(str, Qnil);

#ifdef HAVE_SYS_UN_H
      case RECV_UNIX:
        return rb_assoc_new(str, unixaddr((struct sockaddr_un*)buf, alen));
#endif
      case RECV_SOCKET:
	return rb_assoc_new(str, rb_str_new(buf, alen));
      default:
	rb_bug(&quot;s_recvfrom called with bad value&quot;);
    }
}

static VALUE
s_recvfrom_nonblock(VALUE sock, int argc, VALUE *argv, enum sock_recv_type from)
{
    rb_io_t *fptr;
    VALUE str;
    char buf[1024];
    socklen_t alen = sizeof buf;
    VALUE len, flg;
    long buflen;
    long slen;
    int fd, flags;
    VALUE addr = Qnil;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;len, &amp;flg);

    if (flg == Qnil) flags = 0;
    else             flags = NUM2INT(flg);
    buflen = NUM2INT(len);

#ifdef MSG_DONTWAIT
    /* MSG_DONTWAIT avoids the race condition between fcntl and recvfrom.
       It is not portable, though. */
    flags |= MSG_DONTWAIT;
#endif

    GetOpenFile(sock, fptr);
    if (rb_read_pending(fptr-&gt;f)) {
	rb_raise(rb_eIOError, &quot;recvfrom for buffered IO&quot;);
    }
    fd = fileno(fptr-&gt;f);

    str = rb_tainted_str_new(0, buflen);

    rb_io_check_closed(fptr);
    rb_io_set_nonblock(fptr);
    slen = recvfrom(fd, RSTRING(str)-&gt;ptr, buflen, flags, (struct sockaddr*)buf, &amp;alen);

    if (slen &lt; 0) {
	rb_sys_fail(&quot;recvfrom(2)&quot;);
    }
    if (slen &lt; RSTRING(str)-&gt;len) {
	RSTRING(str)-&gt;len = slen;
	RSTRING(str)-&gt;ptr[slen] = '\0';
    }
    rb_obj_taint(str);
    switch (from) {
      case RECV_RECV:
	return str;

      case RECV_IP:
        if (alen &amp;&amp; alen != sizeof(buf)) /* connection-oriented socket may not return a from result */
            addr = ipaddr((struct sockaddr*)buf);
        break;

      case RECV_SOCKET:
        addr = rb_str_new(buf, alen);
        break;

      default:
        rb_bug(&quot;s_recvfrom_nonblock called with bad value&quot;);
    }
    return rb_assoc_new(str, addr);
}

static VALUE
bsock_recv(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_RECV);
}

/*
 * call-seq:
 * 	basicsocket.recv_nonblock(maxlen) =&gt; mesg
 * 	basicsocket.recv_nonblock(maxlen, flags) =&gt; mesg
 * 
 * Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * _flags_ is zero or more of the +MSG_+ options.
 * The result, _mesg_, is the data received.
 *
 * When recvfrom(2) returns 0, Socket#recv_nonblock returns
 * an empty string as data.
 * The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.
 * 
 * === Parameters
 * * +maxlen+ - the number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options 
 * 
 * === Example
 * 	serv = TCPServer.new(&quot;127.0.0.1&quot;, 0)
 * 	af, port, host, addr = serv.addr
 * 	c = TCPSocket.new(addr, port)
 * 	s = serv.accept
 * 	c.send &quot;aaa&quot;, 0
 * 	IO.select([s])
 * 	p s.recv_nonblock(10) #=&gt; &quot;aaa&quot;
 *
 * Refer to Socket#recvfrom for the exceptions that may be thrown if the call
 * to _recv_nonblock_ fails. 
 *
 * BasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2) failure,
 * including Errno::EAGAIN.
 *
 * === See
 * * Socket#recvfrom
 */

static VALUE
bsock_recv_nonblock(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom_nonblock(sock, argc, argv, RECV_RECV);
}

static VALUE
bsock_do_not_rev_lookup()
{
    return do_not_reverse_lookup?Qtrue:Qfalse;
}

static VALUE
bsock_do_not_rev_lookup_set(self, val)
    VALUE self, val;
{
    rb_secure(4);
    do_not_reverse_lookup = RTEST(val);
    return val;
}

static void
make_ipaddr0(addr, buf, len)
    struct sockaddr *addr;
    char *buf;
    size_t len;
{
    int error;

    error = getnameinfo(addr, SA_LEN(addr), buf, len, NULL, 0, NI_NUMERICHOST);
    if (error) {
	rb_raise(rb_eSocket, &quot;getnameinfo: %s&quot;, gai_strerror(error));
    }
}

static VALUE
make_ipaddr(addr)
    struct sockaddr *addr;
{
    char buf[1024];

    make_ipaddr0(addr, buf, sizeof(buf));
    return rb_str_new2(buf);
}

static void
make_inetaddr(host, buf, len)
    long host;
    char *buf;
    size_t len;
{
    struct sockaddr_in sin;

    MEMZERO(&amp;sin, struct sockaddr_in, 1);
    sin.sin_family = AF_INET;
    SET_SIN_LEN(&amp;sin, sizeof(sin));
    sin.sin_addr.s_addr = host;
    make_ipaddr0((struct sockaddr*)&amp;sin, buf, len);
}

static int
str_isnumber(p)
        const char *p;
{
    char *ep;

    if (!p || *p == '\0')
       return 0;
    ep = NULL;
    (void)strtoul(p, &amp;ep, 10);
    if (ep &amp;&amp; *ep == '\0')
       return 1;
    else
       return 0;
}

static char *
host_str(host, hbuf, len)
    VALUE host;
    char *hbuf;
    size_t len;
{
    if (NIL_P(host)) {
	return NULL;
    }
    else if (rb_obj_is_kind_of(host, rb_cInteger)) {
	long i = NUM2LONG(host);

	make_inetaddr(htonl(i), hbuf, len);
	return hbuf;
    }
    else {
	char *name;

	SafeStringValue(host);
	name = RSTRING(host)-&gt;ptr;
	if (!name || *name == 0 || (name[0] == '&lt;' &amp;&amp; strcmp(name, &quot;&lt;any&gt;&quot;) == 0)) {
	    make_inetaddr(INADDR_ANY, hbuf, len);
	}
	else if (name[0] == '&lt;' &amp;&amp; strcmp(name, &quot;&lt;broadcast&gt;&quot;) == 0) {
	    make_inetaddr(INADDR_BROADCAST, hbuf, len);
	}
	else if (strlen(name) &gt;= len) {
	    rb_raise(rb_eArgError, &quot;hostname too long (%d)&quot;, strlen(name));
	}
	else {
	    strcpy(hbuf, name);
	}
	return hbuf;
    }
}

static char *
port_str(port, pbuf, len)
    VALUE port;
    char *pbuf;
    size_t len;
{
    if (NIL_P(port)) {
	return 0;
    }
    else if (FIXNUM_P(port)) {
	snprintf(pbuf, len, &quot;%ld&quot;, FIX2LONG(port));
	return pbuf;
    }
    else {
	char *serv;

	SafeStringValue(port);
	serv = RSTRING(port)-&gt;ptr;
	if (strlen(serv) &gt;= len) {
	    rb_raise(rb_eArgError, &quot;service name too long (%d)&quot;, strlen(serv));
	}
	strcpy(pbuf, serv);
	return pbuf;
    }
}

#ifndef NI_MAXHOST
# define 1025
#endif
#ifndef NI_MAXSERV
# define 32
#endif

static struct addrinfo*
sock_addrinfo(host, port, socktype, flags)
    VALUE host, port;
    int socktype, flags;
{
    struct addrinfo hints;
    struct addrinfo* res = NULL;
    char *hostp, *portp;
    int error;
    char hbuf[NI_MAXHOST], pbuf[NI_MAXSERV];

    hostp = host_str(host, hbuf, sizeof(hbuf));
    portp = port_str(port, pbuf, sizeof(pbuf));

    if (socktype == 0 &amp;&amp; flags == 0 &amp;&amp; str_isnumber(portp)) {
       socktype = SOCK_DGRAM;
    }

    MEMZERO(&amp;hints, struct addrinfo, 1);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = socktype;
    hints.ai_flags = flags;
    error = getaddrinfo(hostp, portp, &amp;hints, &amp;res);
    if (error) {
	if (hostp &amp;&amp; hostp[strlen(hostp)-1] == '\n') {
	    rb_raise(rb_eSocket, &quot;newline at the end of hostname&quot;);
	}
	rb_raise(rb_eSocket, &quot;getaddrinfo: %s&quot;, gai_strerror(error));
    }

#if defined(__APPLE__) &amp;&amp; defined(__MACH__)
    {
        struct addrinfo *r;
       r = res;
       while (r) {
            if (! r-&gt;ai_socktype) r-&gt;ai_socktype = hints.ai_socktype;
            if (! r-&gt;ai_protocol) {
                if (r-&gt;ai_socktype == SOCK_DGRAM) {
                    r-&gt;ai_protocol = IPPROTO_UDP;
                } else if (r-&gt;ai_socktype == SOCK_STREAM) {
                    r-&gt;ai_protocol = IPPROTO_TCP;
                }
            }
            r = r-&gt;ai_next;
        }
    }
#endif
    return res;
}

static VALUE
ipaddr(sockaddr)
    struct sockaddr *sockaddr;
{
    VALUE family, port, addr1, addr2;
    VALUE ary;
    int error;
    char hbuf[1024], pbuf[1024];

    switch (sockaddr-&gt;sa_family) {
    case AF_UNSPEC:
	family = rb_str_new2(&quot;AF_UNSPEC&quot;);
	break;
    case AF_INET:
	family = rb_str_new2(&quot;AF_INET&quot;);
	break;
#ifdef INET6
    case AF_INET6:
	family = rb_str_new2(&quot;AF_INET6&quot;);
	break;
#endif
#ifdef AF_LOCAL
    case AF_LOCAL:
	family = rb_str_new2(&quot;AF_LOCAL&quot;);
	break;
#elif  AF_UNIX
    case AF_UNIX:
	family = rb_str_new2(&quot;AF_UNIX&quot;);
	break;
#endif
    default:
        sprintf(pbuf, &quot;unknown:%d&quot;, sockaddr-&gt;sa_family);
	family = rb_str_new2(pbuf);
	break;
    }
    addr1 = Qnil;
    if (!do_not_reverse_lookup) {
	error = getnameinfo(sockaddr, SA_LEN(sockaddr), hbuf, sizeof(hbuf),
			    NULL, 0, 0);
	if (! error) {
	    addr1 = rb_str_new2(hbuf);
	}
    }
    error = getnameinfo(sockaddr, SA_LEN(sockaddr), hbuf, sizeof(hbuf),
			pbuf, sizeof(pbuf), NI_NUMERICHOST | NI_NUMERICSERV);
    if (error) {
	rb_raise(rb_eSocket, &quot;getnameinfo: %s&quot;, gai_strerror(error));
    }
    addr2 = rb_str_new2(hbuf);
    if (addr1 == Qnil) {
	addr1 = addr2;
    }
    port = INT2FIX(atoi(pbuf));
    ary = rb_ary_new3(4, family, port, addr1, addr2);

    return ary;
}

static int
ruby_socket(domain, type, proto)
    int domain, type, proto;
{
    int fd;

    fd = socket(domain, type, proto);
    if (fd &lt; 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = socket(domain, type, proto);
	}
    }
    return fd;
}

static int
wait_connectable(fd)
    int fd;
{
    int sockerr;
    socklen_t sockerrlen;
    fd_set fds_w;
    fd_set fds_e;

    for (;;) {
	FD_ZERO(&amp;fds_w);
	FD_ZERO(&amp;fds_e);

	FD_SET(fd, &amp;fds_w);
	FD_SET(fd, &amp;fds_e);

	rb_thread_select(fd+1, 0, &amp;fds_w, &amp;fds_e, 0);

	if (FD_ISSET(fd, &amp;fds_w)) {
	    return 0;
	}
	else if (FD_ISSET(fd, &amp;fds_e)) {
	    sockerrlen = sizeof(sockerr);
	    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *)&amp;sockerr,
			   &amp;sockerrlen) == 0) {
		if (sockerr == 0)
		    continue;	/* workaround for winsock */
		errno = sockerr;
	    }
	    return -1;
	}
    }

    return 0;
}

#ifdef __CYGWIN__
#define WAIT_IN_PROGRESS 10
#endif
#ifdef __APPLE__
#define WAIT_IN_PROGRESS 10
#endif
#ifdef __linux__
/* returns correct error */
#define WAIT_IN_PROGRESS 0
#endif
#ifndef WAIT_IN_PROGRESS
/* BSD origin code apparently has a problem */
#define WAIT_IN_PROGRESS 1
#endif

static int
ruby_connect(fd, sockaddr, len, socks)
    int fd;
    struct sockaddr *sockaddr;
    int len;
    int socks;
{
    int status;
    int mode;
#if WAIT_IN_PROGRESS &gt; 0
    int wait_in_progress = -1;
    int sockerr;
    socklen_t sockerrlen;
#endif

#if defined(HAVE_FCNTL)
# if defined(F_GETFL)
    mode = fcntl(fd, F_GETFL, 0);
# else
    mode = 0;
# endif

#ifdef O_NDELAY
# define NONBLOCKING O_NDELAY
#else
#ifdef O_NBIO
# define NONBLOCKING O_NBIO
#else
# define NONBLOCKING O_NONBLOCK
#endif
#endif
#ifdef SOCKS5
    if (!socks)
#endif
    fcntl(fd, F_SETFL, mode|NONBLOCKING);
#endif /* HAVE_FCNTL */

    for (;;) {
#if defined(SOCKS) &amp;&amp; !defined(SOCKS5)
	if (socks) {
	    status = Rconnect(fd, sockaddr, len);
	}
	else
#endif
	{
	    status = connect(fd, sockaddr, len);
	}
	if (status &lt; 0) {
	    switch (errno) {
	      case EAGAIN:
#ifdef EINPROGRESS
	      case EINPROGRESS:
#endif
#if WAIT_IN_PROGRESS &gt; 0
		sockerrlen = sizeof(sockerr);
		status = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *)&amp;sockerr, &amp;sockerrlen);
		if (status) break;
		if (sockerr) {
		    status = -1;
		    errno = sockerr;
		    break;
		}
#endif
#ifdef EALREADY
	      case EALREADY:
#endif
#if WAIT_IN_PROGRESS &gt; 0
		wait_in_progress = WAIT_IN_PROGRESS;
#endif
		status = wait_connectable(fd);
		if (status) {
		    break;
		}
		errno = 0;
		continue;

#if WAIT_IN_PROGRESS &gt; 0
	      case EINVAL:
		if (wait_in_progress-- &gt; 0) {
		    /*
		     * connect() after EINPROGRESS returns EINVAL on
		     * some platforms, need to check true error
		     * status.
		     */
		    sockerrlen = sizeof(sockerr);
		    status = getsockopt(fd, SOL_SOCKET, SO_ERROR, (void *)&amp;sockerr, &amp;sockerrlen);
		    if (!status &amp;&amp; !sockerr) {
			struct timeval tv = {0, 100000};
			rb_thread_wait_for(tv);
			continue;
		    }
		    status = -1;
		    errno = sockerr;
		}
		break;
#endif

#ifdef EISCONN
	      case EISCONN:
		status = 0;
		errno = 0;
		break;
#endif
	      default:
		break;
	    }
	}
#ifdef HAVE_FCNTL
	fcntl(fd, F_SETFL, mode);
#endif
	return status;
    }
}

struct inetsock_arg
{
    VALUE sock;
    struct {
	VALUE host, serv;
	struct addrinfo *res;
    } remote, local;
    int type;
    int fd;
};

static VALUE
inetsock_cleanup(arg)
    struct inetsock_arg *arg;
{
    if (arg-&gt;remote.res) {
	freeaddrinfo(arg-&gt;remote.res);
	arg-&gt;remote.res = 0;
    }
    if (arg-&gt;local.res) {
	freeaddrinfo(arg-&gt;local.res);
	arg-&gt;local.res = 0;
    }
    if (arg-&gt;fd &gt;= 0) {
	close(arg-&gt;fd);
    }
    return Qnil;
}

static VALUE
init_inetsock_internal(arg)
    struct inetsock_arg *arg;
{
    int type = arg-&gt;type;
    struct addrinfo *res;
    int fd, status = 0;
    char *syscall;

    arg-&gt;remote.res = sock_addrinfo(arg-&gt;remote.host, arg-&gt;remote.serv, SOCK_STREAM,
				    (type == INET_SERVER) ? AI_PASSIVE : 0);
    /*
     * Maybe also accept a local address
     */

    if (type != INET_SERVER &amp;&amp; (!NIL_P(arg-&gt;local.host) || !NIL_P(arg-&gt;local.serv))) {
	arg-&gt;local.res = sock_addrinfo(arg-&gt;local.host, arg-&gt;local.serv, SOCK_STREAM, 0);
    }

    arg-&gt;fd = fd = -1;
    for (res = arg-&gt;remote.res; res; res = res-&gt;ai_next) {
	status = ruby_socket(res-&gt;ai_family,res-&gt;ai_socktype,res-&gt;ai_protocol);
	syscall = &quot;socket(2)&quot;;
	fd = status;
	if (fd &lt; 0) {
	    continue;
	}
	arg-&gt;fd = fd;
	if (type == INET_SERVER) {
#if !defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)
	    status = 1;
	    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,
		       (char*)&amp;status, sizeof(status));
#endif
	    status = bind(fd, res-&gt;ai_addr, res-&gt;ai_addrlen);
	    syscall = &quot;bind(2)&quot;;
	}
	else {
	    if (arg-&gt;local.res) {
		status = bind(fd, arg-&gt;local.res-&gt;ai_addr, arg-&gt;local.res-&gt;ai_addrlen);
		syscall = &quot;bind(2)&quot;;
	    }

	    if (status &gt;= 0) {
		status = ruby_connect(fd, res-&gt;ai_addr, res-&gt;ai_addrlen,
				      (type == INET_SOCKS));
		syscall = &quot;connect(2)&quot;;
	    }
	}

	if (status &lt; 0) {
	    close(fd);
	    arg-&gt;fd = fd = -1;
	    continue;
	} else
	    break;
    }
    if (status &lt; 0) {
	rb_sys_fail(syscall);
    }

    arg-&gt;fd = -1;

    if (type == INET_SERVER)
	listen(fd, 5);

    /* create new instance */
    return init_sock(arg-&gt;sock, fd);
}

static VALUE
init_inetsock(sock, remote_host, remote_serv, local_host, local_serv, type)
    VALUE sock, remote_host, remote_serv, local_host, local_serv;
    int type;
{
    struct inetsock_arg arg;
    arg.sock = sock;
    arg.remote.host = remote_host;
    arg.remote.serv = remote_serv;
    arg.remote.res = 0;
    arg.local.host = local_host;
    arg.local.serv = local_serv;
    arg.local.res = 0;
    arg.type = type;
    arg.fd = -1;
    return rb_ensure(init_inetsock_internal, (VALUE)&amp;arg,
		     inetsock_cleanup, (VALUE)&amp;arg);
}

/*
 * call-seq:
 *    TCPSocket.new(remote_host, remote_port, local_host=nil, local_port=nil)
 *
 * Opens a TCP connection to +remote_host+ on +remote_port+.  If +local_host+
 * and +local_port+ are specified, then those parameters are used on the local
 * end to establish the connection.
 */
static VALUE
tcp_init(argc, argv, sock)
     int argc;
     VALUE *argv;
     VALUE sock;
{
    VALUE remote_host, remote_serv;
    VALUE local_host, local_serv;

    rb_scan_args(argc, argv, &quot;22&quot;, &amp;remote_host, &amp;remote_serv,
			&amp;local_host, &amp;local_serv);

    return init_inetsock(sock, remote_host, remote_serv,
			local_host, local_serv, INET_CLIENT);
}

#ifdef SOCKS
static VALUE
socks_init(sock, host, serv)
    VALUE sock, host, serv;
{
    static init = 0;

    if (init == 0) {
	SOCKSinit(&quot;ruby&quot;);
	init = 1;
    }

    return init_inetsock(sock, host, serv, Qnil, Qnil, INET_SOCKS);
}

#ifdef SOCKS5
static VALUE
socks_s_close(sock)
    VALUE sock;
{
    rb_io_t *fptr;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(sock)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't close socket&quot;);
    }
    GetOpenFile(sock, fptr);
    shutdown(fileno(fptr-&gt;f), 2);
    shutdown(fileno(fptr-&gt;f2), 2);
    return rb_io_close(sock);
}
#endif
#endif

struct hostent_arg {
    VALUE host;
    struct addrinfo* addr;
    VALUE (*ipaddr)_((struct sockaddr*, size_t));
};

static VALUE
make_hostent_internal(arg)
    struct hostent_arg *arg;
{
    VALUE host = arg-&gt;host;
    struct addrinfo* addr = arg-&gt;addr;
    VALUE (*ipaddr)_((struct sockaddr*, size_t)) = arg-&gt;ipaddr;

    struct addrinfo *ai;
    struct hostent *h;
    VALUE ary, names;
    char **pch;
    const char* hostp;
    char hbuf[NI_MAXHOST];

    ary = rb_ary_new();
    if (addr-&gt;ai_canonname) {
	hostp = addr-&gt;ai_canonname;
    }
    else {
	hostp = host_str(host, hbuf, sizeof(hbuf));
    }
    rb_ary_push(ary, rb_str_new2(hostp));

    if (addr-&gt;ai_canonname &amp;&amp; (h = gethostbyname(addr-&gt;ai_canonname))) {
	names = rb_ary_new();
	if (h-&gt;h_aliases != NULL) {
	    for (pch = h-&gt;h_aliases; *pch; pch++) {
		rb_ary_push(names, rb_str_new2(*pch));
	    }
	}
    }
    else {
	names = rb_ary_new2(0);
    }
    rb_ary_push(ary, names);
    rb_ary_push(ary, INT2NUM(addr-&gt;ai_family));
    for (ai = addr; ai; ai = ai-&gt;ai_next) {
      /* Pushing all addresses regardless of address family is not the
       * behaviour expected of gethostbyname(). All the addresses in struct
       * hostent-&gt;h_addr_list must be of the same family.
       */
       if(ai-&gt;ai_family == addr-&gt;ai_family) {
	   rb_ary_push(ary, (*ipaddr)(ai-&gt;ai_addr, ai-&gt;ai_addrlen));
       }
    }

    return ary;
}

static VALUE
make_hostent(host, addr, ipaddr)
    VALUE host;
    struct addrinfo* addr;
    VALUE (*ipaddr)_((struct sockaddr*, size_t));
{
    struct hostent_arg arg;

    arg.host = host;
    arg.addr = addr;
    arg.ipaddr = ipaddr;
    return rb_ensure(make_hostent_internal, (VALUE)&amp;arg,
		     RUBY_METHOD_FUNC(freeaddrinfo), (VALUE)addr);
}

VALUE
tcp_sockaddr(addr, len)
    struct sockaddr *addr;
    size_t len;
{
    return make_ipaddr(addr);
}

static VALUE
tcp_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    rb_secure(3);
    return make_hostent(host, sock_addrinfo(host, Qnil, SOCK_STREAM, AI_CANONNAME), tcp_sockaddr);
}

static VALUE
tcp_svr_init(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE arg1, arg2;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;arg1, &amp;arg2) == 2)
	return init_inetsock(sock, arg1, arg2, Qnil, Qnil, INET_SERVER);
    else
	return init_inetsock(sock, Qnil, arg1, Qnil, Qnil, INET_SERVER);
}

static void
make_fd_nonblock(int fd)
{
    int flags;
#ifdef F_GETFL
    flags = fcntl(fd, F_GETFL);
    if (flags == -1) {
        rb_sys_fail(0);
    }
#else
    flags = 0;
#endif
    flags |= O_NONBLOCK;
    if (fcntl(fd, F_SETFL, flags) == -1) {
        rb_sys_fail(0);
    }
}

static VALUE
s_accept_nonblock(VALUE klass, rb_io_t *fptr, struct sockaddr *sockaddr, socklen_t *len)
{
    int fd2;

    rb_secure(3);
    rb_io_set_nonblock(fptr);
    fd2 = accept(fileno(fptr-&gt;f), (struct sockaddr*)sockaddr, len);
    if (fd2 &lt; 0) {
        rb_sys_fail(&quot;accept(2)&quot;);
    }
    make_fd_nonblock(fd2);
    return init_sock(rb_obj_alloc(klass), fd2);
}

static VALUE
s_accept(klass, fd, sockaddr, len)
    VALUE klass;
    int fd;
    struct sockaddr *sockaddr;
    socklen_t *len;
{
    int fd2;
    int retry = 0;

    rb_secure(3);
  retry:
    rb_thread_wait_fd(fd);
#if defined(_nec_ews)
    fd2 = accept(fd, sockaddr, len);
#else
    TRAP_BEG;
    fd2 = accept(fd, sockaddr, len);
    TRAP_END;
#endif
    if (fd2 &lt; 0) {
	switch (errno) {
	  case EMFILE:
	  case ENFILE:
	    if (retry) break;
	    rb_gc();
	    retry = 1;
	    goto retry;
	  case EWOULDBLOCK:
	    break;
	  default:
	    if (!rb_io_wait_readable(fd)) break;
	    retry = 0;
	    goto retry;
	}
	rb_sys_fail(0);
    }
    if (!klass) return INT2NUM(fd2);
    return init_sock(rb_obj_alloc(klass), fd2);
}

static VALUE
tcp_accept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_storage from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(from);
    return s_accept(rb_cTCPSocket, fileno(fptr-&gt;f),
		    (struct sockaddr*)&amp;from, &amp;fromlen);
}

/*
 * call-seq:
 * 	tcpserver.accept_nonblock =&gt; tcpsocket
 * 
 * Accepts an incoming connection using accept(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * It returns an accepted TCPSocket for the incoming connection.
 * 
 * === Example
 * 	require 'socket'
 * 	serv = TCPServer.new(2202)
 * 	begin
 * 	  sock = serv.accept_nonblock
 * 	rescue Errno::EAGAIN, Errno::EWOULDBLOCK, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
 * 	  IO.select([serv])
 * 	  retry
 * 	end
 * 	# sock is an accepted socket.
 * 
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to TCPServer#accept_nonblock fails. 
 *
 * TCPServer#accept_nonblock may raise any error corresponding to accept(2) failure,
 * including Errno::EAGAIN.
 * 
 * === See
 * * TCPServer#accept
 * * Socket#accept
 */
static VALUE
tcp_accept_nonblock(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_storage from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(from);
    return s_accept_nonblock(rb_cTCPSocket, fptr,
                             (struct sockaddr *)&amp;from, &amp;fromlen);
}

static VALUE
tcp_sysaccept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_storage from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(from);
    return s_accept(0, fileno(fptr-&gt;f), (struct sockaddr*)&amp;from, &amp;fromlen);
}

#ifdef HAVE_SYS_UN_H
struct unixsock_arg {
    struct sockaddr_un *sockaddr;
    int fd;
};

static VALUE
unixsock_connect_internal(arg)
    struct unixsock_arg *arg;
{
    return (VALUE)ruby_connect(arg-&gt;fd, arg-&gt;sockaddr, sizeof(*arg-&gt;sockaddr),
			       0);
}

static VALUE
init_unixsock(sock, path, server)
    VALUE sock;
    VALUE path;
    int server;
{
    struct sockaddr_un sockaddr;
    int fd, status;
    rb_io_t *fptr;

    SafeStringValue(path);
    fd = ruby_socket(AF_UNIX, SOCK_STREAM, 0);
    if (fd &lt; 0) {
	rb_sys_fail(&quot;socket(2)&quot;);
    }

    MEMZERO(&amp;sockaddr, struct sockaddr_un, 1);
    sockaddr.sun_family = AF_UNIX;
    if (sizeof(sockaddr.sun_path) &lt;= RSTRING(path)-&gt;len) {
        rb_raise(rb_eArgError, &quot;too long unix socket path (max: %dbytes)&quot;,
            (int)sizeof(sockaddr.sun_path)-1);
    }
    strcpy(sockaddr.sun_path, StringValueCStr(path));

    if (server) {
        status = bind(fd, (struct sockaddr*)&amp;sockaddr, sizeof(sockaddr));
    }
    else {
	int prot;
	struct unixsock_arg arg;
	arg.sockaddr = &amp;sockaddr;
	arg.fd = fd;
        status = rb_protect(unixsock_connect_internal, (VALUE)&amp;arg, &amp;prot);
	if (prot) {
	    close(fd);
	    rb_jump_tag(prot);
	}
    }

    if (status &lt; 0) {
	close(fd);
	rb_sys_fail(sockaddr.sun_path);
    }

    if (server) listen(fd, 5);

    init_sock(sock, fd);
    GetOpenFile(sock, fptr);
    if (server) {
        fptr-&gt;path = strdup(RSTRING(path)-&gt;ptr);
    }

    return sock;
}
#endif

static VALUE
ip_addr(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_storage addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getsockname(fileno(fptr-&gt;f), (struct sockaddr*)&amp;addr, &amp;len) &lt; 0)
	rb_sys_fail(&quot;getsockname(2)&quot;);
    return ipaddr((struct sockaddr*)&amp;addr);
}

static VALUE
ip_peeraddr(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_storage addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getpeername(fileno(fptr-&gt;f), (struct sockaddr*)&amp;addr, &amp;len) &lt; 0)
	rb_sys_fail(&quot;getpeername(2)&quot;);
    return ipaddr((struct sockaddr*)&amp;addr);
}

static VALUE
ip_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_IP);
}

static VALUE
ip_s_getaddress(obj, host)
    VALUE obj, host;
{
    struct sockaddr_storage addr;
    struct addrinfo *res = sock_addrinfo(host, Qnil, SOCK_STREAM, 0);

    /* just take the first one */
    memcpy(&amp;addr, res-&gt;ai_addr, res-&gt;ai_addrlen);
    freeaddrinfo(res);

    return make_ipaddr((struct sockaddr*)&amp;addr);
}

static VALUE
udp_init(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE arg;
    int socktype = AF_INET;
    int fd;

    rb_secure(3);
    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;arg) == 1) {
	socktype = NUM2INT(arg);
    }
    fd = ruby_socket(socktype, SOCK_DGRAM, 0);
    if (fd &lt; 0) {
	rb_sys_fail(&quot;socket(2) - udp&quot;);
    }

    return init_sock(sock, fd);
}

struct udp_arg
{
    struct addrinfo *res;
    int fd;
};

static VALUE
udp_connect_internal(arg)
    struct udp_arg *arg;
{
    int fd = arg-&gt;fd;
    struct addrinfo *res;

    for (res = arg-&gt;res; res; res = res-&gt;ai_next) {
	if (ruby_connect(fd, res-&gt;ai_addr, res-&gt;ai_addrlen, 0) &gt;= 0) {
	    return Qtrue;
	}
    }
    return Qfalse;
}

static VALUE
udp_connect(sock, host, port)
    VALUE sock, host, port;
{
    rb_io_t *fptr;
    struct udp_arg arg;
    VALUE ret;

    rb_secure(3);
    arg.res = sock_addrinfo(host, port, SOCK_DGRAM, 0);
    GetOpenFile(sock, fptr);
    arg.fd = fileno(fptr-&gt;f);
    ret = rb_ensure(udp_connect_internal, (VALUE)&amp;arg,
		    RUBY_METHOD_FUNC(freeaddrinfo), (VALUE)arg.res);
    if (!ret) rb_sys_fail(&quot;connect(2)&quot;);
    return INT2FIX(0);
}

static VALUE
udp_bind(sock, host, port)
    VALUE sock, host, port;
{
    rb_io_t *fptr;
    struct addrinfo *res0, *res;

    rb_secure(3);
    res0 = sock_addrinfo(host, port, SOCK_DGRAM, 0);
    GetOpenFile(sock, fptr);
    for (res = res0; res; res = res-&gt;ai_next) {
	if (bind(fileno(fptr-&gt;f), res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) {
	    continue;
	}
	freeaddrinfo(res0);
	return INT2FIX(0);
    }
    freeaddrinfo(res0);
    rb_sys_fail(&quot;bind(2)&quot;);
    return INT2FIX(0);
}

static VALUE
udp_send(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    VALUE mesg, flags, host, port;
    rb_io_t *fptr;
    FILE *f;
    int n;
    struct addrinfo *res0, *res;

    if (argc == 2 || argc == 3) {
	return bsock_send(argc, argv, sock);
    }
    rb_secure(4);
    rb_scan_args(argc, argv, &quot;4&quot;, &amp;mesg, &amp;flags, &amp;host, &amp;port);

    StringValue(mesg);
    res0 = sock_addrinfo(host, port, SOCK_DGRAM, 0);
    GetOpenFile(sock, fptr);
    f = GetWriteFile(fptr);
    for (res = res0; res; res = res-&gt;ai_next) {
      retry:
	n = sendto(fileno(f), RSTRING(mesg)-&gt;ptr, RSTRING(mesg)-&gt;len, NUM2INT(flags),
		   res-&gt;ai_addr, res-&gt;ai_addrlen);
	if (n &gt;= 0) {
	    freeaddrinfo(res0);
	    return INT2FIX(n);
	}
	if (rb_io_wait_writable(fileno(f))) {
	    goto retry;
	}
    }
    freeaddrinfo(res0);
    rb_sys_fail(&quot;sendto(2)&quot;);
    return INT2FIX(n);
}

/*
 * call-seq:
 * 	udpsocket.recvfrom_nonblock(maxlen) =&gt; [mesg, sender_inet_addr]
 * 	udpsocket.recvfrom_nonblock(maxlen, flags) =&gt; [mesg, sender_inet_addr]
 * 
 * Receives up to _maxlen_ bytes from +udpsocket+ using recvfrom(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * _flags_ is zero or more of the +MSG_+ options.
 * The first element of the results, _mesg_, is the data received.
 * The second element, _sender_inet_addr_, is an array to represent the sender address.
 *
 * When recvfrom(2) returns 0,
 * Socket#recvfrom_nonblock returns an empty string as data.
 * It means an empty packet.
 * 
 * === Parameters
 * * +maxlen+ - the number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options 
 * 
 * === Example
 * 	require 'socket'
 * 	s1 = UDPSocket.new
 * 	s1.bind(&quot;127.0.0.1&quot;, 0)
 * 	s2 = UDPSocket.new
 * 	s2.bind(&quot;127.0.0.1&quot;, 0)
 * 	s2.connect(*s1.addr.values_at(3,1))
 * 	s1.connect(*s2.addr.values_at(3,1))
 * 	s1.send &quot;aaa&quot;, 0
 * 	IO.select([s2])
 * 	p s2.recvfrom_nonblock(10)  #=&gt; [&quot;aaa&quot;, [&quot;AF_INET&quot;, 33302, &quot;localhost.localdomain&quot;, &quot;127.0.0.1&quot;]]
 *
 * Refer to Socket#recvfrom for the exceptions that may be thrown if the call
 * to _recvfrom_nonblock_ fails. 
 *
 * UDPSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure,
 * including Errno::EAGAIN.
 *
 * === See
 * * Socket#recvfrom
 */
static VALUE
udp_recvfrom_nonblock(int argc, VALUE *argv, VALUE sock)
{
    return s_recvfrom_nonblock(sock, argc, argv, RECV_IP);
}

#ifdef HAVE_SYS_UN_H
static VALUE
unix_init(sock, path)
    VALUE sock, path;
{
    return init_unixsock(sock, path, 0);
}

static char *
unixpath(struct sockaddr_un *sockaddr, socklen_t len)
{
    if (sockaddr-&gt;sun_path &lt; (char*)sockaddr + len)
        return sockaddr-&gt;sun_path;
    else
        return &quot;&quot;;
}

static VALUE
unix_path(sock)
    VALUE sock;
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (fptr-&gt;path == 0) {
	struct sockaddr_un addr;
	socklen_t len = sizeof(addr);
	if (getsockname(fileno(fptr-&gt;f), (struct sockaddr*)&amp;addr, &amp;len) &lt; 0)
	    rb_sys_fail(0);
	fptr-&gt;path = strdup(unixpath(&amp;addr, len));
    }
    return rb_str_new2(fptr-&gt;path);
}

static VALUE
unix_svr_init(sock, path)
    VALUE sock, path;
{
    return init_unixsock(sock, path, 1);
}

static VALUE
unix_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_UNIX);
}

#if defined(HAVE_ST_MSG_CONTROL) &amp;&amp; defined(SCM_RIGHTS)
#define FD_PASSING_BY_MSG_CONTROL 1
#else
#define FD_PASSING_BY_MSG_CONTROL 0
#endif

#if defined(HAVE_ST_MSG_ACCRIGHTS)
#define FD_PASSING_BY_MSG_ACCRIGHTS 1
#else
#define FD_PASSING_BY_MSG_ACCRIGHTS 0
#endif

static VALUE
unix_send_io(sock, val)
    VALUE sock, val;
{
#if defined(HAVE_SENDMSG) &amp;&amp; (FD_PASSING_BY_MSG_CONTROL || FD_PASSING_BY_MSG_ACCRIGHTS)
    int fd;
    rb_io_t *fptr;
    struct msghdr msg;
    struct iovec vec[1];
    char buf[1];

#if FD_PASSING_BY_MSG_CONTROL
    struct {
	struct cmsghdr hdr;
        char pad[8+sizeof(int)+8];
    } cmsg;
#endif

    if (rb_obj_is_kind_of(val, rb_cIO)) {
        rb_io_t *valfptr;
	GetOpenFile(val, valfptr);
	fd = fileno(valfptr-&gt;f);
    }
    else if (FIXNUM_P(val)) {
        fd = FIX2INT(val);
    }
    else {
	rb_raise(rb_eTypeError, &quot;neither IO nor file descriptor&quot;);
    }

    GetOpenFile(sock, fptr);

    msg.msg_name = NULL;
    msg.msg_namelen = 0;

    /* Linux and Solaris doesn't work if msg_iov is NULL. */
    buf[0] = '\0';
    vec[0].iov_base = buf;
    vec[0].iov_len = 1;
    msg.msg_iov = vec;
    msg.msg_iovlen = 1;

#if FD_PASSING_BY_MSG_CONTROL
    msg.msg_control = (caddr_t)&amp;cmsg;
    msg.msg_controllen = CMSG_LEN(sizeof(int));
    msg.msg_flags = 0;
    MEMZERO((char*)&amp;cmsg, char, sizeof(cmsg));
    cmsg.hdr.cmsg_len = CMSG_LEN(sizeof(int));
    cmsg.hdr.cmsg_level = SOL_SOCKET;
    cmsg.hdr.cmsg_type = SCM_RIGHTS;
    *(int *)CMSG_DATA(&amp;cmsg.hdr) = fd;
#else
    msg.msg_accrights = (caddr_t)&amp;fd;
    msg.msg_accrightslen = sizeof(fd);
#endif

    if (sendmsg(fileno(fptr-&gt;f), &amp;msg, 0) == -1)
	rb_sys_fail(&quot;sendmsg(2)&quot;);

    return Qnil;
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

#if defined(HAVE_RECVMSG) &amp;&amp; (FD_PASSING_BY_MSG_CONTROL || FD_PASSING_BY_MSG_ACCRIGHTS)
static void
thread_read_select(fd)
    int fd;
{
    fd_set fds;

    FD_ZERO(&amp;fds);
    FD_SET(fd, &amp;fds);
    rb_thread_select(fd+1, &amp;fds, 0, 0, 0);
}
#endif

static VALUE
unix_recv_io(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
#if defined(HAVE_RECVMSG) &amp;&amp; (FD_PASSING_BY_MSG_CONTROL || FD_PASSING_BY_MSG_ACCRIGHTS)
    VALUE klass, mode;
    rb_io_t *fptr;
    struct msghdr msg;
    struct iovec vec[2];
    char buf[1];

    int fd;
#if FD_PASSING_BY_MSG_CONTROL
    struct {
	struct cmsghdr hdr;
        char pad[8+sizeof(int)+8];
    } cmsg;
#endif

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;klass, &amp;mode);
    if (argc == 0)
	klass = rb_cIO;
    if (argc &lt;= 1)
	mode = Qnil;

    GetOpenFile(sock, fptr);

    thread_read_select(fileno(fptr-&gt;f));

    msg.msg_name = NULL;
    msg.msg_namelen = 0;

    vec[0].iov_base = buf;
    vec[0].iov_len = sizeof(buf);
    msg.msg_iov = vec;
    msg.msg_iovlen = 1;

#if FD_PASSING_BY_MSG_CONTROL
    msg.msg_control = (caddr_t)&amp;cmsg;
    msg.msg_controllen = CMSG_SPACE(sizeof(int));
    msg.msg_flags = 0;
    cmsg.hdr.cmsg_len = CMSG_LEN(sizeof(int));
    cmsg.hdr.cmsg_level = SOL_SOCKET;
    cmsg.hdr.cmsg_type = SCM_RIGHTS;
    *(int *)CMSG_DATA(&amp;cmsg.hdr) = -1;
#else
    msg.msg_accrights = (caddr_t)&amp;fd;
    msg.msg_accrightslen = sizeof(fd);
    fd = -1;
#endif

    if (recvmsg(fileno(fptr-&gt;f), &amp;msg, 0) == -1)
	rb_sys_fail(&quot;recvmsg(2)&quot;);

#if FD_PASSING_BY_MSG_CONTROL
    if (msg.msg_controllen != CMSG_SPACE(sizeof(int))) {
      rb_raise(rb_eSocket,
          &quot;file descriptor was not passed (msg_controllen=%d, %d expected)&quot;,
          msg.msg_controllen, CMSG_SPACE(sizeof(int)));
    }
    if (cmsg.hdr.cmsg_len != CMSG_LEN(sizeof(int))) {
      rb_raise(rb_eSocket,
          &quot;file descriptor was not passed (cmsg_len=%d, %d expected)&quot;,
          cmsg.hdr.cmsg_len, CMSG_LEN(sizeof(int)));
    }
    if (cmsg.hdr.cmsg_level != SOL_SOCKET) {
      rb_raise(rb_eSocket,
          &quot;file descriptor was not passed (cmsg_level=%d, %d expected)&quot;,
          cmsg.hdr.cmsg_level, SOL_SOCKET);
    }
    if (cmsg.hdr.cmsg_type != SCM_RIGHTS) {
      rb_raise(rb_eSocket,
          &quot;file descriptor was not passed (cmsg_type=%d, %d expected)&quot;,
          cmsg.hdr.cmsg_type, SCM_RIGHTS);
    }
#else
    if (msg.msg_accrightslen != sizeof(fd)) {
	rb_raise(rb_eSocket,
            &quot;file descriptor was not passed (accrightslen) : %d != %d&quot;,
            msg.msg_accrightslen, sizeof(fd));
    }
#endif

#if FD_PASSING_BY_MSG_CONTROL
    fd = *(int *)CMSG_DATA(&amp;cmsg.hdr);
#endif

    if (klass == Qnil)
	return INT2FIX(fd);
    else {
	static ID for_fd = 0;
	int ff_argc;
	VALUE ff_argv[2];
	if (!for_fd)
	    for_fd = rb_intern(&quot;for_fd&quot;);
	ff_argc = mode == Qnil ? 1 : 2;
	ff_argv[0] = INT2FIX(fd);
	ff_argv[1] = mode;
        return rb_funcall2(klass, for_fd, ff_argc, ff_argv);
    }
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static VALUE
unix_accept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_un from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(struct sockaddr_un);
    return s_accept(rb_cUNIXSocket, fileno(fptr-&gt;f),
		    (struct sockaddr*)&amp;from, &amp;fromlen);
}

/*
 * call-seq:
 * 	unixserver.accept_nonblock =&gt; unixsocket
 * 
 * Accepts an incoming connection using accept(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * It returns an accepted UNIXSocket for the incoming connection.
 * 
 * === Example
 * 	require 'socket'
 * 	serv = UNIXServer.new(&quot;/tmp/sock&quot;)
 * 	begin
 * 	  sock = serv.accept_nonblock
 * 	rescue Errno::EAGAIN, Errno::EWOULDBLOCK, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
 * 	  IO.select([serv])
 * 	  retry
 * 	end
 * 	# sock is an accepted socket.
 * 
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to UNIXServer#accept_nonblock fails. 
 *
 * UNIXServer#accept_nonblock may raise any error corresponding to accept(2) failure,
 * including Errno::EAGAIN.
 * 
 * === See
 * * UNIXServer#accept
 * * Socket#accept
 */
static VALUE
unix_accept_nonblock(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_un from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(from);
    return s_accept_nonblock(rb_cUNIXSocket, fptr,
                             (struct sockaddr *)&amp;from, &amp;fromlen);
}

static VALUE
unix_sysaccept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_un from;
    socklen_t fromlen;

    GetOpenFile(sock, fptr);
    fromlen = sizeof(struct sockaddr_un);
    return s_accept(0, fileno(fptr-&gt;f), (struct sockaddr*)&amp;from, &amp;fromlen);
}

static VALUE
unixaddr(sockaddr, len)
    struct sockaddr_un *sockaddr;
    socklen_t len;
{
    return rb_assoc_new(rb_str_new2(&quot;AF_UNIX&quot;),
                        rb_str_new2(unixpath(sockaddr, len)));
}

static VALUE
unix_addr(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_un addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getsockname(fileno(fptr-&gt;f), (struct sockaddr*)&amp;addr, &amp;len) &lt; 0)
	rb_sys_fail(&quot;getsockname(2)&quot;);
    return unixaddr(&amp;addr, len);
}

static VALUE
unix_peeraddr(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    struct sockaddr_un addr;
    socklen_t len = sizeof addr;

    GetOpenFile(sock, fptr);

    if (getpeername(fileno(fptr-&gt;f), (struct sockaddr*)&amp;addr, &amp;len) &lt; 0)
	rb_sys_fail(&quot;getpeername(2)&quot;);
    return unixaddr(&amp;addr, len);
}
#endif

static void
setup_domain_and_type(domain, dv, type, tv)
    VALUE domain, type;
    int *dv, *tv;
{
    VALUE tmp;
    char *ptr;

    tmp = rb_check_string_type(domain);
    if (!NIL_P(tmp)) {
	domain = tmp;
	rb_check_safe_obj(domain);
	ptr = RSTRING(domain)-&gt;ptr;
	if (strcmp(ptr, &quot;AF_INET&quot;) == 0)
	    *dv = AF_INET;
#ifdef AF_UNIX
	else if (strcmp(ptr, &quot;AF_UNIX&quot;) == 0)
	    *dv = AF_UNIX;
#endif
#ifdef AF_ISO
	else if (strcmp(ptr, &quot;AF_ISO&quot;) == 0)
	    *dv = AF_ISO;
#endif
#ifdef AF_NS
	else if (strcmp(ptr, &quot;AF_NS&quot;) == 0)
	    *dv = AF_NS;
#endif
#ifdef AF_IMPLINK
	else if (strcmp(ptr, &quot;AF_IMPLINK&quot;) == 0)
	    *dv = AF_IMPLINK;
#endif
#ifdef PF_INET
	else if (strcmp(ptr, &quot;PF_INET&quot;) == 0)
	    *dv = PF_INET;
#endif
#ifdef PF_UNIX
	else if (strcmp(ptr, &quot;PF_UNIX&quot;) == 0)
	    *dv = PF_UNIX;
#endif
#ifdef PF_IMPLINK
	else if (strcmp(ptr, &quot;PF_IMPLINK&quot;) == 0)
	    *dv = PF_IMPLINK;
	else if (strcmp(ptr, &quot;AF_IMPLINK&quot;) == 0)
	    *dv = AF_IMPLINK;
#endif
#ifdef PF_AX25
	else if (strcmp(ptr, &quot;PF_AX25&quot;) == 0)
	    *dv = PF_AX25;
#endif
#ifdef PF_IPX
	else if (strcmp(ptr, &quot;PF_IPX&quot;) == 0)
	    *dv = PF_IPX;
#endif
	else
	    rb_raise(rb_eSocket, &quot;unknown socket domain %s&quot;, ptr);
    }
    else {
	*dv = NUM2INT(domain);
    }
    tmp = rb_check_string_type(type);
    if (!NIL_P(tmp)) {
	type = tmp;
	rb_check_safe_obj(type);
	ptr = RSTRING(type)-&gt;ptr;
	if (strcmp(ptr, &quot;SOCK_STREAM&quot;) == 0)
	    *tv = SOCK_STREAM;
	else if (strcmp(ptr, &quot;SOCK_DGRAM&quot;) == 0)
	    *tv = SOCK_DGRAM;
#ifdef SOCK_RAW
	else if (strcmp(ptr, &quot;SOCK_RAW&quot;) == 0)
	    *tv = SOCK_RAW;
#endif
#ifdef SOCK_SEQPACKET
	else if (strcmp(ptr, &quot;SOCK_SEQPACKET&quot;) == 0)
	    *tv = SOCK_SEQPACKET;
#endif
#ifdef SOCK_RDM
	else if (strcmp(ptr, &quot;SOCK_RDM&quot;) == 0)
	    *tv = SOCK_RDM;
#endif
#ifdef SOCK_PACKET
	else if (strcmp(ptr, &quot;SOCK_PACKET&quot;) == 0)
	    *tv = SOCK_PACKET;
#endif
	else
	    rb_raise(rb_eSocket, &quot;unknown socket type %s&quot;, ptr);
    }
    else {
	*tv = NUM2INT(type);
    }
}

static VALUE
sock_initialize(sock, domain, type, protocol)
    VALUE sock, domain, type, protocol;
{
    int fd;
    int d, t;

    rb_secure(3);
    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    fd = ruby_socket(d, t, NUM2INT(protocol));
    if (fd &lt; 0) rb_sys_fail(&quot;socket(2)&quot;);

    return init_sock(sock, fd);
}

static VALUE
sock_s_socketpair(klass, domain, type, protocol)
    VALUE klass, domain, type, protocol;
{
#if defined HAVE_SOCKETPAIR
    int d, t, p, sp[2];
    int ret;

    setup_domain_and_type(domain, &amp;d, type, &amp;t);
    p = NUM2INT(protocol);
    ret = socketpair(d, t, p, sp);
    if (ret &lt; 0 &amp;&amp; (errno == EMFILE || errno == ENFILE)) {
        rb_gc();
        ret = socketpair(d, t, p, sp);
    }
    if (ret &lt; 0) {
	rb_sys_fail(&quot;socketpair(2)&quot;);
    }

    return rb_assoc_new(init_sock(rb_obj_alloc(klass), sp[0]),
			init_sock(rb_obj_alloc(klass), sp[1]));
#else
    rb_notimplement();
#endif
}

#ifdef HAVE_SYS_UN_H
static VALUE
unix_s_socketpair(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE domain, type, protocol;
    domain = INT2FIX(PF_UNIX);

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;type, &amp;protocol);
    if (argc == 0)
	type = INT2FIX(SOCK_STREAM);
    if (argc &lt;= 1)
	protocol = INT2FIX(0);

    return sock_s_socketpair(klass, domain, type, protocol);
}
#endif

/*
 * call-seq:
 * 	socket.connect(server_sockaddr) =&gt; 0
 * 
 * Requests a connection to be made on the given +server_sockaddr+. Returns 0 if
 * successful, otherwise an exception is raised.
 *  
 * === Parameter
 * * +server_sockaddr+ - the +struct+ sockaddr contained in a string
 * 
 * === Example:
 * 	# Pull down Google's web page
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
 * 	socket.connect( sockaddr )
 * 	socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
 * 	results = socket.read 
 * 
 * === Unix-based Exceptions
 * On unix-based systems the following system exceptions may be raised if 
 * the call to _connect_ fails:
 * * Errno::EACCES - search permission is denied for a component of the prefix
 *   path or write access to the +socket+ is denided
 * * Errno::EADDRINUSE - the _sockaddr_ is already in use
 * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the
 *   local machine
 * * Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for 
 *   the address family of the specified +socket+
 * * Errno::EALREADY - a connection is already in progress for the specified
 *   socket
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections
 *   refused the connection request
 * * Errno::ECONNRESET - the remote host reset the connection request
 * * Errno::EFAULT - the _sockaddr_ cannot be accessed
 * * Errno::EHOSTUNREACH - the destination host cannot be reached (probably 
 *   because the host is down or a remote router cannot reach it)
 * * Errno::EINPROGRESS - the O_NONBLOCK is set for the +socket+ and the
 *   connection cnanot be immediately established; the connection will be
 *   established asynchronously
 * * Errno::EINTR - the attempt to establish the connection was interrupted by
 *   delivery of a signal that was caught; the connection will be established
 *   asynchronously
 * * Errno::EISCONN - the specified +socket+ is already connected
 * * Errno::EINVAL - the address length used for the _sockaddr_ is not a valid
 *   length for the address family or there is an invalid family in _sockaddr_ 
 * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
 *   PATH_MAX
 * * Errno::ENETDOWN - the local interface used to reach the destination is down
 * * Errno::ENETUNREACH - no route to the network is present
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOSR - there were insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * * Errno::EOPNOTSUPP - the calling +socket+ is listening and cannot be connected
 * * Errno::EPROTOTYPE - the _sockaddr_ has a different type than the socket 
 *   bound to the specified peer address
 * * Errno::ETIMEDOUT - the attempt to connect time out before a connection
 *   was made.
 * 
 * On unix-based systems if the address family of the calling +socket+ is
 * AF_UNIX the follow exceptions may be raised if the call to _connect_
 * fails:
 * * Errno::EIO - an i/o error occured while reading from or writing to the 
 *   file system
 * * Errno::ELOOP - too many symbolic links were encountered in translating
 *   the pathname in _sockaddr_
 * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX 
 *   characters, or an entired pathname exceeded PATH_MAX characters
 * * Errno::ENOENT - a component of the pathname does not name an existing file
 *   or the pathname is an empty string
 * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_
 *   is not a directory 
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _connect_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EADDRINUSE - the socket's local address is already in use
 * * Errno::EINTR - the socket was cancelled
 * * Errno::EINPROGRESS - a blocking socket is in progress or the service provider
 *   is still processing a callback function. Or a nonblocking connect call is 
 *   in progress on the +socket+.
 * * Errno::EALREADY - see Errno::EINVAL
 * * Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as 
 *   ADDR_ANY TODO check ADDRANY TO INADDR_ANY
 * * Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
 *   with this +socket+
 * * Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections
 *   refused the connection request
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space address
 * * Errno::EINVAL - the +socket+ is a listening socket
 * * Errno::EISCONN - the +socket+ is already connected
 * * Errno::ENETUNREACH - the network cannot be reached from this host at this time
 * * Errno::EHOSTUNREACH - no route to the network is present
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * * Errno::ETIMEDOUT - the attempt to connect time out before a connection
 *   was made.
 * * Errno::EWOULDBLOCK - the socket is marked as nonblocking and the 
 *   connection cannot be completed immediately
 * * Errno::EACCES - the attempt to connect the datagram socket to the 
 *   broadcast address failed
 * 
 * === See
 * * connect manual pages on unix-based systems
 * * connect function in Microsoft's Winsock functions reference
 */
static VALUE
sock_connect(sock, addr)
    VALUE sock, addr;
{
    rb_io_t *fptr;
    int fd;

    StringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    fd = fileno(fptr-&gt;f);
    if (ruby_connect(fd, (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len, 0) &lt; 0) {
	rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(0);
}

/*
 * call-seq:
 * 	socket.connect_nonblock(server_sockaddr) =&gt; 0
 * 
 * Requests a connection to be made on the given +server_sockaddr+ after
 * O_NONBLOCK is set for the underlying file descriptor.
 * Returns 0 if successful, otherwise an exception is raised.
 *  
 * === Parameter
 * * +server_sockaddr+ - the +struct+ sockaddr contained in a string
 * 
 * === Example:
 * 	# Pull down Google's web page
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 * 	sockaddr = Socket.sockaddr_in(80, 'www.google.com')
 * 	begin
 * 	  socket.connect_nonblock(sockaddr)
 * 	rescue Errno::EINPROGRESS
 * 	  IO.select(nil, [socket])
 * 	  begin
 * 	    socket.connect_nonblock(sockaddr)
 * 	  rescue Errno::EISCONN
 * 	  end
 * 	end
 * 	socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
 * 	results = socket.read 
 * 
 * Refer to Socket#connect for the exceptions that may be thrown if the call
 * to _connect_nonblock_ fails. 
 *
 * Socket#connect_nonblock may raise any error corresponding to connect(2) failure,
 * including Errno::EINPROGRESS.
 *
 * === See
 * * Socket#connect
 */
static VALUE
sock_connect_nonblock(sock, addr)
    VALUE sock, addr;
{
    rb_io_t *fptr;
    int n;

    StringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    rb_io_set_nonblock(fptr);
    n = connect(fileno(fptr-&gt;f), (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len);
    if (n &lt; 0) {
	rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(n);
}

/*
 * call-seq:
 * 	socket.bind(server_sockaddr) =&gt; 0
 * 
 * Binds to the given +struct+ sockaddr.
 * 
 * === Parameter
 * * +server_sockaddr+ - the +struct+ sockaddr contained in a string
 *
 * === Example
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.bind( sockaddr )
 *  
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if 
 * the call to _bind_ fails:
 * * Errno::EACCES - the specified _sockaddr_ is protected and the current
 *   user does not have permission to bind to it
 * * Errno::EADDRINUSE - the specified _sockaddr_ is already in use
 * * Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the
 *   local machine
 * * Errno::EAFNOSUPPORT - the specified _sockaddr_ isnot a valid address for
 *   the family of the calling +socket+
 * * Errno::EBADF - the _sockaddr_ specified is not a valid file descriptor
 * * Errno::EFAULT - the _sockaddr_ argument cannot be accessed
 * * Errno::EINVAL - the +socket+ is already bound to an address, and the 
 *   protocol does not support binding to the new _sockaddr_ or the +socket+
 *   has been shut down.
 * * Errno::EINVAL - the address length is not a valid length for the address
 *   family
 * * Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
 *   PATH_MAX
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOSR - there were insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the socket type of the +socket+ does not support 
 *   binding to an address
 * 
 * On unix-based based systems if the address family of the calling +socket+ is
 * Socket::AF_UNIX the follow exceptions may be raised if the call to _bind_
 * fails:
 * * Errno::EACCES - search permission is denied for a component of the prefix
 *   path or write access to the +socket+ is denided
 * * Errno::EDESTADDRREQ - the _sockaddr_ argument is a null pointer
 * * Errno::EISDIR - same as Errno::EDESTADDRREQ
 * * Errno::EIO - an i/o error occurred
 * * Errno::ELOOP - too many symbolic links were encountered in translating
 *   the pathname in _sockaddr_
 * * Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX 
 *   characters, or an entired pathname exceeded PATH_MAX characters
 * * Errno::ENOENT - a component of the pathname does not name an existing file
 *   or the pathname is an empty string
 * * Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_
 *   is not a directory
 * * Errno::EROFS - the name would reside on a read only filesystem
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _bind_ fails:
 * * Errno::ENETDOWN-- the network is down
 * * Errno::EACCES - the attempt to connect the datagram socket to the 
 *   broadcast address failed
 * * Errno::EADDRINUSE - the socket's local address is already in use
 * * Errno::EADDRNOTAVAIL - the specified address is not a valid address for this
 *   computer
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space addressed
 * * Errno::EINVAL - the +socket+ is already bound to an address
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - the +socket+ argument does not refer to a socket
 * 
 * === See
 * * bind manual pages on unix-based systems
 * * bind function in Microsoft's Winsock functions reference
 */ 
static VALUE
sock_bind(sock, addr)
    VALUE sock, addr;
{
    rb_io_t *fptr;

    StringValue(addr);
    GetOpenFile(sock, fptr);
    if (bind(fileno(fptr-&gt;f), (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len) &lt; 0)
	rb_sys_fail(&quot;bind(2)&quot;);

    return INT2FIX(0);
}

/*
 * call-seq:
 * 	socket.listen( int ) =&gt; 0
 * 
 * Listens for connections, using the specified +int+ as the backlog. A call
 * to _listen_ only applies if the +socket+ is of type SOCK_STREAM or 
 * SOCK_SEQPACKET.
 * 
 * === Parameter
 * * +backlog+ - the maximum length of the queue for pending connections.
 * 
 * === Example 1
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.bind( sockaddr )
 * 	socket.listen( 5 )
 * 
 * === Example 2 (listening on an arbitary port, unix-based systems only):
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	socket.listen( 1 )
 * 
 * === Unix-based Exceptions
 * On unix based systems the above will work because a new +sockaddr+ struct
 * is created on the address ADDR_ANY, for an arbitrary port number as handed
 * off by the kernel. It will not work on Windows, because Windows requires that
 * the +socket+ is bound by calling _bind_ before it can _listen_.
 * 
 * If the _backlog_ amount exceeds the implementation-dependent maximum
 * queue length, the implementation's maximum queue length will be used.
 * 
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _listen_ fails:
 * * Errno::EBADF - the _socket_ argument is not a valid file descriptor
 * * Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and 
 *   the protocol does not support listening on an unbound socket
 * * Errno::EINVAL - the _socket_ is already connected
 * * Errno::ENOTSOCK - the _socket_ argument does not refer to a socket
 * * Errno::EOPNOTSUPP - the _socket_ protocol does not support listen
 * * Errno::EACCES - the calling process does not have approriate privileges
 * * Errno::EINVAL - the _socket_ has been shut down
 * * Errno::ENOBUFS - insufficient resources are available in the system to 
 *   complete the call
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _listen_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EADDRINUSE - the socket's local address is already in use. This 
 *   usually occurs during the execution of _bind_ but could be delayed
 *   if the call to _bind_ was to a partially wildcard address (involving
 *   ADDR_ANY) and if a specific address needs to be commmitted at the 
 *   time of the call to _listen_
 * * Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
 *   service provider is still processing a callback function
 * * Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.
 * * Errno::EISCONN - the +socket+ is already connected
 * * Errno::EMFILE - no more socket descriptors are available
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOC - +socket+ is not a socket
 * * Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports
 *   the _listen_ method
 * 
 * === See
 * * listen manual pages on unix-based systems
 * * listen function in Microsoft's Winsock functions reference
 */
static VALUE
sock_listen(sock, log)
    VALUE sock, log;
{
    rb_io_t *fptr;
    int backlog;

    rb_secure(4);
    backlog = NUM2INT(log);
    GetOpenFile(sock, fptr);
    if (listen(fileno(fptr-&gt;f), backlog) &lt; 0)
	rb_sys_fail(&quot;listen(2)&quot;);

    return INT2FIX(0);
}

/*
 * call-seq:
 * 	socket.recvfrom(maxlen) =&gt; [mesg, sender_sockaddr]
 * 	socket.recvfrom(maxlen, flags) =&gt; [mesg, sender_sockaddr]
 * 
 * Receives up to _maxlen_ bytes from +socket+. _flags_ is zero or more
 * of the +MSG_+ options. The first element of the results, _mesg_, is the data
 * received. The second element, _sender_sockaddr_, contains protocol-specific information
 * on the sender.
 * 
 * === Parameters
 * * +maxlen+ - the number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options 
 * 
 * === Example
 * 	# In one file, start this first
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.bind( sockaddr )
 * 	socket.listen( 5 )
 * 	client, client_sockaddr = socket.accept
 * 	data = client.recvfrom( 20 )[0].chomp
 * 	puts &quot;I only received 20 bytes '#{data}'&quot;
 * 	sleep 1
 * 	socket.close
 * 
 * 	# In another file, start this second
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.connect( sockaddr )
 * 	socket.puts &quot;Watch this get cut short!&quot;
 * 	socket.close 
 * 
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _recvfrom_ fails:
 * * Errno::EAGAIN - the +socket+ file descriptor is marked as O_NONBLOCK and no
 *   data is waiting to be received; or MSG_OOB is set and no out-of-band data
 *   is available and either the +socket+ file descriptor is marked as 
 *   O_NONBLOCK or the +socket+ does not support blocking to wait for 
 *   out-of-band-data
 * * Errno::EWOULDBLOCK - see Errno::EAGAIN
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNRESET - a connection was forcibly closed by a peer
 * * Errno::EFAULT - the socket's internal buffer, address or address length 
 *   cannot be accessed or written
 * * Errno::EINTR - a signal interupted _recvfrom_ before any data was available
 * * Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available
 * * Errno::EIO - an i/o error occurred while reading from or writing to the 
 *   filesystem
 * * Errno::ENOBUFS - insufficient resources were available in the system to 
 *   perform the operation
 * * Errno::ENOMEM - insufficient memory was available to fulfill the request
 * * Errno::ENOSR - there were insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
 *   is not connected
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the specified flags are not supported for this socket type
 * * Errno::ETIMEDOUT - the connection timed out during connection establishment
 *   or due to a transmission timeout on an active connection
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _recvfrom_ fails:
 * * Errno::ENETDOWN - the network is down
 * * Errno::EFAULT - the internal buffer and from parameters on +socket+ are not
 *   part of the user address space, or the internal fromlen parameter is
 *   too small to accomodate the peer address
 * * Errno::EINTR - the (blocking) call was cancelled by an internal call to
 *   the WinSock function WSACancelBlockingCall
 * * Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or 
 *   the service provider is still processing a callback function
 * * Errno::EINVAL - +socket+ has not been bound with a call to _bind_, or an
 *   unknown flag was specified, or MSG_OOB was specified for a socket with
 *   SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
 *   len parameter on +socket+ was zero or negative
 * * Errno::EISCONN - +socket+ is already connected. The call to _recvfrom_ is
 *   not permitted with a connected socket on a socket that is connetion 
 *   oriented or connectionless.
 * * Errno::ENETRESET - the connection has been broken due to the keep-alive 
 *   activity detecting a failure while the operation was in progress.
 * * Errno::EOPNOTSUPP - MSG_OOB was specified, but +socket+ is not stream-style
 *   such as type SOCK_STREAM. OOB data is not supported in the communication
 *   domain associated with +socket+, or +socket+ is unidirectional and 
 *   supports only send operations
 * * Errno::ESHUTDOWN - +socket+ has been shutdown. It is not possible to 
 *   call _recvfrom_ on a socket after _shutdown_ has been invoked.
 * * Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and a  call to 
 *   _recvfrom_ would block.
 * * Errno::EMSGSIZE - the message was too large to fit into the specified buffer
 *   and was truncated.
 * * Errno::ETIMEDOUT - the connection has been dropped, because of a network
 *   failure or because the system on the other end went down without
 *   notice
 * * Errno::ECONNRESET - the virtual circuit was reset by the remote side 
 *   executing a hard or abortive close. The application should close the
 *   socket; it is no longer usable. On a UDP-datagram socket this error
 *   indicates a previous send operation resulted in an ICMP Port Unreachable
 *   message.
 */
static VALUE
sock_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_SOCKET);
}

/*
 * call-seq:
 * 	socket.recvfrom_nonblock(maxlen) =&gt; [mesg, sender_sockaddr]
 * 	socket.recvfrom_nonblock(maxlen, flags) =&gt; [mesg, sender_sockaddr]
 * 
 * Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * _flags_ is zero or more of the +MSG_+ options.
 * The first element of the results, _mesg_, is the data received.
 * The second element, _sender_sockaddr_, contains protocol-specific information
 * on the sender.
 *
 * When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns
 * an empty string as data.
 * The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.
 * 
 * === Parameters
 * * +maxlen+ - the number of bytes to receive from the socket
 * * +flags+ - zero or more of the +MSG_+ options 
 * 
 * === Example
 * 	# In one file, start this first
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 * 	sockaddr = Socket.sockaddr_in(2200, 'localhost')
 * 	socket.bind(sockaddr)
 * 	socket.listen(5)
 * 	client, client_sockaddr = socket.accept
 * 	begin
 * 	  pair = client.recvfrom_nonblock(20)
 * 	rescue Errno::EAGAIN, Errno::EWOULDBLOCK
 * 	  IO.select([client])
 * 	  retry
 * 	end
 * 	data = pair[0].chomp
 * 	puts &quot;I only received 20 bytes '#{data}'&quot;
 * 	sleep 1
 * 	socket.close
 * 
 * 	# In another file, start this second
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 * 	sockaddr = Socket.sockaddr_in(2200, 'localhost')
 * 	socket.connect(sockaddr)
 * 	socket.puts &quot;Watch this get cut short!&quot;
 * 	socket.close 
 * 
 * Refer to Socket#recvfrom for the exceptions that may be thrown if the call
 * to _recvfrom_nonblock_ fails. 
 *
 * Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure,
 * including Errno::EAGAIN.
 *
 * === See
 * * Socket#recvfrom
 */
static VALUE
sock_recvfrom_nonblock(int argc, VALUE *argv, VALUE sock)
{
    return s_recvfrom_nonblock(sock, argc, argv, RECV_SOCKET);
}

/*
 * call-seq:
 * 	socket.accept =&gt; [ socket, string ]
 * 
 * Accepts an incoming connection returning an array containing a new
 * Socket object and a string holding the +struct+ sockaddr information about 
 * the caller.
 * 
 * === Example
 * 	# In one script, start this first
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.bind( sockaddr )
 * 	socket.listen( 5 )
 * 	client, client_sockaddr = socket.accept
 * 	puts &quot;The client said, '#{client.readline.chomp}'&quot;
 * 	client.puts &quot;Hello from script one!&quot;
 * 	socket.close
 * 
 * 	# In another script, start this second
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.connect( sockaddr )
 * 	socket.puts &quot;Hello from script 2.&quot; 
 * 	puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 * 	socket.close 
 * 
 * === Unix-based Exceptions
 * On unix-based based systems the following system exceptions may be raised if the
 * call to _accept_ fails:
 * * Errno::EAGAIN - O_NONBLOCK is set for the +socket+ file descriptor and no 
 *   connections are parent to be accepted
 * * Errno::EWOULDBLOCK - same as Errno::EAGAIN
 * * Errno::EBADF - the +socket+ is not a valid file descriptor
 * * Errno::ECONNABORTED - a connection has been aborted
 * * Errno::EFAULT - the socket's internal address or address length parameter 
 *   cannot be access or written
 * * Errno::EINTR - the _accept_ method was interrupted by a signal that was 
 *   caught before a valid connection arrived
 * * Errno::EINVAL - the +socket+ is not accepting connections
 * * Errno::EMFILE - OPEN_MAX file descriptors are currently open in the calling 
 *   process
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOMEM - there was insufficient memory available to complete the
 *   operation
 * * Errno::ENOSR - there was insufficient STREAMS resources available to 
 *   complete the operation
 * * Errno::ENFILE - the maximum number of file descriptors in the system are 
 *   already open
 * * Errno::ENOTSOCK - the +socket+ does not refer to a socket
 * * Errno::EOPNOTSUPP - the socket type for the calling +socket+ does not 
 *   support accept connections
 * * Errno::EPROTO - a protocol error has occurred
 * 
 * === Windows Exceptions
 * On Windows systems the following system exceptions may be raised if 
 * the call to _accept_ fails:
 * * Errno::ECONNRESET - an incoming connection was indicated, but was 
 *   terminated by the remote peer prior to accepting the connection
 * * Errno::EFAULT - the socket's internal address or address length parameter
 *   is too small or is not a valid part of the user space address
 * * Errno::EINVAL - the _listen_ method was not invoked prior to calling _accept_
 * * Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
 *   the service provider is still processing a callback function
 * * Errno::EMFILE - the queue is not empty, upong etry to _accept_ and there are
 *   no socket descriptors available
 * * Errno::ENETDOWN - the network is down
 * * Errno::ENOBUFS - no buffer space is available
 * * Errno::ENOTSOCK - +socket+ is not a socket
 * * Errno::EOPNOTSUPP - +socket+ is not a type that supports connection-oriented
 *   service.
 * * Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and no connections are
 *   present to be accepted
 * 
 * === See
 * * accept manual pages on unix-based systems
 * * accept function in Microsoft's Winsock functions reference
 */
static VALUE
sock_accept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(rb_cSocket,fileno(fptr-&gt;f),(struct sockaddr*)buf,&amp;len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}

/*
 * call-seq:
 *    socket.accept_nonblock =&gt; [client_socket, client_sockaddr]
 * 
 * Accepts an incoming connection using accept(2) after
 * O_NONBLOCK is set for the underlying file descriptor.
 * It returns an array containg the accpeted socket
 * for the incoming connection, _client_socket_,
 * and a string that contains the +struct+ sockaddr information
 * about the caller, _client_sockaddr_.
 * 
 * === Example
 * 	# In one script, start this first
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 * 	sockaddr = Socket.sockaddr_in(2200, 'localhost')
 * 	socket.bind(sockaddr)
 * 	socket.listen(5)
 * 	begin
 * 	  client_socket, client_sockaddr = socket.accept_nonblock
 * 	rescue Errno::EAGAIN, Errno::EWOULDBLOCK, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
 * 	  IO.select([socket])
 * 	  retry
 * 	end
 * 	puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 * 	client_socket.puts &quot;Hello from script one!&quot;
 * 	socket.close
 *
 * 	# In another script, start this second
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new(AF_INET, SOCK_STREAM, 0)
 * 	sockaddr = Socket.sockaddr_in(2200, 'localhost')
 * 	socket.connect(sockaddr)
 * 	socket.puts &quot;Hello from script 2.&quot; 
 * 	puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 * 	socket.close
 * 
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to _accept_nonblock_ fails. 
 *
 * Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
 * including Errno::EAGAIN.
 * 
 * === See
 * * Socket#accept
 */
static VALUE
sock_accept_nonblock(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept_nonblock(rb_cSocket, fptr, (struct sockaddr *)buf, &amp;len);
    return rb_assoc_new(sock2, rb_str_new(buf, len));
}

/*
 * call-seq:
 * 	socket.sysaccept =&gt; [client_socket_fd, client_sockaddr]
 * 
 * Accepts an incoming connection returnings an array containg the (integer)
 * file descriptor for the incoming connection, _client_socket_fd_,
 * and a string that contains the +struct+ sockaddr information
 * about the caller, _client_sockaddr_.
 * 
 * === Example
 * 	# In one script, start this first
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.bind( sockaddr )
 * 	socket.listen( 5 )
 * 	client_fd, client_sockaddr = socket.sysaccept
 * 	client_socket = Socket.for_fd( client_fd )
 * 	puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
 * 	client_socket.puts &quot;Hello from script one!&quot;
 * 	socket.close
 * 
 * 	# In another script, start this second
 * 	require 'socket'
 * 	include Socket::Constants
 * 	socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
 * 	sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
 * 	socket.connect( sockaddr )
 * 	socket.puts &quot;Hello from script 2.&quot; 
 * 	puts &quot;The server said, '#{socket.readline.chomp}'&quot;
 * 	socket.close
 * 
 * Refer to Socket#accept for the exceptions that may be thrown if the call
 * to _sysaccept_ fails. 
 * 
 * === See
 * * Socket#accept
 */
static VALUE
sock_sysaccept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(0,fileno(fptr-&gt;f),(struct sockaddr*)buf,&amp;len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}

#ifdef HAVE_GETHOSTNAME
static VALUE
sock_gethostname(obj)
    VALUE obj;
{
    char buf[1024];

    rb_secure(3);
    if (gethostname(buf, (int)sizeof buf - 1) &lt; 0)
	rb_sys_fail(&quot;gethostname&quot;);

    buf[sizeof buf - 1] = '\0';
    return rb_str_new2(buf);
}
#else
#ifdef HAVE_UNAME

#include &lt;sys/utsname.h&gt;

static VALUE
sock_gethostname(obj)
    VALUE obj;
{
    struct utsname un;

    rb_secure(3);
    uname(&amp;un);
    return rb_str_new2(un.nodename);
}
#else
static VALUE
sock_gethostname(obj)
    VALUE obj;
{
    rb_notimplement();
}
#endif
#endif

static VALUE
make_addrinfo(res0)
    struct addrinfo *res0;
{
    VALUE base, ary;
    struct addrinfo *res;

    if (res0 == NULL) {
	rb_raise(rb_eSocket, &quot;host not found&quot;);
    }
    base = rb_ary_new();
    for (res = res0; res; res = res-&gt;ai_next) {
	ary = ipaddr(res-&gt;ai_addr);
	rb_ary_push(ary, INT2FIX(res-&gt;ai_family));
	rb_ary_push(ary, INT2FIX(res-&gt;ai_socktype));
	rb_ary_push(ary, INT2FIX(res-&gt;ai_protocol));
	rb_ary_push(base, ary);
    }
    return base;
}

/* Returns a String containing the binary value of a struct sockaddr. */
VALUE
sock_sockaddr(addr, len)
    struct sockaddr *addr;
    size_t len;
{
    char *ptr;

    switch (addr-&gt;sa_family) {
      case AF_INET:
	ptr = (char*)&amp;((struct sockaddr_in*)addr)-&gt;sin_addr.s_addr;
	len = sizeof(((struct sockaddr_in*)addr)-&gt;sin_addr.s_addr);
	break;
#ifdef INET6
      case AF_INET6:
	ptr = (char*)&amp;((struct sockaddr_in6*)addr)-&gt;sin6_addr.s6_addr;
	len = sizeof(((struct sockaddr_in6*)addr)-&gt;sin6_addr.s6_addr);
	break;
#endif
      default:
        rb_raise(rb_eSocket, &quot;unknown socket family:%d&quot;, addr-&gt;sa_family);
	break;
    }
    return rb_str_new(ptr, len);
}

/*
 * Document-class: IPSocket
 *
 * IPSocket is the parent of TCPSocket and UDPSocket and implements
 * functionality common to them.
 *
 * A number of APIs in IPSocket, Socket, and their descendants return an
 * address as an array. The members of that array are:
 * - address family: A string like &quot;AF_INET&quot; or &quot;AF_INET6&quot; if it is one of the
 *   commonly used families, the string &quot;unknown:#&quot; (where `#' is the address
 *   family number) if it is not one of the common ones.  The strings map to
 *   the Socket::AF_* constants.
 * - port: The port number.
 * - name: Either the canonical name from looking the address up in the DNS, or
 *   the address in presentation format
 * - address: The address in presentation format (a dotted decimal string for
 *   IPv4, a hex string for IPv6).
 *
 * The address and port can be used directly to create sockets and to bind or
 * connect them to the address.
 */

/*
 * Document-class: Socket
 *
 * Socket contains a number of generally useful singleton methods and
 * constants, as well as offering low-level interfaces that can be used to
 * develop socket applications using protocols other than TCP, UDP, and UNIX
 * domain sockets.
 */

/*
 * Document-method: gethostbyname
 * call-seq: Socket.gethostbyname(host) =&gt; hostent
 *
 * Resolve +host+ and return name and address information for it, similarly to
 * gethostbyname(3). +host+ can be a domain name or the presentation format of
 * an address.
 *
 * Returns an array of information similar to that found in a +struct hostent+:
 *   - cannonical name: the cannonical name for host in the DNS, or a
 *     string representing the address
 *   - aliases: an array of aliases for the canonical name, there may be no aliases
 *   - address family: usually one of Socket::AF_INET or Socket::AF_INET6
 *   - address: a string, the binary value of the +struct sockaddr+ for this name, in
 *     the indicated address family
 *   - ...: if there are multiple addresses for this host,  a series of
 *     strings/+struct sockaddr+s may follow, not all necessarily in the same
 *     address family. Note that the fact that they may not be all in the same
 *     address family is a departure from the behaviour of gethostbyname(3).
 *
 * Note: I believe that the fact that the multiple addresses returned are not
 * necessarily in the same address family may be a bug, since if this function
 * actually called gethostbyname(3), ALL the addresses returned in the trailing
 * address list (h_addr_list from struct hostent) would be of the same address
 * family!  Examples from my system, OS X 10.3:
 *
 *   [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
 *     and
 *   [&quot;ensemble.local&quot;, [], 30, &quot;\376\200\000\004\000\000\000\000\002\003\223\377\376\255\010\214&quot;, &quot;\300\250{\232&quot; ]
 *
 * Similar information can be returned by Socket.getaddrinfo if called as:
 *
 *    Socket.getaddrinfo(+host+, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
 *
 * == Examples
 *   
 *   Socket.gethostbyname &quot;example.com&quot;                                                           
 *   =&gt; [&quot;example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
 *   
 * This name has no DNS aliases, and a single IPv4 address.
 *   
 *   Socket.gethostbyname &quot;smtp.telus.net&quot;
 *   =&gt; [&quot;smtp.svc.telus.net&quot;, [&quot;smtp.telus.net&quot;], 2, &quot;\307\271\334\371&quot;]
 *   
 * This name is an an alias so the canonical name is returned, as well as the
 * alias and a single IPv4 address.
 *   
 *   Socket.gethostbyname &quot;localhost&quot;
 *   =&gt; [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
 *   
 * This machine has no aliases, returns an IPv6 address, and has an additional IPv4 address.
 *
 * +host+ can also be an IP address in presentation format, in which case a
 * reverse lookup is done on the address:
 *
 *   Socket.gethostbyname(&quot;127.0.0.1&quot;)
 *   =&gt; [&quot;localhost&quot;, [], 2, &quot;\177\000\000\001&quot;]
 *
 *   Socket.gethostbyname(&quot;192.0.34.166&quot;)
 *   =&gt; [&quot;www.example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
 *
 *
 * == See
 * See: Socket.getaddrinfo
 */
static VALUE
sock_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    rb_secure(3);
    return make_hostent(host, sock_addrinfo(host, Qnil, SOCK_STREAM, AI_CANONNAME), sock_sockaddr);
}

static VALUE
sock_s_gethostbyaddr(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE addr, type;
    struct hostent *h;
    struct sockaddr *sa;
    char **pch;
    VALUE ary, names;
    int t = AF_INET;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;addr, &amp;type);
    sa = (struct sockaddr*)StringValuePtr(addr);
    if (!NIL_P(type)) {
	t = NUM2INT(type);
    }
#ifdef INET6
    else if (RSTRING(addr)-&gt;len == 16) {
	t = AF_INET6;
    }
#endif
    h = gethostbyaddr(RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len, t);
    if (h == NULL) {
#ifdef HAVE_HSTRERROR
	extern int h_errno;
	rb_raise(rb_eSocket, &quot;%s&quot;, (char*)hstrerror(h_errno));
#else
	rb_raise(rb_eSocket, &quot;host not found&quot;);
#endif
    }
    ary = rb_ary_new();
    rb_ary_push(ary, rb_str_new2(h-&gt;h_name));
    names = rb_ary_new();
    rb_ary_push(ary, names);
    if (h-&gt;h_aliases != NULL) {
	for (pch = h-&gt;h_aliases; *pch; pch++) {
	    rb_ary_push(names, rb_str_new2(*pch));
	}
    }
    rb_ary_push(ary, INT2NUM(h-&gt;h_addrtype));
#ifdef h_addr
    for (pch = h-&gt;h_addr_list; *pch; pch++) {
	rb_ary_push(ary, rb_str_new(*pch, h-&gt;h_length));
    }
#else
    rb_ary_push(ary, rb_str_new(h-&gt;h_addr, h-&gt;h_length));
#endif

    return ary;
}

/*
 * Document-method: getservbyname
 * call-seq: Socket.getservbyname(name, proto=&quot;tcp&quot;) =&gt; port
 *
 * +name+ is a service name (&quot;ftp&quot;, &quot;telnet&quot;, ...) and proto is a protocol name
 * (&quot;udp&quot;, &quot;tcp&quot;, ...). '/etc/services' (or your system's equivalent) is
 * searched for a service for +name+ and +proto+, and the port number is
 * returned.
 *
 * Note that unlike Socket.getaddrinfo, +proto+ may not be specified using the
 * Socket::SOCK_* constants, a string must must be used.
 */
static VALUE
sock_s_getservbyaname(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE service, proto;
    struct servent *sp;
    int port;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;service, &amp;proto);
    if (NIL_P(proto)) proto = rb_str_new2(&quot;tcp&quot;);
    StringValue(service);
    StringValue(proto);

    sp = getservbyname(StringValueCStr(service),  StringValueCStr(proto));
    if (sp) {
	port = ntohs(sp-&gt;s_port);
    }
    else {
	char *s = RSTRING(service)-&gt;ptr;
	char *end;

	port = strtoul(s, &amp;end, 0);
	if (*end != '\0') {
	    rb_raise(rb_eSocket, &quot;no such service %s/%s&quot;, s, RSTRING(proto)-&gt;ptr);
	}
    }
    return INT2FIX(port);
}

/*
Documentation should explain the following:

  $ pp Socket.getaddrinfo(&quot;&quot;, 1, Socket::AF_UNSPEC, Socket::SOCK_STREAM, 0, Socket::AI_PASSIVE)
  [[&quot;AF_INET&quot;, 1, &quot;0.0.0.0&quot;, &quot;0.0.0.0&quot;, 2, 1, 6]]

  $ pp Socket.getaddrinfo(nil, 1, Socket::AF_UNSPEC, Socket::SOCK_STREAM, 0, Socket::AI_PASSIVE)
  [[&quot;AF_INET6&quot;, 1, &quot;::&quot;, &quot;::&quot;, 30, 1, 6],
   [&quot;AF_INET&quot;, 1, &quot;0.0.0.0&quot;, &quot;0.0.0.0&quot;, 2, 1, 6]]

  $ pp Socket.getaddrinfo(&quot;localhost&quot;, 1, Socket::AF_UNSPEC, Socket::SOCK_STREAM, 0, Socket::AI_PASSIVE)
  [[&quot;AF_INET6&quot;, 1, &quot;localhost&quot;, &quot;::1&quot;, 30, 1, 6],
   [&quot;AF_INET&quot;, 1, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 1, 6]]

  $ pp Socket.getaddrinfo(&quot;ensemble.local.&quot;, 1, Socket::AF_UNSPEC, Socket::SOCK_STREAM, 0, Socket::AI_PASSIVE)
  [[&quot;AF_INET&quot;, 1, &quot;localhost&quot;, &quot;192.168.123.154&quot;, 2, 1, 6]]

Does it?

API suggestion: this method has too many arguments, it would be backwards compatible and easier
to understand if limit args were accepted as :family=&gt;..., :flags=&gt;...
*/

/*
 * Document-method: getaddrinfo
 * call-seq: Socket.getaddrinfo(host, service, family=nil, socktype=nil, protocol=nil, flags=nil) =&gt; addrinfo
 *
 * Return address information for +host+ and +port+. The remaining arguments
 * are hints that limit the address information returned.
 *
 * This method corresponds closely to the POSIX.1g getaddrinfo() definition.
 *
 * === Parameters
 * - +host+ is a host name or an address string (dotted decimal for IPv4, or a hex string
 *   for IPv6) for which to return information. A nil is also allowed, its meaning
 *   depends on +flags+, see below.
 * - +service+ is a service name (&quot;http&quot;, &quot;ssh&quot;, ...), or 
 *   a port number (80, 22, ...), see Socket.getservbyname for more
 *   information. A nil is also allowed, meaning zero.
 * - +family+ limits the output to a specific address family, one of the
 *   Socket::AF_* constants. Socket::AF_INET (IPv4) and Socket::AF_INET6 (IPv6)
 *   are the most commonly used families. You will usually pass either nil or
 *   Socket::AF_UNSPEC, allowing the IPv6 information to be returned first if
 *   +host+ is reachable via IPv6, and IPv4 information otherwise.  The two
 *   strings &quot;AF_INET&quot; or &quot;AF_INET6&quot; are also allowed, they are converted to
 *   their respective Socket::AF_* constants.
 * - +socktype+ limits the output to a specific type of socket, one of the
 *   Socket::SOCK_* constants. Socket::SOCK_STREAM (for TCP) and
 *   Socket::SOCK_DGRAM (for UDP) are the most commonly used socket types. If
 *   nil, then information for all types of sockets supported by +service+ will
 *   be returned. You will usually know what type of socket you intend to
 *   create, and should pass that socket type in.
 * - +protocol+ limits the output to a specific protocol numpber, one of the
 *   Socket::IPPROTO_* constants. It is usually implied by the socket type
 *   (Socket::SOCK_STREAM =&gt; Socket::IPPROTO_TCP, ...), if you pass other than
 *   nil you already know what this is for.
 * - +flags+ is one of the Socket::AI_* constants. They mean:
 *   - Socket::AI_PASSIVE: when set, if +host+ is nil the 'any' address will be
 *     returned, Socket::INADDR_ANY or 0 for IPv4, &quot;0::0&quot; or &quot;::&quot; for IPv6.  This
 *     address is suitable for use by servers that will bind their socket and do
 *     a passive listen, thus the name of the flag. Otherwise the local or
 *     loopback address will be returned, this is &quot;127.0.0.1&quot; for IPv4 and &quot;::1'
 *     for IPv6.
 *   - ...
 *
 *
 * === Returns
 *
 * Returns an array of arrays, where each subarray contains:
 * - address family, a string like &quot;AF_INET&quot; or &quot;AF_INET6&quot;
 * - port number, the port number for +service+
 * - host name, either a canonical name for +host+, or it's address in presentation
 *   format if the address could not be looked up.
 * - host IP, the address of +host+ in presentation format
 * - address family, as a numeric value (one of the Socket::AF_* constants).
 * - socket type, as a numeric value (one of the Socket::SOCK_* constants).
 * - protocol number, as a numeric value (one of the Socket::IPPROTO_* constants).
 *
 * The first four values are identical to what is commonly returned as an
 * address array, see IPSocket for more information.
 *
 * === Examples
 *
 * Not all input combinations are valid, and while there are many combinations,
 * only a few cases are common.
 *
 * A typical client will call getaddrinfo with the +host+ and +service+ it
 * wants to connect to. It knows that it will attempt to connect with either
 * TCP or UDP, and specifies +socktype+ accordingly. It loops through all
 * returned addresses, and try to connect to them in turn:
 *
 *   addrinfo = Socket::getaddrinfo('www.example.com', 'www', nil, Socket::SOCK_STREAM)
 *   addrinfo.each do |af, port, name, addr|
 *     begin
 *       sock = TCPSocket.new(addr, port)
 *       # ...
 *       exit 1
 *     rescue
 *     end
 *   end
 *
 * With UDP you don't know if connect suceeded, but if communication fails,
 * the next address can be tried.
 *
 * A typical server will call getaddrinfo with a +host+ of nil, the +service+
 * it listens to, and a +flags+ of Socket::AI_PASSIVE. It will listen for
 * connections on the first returned address:
 *   addrinfo = Socket::getaddrinfo(nil, 'www', nil, Socket::SOCK_STREAM, nil, Socket::AI_PASSIVE)
 *   af, port, name, addr = addrinfo.first
 *   sock = TCPServer(addr, port)
 *   while( client = s.accept )
 *     # ...
 *   end
 */
static VALUE
sock_s_getaddrinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE host, port, family, socktype, protocol, flags, ret;
    char hbuf[1024], pbuf[1024];
    char *hptr, *pptr, *ap;
    struct addrinfo hints, *res;
    int error;

    host = port = family = socktype = protocol = flags = Qnil;
    rb_scan_args(argc, argv, &quot;24&quot;, &amp;host, &amp;port, &amp;family, &amp;socktype, &amp;protocol, &amp;flags);
    if (NIL_P(host)) {
	hptr = NULL;
    }
    else {
	strncpy(hbuf, StringValuePtr(host), sizeof(hbuf));
	hbuf[sizeof(hbuf) - 1] = '\0';
	hptr = hbuf;
    }
    if (NIL_P(port)) {
	pptr = NULL;
    }
    else if (FIXNUM_P(port)) {
	snprintf(pbuf, sizeof(pbuf), &quot;%ld&quot;, FIX2LONG(port));
	pptr = pbuf;
    }
    else {
	strncpy(pbuf, StringValuePtr(port), sizeof(pbuf));
	pbuf[sizeof(pbuf) - 1] = '\0';
	pptr = pbuf;
    }

    MEMZERO(&amp;hints, struct addrinfo, 1);
    if (NIL_P(family)) {
	hints.ai_family = PF_UNSPEC;
    }
    else if (FIXNUM_P(family)) {
	hints.ai_family = FIX2INT(family);
    }
    else if ((ap = StringValuePtr(family)) != 0) {
	if (strcmp(ap, &quot;AF_INET&quot;) == 0) {
	    hints.ai_family = PF_INET;
	}
#ifdef INET6
	else if (strcmp(ap, &quot;AF_INET6&quot;) == 0) {
	    hints.ai_family = PF_INET6;
	}
#endif
    }

    if (!NIL_P(socktype)) {
	hints.ai_socktype = NUM2INT(socktype);
    }
    if (!NIL_P(protocol)) {
	hints.ai_protocol = NUM2INT(protocol);
    }
    if (!NIL_P(flags)) {
	hints.ai_flags = NUM2INT(flags);
    }
    error = getaddrinfo(hptr, pptr, &amp;hints, &amp;res);
    if (error) {
	rb_raise(rb_eSocket, &quot;getaddrinfo: %s&quot;, gai_strerror(error));
    }

    ret = make_addrinfo(res);
    freeaddrinfo(res);
    return ret;
}

static VALUE
sock_s_getnameinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE sa, af = Qnil, host = Qnil, port = Qnil, flags, tmp;
    char *hptr, *pptr;
    char hbuf[1024], pbuf[1024];
    int fl;
    struct addrinfo hints, *res = NULL, *r;
    int error;
    struct sockaddr_storage ss;
    struct sockaddr *sap;
    char *ap;

    sa = flags = Qnil;
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;sa, &amp;flags);

    fl = 0;
    if (!NIL_P(flags)) {
	fl = NUM2INT(flags);
    }
    tmp = rb_check_string_type(sa);
    if (!NIL_P(tmp)) {
	sa = tmp;
	if (sizeof(ss) &lt; RSTRING(sa)-&gt;len) {
	    rb_raise(rb_eTypeError, &quot;sockaddr length too big&quot;);
	}
	memcpy(&amp;ss, RSTRING(sa)-&gt;ptr, RSTRING(sa)-&gt;len);
	if (RSTRING(sa)-&gt;len != SA_LEN((struct sockaddr*)&amp;ss)) {
	    rb_raise(rb_eTypeError, &quot;sockaddr size differs - should not happen&quot;);
	}
	sap = (struct sockaddr*)&amp;ss;
	goto call_nameinfo;
    }
    tmp = rb_check_array_type(sa);
    if (!NIL_P(tmp)) {
	sa = tmp;
	MEMZERO(&amp;hints, struct addrinfo, 1);
	if (RARRAY(sa)-&gt;len == 3) {
	    af = RARRAY(sa)-&gt;ptr[0];
	    port = RARRAY(sa)-&gt;ptr[1];
	    host = RARRAY(sa)-&gt;ptr[2];
	}
	else if (RARRAY(sa)-&gt;len &gt;= 4) {
	    af = RARRAY(sa)-&gt;ptr[0];
	    port = RARRAY(sa)-&gt;ptr[1];
	    host = RARRAY(sa)-&gt;ptr[3];
	    if (NIL_P(host)) {
		host = RARRAY(sa)-&gt;ptr[2];
	    }
	    else {
		/*
		 * 4th element holds numeric form, don't resolve.
		 * see ipaddr().
		 */
#ifdef AI_NUMERICHOST /* AIX 4.3.3 doesn't have AI_NUMERICHOST. */
		hints.ai_flags |= AI_NUMERICHOST;
#endif
	    }
	}
	else {
	    rb_raise(rb_eArgError, &quot;array size should be 3 or 4, %ld given&quot;,
		     RARRAY(sa)-&gt;len);
	}
	/* host */
	if (NIL_P(host)) {
	    hptr = NULL;
	}
	else {
	    strncpy(hbuf, StringValuePtr(host), sizeof(hbuf));
	    hbuf[sizeof(hbuf) - 1] = '\0';
	    hptr = hbuf;
	}
	/* port */
	if (NIL_P(port)) {
	    strcpy(pbuf, &quot;0&quot;);
	    pptr = NULL;
	}
	else if (FIXNUM_P(port)) {
	    snprintf(pbuf, sizeof(pbuf), &quot;%ld&quot;, NUM2LONG(port));
	    pptr = pbuf;
	}
	else {
	    strncpy(pbuf, StringValuePtr(port), sizeof(pbuf));
	    pbuf[sizeof(pbuf) - 1] = '\0';
	    pptr = pbuf;
	}
	hints.ai_socktype = (fl &amp; NI_DGRAM) ? SOCK_DGRAM : SOCK_STREAM;
	/* af */
	if (NIL_P(af)) {
	    hints.ai_family = PF_UNSPEC;
	}
	else if (FIXNUM_P(af)) {
	    hints.ai_family = FIX2INT(af);
	}
	else if ((ap = StringValuePtr(af)) != 0) {
	    if (strcmp(ap, &quot;AF_INET&quot;) == 0) {
		hints.ai_family = PF_INET;
	    }
#ifdef INET6
	    else if (strcmp(ap, &quot;AF_INET6&quot;) == 0) {
		hints.ai_family = PF_INET6;
	    }
#endif
	}
	error = getaddrinfo(hptr, pptr, &amp;hints, &amp;res);
	if (error) goto error_exit_addr;
	sap = res-&gt;ai_addr;
    }
    else {
	rb_raise(rb_eTypeError, &quot;expecting String or Array&quot;);
    }

  call_nameinfo:
    error = getnameinfo(sap, SA_LEN(sap), hbuf, sizeof(hbuf),
			pbuf, sizeof(pbuf), fl);
    if (error) goto error_exit_name;
    if (res) {
	for (r = res-&gt;ai_next; r; r = r-&gt;ai_next) {
	    char hbuf2[1024], pbuf2[1024];

	    sap = r-&gt;ai_addr;
	    error = getnameinfo(sap, SA_LEN(sap), hbuf2, sizeof(hbuf2),
				pbuf2, sizeof(pbuf2), fl);
	    if (error) goto error_exit_name;
	    if (strcmp(hbuf, hbuf2) != 0|| strcmp(pbuf, pbuf2) != 0) {
		freeaddrinfo(res);
		rb_raise(rb_eSocket, &quot;sockaddr resolved to multiple nodename&quot;);
	    }
	}
	freeaddrinfo(res);
    }
    return rb_assoc_new(rb_str_new2(hbuf), rb_str_new2(pbuf));

  error_exit_addr:
    if (res) freeaddrinfo(res);
    rb_raise(rb_eSocket, &quot;getaddrinfo: %s&quot;, gai_strerror(error));

  error_exit_name:
    if (res) freeaddrinfo(res);
    rb_raise(rb_eSocket, &quot;getnameinfo: %s&quot;, gai_strerror(error));
}

static VALUE
sock_s_pack_sockaddr_in(self, port, host)
    VALUE self, port, host;
{
    struct addrinfo *res = sock_addrinfo(host, port, 0, 0);
    VALUE addr = rb_str_new((char*)res-&gt;ai_addr, res-&gt;ai_addrlen);

    freeaddrinfo(res);
    OBJ_INFECT(addr, port);
    OBJ_INFECT(addr, host);

    return addr;
}

static VALUE
sock_s_unpack_sockaddr_in(self, addr)
    VALUE self, addr;
{
    struct sockaddr_in * sockaddr;
    VALUE host;

    sockaddr = (struct sockaddr_in*)StringValuePtr(addr);
    if (((struct sockaddr *)sockaddr)-&gt;sa_family != AF_INET
#ifdef INET6
        &amp;&amp; ((struct sockaddr *)sockaddr)-&gt;sa_family != AF_INET6
#endif
        ) {
#ifdef INET6
        rb_raise(rb_eArgError, &quot;not an AF_INET/AF_INET6 sockaddr&quot;);
#else
        rb_raise(rb_eArgError, &quot;not an AF_INET sockaddr&quot;);
#endif
    }
    host = make_ipaddr((struct sockaddr*)sockaddr);
    OBJ_INFECT(host, addr);
    return rb_assoc_new(INT2NUM(ntohs(sockaddr-&gt;sin_port)), host);
}

#ifdef HAVE_SYS_UN_H
static VALUE
sock_s_pack_sockaddr_un(self, path)
    VALUE self, path;
{
    struct sockaddr_un sockaddr;
    char *sun_path;
    VALUE addr;

    MEMZERO(&amp;sockaddr, struct sockaddr_un, 1);
    sockaddr.sun_family = AF_UNIX;
    sun_path = StringValueCStr(path);
    if (sizeof(sockaddr.sun_path) &lt;= strlen(sun_path)) {
        rb_raise(rb_eArgError, &quot;too long unix socket path (max: %dbytes)&quot;,
            (int)sizeof(sockaddr.sun_path)-1);
    }
    strncpy(sockaddr.sun_path, sun_path, sizeof(sockaddr.sun_path)-1);
    addr = rb_str_new((char*)&amp;sockaddr, sizeof(sockaddr));
    OBJ_INFECT(addr, path);

    return addr;
}

static VALUE
sock_s_unpack_sockaddr_un(self, addr)
    VALUE self, addr;
{
    struct sockaddr_un * sockaddr;
    char *sun_path;
    VALUE path;

    sockaddr = (struct sockaddr_un*)StringValuePtr(addr);
    if (((struct sockaddr *)sockaddr)-&gt;sa_family != AF_UNIX) {
        rb_raise(rb_eArgError, &quot;not an AF_UNIX sockaddr&quot;);
    }
    if (sizeof(struct sockaddr_un) &lt; RSTRING(addr)-&gt;len) {
        rb_raise(rb_eTypeError, &quot;too long sockaddr_un - %ld longer than %d&quot;,
		 RSTRING(addr)-&gt;len, sizeof(struct sockaddr_un));
    }
    sun_path = unixpath(sockaddr, RSTRING(addr)-&gt;len);
    if (sizeof(struct sockaddr_un) == RSTRING(addr)-&gt;len &amp;&amp;
        sun_path == sockaddr-&gt;sun_path &amp;&amp;
        sun_path + strlen(sun_path) == RSTRING(addr)-&gt;ptr + RSTRING(addr)-&gt;len) {
        rb_raise(rb_eArgError, &quot;sockaddr_un.sun_path not NUL terminated&quot;);
    }
    path = rb_str_new2(sun_path);
    OBJ_INFECT(path, addr);
    return path;
}
#endif

static VALUE mConst;

static void
sock_define_const(name, value)
    char *name;
    int value;
{
    rb_define_const(rb_cSocket, name, INT2FIX(value));
    rb_define_const(mConst, name, INT2FIX(value));
}

/*
 * Class +Socket+ provides access to the underlying operating system
 * socket implementations. It can be used to provide more operating system
 * specific functionality than the protocol-specific socket classes but at the
 * expense of greater complexity. In particular, the class handles addresses
 * using +struct sockaddr+ structures packed into Ruby strings, which can be
 * a joy to manipulate.
 * 
 * === Exception Handling
 * Ruby's implementation of +Socket+ causes an exception to be raised
 * based on the error generated by the system dependent implementation.
 * This is why the methods are documented in a way that isolate
 * Unix-based system exceptions from Windows based exceptions. If more
 * information on particular exception is needed please refer to the 
 * Unix manual pages or the Windows WinSock reference.
 * 
 * 
 * === Documentation by
 * * Zach Dennis
 * * Sam Roberts
 * * &lt;em&gt;Programming Ruby&lt;/em&gt; from The Pragmatic Bookshelf.  
 * 
 * Much material in this documentation is taken with permission from  
 * &lt;em&gt;Programming Ruby&lt;/em&gt; from The Pragmatic Bookshelf.  
 */
void
Init_socket()
{
    rb_eSocket = rb_define_class(&quot;SocketError&quot;, rb_eStandardError);

    rb_cBasicSocket = rb_define_class(&quot;BasicSocket&quot;, rb_cIO);
    rb_undef_method(rb_cBasicSocket, &quot;initialize&quot;);

    rb_define_singleton_method(rb_cBasicSocket, &quot;do_not_reverse_lookup&quot;,
			       bsock_do_not_rev_lookup, 0);
    rb_define_singleton_method(rb_cBasicSocket, &quot;do_not_reverse_lookup=&quot;,
			       bsock_do_not_rev_lookup_set, 1);
    rb_define_singleton_method(rb_cBasicSocket, &quot;for_fd&quot;, bsock_s_for_fd, 1);

    rb_define_method(rb_cBasicSocket, &quot;close_read&quot;, bsock_close_read, 0);
    rb_define_method(rb_cBasicSocket, &quot;close_write&quot;, bsock_close_write, 0);
    rb_define_method(rb_cBasicSocket, &quot;shutdown&quot;, bsock_shutdown, -1);
    rb_define_method(rb_cBasicSocket, &quot;setsockopt&quot;, bsock_setsockopt, 3);
    rb_define_method(rb_cBasicSocket, &quot;getsockopt&quot;, bsock_getsockopt, 2);
    rb_define_method(rb_cBasicSocket, &quot;getsockname&quot;, bsock_getsockname, 0);
    rb_define_method(rb_cBasicSocket, &quot;getpeername&quot;, bsock_getpeername, 0);
    rb_define_method(rb_cBasicSocket, &quot;send&quot;, bsock_send, -1);
    rb_define_method(rb_cBasicSocket, &quot;recv&quot;, bsock_recv, -1);
    rb_define_method(rb_cBasicSocket, &quot;recv_nonblock&quot;, bsock_recv_nonblock, -1);

    rb_cIPSocket = rb_define_class(&quot;IPSocket&quot;, rb_cBasicSocket);
    rb_define_global_const(&quot;IPsocket&quot;, rb_cIPSocket);
    rb_define_method(rb_cIPSocket, &quot;addr&quot;, ip_addr, 0);
    rb_define_method(rb_cIPSocket, &quot;peeraddr&quot;, ip_peeraddr, 0);
    rb_define_method(rb_cIPSocket, &quot;recvfrom&quot;, ip_recvfrom, -1);
    rb_define_singleton_method(rb_cIPSocket, &quot;getaddress&quot;, ip_s_getaddress, 1);

    rb_cTCPSocket = rb_define_class(&quot;TCPSocket&quot;, rb_cIPSocket);
    rb_define_global_const(&quot;TCPsocket&quot;, rb_cTCPSocket);
    rb_define_singleton_method(rb_cTCPSocket, &quot;gethostbyname&quot;, tcp_s_gethostbyname, 1);
    rb_define_method(rb_cTCPSocket, &quot;initialize&quot;, tcp_init, -1);

#ifdef SOCKS
    rb_cSOCKSSocket = rb_define_class(&quot;SOCKSSocket&quot;, rb_cTCPSocket);
    rb_define_global_const(&quot;SOCKSsocket&quot;, rb_cSOCKSSocket);
    rb_define_method(rb_cSOCKSSocket, &quot;initialize&quot;, socks_init, 2);
#ifdef SOCKS5
    rb_define_method(rb_cSOCKSSocket, &quot;close&quot;, socks_s_close, 0);
#endif
#endif

    rb_cTCPServer = rb_define_class(&quot;TCPServer&quot;, rb_cTCPSocket);
    rb_define_global_const(&quot;TCPserver&quot;, rb_cTCPServer);
    rb_define_method(rb_cTCPServer, &quot;accept&quot;, tcp_accept, 0);
    rb_define_method(rb_cTCPServer, &quot;accept_nonblock&quot;, tcp_accept_nonblock, 0);
    rb_define_method(rb_cTCPServer, &quot;sysaccept&quot;, tcp_sysaccept, 0);
    rb_define_method(rb_cTCPServer, &quot;initialize&quot;, tcp_svr_init, -1);
    rb_define_method(rb_cTCPServer, &quot;listen&quot;, sock_listen, 1);

    rb_cUDPSocket = rb_define_class(&quot;UDPSocket&quot;, rb_cIPSocket);
    rb_define_global_const(&quot;UDPsocket&quot;, rb_cUDPSocket);
    rb_define_method(rb_cUDPSocket, &quot;initialize&quot;, udp_init, -1);
    rb_define_method(rb_cUDPSocket, &quot;connect&quot;, udp_connect, 2);
    rb_define_method(rb_cUDPSocket, &quot;bind&quot;, udp_bind, 2);
    rb_define_method(rb_cUDPSocket, &quot;send&quot;, udp_send, -1);
    rb_define_method(rb_cUDPSocket, &quot;recvfrom_nonblock&quot;, udp_recvfrom_nonblock, -1);

#ifdef HAVE_SYS_UN_H
    rb_cUNIXSocket = rb_define_class(&quot;UNIXSocket&quot;, rb_cBasicSocket);
    rb_define_global_const(&quot;UNIXsocket&quot;, rb_cUNIXSocket);
    rb_define_method(rb_cUNIXSocket, &quot;initialize&quot;, unix_init, 1);
    rb_define_method(rb_cUNIXSocket, &quot;path&quot;, unix_path, 0);
    rb_define_method(rb_cUNIXSocket, &quot;addr&quot;, unix_addr, 0);
    rb_define_method(rb_cUNIXSocket, &quot;peeraddr&quot;, unix_peeraddr, 0);
    rb_define_method(rb_cUNIXSocket, &quot;recvfrom&quot;, unix_recvfrom, -1);
    rb_define_method(rb_cUNIXSocket, &quot;send_io&quot;, unix_send_io, 1);
    rb_define_method(rb_cUNIXSocket, &quot;recv_io&quot;, unix_recv_io, -1);
    rb_define_singleton_method(rb_cUNIXSocket, &quot;socketpair&quot;, unix_s_socketpair, -1);
    rb_define_singleton_method(rb_cUNIXSocket, &quot;pair&quot;, unix_s_socketpair, -1);

    rb_cUNIXServer = rb_define_class(&quot;UNIXServer&quot;, rb_cUNIXSocket);
    rb_define_global_const(&quot;UNIXserver&quot;, rb_cUNIXServer);
    rb_define_method(rb_cUNIXServer, &quot;initialize&quot;, unix_svr_init, 1);
    rb_define_method(rb_cUNIXServer, &quot;accept&quot;, unix_accept, 0);
    rb_define_method(rb_cUNIXServer, &quot;accept_nonblock&quot;, unix_accept_nonblock, 0);
    rb_define_method(rb_cUNIXServer, &quot;sysaccept&quot;, unix_sysaccept, 0);
    rb_define_method(rb_cUNIXServer, &quot;listen&quot;, sock_listen, 1);
#endif

    rb_cSocket = rb_define_class(&quot;Socket&quot;, rb_cBasicSocket);

    rb_define_method(rb_cSocket, &quot;initialize&quot;, sock_initialize, 3);
    rb_define_method(rb_cSocket, &quot;connect&quot;, sock_connect, 1);
    rb_define_method(rb_cSocket, &quot;connect_nonblock&quot;, sock_connect_nonblock, 1);
    rb_define_method(rb_cSocket, &quot;bind&quot;, sock_bind, 1);
    rb_define_method(rb_cSocket, &quot;listen&quot;, sock_listen, 1);
    rb_define_method(rb_cSocket, &quot;accept&quot;, sock_accept, 0);
    rb_define_method(rb_cSocket, &quot;accept_nonblock&quot;, sock_accept_nonblock, 0);
    rb_define_method(rb_cSocket, &quot;sysaccept&quot;, sock_sysaccept, 0);

    rb_define_method(rb_cSocket, &quot;recvfrom&quot;, sock_recvfrom, -1);
    rb_define_method(rb_cSocket, &quot;recvfrom_nonblock&quot;, sock_recvfrom_nonblock, -1);

    rb_define_singleton_method(rb_cSocket, &quot;socketpair&quot;, sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, &quot;pair&quot;, sock_s_socketpair, 3);
    rb_define_singleton_method(rb_cSocket, &quot;gethostname&quot;, sock_gethostname, 0);
    rb_define_singleton_method(rb_cSocket, &quot;gethostbyname&quot;, sock_s_gethostbyname, 1);
    rb_define_singleton_method(rb_cSocket, &quot;gethostbyaddr&quot;, sock_s_gethostbyaddr, -1);
    rb_define_singleton_method(rb_cSocket, &quot;getservbyname&quot;, sock_s_getservbyaname, -1);
    rb_define_singleton_method(rb_cSocket, &quot;getaddrinfo&quot;, sock_s_getaddrinfo, -1);
    rb_define_singleton_method(rb_cSocket, &quot;getnameinfo&quot;, sock_s_getnameinfo, -1);
    rb_define_singleton_method(rb_cSocket, &quot;sockaddr_in&quot;, sock_s_pack_sockaddr_in, 2);
    rb_define_singleton_method(rb_cSocket, &quot;pack_sockaddr_in&quot;, sock_s_pack_sockaddr_in, 2);
    rb_define_singleton_method(rb_cSocket, &quot;unpack_sockaddr_in&quot;, sock_s_unpack_sockaddr_in, 1);
#ifdef HAVE_SYS_UN_H
    rb_define_singleton_method(rb_cSocket, &quot;sockaddr_un&quot;, sock_s_pack_sockaddr_un, 1);
    rb_define_singleton_method(rb_cSocket, &quot;pack_sockaddr_un&quot;, sock_s_pack_sockaddr_un, 1);
    rb_define_singleton_method(rb_cSocket, &quot;unpack_sockaddr_un&quot;, sock_s_unpack_sockaddr_un, 1);
#endif

    /* constants */
    mConst = rb_define_module_under(rb_cSocket, &quot;Constants&quot;);
    sock_define_const(&quot;SOCK_STREAM&quot;, SOCK_STREAM);
    sock_define_const(&quot;SOCK_DGRAM&quot;, SOCK_DGRAM);
#ifdef SOCK_RAW
    sock_define_const(&quot;SOCK_RAW&quot;, SOCK_RAW);
#endif
#ifdef SOCK_RDM
    sock_define_const(&quot;SOCK_RDM&quot;, SOCK_RDM);
#endif
#ifdef SOCK_SEQPACKET
    sock_define_const(&quot;SOCK_SEQPACKET&quot;, SOCK_SEQPACKET);
#endif
#ifdef SOCK_PACKET
    sock_define_const(&quot;SOCK_PACKET&quot;, SOCK_PACKET);
#endif

    sock_define_const(&quot;AF_INET&quot;, AF_INET);
#ifdef PF_INET
    sock_define_const(&quot;PF_INET&quot;, PF_INET);
#endif
#ifdef AF_UNIX
    sock_define_const(&quot;AF_UNIX&quot;, AF_UNIX);
    sock_define_const(&quot;PF_UNIX&quot;, PF_UNIX);
#endif
#ifdef AF_AX25
    sock_define_const(&quot;AF_AX25&quot;, AF_AX25);
    sock_define_const(&quot;PF_AX25&quot;, PF_AX25);
#endif
#ifdef AF_IPX
    sock_define_const(&quot;AF_IPX&quot;, AF_IPX);
    sock_define_const(&quot;PF_IPX&quot;, PF_IPX);
#endif
#ifdef AF_APPLETALK
    sock_define_const(&quot;AF_APPLETALK&quot;, AF_APPLETALK);
    sock_define_const(&quot;PF_APPLETALK&quot;, PF_APPLETALK);
#endif
#ifdef AF_UNSPEC
    sock_define_const(&quot;AF_UNSPEC&quot;, AF_UNSPEC);
    sock_define_const(&quot;PF_UNSPEC&quot;, PF_UNSPEC);
#endif
#ifdef INET6
    sock_define_const(&quot;AF_INET6&quot;, AF_INET6);
#endif
#ifdef INET6
    sock_define_const(&quot;PF_INET6&quot;, PF_INET6);
#endif
#ifdef AF_LOCAL
    sock_define_const(&quot;AF_LOCAL&quot;, AF_LOCAL);
#endif
#ifdef PF_LOCAL
    sock_define_const(&quot;PF_LOCAL&quot;, PF_LOCAL);
#endif
#ifdef AF_IMPLINK
    sock_define_const(&quot;AF_IMPLINK&quot;, AF_IMPLINK);
#endif
#ifdef PF_IMPLINK
    sock_define_const(&quot;PF_IMPLINK&quot;, PF_IMPLINK);
#endif
#ifdef AF_PUP
    sock_define_const(&quot;AF_PUP&quot;, AF_PUP);
#endif
#ifdef PF_PUP
    sock_define_const(&quot;PF_PUP&quot;, PF_PUP);
#endif
#ifdef AF_CHAOS
    sock_define_const(&quot;AF_CHAOS&quot;, AF_CHAOS);
#endif
#ifdef PF_CHAOS
    sock_define_const(&quot;PF_CHAOS&quot;, PF_CHAOS);
#endif
#ifdef AF_NS
    sock_define_const(&quot;AF_NS&quot;, AF_NS);
#endif
#ifdef PF_NS
    sock_define_const(&quot;PF_NS&quot;, PF_NS);
#endif
#ifdef AF_ISO
    sock_define_const(&quot;AF_ISO&quot;, AF_ISO);
#endif
#ifdef PF_ISO
    sock_define_const(&quot;PF_ISO&quot;, PF_ISO);
#endif
#ifdef AF_OSI
    sock_define_const(&quot;AF_OSI&quot;, AF_OSI);
#endif
#ifdef PF_OSI
    sock_define_const(&quot;PF_OSI&quot;, PF_OSI);
#endif
#ifdef AF_ECMA
    sock_define_const(&quot;AF_ECMA&quot;, AF_ECMA);
#endif
#ifdef PF_ECMA
    sock_define_const(&quot;PF_ECMA&quot;, PF_ECMA);
#endif
#ifdef AF_DATAKIT
    sock_define_const(&quot;AF_DATAKIT&quot;, AF_DATAKIT);
#endif
#ifdef PF_DATAKIT
    sock_define_const(&quot;PF_DATAKIT&quot;, PF_DATAKIT);
#endif
#ifdef AF_CCITT
    sock_define_const(&quot;AF_CCITT&quot;, AF_CCITT);
#endif
#ifdef PF_CCITT
    sock_define_const(&quot;PF_CCITT&quot;, PF_CCITT);
#endif
#ifdef AF_SNA
    sock_define_const(&quot;AF_SNA&quot;, AF_SNA);
#endif
#ifdef PF_SNA
    sock_define_const(&quot;PF_SNA&quot;, PF_SNA);
#endif
#ifdef AF_DEC
    sock_define_const(&quot;AF_DEC&quot;, AF_DEC);
#endif
#ifdef PF_DEC
    sock_define_const(&quot;PF_DEC&quot;, PF_DEC);
#endif
#ifdef AF_DLI
    sock_define_const(&quot;AF_DLI&quot;, AF_DLI);
#endif
#ifdef PF_DLI
    sock_define_const(&quot;PF_DLI&quot;, PF_DLI);
#endif
#ifdef AF_LAT
    sock_define_const(&quot;AF_LAT&quot;, AF_LAT);
#endif
#ifdef PF_LAT
    sock_define_const(&quot;PF_LAT&quot;, PF_LAT);
#endif
#ifdef AF_HYLINK
    sock_define_const(&quot;AF_HYLINK&quot;, AF_HYLINK);
#endif
#ifdef PF_HYLINK
    sock_define_const(&quot;PF_HYLINK&quot;, PF_HYLINK);
#endif
#ifdef AF_ROUTE
    sock_define_const(&quot;AF_ROUTE&quot;, AF_ROUTE);
#endif
#ifdef PF_ROUTE
    sock_define_const(&quot;PF_ROUTE&quot;, PF_ROUTE);
#endif
#ifdef AF_LINK
    sock_define_const(&quot;AF_LINK&quot;, AF_LINK);
#endif
#ifdef PF_LINK
    sock_define_const(&quot;PF_LINK&quot;, PF_LINK);
#endif
#ifdef AF_COIP
    sock_define_const(&quot;AF_COIP&quot;, AF_COIP);
#endif
#ifdef PF_COIP
    sock_define_const(&quot;PF_COIP&quot;, PF_COIP);
#endif
#ifdef AF_CNT
    sock_define_const(&quot;AF_CNT&quot;, AF_CNT);
#endif
#ifdef PF_CNT
    sock_define_const(&quot;PF_CNT&quot;, PF_CNT);
#endif
#ifdef AF_SIP
    sock_define_const(&quot;AF_SIP&quot;, AF_SIP);
#endif
#ifdef PF_SIP
    sock_define_const(&quot;PF_SIP&quot;, PF_SIP);
#endif
#ifdef AF_NDRV
    sock_define_const(&quot;AF_NDRV&quot;, AF_NDRV);
#endif
#ifdef PF_NDRV
    sock_define_const(&quot;PF_NDRV&quot;, PF_NDRV);
#endif
#ifdef AF_ISDN
    sock_define_const(&quot;AF_ISDN&quot;, AF_ISDN);
#endif
#ifdef PF_ISDN
    sock_define_const(&quot;PF_ISDN&quot;, PF_ISDN);
#endif
#ifdef AF_NATM
    sock_define_const(&quot;AF_NATM&quot;, AF_NATM);
#endif
#ifdef PF_NATM
    sock_define_const(&quot;PF_NATM&quot;, PF_NATM);
#endif
#ifdef AF_SYSTEM
    sock_define_const(&quot;AF_SYSTEM&quot;, AF_SYSTEM);
#endif
#ifdef PF_SYSTEM
    sock_define_const(&quot;PF_SYSTEM&quot;, PF_SYSTEM);
#endif
#ifdef AF_NETBIOS
    sock_define_const(&quot;AF_NETBIOS&quot;, AF_NETBIOS);
#endif
#ifdef PF_NETBIOS
    sock_define_const(&quot;PF_NETBIOS&quot;, PF_NETBIOS);
#endif
#ifdef AF_PPP
    sock_define_const(&quot;AF_PPP&quot;, AF_PPP);
#endif
#ifdef PF_PPP
    sock_define_const(&quot;PF_PPP&quot;, PF_PPP);
#endif
#ifdef AF_ATM
    sock_define_const(&quot;AF_ATM&quot;, AF_ATM);
#endif
#ifdef PF_ATM
    sock_define_const(&quot;PF_ATM&quot;, PF_ATM);
#endif
#ifdef AF_NETGRAPH
    sock_define_const(&quot;AF_NETGRAPH&quot;, AF_NETGRAPH);
#endif
#ifdef PF_NETGRAPH
    sock_define_const(&quot;PF_NETGRAPH&quot;, PF_NETGRAPH);
#endif
#ifdef AF_MAX
    sock_define_const(&quot;AF_MAX&quot;, AF_MAX);
#endif
#ifdef PF_MAX
    sock_define_const(&quot;PF_MAX&quot;, PF_MAX);
#endif
#ifdef AF_E164
    sock_define_const(&quot;AF_E164&quot;, AF_E164);
#endif
#ifdef PF_XTP
    sock_define_const(&quot;PF_XTP&quot;, PF_XTP);
#endif
#ifdef PF_RTIP
    sock_define_const(&quot;PF_RTIP&quot;, PF_RTIP);
#endif
#ifdef PF_PIP
    sock_define_const(&quot;PF_PIP&quot;, PF_PIP);
#endif
#ifdef PF_KEY
    sock_define_const(&quot;PF_KEY&quot;, PF_KEY);
#endif

    sock_define_const(&quot;MSG_OOB&quot;, MSG_OOB);
#ifdef MSG_PEEK
    sock_define_const(&quot;MSG_PEEK&quot;, MSG_PEEK);
#endif
#ifdef MSG_DONTROUTE
    sock_define_const(&quot;MSG_DONTROUTE&quot;, MSG_DONTROUTE);
#endif
#ifdef MSG_EOR
    sock_define_const(&quot;MSG_EOR&quot;, MSG_EOR);
#endif
#ifdef MSG_TRUNC
    sock_define_const(&quot;MSG_TRUNC&quot;, MSG_TRUNC);
#endif
#ifdef MSG_CTRUNC
    sock_define_const(&quot;MSG_CTRUNC&quot;, MSG_CTRUNC);
#endif
#ifdef MSG_WAITALL
    sock_define_const(&quot;MSG_WAITALL&quot;, MSG_WAITALL);
#endif
#ifdef MSG_DONTWAIT
    sock_define_const(&quot;MSG_DONTWAIT&quot;, MSG_DONTWAIT);
#endif
#ifdef MSG_EOF
    sock_define_const(&quot;MSG_EOF&quot;, MSG_EOF);
#endif
#ifdef MSG_FLUSH
    sock_define_const(&quot;MSG_FLUSH&quot;, MSG_FLUSH);
#endif
#ifdef MSG_HOLD
    sock_define_const(&quot;MSG_HOLD&quot;, MSG_HOLD);
#endif
#ifdef MSG_SEND
    sock_define_const(&quot;MSG_SEND&quot;, MSG_SEND);
#endif
#ifdef MSG_HAVEMORE
    sock_define_const(&quot;MSG_HAVEMORE&quot;, MSG_HAVEMORE);
#endif
#ifdef MSG_RCVMORE
    sock_define_const(&quot;MSG_RCVMORE&quot;, MSG_RCVMORE);
#endif
#ifdef MSG_COMPAT
    sock_define_const(&quot;MSG_COMPAT&quot;, MSG_COMPAT);
#endif

    sock_define_const(&quot;SOL_SOCKET&quot;, SOL_SOCKET);
#ifdef SOL_IP
    sock_define_const(&quot;SOL_IP&quot;, SOL_IP);
#endif
#ifdef SOL_IPX
    sock_define_const(&quot;SOL_IPX&quot;, SOL_IPX);
#endif
#ifdef SOL_AX25
    sock_define_const(&quot;SOL_AX25&quot;, SOL_AX25);
#endif
#ifdef SOL_ATALK
    sock_define_const(&quot;SOL_ATALK&quot;, SOL_ATALK);
#endif
#ifdef SOL_TCP
    sock_define_const(&quot;SOL_TCP&quot;, SOL_TCP);
#endif
#ifdef SOL_UDP
    sock_define_const(&quot;SOL_UDP&quot;, SOL_UDP);
#endif

#ifdef	IPPROTO_IP
    sock_define_const(&quot;IPPROTO_IP&quot;, IPPROTO_IP);
#else
    sock_define_const(&quot;IPPROTO_IP&quot;, 0);
#endif
#ifdef	IPPROTO_ICMP
    sock_define_const(&quot;IPPROTO_ICMP&quot;, IPPROTO_ICMP);
#else
    sock_define_const(&quot;IPPROTO_ICMP&quot;, 1);
#endif
#ifdef	IPPROTO_IGMP
    sock_define_const(&quot;IPPROTO_IGMP&quot;, IPPROTO_IGMP);
#endif
#ifdef	IPPROTO_GGP
    sock_define_const(&quot;IPPROTO_GGP&quot;, IPPROTO_GGP);
#endif
#ifdef	IPPROTO_TCP
    sock_define_const(&quot;IPPROTO_TCP&quot;, IPPROTO_TCP);
#else
    sock_define_const(&quot;IPPROTO_TCP&quot;, 6);
#endif
#ifdef	IPPROTO_EGP
    sock_define_const(&quot;IPPROTO_EGP&quot;, IPPROTO_EGP);
#endif
#ifdef	IPPROTO_PUP
    sock_define_const(&quot;IPPROTO_PUP&quot;, IPPROTO_PUP);
#endif
#ifdef	IPPROTO_UDP
    sock_define_const(&quot;IPPROTO_UDP&quot;, IPPROTO_UDP);
#else
    sock_define_const(&quot;IPPROTO_UDP&quot;, 17);
#endif
#ifdef	IPPROTO_IDP
    sock_define_const(&quot;IPPROTO_IDP&quot;, IPPROTO_IDP);
#endif
#ifdef	IPPROTO_HELLO
    sock_define_const(&quot;IPPROTO_HELLO&quot;, IPPROTO_HELLO);
#endif
#ifdef	IPPROTO_ND
    sock_define_const(&quot;IPPROTO_ND&quot;, IPPROTO_ND);
#endif
#ifdef	IPPROTO_TP
    sock_define_const(&quot;IPPROTO_TP&quot;, IPPROTO_TP);
#endif
#ifdef	IPPROTO_XTP
    sock_define_const(&quot;IPPROTO_XTP&quot;, IPPROTO_XTP);
#endif
#ifdef	IPPROTO_EON
    sock_define_const(&quot;IPPROTO_EON&quot;, IPPROTO_EON);
#endif
#ifdef	IPPROTO_BIP
    sock_define_const(&quot;IPPROTO_BIP&quot;, IPPROTO_BIP);
#endif
/**/
#ifdef	IPPROTO_RAW
    sock_define_const(&quot;IPPROTO_RAW&quot;, IPPROTO_RAW);
#else
    sock_define_const(&quot;IPPROTO_RAW&quot;, 255);
#endif
#ifdef	IPPROTO_MAX
    sock_define_const(&quot;IPPROTO_MAX&quot;, IPPROTO_MAX);
#endif

	/* Some port configuration */
#ifdef	IPPORT_RESERVED
    sock_define_const(&quot;IPPORT_RESERVED&quot;, IPPORT_RESERVED);
#else
    sock_define_const(&quot;IPPORT_RESERVED&quot;, 1024);
#endif
#ifdef	IPPORT_USERRESERVED
    sock_define_const(&quot;IPPORT_USERRESERVED&quot;, IPPORT_USERRESERVED);
#else
    sock_define_const(&quot;IPPORT_USERRESERVED&quot;, 5000);
#endif
	/* Some reserved IP v.4 addresses */
#ifdef	INADDR_ANY
    sock_define_const(&quot;INADDR_ANY&quot;, INADDR_ANY);
#else
    sock_define_const(&quot;INADDR_ANY&quot;, 0x00000000);
#endif
#ifdef	INADDR_BROADCAST
    sock_define_const(&quot;INADDR_BROADCAST&quot;, INADDR_BROADCAST);
#else
    sock_define_const(&quot;INADDR_BROADCAST&quot;, 0xffffffff);
#endif
#ifdef	INADDR_LOOPBACK
    sock_define_const(&quot;INADDR_LOOPBACK&quot;, INADDR_LOOPBACK);
#else
    sock_define_const(&quot;INADDR_LOOPBACK&quot;, 0x7F000001);
#endif
#ifdef	INADDR_UNSPEC_GROUP
    sock_define_const(&quot;INADDR_UNSPEC_GROUP&quot;, INADDR_UNSPEC_GROUP);
#else
    sock_define_const(&quot;INADDR_UNSPEC_GROUP&quot;, 0xe0000000);
#endif
#ifdef	INADDR_ALLHOSTS_GROUP
    sock_define_const(&quot;INADDR_ALLHOSTS_GROUP&quot;, INADDR_ALLHOSTS_GROUP);
#else
    sock_define_const(&quot;INADDR_ALLHOSTS_GROUP&quot;, 0xe0000001);
#endif
#ifdef	INADDR_MAX_LOCAL_GROUP
    sock_define_const(&quot;INADDR_MAX_LOCAL_GROUP&quot;, INADDR_MAX_LOCAL_GROUP);
#else
    sock_define_const(&quot;INADDR_MAX_LOCAL_GROUP&quot;, 0xe00000ff);
#endif
#ifdef	INADDR_NONE
    sock_define_const(&quot;INADDR_NONE&quot;, INADDR_NONE);
#else
    sock_define_const(&quot;INADDR_NONE&quot;, 0xffffffff);
#endif
	/* IP [gs]etsockopt options */
#ifdef	IP_OPTIONS
    sock_define_const(&quot;IP_OPTIONS&quot;, IP_OPTIONS);
#endif
#ifdef	IP_HDRINCL
    sock_define_const(&quot;IP_HDRINCL&quot;, IP_HDRINCL);
#endif
#ifdef	IP_TOS
    sock_define_const(&quot;IP_TOS&quot;, IP_TOS);
#endif
#ifdef	IP_TTL
    sock_define_const(&quot;IP_TTL&quot;, IP_TTL);
#endif
#ifdef	IP_RECVOPTS
    sock_define_const(&quot;IP_RECVOPTS&quot;, IP_RECVOPTS);
#endif
#ifdef	IP_RECVRETOPTS
    sock_define_const(&quot;IP_RECVRETOPTS&quot;, IP_RECVRETOPTS);
#endif
#ifdef	IP_RECVDSTADDR
    sock_define_const(&quot;IP_RECVDSTADDR&quot;, IP_RECVDSTADDR);
#endif
#ifdef	IP_RETOPTS
    sock_define_const(&quot;IP_RETOPTS&quot;, IP_RETOPTS);
#endif
#ifdef	IP_MULTICAST_IF
    sock_define_const(&quot;IP_MULTICAST_IF&quot;, IP_MULTICAST_IF);
#endif
#ifdef	IP_MULTICAST_TTL
    sock_define_const(&quot;IP_MULTICAST_TTL&quot;, IP_MULTICAST_TTL);
#endif
#ifdef	IP_MULTICAST_LOOP
    sock_define_const(&quot;IP_MULTICAST_LOOP&quot;, IP_MULTICAST_LOOP);
#endif
#ifdef	IP_ADD_MEMBERSHIP
    sock_define_const(&quot;IP_ADD_MEMBERSHIP&quot;, IP_ADD_MEMBERSHIP);
#endif
#ifdef	IP_DROP_MEMBERSHIP
    sock_define_const(&quot;IP_DROP_MEMBERSHIP&quot;, IP_DROP_MEMBERSHIP);
#endif
#ifdef	IP_DEFAULT_MULTICAST_TTL
    sock_define_const(&quot;IP_DEFAULT_MULTICAST_TTL&quot;, IP_DEFAULT_MULTICAST_TTL);
#endif
#ifdef	IP_DEFAULT_MULTICAST_LOOP
    sock_define_const(&quot;IP_DEFAULT_MULTICAST_LOOP&quot;, IP_DEFAULT_MULTICAST_LOOP);
#endif
#ifdef	IP_MAX_MEMBERSHIPS
    sock_define_const(&quot;IP_MAX_MEMBERSHIPS&quot;, IP_MAX_MEMBERSHIPS);
#endif
#ifdef SO_DEBUG
    sock_define_const(&quot;SO_DEBUG&quot;, SO_DEBUG);
#endif
    sock_define_const(&quot;SO_REUSEADDR&quot;, SO_REUSEADDR);
#ifdef SO_REUSEPORT
    sock_define_const(&quot;SO_REUSEPORT&quot;, SO_REUSEPORT);
#endif
#ifdef SO_TYPE
    sock_define_const(&quot;SO_TYPE&quot;, SO_TYPE);
#endif
#ifdef SO_ERROR
    sock_define_const(&quot;SO_ERROR&quot;, SO_ERROR);
#endif
#ifdef SO_DONTROUTE
    sock_define_const(&quot;SO_DONTROUTE&quot;, SO_DONTROUTE);
#endif
#ifdef SO_BROADCAST
    sock_define_const(&quot;SO_BROADCAST&quot;, SO_BROADCAST);
#endif
#ifdef SO_SNDBUF
    sock_define_const(&quot;SO_SNDBUF&quot;, SO_SNDBUF);
#endif
#ifdef SO_RCVBUF
    sock_define_const(&quot;SO_RCVBUF&quot;, SO_RCVBUF);
#endif
#ifdef SO_KEEPALIVE
    sock_define_const(&quot;SO_KEEPALIVE&quot;, SO_KEEPALIVE);
#endif
#ifdef SO_OOBINLINE
    sock_define_const(&quot;SO_OOBINLINE&quot;, SO_OOBINLINE);
#endif
#ifdef SO_NO_CHECK
    sock_define_const(&quot;SO_NO_CHECK&quot;, SO_NO_CHECK);
#endif
#ifdef SO_PRIORITY
    sock_define_const(&quot;SO_PRIORITY&quot;, SO_PRIORITY);
#endif
#ifdef SO_LINGER
    sock_define_const(&quot;SO_LINGER&quot;, SO_LINGER);
#endif
#ifdef SO_PASSCRED
    sock_define_const(&quot;SO_PASSCRED&quot;, SO_PASSCRED);
#endif
#ifdef SO_PEERCRED
    sock_define_const(&quot;SO_PEERCRED&quot;, SO_PEERCRED);
#endif
#ifdef SO_RCVLOWAT
    sock_define_const(&quot;SO_RCVLOWAT&quot;, SO_RCVLOWAT);
#endif
#ifdef SO_SNDLOWAT
    sock_define_const(&quot;SO_SNDLOWAT&quot;, SO_SNDLOWAT);
#endif
#ifdef SO_RCVTIMEO
    sock_define_const(&quot;SO_RCVTIMEO&quot;, SO_RCVTIMEO);
#endif
#ifdef SO_SNDTIMEO
    sock_define_const(&quot;SO_SNDTIMEO&quot;, SO_SNDTIMEO);
#endif
#ifdef SO_ACCEPTCONN
    sock_define_const(&quot;SO_ACCEPTCONN&quot;, SO_ACCEPTCONN);
#endif
#ifdef SO_USELOOPBACK
    sock_define_const(&quot;SO_USELOOPBACK&quot;, SO_USELOOPBACK);
#endif
#ifdef SO_ACCEPTFILTER
    sock_define_const(&quot;SO_ACCEPTFILTER&quot;, SO_ACCEPTFILTER);
#endif
#ifdef SO_DONTTRUNC
    sock_define_const(&quot;SO_DONTTRUNC&quot;, SO_DONTTRUNC);
#endif
#ifdef SO_WANTMORE
    sock_define_const(&quot;SO_WANTMORE&quot;, SO_WANTMORE);
#endif
#ifdef SO_WANTOOBFLAG
    sock_define_const(&quot;SO_WANTOOBFLAG&quot;, SO_WANTOOBFLAG);
#endif
#ifdef SO_NREAD
    sock_define_const(&quot;SO_NREAD&quot;, SO_NREAD);
#endif
#ifdef SO_NKE
    sock_define_const(&quot;SO_NKE&quot;, SO_NKE);
#endif
#ifdef SO_NOSIGPIPE
    sock_define_const(&quot;SO_NOSIGPIPE&quot;, SO_NOSIGPIPE);
#endif

#ifdef SO_SECURITY_AUTHENTICATION
    sock_define_const(&quot;SO_SECURITY_AUTHENTICATION&quot;, SO_SECURITY_AUTHENTICATION);
#endif
#ifdef SO_SECURITY_ENCRYPTION_TRANSPORT
    sock_define_const(&quot;SO_SECURITY_ENCRYPTION_TRANSPORT&quot;, SO_SECURITY_ENCRYPTION_TRANSPORT);
#endif
#ifdef SO_SECURITY_ENCRYPTION_NETWORK
    sock_define_const(&quot;SO_SECURITY_ENCRYPTION_NETWORK&quot;, SO_SECURITY_ENCRYPTION_NETWORK);
#endif

#ifdef SO_BINDTODEVICE
    sock_define_const(&quot;SO_BINDTODEVICE&quot;, SO_BINDTODEVICE);
#endif
#ifdef SO_ATTACH_FILTER
    sock_define_const(&quot;SO_ATTACH_FILTER&quot;, SO_ATTACH_FILTER);
#endif
#ifdef SO_DETACH_FILTER
    sock_define_const(&quot;SO_DETACH_FILTER&quot;, SO_DETACH_FILTER);
#endif
#ifdef SO_PEERNAME
    sock_define_const(&quot;SO_PEERNAME&quot;, SO_PEERNAME);
#endif
#ifdef SO_TIMESTAMP
    sock_define_const(&quot;SO_TIMESTAMP&quot;, SO_TIMESTAMP);
#endif

#ifdef SOPRI_INTERACTIVE
    sock_define_const(&quot;SOPRI_INTERACTIVE&quot;, SOPRI_INTERACTIVE);
#endif
#ifdef SOPRI_NORMAL
    sock_define_const(&quot;SOPRI_NORMAL&quot;, SOPRI_NORMAL);
#endif
#ifdef SOPRI_BACKGROUND
    sock_define_const(&quot;SOPRI_BACKGROUND&quot;, SOPRI_BACKGROUND);
#endif

#ifdef IPX_TYPE
    sock_define_const(&quot;IPX_TYPE&quot;, IPX_TYPE);
#endif

#ifdef TCP_NODELAY
    sock_define_const(&quot;TCP_NODELAY&quot;, TCP_NODELAY);
#endif
#ifdef TCP_MAXSEG
    sock_define_const(&quot;TCP_MAXSEG&quot;, TCP_MAXSEG);
#endif

#ifdef EAI_ADDRFAMILY
    sock_define_const(&quot;EAI_ADDRFAMILY&quot;, EAI_ADDRFAMILY);
#endif
#ifdef EAI_AGAIN
    sock_define_const(&quot;EAI_AGAIN&quot;, EAI_AGAIN);
#endif
#ifdef EAI_BADFLAGS
    sock_define_const(&quot;EAI_BADFLAGS&quot;, EAI_BADFLAGS);
#endif
#ifdef EAI_FAIL
    sock_define_const(&quot;EAI_FAIL&quot;, EAI_FAIL);
#endif
#ifdef EAI_FAMILY
    sock_define_const(&quot;EAI_FAMILY&quot;, EAI_FAMILY);
#endif
#ifdef EAI_MEMORY
    sock_define_const(&quot;EAI_MEMORY&quot;, EAI_MEMORY);
#endif
#ifdef EAI_NODATA
    sock_define_const(&quot;EAI_NODATA&quot;, EAI_NODATA);
#endif
#ifdef EAI_NONAME
    sock_define_const(&quot;EAI_NONAME&quot;, EAI_NONAME);
#endif
#ifdef EAI_SERVICE
    sock_define_const(&quot;EAI_SERVICE&quot;, EAI_SERVICE);
#endif
#ifdef EAI_SOCKTYPE
    sock_define_const(&quot;EAI_SOCKTYPE&quot;, EAI_SOCKTYPE);
#endif
#ifdef EAI_SYSTEM
    sock_define_const(&quot;EAI_SYSTEM&quot;, EAI_SYSTEM);
#endif
#ifdef EAI_BADHINTS
    sock_define_const(&quot;EAI_BADHINTS&quot;, EAI_BADHINTS);
#endif
#ifdef EAI_PROTOCOL
    sock_define_const(&quot;EAI_PROTOCOL&quot;, EAI_PROTOCOL);
#endif
#ifdef EAI_MAX
    sock_define_const(&quot;EAI_MAX&quot;, EAI_MAX);
#endif
#ifdef AI_PASSIVE
    sock_define_const(&quot;AI_PASSIVE&quot;, AI_PASSIVE);
#endif
#ifdef AI_CANONNAME
    sock_define_const(&quot;AI_CANONNAME&quot;, AI_CANONNAME);
#endif
#ifdef AI_NUMERICHOST
    sock_define_const(&quot;AI_NUMERICHOST&quot;, AI_NUMERICHOST);
#endif
#ifdef AI_MASK
    sock_define_const(&quot;AI_MASK&quot;, AI_MASK);
#endif
#ifdef AI_ALL
    sock_define_const(&quot;AI_ALL&quot;, AI_ALL);
#endif
#ifdef AI_V4MAPPED_CFG
    sock_define_const(&quot;AI_V4MAPPED_CFG&quot;, AI_V4MAPPED_CFG);
#endif
#ifdef AI_ADDRCONFIG
    sock_define_const(&quot;AI_ADDRCONFIG&quot;, AI_ADDRCONFIG);
#endif
#ifdef AI_V4MAPPED
    sock_define_const(&quot;AI_V4MAPPED&quot;, AI_V4MAPPED);
#endif
#ifdef AI_DEFAULT
    sock_define_const(&quot;AI_DEFAULT&quot;, AI_DEFAULT);
#endif
#ifdef NI_MAXHOST
    sock_define_const(&quot;NI_MAXHOST&quot;, NI_MAXHOST);
#endif
#ifdef NI_MAXSERV
    sock_define_const(&quot;NI_MAXSERV&quot;, NI_MAXSERV);
#endif
#ifdef NI_NOFQDN
    sock_define_const(&quot;NI_NOFQDN&quot;, NI_NOFQDN);
#endif
#ifdef NI_NUMERICHOST
    sock_define_const(&quot;NI_NUMERICHOST&quot;, NI_NUMERICHOST);
#endif
#ifdef NI_NAMEREQD
    sock_define_const(&quot;NI_NAMEREQD&quot;, NI_NAMEREQD);
#endif
#ifdef NI_NUMERICSERV
    sock_define_const(&quot;NI_NUMERICSERV&quot;, NI_NUMERICSERV);
#endif
#ifdef NI_DGRAM
    sock_define_const(&quot;NI_DGRAM&quot;, NI_DGRAM);
#endif
#ifdef SHUT_RD
    sock_define_const(&quot;SHUT_RD&quot;, SHUT_RD);
#else
    sock_define_const(&quot;SHUT_RD&quot;, 0);
#endif
#ifdef SHUT_WR
    sock_define_const(&quot;SHUT_WR&quot;, SHUT_WR);
#else
    sock_define_const(&quot;SHUT_WR&quot;, 1);
#endif
#ifdef SHUT_RDWR
    sock_define_const(&quot;SHUT_RDWR&quot;, SHUT_RDWR);
#else
    sock_define_const(&quot;SHUT_RDWR&quot;, 2);
#endif
}
</pre>
    </div>