  <div id="fileHeader">
    <h1>numeric.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/numeric.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat May 31 06:44:49 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  numeric.c -

  $Author: knu $
  $Date: 2008-05-31 20:44:49 +0900 (Sat, 31 May 2008) $
  created at: Fri Aug 13 18:33:09 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;env.h&quot;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

#if defined(__FreeBSD__) &amp;&amp; __FreeBSD__ &lt; 4
#include &lt;floatingpoint.h&gt;
#endif

#ifdef HAVE_FLOAT_H
#include &lt;float.h&gt;
#endif

#ifdef HAVE_IEEEFP_H
#include &lt;ieeefp.h&gt;
#endif

/* use IEEE 64bit values if not defined */
#ifndef FLT_RADIX
#define FLT_RADIX 2
#endif
#ifndef FLT_ROUNDS
#define FLT_ROUNDS 1
#endif
#ifndef DBL_MIN
#define DBL_MIN 2.2250738585072014e-308
#endif
#ifndef DBL_MAX
#define DBL_MAX 1.7976931348623157e+308
#endif
#ifndef DBL_MIN_EXP
#define DBL_MIN_EXP (-1021)
#endif
#ifndef DBL_MAX_EXP
#define DBL_MAX_EXP 1024
#endif
#ifndef DBL_MIN_10_EXP
#define DBL_MIN_10_EXP (-307)
#endif
#ifndef DBL_MAX_10_EXP
#define DBL_MAX_10_EXP 308
#endif
#ifndef DBL_DIG
#define DBL_DIG 15
#endif
#ifndef DBL_MANT_DIG
#define DBL_MANT_DIG 53
#endif
#ifndef DBL_EPSILON
#define DBL_EPSILON 2.2204460492503131e-16
#endif

#ifndef HAVE_ROUND
double
round(x)
    double x;
{
    double f;

    if (x &gt; 0.0) {
	f = floor(x);
	x = f + (x - f &gt;= 0.5);
    }
    else if (x &lt; 0.0) {
	f = ceil(x);
	x = f - (f - x &gt;= 0.5);
    }
    return x;
}
#endif

static ID id_coerce, id_to_i, id_eq;

VALUE rb_cNumeric;
VALUE rb_cFloat;
VALUE rb_cInteger;
VALUE rb_cFixnum;

VALUE rb_eZeroDivError;
VALUE rb_eFloatDomainError;

void
rb_num_zerodiv()
{
    rb_raise(rb_eZeroDivError, &quot;divided by 0&quot;);
}


/*
 *  call-seq:
 *     num.coerce(numeric)   =&gt; array
 *
 *  If &lt;i&gt;aNumeric&lt;/i&gt; is the same type as &lt;i&gt;num&lt;/i&gt;, returns an array
 *  containing &lt;i&gt;aNumeric&lt;/i&gt; and &lt;i&gt;num&lt;/i&gt;. Otherwise, returns an
 *  array with both &lt;i&gt;aNumeric&lt;/i&gt; and &lt;i&gt;num&lt;/i&gt; represented as
 *  &lt;code&gt;Float&lt;/code&gt; objects. This coercion mechanism is used by
 *  Ruby to handle mixed-type numeric operations: it is intended to
 *  find a compatible common type between the two operands of the operator.
 *
 *     1.coerce(2.5)   #=&gt; [2.5, 1.0]
 *     1.2.coerce(3)   #=&gt; [3.0, 1.2]
 *     1.coerce(2)     #=&gt; [2, 1]
 */

static VALUE
num_coerce(x, y)
    VALUE x, y;
{
    if (CLASS_OF(x) == CLASS_OF(y))
	return rb_assoc_new(y, x);
    return rb_assoc_new(rb_Float(y), rb_Float(x));
}

static VALUE
coerce_body(x)
    VALUE *x;
{
    return rb_funcall(x[1], id_coerce, 1, x[0]);
}

static VALUE
coerce_rescue(x)
    VALUE *x;
{
    volatile VALUE v = rb_inspect(x[1]);

    rb_raise(rb_eTypeError, &quot;%s can't be coerced into %s&quot;,
	     rb_special_const_p(x[1])?
	     RSTRING(v)-&gt;ptr:
	     rb_obj_classname(x[1]),
	     rb_obj_classname(x[0]));
    return Qnil;		/* dummy */
}

static int
do_coerce(x, y, err)
    VALUE *x, *y;
    int err;
{
    VALUE ary;
    VALUE a[2];

    a[0] = *x; a[1] = *y;

    ary = rb_rescue(coerce_body, (VALUE)a, err?coerce_rescue:0, (VALUE)a);
    if (TYPE(ary) != T_ARRAY || RARRAY(ary)-&gt;len != 2) {
	if (err) {
	    rb_raise(rb_eTypeError, &quot;coerce must return [x, y]&quot;);
	}
	return Qfalse;
    }

    *x = RARRAY(ary)-&gt;ptr[0];
    *y = RARRAY(ary)-&gt;ptr[1];
    return Qtrue;
}

VALUE
rb_num_coerce_bin(x, y)
    VALUE x, y;
{
    do_coerce(&amp;x, &amp;y, Qtrue);
    return rb_funcall(x, ruby_frame-&gt;orig_func, 1, y);
}

VALUE
rb_num_coerce_cmp(x, y)
    VALUE x, y;
{
    if (do_coerce(&amp;x, &amp;y, Qfalse))
	return rb_funcall(x, ruby_frame-&gt;orig_func, 1, y);
    return Qnil;
}

VALUE
rb_num_coerce_relop(x, y)
    VALUE x, y;
{
    VALUE c, x0 = x, y0 = y;

    if (!do_coerce(&amp;x, &amp;y, Qfalse) ||
	NIL_P(c = rb_funcall(x, ruby_frame-&gt;orig_func, 1, y))) {
	rb_cmperr(x0, y0);
	return Qnil;		/* not reached */
    }
    return c;
}

/*
 * Trap attempts to add methods to &lt;code&gt;Numeric&lt;/code&gt; objects. Always
 * raises a &lt;code&gt;TypeError&lt;/code&gt;
 */

static VALUE
num_sadded(x, name)
    VALUE x, name;
{
    ruby_frame = ruby_frame-&gt;prev; /* pop frame for &quot;singleton_method_added&quot; */
    /* Numerics should be values; singleton_methods should not be added to them */
    rb_raise(rb_eTypeError,
	     &quot;can't define singleton method \&quot;%s\&quot; for %s&quot;,
	     rb_id2name(rb_to_id(name)),
	     rb_obj_classname(x));
    return Qnil;		/* not reached */
}

/* :nodoc: */
static VALUE
num_init_copy(x, y)
    VALUE x, y;
{
    /* Numerics are immutable values, which should not be copied */
    rb_raise(rb_eTypeError, &quot;can't copy %s&quot;, rb_obj_classname(x));
    return Qnil;		/* not reached */
}

/*
 *  call-seq:
 *     +num    =&gt; num
 *
 *  Unary Plus---Returns the receiver's value.
 */

static VALUE
num_uplus(num)
    VALUE num;
{
    return num;
}

/*
 *  call-seq:
 *     -num    =&gt; numeric
 *
 *  Unary Minus---Returns the receiver's value, negated.
 */

static VALUE
num_uminus(num)
    VALUE num;
{
    VALUE zero;

    zero = INT2FIX(0);
    do_coerce(&amp;zero, &amp;num, Qtrue);

    return rb_funcall(zero, '-', 1, num);
}

/*
 *  call-seq:
 *     num.quo(numeric)    =&gt;   result
 *     num.fdiv(numeric)   =&gt;   result
 *
 *  Equivalent to &lt;code&gt;Numeric#/&lt;/code&gt;, but overridden in subclasses.
 */

static VALUE
num_quo(x, y)
    VALUE x, y;
{
    return rb_funcall(x, '/', 1, y);
}


static VALUE num_floor(VALUE num);

/*
 *  call-seq:
 *     num.div(numeric)    =&gt; integer
 *
 *  Uses &lt;code&gt;/&lt;/code&gt; to perform division, then converts the result to
 *  an integer. &lt;code&gt;Numeric&lt;/code&gt; does not define the &lt;code&gt;/&lt;/code&gt;
 *  operator; this is left to subclasses.
 */

static VALUE
num_div(x, y)
    VALUE x, y;
{
    return num_floor(rb_funcall(x, '/', 1, y));
}



/*
 *  call-seq:
 *     num.divmod( aNumeric ) -&gt; anArray
 *
 *  Returns an array containing the quotient and modulus obtained by
 *  dividing &lt;i&gt;num&lt;/i&gt; by &lt;i&gt;aNumeric&lt;/i&gt;. If &lt;code&gt;q, r =
 *  x.divmod(y)&lt;/code&gt;, then
 *
 *      q = floor(float(x)/float(y))
 *      x = q*y + r
 *
 *  The quotient is rounded toward -infinity, as shown in the following table:
 *
 *     a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)
 *    ------+-----+---------------+---------+-------------+---------------
 *     13   |  4  |   3,    1     |   3     |    1        |     1
 *    ------+-----+---------------+---------+-------------+---------------
 *     13   | -4  |  -4,   -3     |  -3     |   -3        |     1
 *    ------+-----+---------------+---------+-------------+---------------
 *    -13   |  4  |  -4,    3     |  -4     |    3        |    -1
 *    ------+-----+---------------+---------+-------------+---------------
 *    -13   | -4  |   3,   -1     |   3     |   -1        |    -1
 *    ------+-----+---------------+---------+-------------+---------------
 *     11.5 |  4  |   2,    3.5   |   2.875 |    3.5      |     3.5
 *    ------+-----+---------------+---------+-------------+---------------
 *     11.5 | -4  |  -3,   -0.5   |  -2.875 |   -0.5      |     3.5
 *    ------+-----+---------------+---------+-------------+---------------
 *    -11.5 |  4  |  -3,    0.5   |  -2.875 |    0.5      |    -3.5
 *    ------+-----+---------------+---------+-------------+---------------
 *    -11.5 | -4  |   2    -3.5   |   2.875 |   -3.5      |    -3.5
 *
 *
 *  Examples
 *     11.divmod(3)         #=&gt; [3, 2]
 *     11.divmod(-3)        #=&gt; [-4, -1]
 *     11.divmod(3.5)       #=&gt; [3, 0.5]
 *     (-11).divmod(3.5)    #=&gt; [-4, 3.0]
 *     (11.5).divmod(3.5)   #=&gt; [3, 1.0]
 */

static VALUE
num_divmod(x, y)
    VALUE x, y;
{
    return rb_assoc_new(num_div(x, y), rb_funcall(x, '%', 1, y));
}

/*
 *  call-seq:
 *     num.modulo(numeric)    =&gt; result
 *
 *  Equivalent to
 *  &lt;i&gt;num&lt;/i&gt;.&lt;code&gt;divmod(&lt;/code&gt;&lt;i&gt;aNumeric&lt;/i&gt;&lt;code&gt;)[1]&lt;/code&gt;.
 */

static VALUE
num_modulo(x, y)
    VALUE x, y;
{
    return rb_funcall(x, '%', 1, y);
}

/*
 *  call-seq:
 *     num.remainder(numeric)    =&gt; result
 *
 *  If &lt;i&gt;num&lt;/i&gt; and &lt;i&gt;numeric&lt;/i&gt; have different signs, returns
 *  &lt;em&gt;mod&lt;/em&gt;-&lt;i&gt;numeric&lt;/i&gt;; otherwise, returns &lt;em&gt;mod&lt;/em&gt;. In
 *  both cases &lt;em&gt;mod&lt;/em&gt; is the value
 *  &lt;i&gt;num&lt;/i&gt;.&lt;code&gt;modulo(&lt;/code&gt;&lt;i&gt;numeric&lt;/i&gt;&lt;code&gt;)&lt;/code&gt;. The
 *  differences between &lt;code&gt;remainder&lt;/code&gt; and modulo
 *  (&lt;code&gt;%&lt;/code&gt;) are shown in the table under &lt;code&gt;Numeric#divmod&lt;/code&gt;.
 */

static VALUE
num_remainder(x, y)
    VALUE x, y;
{
    VALUE z = rb_funcall(x, '%', 1, y);

    if ((!rb_equal(z, INT2FIX(0))) &amp;&amp;
	((RTEST(rb_funcall(x, '&lt;', 1, INT2FIX(0))) &amp;&amp;
	  RTEST(rb_funcall(y, '&gt;', 1, INT2FIX(0)))) ||
	 (RTEST(rb_funcall(x, '&gt;', 1, INT2FIX(0))) &amp;&amp;
	  RTEST(rb_funcall(y, '&lt;', 1, INT2FIX(0)))))) {
	return rb_funcall(z, '-', 1, y);
    }
    return z;
}

/*
 *  call-seq:
 *     num.integer? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;num&lt;/i&gt; is an &lt;code&gt;Integer&lt;/code&gt;
 *  (including &lt;code&gt;Fixnum&lt;/code&gt; and &lt;code&gt;Bignum&lt;/code&gt;).
 */

static VALUE
num_int_p(num)
    VALUE num;
{
    return Qfalse;
}

/*
 *  call-seq:
 *     num.abs   =&gt; num or numeric
 *
 *  Returns the absolute value of &lt;i&gt;num&lt;/i&gt;.
 *
 *     12.abs         #=&gt; 12
 *     (-34.56).abs   #=&gt; 34.56
 *     -34.56.abs     #=&gt; 34.56
 */

static VALUE
num_abs(num)
    VALUE num;
{
    if (RTEST(rb_funcall(num, '&lt;', 1, INT2FIX(0)))) {
	return rb_funcall(num, rb_intern(&quot;-@&quot;), 0);
    }
    return num;
}


/*
 *  call-seq:
 *     num.zero?    =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;num&lt;/i&gt; has a zero value.
 */

static VALUE
num_zero_p(num)
    VALUE num;
{
    if (rb_equal(num, INT2FIX(0))) {
	return Qtrue;
    }
    return Qfalse;
}


/*
 *  call-seq:
 *     num.nonzero?    =&gt; num or nil
 *
 *  Returns &lt;i&gt;num&lt;/i&gt; if &lt;i&gt;num&lt;/i&gt; is not zero, &lt;code&gt;nil&lt;/code&gt;
 *  otherwise. This behavior is useful when chaining comparisons:
 *
 *     a = %w( z Bb bB bb BB a aA Aa AA A )
 *     b = a.sort {|a,b| (a.downcase &lt;=&gt; b.downcase).nonzero? || a &lt;=&gt; b }
 *     b   #=&gt; [&quot;A&quot;, &quot;a&quot;, &quot;AA&quot;, &quot;Aa&quot;, &quot;aA&quot;, &quot;BB&quot;, &quot;Bb&quot;, &quot;bB&quot;, &quot;bb&quot;, &quot;z&quot;]
 */

static VALUE
num_nonzero_p(num)
    VALUE num;
{
    if (RTEST(rb_funcall(num, rb_intern(&quot;zero?&quot;), 0, 0))) {
	return Qnil;
    }
    return num;
}

/*
 *  call-seq:
 *     num.to_int    =&gt; integer
 *
 *  Invokes the child class's &lt;code&gt;to_i&lt;/code&gt; method to convert
 *  &lt;i&gt;num&lt;/i&gt; to an integer.
 */

static VALUE
num_to_int(num)
    VALUE num;
{
    return rb_funcall(num, id_to_i, 0, 0);
}


/********************************************************************
 *
 * Document-class: Float
 *
 *  &lt;code&gt;Float&lt;/code&gt; objects represent real numbers using the native
 *  architecture's double-precision floating point representation.
 */

VALUE
rb_float_new(d)
    double d;
{
    NEWOBJ(flt, struct RFloat);
    OBJSETUP(flt, rb_cFloat, T_FLOAT);

    flt-&gt;value = d;
    return (VALUE)flt;
}

/*
 *  call-seq:
 *     flt.to_s    =&gt; string
 *
 *  Returns a string containing a representation of self. As well as a
 *  fixed or exponential form of the number, the call may return
 *  ``&lt;code&gt;NaN&lt;/code&gt;'', ``&lt;code&gt;Infinity&lt;/code&gt;'', and
 *  ``&lt;code&gt;-Infinity&lt;/code&gt;''.
 */

static VALUE
flo_to_s(flt)
    VALUE flt;
{
    char buf[32];
    double value = RFLOAT(flt)-&gt;value;
    char *p, *e;

    if (isinf(value))
	return rb_str_new2(value &lt; 0 ? &quot;-Infinity&quot; : &quot;Infinity&quot;);
    else if(isnan(value))
	return rb_str_new2(&quot;NaN&quot;);

    sprintf(buf, &quot;%#.15g&quot;, value); /* ensure to print decimal point */
    if (!(e = strchr(buf, 'e'))) {
	e = buf + strlen(buf);
    }
    if (!ISDIGIT(e[-1])) { /* reformat if ended with decimal point (ex 111111111111111.) */
	sprintf(buf, &quot;%#.14e&quot;, value);
	if (!(e = strchr(buf, 'e'))) {
	    e = buf + strlen(buf);
	}
    }
    p = e;
    while (p[-1]=='0' &amp;&amp; ISDIGIT(p[-2]))
	p--;
    memmove(p, e, strlen(e)+1);
    return rb_str_new2(buf);
}

/*
 * MISSING: documentation
 */

static VALUE
flo_coerce(x, y)
    VALUE x, y;
{
    return rb_assoc_new(rb_Float(y), x);
}

/*
 * call-seq:
 *    -float   =&gt; float
 *
 * Returns float, negated.
 */

static VALUE
flo_uminus(flt)
    VALUE flt;
{
    return rb_float_new(-RFLOAT(flt)-&gt;value);
}

/*
 * call-seq:
 *   float + other   =&gt; float
 *
 * Returns a new float which is the sum of &lt;code&gt;float&lt;/code&gt;
 * and &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_plus(x, y)
    VALUE x, y;
{
    switch (TYPE(y)) {
      case T_FIXNUM:
	return rb_float_new(RFLOAT(x)-&gt;value + (double)FIX2LONG(y));
      case T_BIGNUM:
	return rb_float_new(RFLOAT(x)-&gt;value + rb_big2dbl(y));
      case T_FLOAT:
	return rb_float_new(RFLOAT(x)-&gt;value + RFLOAT(y)-&gt;value);
      default:
	return rb_num_coerce_bin(x, y);
    }
}

/*
 * call-seq:
 *   float + other   =&gt; float
 *
 * Returns a new float which is the difference of &lt;code&gt;float&lt;/code&gt;
 * and &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_minus(x, y)
    VALUE x, y;
{
    switch (TYPE(y)) {
      case T_FIXNUM:
	return rb_float_new(RFLOAT(x)-&gt;value - (double)FIX2LONG(y));
      case T_BIGNUM:
	return rb_float_new(RFLOAT(x)-&gt;value - rb_big2dbl(y));
      case T_FLOAT:
	return rb_float_new(RFLOAT(x)-&gt;value - RFLOAT(y)-&gt;value);
      default:
	return rb_num_coerce_bin(x, y);
    }
}

/*
 * call-seq:
 *   float * other   =&gt; float
 *
 * Returns a new float which is the product of &lt;code&gt;float&lt;/code&gt;
 * and &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_mul(x, y)
    VALUE x, y;
{
    switch (TYPE(y)) {
      case T_FIXNUM:
	return rb_float_new(RFLOAT(x)-&gt;value * (double)FIX2LONG(y));
      case T_BIGNUM:
	return rb_float_new(RFLOAT(x)-&gt;value * rb_big2dbl(y));
      case T_FLOAT:
	return rb_float_new(RFLOAT(x)-&gt;value * RFLOAT(y)-&gt;value);
      default:
	return rb_num_coerce_bin(x, y);
    }
}

/*
 * call-seq:
 *   float / other   =&gt; float
 *
 * Returns a new float which is the result of dividing
 * &lt;code&gt;float&lt;/code&gt; by &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_div(x, y)
    VALUE x, y;
{
    long f_y;
    double d;

    switch (TYPE(y)) {
      case T_FIXNUM:
	f_y = FIX2LONG(y);
	return rb_float_new(RFLOAT(x)-&gt;value / (double)f_y);
      case T_BIGNUM:
	d = rb_big2dbl(y);
	return rb_float_new(RFLOAT(x)-&gt;value / d);
      case T_FLOAT:
	return rb_float_new(RFLOAT(x)-&gt;value / RFLOAT(y)-&gt;value);
      default:
	return rb_num_coerce_bin(x, y);
    }
}


static void
flodivmod(x, y, divp, modp)
    double x, y;
    double *divp, *modp;
{
    double div, mod;

#ifdef HAVE_FMOD
    mod = fmod(x, y);
#else
    {
	double z;

	modf(x/y, &amp;z);
	mod = x - z * y;
    }
#endif
    if (isinf(x) &amp;&amp; !isinf(y) &amp;&amp; !isnan(y))
	div = x;
    else
	div = (x - mod) / y;
    if (y*mod &lt; 0) {
	mod += y;
	div -= 1.0;
    }
    if (modp) *modp = mod;
    if (divp) *divp = div;
}


/*
 *  call-seq:
 *     flt % other         =&gt; float
 *     flt.modulo(other)   =&gt; float
 *
 *  Return the modulo after division of &lt;code&gt;flt&lt;/code&gt; by &lt;code&gt;other&lt;/code&gt;.
 *
 *     6543.21.modulo(137)      #=&gt; 104.21
 *     6543.21.modulo(137.24)   #=&gt; 92.9299999999996
 */

static VALUE
flo_mod(x, y)
    VALUE x, y;
{
    double fy, mod;

    switch (TYPE(y)) {
      case T_FIXNUM:
	fy = (double)FIX2LONG(y);
	break;
      case T_BIGNUM:
	fy = rb_big2dbl(y);
	break;
      case T_FLOAT:
	fy = RFLOAT(y)-&gt;value;
	break;
      default:
	return rb_num_coerce_bin(x, y);
    }
    flodivmod(RFLOAT(x)-&gt;value, fy, 0, &amp;mod);
    return rb_float_new(mod);
}

/*
 *  call-seq:
 *     flt.divmod(numeric)    =&gt; array
 *
 *  See &lt;code&gt;Numeric#divmod&lt;/code&gt;.
 */

static VALUE
flo_divmod(x, y)
    VALUE x, y;
{
    double fy, div, mod, val;
    volatile VALUE a, b;

    switch (TYPE(y)) {
      case T_FIXNUM:
	fy = (double)FIX2LONG(y);
	break;
      case T_BIGNUM:
	fy = rb_big2dbl(y);
	break;
      case T_FLOAT:
	fy = RFLOAT(y)-&gt;value;
	break;
      default:
	return rb_num_coerce_bin(x, y);
    }
    flodivmod(RFLOAT(x)-&gt;value, fy, &amp;div, &amp;mod);
    if (FIXABLE(div)) {
        val = round(div);
	a = LONG2FIX(val);
    }
    else {
	a = rb_dbl2big(div);
    }
    b = rb_float_new(mod);
    return rb_assoc_new(a, b);
}

/*
 * call-seq:
 *
 *  flt ** other   =&gt; float
 *
 * Raises &lt;code&gt;float&lt;/code&gt; the &lt;code&gt;other&lt;/code&gt; power.
 */

static VALUE
flo_pow(x, y)
    VALUE x, y;
{
    switch (TYPE(y)) {
      case T_FIXNUM:
        return rb_float_new(pow(RFLOAT(x)-&gt;value, (double)FIX2LONG(y)));
      case T_BIGNUM:
	return rb_float_new(pow(RFLOAT(x)-&gt;value, rb_big2dbl(y)));
      case T_FLOAT:
        return rb_float_new(pow(RFLOAT(x)-&gt;value, RFLOAT(y)-&gt;value));
      default:
        return rb_num_coerce_bin(x, y);
    }
}

/*
 *  call-seq:
 *     num.eql?(numeric)    =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;num&lt;/i&gt; and &lt;i&gt;numeric&lt;/i&gt; are the
 *  same type and have equal values.
 *
 *     1 == 1.0          #=&gt; true
 *     1.eql?(1.0)       #=&gt; false
 *     (1.0).eql?(1.0)   #=&gt; true
 */

static VALUE
num_eql(x, y)
    VALUE x, y;
{
    if (TYPE(x) != TYPE(y)) return Qfalse;

    return rb_equal(x, y);
}

/*
 *  call-seq:
 *     num &lt;=&gt; other -&gt; 0 or nil
 *
 *  Returns zero if &lt;i&gt;num&lt;/i&gt; equals &lt;i&gt;other&lt;/i&gt;, &lt;code&gt;nil&lt;/code&gt;
 *  otherwise.
 */

static VALUE
num_cmp(x, y)
    VALUE x, y;
{
    if (x == y) return INT2FIX(0);
    return Qnil;
}

static VALUE
num_equal(x, y)
    VALUE x, y;
{
    if (x == y) return Qtrue;
    return rb_funcall(y, id_eq, 1, x);
}

/*
 *  call-seq:
 *     flt == obj   =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; only if &lt;i&gt;obj&lt;/i&gt; has the same value
 *  as &lt;i&gt;flt&lt;/i&gt;. Contrast this with &lt;code&gt;Float#eql?&lt;/code&gt;, which
 *  requires &lt;i&gt;obj&lt;/i&gt; to be a &lt;code&gt;Float&lt;/code&gt;.
 *
 *     1.0 == 1   #=&gt; true
 *
 */

static VALUE
flo_eq(x, y)
    VALUE x, y;
{
    volatile double a, b;

    switch (TYPE(y)) {
      case T_FIXNUM:
	b = FIX2LONG(y);
	break;
      case T_BIGNUM:
	b = rb_big2dbl(y);
	break;
      case T_FLOAT:
	b = RFLOAT(y)-&gt;value;
	if (isnan(b)) return Qfalse;
	break;
      default:
	return num_equal(x, y);
    }
    a = RFLOAT(x)-&gt;value;
    if (isnan(a)) return Qfalse;
    return (a == b)?Qtrue:Qfalse;
}

/*
 * call-seq:
 *   flt.hash   =&gt; integer
 *
 * Returns a hash code for this float.
 */

static VALUE
flo_hash(num)
    VALUE num;
{
    double d;
    char *c;
    int i, hash;

    d = RFLOAT(num)-&gt;value;
    if (d == 0) d = fabs(d);
    c = (char*)&amp;d;
    for (hash=0, i=0; i&lt;sizeof(double);i++) {
	hash = (hash * 971) ^ (unsigned char)c[i];
    }
    if (hash &lt; 0) hash = -hash;
    return INT2FIX(hash);
}

VALUE
rb_dbl_cmp(a, b)
    double a, b;
{
    if (isnan(a) || isnan(b)) return Qnil;
    if (a == b) return INT2FIX(0);
    if (a &gt; b) return INT2FIX(1);
    if (a &lt; b) return INT2FIX(-1);
    return Qnil;
}

/*
 *  call-seq:
 *     flt &lt;=&gt; numeric   =&gt; -1, 0, +1
 *
 *  Returns -1, 0, or +1 depending on whether &lt;i&gt;flt&lt;/i&gt; is less than,
 *  equal to, or greater than &lt;i&gt;numeric&lt;/i&gt;. This is the basis for the
 *  tests in &lt;code&gt;Comparable&lt;/code&gt;.
 */

static VALUE
flo_cmp(x, y)
    VALUE x, y;
{
    double a, b;

    a = RFLOAT(x)-&gt;value;
    switch (TYPE(y)) {
      case T_FIXNUM:
	b = (double)FIX2LONG(y);
	break;

      case T_BIGNUM:
	b = rb_big2dbl(y);
	break;

      case T_FLOAT:
	b = RFLOAT(y)-&gt;value;
	break;

      default:
	return rb_num_coerce_cmp(x, y);
    }
    return rb_dbl_cmp(a, b);
}

/*
 * call-seq:
 *   flt &gt; other    =&gt;  true or false
 *
 * &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;flt&lt;/code&gt; is greater than &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_gt(x, y)
    VALUE x, y;
{
    double a, b;

    a = RFLOAT(x)-&gt;value;
    switch (TYPE(y)) {
      case T_FIXNUM:
	b = (double)FIX2LONG(y);
	break;

      case T_BIGNUM:
	b = rb_big2dbl(y);
	break;

      case T_FLOAT:
	b = RFLOAT(y)-&gt;value;
	if (isnan(b)) return Qfalse;
	break;

      default:
	return rb_num_coerce_relop(x, y);
    }
    if (isnan(a)) return Qfalse;
    return (a &gt; b)?Qtrue:Qfalse;
}

/*
 * call-seq:
 *   flt &gt;= other    =&gt;  true or false
 *
 * &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;flt&lt;/code&gt; is greater than
 * or equal to &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_ge(x, y)
    VALUE x, y;
{
    double a, b;

    a = RFLOAT(x)-&gt;value;
    switch (TYPE(y)) {
      case T_FIXNUM:
	b = (double)FIX2LONG(y);
	break;

      case T_BIGNUM:
	b = rb_big2dbl(y);
	break;

      case T_FLOAT:
	b = RFLOAT(y)-&gt;value;
	if (isnan(b)) return Qfalse;
	break;

      default:
	return rb_num_coerce_relop(x, y);
    }
    if (isnan(a)) return Qfalse;
    return (a &gt;= b)?Qtrue:Qfalse;
}

/*
 * call-seq:
 *   flt &lt; other    =&gt;  true or false
 *
 * &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;flt&lt;/code&gt; is less than &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_lt(x, y)
    VALUE x, y;
{
    double a, b;

    a = RFLOAT(x)-&gt;value;
    switch (TYPE(y)) {
      case T_FIXNUM:
	b = (double)FIX2LONG(y);
	break;

      case T_BIGNUM:
	b = rb_big2dbl(y);
	break;

      case T_FLOAT:
	b = RFLOAT(y)-&gt;value;
	if (isnan(b)) return Qfalse;
	break;

      default:
	return rb_num_coerce_relop(x, y);
    }
    if (isnan(a)) return Qfalse;
    return (a &lt; b)?Qtrue:Qfalse;
}

/*
 * call-seq:
 *   flt &lt;= other    =&gt;  true or false
 *
 * &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;flt&lt;/code&gt; is less than
 * or equal to &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
flo_le(x, y)
    VALUE x, y;
{
    double a, b;

    a = RFLOAT(x)-&gt;value;
    switch (TYPE(y)) {
      case T_FIXNUM:
	b = (double)FIX2LONG(y);
	break;

      case T_BIGNUM:
	b = rb_big2dbl(y);
	break;

      case T_FLOAT:
	b = RFLOAT(y)-&gt;value;
	if (isnan(b)) return Qfalse;
	break;

      default:
	return rb_num_coerce_relop(x, y);
    }
    if (isnan(a)) return Qfalse;
    return (a &lt;= b)?Qtrue:Qfalse;
}

/*
 *  call-seq:
 *     flt.eql?(obj)   =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; only if &lt;i&gt;obj&lt;/i&gt; is a
 *  &lt;code&gt;Float&lt;/code&gt; with the same value as &lt;i&gt;flt&lt;/i&gt;. Contrast this
 *  with &lt;code&gt;Float#==&lt;/code&gt;, which performs type conversions.
 *
 *     1.0.eql?(1)   #=&gt; false
 */

static VALUE
flo_eql(x, y)
    VALUE x, y;
{
    if (TYPE(y) == T_FLOAT) {
	double a = RFLOAT(x)-&gt;value;
	double b = RFLOAT(y)-&gt;value;

	if (isnan(a) || isnan(b)) return Qfalse;
	if (a == b) return Qtrue;
    }
    return Qfalse;
}

/*
 * call-seq:
 *   flt.to_f   =&gt; flt
 *
 * As &lt;code&gt;flt&lt;/code&gt; is already a float, returns &lt;i&gt;self&lt;/i&gt;.
 */

static VALUE
flo_to_f(num)
    VALUE num;
{
    return num;
}

/*
 *  call-seq:
 *     flt.abs    =&gt; float
 *
 *  Returns the absolute value of &lt;i&gt;flt&lt;/i&gt;.
 *
 *     (-34.56).abs   #=&gt; 34.56
 *     -34.56.abs     #=&gt; 34.56
 *
 */

static VALUE
flo_abs(flt)
    VALUE flt;
{
    double val = fabs(RFLOAT(flt)-&gt;value);
    return rb_float_new(val);
}

/*
 *  call-seq:
 *     flt.zero? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;flt&lt;/i&gt; is 0.0.
 *
 */

static VALUE
flo_zero_p(num)
    VALUE num;
{
    if (RFLOAT(num)-&gt;value == 0.0) {
	return Qtrue;
    }
    return Qfalse;
}

/*
 *  call-seq:
 *     flt.nan? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;flt&lt;/i&gt; is an invalid IEEE floating
 *  point number.
 *
 *     a = -1.0      #=&gt; -1.0
 *     a.nan?        #=&gt; false
 *     a = 0.0/0.0   #=&gt; NaN
 *     a.nan?        #=&gt; true
 */

static VALUE
flo_is_nan_p(num)
     VALUE num;
{
    double value = RFLOAT(num)-&gt;value;

    return isnan(value) ? Qtrue : Qfalse;
}

/*
 *  call-seq:
 *     flt.infinite? -&gt; nil, -1, +1
 *
 *  Returns &lt;code&gt;nil&lt;/code&gt;, -1, or +1 depending on whether &lt;i&gt;flt&lt;/i&gt;
 *  is finite, -infinity, or +infinity.
 *
 *     (0.0).infinite?        #=&gt; nil
 *     (-1.0/0.0).infinite?   #=&gt; -1
 *     (+1.0/0.0).infinite?   #=&gt; 1
 */

static VALUE
flo_is_infinite_p(num)
     VALUE num;
{
    double value = RFLOAT(num)-&gt;value;

    if (isinf(value)) {
	return INT2FIX( value &lt; 0 ? -1 : 1 );
    }

    return Qnil;
}

/*
 *  call-seq:
 *     flt.finite? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;flt&lt;/i&gt; is a valid IEEE floating
 *  point number (it is not infinite, and &lt;code&gt;nan?&lt;/code&gt; is
 *  &lt;code&gt;false&lt;/code&gt;).
 *
 */

static VALUE
flo_is_finite_p(num)
     VALUE num;
{
    double value = RFLOAT(num)-&gt;value;

#if HAVE_FINITE
    if (!finite(value))
	return Qfalse;
#else
    if (isinf(value) || isnan(value))
	return Qfalse;
#endif

    return Qtrue;
}

/*
 *  call-seq:
 *     flt.floor   =&gt; integer
 *
 *  Returns the largest integer less than or equal to &lt;i&gt;flt&lt;/i&gt;.
 *
 *     1.2.floor      #=&gt; 1
 *     2.0.floor      #=&gt; 2
 *     (-1.2).floor   #=&gt; -2
 *     (-2.0).floor   #=&gt; -2
 */

static VALUE
flo_floor(num)
    VALUE num;
{
    double f = floor(RFLOAT(num)-&gt;value);
    long val;

    if (!FIXABLE(f)) {
	return rb_dbl2big(f);
    }
    val = f;
    return LONG2FIX(val);
}

/*
 *  call-seq:
 *     flt.ceil    =&gt; integer
 *
 *  Returns the smallest &lt;code&gt;Integer&lt;/code&gt; greater than or equal to
 *  &lt;i&gt;flt&lt;/i&gt;.
 *
 *     1.2.ceil      #=&gt; 2
 *     2.0.ceil      #=&gt; 2
 *     (-1.2).ceil   #=&gt; -1
 *     (-2.0).ceil   #=&gt; -2
 */

static VALUE
flo_ceil(num)
    VALUE num;
{
    double f = ceil(RFLOAT(num)-&gt;value);
    long val;

    if (!FIXABLE(f)) {
	return rb_dbl2big(f);
    }
    val = f;
    return LONG2FIX(val);
}

/*
 *  call-seq:
 *     flt.round   =&gt; integer
 *
 *  Rounds &lt;i&gt;flt&lt;/i&gt; to the nearest integer. Equivalent to:
 *
 *     def round
 *       return (self+0.5).floor if self &gt; 0.0
 *       return (self-0.5).ceil  if self &lt; 0.0
 *       return 0
 *     end
 *
 *     1.5.round      #=&gt; 2
 *     (-1.5).round   #=&gt; -2
 *
 */

static VALUE
flo_round(num)
    VALUE num;
{
    double f = RFLOAT(num)-&gt;value;
    long val;

    f = round(f);

    if (!FIXABLE(f)) {
	return rb_dbl2big(f);
    }
    val = f;
    return LONG2FIX(val);
}

/*
 *  call-seq:
 *     flt.to_i       =&gt; integer
 *     flt.to_int     =&gt; integer
 *     flt.truncate   =&gt; integer
 *
 *  Returns &lt;i&gt;flt&lt;/i&gt; truncated to an &lt;code&gt;Integer&lt;/code&gt;.
 */

static VALUE
flo_truncate(num)
    VALUE num;
{
    double f = RFLOAT(num)-&gt;value;
    long val;

    if (f &gt; 0.0) f = floor(f);
    if (f &lt; 0.0) f = ceil(f);

    if (!FIXABLE(f)) {
	return rb_dbl2big(f);
    }
    val = f;
    return LONG2FIX(val);
}


/*
 *  call-seq:
 *     num.floor    =&gt; integer
 *
 *  Returns the largest integer less than or equal to &lt;i&gt;num&lt;/i&gt;.
 *  &lt;code&gt;Numeric&lt;/code&gt; implements this by converting &lt;i&gt;anInteger&lt;/i&gt;
 *  to a &lt;code&gt;Float&lt;/code&gt; and invoking &lt;code&gt;Float#floor&lt;/code&gt;.
 *
 *     1.floor      #=&gt; 1
 *     (-1).floor   #=&gt; -1
 */

static VALUE
num_floor(num)
    VALUE num;
{
    return flo_floor(rb_Float(num));
}


/*
 *  call-seq:
 *     num.ceil    =&gt; integer
 *
 *  Returns the smallest &lt;code&gt;Integer&lt;/code&gt; greater than or equal to
 *  &lt;i&gt;num&lt;/i&gt;. Class &lt;code&gt;Numeric&lt;/code&gt; achieves this by converting
 *  itself to a &lt;code&gt;Float&lt;/code&gt; then invoking
 *  &lt;code&gt;Float#ceil&lt;/code&gt;.
 *
 *     1.ceil        #=&gt; 1
 *     1.2.ceil      #=&gt; 2
 *     (-1.2).ceil   #=&gt; -1
 *     (-1.0).ceil   #=&gt; -1
 */

static VALUE
num_ceil(num)
    VALUE num;
{
    return flo_ceil(rb_Float(num));
}

/*
 *  call-seq:
 *     num.round    =&gt; integer
 *
 *  Rounds &lt;i&gt;num&lt;/i&gt; to the nearest integer. &lt;code&gt;Numeric&lt;/code&gt;
 *  implements this by converting itself to a
 *  &lt;code&gt;Float&lt;/code&gt; and invoking &lt;code&gt;Float#round&lt;/code&gt;.
 */

static VALUE
num_round(num)
    VALUE num;
{
    return flo_round(rb_Float(num));
}

/*
 *  call-seq:
 *     num.truncate    =&gt; integer
 *
 *  Returns &lt;i&gt;num&lt;/i&gt; truncated to an integer. &lt;code&gt;Numeric&lt;/code&gt;
 *  implements this by converting its value to a float and invoking
 *  &lt;code&gt;Float#truncate&lt;/code&gt;.
 */

static VALUE
num_truncate(num)
    VALUE num;
{
    return flo_truncate(rb_Float(num));
}


/*
 *  call-seq:
 *     num.step(limit, step ) {|i| block }     =&gt; num
 *
 *  Invokes &lt;em&gt;block&lt;/em&gt; with the sequence of numbers starting at
 *  &lt;i&gt;num&lt;/i&gt;, incremented by &lt;i&gt;step&lt;/i&gt; on each call. The loop
 *  finishes when the value to be passed to the block is greater than
 *  &lt;i&gt;limit&lt;/i&gt; (if &lt;i&gt;step&lt;/i&gt; is positive) or less than
 *  &lt;i&gt;limit&lt;/i&gt; (if &lt;i&gt;step&lt;/i&gt; is negative). If all the arguments are
 *  integers, the loop operates using an integer counter. If any of the
 *  arguments are floating point numbers, all are converted to floats,
 *  and the loop is executed &lt;i&gt;floor(n + n*epsilon)+ 1&lt;/i&gt; times,
 *  where &lt;i&gt;n = (limit - num)/step&lt;/i&gt;. Otherwise, the loop
 *  starts at &lt;i&gt;num&lt;/i&gt;, uses either the &lt;code&gt;&lt;&lt;/code&gt; or
 *  &lt;code&gt;&gt;&lt;/code&gt; operator to compare the counter against
 *  &lt;i&gt;limit&lt;/i&gt;, and increments itself using the &lt;code&gt;+&lt;/code&gt;
 *  operator.
 *
 *     1.step(10, 2) { |i| print i, &quot; &quot; }
 *     Math::E.step(Math::PI, 0.2) { |f| print f, &quot; &quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     1 3 5 7 9
 *     2.71828182845905 2.91828182845905 3.11828182845905
 */

static VALUE
num_step(argc, argv, from)
    int argc;
    VALUE *argv;
    VALUE from;
{
    VALUE to, step;

    RETURN_ENUMERATOR(from, argc, argv);

    if (argc == 1) {
	to = argv[0];
	step = INT2FIX(1);
    }
    else {
	if (argc == 2) {
	    to = argv[0];
	    step = argv[1];
	}
	else {
	    rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
	}
	if (rb_equal(step, INT2FIX(0))) {
	    rb_raise(rb_eArgError, &quot;step can't be 0&quot;);
	}
    }

    if (FIXNUM_P(from) &amp;&amp; FIXNUM_P(to) &amp;&amp; FIXNUM_P(step)) {
	long i, end, diff;

	i = FIX2LONG(from);
	end = FIX2LONG(to);
	diff = FIX2LONG(step);

	if (diff &gt; 0) {
	    while (i &lt;= end) {
		rb_yield(LONG2FIX(i));
		i += diff;
	    }
	}
	else {
	    while (i &gt;= end) {
		rb_yield(LONG2FIX(i));
		i += diff;
	    }
	}
    }
    else if (TYPE(from) == T_FLOAT || TYPE(to) == T_FLOAT || TYPE(step) == T_FLOAT) {
	const double epsilon = DBL_EPSILON;
	double beg = NUM2DBL(from);
	double end = NUM2DBL(to);
	double unit = NUM2DBL(step);
	double n = (end - beg)/unit;
	double err = (fabs(beg) + fabs(end) + fabs(end-beg)) / fabs(unit) * epsilon;
	long i;

	if (err&gt;0.5) err=0.5;
	n = floor(n + err) + 1;
	for (i=0; i&lt;n; i++) {
	    rb_yield(rb_float_new(i*unit+beg));
	}
    }
    else {
	VALUE i = from;
	ID cmp;

	if (RTEST(rb_funcall(step, '&gt;', 1, INT2FIX(0)))) {
	    cmp = '&gt;';
	}
	else {
	    cmp = '&lt;';
	}
	for (;;) {
	    if (RTEST(rb_funcall(i, cmp, 1, to))) break;
	    rb_yield(i);
	    i = rb_funcall(i, '+', 1, step);
	}
    }
    return from;
}

long
rb_num2long(val)
    VALUE val;
{
  again:
    if (NIL_P(val)) {
	rb_raise(rb_eTypeError, &quot;no implicit conversion from nil to integer&quot;);
    }

    if (FIXNUM_P(val)) return FIX2LONG(val);

    switch (TYPE(val)) {
      case T_FLOAT:
	if (RFLOAT(val)-&gt;value &lt;= (double)LONG_MAX
	    &amp;&amp; RFLOAT(val)-&gt;value &gt;= (double)LONG_MIN) {
	    return (long)(RFLOAT(val)-&gt;value);
	}
	else {
	    char buf[24];
	    char *s;

	    sprintf(buf, &quot;%-.10g&quot;, RFLOAT(val)-&gt;value);
	    if ((s = strchr(buf, ' ')) != 0) *s = '\0';
	    rb_raise(rb_eRangeError, &quot;float %s out of range of integer&quot;, buf);
	}

      case T_BIGNUM:
	return rb_big2long(val);

      default:
	val = rb_to_int(val);
	goto again;
    }
}

unsigned long
rb_num2ulong(val)
    VALUE val;
{
    if (TYPE(val) == T_BIGNUM) {
	return rb_big2ulong(val);
    }
    return (unsigned long)rb_num2long(val);
}

#if SIZEOF_INT &lt; SIZEOF_LONG
static void
check_int(num)
    long num;
{
    const char *s;

    if (num &lt; INT_MIN) {
	s = &quot;small&quot;;
    }
    else if (num &gt; INT_MAX) {
	s = &quot;big&quot;;
    }
    else {
	return;
    }
    rb_raise(rb_eRangeError, &quot;integer %ld too %s to convert to `int'&quot;, num, s);
}

static void
check_uint(num)
    unsigned long num;
{
    if (num &gt; UINT_MAX) {
	rb_raise(rb_eRangeError, &quot;integer %lu too big to convert to `unsigned int'&quot;, num);
    }
}

long
rb_num2int(val)
    VALUE val;
{
    long num = rb_num2long(val);

    check_int(num);
    return num;
}

long
rb_fix2int(val)
    VALUE val;
{
    long num = FIXNUM_P(val)?FIX2LONG(val):rb_num2long(val);

    check_int(num);
    return num;
}

unsigned long
rb_num2uint(val)
    VALUE val;
{
    unsigned long num = rb_num2ulong(val);

    if (RTEST(rb_funcall(INT2FIX(0), '&lt;', 1, val))) {
	check_uint(num);
    }
    return num;
}

unsigned long
rb_fix2uint(val)
    VALUE val;
{
    unsigned long num;

    if (!FIXNUM_P(val)) {
        return rb_num2uint(val);
    }
    num = FIX2ULONG(val);
    if (FIX2LONG(val) &gt; 0) {
	check_uint(num);
    }
    return num;
}
#else
long
rb_num2int(val)
    VALUE val;
{
    return rb_num2long(val);
}

long
rb_fix2int(val)
    VALUE val;
{
    return FIX2INT(val);
}
#endif

VALUE
rb_num2fix(val)
    VALUE val;
{
    long v;

    if (FIXNUM_P(val)) return val;

    v = rb_num2long(val);
    if (!FIXABLE(v))
	rb_raise(rb_eRangeError, &quot;integer %ld out of range of fixnum&quot;, v);
    return LONG2FIX(v);
}

#if HAVE_LONG_LONG

LONG_LONG
rb_num2ll(val)
    VALUE val;
{
    if (NIL_P(val)) {
	rb_raise(rb_eTypeError, &quot;no implicit conversion from nil&quot;);
    }

    if (FIXNUM_P(val)) return (LONG_LONG)FIX2LONG(val);

    switch (TYPE(val)) {
    case T_FLOAT:
	if (RFLOAT(val)-&gt;value &lt;= (double)LLONG_MAX
	    &amp;&amp; RFLOAT(val)-&gt;value &gt;= (double)LLONG_MIN) {
	    return (LONG_LONG)(RFLOAT(val)-&gt;value);
	}
	else {
	    char buf[24];
	    char *s;

	    sprintf(buf, &quot;%-.10g&quot;, RFLOAT(val)-&gt;value);
	    if ((s = strchr(buf, ' ')) != 0) *s = '\0';
	    rb_raise(rb_eRangeError, &quot;float %s out of range of long long&quot;, buf);
	}

    case T_BIGNUM:
	return rb_big2ll(val);

    case T_STRING:
	rb_raise(rb_eTypeError, &quot;no implicit conversion from string&quot;);
	return Qnil;            /* not reached */

    case T_TRUE:
    case T_FALSE:
	rb_raise(rb_eTypeError, &quot;no implicit conversion from boolean&quot;);
	return Qnil;		/* not reached */

      default:
	  val = rb_to_int(val);
	  return NUM2LL(val);
    }
}

unsigned LONG_LONG
rb_num2ull(val)
    VALUE val;
{
    if (TYPE(val) == T_BIGNUM) {
	return rb_big2ull(val);
    }
    return (unsigned LONG_LONG)rb_num2ll(val);
}

#endif  /* HAVE_LONG_LONG */


/*
 * Document-class: Integer
 *
 *  &lt;code&gt;Integer&lt;/code&gt; is the basis for the two concrete classes that
 *  hold whole numbers, &lt;code&gt;Bignum&lt;/code&gt; and &lt;code&gt;Fixnum&lt;/code&gt;.
 *
 */


/*
 *  call-seq:
 *     int.to_i      =&gt; int
 *     int.to_int    =&gt; int
 *     int.floor     =&gt; int
 *     int.ceil      =&gt; int
 *     int.round     =&gt; int
 *     int.truncate  =&gt; int
 *
 *  As &lt;i&gt;int&lt;/i&gt; is already an &lt;code&gt;Integer&lt;/code&gt;, all these
 *  methods simply return the receiver.
 */

static VALUE
int_to_i(num)
    VALUE num;
{
    return num;
}

/*
 *  call-seq:
 *     int.integer? -&gt; true
 *
 *  Always returns &lt;code&gt;true&lt;/code&gt;.
 */

static VALUE
int_int_p(num)
    VALUE num;
{
    return Qtrue;
}

/*
 *  call-seq:
 *     int.odd? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;int&lt;/i&gt; is an odd number.
 */

static VALUE
int_odd_p(VALUE num)
{
    if (rb_funcall(num, '%', 1, INT2FIX(2)) != INT2FIX(0)) {
        return Qtrue;
    }
    return Qfalse;
}

/*
 *  call-seq:
 *     int.even? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;int&lt;/i&gt; is an even number.
 */

static VALUE
int_even_p(VALUE num)
{
    if (rb_funcall(num, '%', 1, INT2FIX(2)) == INT2FIX(0)) {
        return Qtrue;
    }
    return Qfalse;
}


/*
 *  call-seq:
 *     int.next    =&gt; integer
 *     int.succ    =&gt; integer
 *
 *  Returns the &lt;code&gt;Integer&lt;/code&gt; equal to &lt;i&gt;int&lt;/i&gt; + 1.
 *
 *     1.next      #=&gt; 2
 *     (-1).next   #=&gt; 0
 */

static VALUE
int_succ(num)
    VALUE num;
{
    if (FIXNUM_P(num)) {
	long i = FIX2LONG(num) + 1;
	return LONG2NUM(i);
    }
    return rb_funcall(num, '+', 1, INT2FIX(1));
}

/*
 *  call-seq:
 *     int.pred    =&gt; integer
 *
 *  Returns the &lt;code&gt;Integer&lt;/code&gt; equal to &lt;i&gt;int&lt;/i&gt; - 1.
 *
 *     1.pred      #=&gt; 0
 *     (-1).pred   #=&gt; -2
 */

static VALUE
int_pred(VALUE num)
{
    if (FIXNUM_P(num)) {
        long i = FIX2LONG(num) - 1;
        return LONG2NUM(i);
    }
    return rb_funcall(num, '-', 1, INT2FIX(1));
}

/*
 *  call-seq:
 *     int.chr    =&gt; string
 *
 *  Returns a string containing the ASCII character represented by the
 *  receiver's value.
 *
 *     65.chr    #=&gt; &quot;A&quot;
 *     ?a.chr    #=&gt; &quot;a&quot;
 *     230.chr   #=&gt; &quot;\346&quot;
 */

static VALUE
int_chr(num)
    VALUE num;
{
    char c;
    long i = NUM2LONG(num);

    if (i &lt; 0 || 0xff &lt; i)
	rb_raise(rb_eRangeError, &quot;%ld out of char range&quot;, i);
    c = i;
    return rb_str_new(&amp;c, 1);
}

/*
 *  call-seq:
 *     int.ord    =&gt; int
 *
 *  Returns the int itself.
 *
 *     ?a.ord    #=&gt; 97
 *
 *  This method is intended for compatibility to
 *  character constant in Ruby 1.9.
 *  For example, ?a.ord returns 97 both in 1.8 and 1.9.
 */

static VALUE
int_ord(num)
    VALUE num;
{
    return num;
}

/********************************************************************
 *
 * Document-class: Fixnum
 *
 *  A &lt;code&gt;Fixnum&lt;/code&gt; holds &lt;code&gt;Integer&lt;/code&gt; values that can be
 *  represented in a native machine word (minus 1 bit). If any operation
 *  on a &lt;code&gt;Fixnum&lt;/code&gt; exceeds this range, the value is
 *  automatically converted to a &lt;code&gt;Bignum&lt;/code&gt;.
 *
 *  &lt;code&gt;Fixnum&lt;/code&gt; objects have immediate value. This means that
 *  when they are assigned or passed as parameters, the actual object is
 *  passed, rather than a reference to that object. Assignment does not
 *  alias &lt;code&gt;Fixnum&lt;/code&gt; objects. There is effectively only one
 *  &lt;code&gt;Fixnum&lt;/code&gt; object instance for any given integer value, so,
 *  for example, you cannot add a singleton method to a
 *  &lt;code&gt;Fixnum&lt;/code&gt;.
 */


/*
 * call-seq:
 *   Fixnum.induced_from(obj)    =&gt;  fixnum
 *
 * Convert &lt;code&gt;obj&lt;/code&gt; to a Fixnum. Works with numeric parameters.
 * Also works with Symbols, but this is deprecated.
 */

static VALUE
rb_fix_induced_from(klass, x)
    VALUE klass, x;
{
    return rb_num2fix(x);
}

/*
 * call-seq:
 *   Integer.induced_from(obj)    =&gt;  fixnum, bignum
 *
 * Convert &lt;code&gt;obj&lt;/code&gt; to an Integer.
 */

static VALUE
rb_int_induced_from(klass, x)
    VALUE klass, x;
{
    switch (TYPE(x)) {
    case T_FIXNUM:
    case T_BIGNUM:
       return x;
    case T_FLOAT:
       return rb_funcall(x, id_to_i, 0);
    default:
       rb_raise(rb_eTypeError, &quot;failed to convert %s into Integer&quot;,
                rb_obj_classname(x));
    }
}

/*
 * call-seq:
 *   Float.induced_from(obj)    =&gt;  float
 *
 * Convert &lt;code&gt;obj&lt;/code&gt; to a float.
 */

static VALUE
rb_flo_induced_from(klass, x)
    VALUE klass, x;
{
    switch (TYPE(x)) {
    case T_FIXNUM:
    case T_BIGNUM:
       return rb_funcall(x, rb_intern(&quot;to_f&quot;), 0);
    case T_FLOAT:
       return x;
    default:
       rb_raise(rb_eTypeError, &quot;failed to convert %s into Float&quot;,
                rb_obj_classname(x));
    }
}

/*
 * call-seq:
 *   -fix   =&gt;  integer
 *
 * Negates &lt;code&gt;fix&lt;/code&gt; (which might return a Bignum).
 */

static VALUE
fix_uminus(num)
    VALUE num;
{
    return LONG2NUM(-FIX2LONG(num));
}

VALUE
rb_fix2str(x, base)
    VALUE x;
    int base;
{
    extern const char ruby_digitmap[];
    char buf[SIZEOF_LONG*CHAR_BIT + 2], *b = buf + sizeof buf;
    long val = FIX2LONG(x);
    int neg = 0;

    if (base &lt; 2 || 36 &lt; base) {
	rb_raise(rb_eArgError, &quot;illegal radix %d&quot;, base);
    }
    if (val == 0) {
	return rb_str_new2(&quot;0&quot;);
    }
    if (val &lt; 0) {
	val = -val;
	neg = 1;
    }
    *--b = '\0';
    do {
	*--b = ruby_digitmap[(int)(val % base)];
    } while (val /= base);
    if (neg) {
	*--b = '-';
    }

    return rb_str_new2(b);
}

/*
 *  call-seq:
 *     fix.to_s( base=10 ) -&gt; aString
 *
 *  Returns a string containing the representation of &lt;i&gt;fix&lt;/i&gt; radix
 *  &lt;i&gt;base&lt;/i&gt; (between 2 and 36).
 *
 *     12345.to_s       #=&gt; &quot;12345&quot;
 *     12345.to_s(2)    #=&gt; &quot;11000000111001&quot;
 *     12345.to_s(8)    #=&gt; &quot;30071&quot;
 *     12345.to_s(10)   #=&gt; &quot;12345&quot;
 *     12345.to_s(16)   #=&gt; &quot;3039&quot;
 *     12345.to_s(36)   #=&gt; &quot;9ix&quot;
 *
 */
static VALUE
fix_to_s(argc, argv, x)
    int argc;
    VALUE *argv;
    VALUE x;
{
    VALUE b;
    int base;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;b);
    if (argc == 0) base = 10;
    else base = NUM2INT(b);

    return rb_fix2str(x, base);
}

/*
 * call-seq:
 *   fix + numeric   =&gt;  numeric_result
 *
 * Performs addition: the class of the resulting object depends on
 * the class of &lt;code&gt;numeric&lt;/code&gt; and on the magnitude of the
 * result.
 */

static VALUE
fix_plus(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long a, b, c;
	VALUE r;

	a = FIX2LONG(x);
	b = FIX2LONG(y);
	c = a + b;
	r = LONG2NUM(c);

	return r;
    }
    if (TYPE(y) == T_FLOAT) {
	return rb_float_new((double)FIX2LONG(x) + RFLOAT(y)-&gt;value);
    }
    return rb_num_coerce_bin(x, y);
}

/*
 * call-seq:
 *   fix - numeric   =&gt;  numeric_result
 *
 * Performs subtraction: the class of the resulting object depends on
 * the class of &lt;code&gt;numeric&lt;/code&gt; and on the magnitude of the
 * result.
 */

static VALUE
fix_minus(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long a, b, c;
	VALUE r;

	a = FIX2LONG(x);
	b = FIX2LONG(y);
	c = a - b;
	r = LONG2NUM(c);

	return r;
    }
    if (TYPE(y) == T_FLOAT) {
	return rb_float_new((double)FIX2LONG(x) - RFLOAT(y)-&gt;value);
    }
    return rb_num_coerce_bin(x, y);
}

/*
 * call-seq:
 *   fix * numeric   =&gt;  numeric_result
 *
 * Performs multiplication: the class of the resulting object depends on
 * the class of &lt;code&gt;numeric&lt;/code&gt; and on the magnitude of the
 * result.
 */

static VALUE
fix_mul(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
#ifdef __HP_cc
        /* avoids an optimization bug of HP aC++/ANSI C B3910B A.06.05 [Jul 25 2005] */
        volatile
#endif
	long a, b, c;
	VALUE r;

	a = FIX2LONG(x);
	if (a == 0) return x;

	b = FIX2LONG(y);
	c = a * b;
	r = LONG2FIX(c);

	if (FIX2LONG(r) != c || c/a != b) {
	    r = rb_big_mul(rb_int2big(a), rb_int2big(b));
	}
	return r;
    }
    if (TYPE(y) == T_FLOAT) {
	return rb_float_new((double)FIX2LONG(x) * RFLOAT(y)-&gt;value);
    }
    return rb_num_coerce_bin(x, y);
}

static void
fixdivmod(x, y, divp, modp)
    long x, y;
    long *divp, *modp;
{
    long div, mod;

    if (y == 0) rb_num_zerodiv();
    if (y &lt; 0) {
	if (x &lt; 0)
	    div = -x / -y;
	else
	    div = - (x / -y);
    }
    else {
	if (x &lt; 0)
	    div = - (-x / y);
	else
	    div = x / y;
    }
    mod = x - div*y;
    if ((mod &lt; 0 &amp;&amp; y &gt; 0) || (mod &gt; 0 &amp;&amp; y &lt; 0)) {
	mod += y;
	div -= 1;
    }
    if (divp) *divp = div;
    if (modp) *modp = mod;
}

/*
 *  call-seq:
 *     fix.quo(numeric)    =&gt; float
 *     fix.fdiv(numeric)   =&gt; float
 *
 *  Returns the floating point result of dividing &lt;i&gt;fix&lt;/i&gt; by
 *  &lt;i&gt;numeric&lt;/i&gt;.
 *
 *     654321.quo(13731)      #=&gt; 47.6528293642124
 *     654321.quo(13731.24)   #=&gt; 47.6519964693647
 *
 */

static VALUE
fix_quo(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	return rb_float_new((double)FIX2LONG(x) / (double)FIX2LONG(y));
    }
    return rb_num_coerce_bin(x, y);
}

/*
 * call-seq:
 *   fix / numeric      =&gt;  numeric_result
 *   fix.div(numeric)   =&gt;  numeric_result
 *
 * Performs division: the class of the resulting object depends on
 * the class of &lt;code&gt;numeric&lt;/code&gt; and on the magnitude of the
 * result.
 */

static VALUE
fix_div(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long div;

	fixdivmod(FIX2LONG(x), FIX2LONG(y), &amp;div, 0);
	return LONG2NUM(div);
    }
    return rb_num_coerce_bin(x, y);
}

/*
 *  call-seq:
 *    fix % other         =&gt; Numeric
 *    fix.modulo(other)   =&gt; Numeric
 *
 *  Returns &lt;code&gt;fix&lt;/code&gt; modulo &lt;code&gt;other&lt;/code&gt;.
 *  See &lt;code&gt;Numeric.divmod&lt;/code&gt; for more information.
 */

static VALUE
fix_mod(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long mod;

	fixdivmod(FIX2LONG(x), FIX2LONG(y), 0, &amp;mod);
	return LONG2NUM(mod);
    }
    return rb_num_coerce_bin(x, y);
}

/*
 *  call-seq:
 *     fix.divmod(numeric)    =&gt; array
 *
 *  See &lt;code&gt;Numeric#divmod&lt;/code&gt;.
 */
static VALUE
fix_divmod(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long div, mod;

	fixdivmod(FIX2LONG(x), FIX2LONG(y), &amp;div, &amp;mod);

	return rb_assoc_new(LONG2NUM(div), LONG2NUM(mod));
    }
    return rb_num_coerce_bin(x, y);
}

static VALUE
int_pow(x, y)
    long x;
    unsigned long y;
{
    int neg = x &lt; 0;
    long z = 1;

    if (neg) x = -x;
    if (y &amp; 1)
	z = x;
    else
	neg = 0;
    y &amp;= ~1;
    do {
	while (y % 2 == 0) {
	    long x2 = x * x;
	    if (x2/x != x || !POSFIXABLE(x2)) {
		VALUE v;
	      bignum:
		v = rb_big_pow(rb_int2big(x), LONG2NUM(y));
		if (z != 1) v = rb_big_mul(rb_int2big(neg ? -z : z), v);
		return v;
	    }
	    x = x2;
	    y &gt;&gt;= 1;
	}
	{
	    long xz = x * z;
	    if (!POSFIXABLE(xz) || xz / x != z) {
		goto bignum;
	    }
	    z = xz;
	}
    } while (--y);
    if (neg) z = -z;
    return LONG2NUM(z);
}

/*
 *  call-seq:
 *    fix ** other         =&gt; Numeric
 *
 *  Raises &lt;code&gt;fix&lt;/code&gt; to the &lt;code&gt;other&lt;/code&gt; power, which may
 *  be negative or fractional.
 *
 *    2 ** 3      #=&gt; 8
 *    2 ** -1     #=&gt; 0.5
 *    2 ** 0.5    #=&gt; 1.4142135623731
 */

static VALUE
fix_pow(x, y)
    VALUE x, y;
{
    static const double zero = 0.0;
    long a = FIX2LONG(x);

    if (FIXNUM_P(y)) {
	long b = FIX2LONG(y);

	if (b == 0) return INT2FIX(1);
	if (b == 1) return x;
	if (a == 0) {
	    if (b &gt; 0) return INT2FIX(0);
	    return rb_float_new(1.0 / zero);
	}
	if (a == 1) return INT2FIX(1);
	if (a == -1) {
	    if (b % 2 == 0)
		return INT2FIX(1);
	    else 
		return INT2FIX(-1);
	}
	if (b &gt; 0) {
	    return int_pow(a, b);
	}
	return rb_float_new(pow((double)a, (double)b));
    }
    switch (TYPE(y)) {
      case T_BIGNUM:
	if (a == 0) return INT2FIX(0);
	if (a == 1) return INT2FIX(1);
	if (a == -1) {
	    if (int_even_p(y)) return INT2FIX(1);
	    else return INT2FIX(-1);
	}
	x = rb_int2big(FIX2LONG(x));
	return rb_big_pow(x, y);
      case T_FLOAT:
	if (RFLOAT(y)-&gt;value == 0.0) return rb_float_new(1.0);
	if (a == 0) {
	    return rb_float_new(RFLOAT(y)-&gt;value &lt; 0 ? (1.0 / zero) : 0.0);
	}
	if (a == 1) return rb_float_new(1.0);
	return rb_float_new(pow((double)a, RFLOAT(y)-&gt;value));
      default:
	return rb_num_coerce_bin(x, y);
    }
}

/*
 * call-seq:
 *   fix == other
 *
 * Return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;fix&lt;/code&gt; equals &lt;code&gt;other&lt;/code&gt;
 * numerically.
 *
 *   1 == 2      #=&gt; false
 *   1 == 1.0    #=&gt; true
 */

static VALUE
fix_equal(x, y)
    VALUE x, y;
{
    if (x == y) return Qtrue;
    if (FIXNUM_P(y)) return Qfalse;
    return num_equal(x, y);
}

/*
 *  call-seq:
 *     fix &lt;=&gt; numeric    =&gt; -1, 0, +1
 *
 *  Comparison---Returns -1, 0, or +1 depending on whether &lt;i&gt;fix&lt;/i&gt; is
 *  less than, equal to, or greater than &lt;i&gt;numeric&lt;/i&gt;. This is the
 *  basis for the tests in &lt;code&gt;Comparable&lt;/code&gt;.
 */

static VALUE
fix_cmp(x, y)
    VALUE x, y;
{
    if (x == y) return INT2FIX(0);
    if (FIXNUM_P(y)) {
	long a = FIX2LONG(x), b = FIX2LONG(y);

	if (a &gt; b) return INT2FIX(1);
	return INT2FIX(-1);
    }
    else {
	return rb_num_coerce_cmp(x, y);
    }
}

/*
 * call-seq:
 *   fix &gt; other     =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the value of &lt;code&gt;fix&lt;/code&gt; is
 * greater than that of &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
fix_gt(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long a = FIX2LONG(x), b = FIX2LONG(y);

	if (a &gt; b) return Qtrue;
	return Qfalse;
    }
    else {
	return rb_num_coerce_relop(x, y);
    }
}

/*
 * call-seq:
 *   fix &gt;= other     =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the value of &lt;code&gt;fix&lt;/code&gt; is
 * greater than or equal to that of &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
fix_ge(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long a = FIX2LONG(x), b = FIX2LONG(y);

	if (a &gt;= b) return Qtrue;
	return Qfalse;
    }
    else {
	return rb_num_coerce_relop(x, y);
    }
}

/*
 * call-seq:
 *   fix &lt; other     =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the value of &lt;code&gt;fix&lt;/code&gt; is
 * less than that of &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
fix_lt(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long a = FIX2LONG(x), b = FIX2LONG(y);

	if (a &lt; b) return Qtrue;
	return Qfalse;
    }
    else {
	return rb_num_coerce_relop(x, y);
    }
}

/*
 * call-seq:
 *   fix &lt;= other     =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the value of &lt;code&gt;fix&lt;/code&gt; is
 * less thanor equal to that of &lt;code&gt;other&lt;/code&gt;.
 */

static VALUE
fix_le(x, y)
    VALUE x, y;
{
    if (FIXNUM_P(y)) {
	long a = FIX2LONG(x), b = FIX2LONG(y);

	if (a &lt;= b) return Qtrue;
	return Qfalse;
    }
    else {
	return rb_num_coerce_relop(x, y);
    }
}

/*
 * call-seq:
 *   ~fix     =&gt; integer
 *
 * One's complement: returns a number where each bit is flipped.
 */

static VALUE
fix_rev(num)
    VALUE num;
{
    long val = FIX2LONG(num);

    val = ~val;
    return LONG2NUM(val);
}

static VALUE
fix_coerce(x)
    VALUE x;
{
    while (!FIXNUM_P(x) &amp;&amp; TYPE(x) != T_BIGNUM) {
	x = rb_to_int(x);
    }
    return x;
}

/*
 * call-seq:
 *   fix &amp; other     =&gt; integer
 *
 * Bitwise AND.
 */

static VALUE
fix_and(x, y)
    VALUE x, y;
{
    long val;

    if (!FIXNUM_P(y = fix_coerce(y))) {
	return rb_big_and(y, x);
    }
    val = FIX2LONG(x) &amp; FIX2LONG(y);
    return LONG2NUM(val);
}

/*
 * call-seq:
 *   fix | other     =&gt; integer
 *
 * Bitwise OR.
 */

static VALUE
fix_or(x, y)
    VALUE x, y;
{
    long val;

    if (!FIXNUM_P(y = fix_coerce(y))) {
	return rb_big_or(y, x);
    }
    val = FIX2LONG(x) | FIX2LONG(y);
    return LONG2NUM(val);
}

/*
 * call-seq:
 *   fix ^ other     =&gt; integer
 *
 * Bitwise EXCLUSIVE OR.
 */

static VALUE
fix_xor(x, y)
    VALUE x, y;
{
    long val;

    if (!FIXNUM_P(y = fix_coerce(y))) {
	return rb_big_xor(y, x);
    }
    val = FIX2LONG(x) ^ FIX2LONG(y);
    return LONG2NUM(val);
}

static VALUE fix_lshift _((long, unsigned long));
static VALUE fix_rshift _((long, unsigned long));

/*
 * call-seq:
 *   fix &lt;&lt; count     =&gt; integer
 *
 * Shifts _fix_ left _count_ positions (right if _count_ is negative).
 */

static VALUE
rb_fix_lshift(x, y)
    VALUE x, y;
{
    long val, width;

    val = NUM2LONG(x);
    if (!FIXNUM_P(y))
	return rb_big_lshift(rb_int2big(val), y);
    width = FIX2LONG(y);
    if (width &lt; 0)
	return fix_rshift(val, (unsigned long)-width);
    return fix_lshift(val, width);
}

static VALUE
fix_lshift(val, width)
    long val;
    unsigned long width;
{
    if (width &gt; (sizeof(VALUE)*CHAR_BIT-1)
	|| ((unsigned long)val)&gt;&gt;(sizeof(VALUE)*CHAR_BIT-1-width) &gt; 0) {
	return rb_big_lshift(rb_int2big(val), ULONG2NUM(width));
    }
    val = val &lt;&lt; width;
    return LONG2NUM(val);
}

/*
 * call-seq:
 *   fix &gt;&gt; count     =&gt; integer
 *
 * Shifts _fix_ right _count_ positions (left if _count_ is negative).
 */

static VALUE
rb_fix_rshift(x, y)
    VALUE x, y;
{
    long i, val;

    val = FIX2LONG(x);
    if (!FIXNUM_P(y))
	return rb_big_rshift(rb_int2big(val), y);
    i = FIX2LONG(y);
    if (i == 0) return x;
    if (i &lt; 0)
	return fix_lshift(val, (unsigned long)-i);
    return fix_rshift(val, i);
}

static VALUE
fix_rshift(long val, unsigned long i)
{
    if (i &gt;= sizeof(long)*CHAR_BIT-1) {
	if (val &lt; 0) return INT2FIX(-1);
	return INT2FIX(0);
    }
    val = RSHIFT(val, i);
    return LONG2FIX(val);
}

/*
 *  call-seq:
 *     fix[n]     =&gt; 0, 1
 *
 *  Bit Reference---Returns the &lt;em&gt;n&lt;/em&gt;th bit in the binary
 *  representation of &lt;i&gt;fix&lt;/i&gt;, where &lt;i&gt;fix&lt;/i&gt;[0] is the least
 *  significant bit.
 *
 *     a = 0b11001100101010
 *     30.downto(0) do |n| print a[n] end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     0000000000000000011001100101010
 */

static VALUE
fix_aref(fix, idx)
    VALUE fix, idx;
{
    long val = FIX2LONG(fix);
    long i;

    if (!FIXNUM_P(idx = fix_coerce(idx))) {
	idx = rb_big_norm(idx);
	if (!FIXNUM_P(idx)) {
	    if (!RBIGNUM(idx)-&gt;sign || val &gt;= 0)
		return INT2FIX(0);
	    return INT2FIX(1);
	}
    }
    i = FIX2LONG(idx);

    if (i &lt; 0) return INT2FIX(0);
    if (sizeof(VALUE)*CHAR_BIT-1 &lt; i) {
	if (val &lt; 0) return INT2FIX(1);
	return INT2FIX(0);
    }
    if (val &amp; (1L&lt;&lt;i))
	return INT2FIX(1);
    return INT2FIX(0);
}

/*
 *  call-seq:
 *     fix.to_f -&gt; float
 *
 *  Converts &lt;i&gt;fix&lt;/i&gt; to a &lt;code&gt;Float&lt;/code&gt;.
 *
 */

static VALUE
fix_to_f(num)
    VALUE num;
{
    double val;

    val = (double)FIX2LONG(num);

    return rb_float_new(val);
}

/*
 *  call-seq:
 *     fix.abs -&gt; aFixnum
 *
 *  Returns the absolute value of &lt;i&gt;fix&lt;/i&gt;.
 *
 *     -12345.abs   #=&gt; 12345
 *     12345.abs    #=&gt; 12345
 *
 */

static VALUE
fix_abs(fix)
    VALUE fix;
{
    long i = FIX2LONG(fix);

    if (i &lt; 0) i = -i;

    return LONG2NUM(i);
}

/*
 *  call-seq:
 *     fix.id2name -&gt; string or nil
 *
 *  Returns the name of the object whose symbol id is &lt;i&gt;fix&lt;/i&gt;. If
 *  there is no symbol in the symbol table with this value, returns
 *  &lt;code&gt;nil&lt;/code&gt;. &lt;code&gt;id2name&lt;/code&gt; has nothing to do with the
 *  &lt;code&gt;Object.id&lt;/code&gt; method. See also &lt;code&gt;Fixnum#to_sym&lt;/code&gt;,
 *  &lt;code&gt;String#intern&lt;/code&gt;, and class &lt;code&gt;Symbol&lt;/code&gt;.
 *
 *     symbol = :@inst_var    #=&gt; :@inst_var
 *     id     = symbol.to_i   #=&gt; 9818
 *     id.id2name             #=&gt; &quot;@inst_var&quot;
 */

static VALUE
fix_id2name(fix)
    VALUE fix;
{
    const char *name = rb_id2name(FIX2UINT(fix));
    if (name) return rb_str_new2(name);
    return Qnil;
}


/*
 *  call-seq:
 *     fix.to_sym -&gt; aSymbol
 *
 *  Returns the symbol whose integer value is &lt;i&gt;fix&lt;/i&gt;. See also
 *  &lt;code&gt;Fixnum#id2name&lt;/code&gt;.
 *
 *     fred = :fred.to_i
 *     fred.id2name   #=&gt; &quot;fred&quot;
 *     fred.to_sym    #=&gt; :fred
 */

static VALUE
fix_to_sym(fix)
    VALUE fix;
{
    ID id = FIX2UINT(fix);

    if (rb_id2name(id)) {
	return ID2SYM(id);
    }
    return Qnil;
}


/*
 *  call-seq:
 *     fix.size -&gt; fixnum
 *
 *  Returns the number of &lt;em&gt;bytes&lt;/em&gt; in the machine representation
 *  of a &lt;code&gt;Fixnum&lt;/code&gt;.
 *
 *     1.size            #=&gt; 4
 *     -1.size           #=&gt; 4
 *     2147483647.size   #=&gt; 4
 */

static VALUE
fix_size(fix)
    VALUE fix;
{
    return INT2FIX(sizeof(long));
}

/*
 *  call-seq:
 *     int.upto(limit) {|i| block }     =&gt; int
 *
 *  Iterates &lt;em&gt;block&lt;/em&gt;, passing in integer values from &lt;i&gt;int&lt;/i&gt;
 *  up to and including &lt;i&gt;limit&lt;/i&gt;.
 *
 *     5.upto(10) { |i| print i, &quot; &quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     5 6 7 8 9 10
 */

static VALUE
int_upto(from, to)
    VALUE from, to;
{
    RETURN_ENUMERATOR(from, 1, &amp;to);

    if (FIXNUM_P(from) &amp;&amp; FIXNUM_P(to)) {
	long i, end;

	end = FIX2LONG(to);
	for (i = FIX2LONG(from); i &lt;= end; i++) {
	    rb_yield(LONG2FIX(i));
	}
    }
    else {
	VALUE i = from, c;

	while (!(c = rb_funcall(i, '&gt;', 1, to))) {
	    rb_yield(i);
	    i = rb_funcall(i, '+', 1, INT2FIX(1));
	}
	if (NIL_P(c)) rb_cmperr(i, to);
    }
    return from;
}

/*
 *  call-seq:
 *     int.downto(limit) {|i| block }     =&gt; int
 *
 *  Iterates &lt;em&gt;block&lt;/em&gt;, passing decreasing values from &lt;i&gt;int&lt;/i&gt;
 *  down to and including &lt;i&gt;limit&lt;/i&gt;.
 *
 *     5.downto(1) { |n| print n, &quot;.. &quot; }
 *     print &quot;  Liftoff!\n&quot;
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     5.. 4.. 3.. 2.. 1..   Liftoff!
 */

static VALUE
int_downto(from, to)
    VALUE from, to;
{
    RETURN_ENUMERATOR(from, 1, &amp;to);

    if (FIXNUM_P(from) &amp;&amp; FIXNUM_P(to)) {
	long i, end;

	end = FIX2LONG(to);
	for (i=FIX2LONG(from); i &gt;= end; i--) {
	    rb_yield(LONG2FIX(i));
	}
    }
    else {
	VALUE i = from, c;

	while (!(c = rb_funcall(i, '&lt;', 1, to))) {
	    rb_yield(i);
	    i = rb_funcall(i, '-', 1, INT2FIX(1));
	}
	if (NIL_P(c)) rb_cmperr(i, to);
    }
    return from;
}

/*
 *  call-seq:
 *     int.times {|i| block }     =&gt; int
 *
 *  Iterates block &lt;i&gt;int&lt;/i&gt; times, passing in values from zero to
 *  &lt;i&gt;int&lt;/i&gt; - 1.
 *
 *     5.times do |i|
 *       print i, &quot; &quot;
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     0 1 2 3 4
 */

static VALUE
int_dotimes(num)
    VALUE num;
{
    RETURN_ENUMERATOR(num, 0, 0);

    if (FIXNUM_P(num)) {
	long i, end;

	end = FIX2LONG(num);
	for (i=0; i&lt;end; i++) {
	    rb_yield(LONG2FIX(i));
	}
    }
    else {
	VALUE i = INT2FIX(0);

	for (;;) {
	    if (!RTEST(rb_funcall(i, '&lt;', 1, num))) break;
	    rb_yield(i);
	    i = rb_funcall(i, '+', 1, INT2FIX(1));
	}
    }
    return num;
}

/*
 *  call-seq:
 *     fix.zero?    =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;fix&lt;/i&gt; is zero.
 *
 */

static VALUE
fix_zero_p(num)
    VALUE num;
{
    if (FIX2LONG(num) == 0) {
	return Qtrue;
    }
    return Qfalse;
}

/*
 *  call-seq:
 *     fix.odd? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;fix&lt;/i&gt; is an odd number.
 */

static VALUE
fix_odd_p(VALUE num)
{
    if (num &amp; 2) {
        return Qtrue;
    }
    return Qfalse;
}

/*
 *  call-seq:
 *     fix.even? -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;fix&lt;/i&gt; is an even number.
 */

static VALUE
fix_even_p(VALUE num)
{
    if (num &amp; 2) {
        return Qfalse;
    }
    return Qtrue;
}

void
Init_Numeric()
{
#if defined(__FreeBSD__) &amp;&amp; __FreeBSD__ &lt; 4
    /* allow divide by zero -- Inf */
    fpsetmask(fpgetmask() &amp; ~(FP_X_DZ|FP_X_INV|FP_X_OFL));
#elif defined(_UNICOSMP)
    /* Turn off floating point exceptions for divide by zero, etc. */
    _set_Creg(0, 0);
#elif defined(__BORLANDC__)
    /* Turn off floating point exceptions for overflow, etc. */
    _control87(MCW_EM, MCW_EM);
#endif
    id_coerce = rb_intern(&quot;coerce&quot;);
    id_to_i = rb_intern(&quot;to_i&quot;);
    id_eq = rb_intern(&quot;==&quot;);

    rb_eZeroDivError = rb_define_class(&quot;ZeroDivisionError&quot;, rb_eStandardError);
    rb_eFloatDomainError = rb_define_class(&quot;FloatDomainError&quot;, rb_eRangeError);
    rb_cNumeric = rb_define_class(&quot;Numeric&quot;, rb_cObject);

    rb_define_method(rb_cNumeric, &quot;singleton_method_added&quot;, num_sadded, 1);
    rb_include_module(rb_cNumeric, rb_mComparable);
    rb_define_method(rb_cNumeric, &quot;initialize_copy&quot;, num_init_copy, 1);
    rb_define_method(rb_cNumeric, &quot;coerce&quot;, num_coerce, 1);

    rb_define_method(rb_cNumeric, &quot;+@&quot;, num_uplus, 0);
    rb_define_method(rb_cNumeric, &quot;-@&quot;, num_uminus, 0);
    rb_define_method(rb_cNumeric, &quot;&lt;=&gt;&quot;, num_cmp, 1);
    rb_define_method(rb_cNumeric, &quot;eql?&quot;, num_eql, 1);
    rb_define_method(rb_cNumeric, &quot;quo&quot;, num_quo, 1);
    rb_define_method(rb_cNumeric, &quot;fdiv&quot;, num_quo, 1);
    rb_define_method(rb_cNumeric, &quot;div&quot;, num_div, 1);
    rb_define_method(rb_cNumeric, &quot;divmod&quot;, num_divmod, 1);
    rb_define_method(rb_cNumeric, &quot;modulo&quot;, num_modulo, 1);
    rb_define_method(rb_cNumeric, &quot;remainder&quot;, num_remainder, 1);
    rb_define_method(rb_cNumeric, &quot;abs&quot;, num_abs, 0);
    rb_define_method(rb_cNumeric, &quot;to_int&quot;, num_to_int, 0);

    rb_define_method(rb_cNumeric, &quot;integer?&quot;, num_int_p, 0);
    rb_define_method(rb_cNumeric, &quot;zero?&quot;, num_zero_p, 0);
    rb_define_method(rb_cNumeric, &quot;nonzero?&quot;, num_nonzero_p, 0);

    rb_define_method(rb_cNumeric, &quot;floor&quot;, num_floor, 0);
    rb_define_method(rb_cNumeric, &quot;ceil&quot;, num_ceil, 0);
    rb_define_method(rb_cNumeric, &quot;round&quot;, num_round, 0);
    rb_define_method(rb_cNumeric, &quot;truncate&quot;, num_truncate, 0);
    rb_define_method(rb_cNumeric, &quot;step&quot;, num_step, -1);

    rb_cInteger = rb_define_class(&quot;Integer&quot;, rb_cNumeric);
    rb_undef_alloc_func(rb_cInteger);
    rb_undef_method(CLASS_OF(rb_cInteger), &quot;new&quot;);

    rb_define_method(rb_cInteger, &quot;integer?&quot;, int_int_p, 0);
    rb_define_method(rb_cInteger, &quot;odd?&quot;, int_odd_p, 0);
    rb_define_method(rb_cInteger, &quot;even?&quot;, int_even_p, 0);
    rb_define_method(rb_cInteger, &quot;upto&quot;, int_upto, 1);
    rb_define_method(rb_cInteger, &quot;downto&quot;, int_downto, 1);
    rb_define_method(rb_cInteger, &quot;times&quot;, int_dotimes, 0);
    rb_include_module(rb_cInteger, rb_mPrecision);
    rb_define_method(rb_cInteger, &quot;succ&quot;, int_succ, 0);
    rb_define_method(rb_cInteger, &quot;next&quot;, int_succ, 0);
    rb_define_method(rb_cInteger, &quot;pred&quot;, int_pred, 0);
    rb_define_method(rb_cInteger, &quot;chr&quot;, int_chr, 0);
    rb_define_method(rb_cInteger, &quot;ord&quot;, int_ord, 0);
    rb_define_method(rb_cInteger, &quot;to_i&quot;, int_to_i, 0);
    rb_define_method(rb_cInteger, &quot;to_int&quot;, int_to_i, 0);
    rb_define_method(rb_cInteger, &quot;floor&quot;, int_to_i, 0);
    rb_define_method(rb_cInteger, &quot;ceil&quot;, int_to_i, 0);
    rb_define_method(rb_cInteger, &quot;round&quot;, int_to_i, 0);
    rb_define_method(rb_cInteger, &quot;truncate&quot;, int_to_i, 0);

    rb_cFixnum = rb_define_class(&quot;Fixnum&quot;, rb_cInteger);
    rb_include_module(rb_cFixnum, rb_mPrecision);
    rb_define_singleton_method(rb_cFixnum, &quot;induced_from&quot;, rb_fix_induced_from, 1);
    rb_define_singleton_method(rb_cInteger, &quot;induced_from&quot;, rb_int_induced_from, 1);

    rb_define_method(rb_cFixnum, &quot;to_s&quot;, fix_to_s, -1);

    rb_define_method(rb_cFixnum, &quot;id2name&quot;, fix_id2name, 0);
    rb_define_method(rb_cFixnum, &quot;to_sym&quot;, fix_to_sym, 0);

    rb_define_method(rb_cFixnum, &quot;-@&quot;, fix_uminus, 0);
    rb_define_method(rb_cFixnum, &quot;+&quot;, fix_plus, 1);
    rb_define_method(rb_cFixnum, &quot;-&quot;, fix_minus, 1);
    rb_define_method(rb_cFixnum, &quot;*&quot;, fix_mul, 1);
    rb_define_method(rb_cFixnum, &quot;/&quot;, fix_div, 1);
    rb_define_method(rb_cFixnum, &quot;div&quot;, fix_div, 1);
    rb_define_method(rb_cFixnum, &quot;%&quot;, fix_mod, 1);
    rb_define_method(rb_cFixnum, &quot;modulo&quot;, fix_mod, 1);
    rb_define_method(rb_cFixnum, &quot;divmod&quot;, fix_divmod, 1);
    rb_define_method(rb_cFixnum, &quot;quo&quot;, fix_quo, 1);
    rb_define_method(rb_cFixnum, &quot;fdiv&quot;, fix_quo, 1);
    rb_define_method(rb_cFixnum, &quot;**&quot;, fix_pow, 1);

    rb_define_method(rb_cFixnum, &quot;abs&quot;, fix_abs, 0);

    rb_define_method(rb_cFixnum, &quot;==&quot;, fix_equal, 1);
    rb_define_method(rb_cFixnum, &quot;&lt;=&gt;&quot;, fix_cmp, 1);
    rb_define_method(rb_cFixnum, &quot;&gt;&quot;,  fix_gt, 1);
    rb_define_method(rb_cFixnum, &quot;&gt;=&quot;, fix_ge, 1);
    rb_define_method(rb_cFixnum, &quot;&lt;&quot;,  fix_lt, 1);
    rb_define_method(rb_cFixnum, &quot;&lt;=&quot;, fix_le, 1);

    rb_define_method(rb_cFixnum, &quot;~&quot;, fix_rev, 0);
    rb_define_method(rb_cFixnum, &quot;&amp;&quot;, fix_and, 1);
    rb_define_method(rb_cFixnum, &quot;|&quot;, fix_or,  1);
    rb_define_method(rb_cFixnum, &quot;^&quot;, fix_xor, 1);
    rb_define_method(rb_cFixnum, &quot;[]&quot;, fix_aref, 1);

    rb_define_method(rb_cFixnum, &quot;&lt;&lt;&quot;, rb_fix_lshift, 1);
    rb_define_method(rb_cFixnum, &quot;&gt;&gt;&quot;, rb_fix_rshift, 1);

    rb_define_method(rb_cFixnum, &quot;to_f&quot;, fix_to_f, 0);
    rb_define_method(rb_cFixnum, &quot;size&quot;, fix_size, 0);
    rb_define_method(rb_cFixnum, &quot;zero?&quot;, fix_zero_p, 0);
    rb_define_method(rb_cFixnum, &quot;odd?&quot;, fix_odd_p, 0);
    rb_define_method(rb_cFixnum, &quot;even?&quot;, fix_even_p, 0);

    rb_cFloat  = rb_define_class(&quot;Float&quot;, rb_cNumeric);

    rb_undef_alloc_func(rb_cFloat);
    rb_undef_method(CLASS_OF(rb_cFloat), &quot;new&quot;);

    rb_define_singleton_method(rb_cFloat, &quot;induced_from&quot;, rb_flo_induced_from, 1);
    rb_include_module(rb_cFloat, rb_mPrecision);

    rb_define_const(rb_cFloat, &quot;ROUNDS&quot;, INT2FIX(FLT_ROUNDS));
    rb_define_const(rb_cFloat, &quot;RADIX&quot;, INT2FIX(FLT_RADIX));
    rb_define_const(rb_cFloat, &quot;MANT_DIG&quot;, INT2FIX(DBL_MANT_DIG));
    rb_define_const(rb_cFloat, &quot;DIG&quot;, INT2FIX(DBL_DIG));
    rb_define_const(rb_cFloat, &quot;MIN_EXP&quot;, INT2FIX(DBL_MIN_EXP));
    rb_define_const(rb_cFloat, &quot;MAX_EXP&quot;, INT2FIX(DBL_MAX_EXP));
    rb_define_const(rb_cFloat, &quot;MIN_10_EXP&quot;, INT2FIX(DBL_MIN_10_EXP));
    rb_define_const(rb_cFloat, &quot;MAX_10_EXP&quot;, INT2FIX(DBL_MAX_10_EXP));
    rb_define_const(rb_cFloat, &quot;MIN&quot;, rb_float_new(DBL_MIN));
    rb_define_const(rb_cFloat, &quot;MAX&quot;, rb_float_new(DBL_MAX));
    rb_define_const(rb_cFloat, &quot;EPSILON&quot;, rb_float_new(DBL_EPSILON));

    rb_define_method(rb_cFloat, &quot;to_s&quot;, flo_to_s, 0);
    rb_define_method(rb_cFloat, &quot;coerce&quot;, flo_coerce, 1);
    rb_define_method(rb_cFloat, &quot;-@&quot;, flo_uminus, 0);
    rb_define_method(rb_cFloat, &quot;+&quot;, flo_plus, 1);
    rb_define_method(rb_cFloat, &quot;-&quot;, flo_minus, 1);
    rb_define_method(rb_cFloat, &quot;*&quot;, flo_mul, 1);
    rb_define_method(rb_cFloat, &quot;/&quot;, flo_div, 1);
    rb_define_method(rb_cFloat, &quot;%&quot;, flo_mod, 1);
    rb_define_method(rb_cFloat, &quot;modulo&quot;, flo_mod, 1);
    rb_define_method(rb_cFloat, &quot;divmod&quot;, flo_divmod, 1);
    rb_define_method(rb_cFloat, &quot;**&quot;, flo_pow, 1);
    rb_define_method(rb_cFloat, &quot;==&quot;, flo_eq, 1);
    rb_define_method(rb_cFloat, &quot;&lt;=&gt;&quot;, flo_cmp, 1);
    rb_define_method(rb_cFloat, &quot;&gt;&quot;,  flo_gt, 1);
    rb_define_method(rb_cFloat, &quot;&gt;=&quot;, flo_ge, 1);
    rb_define_method(rb_cFloat, &quot;&lt;&quot;,  flo_lt, 1);
    rb_define_method(rb_cFloat, &quot;&lt;=&quot;, flo_le, 1);
    rb_define_method(rb_cFloat, &quot;eql?&quot;, flo_eql, 1);
    rb_define_method(rb_cFloat, &quot;hash&quot;, flo_hash, 0);
    rb_define_method(rb_cFloat, &quot;to_f&quot;, flo_to_f, 0);
    rb_define_method(rb_cFloat, &quot;abs&quot;, flo_abs, 0);
    rb_define_method(rb_cFloat, &quot;zero?&quot;, flo_zero_p, 0);

    rb_define_method(rb_cFloat, &quot;to_i&quot;, flo_truncate, 0);
    rb_define_method(rb_cFloat, &quot;to_int&quot;, flo_truncate, 0);
    rb_define_method(rb_cFloat, &quot;floor&quot;, flo_floor, 0);
    rb_define_method(rb_cFloat, &quot;ceil&quot;, flo_ceil, 0);
    rb_define_method(rb_cFloat, &quot;round&quot;, flo_round, 0);
    rb_define_method(rb_cFloat, &quot;truncate&quot;, flo_truncate, 0);

    rb_define_method(rb_cFloat, &quot;nan?&quot;,      flo_is_nan_p, 0);
    rb_define_method(rb_cFloat, &quot;infinite?&quot;, flo_is_infinite_p, 0);
    rb_define_method(rb_cFloat, &quot;finite?&quot;,   flo_is_finite_p, 0);
}
</pre>
    </div>