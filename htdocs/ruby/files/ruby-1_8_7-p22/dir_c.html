  <div id="fileHeader">
    <h1>dir.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/dir.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat May 31 06:44:49 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  dir.c -

  $Author: knu $
  $Date: 2008-05-31 20:44:49 +0900 (Sat, 31 May 2008) $
  created at: Wed Jan  5 09:51:01 JST 1994

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include &quot;ruby.h&quot;

#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif

#if defined HAVE_DIRENT_H &amp;&amp; !defined _WIN32
# include &lt;dirent.h&gt;
# define NAMLEN(dirent) strlen((dirent)-&gt;d_name)
#elif defined HAVE_DIRECT_H &amp;&amp; !defined _WIN32
# include &lt;direct.h&gt;
# define NAMLEN(dirent) strlen((dirent)-&gt;d_name)
#else
# define dirent direct
# if !defined __NeXT__
#  define NAMLEN(dirent) (dirent)-&gt;d_namlen
# else
#  /* On some versions of NextStep, d_namlen is always zero, so avoid it. */
#  define NAMLEN(dirent) strlen((dirent)-&gt;d_name)
# endif
# if HAVE_SYS_NDIR_H
#  include &lt;sys/ndir.h&gt;
# endif
# if HAVE_SYS_DIR_H
#  include &lt;sys/dir.h&gt;
# endif
# if HAVE_NDIR_H
#  include &lt;ndir.h&gt;
# endif
# ifdef _WIN32
#  include &quot;win32/dir.h&quot;
# endif
#endif

#include &lt;errno.h&gt;

#ifndef HAVE_STDLIB_H
char *getenv();
#endif

#ifndef HAVE_STRING_H
char *strchr _((char*,char));
#endif

#include &lt;ctype.h&gt;

#include &quot;util.h&quot;

#if !defined HAVE_LSTAT &amp;&amp; !defined lstat
#define lstat stat
#endif

#ifndef CASEFOLD_FILESYSTEM
# if defined DOSISH || defined __VMS
#   define CASEFOLD_FILESYSTEM 1
# else
#   define CASEFOLD_FILESYSTEM 0
# endif
#endif

#define FNM_NOESCAPE	0x01
#define FNM_PATHNAME	0x02
#define FNM_DOTMATCH	0x04
#define FNM_CASEFOLD	0x08
#if CASEFOLD_FILESYSTEM
#define FNM_SYSCASE	FNM_CASEFOLD
#else
#define FNM_SYSCASE	0
#endif

#define FNM_NOMATCH	1
#define FNM_ERROR	2

#define downcase(c) (nocase &amp;&amp; ISUPPER(c) ? tolower(c) : (c))
#define compare(c1, c2) (((unsigned char)(c1)) - ((unsigned char)(c2)))

/* caution: in case *p == '\0'
   Next(p) == p + 1 in single byte environment
   Next(p) == p     in multi byte environment
*/
#if defined(CharNext)
# define Next(p) CharNext(p)
#elif defined(DJGPP)
# define Next(p) ((p) + mblen(p, RUBY_MBCHAR_MAXSIZE))
#elif defined(__EMX__)
# define Next(p) ((p) + emx_mblen(p))
static inline int
emx_mblen(const char *p)
{
    int n = mblen(p, RUBY_MBCHAR_MAXSIZE);
    return (n &lt; 0) ? 1 : n;
}
#endif

#ifndef Next /* single byte environment */
# define Next(p) ((p) + 1)
# define Inc(p) (++(p))
# define Compare(p1, p2) (compare(downcase(*(p1)), downcase(*(p2))))
#else /* multi byte environment */
# define Inc(p) ((p) = Next(p))
# define Compare(p1, p2) (CompareImpl(p1, p2, nocase))
static int
CompareImpl(const char *p1, const char *p2, int nocase)
{
    const int len1 = Next(p1) - p1;
    const int len2 = Next(p2) - p2;
#ifdef _WIN32
    char buf1[10], buf2[10]; /* large enough? */
#endif

    if (len1 &lt; 0 || len2 &lt; 0) {
	rb_fatal(&quot;CompareImpl: negative len&quot;);
    }

    if (len1 == 0) return  len2;
    if (len2 == 0) return -len1;

#ifdef _WIN32
    if (nocase &amp;&amp; rb_w32_iswinnt()) {
	if (len1 &gt; 1) {
	    if (len1 &gt;= sizeof(buf1)) {
		rb_fatal(&quot;CompareImpl: too large len&quot;);
	    }
	    memcpy(buf1, p1, len1);
	    buf1[len1] = '\0';
	    CharLower(buf1);
	    p1 = buf1; /* trick */
	}
	if (len2 &gt; 1) {
	    if (len2 &gt;= sizeof(buf2)) {
		rb_fatal(&quot;CompareImpl: too large len&quot;);
	    }
	    memcpy(buf2, p2, len2);
	    buf2[len2] = '\0';
	    CharLower(buf2);
	    p2 = buf2; /* trick */
	}
    }
#endif
    if (len1 == 1)
	if (len2 == 1)
	    return compare(downcase(*p1), downcase(*p2));
	else {
	    const int ret = compare(downcase(*p1), *p2);
	    return ret ? ret : -1;
	}
    else
	if (len2 == 1) {
	    const int ret = compare(*p1, downcase(*p2));
	    return ret ? ret : 1;
	}
	else {
	    const int ret = memcmp(p1, p2, len1 &lt; len2 ? len1 : len2);
	    return ret ? ret : len1 - len2;
	}
}
#endif /* environment */

static char *
bracket(p, s, flags)
    const char *p; /* pattern (next to '[') */
    const char *s; /* string */
    int flags;
{
    const int nocase = flags &amp; FNM_CASEFOLD;
    const int escape = !(flags &amp; FNM_NOESCAPE);

    int ok = 0, not = 0;

    if (*p == '!' || *p == '^') {
	not = 1;
	p++;
    }

    while (*p != ']') {
	const char *t1 = p;
	if (escape &amp;&amp; *t1 == '\\')
	    t1++;
	if (!*t1)
	    return NULL;
	p = Next(t1);
	if (p[0] == '-' &amp;&amp; p[1] != ']') {
	    const char *t2 = p + 1;
	    if (escape &amp;&amp; *t2 == '\\')
		t2++;
	    if (!*t2)
		return NULL;
	    p = Next(t2);
	    if (!ok &amp;&amp; Compare(t1, s) &lt;= 0 &amp;&amp; Compare(s, t2) &lt;= 0)
		ok = 1;
	}
	else
	    if (!ok &amp;&amp; Compare(t1, s) == 0)
		ok = 1;
    }

    return ok == not ? NULL : (char *)p + 1;
}

/* If FNM_PATHNAME is set, only path element will be matched. (upto '/' or '\0')
   Otherwise, entire string will be matched.
   End marker itself won't be compared.
   And if function succeeds, *pcur reaches end marker.
*/
#define UNESCAPE(p) (escape &amp;&amp; *(p) == '\\' ? (p) + 1 : (p))
#define ISEND(p) (!*(p) || (pathname &amp;&amp; *(p) == '/'))
#define RETURN(val) return *pcur = p, *scur = s, (val);

static int
fnmatch_helper(pcur, scur, flags)
    const char **pcur; /* pattern */
    const char **scur; /* string */
    int flags;
{
    const int period = !(flags &amp; FNM_DOTMATCH);
    const int pathname = flags &amp; FNM_PATHNAME;
    const int escape = !(flags &amp; FNM_NOESCAPE);
    const int nocase = flags &amp; FNM_CASEFOLD;

    const char *ptmp = 0;
    const char *stmp = 0;

    const char *p = *pcur;
    const char *s = *scur;

    if (period &amp;&amp; *s == '.' &amp;&amp; *UNESCAPE(p) != '.') /* leading period */
	RETURN(FNM_NOMATCH);

    while (1) {
	switch (*p) {
	  case '*':
	    do { p++; } while (*p == '*');
	    if (ISEND(UNESCAPE(p))) {
		p = UNESCAPE(p);
		RETURN(0);
	    }
	    if (ISEND(s))
		RETURN(FNM_NOMATCH);
	    ptmp = p;
	    stmp = s;
	    continue;

	  case '?':
	    if (ISEND(s))
		RETURN(FNM_NOMATCH);
	    p++;
	    Inc(s);
	    continue;

	  case '[': {
	    const char *t;
	    if (ISEND(s))
		RETURN(FNM_NOMATCH);
	    if ((t = bracket(p + 1, s, flags)) != 0) {
		p = t;
		Inc(s);
		continue;
	    }
	    goto failed;
	  }
	}

	/* ordinary */
	p = UNESCAPE(p);
	if (ISEND(s))
	    RETURN(ISEND(p) ? 0 : FNM_NOMATCH);
	if (ISEND(p))
	    goto failed;
	if (Compare(p, s) != 0)
	    goto failed;
	Inc(p);
	Inc(s);
	continue;

      failed: /* try next '*' position */
	if (ptmp &amp;&amp; stmp) {
	    p = ptmp;
	    Inc(stmp); /* !ISEND(*stmp) */
	    s = stmp;
	    continue;
	}
	RETURN(FNM_NOMATCH);
    }
}

static int
fnmatch(p, s, flags)
    const char *p; /* pattern */
    const char *s; /* string */
    int flags;
{
    const int period = !(flags &amp; FNM_DOTMATCH);
    const int pathname = flags &amp; FNM_PATHNAME;

    const char *ptmp = 0;
    const char *stmp = 0;

    if (pathname) {
	while (1) {
	    if (p[0] == '*' &amp;&amp; p[1] == '*' &amp;&amp; p[2] == '/') {
		do { p += 3; } while (p[0] == '*' &amp;&amp; p[1] == '*' &amp;&amp; p[2] == '/');
		ptmp = p;
		stmp = s;
	    }
	    if (fnmatch_helper(&amp;p, &amp;s, flags) == 0) {
		while (*s &amp;&amp; *s != '/') Inc(s);
		if (*p &amp;&amp; *s) {
		    p++;
		    s++;
		    continue;
		}
		if (!*p &amp;&amp; !*s)
		    return 0;
	    }
	    /* failed : try next recursion */
	    if (ptmp &amp;&amp; stmp &amp;&amp; !(period &amp;&amp; *stmp == '.')) {
		while (*stmp &amp;&amp; *stmp != '/') Inc(stmp);
		if (*stmp) {
		    p = ptmp;
		    stmp++;
		    s = stmp;
		    continue;
		}
	    }
	    return FNM_NOMATCH;
	}
    }
    else
	return fnmatch_helper(&amp;p, &amp;s, flags);
}

VALUE rb_cDir;

struct dir_data {
    DIR *dir;
    char *path;
};

static void
free_dir(dir)
    struct dir_data *dir;
{
    if (dir) {
	if (dir-&gt;dir) closedir(dir-&gt;dir);
	if (dir-&gt;path) free(dir-&gt;path);
    }
    free(dir);
}

static VALUE dir_close _((VALUE));

static VALUE dir_s_alloc _((VALUE));
static VALUE
dir_s_alloc(klass)
    VALUE klass;
{
    struct dir_data *dirp;
    VALUE obj = Data_Make_Struct(klass, struct dir_data, 0, free_dir, dirp);

    dirp-&gt;dir = NULL;
    dirp-&gt;path = NULL;

    return obj;
}

/*
 *  call-seq:
 *     Dir.new( string ) -&gt; aDir
 *
 *  Returns a new directory object for the named directory.
 */
static VALUE
dir_initialize(dir, dirname)
    VALUE dir, dirname;
{
    struct dir_data *dp;

    SafeStringValue(dirname);
    Data_Get_Struct(dir, struct dir_data, dp);
    if (dp-&gt;dir) closedir(dp-&gt;dir);
    if (dp-&gt;path) free(dp-&gt;path);
    dp-&gt;dir = NULL;
    dp-&gt;path = NULL;
    dp-&gt;dir = opendir(RSTRING(dirname)-&gt;ptr);
    if (dp-&gt;dir == NULL) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    dp-&gt;dir = opendir(RSTRING(dirname)-&gt;ptr);
	}
	if (dp-&gt;dir == NULL) {
	    rb_sys_fail(RSTRING(dirname)-&gt;ptr);
	}
    }
    dp-&gt;path = strdup(RSTRING(dirname)-&gt;ptr);

    return dir;
}

/*
 *  call-seq:
 *     Dir.open( string ) =&gt; aDir
 *     Dir.open( string ) {| aDir | block } =&gt; anObject
 *
 *  With no block, &lt;code&gt;open&lt;/code&gt; is a synonym for
 *  &lt;code&gt;Dir::new&lt;/code&gt;. If a block is present, it is passed
 *  &lt;i&gt;aDir&lt;/i&gt; as a parameter. The directory is closed at the end of
 *  the block, and &lt;code&gt;Dir::open&lt;/code&gt; returns the value of the
 *  block.
 */

static VALUE
dir_s_open(klass, dirname)
    VALUE klass, dirname;
{
    struct dir_data *dp;
    VALUE dir = Data_Make_Struct(klass, struct dir_data, 0, free_dir, dp);

    dir_initialize(dir, dirname);
    if (rb_block_given_p()) {
	return rb_ensure(rb_yield, dir, dir_close, dir);
    }

    return dir;
}

static void
dir_closed()
{
    rb_raise(rb_eIOError, &quot;closed directory&quot;);
}

static void
dir_check(dir)
    VALUE dir;
{
    if (!OBJ_TAINTED(dir) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: operation on untainted Dir&quot;);
    rb_check_frozen(dir);
}

#define GetDIR(obj, dirp) do {\
    dir_check(dir);\
    Data_Get_Struct(obj, struct dir_data, dirp);\
    if (dirp-&gt;dir == NULL) dir_closed();\
} while (0)

/*
 *  call-seq:
 *     dir.inspect =&gt; string
 *
 *  Return a string describing this Dir object.
 */
static VALUE
dir_inspect(dir)
    VALUE dir;
{
    struct dir_data *dirp;

    Data_Get_Struct(dir, struct dir_data, dirp);
    if (dirp-&gt;path) {
	const char *c = rb_obj_classname(dir);
	int len = strlen(c) + strlen(dirp-&gt;path) + 4;
	VALUE s = rb_str_new(0, len);
	snprintf(RSTRING_PTR(s), len+1, &quot;#&lt;%s:%s&gt;&quot;, c, dirp-&gt;path);
	return s;
    }
    return rb_funcall(dir, rb_intern(&quot;to_s&quot;), 0, 0);
}

/*
 *  call-seq:
 *     dir.path =&gt; string or nil
 *
 *  Returns the path parameter passed to &lt;em&gt;dir&lt;/em&gt;'s constructor.
 *
 *     d = Dir.new(&quot;..&quot;)
 *     d.path   #=&gt; &quot;..&quot;
 */
static VALUE
dir_path(dir)
    VALUE dir;
{
    struct dir_data *dirp;

    Data_Get_Struct(dir, struct dir_data, dirp);
    if (!dirp-&gt;path) return Qnil;
    return rb_str_new2(dirp-&gt;path);
}

/*
 *  call-seq:
 *     dir.read =&gt; string or nil
 *
 *  Reads the next entry from &lt;em&gt;dir&lt;/em&gt; and returns it as a string.
 *  Returns &lt;code&gt;nil&lt;/code&gt; at the end of the stream.
 *
 *     d = Dir.new(&quot;testdir&quot;)
 *     d.read   #=&gt; &quot;.&quot;
 *     d.read   #=&gt; &quot;..&quot;
 *     d.read   #=&gt; &quot;config.h&quot;
 */
static VALUE
dir_read(dir)
    VALUE dir;
{
    struct dir_data *dirp;
    struct dirent *dp;

    GetDIR(dir, dirp);
    errno = 0;
    dp = readdir(dirp-&gt;dir);
    if (dp) {
	return rb_tainted_str_new(dp-&gt;d_name, NAMLEN(dp));
    }
    else if (errno == 0) {	/* end of stream */
	return Qnil;
    }
    else {
	rb_sys_fail(0);
    }
    return Qnil;		/* not reached */
}

/*
 *  call-seq:
 *     dir.each { |filename| block }  =&gt; dir
 *
 *  Calls the block once for each entry in this directory, passing the
 *  filename of each entry as a parameter to the block.
 *
 *     d = Dir.new(&quot;testdir&quot;)
 *     d.each  {|x| puts &quot;Got #{x}&quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Got .
 *     Got ..
 *     Got config.h
 *     Got main.rb
 */
static VALUE
dir_each(dir)
    VALUE dir;
{
    struct dir_data *dirp;
    struct dirent *dp;

    RETURN_ENUMERATOR(dir, 0, 0);
    GetDIR(dir, dirp);
    rewinddir(dirp-&gt;dir);
    for (dp = readdir(dirp-&gt;dir); dp != NULL; dp = readdir(dirp-&gt;dir)) {
	rb_yield(rb_tainted_str_new(dp-&gt;d_name, NAMLEN(dp)));
	if (dirp-&gt;dir == NULL) dir_closed();
    }
    return dir;
}

/*
 *  call-seq:
 *     dir.pos =&gt; integer
 *     dir.tell =&gt; integer
 *
 *  Returns the current position in &lt;em&gt;dir&lt;/em&gt;. See also
 *  &lt;code&gt;Dir#seek&lt;/code&gt;.
 *
 *     d = Dir.new(&quot;testdir&quot;)
 *     d.tell   #=&gt; 0
 *     d.read   #=&gt; &quot;.&quot;
 *     d.tell   #=&gt; 12
 */
static VALUE
dir_tell(dir)
    VALUE dir;
{
#ifdef HAVE_TELLDIR
    struct dir_data *dirp;
    long pos;

    GetDIR(dir, dirp);
    pos = telldir(dirp-&gt;dir);
    return rb_int2inum(pos);
#else
    rb_notimplement();
#endif
}

/*
 *  call-seq:
 *     dir.seek( integer ) =&gt; dir
 *
 *  Seeks to a particular location in &lt;em&gt;dir&lt;/em&gt;. &lt;i&gt;integer&lt;/i&gt;
 *  must be a value returned by &lt;code&gt;Dir#tell&lt;/code&gt;.
 *
 *     d = Dir.new(&quot;testdir&quot;)   #=&gt; #&lt;Dir:0x401b3c40&gt;
 *     d.read                   #=&gt; &quot;.&quot;
 *     i = d.tell               #=&gt; 12
 *     d.read                   #=&gt; &quot;..&quot;
 *     d.seek(i)                #=&gt; #&lt;Dir:0x401b3c40&gt;
 *     d.read                   #=&gt; &quot;..&quot;
 */
static VALUE
dir_seek(dir, pos)
    VALUE dir, pos;
{
    struct dir_data *dirp;
    off_t p = NUM2OFFT(pos);

    GetDIR(dir, dirp);
#ifdef HAVE_SEEKDIR
    seekdir(dirp-&gt;dir, p);
    return dir;
#else
    rb_notimplement();
#endif
}

/*
 *  call-seq:
 *     dir.pos( integer ) =&gt; integer
 *
 *  Synonym for &lt;code&gt;Dir#seek&lt;/code&gt;, but returns the position
 *  parameter.
 *
 *     d = Dir.new(&quot;testdir&quot;)   #=&gt; #&lt;Dir:0x401b3c40&gt;
 *     d.read                   #=&gt; &quot;.&quot;
 *     i = d.pos                #=&gt; 12
 *     d.read                   #=&gt; &quot;..&quot;
 *     d.pos = i                #=&gt; 12
 *     d.read                   #=&gt; &quot;..&quot;
 */
static VALUE
dir_set_pos(dir, pos)
    VALUE dir, pos;
{
    dir_seek(dir, pos);
    return pos;
}

/*
 *  call-seq:
 *     dir.rewind =&gt; dir
 *
 *  Repositions &lt;em&gt;dir&lt;/em&gt; to the first entry.
 *
 *     d = Dir.new(&quot;testdir&quot;)
 *     d.read     #=&gt; &quot;.&quot;
 *     d.rewind   #=&gt; #&lt;Dir:0x401b3fb0&gt;
 *     d.read     #=&gt; &quot;.&quot;
 */
static VALUE
dir_rewind(dir)
    VALUE dir;
{
    struct dir_data *dirp;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(dir)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't close&quot;);
    }
    GetDIR(dir, dirp);
    rewinddir(dirp-&gt;dir);
    return dir;
}

/*
 *  call-seq:
 *     dir.close =&gt; nil
 *
 *  Closes the directory stream. Any further attempts to access
 *  &lt;em&gt;dir&lt;/em&gt; will raise an &lt;code&gt;IOError&lt;/code&gt;.
 *
 *     d = Dir.new(&quot;testdir&quot;)
 *     d.close   #=&gt; nil
 */
static VALUE
dir_close(dir)
    VALUE dir;
{
    struct dir_data *dirp;

    GetDIR(dir, dirp);
    closedir(dirp-&gt;dir);
    dirp-&gt;dir = NULL;

    return Qnil;
}

static void
dir_chdir(path)
    VALUE path;
{
    if (chdir(RSTRING(path)-&gt;ptr) &lt; 0)
	rb_sys_fail(RSTRING(path)-&gt;ptr);
}

static int chdir_blocking = 0;
static VALUE chdir_thread = Qnil;

struct chdir_data {
    VALUE old_path, new_path;
    int done;
};

static VALUE
chdir_yield(args)
    struct chdir_data *args;
{
    dir_chdir(args-&gt;new_path);
    args-&gt;done = Qtrue;
    chdir_blocking++;
    if (chdir_thread == Qnil)
	chdir_thread = rb_thread_current();
    return rb_yield(args-&gt;new_path);
}

static VALUE
chdir_restore(args)
    struct chdir_data *args;
{
    if (args-&gt;done) {
	chdir_blocking--;
	if (chdir_blocking == 0)
	    chdir_thread = Qnil;
	dir_chdir(args-&gt;old_path);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     Dir.chdir( [ string] ) =&gt; 0
 *     Dir.chdir( [ string] ) {| path | block }  =&gt; anObject
 *
 *  Changes the current working directory of the process to the given
 *  string. When called without an argument, changes the directory to
 *  the value of the environment variable &lt;code&gt;HOME&lt;/code&gt;, or
 *  &lt;code&gt;LOGDIR&lt;/code&gt;. &lt;code&gt;SystemCallError&lt;/code&gt; (probably
 *  &lt;code&gt;Errno::ENOENT&lt;/code&gt;) if the target directory does not exist.
 *
 *  If a block is given, it is passed the name of the new current
 *  directory, and the block is executed with that as the current
 *  directory. The original working directory is restored when the block
 *  exits. The return value of &lt;code&gt;chdir&lt;/code&gt; is the value of the
 *  block. &lt;code&gt;chdir&lt;/code&gt; blocks can be nested, but in a
 *  multi-threaded program an error will be raised if a thread attempts
 *  to open a &lt;code&gt;chdir&lt;/code&gt; block while another thread has one
 *  open.
 *
 *     Dir.chdir(&quot;/var/spool/mail&quot;)
 *     puts Dir.pwd
 *     Dir.chdir(&quot;/tmp&quot;) do
 *       puts Dir.pwd
 *       Dir.chdir(&quot;/usr&quot;) do
 *         puts Dir.pwd
 *       end
 *       puts Dir.pwd
 *     end
 *     puts Dir.pwd
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     /var/spool/mail
 *     /tmp
 *     /usr
 *     /tmp
 *     /var/spool/mail
 */
static VALUE
dir_s_chdir(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE path = Qnil;

    rb_secure(2);
    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;path) == 1) {
	SafeStringValue(path);
    }
    else {
	const char *dist = getenv(&quot;HOME&quot;);
	if (!dist) {
	    dist = getenv(&quot;LOGDIR&quot;);
	    if (!dist) rb_raise(rb_eArgError, &quot;HOME/LOGDIR not set&quot;);
	}
	path = rb_str_new2(dist);
    }

    if (chdir_blocking &gt; 0) {
	if (!rb_block_given_p() || rb_thread_current() != chdir_thread)
	    rb_warn(&quot;conflicting chdir during another chdir block&quot;);
    }

    if (rb_block_given_p()) {
	struct chdir_data args;
	char *cwd = my_getcwd();

	args.old_path = rb_tainted_str_new2(cwd); free(cwd);
	args.new_path = path;
	args.done = Qfalse;
	return rb_ensure(chdir_yield, (VALUE)&amp;args, chdir_restore, (VALUE)&amp;args);
    }
    dir_chdir(path);

    return INT2FIX(0);
}

/*
 *  call-seq:
 *     Dir.getwd =&gt; string
 *     Dir.pwd =&gt; string
 *
 *  Returns the path to the current working directory of this process as
 *  a string.
 *
 *     Dir.chdir(&quot;/tmp&quot;)   #=&gt; 0
 *     Dir.getwd           #=&gt; &quot;/tmp&quot;
 */
static VALUE
dir_s_getwd(dir)
    VALUE dir;
{
    char *path;
    VALUE cwd;

    rb_secure(4);
    path = my_getcwd();
    cwd = rb_tainted_str_new2(path);

    free(path);
    return cwd;
}

static void check_dirname _((volatile VALUE *));
static void
check_dirname(dir)
    volatile VALUE *dir;
{
    char *path, *pend;

    SafeStringValue(*dir);
    rb_secure(2);
    path = RSTRING(*dir)-&gt;ptr;
    if (path &amp;&amp; *(pend = rb_path_end(rb_path_skip_prefix(path)))) {
	*dir = rb_str_new(path, pend - path);
    }
}

/*
 *  call-seq:
 *     Dir.chroot( string ) =&gt; 0
 *
 *  Changes this process's idea of the file system root. Only a
 *  privileged process may make this call. Not available on all
 *  platforms. On Unix systems, see &lt;code&gt;chroot(2)&lt;/code&gt; for more
 *  information.
 */
static VALUE
dir_s_chroot(dir, path)
    VALUE dir, path;
{
#if defined(HAVE_CHROOT) &amp;&amp; !defined(__CHECKER__)
    check_dirname(&amp;path);

    if (chroot(RSTRING(path)-&gt;ptr) == -1)
	rb_sys_fail(RSTRING(path)-&gt;ptr);

    return INT2FIX(0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

/*
 *  call-seq:
 *     Dir.mkdir( string [, integer] ) =&gt; 0
 *
 *  Makes a new directory named by &lt;i&gt;string&lt;/i&gt;, with permissions
 *  specified by the optional parameter &lt;i&gt;anInteger&lt;/i&gt;. The
 *  permissions may be modified by the value of
 *  &lt;code&gt;File::umask&lt;/code&gt;, and are ignored on NT. Raises a
 *  &lt;code&gt;SystemCallError&lt;/code&gt; if the directory cannot be created. See
 *  also the discussion of permissions in the class documentation for
 *  &lt;code&gt;File&lt;/code&gt;.
 *
 */
static VALUE
dir_s_mkdir(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE path, vmode;
    int mode;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;path, &amp;vmode) == 2) {
	mode = NUM2INT(vmode);
    }
    else {
	mode = 0777;
    }

    check_dirname(&amp;path);
    if (mkdir(RSTRING(path)-&gt;ptr, mode) == -1)
	rb_sys_fail(RSTRING(path)-&gt;ptr);

    return INT2FIX(0);
}

/*
 *  call-seq:
 *     Dir.delete( string ) =&gt; 0
 *     Dir.rmdir( string ) =&gt; 0
 *     Dir.unlink( string ) =&gt; 0
 *
 *  Deletes the named directory. Raises a subclass of
 *  &lt;code&gt;SystemCallError&lt;/code&gt; if the directory isn't empty.
 */
static VALUE
dir_s_rmdir(obj, dir)
    VALUE obj, dir;
{
    check_dirname(&amp;dir);
    if (rmdir(RSTRING(dir)-&gt;ptr) &lt; 0)
	rb_sys_fail(RSTRING(dir)-&gt;ptr);

    return INT2FIX(0);
}

static void
sys_warning_1(mesg)
    const char* mesg;
{
    rb_sys_warning(&quot;%s&quot;, mesg);
}

#define GLOB_VERBOSE	(1UL &lt;&lt; (sizeof(int) * CHAR_BIT - 1))
#define sys_warning(val) \
    (void)((flags &amp; GLOB_VERBOSE) &amp;&amp; rb_protect((VALUE (*)_((VALUE)))sys_warning_1, (VALUE)(val), 0))

#define GLOB_ALLOC(type) (type *)malloc(sizeof(type))
#define GLOB_ALLOC_N(type, n) (type *)malloc(sizeof(type) * (n))
#define GLOB_JUMP_TAG(status) ((status == -1) ? rb_memerror() : rb_jump_tag(status))

/*
 * ENOTDIR can be returned by stat(2) if a non-leaf element of the path
 * is not a directory.
 */
#define to_be_ignored(e) ((e) == ENOENT || (e) == ENOTDIR)

/* System call with warning */
static int
do_stat(const char *path, struct stat *pst, int flags)

{
    int ret = stat(path, pst);
    if (ret &lt; 0 &amp;&amp; !to_be_ignored(errno))
	sys_warning(path);

    return ret;
}

static int
do_lstat(const char *path, struct stat *pst, int flags)
{
    int ret = lstat(path, pst);
    if (ret &lt; 0 &amp;&amp; !to_be_ignored(errno))
	sys_warning(path);

    return ret;
}

static DIR *
do_opendir(const char *path, int flags)
{
    DIR *dirp = opendir(path);
    if (dirp == NULL &amp;&amp; !to_be_ignored(errno))
	sys_warning(path);

    return dirp;
}

/* Return nonzero if S has any special globbing chars in it.  */
static int
has_magic(s, flags)
    const char *s;
    int flags;
{
    const int escape = !(flags &amp; FNM_NOESCAPE);
    const int nocase = flags &amp; FNM_CASEFOLD;

    register const char *p = s;
    register char c;

    while ((c = *p++) != 0) {
	switch (c) {
	  case '*':
	  case '?':
	  case '[':
	    return 1;

	  case '\\':
	    if (escape &amp;&amp; !(c = *p++))
		return 0;
	    continue;

	  default:
	    if (!FNM_SYSCASE &amp;&amp; ISALPHA(c) &amp;&amp; nocase)
		return 1;
	}

	p = Next(p-1);
    }

    return 0;
}

/* Find separator in globbing pattern. */
static char *
find_dirsep(const char *s, int flags)
{
    const int escape = !(flags &amp; FNM_NOESCAPE);

    register const char *p = s;
    register char c;
    int open = 0;

    while ((c = *p++) != 0) {
	switch (c) {
	  case '[':
	    open = 1;
	    continue;
	  case ']':
	    open = 0;
	    continue;

	  case '/':
	    if (!open)
		return (char *)p-1;
	    continue;

	  case '\\':
	    if (escape &amp;&amp; !(c = *p++))
		return (char *)p-1;
	    continue;
	}

	p = Next(p-1);
    }

    return (char *)p-1;
}

/* Remove escaping backslashes */
static void
remove_backslashes(p)
    char *p;
{
    char *t = p;
    char *s = p;

    while (*p) {
	if (*p == '\\') {
	    if (t != s)
		memmove(t, s, p - s);
	    t += p - s;
	    s = ++p;
	    if (!*p) break;
	}
	Inc(p);
    }

    while (*p++);

    if (t != s)
	memmove(t, s, p - s); /* move '\0' too */
}

/* Globing pattern */
enum glob_pattern_type { PLAIN, MAGICAL, RECURSIVE, MATCH_ALL, MATCH_DIR };

struct glob_pattern {
    char *str;
    enum glob_pattern_type type;
    struct glob_pattern *next;
};

static void glob_free_pattern(struct glob_pattern *list);

static struct glob_pattern *
glob_make_pattern(const char *p, int flags)
{
    struct glob_pattern *list, *tmp, **tail = &amp;list;
    int dirsep = 0; /* pattern is terminated with '/' */

    while (*p) {
	tmp = GLOB_ALLOC(struct glob_pattern);
	if (!tmp) goto error;
	if (p[0] == '*' &amp;&amp; p[1] == '*' &amp;&amp; p[2] == '/') {
	    /* fold continuous RECURSIVEs (needed in glob_helper) */
	    do { p += 3; } while (p[0] == '*' &amp;&amp; p[1] == '*' &amp;&amp; p[2] == '/');
	    tmp-&gt;type = RECURSIVE;
	    tmp-&gt;str = 0;
	    dirsep = 1;
	}
	else {
	    const char *m = find_dirsep(p, flags);
	    char *buf = GLOB_ALLOC_N(char, m-p+1);
	    if (!buf) {
		free(tmp);
		goto error;
	    }
	    memcpy(buf, p, m-p);
	    buf[m-p] = '\0';
	    tmp-&gt;type = has_magic(buf, flags) ? MAGICAL : PLAIN;
	    tmp-&gt;str = buf;
	    if (*m) {
		dirsep = 1;
		p = m + 1;
	    }
	    else {
		dirsep = 0;
		p = m;
	    }
	}
	*tail = tmp;
	tail = &amp;tmp-&gt;next;
    }

    tmp = GLOB_ALLOC(struct glob_pattern);
    if (!tmp) {
      error:
	*tail = 0;
	glob_free_pattern(list);
	return 0;
    }
    tmp-&gt;type = dirsep ? MATCH_DIR : MATCH_ALL;
    tmp-&gt;str = 0;
    *tail = tmp;
    tmp-&gt;next = 0;

    return list;
}

static void
glob_free_pattern(struct glob_pattern *list)
{
    while (list) {
	struct glob_pattern *tmp = list;
	list = list-&gt;next;
	if (tmp-&gt;str)
	    free(tmp-&gt;str);
	free(tmp);
    }
}

static char *
join_path(const char *path, int dirsep, const char *name)
{
    long len = strlen(path);
    char *buf = GLOB_ALLOC_N(char, len+strlen(name)+(dirsep?1:0)+1);

    if (!buf) return 0;
    memcpy(buf, path, len);
    if (dirsep) {
	strcpy(buf+len, &quot;/&quot;);
	len++;
    }
    strcpy(buf+len, name);
    return buf;
}

enum answer { YES, NO, UNKNOWN };

#ifndef S_ISLNK
#  ifndef S_IFLNK
#    define S_ISLNK(m) (0)
#  else
#    define S_ISLNK(m) ((m &amp; S_IFMT) == S_IFLNK)
#  endif
#endif

#ifndef S_ISDIR
#   define S_ISDIR(m) ((m &amp; S_IFMT) == S_IFDIR)
#endif

struct glob_args {
    void (*func) _((const char*, VALUE));
    const char *c;
    VALUE v;
};

static VALUE glob_func_caller _((VALUE));

static VALUE
glob_func_caller(val)
    VALUE val;
{
    struct glob_args *args = (struct glob_args *)val;

    (*args-&gt;func)(args-&gt;c, args-&gt;v);
    return Qnil;
}

#define glob_call_func(func, path, arg) (*func)(path, arg)

static int glob_helper _((const char *, int, enum answer, enum answer, struct glob_pattern **, struct glob_pattern **, int, ruby_glob_func *, VALUE));

static int
glob_helper(path, dirsep, exist, isdir, beg, end, flags, func, arg)
    const char *path;
    int dirsep; /* '/' should be placed before appending child entry's name to 'path'. */
    enum answer exist; /* Does 'path' indicate an existing entry? */
    enum answer isdir; /* Does 'path' indicate a directory or a symlink to a directory? */
    struct glob_pattern **beg;
    struct glob_pattern **end;
    int flags;
    ruby_glob_func *func;
    VALUE arg;
{
    struct stat st;
    int status = 0;
    struct glob_pattern **cur, **new_beg, **new_end;
    int plain = 0, magical = 0, recursive = 0, match_all = 0, match_dir = 0;
    int escape = !(flags &amp; FNM_NOESCAPE);

    for (cur = beg; cur &lt; end; ++cur) {
	struct glob_pattern *p = *cur;
	if (p-&gt;type == RECURSIVE) {
	    recursive = 1;
	    p = p-&gt;next;
	}
	switch (p-&gt;type) {
	case PLAIN:
	    plain = 1;
	    break;
	case MAGICAL:
	    magical = 1;
	    break;
	case MATCH_ALL:
	    match_all = 1;
	    break;
	case MATCH_DIR:
	    match_dir = 1;
	    break;
	case RECURSIVE:
	    rb_bug(&quot;continuous RECURSIVEs&quot;);
	}
    }

    if (*path) {
	if (match_all &amp;&amp; exist == UNKNOWN) {
	    if (do_lstat(path, &amp;st, flags) == 0) {
		exist = YES;
		isdir = S_ISDIR(st.st_mode) ? YES : S_ISLNK(st.st_mode) ? UNKNOWN : NO;
	    }
	    else {
		exist = NO;
		isdir = NO;
	    }
	}
	if (match_dir &amp;&amp; isdir == UNKNOWN) {
	    if (do_stat(path, &amp;st, flags) == 0) {
		exist = YES;
		isdir = S_ISDIR(st.st_mode) ? YES : NO;
	    }
	    else {
		exist = NO;
		isdir = NO;
	    }
	}
	if (match_all &amp;&amp; exist == YES) {
	    status = glob_call_func(func, path, arg);
	    if (status) return status;
	}
	if (match_dir &amp;&amp; isdir == YES) {
	    char *tmp = join_path(path, dirsep, &quot;&quot;);
	    if (!tmp) return -1;
	    status = glob_call_func(func, tmp, arg);
	    free(tmp);
	    if (status) return status;
	}
    }

    if (exist == NO || isdir == NO) return 0;

    if (magical || recursive) {
	struct dirent *dp;
	DIR *dirp = do_opendir(*path ? path : &quot;.&quot;, flags);
	if (dirp == NULL) return 0;

	for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
	    char *buf = join_path(path, dirsep, dp-&gt;d_name);
	    enum answer new_isdir = UNKNOWN;

	    if (!buf) {
		status = -1;
		break;
	    }
	    if (recursive &amp;&amp; strcmp(dp-&gt;d_name, &quot;.&quot;) != 0 &amp;&amp; strcmp(dp-&gt;d_name, &quot;..&quot;) != 0
		&amp;&amp; fnmatch(&quot;*&quot;, dp-&gt;d_name, flags) == 0) {
#ifndef _WIN32
		if (do_lstat(buf, &amp;st, flags) == 0)
		    new_isdir = S_ISDIR(st.st_mode) ? YES : S_ISLNK(st.st_mode) ? UNKNOWN : NO;
		else
		    new_isdir = NO;
#else
		new_isdir = dp-&gt;d_isdir ? (!dp-&gt;d_isrep ? YES : UNKNOWN) : NO;
#endif
	    }

	    new_beg = new_end = GLOB_ALLOC_N(struct glob_pattern *, (end - beg) * 2);
	    if (!new_beg) {
		status = -1;
		break;
	    }

	    for (cur = beg; cur &lt; end; ++cur) {
		struct glob_pattern *p = *cur;
		if (p-&gt;type == RECURSIVE) {
		    if (new_isdir == YES) /* not symlink but real directory */
			*new_end++ = p; /* append recursive pattern */
		    p = p-&gt;next; /* 0 times recursion */
		}
		if (p-&gt;type == PLAIN || p-&gt;type == MAGICAL) {
		    if (fnmatch(p-&gt;str, dp-&gt;d_name, flags) == 0)
			*new_end++ = p-&gt;next;
		}
	    }

	    status = glob_helper(buf, 1, YES, new_isdir, new_beg, new_end, flags, func, arg);
	    free(buf);
	    free(new_beg);
	    if (status) break;
	}

	closedir(dirp);
    }
    else if (plain) {
	struct glob_pattern **copy_beg, **copy_end, **cur2;

	copy_beg = copy_end = GLOB_ALLOC_N(struct glob_pattern *, end - beg);
	if (!copy_beg) return -1;
	for (cur = beg; cur &lt; end; ++cur)
	    *copy_end++ = (*cur)-&gt;type == PLAIN ? *cur : 0;

	for (cur = copy_beg; cur &lt; copy_end; ++cur) {
	    if (*cur) {
		char *buf;
		char *name;
		name = GLOB_ALLOC_N(char, strlen((*cur)-&gt;str) + 1);
		if (!name) {
		    status = -1;
		    break;
		}
		strcpy(name, (*cur)-&gt;str);
		if (escape) remove_backslashes(name);

		new_beg = new_end = GLOB_ALLOC_N(struct glob_pattern *, end - beg);
		if (!new_beg) {
		    free(name);
		    status = -1;
		    break;
		}
		*new_end++ = (*cur)-&gt;next;
		for (cur2 = cur + 1; cur2 &lt; copy_end; ++cur2) {
		    if (*cur2 &amp;&amp; fnmatch((*cur2)-&gt;str, name, flags) == 0) {
			*new_end++ = (*cur2)-&gt;next;
			*cur2 = 0;
		    }
		}

		buf = join_path(path, dirsep, name);
		free(name);
		if (!buf) {
		    free(new_beg);
		    status = -1;
		    break;
		}
		status = glob_helper(buf, 1, UNKNOWN, UNKNOWN, new_beg, new_end, flags, func, arg);
		free(buf);
		free(new_beg);
		if (status) break;
	    }
	}

	free(copy_beg);
    }

    return status;
}

static int
ruby_glob0(path, flags, func, arg)
    const char *path;
    int flags;
    ruby_glob_func *func;
    VALUE arg;
{
    struct glob_pattern *list;
    const char *root, *start;
    char *buf;
    int n;
    int status;

    start = root = path;
    flags |= FNM_SYSCASE;
#if defined DOSISH
    root = rb_path_skip_prefix(root);
#endif

    if (root &amp;&amp; *root == '/') root++;

    n = root - start;
    buf = GLOB_ALLOC_N(char, n + 1);
    if (!buf) return -1;
    MEMCPY(buf, start, char, n);
    buf[n] = '\0';

    list = glob_make_pattern(root, flags);
    if (!list) {
	free(buf);
	return -1;
    }
    status = glob_helper(buf, 0, UNKNOWN, UNKNOWN, &amp;list, &amp;list + 1, flags, func, arg);
    glob_free_pattern(list);
    free(buf);

    return status;
}

int
ruby_glob(path, flags, func, arg)
    const char *path;
    int flags;
    ruby_glob_func *func;
    VALUE arg;
{
    return ruby_glob0(path, flags &amp; ~GLOB_VERBOSE, func, arg);
}

static int rb_glob_caller _((const char *, VALUE));

static int
rb_glob_caller(path, a)
    const char *path;
    VALUE a;
{
    int status;
    struct glob_args *args = (struct glob_args *)a;

    args-&gt;c = path;
    rb_protect(glob_func_caller, a, &amp;status);
    return status;
}

static int
rb_glob2(path, flags, func, arg)
    const char *path;
    int flags;
    void (*func) _((const char *, VALUE));
    VALUE arg;
{
    struct glob_args args;

    args.func = func;
    args.v = arg;

    if (flags &amp; FNM_SYSCASE) {
	rb_warning(&quot;Dir.glob() ignores File::FNM_CASEFOLD&quot;);
    }

    return ruby_glob0(path, flags | GLOB_VERBOSE, rb_glob_caller, (VALUE)&amp;args);
}

void
rb_glob(path, func, arg)
    const char *path;
    void (*func) _((const char*, VALUE));
    VALUE arg;
{
    int status = rb_glob2(path, 0, func, arg);
    if (status) GLOB_JUMP_TAG(status);
}

static void push_pattern _((const char* path, VALUE ary));
static void
push_pattern(path, ary)
    const char *path;
    VALUE ary;
{
    rb_ary_push(ary, rb_tainted_str_new2(path));
}

int
ruby_brace_expand(str, flags, func, arg)
    const char *str;
    int flags;
    ruby_glob_func *func;
    VALUE arg;
{
    const int escape = !(flags &amp; FNM_NOESCAPE);
    const char *p = str;
    const char *s = p;
    const char *lbrace = 0, *rbrace = 0;
    int nest = 0, status = 0;

    while (*p) {
	if (*p == '{' &amp;&amp; nest++ == 0) {
	    lbrace = p;
	}
	if (*p == '}' &amp;&amp; --nest &lt;= 0) {
	    rbrace = p;
	    break;
	}
	if (*p == '\\' &amp;&amp; escape) {
	    if (!*++p) break;
	}
	Inc(p);
    }

    if (lbrace &amp;&amp; rbrace) {
	char *buf = GLOB_ALLOC_N(char, strlen(s) + 1);
	long shift;

	if (!buf) return -1;
	memcpy(buf, s, lbrace-s);
	shift = (lbrace-s);
	p = lbrace;
	while (p &lt; rbrace) {
	    const char *t = ++p;
	    nest = 0;
	    while (p &lt; rbrace &amp;&amp; !(*p == ',' &amp;&amp; nest == 0)) {
		if (*p == '{') nest++;
		if (*p == '}') nest--;
		if (*p == '\\' &amp;&amp; escape) {
		    if (++p == rbrace) break;
		}
		Inc(p);
	    }
	    memcpy(buf+shift, t, p-t);
	    strcpy(buf+shift+(p-t), rbrace+1);
	    status = ruby_brace_expand(buf, flags, func, arg);
	    if (status) break;
	}
	free(buf);
    }
    else if (!lbrace &amp;&amp; !rbrace) {
	status = (*func)(s, arg);
    }

    return status;
}

struct brace_args {
    ruby_glob_func *func;
    VALUE value;
    int flags;
};

static int glob_brace _((const char *, VALUE));
static int
glob_brace(path, val)
    const char *path;
    VALUE val;
{
    struct brace_args *arg = (struct brace_args *)val;

    return ruby_glob0(path, arg-&gt;flags, arg-&gt;func, arg-&gt;value);
}

static int
ruby_brace_glob0(str, flags, func, arg)
    const char *str;
    int flags;
    ruby_glob_func *func;
    VALUE arg;
{
    struct brace_args args;

    args.func = func;
    args.value = arg;
    args.flags = flags;
    return ruby_brace_expand(str, flags, glob_brace, (VALUE)&amp;args);
}

int
ruby_brace_glob(str, flags, func, arg)
    const char *str;
    int flags;
    ruby_glob_func *func;
    VALUE arg;
{
    return ruby_brace_glob0(str, flags &amp; ~GLOB_VERBOSE, func, arg);
}

static int
push_glob(VALUE ary, const char *str, int flags)
{
    struct glob_args args;

    args.func = push_pattern;
    args.v = ary;
    return ruby_brace_glob0(str, flags | GLOB_VERBOSE, rb_glob_caller, (VALUE)&amp;args);
}

static VALUE
rb_push_glob(str, flags) /* '\0' is delimiter */
    VALUE str;
    int flags;
{
    long offset = 0;
    VALUE ary;

    ary = rb_ary_new();
    SafeStringValue(str);

    while (offset &lt; RSTRING_LEN(str)) {
	int status = push_glob(ary, RSTRING(str)-&gt;ptr + offset, flags);
	char *p, *pend;
	if (status) GLOB_JUMP_TAG(status);
	if (offset &gt;= RSTRING_LEN(str)) break;
	p = RSTRING(str)-&gt;ptr + offset;
	p += strlen(p) + 1;
	pend = RSTRING(str)-&gt;ptr + RSTRING_LEN(str);
	while (p &lt; pend &amp;&amp; !*p)
	    p++;
	offset = p - RSTRING(str)-&gt;ptr;
    }

    return ary;
}

static VALUE
dir_globs(argc, argv, flags)
    long argc;
    VALUE *argv;
    int flags;
{
    VALUE ary = rb_ary_new();
    long i;

    for (i = 0; i &lt; argc; ++i) {
	int status;
	VALUE str = argv[i];
	StringValue(str);
	status = push_glob(ary, RSTRING(str)-&gt;ptr, flags);
	if (status) GLOB_JUMP_TAG(status);
    }

    return ary;
}

/*
 *  call-seq:
 *     Dir[ array ]                 =&gt; array
 *     Dir[ string [, string ...] ] =&gt; array
 *
 *  Equivalent to calling
 *  &lt;code&gt;Dir.glob(&lt;/code&gt;&lt;i&gt;array,&lt;/i&gt;&lt;code&gt;0)&lt;/code&gt; and 
 *  &lt;code&gt;Dir.glob([&lt;/code&gt;&lt;i&gt;string,...&lt;/i&gt;&lt;code&gt;],0)&lt;/code&gt;.
 *
 */
static VALUE
dir_s_aref(int argc, VALUE *argv, VALUE obj)
 {
    if (argc == 1) {
	return rb_push_glob(argv[0], 0);
    }
    return dir_globs(argc, argv, 0);
 }

/*
 *  call-seq:
 *     Dir.glob( pattern, [flags] ) =&gt; array
 *     Dir.glob( pattern, [flags] ) {| filename | block }  =&gt; nil
 *
 *  Returns the filenames found by expanding &lt;i&gt;pattern&lt;/i&gt; which is
 *  an +Array+ of the patterns or the pattern +String+, either as an
 *  &lt;i&gt;array&lt;/i&gt; or as parameters to the block. Note that this pattern
 *  is not a regexp (it's closer to a shell glob). See
 *  &lt;code&gt;File::fnmatch&lt;/code&gt; for the meaning of the &lt;i&gt;flags&lt;/i&gt;
 *  parameter. Note that case sensitivity depends on your system (so
 *  &lt;code&gt;File::FNM_CASEFOLD&lt;/code&gt; is ignored)
 *
 *  &lt;code&gt;*&lt;/code&gt;::        Matches any file. Can be restricted by
 *                          other values in the glob. &lt;code&gt;*&lt;/code&gt;
 *                          will match all files; &lt;code&gt;c*&lt;/code&gt; will
 *                          match all files beginning with
 *                          &lt;code&gt;c&lt;/code&gt;; &lt;code&gt;*c&lt;/code&gt; will match
 *                          all files ending with &lt;code&gt;c&lt;/code&gt;; and
 *                          &lt;code&gt;*c*&lt;/code&gt; will match all files that
 *                          have &lt;code&gt;c&lt;/code&gt; in them (including at
 *                          the beginning or end). Equivalent to
 *                          &lt;code&gt;/ .* /x&lt;/code&gt; in regexp.
 *  &lt;code&gt;**&lt;/code&gt;::       Matches directories recursively.
 *  &lt;code&gt;?&lt;/code&gt;::        Matches any one character. Equivalent to
 *                          &lt;code&gt;/.{1}/&lt;/code&gt; in regexp.
 *  &lt;code&gt;[set]&lt;/code&gt;::    Matches any one character in +set+.
 *                          Behaves exactly like character sets in
 *                          Regexp, including set negation
 *                          (&lt;code&gt;[^a-z]&lt;/code&gt;).
 *  &lt;code&gt;{p,q}&lt;/code&gt;::    Matches either literal &lt;code&gt;p&lt;/code&gt; or
 *                          literal &lt;code&gt;q&lt;/code&gt;. Matching literals
 *                          may be more than one character in length.
 *                          More than two literals may be specified.
 *                          Equivalent to pattern alternation in
 *                          regexp.
 *  &lt;code&gt;\&lt;/code&gt;::        Escapes the next metacharacter.
 *
 *     Dir[&quot;config.?&quot;]                     #=&gt; [&quot;config.h&quot;]
 *     Dir.glob(&quot;config.?&quot;)                #=&gt; [&quot;config.h&quot;]
 *     Dir.glob(&quot;*.[a-z][a-z]&quot;)            #=&gt; [&quot;main.rb&quot;]
 *     Dir.glob(&quot;*.[^r]*&quot;)                 #=&gt; [&quot;config.h&quot;]
 *     Dir.glob(&quot;*.{rb,h}&quot;)                #=&gt; [&quot;main.rb&quot;, &quot;config.h&quot;]
 *     Dir.glob(&quot;*&quot;)                       #=&gt; [&quot;config.h&quot;, &quot;main.rb&quot;]
 *     Dir.glob(&quot;*&quot;, File::FNM_DOTMATCH)   #=&gt; [&quot;.&quot;, &quot;..&quot;, &quot;config.h&quot;, &quot;main.rb&quot;]
 *
 *     rbfiles = File.join(&quot;**&quot;, &quot;*.rb&quot;)
 *     Dir.glob(rbfiles)                   #=&gt; [&quot;main.rb&quot;,
 *                                              &quot;lib/song.rb&quot;,
 *                                              &quot;lib/song/karaoke.rb&quot;]
 *     libdirs = File.join(&quot;**&quot;, &quot;lib&quot;)
 *     Dir.glob(libdirs)                   #=&gt; [&quot;lib&quot;]
 *
 *     librbfiles = File.join(&quot;**&quot;, &quot;lib&quot;, &quot;**&quot;, &quot;*.rb&quot;)
 *     Dir.glob(librbfiles)                #=&gt; [&quot;lib/song.rb&quot;,
 *                                              &quot;lib/song/karaoke.rb&quot;]
 *
 *     librbfiles = File.join(&quot;**&quot;, &quot;lib&quot;, &quot;*.rb&quot;)
 *     Dir.glob(librbfiles)                #=&gt; [&quot;lib/song.rb&quot;]
 */
static VALUE
dir_s_glob(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE str, rflags, ary;
    int flags;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;rflags) == 2)
	flags = NUM2INT(rflags);
    else
	flags = 0;

    ary = rb_check_array_type(str);
    if (NIL_P(ary)) {
	ary = rb_push_glob(str, flags);
    }
    else {
	volatile VALUE v = ary;
	ary = dir_globs(RARRAY_LEN(v), RARRAY_PTR(v), flags);
    }

    if (rb_block_given_p()) {
	rb_ary_each(ary);
	return Qnil;
    }
    return ary;
}

static VALUE
dir_open_dir(path)
    VALUE path;
{
    VALUE dir = rb_funcall(rb_cDir, rb_intern(&quot;open&quot;), 1, path);

    if (TYPE(dir) != T_DATA ||
	RDATA(dir)-&gt;dfree != (RUBY_DATA_FUNC)free_dir) {
	rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Dir)&quot;,
		 rb_obj_classname(dir));
    }
    return dir;
}


/*
 *  call-seq:
 *     Dir.foreach( dirname ) {| filename | block }  =&gt; nil
 *
 *  Calls the block once for each entry in the named directory, passing
 *  the filename of each entry as a parameter to the block.
 *
 *     Dir.foreach(&quot;testdir&quot;) {|x| puts &quot;Got #{x}&quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     Got .
 *     Got ..
 *     Got config.h
 *     Got main.rb
 *
 */
static VALUE
dir_foreach(io, dirname)
    VALUE io, dirname;
{
    VALUE dir;

    RETURN_ENUMERATOR(io, 1, &amp;dirname);
    dir = dir_open_dir(dirname);
    rb_ensure(dir_each, dir, dir_close, dir);
    return Qnil;
}

/*
 *  call-seq:
 *     Dir.entries( dirname ) =&gt; array
 *
 *  Returns an array containing all of the filenames in the given
 *  directory. Will raise a &lt;code&gt;SystemCallError&lt;/code&gt; if the named
 *  directory doesn't exist.
 *
 *     Dir.entries(&quot;testdir&quot;)   #=&gt; [&quot;.&quot;, &quot;..&quot;, &quot;config.h&quot;, &quot;main.rb&quot;]
 *
 */
static VALUE
dir_entries(io, dirname)
    VALUE io, dirname;
{
    VALUE dir;

    dir = dir_open_dir(dirname);
    return rb_ensure(rb_Array, dir, dir_close, dir);
}

/*
 *  call-seq:
 *     File.fnmatch( pattern, path, [flags] ) =&gt; (true or false)
 *     File.fnmatch?( pattern, path, [flags] ) =&gt; (true or false)
 *
 *  Returns true if &lt;i&gt;path&lt;/i&gt; matches against &lt;i&gt;pattern&lt;/i&gt; The
 *  pattern is not a regular expression; instead it follows rules
 *  similar to shell filename globbing. It may contain the following
 *  metacharacters:
 *
 *  &lt;code&gt;*&lt;/code&gt;::        Matches any file. Can be restricted by
 *                          other values in the glob. &lt;code&gt;*&lt;/code&gt;
 *                          will match all files; &lt;code&gt;c*&lt;/code&gt; will
 *                          match all files beginning with
 *                          &lt;code&gt;c&lt;/code&gt;; &lt;code&gt;*c&lt;/code&gt; will match
 *                          all files ending with &lt;code&gt;c&lt;/code&gt;; and
 *                          &lt;code&gt;*c*&lt;/code&gt; will match all files that
 *                          have &lt;code&gt;c&lt;/code&gt; in them (including at
 *                          the beginning or end). Equivalent to
 *                          &lt;code&gt;/ .* /x&lt;/code&gt; in regexp.
 *  &lt;code&gt;**&lt;/code&gt;::       Matches directories recursively or files
 *                          expansively.
 *  &lt;code&gt;?&lt;/code&gt;::        Matches any one character. Equivalent to
 *                          &lt;code&gt;/.{1}/&lt;/code&gt; in regexp.
 *  &lt;code&gt;[set]&lt;/code&gt;::    Matches any one character in +set+.
 *                          Behaves exactly like character sets in
 *                          Regexp, including set negation
 *                          (&lt;code&gt;[^a-z]&lt;/code&gt;).
 *  &lt;code&gt;\&lt;/code&gt;::        Escapes the next metacharacter.
 *
 *  &lt;i&gt;flags&lt;/i&gt; is a bitwise OR of the &lt;code&gt;FNM_xxx&lt;/code&gt;
 *  parameters. The same glob pattern and flags are used by
 *  &lt;code&gt;Dir::glob&lt;/code&gt;.
 *
 *     File.fnmatch('cat',       'cat')        #=&gt; true  : match entire string
 *     File.fnmatch('cat',       'category')   #=&gt; false : only match partial string
 *     File.fnmatch('c{at,ub}s', 'cats')       #=&gt; false : { } isn't supported
 *
 *     File.fnmatch('c?t',     'cat')          #=&gt; true  : '?' match only 1 character
 *     File.fnmatch('c??t',    'cat')          #=&gt; false : ditto
 *     File.fnmatch('c*',      'cats')         #=&gt; true  : '*' match 0 or more characters
 *     File.fnmatch('c*t',     'c/a/b/t')      #=&gt; true  : ditto
 *     File.fnmatch('ca[a-z]', 'cat')          #=&gt; true  : inclusive bracket expression
 *     File.fnmatch('ca[^t]',  'cat')          #=&gt; false : exclusive bracket expression ('^' or '!')
 *
 *     File.fnmatch('cat', 'CAT')                     #=&gt; false : case sensitive
 *     File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=&gt; true  : case insensitive
 *
 *     File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=&gt; false : wildcard doesn't match '/' on FNM_PATHNAME
 *     File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=&gt; false : ditto
 *     File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=&gt; false : ditto
 *
 *     File.fnmatch('\?',   '?')                       #=&gt; true  : escaped wildcard becomes ordinary
 *     File.fnmatch('\a',   'a')                       #=&gt; true  : escaped ordinary remains ordinary
 *     File.fnmatch('\a',   '\a', File::FNM_NOESCAPE)  #=&gt; true  : FNM_NOESACPE makes '\' ordinary
 *     File.fnmatch('[\?]', '?')                       #=&gt; true  : can escape inside bracket expression
 *
 *     File.fnmatch('*',   '.profile')                      #=&gt; false : wildcard doesn't match leading
 *     File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=&gt; true    period by default.
 *     File.fnmatch('.*',  '.profile')                      #=&gt; true
 *
 *     rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.
 *     File.fnmatch(rbfiles, 'main.rb')                    #=&gt; false
 *     File.fnmatch(rbfiles, './main.rb')                  #=&gt; false
 *     File.fnmatch(rbfiles, 'lib/song.rb')                #=&gt; true
 *     File.fnmatch('**.rb', 'main.rb')                    #=&gt; true
 *     File.fnmatch('**.rb', './main.rb')                  #=&gt; false
 *     File.fnmatch('**.rb', 'lib/song.rb')                #=&gt; true
 *     File.fnmatch('*',           'dave/.profile')                      #=&gt; true
 *
 *     pattern = '*' '/' '*'
 *     File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=&gt; false
 *     File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=&gt; true
 *
 *     pattern = '**' '/' 'foo'
 *     File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=&gt; true
 *     File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=&gt; true
 *     File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=&gt; true
 *     File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=&gt; false
 *     File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=&gt; true
 */
static VALUE
file_s_fnmatch(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE pattern, path;
    VALUE rflags;
    int flags;

    if (rb_scan_args(argc, argv, &quot;21&quot;, &amp;pattern, &amp;path, &amp;rflags) == 3)
	flags = NUM2INT(rflags);
    else
	flags = 0;

    StringValue(pattern);
    StringValue(path);

    if (fnmatch(RSTRING(pattern)-&gt;ptr, RSTRING(path)-&gt;ptr, flags) == 0)
	return Qtrue;

    return Qfalse;
}

/*
 *  Objects of class &lt;code&gt;Dir&lt;/code&gt; are directory streams representing
 *  directories in the underlying file system. They provide a variety of
 *  ways to list directories and their contents. See also
 *  &lt;code&gt;File&lt;/code&gt;.
 *
 *  The directory used in these examples contains the two regular files
 *  (&lt;code&gt;config.h&lt;/code&gt; and &lt;code&gt;main.rb&lt;/code&gt;), the parent
 *  directory (&lt;code&gt;..&lt;/code&gt;), and the directory itself
 *  (&lt;code&gt;.&lt;/code&gt;).
 */
void
Init_Dir()
{
    rb_cDir = rb_define_class(&quot;Dir&quot;, rb_cObject);

    rb_include_module(rb_cDir, rb_mEnumerable);

    rb_define_alloc_func(rb_cDir, dir_s_alloc);
    rb_define_singleton_method(rb_cDir, &quot;open&quot;, dir_s_open, 1);
    rb_define_singleton_method(rb_cDir, &quot;foreach&quot;, dir_foreach, 1);
    rb_define_singleton_method(rb_cDir, &quot;entries&quot;, dir_entries, 1);

    rb_define_method(rb_cDir,&quot;initialize&quot;, dir_initialize, 1);
    rb_define_method(rb_cDir,&quot;path&quot;, dir_path, 0);
    rb_define_method(rb_cDir,&quot;inspect&quot;, dir_inspect, 0);
    rb_define_method(rb_cDir,&quot;read&quot;, dir_read, 0);
    rb_define_method(rb_cDir,&quot;each&quot;, dir_each, 0);
    rb_define_method(rb_cDir,&quot;rewind&quot;, dir_rewind, 0);
    rb_define_method(rb_cDir,&quot;tell&quot;, dir_tell, 0);
    rb_define_method(rb_cDir,&quot;seek&quot;, dir_seek, 1);
    rb_define_method(rb_cDir,&quot;pos&quot;, dir_tell, 0);
    rb_define_method(rb_cDir,&quot;pos=&quot;, dir_set_pos, 1);
    rb_define_method(rb_cDir,&quot;close&quot;, dir_close, 0);

    rb_define_singleton_method(rb_cDir,&quot;chdir&quot;, dir_s_chdir, -1);
    rb_define_singleton_method(rb_cDir,&quot;getwd&quot;, dir_s_getwd, 0);
    rb_define_singleton_method(rb_cDir,&quot;pwd&quot;, dir_s_getwd, 0);
    rb_define_singleton_method(rb_cDir,&quot;chroot&quot;, dir_s_chroot, 1);
    rb_define_singleton_method(rb_cDir,&quot;mkdir&quot;, dir_s_mkdir, -1);
    rb_define_singleton_method(rb_cDir,&quot;rmdir&quot;, dir_s_rmdir, 1);
    rb_define_singleton_method(rb_cDir,&quot;delete&quot;, dir_s_rmdir, 1);
    rb_define_singleton_method(rb_cDir,&quot;unlink&quot;, dir_s_rmdir, 1);

    rb_define_singleton_method(rb_cDir,&quot;glob&quot;, dir_s_glob, -1);
    rb_define_singleton_method(rb_cDir,&quot;[]&quot;, dir_s_aref, -1);

    rb_define_singleton_method(rb_cFile,&quot;fnmatch&quot;, file_s_fnmatch, -1);
    rb_define_singleton_method(rb_cFile,&quot;fnmatch?&quot;, file_s_fnmatch, -1);

    rb_file_const(&quot;FNM_NOESCAPE&quot;, INT2FIX(FNM_NOESCAPE));
    rb_file_const(&quot;FNM_PATHNAME&quot;, INT2FIX(FNM_PATHNAME));
    rb_file_const(&quot;FNM_DOTMATCH&quot;, INT2FIX(FNM_DOTMATCH));
    rb_file_const(&quot;FNM_CASEFOLD&quot;, INT2FIX(FNM_CASEFOLD));
    rb_file_const(&quot;FNM_SYSCASE&quot;, INT2FIX(FNM_SYSCASE));
}
</pre>
    </div>