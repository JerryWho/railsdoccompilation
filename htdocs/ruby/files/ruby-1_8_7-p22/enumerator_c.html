  <div id="fileHeader">
    <h1>enumerator.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/enumerator.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Jun 03 06:06:38 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/************************************************

  enumerator.c - provides Enumerator class

  $Author: knu $

  Copyright (C) 2001-2003 Akinori MUSHA

  $Idaemons: /home/cvs/rb/enumerator/enumerator.c,v 1.1.1.1 2001/07/15 10:12:48 knu Exp $
  $RoughId: enumerator.c,v 1.6 2003/07/27 11:03:24 nobu Exp $
  $Id: enumerator.c 16794 2008-06-03 11:06:38Z knu $

************************************************/

#include &quot;ruby.h&quot;

/*
 * Document-class: Enumerable::Enumerator
 *
 * A class which provides a method `each' to be used as an Enumerable
 * object.
 */
VALUE rb_cEnumerator;
static VALUE sym_each;

VALUE rb_eStopIteration;

struct enumerator {
    VALUE obj;
    ID    meth;
    VALUE proc;
    VALUE args;
    rb_block_call_func *iter;
};

static void enumerator_mark _((void *));
static void
enumerator_mark(p)
    void *p;
{
    struct enumerator *ptr = p;
    rb_gc_mark(ptr-&gt;obj);
    rb_gc_mark(ptr-&gt;args);
}

static struct enumerator *
enumerator_ptr(obj)
    VALUE obj;
{
    struct enumerator *ptr;

    Data_Get_Struct(obj, struct enumerator, ptr);
    if (RDATA(obj)-&gt;dmark != enumerator_mark) {
	rb_raise(rb_eTypeError,
		 &quot;wrong argument type %s (expected Enumerable::Enumerator)&quot;,
		 rb_obj_classname(obj));
    }
    if (!ptr || ptr-&gt;obj == Qundef) {
	rb_raise(rb_eArgError, &quot;uninitialized enumerator&quot;);
    }
    return ptr;
}

/*
 *  call-seq:
 *    obj.to_enum(method = :each, *args)
 *    obj.enum_for(method = :each, *args)
 *
 *  Returns Enumerable::Enumerator.new(self, method, *args).
 *
 *  e.g.:
 *
 *     str = &quot;xyz&quot;
 *
 *     enum = str.enum_for(:each_byte)
 *     a = enum.map {|b| '%02x' % b } #=&gt; [&quot;78&quot;, &quot;79&quot;, &quot;7a&quot;]
 *
 *     # protects an array from being modified
 *     a = [1, 2, 3]
 *     some_method(a.to_enum)
 *
 */
static VALUE
obj_to_enum(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE meth = sym_each;

    if (argc &gt; 0) {
	--argc;
	meth = *argv++;
    }
    return rb_enumeratorize(obj, meth, argc, argv);
}

static VALUE
each_slice_i(val, memo)
    VALUE val;
    VALUE *memo;
{
    VALUE ary = memo[0];
    VALUE v = Qnil;
    long size = (long)memo[1];

    rb_ary_push(ary, val);

    if (RARRAY_LEN(ary) == size) {
	v = rb_yield(ary);
	memo[0] = rb_ary_new2(size);
    }

    return v;
}

/*
 *  call-seq:
 *    e.each_slice(n) {...}
 *    e.each_slice(n)
 *
 *  Iterates the given block for each slice of &lt;n&gt; elements.  If no
 *  block is given, returns an enumerator.
 *
 *  e.g.:
 *      (1..10).each_slice(3) {|a| p a}
 *      # outputs below
 *      [1, 2, 3]
 *      [4, 5, 6]
 *      [7, 8, 9]
 *      [10]
 *
 */
static VALUE
enum_each_slice(obj, n)
    VALUE obj, n;
{
    long size = NUM2LONG(n);
    VALUE args[2], ary;

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid slice size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, SYM2ID(sym_each), 0, 0, each_slice_i, (VALUE)args);

    ary = args[0];
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return Qnil;
}

static VALUE
each_cons_i(val, memo)
    VALUE val;
    VALUE *memo;
{
    VALUE ary = memo[0];
    VALUE v = Qnil;
    long size = (long)memo[1];

    if (RARRAY_LEN(ary) == size) {
	rb_ary_shift(ary);
    }
    rb_ary_push(ary, val);
    if (RARRAY_LEN(ary) == size) {
	v = rb_yield(rb_ary_dup(ary));
    }
    return v;
}

/*
 *  call-seq:
 *    each_cons(n) {...}
 *    each_cons(n)
 *
 *  Iterates the given block for each array of consecutive &lt;n&gt;
 *  elements.  If no block is given, returns an enumerator.a
 *
 *  e.g.:
 *      (1..10).each_cons(3) {|a| p a}
 *      # outputs below
 *      [1, 2, 3]
 *      [2, 3, 4]
 *      [3, 4, 5]
 *      [4, 5, 6]
 *      [5, 6, 7]
 *      [6, 7, 8]
 *      [7, 8, 9]
 *      [8, 9, 10]
 *
 */
static VALUE
enum_each_cons(obj, n)
    VALUE obj, n;
{
    long size = NUM2LONG(n);
    VALUE args[2];

    if (size &lt;= 0) rb_raise(rb_eArgError, &quot;invalid size&quot;);
    RETURN_ENUMERATOR(obj, 1, &amp;n);
    args[0] = rb_ary_new2(size);
    args[1] = (VALUE)size;

    rb_block_call(obj, SYM2ID(sym_each), 0, 0, each_cons_i, (VALUE)args);

    return Qnil;
}

static VALUE enumerator_allocate _((VALUE));
static VALUE
enumerator_allocate(klass)
    VALUE klass;
{
    struct enumerator *ptr;
    VALUE enum_obj;

    enum_obj = Data_Make_Struct(klass, struct enumerator,
				enumerator_mark, -1, ptr);
    ptr-&gt;obj = Qundef;

    return enum_obj;
}

static VALUE enumerator_each_i _((VALUE, VALUE));
static VALUE
enumerator_each_i(v, enum_obj)
    VALUE v;
    VALUE enum_obj;
{
    return rb_yield(v);
}

static VALUE
enumerator_init(enum_obj, obj, meth, argc, argv)
    VALUE enum_obj;
    VALUE obj;
    VALUE meth;
    int argc;
    VALUE *argv;
{
    struct enumerator *ptr;

    Data_Get_Struct(enum_obj, struct enumerator, ptr);

    if (!ptr) {
	rb_raise(rb_eArgError, &quot;unallocated enumerator&quot;);
    }

    ptr-&gt;obj  = obj;
    ptr-&gt;meth = rb_to_id(meth);
    ptr-&gt;iter = enumerator_each_i;
    if (argc) ptr-&gt;args = rb_ary_new4(argc, argv);

    return enum_obj;
}

/*
 *  call-seq:
 *    Enumerable::Enumerator.new(obj, method = :each, *args)
 *
 *  Creates a new Enumerable::Enumerator object, which is to be
 *  used as an Enumerable object using the given object's given
 *  method with the given arguments.
 *
 *  Use of this method is discouraged.  Use Kernel#enum_for() instead.
 */
static VALUE
enumerator_initialize(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE recv, meth = sym_each;

    if (argc == 0)
	rb_raise(rb_eArgError, &quot;wrong number of argument (0 for 1)&quot;);
    recv = *argv++;
    if (--argc) {
	meth = *argv++;
	--argc;
    }
    return enumerator_init(obj, recv, meth, argc, argv);
}

/* :nodoc: */
static VALUE
enumerator_init_copy(obj, orig)
    VALUE obj;
    VALUE orig;
{
    struct enumerator *ptr0, *ptr1;

    ptr0 = enumerator_ptr(orig);

    Data_Get_Struct(obj, struct enumerator, ptr1);

    if (!ptr1) {
	rb_raise(rb_eArgError, &quot;unallocated enumerator&quot;);
    }

    ptr1-&gt;obj  = ptr0-&gt;obj;
    ptr1-&gt;meth = ptr0-&gt;meth;
    ptr1-&gt;iter = ptr0-&gt;iter;
    ptr1-&gt;args = ptr0-&gt;args;

    return obj;
}

VALUE
rb_enumeratorize(obj, meth, argc, argv)
    VALUE obj;
    VALUE meth;
    int argc;
    VALUE *argv;
{
    return enumerator_init(enumerator_allocate(rb_cEnumerator), obj, meth, argc, argv);
}

/*
 *  call-seq:
 *    enum.each {...}
 *
 *  Iterates the given block using the object and the method specified
 *  in the first place.  If no block is given, returns self.
 *
 */
static VALUE
enumerator_each(obj)
    VALUE obj;
{
    struct enumerator *e;
    int argc = 0;
    VALUE *argv = 0;

    if (!rb_block_given_p()) return obj;
    e = enumerator_ptr(obj);
    if (e-&gt;args) {
	argc = RARRAY_LEN(e-&gt;args);
	argv = RARRAY_PTR(e-&gt;args);
    }
    return rb_block_call(e-&gt;obj, e-&gt;meth, argc, argv, e-&gt;iter, (VALUE)e);
}

static VALUE
enumerator_with_index_i(val, memo)
    VALUE val;
    VALUE *memo;
{
    val = rb_yield_values(2, val, INT2FIX(*memo));
    ++*memo;
    return val;
}

/*
 *  call-seq:
 *    e.with_index {|(*args), idx| ... }
 *    e.with_index
 *
 *  Iterates the given block for each elements with an index, which
 *  start from 0.  If no block is given, returns an enumerator.
 *
 */
static VALUE
enumerator_with_index(obj)
    VALUE obj;
{
    struct enumerator *e = enumerator_ptr(obj);
    VALUE memo = 0;
    int argc = 0;
    VALUE *argv = 0;

    RETURN_ENUMERATOR(obj, 0, 0);
    if (e-&gt;args) {
	argc = RARRAY_LEN(e-&gt;args);
	argv = RARRAY_PTR(e-&gt;args);
    }
    return rb_block_call(e-&gt;obj, e-&gt;meth, argc, argv,
			 enumerator_with_index_i, (VALUE)&amp;memo);
}

/*
 * call-seq:
 *   e.next   =&gt; object
 *
 * Returns the next object in the enumerator, and move the internal
 * position forward.  When the position reached at the end, internal
 * position is rewinded then StopIteration is raised.
 *
 * Note that enumeration sequence by next method does not affect other
 * non-external enumeration methods, unless underlying iteration
 * methods itself has side-effect, e.g. IO#each_line.
 *
 * Caution: Calling this method causes the &quot;generator&quot; library to be
 * loaded.
 */

static VALUE
enumerator_next(obj)
    VALUE obj;
{
    rb_require(&quot;generator&quot;);
    return rb_funcall(obj, rb_intern(&quot;next&quot;), 0, 0);
}

/*
 * call-seq:
 *   e.rewind   =&gt; e
 *
 * Rewinds the enumeration sequence by the next method.
 */

static VALUE
enumerator_rewind(obj)
    VALUE obj;
{
    rb_require(&quot;generator&quot;);
    return rb_funcall(obj, rb_intern(&quot;rewind&quot;), 0, 0);
}

void
Init_Enumerator()
{
    rb_define_method(rb_mKernel, &quot;to_enum&quot;, obj_to_enum, -1);
    rb_define_method(rb_mKernel, &quot;enum_for&quot;, obj_to_enum, -1);

    rb_define_method(rb_mEnumerable, &quot;each_slice&quot;, enum_each_slice, 1);
    rb_define_method(rb_mEnumerable, &quot;enum_slice&quot;, enum_each_slice, 1);
    rb_define_method(rb_mEnumerable, &quot;each_cons&quot;, enum_each_cons, 1);
    rb_define_method(rb_mEnumerable, &quot;enum_cons&quot;, enum_each_cons, 1);

    rb_cEnumerator = rb_define_class_under(rb_mEnumerable, &quot;Enumerator&quot;, rb_cObject);
    rb_include_module(rb_cEnumerator, rb_mEnumerable);

    rb_define_alloc_func(rb_cEnumerator, enumerator_allocate);
    rb_define_method(rb_cEnumerator, &quot;initialize&quot;, enumerator_initialize, -1);
    rb_define_method(rb_cEnumerator, &quot;initialize_copy&quot;, enumerator_init_copy, 1);
    rb_define_method(rb_cEnumerator, &quot;each&quot;, enumerator_each, 0);
    rb_define_method(rb_cEnumerator, &quot;each_with_index&quot;, enumerator_with_index, 0);
    rb_define_method(rb_cEnumerator, &quot;with_index&quot;, enumerator_with_index, 0);
    rb_define_method(rb_cEnumerator, &quot;next&quot;, enumerator_next, 0);
    rb_define_method(rb_cEnumerator, &quot;rewind&quot;, enumerator_rewind, 0);

    rb_eStopIteration   = rb_define_class(&quot;StopIteration&quot;, rb_eIndexError);

    sym_each	 	= ID2SYM(rb_intern(&quot;each&quot;));

    rb_provide(&quot;enumerator.so&quot;);	/* for backward compatibility */
}
</pre>
    </div>