  <div id="fileHeader">
    <h1>io.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/io.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jun 08 13:20:37 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  io.c -

  $Author: knu $
  $Date: 2008-06-09 03:20:37 +0900 (Mon, 09 Jun 2008) $
  created at: Fri Oct 15 18:08:59 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#if defined(__VMS)
#define _XOPEN_SOURCE
#define _POSIX_C_SOURCE 2
#endif

#include &quot;ruby.h&quot;
#include &quot;rubyio.h&quot;
#include &quot;rubysig.h&quot;
#include &quot;env.h&quot;
#include &quot;re.h&quot;
#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;

#if defined(MSDOS) || defined(__BOW__) || defined(__CYGWIN__) || defined(_WIN32) || defined(__human68k__) || defined(__EMX__) || defined(__BEOS__)
# define NO_SAFE_RENAME
#endif

#if defined(MSDOS) || defined(__CYGWIN__) || defined(_WIN32)
# define NO_LONG_FNAME
#endif

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(sun) || defined(_nec_ews)
# define USE_SETVBUF
#endif

#ifdef __QNXNTO__
#include &quot;unix.h&quot;
#endif

#include &lt;sys/types.h&gt;
#if defined(HAVE_SYS_IOCTL_H) &amp;&amp; !defined(DJGPP) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(__human68k__)
#include &lt;sys/ioctl.h&gt;
#endif
#if defined(HAVE_FCNTL_H) || defined(_WIN32)
#include &lt;fcntl.h&gt;
#elif defined(HAVE_SYS_FCNTL_H)
#include &lt;sys/fcntl.h&gt;
#endif
#ifdef __CYGWIN__
#include &lt;io.h&gt;
#endif

#if !HAVE_OFF_T &amp;&amp; !defined(off_t)
# define off_t  long
#endif
#if !HAVE_FSEEKO &amp;&amp; !defined(fseeko)
# define fseeko  fseek
#endif
#if !HAVE_FTELLO &amp;&amp; !defined(ftello)
# define ftello  ftell
#endif

#include &lt;sys/stat.h&gt;

/* EMX has sys/param.h, but.. */
#if defined(HAVE_SYS_PARAM_H) &amp;&amp; !(defined(__EMX__) || defined(__HIUX_MPP__))
# include &lt;sys/param.h&gt;
#endif

#if !defined NOFILE
# define NOFILE 64
#endif

#ifdef HAVE_UNISTD_H
#ifdef HAVE_SYSCALL_H
#include &lt;syscall.h&gt;
#elif defined HAVE_SYS_SYSCALL_H
#include &lt;sys/syscall.h&gt;
#endif

#include &lt;unistd.h&gt;
#endif

extern void Init_File _((void));

#ifdef __BEOS__
# ifndef NOFILE
#  define NOFILE (OPEN_MAX)
# endif
#include &lt;net/socket.h&gt;
#endif

#include &quot;util.h&quot;

#ifndef O_ACCMODE
#define O_ACCMODE (O_RDONLY | O_WRONLY | O_RDWR)
#endif

#if SIZEOF_OFF_T &gt; SIZEOF_LONG &amp;&amp; !defined(HAVE_LONG_LONG)
# error off_t is bigger than long, but you have no long long...
#endif

#ifndef PIPE_BUF
# ifdef _POSIX_PIPE_BUF
#  define PIPE_BUF _POSIX_PIPE_BUF
# else
#  define PIPE_BUF 512 /* is this ok? */
# endif
#endif

VALUE rb_cIO;
VALUE rb_eEOFError;
VALUE rb_eIOError;

VALUE rb_stdin, rb_stdout, rb_stderr;
VALUE rb_deferr;		/* rescue VIM plugin */
static VALUE orig_stdout, orig_stderr;

VALUE rb_output_fs;
VALUE rb_rs;
VALUE rb_output_rs;
VALUE rb_default_rs;

static VALUE argf;

static ID id_write, id_read, id_getc;

extern char *ruby_inplace_mode;

struct timeval rb_time_interval _((VALUE));

static VALUE filename, current_file;
static int gets_lineno;
static int init_p = 0, next_p = 0;
static VALUE lineno = INT2FIX(0);

#ifdef _STDIO_USES_IOSTREAM  /* GNU libc */
#  ifdef _IO_fpos_t
#    define READ_DATA_PENDING(fp) ((fp)-&gt;_IO_read_ptr != (fp)-&gt;_IO_read_end)
#    define READ_DATA_PENDING_COUNT(fp) ((fp)-&gt;_IO_read_end - (fp)-&gt;_IO_read_ptr)
#    define READ_DATA_PENDING_PTR(fp) ((fp)-&gt;_IO_read_ptr)
#  else
#    define READ_DATA_PENDING(fp) ((fp)-&gt;_gptr &lt; (fp)-&gt;_egptr)
#    define READ_DATA_PENDING_COUNT(fp) ((fp)-&gt;_egptr - (fp)-&gt;_gptr)
#    define READ_DATA_PENDING_PTR(fp) ((fp)-&gt;_gptr)
#  endif
#elif defined(_LP64) &amp;&amp; (defined(__sun__) || defined(__sun))
typedef struct _FILE64 {
  unsigned char        *_ptr;  /* next character from/to here in buffer */
  unsigned char        *_base; /* the buffer */
  unsigned char        *_end;  /* the end of the buffer */
  ssize_t      _cnt;   /* number of available characters in buffer */
  int          _file;  /* UNIX System file descriptor */
  unsigned int _flag;  /* the state of the stream */
  char         __fill[80];     /* filler to bring size to 128 bytes */
} FILE64;
#  define READ_DATA_PENDING(fp) (((FILE64*)(fp))-&gt;_cnt &gt; 0)
#  define READ_DATA_PENDING_COUNT(fp) (((FILE64*)(fp))-&gt;_cnt)
#  define READ_DATA_PENDING_PTR(fp) ((char *)((FILE64*)(fp))-&gt;_ptr)
#elif defined(FILE_COUNT)
#  define READ_DATA_PENDING(fp) ((fp)-&gt;FILE_COUNT &gt; 0)
#  define READ_DATA_PENDING_COUNT(fp) ((fp)-&gt;FILE_COUNT)
#elif defined(FILE_READEND)
#  define READ_DATA_PENDING(fp) ((fp)-&gt;FILE_READPTR &lt; (fp)-&gt;FILE_READEND)
#  define READ_DATA_PENDING_COUNT(fp) ((fp)-&gt;FILE_READEND - (fp)-&gt;FILE_READPTR)
#elif defined(__BEOS__)
#  define READ_DATA_PENDING(fp) (fp-&gt;_state._eof == 0)
#elif defined(__VMS)
#  define READ_DATA_PENDING_COUNT(fp) ((unsigned int)(*(fp))-&gt;_cnt)
#  define READ_DATA_PENDING(fp)       (((unsigned int)(*(fp))-&gt;_cnt) &gt; 0)
#  define READ_DATA_BUFFERED(fp) 0
#elif defined(__DragonFly__)
/* FILE is an incomplete struct type since DragonFly BSD 1.4.0 */
#  define READ_DATA_PENDING(fp) (((struct __FILE_public *)(fp))-&gt;_r &gt; 0)
#  define READ_DATA_PENDING_COUNT(fp) (((struct __FILE_public *)(fp))-&gt;_r)
#else
/* requires systems own version of the ReadDataPending() */
extern int ReadDataPending();
#  define READ_DATA_PENDING(fp) (!feof(fp))
#  define READ_DATA_BUFFERED(fp) 0
#endif
#ifndef READ_DATA_BUFFERED
#  define READ_DATA_BUFFERED(fp) READ_DATA_PENDING(fp)
#endif

#ifndef READ_DATA_PENDING_PTR
# ifdef FILE_READPTR
#  define READ_DATA_PENDING_PTR(fp) ((char *)(fp)-&gt;FILE_READPTR)
# endif
#endif

#if defined __DJGPP__
# undef READ_DATA_PENDING_COUNT
# undef READ_DATA_PENDING_PTR
#endif

#define READ_CHECK(fp) do {\
    if (!READ_DATA_PENDING(fp)) {\
	rb_thread_wait_fd(fileno(fp));\
        rb_io_check_closed(fptr);\
     }\
} while(0)

void
rb_eof_error()
{
    rb_raise(rb_eEOFError, &quot;end of file reached&quot;);
}

VALUE
rb_io_taint_check(io)
    VALUE io;
{
    if (!OBJ_TAINTED(io) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: operation on untainted IO&quot;);
    rb_check_frozen(io);
    return io;
}

void
rb_io_check_initialized(fptr)
    rb_io_t *fptr;
{
    if (!fptr) {
	rb_raise(rb_eIOError, &quot;uninitialized stream&quot;);
    }
}

void
rb_io_check_closed(fptr)
    rb_io_t *fptr;
{
    rb_io_check_initialized(fptr);
    if (!fptr-&gt;f &amp;&amp; !fptr-&gt;f2) {
	rb_raise(rb_eIOError, &quot;closed stream&quot;);
    }
}

static void io_fflush _((FILE *, rb_io_t *));

static rb_io_t *
flush_before_seek(fptr)
    rb_io_t *fptr;
{
    if (fptr-&gt;mode &amp; FMODE_WBUF) {
	io_fflush(GetWriteFile(fptr), fptr);
    }
    errno = 0;
    return fptr;
}

#define io_seek(fptr, ofs, whence) fseeko(flush_before_seek(fptr)-&gt;f, ofs, whence)
#define io_tell(fptr) ftello(flush_before_seek(fptr)-&gt;f)

#ifndef SEEK_CUR
# define SEEK_SET 0
# define SEEK_CUR 1
# define SEEK_END 2
#endif

#define FMODE_SYNCWRITE (FMODE_SYNC|FMODE_WRITABLE)

void
rb_io_check_readable(fptr)
    rb_io_t *fptr;
{
    rb_io_check_closed(fptr);
    if (!(fptr-&gt;mode &amp; FMODE_READABLE)) {
	rb_raise(rb_eIOError, &quot;not opened for reading&quot;);
    }
#ifdef NEED_IO_SEEK_BETWEEN_RW
    if (((fptr-&gt;mode &amp; FMODE_WBUF) ||
	 (fptr-&gt;mode &amp; (FMODE_SYNCWRITE|FMODE_RBUF)) == FMODE_SYNCWRITE) &amp;&amp;
	!feof(fptr-&gt;f) &amp;&amp;
	!fptr-&gt;f2) {
	io_seek(fptr, 0, SEEK_CUR);
    }
#endif
    fptr-&gt;mode |= FMODE_RBUF;
}

void
rb_io_check_writable(fptr)
    rb_io_t *fptr;
{
    rb_io_check_closed(fptr);
    if (!(fptr-&gt;mode &amp; FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, &quot;not opened for writing&quot;);
    }
    if ((fptr-&gt;mode &amp; FMODE_RBUF) &amp;&amp; !feof(fptr-&gt;f) &amp;&amp; !fptr-&gt;f2) {
	io_seek(fptr, 0, SEEK_CUR);
    }
    if (!fptr-&gt;f2) {
	fptr-&gt;mode &amp;= ~FMODE_RBUF;
    }
}

int
rb_read_pending(fp)
    FILE *fp;
{
    return READ_DATA_PENDING(fp);
}

void
rb_read_check(fp)
    FILE *fp;
{
    if (!READ_DATA_PENDING(fp)) {
	rb_thread_wait_fd(fileno(fp));
    }
}

static int
ruby_dup(orig)
    int orig;
{
    int fd;

    fd = dup(orig);
    if (fd &lt; 0) {
	if (errno == EMFILE || errno == ENFILE || errno == ENOMEM) {
	    rb_gc();
	    fd = dup(orig);
	}
	if (fd &lt; 0) {
	    rb_sys_fail(0);
	}
    }
    return fd;
}

static VALUE io_alloc _((VALUE));
static VALUE
io_alloc(klass)
    VALUE klass;
{
    NEWOBJ(io, struct RFile);
    OBJSETUP(io, klass, T_FILE);

    io-&gt;fptr = 0;

    return (VALUE)io;
}

static void
io_fflush(f, fptr)
    FILE *f;
    rb_io_t *fptr;
{
    int n;

    if (!rb_thread_fd_writable(fileno(f))) {
        rb_io_check_closed(fptr);
    }
    for (;;) {
	TRAP_BEG;
	n = fflush(f);
	TRAP_END;
	if (n != EOF) break;
	if (!rb_io_wait_writable(fileno(f)))
	    rb_sys_fail(fptr-&gt;path);
    }
    fptr-&gt;mode &amp;= ~FMODE_WBUF;
}

int
rb_io_wait_readable(f)
    int f;
{
    fd_set rfds;

    switch (errno) {
      case EINTR:
#if defined(ERESTART)
      case ERESTART:
#endif
	rb_thread_wait_fd(f);
	return Qtrue;

      case EAGAIN:
#if defined(EWOULDBLOCK) &amp;&amp; EWOULDBLOCK != EAGAIN
      case EWOULDBLOCK:
#endif
	FD_ZERO(&amp;rfds);
	FD_SET(f, &amp;rfds);
	rb_thread_select(f + 1, &amp;rfds, NULL, NULL, NULL);
	return Qtrue;

      default:
	return Qfalse;
    }
}

int
rb_io_wait_writable(f)
    int f;
{
    fd_set wfds;

    switch (errno) {
      case EINTR:
#if defined(ERESTART)
      case ERESTART:
#endif
	rb_thread_fd_writable(f);
	return Qtrue;

      case EAGAIN:
#if defined(EWOULDBLOCK) &amp;&amp; EWOULDBLOCK != EAGAIN
      case EWOULDBLOCK:
#endif
	FD_ZERO(&amp;wfds);
	FD_SET(f, &amp;wfds);
	rb_thread_select(f + 1, NULL, &amp;wfds, NULL, NULL);
	return Qtrue;

      default:
	return Qfalse;
    }
}

#ifndef S_ISREG
#   define S_ISREG(m) ((m &amp; S_IFMT) == S_IFREG)
#endif

static int
wsplit_p(rb_io_t *fptr)
{
    FILE *f = GetWriteFile(fptr);
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL) &amp;&amp; defined(O_NONBLOCK)
    int r;
#endif

    if (!(fptr-&gt;mode &amp; FMODE_WSPLIT_INITIALIZED)) {
        struct stat buf;
        if (fstat(fileno(f), &amp;buf) == 0 &amp;&amp;
            !S_ISREG(buf.st_mode)
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL) &amp;&amp; defined(O_NONBLOCK)
            &amp;&amp; (r = fcntl(fileno(f), F_GETFL)) != -1 &amp;&amp;
            !(r &amp; O_NONBLOCK)
#endif
            ) {
            fptr-&gt;mode |= FMODE_WSPLIT;
        }
        fptr-&gt;mode |= FMODE_WSPLIT_INITIALIZED;
    }
    return fptr-&gt;mode &amp; FMODE_WSPLIT;
}

/* writing functions */
static long
io_fwrite(str, fptr)
    VALUE str;
    rb_io_t *fptr;
{
    long len, n, r, l, offset = 0;
    FILE *f = GetWriteFile(fptr);

    len = RSTRING(str)-&gt;len;
    if ((n = len) &lt;= 0) return n;
    if (fptr-&gt;mode &amp; FMODE_SYNC) {
	io_fflush(f, fptr);
	if (!rb_thread_fd_writable(fileno(f))) {
	    rb_io_check_closed(fptr);
	}
      retry:
        l = n;
        if (PIPE_BUF &lt; l &amp;&amp;
            !rb_thread_critical &amp;&amp;
            !rb_thread_alone() &amp;&amp;
            wsplit_p(fptr)) {
            l = PIPE_BUF;
        }
        TRAP_BEG;
	r = write(fileno(f), RSTRING(str)-&gt;ptr+offset, l);
        TRAP_END;
        if (r == n) return len;
        if (0 &lt;= r) {
            offset += r;
            n -= r;
            errno = EAGAIN;
        }
        if (rb_io_wait_writable(fileno(f))) {
            rb_io_check_closed(fptr);
	    if (offset &lt; RSTRING(str)-&gt;len)
		goto retry;
        }
        return -1L;
    }
#if defined(__human68k__) || defined(__vms)
    do {
	if (fputc(RSTRING(str)-&gt;ptr[offset++], f) == EOF) {
	    if (ferror(f)) return -1L;
	    break;
	}
    } while (--n &gt; 0);
#else
    while (errno = 0, offset += (r = fwrite(RSTRING(str)-&gt;ptr+offset, 1, n, f)), (n -= r) &gt; 0) {
	if (ferror(f)
#if defined __BORLANDC__
	    || errno
#endif
	) {
#ifdef __hpux
	    if (!errno) errno = EAGAIN;
#elif defined(_WIN32) &amp;&amp; !defined(__BORLANDC__)
	    /* workaround for MSVCRT's bug */
	    if (!errno) {
		if (GetLastError() == ERROR_NO_DATA)
		    errno = EPIPE;
		else
		    errno = EBADF;
	    }
#endif
	    if (rb_io_wait_writable(fileno(f))) {
		rb_io_check_closed(fptr);
		clearerr(f);
		if (offset &lt; RSTRING(str)-&gt;len)
		    continue;
	    }
	    return -1L;
	}
    }
#endif
    return len - n;
}

long
rb_io_fwrite(ptr, len, f)
    const char *ptr;
    long len;
    FILE *f;
{
    rb_io_t of;

    of.f = f;
    of.f2 = NULL;
    of.mode = FMODE_WRITABLE;
    of.path = NULL;
    return io_fwrite(rb_str_new(ptr, len), &amp;of);
}

/*
 *  call-seq:
 *     ios.write(string)    =&gt; integer
 *  
 *  Writes the given string to &lt;em&gt;ios&lt;/em&gt;. The stream must be opened
 *  for writing. If the argument is not a string, it will be converted
 *  to a string using &lt;code&gt;to_s&lt;/code&gt;. Returns the number of bytes
 *  written.
 *     
 *     count = $stdout.write( &quot;This is a test\n&quot; )
 *     puts &quot;That was #{count} bytes of data&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     This is a test
 *     That was 15 bytes of data
 */

static VALUE
io_write(io, str)
    VALUE io, str;
{
    rb_io_t *fptr;
    long n;

    rb_secure(4);
    if (TYPE(str) != T_STRING)
	str = rb_obj_as_string(str);

    if (TYPE(io) != T_FILE) {
	/* port is not IO, call write method for it. */
	return rb_funcall(io, id_write, 1, str);
    }
    if (RSTRING(str)-&gt;len == 0) return INT2FIX(0);

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);

    n = io_fwrite(str, fptr);
    if (n == -1L) rb_sys_fail(fptr-&gt;path);
    if (!(fptr-&gt;mode &amp; FMODE_SYNC)) {
	fptr-&gt;mode |= FMODE_WBUF;
    }

    return LONG2FIX(n);
}

VALUE
rb_io_write(io, str)
    VALUE io, str;
{
    return rb_funcall(io, id_write, 1, str);
}

/*
 *  call-seq:
 *     ios &lt;&lt; obj     =&gt; ios
 *  
 *  String Output---Writes &lt;i&gt;obj&lt;/i&gt; to &lt;em&gt;ios&lt;/em&gt;.
 *  &lt;i&gt;obj&lt;/i&gt; will be converted to a string using
 *  &lt;code&gt;to_s&lt;/code&gt;.
 *     
 *     $stdout &lt;&lt; &quot;Hello &quot; &lt;&lt; &quot;world!\n&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Hello world!
 */

VALUE
rb_io_addstr(io, str)
    VALUE io, str;
{
    rb_io_write(io, str);
    return io;
}

/*
 *  call-seq:
 *     ios.flush    =&gt; ios
 *  
 *  Flushes any buffered data within &lt;em&gt;ios&lt;/em&gt; to the underlying
 *  operating system (note that this is Ruby internal buffering only;
 *  the OS may buffer the data as well).
 *     
 *     $stdout.print &quot;no newline&quot;
 *     $stdout.flush
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     no newline
 */

static VALUE
rb_io_flush(io)
    VALUE io;
{
    rb_io_t *fptr;
    FILE *f;

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    io_fflush(f, fptr);

    return io;
}

/*
 *  call-seq:
 *     ios.pos     =&gt; integer
 *     ios.tell    =&gt; integer
 *  
 *  Returns the current offset (in bytes) of &lt;em&gt;ios&lt;/em&gt;.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.pos    #=&gt; 0
 *     f.gets   #=&gt; &quot;This is line one\n&quot;
 *     f.pos    #=&gt; 17
 */

static VALUE
rb_io_tell(io)
     VALUE io;
{
    rb_io_t *fptr;
    off_t pos;

    GetOpenFile(io, fptr);
    pos = io_tell(fptr);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail(fptr-&gt;path);
    return OFFT2NUM(pos);
}

static VALUE
rb_io_seek(io, offset, whence)
    VALUE io, offset;
    int whence;
{
    rb_io_t *fptr;
    off_t pos;

    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    pos = io_seek(fptr, pos, whence);
    if (pos &lt; 0 &amp;&amp; errno) rb_sys_fail(fptr-&gt;path);
    clearerr(fptr-&gt;f);

    return INT2FIX(0);
}

/*
 *  call-seq:
 *     ios.seek(amount, whence=SEEK_SET) -&gt; 0
 *  
 *  Seeks to a given offset &lt;i&gt;anInteger&lt;/i&gt; in the stream according to
 *  the value of &lt;i&gt;whence&lt;/i&gt;:
 *
 *    IO::SEEK_CUR  | Seeks to _amount_ plus current position
 *    --------------+----------------------------------------------------
 *    IO::SEEK_END  | Seeks to _amount_ plus end of stream (you probably 
 *                  | want a negative value for _amount_)
 *    --------------+----------------------------------------------------
 *    IO::SEEK_SET  | Seeks to the absolute location given by _amount_
 *
 *  Example:
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.seek(-13, IO::SEEK_END)   #=&gt; 0
 *     f.readline                  #=&gt; &quot;And so on...\n&quot;
 */

static VALUE
rb_io_seek_m(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;offset, &amp;ptrname) == 2) {
	whence = NUM2INT(ptrname);
    }

    return rb_io_seek(io, offset, whence);
}

/*
 *  call-seq:
 *     ios.pos = integer    =&gt; integer
 *  
 *  Seeks to the given position (in bytes) in &lt;em&gt;ios&lt;/em&gt;.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.pos = 17
 *     f.gets   #=&gt; &quot;This is line two\n&quot;
 */

static VALUE
rb_io_set_pos(io, offset)
     VALUE io, offset;
{
    rb_io_t *fptr;
    off_t pos;

    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    pos = io_seek(fptr, pos, SEEK_SET);
    if (pos != 0) rb_sys_fail(fptr-&gt;path);
    clearerr(fptr-&gt;f);

    return OFFT2NUM(pos);
}

/*
 *  call-seq:
 *     ios.rewind    =&gt; 0
 *  
 *  Positions &lt;em&gt;ios&lt;/em&gt; to the beginning of input, resetting
 *  &lt;code&gt;lineno&lt;/code&gt; to zero.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.readline   #=&gt; &quot;This is line one\n&quot;
 *     f.rewind     #=&gt; 0
 *     f.lineno     #=&gt; 0
 *     f.readline   #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_io_rewind(io)
    VALUE io;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (io_seek(fptr, 0L, 0) != 0) rb_sys_fail(fptr-&gt;path);
    clearerr(fptr-&gt;f);
    if (io == current_file) {
	gets_lineno -= fptr-&gt;lineno;
    }
    fptr-&gt;lineno = 0;

    return INT2FIX(0);
}

/*
 *  call-seq:
 *     ios.eof     =&gt; true or false
 *     ios.eof?    =&gt; true or false
 *
 *  Returns true if &lt;em&gt;ios&lt;/em&gt; is at end of file that means
 *  there are no more data to read.
 *  The stream must be opened for reading or an &lt;code&gt;IOError&lt;/code&gt; will be
 *  raised.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     dummy = f.readlines
 *     f.eof   #=&gt; true
 *
 *  If &lt;em&gt;ios&lt;/em&gt; is a stream such as pipe or socket, &lt;code&gt;IO#eof?&lt;/code&gt;
 *  blocks until the other end sends some data or closes it.
 *
 *     r, w = IO.pipe
 *     Thread.new { sleep 1; w.close }
 *     r.eof?  #=&gt; true after 1 second blocking
 *
 *     r, w = IO.pipe
 *     Thread.new { sleep 1; w.puts &quot;a&quot; }
 *     r.eof?  #=&gt; false after 1 second blocking
 *
 *     r, w = IO.pipe
 *     r.eof?  # blocks forever
 *
 *  Note that &lt;code&gt;IO#eof?&lt;/code&gt; reads data to a input buffer.
 *  So &lt;code&gt;IO#sysread&lt;/code&gt; doesn't work with &lt;code&gt;IO#eof?&lt;/code&gt;.
 */

VALUE
rb_io_eof(io)
    VALUE io;
{
    rb_io_t *fptr;
    int ch;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);

    if (feof(fptr-&gt;f)) return Qtrue;
    if (READ_DATA_PENDING(fptr-&gt;f)) return Qfalse;
    READ_CHECK(fptr-&gt;f);
    clearerr(fptr-&gt;f);
    TRAP_BEG;
    ch = getc(fptr-&gt;f);
    TRAP_END;

    if (ch != EOF) {
	ungetc(ch, fptr-&gt;f);
	return Qfalse;
    }
    rb_io_check_closed(fptr);
    clearerr(fptr-&gt;f);
    return Qtrue;
}

/*
 *  call-seq:
 *     ios.sync    =&gt; true or false
 *  
 *  Returns the current ``sync mode'' of &lt;em&gt;ios&lt;/em&gt;. When sync mode is
 *  true, all output is immediately flushed to the underlying operating
 *  system and is not buffered by Ruby internally. See also
 *  &lt;code&gt;IO#fsync&lt;/code&gt;.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.sync   #=&gt; false
 */

static VALUE
rb_io_sync(io)
    VALUE io;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    return (fptr-&gt;mode &amp; FMODE_SYNC) ? Qtrue : Qfalse;
}

/*
 *  call-seq:
 *     ios.sync = boolean   =&gt; boolean
 *  
 *  Sets the ``sync mode'' to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
 *  When sync mode is true, all output is immediately flushed to the
 *  underlying operating system and is not buffered internally. Returns
 *  the new state. See also &lt;code&gt;IO#fsync&lt;/code&gt;.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.sync = true
 *     
 *  &lt;em&gt;(produces no output)&lt;/em&gt;
 */

static VALUE
rb_io_set_sync(io, mode)
    VALUE io, mode;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (RTEST(mode)) {
	fptr-&gt;mode |= FMODE_SYNC;
    }
    else {
	fptr-&gt;mode &amp;= ~FMODE_SYNC;
    }
    return mode;
}

/*
 *  call-seq:
 *     ios.fsync   =&gt; 0 or nil
 *  
 *  Immediately writes all buffered data in &lt;em&gt;ios&lt;/em&gt; to disk.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if the underlying operating system does not
 *  support &lt;em&gt;fsync(2)&lt;/em&gt;. Note that &lt;code&gt;fsync&lt;/code&gt; differs from
 *  using &lt;code&gt;IO#sync=&lt;/code&gt;. The latter ensures that data is flushed
 *  from Ruby's buffers, but doesn't not guarantee that the underlying
 *  operating system actually writes it to disk.
 */

static VALUE
rb_io_fsync(io)
    VALUE io;
{
#ifdef HAVE_FSYNC
    rb_io_t *fptr;
    FILE *f;

    GetOpenFile(io, fptr);
    f = GetWriteFile(fptr);

    io_fflush(f, fptr);
    if (fsync(fileno(f)) &lt; 0)
	rb_sys_fail(fptr-&gt;path);
    return INT2FIX(0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

/*
 *  call-seq:
 *     ios.fileno    =&gt; fixnum
 *     ios.to_i      =&gt; fixnum
 *  
 *  Returns an integer representing the numeric file descriptor for
 *  &lt;em&gt;ios&lt;/em&gt;.
 *     
 *     $stdin.fileno    #=&gt; 0
 *     $stdout.fileno   #=&gt; 1
 */

static VALUE
rb_io_fileno(io)
    VALUE io;
{
    rb_io_t *fptr;
    int fd;

    GetOpenFile(io, fptr);
    fd = fileno(fptr-&gt;f);
    return INT2FIX(fd);
}

/*
 *  call-seq:
 *     ios.pid    =&gt; fixnum
 *  
 *  Returns the process ID of a child process associated with
 *  &lt;em&gt;ios&lt;/em&gt;. This will be set by &lt;code&gt;IO::popen&lt;/code&gt;.
 *     
 *     pipe = IO.popen(&quot;-&quot;)
 *     if pipe
 *       $stderr.puts &quot;In parent, child pid is #{pipe.pid}&quot;
 *     else
 *       $stderr.puts &quot;In child, pid is #{$$}&quot;
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     In child, pid is 26209
 *     In parent, child pid is 26209
 */

static VALUE
rb_io_pid(io)
    VALUE io;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (!fptr-&gt;pid)
	return Qnil;
    return INT2FIX(fptr-&gt;pid);
}

/*
 * call-seq:
 *   ios.inspect   =&gt; string
 *
 * Return a string describing this IO object.
 */

static VALUE
rb_io_inspect(obj)
    VALUE obj;
{
    rb_io_t *fptr;
    char *buf;
    const char *cname, *st = &quot;&quot;;
    long len;

    fptr = RFILE(rb_io_taint_check(obj))-&gt;fptr;
    if (!fptr || !fptr-&gt;path) return rb_any_to_s(obj);
    cname = rb_obj_classname(obj);
    len = strlen(cname) + strlen(fptr-&gt;path) + 5;
    if (!(fptr-&gt;f || fptr-&gt;f2)) {
	st = &quot; (closed)&quot;;
	len += 9;
    }
    buf = ALLOCA_N(char, len);
    snprintf(buf, len, &quot;#&lt;%s:%s%s&gt;&quot;, cname, fptr-&gt;path, st);
    return rb_str_new2(buf);
}

/*
 *  call-seq:
 *     ios.to_io -&gt; ios
 *  
 *  Returns &lt;em&gt;ios&lt;/em&gt;.
 */

static VALUE
rb_io_to_io(io)
    VALUE io;
{
    return io;
}

/* reading functions */
static long
read_buffered_data(ptr, len, f)
    char *ptr;
    long len;
    FILE *f;
{
    long n;

#ifdef READ_DATA_PENDING_COUNT
    n = READ_DATA_PENDING_COUNT(f);
    if (n &lt;= 0) return 0;
    if (n &gt; len) n = len;
    return fread(ptr, 1, n, f);
#else
    int c;

    for (n = 0; n &lt; len &amp;&amp; READ_DATA_PENDING(f) &amp;&amp; (c = getc(f)) != EOF; ++n) {
	*ptr++ = c;
    }
    return n;
#endif
}

static long
io_fread(ptr, len, fptr)
    char *ptr;
    long len;
    rb_io_t *fptr;
{
    long n = len;
    int c;
    int saved_errno;

    while (n &gt; 0) {
        c = read_buffered_data(ptr, n, fptr-&gt;f);
        if (c &lt; 0) goto eof;
        if (c &gt; 0) {
            ptr += c;
            if ((n -= c) &lt;= 0) break;
        }
        rb_thread_wait_fd(fileno(fptr-&gt;f));
        rb_io_check_closed(fptr);
	clearerr(fptr-&gt;f);
	TRAP_BEG;
	c = getc(fptr-&gt;f);
	TRAP_END;
	if (c == EOF) {
	  eof:
	    if (ferror(fptr-&gt;f)) {
		switch (errno) {
		  case EINTR:
#if defined(ERESTART)
		  case ERESTART:
#endif
		    clearerr(fptr-&gt;f);
		    continue;
		  case EAGAIN:
#if defined(EWOULDBLOCK) &amp;&amp; EWOULDBLOCK != EAGAIN
		  case EWOULDBLOCK:
#endif
		    if (len &gt; n) {
			clearerr(fptr-&gt;f);
		    }
                    saved_errno = errno;
                    rb_warning(&quot;nonblocking IO#read is obsolete; use IO#readpartial or IO#sysread&quot;);
                    errno = saved_errno;
		}
		if (len == n) return 0;
	    }
	    break;
	}
	*ptr++ = c;
	n--;
    }
    return len - n;
}

long
rb_io_fread(ptr, len, f)
    char *ptr;
    long len;
    FILE *f;
{
    rb_io_t of;

    of.f = f;
    of.f2 = NULL;
    return io_fread(ptr, len, &amp;of);
}

#define SMALLBUF 100

static long
remain_size(fptr)
    rb_io_t *fptr;
{
    struct stat st;
    off_t siz = BUFSIZ;
    off_t pos;

    if (feof(fptr-&gt;f)) return 0;
    if (fstat(fileno(fptr-&gt;f), &amp;st) == 0  &amp;&amp; S_ISREG(st.st_mode)
#ifdef __BEOS__
	&amp;&amp; (st.st_dev &gt; 3)
#endif
	)
    {
	pos = io_tell(fptr);
	if (st.st_size &gt;= pos &amp;&amp; pos &gt;= 0) {
	    siz = st.st_size - pos + 1;
	    if (siz &gt; LONG_MAX) {
		rb_raise(rb_eIOError, &quot;file too big for single read&quot;);
	    }
	}
    }
    return (long)siz;
}

static VALUE
read_all(fptr, siz, str)
    rb_io_t *fptr;
    long siz;
    VALUE str;
{
    long bytes = 0;
    long n;

    if (siz == 0) siz = BUFSIZ;
    if (NIL_P(str)) {
	str = rb_str_new(0, siz);
    }
    else {
	rb_str_resize(str, siz);
    }
    for (;;) {
	rb_str_locktmp(str);
	READ_CHECK(fptr-&gt;f);
	n = io_fread(RSTRING(str)-&gt;ptr+bytes, siz-bytes, fptr);
	rb_str_unlocktmp(str);
	if (n == 0 &amp;&amp; bytes == 0) {
	    if (!fptr-&gt;f) break;
	    if (feof(fptr-&gt;f)) break;
	    if (!ferror(fptr-&gt;f)) break;
	    rb_sys_fail(fptr-&gt;path);
	}
	bytes += n;
	if (bytes &lt; siz) break;
	siz += BUFSIZ;
	rb_str_resize(str, siz);
    }
    if (bytes != siz) rb_str_resize(str, bytes);
    OBJ_TAINT(str);

    return str;
}

void rb_io_set_nonblock(rb_io_t *fptr)
{
    int flags;
#ifdef F_GETFL
    flags = fcntl(fileno(fptr-&gt;f), F_GETFL);
    if (flags == -1) {
        rb_sys_fail(fptr-&gt;path);
    }
#else
    flags = 0;
#endif
    if ((flags &amp; O_NONBLOCK) == 0) {
        flags |= O_NONBLOCK;
        if (fcntl(fileno(fptr-&gt;f), F_SETFL, flags) == -1) {
            rb_sys_fail(fptr-&gt;path);
        }
    }
    if (fptr-&gt;f2) {
#ifdef F_GETFL
        flags = fcntl(fileno(fptr-&gt;f2), F_GETFL);
        if (flags == -1) {
            rb_sys_fail(fptr-&gt;path);
        }
#else
        flags = 0;
#endif
        if ((flags &amp; O_NONBLOCK) == 0) {
            flags |= O_NONBLOCK;
            if (fcntl(fileno(fptr-&gt;f2), F_SETFL, flags) == -1) {
                rb_sys_fail(fptr-&gt;path);
            }
        }
    }
}

static VALUE
io_getpartial(int argc, VALUE *argv, VALUE io, int nonblock)
{
    rb_io_t *fptr;
    VALUE length, str;
    long n, len;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;length, &amp;str);

    if ((len = NUM2LONG(length)) &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative length %ld given&quot;, len);
    }

    if (NIL_P(str)) {
        str = rb_str_new(0, len);
    }
    else {
        StringValue(str);
        rb_str_modify(str);
        rb_str_resize(str, len);
    }
    OBJ_TAINT(str);

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);

    if (len == 0)
        return str;

    if (!nonblock) {
        READ_CHECK(fptr-&gt;f);
    }
    if (RSTRING(str)-&gt;len != len) {
      modified:
        rb_raise(rb_eRuntimeError, &quot;buffer string modified&quot;);
    }
    n = read_buffered_data(RSTRING(str)-&gt;ptr, len, fptr-&gt;f);
    if (n &lt;= 0) {
      again:
        if (RSTRING(str)-&gt;len != len) goto modified;
        if (nonblock) {
            rb_io_set_nonblock(fptr);
            n = read(fileno(fptr-&gt;f), RSTRING(str)-&gt;ptr, len);
        }
        else {
            TRAP_BEG;
            n = read(fileno(fptr-&gt;f), RSTRING(str)-&gt;ptr, len);
            TRAP_END;
        }
        if (n &lt; 0) {
            if (!nonblock &amp;&amp; rb_io_wait_readable(fileno(fptr-&gt;f)))
                goto again;
            rb_sys_fail(fptr-&gt;path);
        }
    }
    rb_str_resize(str, n);

    if (n == 0)
        return Qnil;
    else
        return str;
}

/*
 *  call-seq:
 *     ios.readpartial(maxlen)              =&gt; string
 *     ios.readpartial(maxlen, outbuf)      =&gt; outbuf
 *
 *  Reads at most &lt;i&gt;maxlen&lt;/i&gt; bytes from the I/O stream.
 *  It blocks only if &lt;em&gt;ios&lt;/em&gt; has no data immediately available.
 *  It doesn't block if some data available.
 *  If the optional &lt;i&gt;outbuf&lt;/i&gt; argument is present,
 *  it must reference a String, which will receive the data.
 *  It raises &lt;code&gt;EOFError&lt;/code&gt; on end of file.
 *
 *  readpartial is designed for streams such as pipe, socket, tty, etc.
 *  It blocks only when no data immediately available.
 *  This means that it blocks only when following all conditions hold.
 *  * the buffer in the IO object is empty.
 *  * the content of the stream is empty.
 *  * the stream is not reached to EOF.
 *
 *  When readpartial blocks, it waits data or EOF on the stream.
 *  If some data is reached, readpartial returns with the data.
 *  If EOF is reached, readpartial raises EOFError.
 *
 *  When readpartial doesn't blocks, it returns or raises immediately.
 *  If the buffer is not empty, it returns the data in the buffer.
 *  Otherwise if the stream has some content,
 *  it returns the data in the stream. 
 *  Otherwise if the stream is reached to EOF, it raises EOFError.
 *
 *     r, w = IO.pipe           #               buffer          pipe content
 *     w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;.
 *     r.readpartial(4096)      #=&gt; &quot;abc&quot;       &quot;&quot;              &quot;&quot;
 *     r.readpartial(4096)      # blocks because buffer and pipe is empty.
 *
 *     r, w = IO.pipe           #               buffer          pipe content
 *     w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;
 *     w.close                  #               &quot;&quot;              &quot;abc&quot; EOF
 *     r.readpartial(4096)      #=&gt; &quot;abc&quot;       &quot;&quot;              EOF
 *     r.readpartial(4096)      # raises EOFError
 *
 *     r, w = IO.pipe           #               buffer          pipe content
 *     w &lt;&lt; &quot;abc\ndef\n&quot;        #               &quot;&quot;              &quot;abc\ndef\n&quot;
 *     r.gets                   #=&gt; &quot;abc\n&quot;     &quot;def\n&quot;         &quot;&quot;
 *     w &lt;&lt; &quot;ghi\n&quot;             #               &quot;def\n&quot;         &quot;ghi\n&quot;
 *     r.readpartial(4096)      #=&gt; &quot;def\n&quot;     &quot;&quot;              &quot;ghi\n&quot;
 *     r.readpartial(4096)      #=&gt; &quot;ghi\n&quot;     &quot;&quot;              &quot;&quot;
 *
 *  Note that readpartial behaves similar to sysread.
 *  The differences are:
 *  * If the buffer is not empty, read from the buffer instead of &quot;sysread for buffered IO (IOError)&quot;.
 *  * It doesn't cause Errno::EAGAIN and Errno::EINTR.  When readpartial meets EAGAIN and EINTR by read system call, readpartial retry the system call.
 *
 *  The later means that readpartial is nonblocking-flag insensitive.
 *  It blocks on the situation IO#sysread causes Errno::EAGAIN as if the fd is blocking mode.
 *
 */

static VALUE
io_readpartial(int argc, VALUE *argv, VALUE io)
{
    VALUE ret;

    ret = io_getpartial(argc, argv, io, 0);
    if (NIL_P(ret))
        rb_eof_error();
    else
        return ret;
}

/*
 *  call-seq:
 *     ios.read_nonblock(maxlen)              =&gt; string
 *     ios.read_nonblock(maxlen, outbuf)      =&gt; outbuf
 *
 *  Reads at most &lt;i&gt;maxlen&lt;/i&gt; bytes from &lt;em&gt;ios&lt;/em&gt; using
 *  read(2) system call after O_NONBLOCK is set for
 *  the underlying file descriptor.
 *
 *  If the optional &lt;i&gt;outbuf&lt;/i&gt; argument is present,
 *  it must reference a String, which will receive the data.
 *
 *  read_nonblock just calls read(2).
 *  It causes all errors read(2) causes: EAGAIN, EINTR, etc.
 *  The caller should care such errors.
 *
 *  read_nonblock causes EOFError on EOF.
 *
 *  If the read buffer is not empty,
 *  read_nonblock reads from the buffer like readpartial.
 *  In this case, read(2) is not called.
 *
 */

static VALUE
io_read_nonblock(int argc, VALUE *argv, VALUE io)
{
    VALUE ret;

    ret = io_getpartial(argc, argv, io, 1);
    if (NIL_P(ret))
        rb_eof_error();
    else
        return ret;
}

/*
 *  call-seq:
 *     ios.write_nonblock(string)   =&gt; integer
 *
 *  Writes the given string to &lt;em&gt;ios&lt;/em&gt; using
 *  write(2) system call after O_NONBLOCK is set for
 *  the underlying file descriptor.
 *
 *  write_nonblock just calls write(2).
 *  It causes all errors write(2) causes: EAGAIN, EINTR, etc.
 *  The result may also be smaller than string.length (partial write).
 *  The caller should care such errors and partial write.
 *
 */

static VALUE
rb_io_write_nonblock(VALUE io, VALUE str)
{
    rb_io_t *fptr;
    FILE *f;
    long n;

    rb_secure(4);
    if (TYPE(str) != T_STRING)
	str = rb_obj_as_string(str);

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);

    f = GetWriteFile(fptr);

    rb_io_set_nonblock(fptr);
    n = write(fileno(f), RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len);

    if (n == -1) rb_sys_fail(fptr-&gt;path);

    return LONG2FIX(n);
}

/*
 *  call-seq:
 *     ios.read([length [, buffer]])    =&gt; string, buffer, or nil
 *
 *  Reads at most &lt;i&gt;length&lt;/i&gt; bytes from the I/O stream, or to the
 *  end of file if &lt;i&gt;length&lt;/i&gt; is omitted or is &lt;code&gt;nil&lt;/code&gt;.
 *  &lt;i&gt;length&lt;/i&gt; must be a non-negative integer or nil.
 *  If the optional &lt;i&gt;buffer&lt;/i&gt; argument is present, it must reference
 *  a String, which will receive the data.
 *
 *  At end of file, it returns &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt;
 *  depend on &lt;i&gt;length&lt;/i&gt;.
 *  &lt;code&gt;&lt;i&gt;ios&lt;/i&gt;.read()&lt;/code&gt; and
 *  &lt;code&gt;&lt;i&gt;ios&lt;/i&gt;.read(nil)&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.
 *  &lt;code&gt;&lt;i&gt;ios&lt;/i&gt;.read(&lt;i&gt;positive-integer&lt;/i&gt;)&lt;/code&gt; returns nil.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.read(16)   #=&gt; &quot;This is line one&quot;
 */

static VALUE
io_read(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    rb_io_t *fptr;
    long n, len;
    VALUE length, str;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;length, &amp;str);

    if (NIL_P(length)) {
	if (!NIL_P(str)) StringValue(str);
	GetOpenFile(io, fptr);
	rb_io_check_readable(fptr);	
	return read_all(fptr, remain_size(fptr), str);
    }
    len = NUM2LONG(length);
    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;negative length %ld given&quot;, len);
    }

    if (NIL_P(str)) {
	str = rb_tainted_str_new(0, len);
    }
    else {
	StringValue(str);
	rb_str_modify(str);
	rb_str_resize(str,len);
    }

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    if (feof(fptr-&gt;f)) return Qnil;
    if (len == 0) return str;

    rb_str_locktmp(str);
    READ_CHECK(fptr-&gt;f);
    if (RSTRING(str)-&gt;len != len) {
	rb_raise(rb_eRuntimeError, &quot;buffer string modified&quot;);
    }
    n = io_fread(RSTRING(str)-&gt;ptr, len, fptr);
    rb_str_unlocktmp(str);
    if (n == 0) {
	if (!fptr-&gt;f) return Qnil;
	if (feof(fptr-&gt;f)) {
	    rb_str_resize(str, 0);
	    return Qnil;
	}
	if (len &gt; 0) rb_sys_fail(fptr-&gt;path);
    }
    rb_str_resize(str, n);
    RSTRING(str)-&gt;len = n;
    RSTRING(str)-&gt;ptr[n] = '\0';
    OBJ_TAINT(str);

    return str;
}

static int
appendline(fptr, delim, strp)
    rb_io_t *fptr;
    int delim;
    VALUE *strp;
{
    FILE *f = fptr-&gt;f;
    VALUE str = *strp;
    int c = EOF;
#ifndef READ_DATA_PENDING_PTR
    char buf[8192];
    char *bp = buf, *bpe = buf + sizeof buf - 3;
    int update = Qfalse;
#endif

    do {
#ifdef READ_DATA_PENDING_PTR
	long pending = READ_DATA_PENDING_COUNT(f);
	if (pending &gt; 0) {
	    const char *p = READ_DATA_PENDING_PTR(f);
	    const char *e = memchr(p, delim, pending);
	    long last = 0, len = (c != EOF);
	    if (e) pending = e - p + 1;
	    len += pending;
	    if (!NIL_P(str)) {
		last = RSTRING(str)-&gt;len;
		rb_str_resize(str, last + len);
	    }
	    else {
		*strp = str = rb_str_buf_new(len);
		RSTRING(str)-&gt;len = len;
		RSTRING(str)-&gt;ptr[len] = '\0';
	    }
	    if (c != EOF) {
		RSTRING(str)-&gt;ptr[last++] = c;
	    }
	    fread(RSTRING(str)-&gt;ptr + last, 1, pending, f); /* must not fail */
	    if (e) return delim;
	}
	else if (c != EOF) {
	    if (!NIL_P(str)) {
		char ch = c;
		rb_str_buf_cat(str, &amp;ch, 1);
	    }
	    else {
		*strp = str = rb_str_buf_new(1);
		RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len++] = c;
	    }
	}
	rb_thread_wait_fd(fileno(f));
	rb_io_check_closed(fptr);
#else
	READ_CHECK(f);
#endif
	clearerr(f);
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    if (ferror(f)) {
		clearerr(f);
		if (!rb_io_wait_readable(fileno(f)))
		    rb_sys_fail(fptr-&gt;path);
		continue;
	    }
#ifdef READ_DATA_PENDING_PTR
	    return c;
#endif
	}
#ifndef READ_DATA_PENDING_PTR
	if (c == EOF || (*bp++ = c) == delim || bp == bpe) {
	    int cnt = bp - buf;

	    if (cnt &gt; 0) {
		if (!NIL_P(str))
		    rb_str_cat(str, buf, cnt);
		else
		    *strp = str = rb_str_new(buf, cnt);
	    }
	    if (c == EOF) {
		if (update)
		    return (int)RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len-1];
		return c;
	    }
	    bp = buf;
	}
	update = Qtrue;
#endif
    } while (c != delim);

#ifdef READ_DATA_PENDING_PTR
    {
	char ch = c;
	if (!NIL_P(str)) {
	    rb_str_cat(str, &amp;ch, 1);
	}
	else {
	    *strp = str = rb_str_new(&amp;ch, 1);
	}
    }
#endif

    return c;
}

static inline int
swallow(fptr, term)
    rb_io_t *fptr;
    int term;
{
    FILE *f = fptr-&gt;f;
    int c;

    do {
#ifdef READ_DATA_PENDING_PTR
	long cnt;
	while ((cnt = READ_DATA_PENDING_COUNT(f)) &gt; 0) {
	    char buf[1024];
	    const char *p = READ_DATA_PENDING_PTR(f);
	    int i;
	    if (cnt &gt; sizeof buf) cnt = sizeof buf;
	    if (*p != term) return Qtrue;
	    i = cnt;
	    while (--i &amp;&amp; *++p == term);
	    if (!fread(buf, 1, cnt - i, f)) /* must not fail */
		rb_sys_fail(fptr-&gt;path);
	}
	rb_thread_wait_fd(fileno(f));
	rb_io_check_closed(fptr);
#else
	READ_CHECK(f);
#endif
	clearerr(f);
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c != term) {
	    ungetc(c, f);
	    return Qtrue;
	}
    } while (c != EOF);
    return Qfalse;
}

static VALUE
rb_io_getline_fast(fptr, delim)
    rb_io_t *fptr;
    unsigned char delim;
{
    VALUE str = Qnil;
    int c;

    while ((c = appendline(fptr, delim, &amp;str)) != EOF &amp;&amp; c != delim);

    if (!NIL_P(str)) {
	fptr-&gt;lineno++;
	lineno = INT2FIX(fptr-&gt;lineno);
	OBJ_TAINT(str);
    }

    return str;
}

static int
rscheck(rsptr, rslen, rs)
    const char *rsptr;
    long rslen;
    VALUE rs;
{
    if (RSTRING(rs)-&gt;ptr != rsptr &amp;&amp; RSTRING(rs)-&gt;len != rslen)
	rb_raise(rb_eRuntimeError, &quot;rs modified&quot;);
    return 1;
}

static VALUE rb_io_getline(VALUE rs, VALUE io);

static VALUE
rb_io_getline(rs, io)
    VALUE rs, io;
{
    VALUE str = Qnil;
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    if (NIL_P(rs)) {
	str = read_all(fptr, 0, Qnil);
	if (RSTRING(str)-&gt;len == 0) return Qnil;
    }
    else if (rs == rb_default_rs) {
	return rb_io_getline_fast(fptr, '\n');
    }
    else {
	int c, newline;
	const char *rsptr;
	long rslen;
	int rspara = 0;

	rslen = RSTRING(rs)-&gt;len;
	if (rslen == 0) {
	    rsptr = &quot;\n\n&quot;;
	    rslen = 2;
	    rspara = 1;
	    swallow(fptr, '\n');
	}
	else if (rslen == 1) {
	    return rb_io_getline_fast(fptr, (unsigned char)RSTRING(rs)-&gt;ptr[0]);
	}
	else {
	    rsptr = RSTRING(rs)-&gt;ptr;
	}
	newline = rsptr[rslen - 1];

	while ((c = appendline(fptr, newline, &amp;str)) != EOF &amp;&amp;
	       (c != newline || RSTRING(str)-&gt;len &lt; rslen ||
		((rspara || rscheck(rsptr,rslen,rs)) &amp;&amp; 0) ||
		memcmp(RSTRING(str)-&gt;ptr+RSTRING(str)-&gt;len-rslen,rsptr,rslen)));

	if (rspara) {
	    if (c != EOF) {
		swallow(fptr, '\n');
	    }
	}
    }

    if (!NIL_P(str)) {
	fptr-&gt;lineno++;
	lineno = INT2FIX(fptr-&gt;lineno);
	OBJ_TAINT(str);
    }

    return str;
}

VALUE
rb_io_gets(io)
    VALUE io;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    return rb_io_getline_fast(fptr, '\n');
}

/*
 *  call-seq:
 *     ios.gets(sep_string=$/)   =&gt; string or nil
 *  
 *  Reads the next ``line'' from the I/O stream; lines are separated by
 *  &lt;i&gt;sep_string&lt;/i&gt;. A separator of &lt;code&gt;nil&lt;/code&gt; reads the entire
 *  contents, and a zero-length separator reads the input a paragraph at
 *  a time (two successive newlines in the input separate paragraphs).
 *  The stream must be opened for reading or an &lt;code&gt;IOError&lt;/code&gt;
 *  will be raised. The line read in will be returned and also assigned
 *  to &lt;code&gt;$_&lt;/code&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if called at end of
 *  file.
 *     
 *     File.new(&quot;testfile&quot;).gets   #=&gt; &quot;This is line one\n&quot;
 *     $_                          #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_io_gets_m(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE rs, str;

    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, &quot;1&quot;, &amp;rs);
	if (!NIL_P(rs)) StringValue(rs);
    }
    str = rb_io_getline(rs, io);
    rb_lastline_set(str);

    return str;
}

/*
 *  call-seq:
 *     ios.lineno    =&gt; integer
 *  
 *  Returns the current line number in &lt;em&gt;ios&lt;/em&gt;. The stream must be
 *  opened for reading. &lt;code&gt;lineno&lt;/code&gt; counts the number of times
 *  &lt;code&gt;gets&lt;/code&gt; is called, rather than the number of newlines
 *  encountered. The two values will differ if &lt;code&gt;gets&lt;/code&gt; is
 *  called with a separator other than newline. See also the
 *  &lt;code&gt;$.&lt;/code&gt; variable.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.lineno   #=&gt; 0
 *     f.gets     #=&gt; &quot;This is line one\n&quot;
 *     f.lineno   #=&gt; 1
 *     f.gets     #=&gt; &quot;This is line two\n&quot;
 *     f.lineno   #=&gt; 2
 */

static VALUE
rb_io_lineno(io)
    VALUE io;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    return INT2NUM(fptr-&gt;lineno);
}

/*
 *  call-seq:
 *     ios.lineno = integer    =&gt; integer
 *  
 *  Manually sets the current line number to the given value.
 *  &lt;code&gt;$.&lt;/code&gt; is updated only on the next read.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.gets                     #=&gt; &quot;This is line one\n&quot;
 *     $.                         #=&gt; 1
 *     f.lineno = 1000
 *     f.lineno                   #=&gt; 1000
 *     $. # lineno of last read   #=&gt; 1
 *     f.gets                     #=&gt; &quot;This is line two\n&quot;
 *     $. # lineno of last read   #=&gt; 1001
 */

static VALUE
rb_io_set_lineno(io, lineno)
    VALUE io, lineno;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    fptr-&gt;lineno = NUM2INT(lineno);
    return lineno;
}

static void
lineno_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    gets_lineno = NUM2INT(val);
    *var = INT2FIX(gets_lineno);
}

static VALUE
argf_set_lineno(argf, val)
    VALUE argf, val;
{
    gets_lineno = NUM2INT(val);
    lineno = INT2FIX(gets_lineno);
    return Qnil;
}

static VALUE
argf_lineno()
{
    return lineno;
}

/*
 *  call-seq:
 *     ios.readline(sep_string=$/)   =&gt; string
 *  
 *  Reads a line as with &lt;code&gt;IO#gets&lt;/code&gt;, but raises an
 *  &lt;code&gt;EOFError&lt;/code&gt; on end of file.
 */

static VALUE
rb_io_readline(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE line = rb_io_gets_m(argc, argv, io);

    if (NIL_P(line)) {
	rb_eof_error();
    }
    return line;
}

/*
 *  call-seq:
 *     ios.readlines(sep_string=$/)  =&gt;   array
 *  
 *  Reads all of the lines in &lt;em&gt;ios&lt;/em&gt;, and returns them in
 *  &lt;i&gt;anArray&lt;/i&gt;. Lines are separated by the optional
 *  &lt;i&gt;sep_string&lt;/i&gt;. If &lt;i&gt;sep_string&lt;/i&gt; is &lt;code&gt;nil&lt;/code&gt;, the
 *  rest of the stream is returned as a single record.
 *  The stream must be opened for reading or an
 *  &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.readlines[0]   #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_io_readlines(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE line, ary;
    VALUE rs;

    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, &quot;1&quot;, &amp;rs);
	if (!NIL_P(rs)) StringValue(rs);
    }
    ary = rb_ary_new();
    while (!NIL_P(line = rb_io_getline(rs, io))) {
	rb_ary_push(ary, line);
    }
    return ary;
}

/*
 *  call-seq:
 *     ios.each(sep_string=$/)      {|line| block }  =&gt; ios
 *     ios.each_line(sep_string=$/) {|line| block }  =&gt; ios
 *  
 *  Executes the block for every line in &lt;em&gt;ios&lt;/em&gt;, where lines are
 *  separated by &lt;i&gt;sep_string&lt;/i&gt;. &lt;em&gt;ios&lt;/em&gt; must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     1: This is line one
 *     2: This is line two
 *     3: This is line three
 *     4: And so on...
 */

static VALUE
rb_io_each_line(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE str;
    VALUE rs;

    RETURN_ENUMERATOR(io, argc, argv);
    if (argc == 0) {
	rs = rb_rs;
    }
    else {
	rb_scan_args(argc, argv, &quot;1&quot;, &amp;rs);
	if (!NIL_P(rs)) StringValue(rs);
    }
    while (!NIL_P(str = rb_io_getline(rs, io))) {
	rb_yield(str);
    }
    return io;
}

/*
 *  call-seq:
 *     ios.each_byte {|byte| block }  =&gt; ios
 *  
 *  Calls the given block once for each byte (0..255) in &lt;em&gt;ios&lt;/em&gt;,
 *  passing the byte as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     checksum = 0
 *     f.each_byte {|x| checksum ^= x }   #=&gt; #&lt;File:testfile&gt;
 *     checksum                           #=&gt; 12
 */

static VALUE
rb_io_each_byte(io)
    VALUE io;
{
    rb_io_t *fptr;
    FILE *f;
    int c;

    RETURN_ENUMERATOR(io, 0, 0);
    GetOpenFile(io, fptr);

    for (;;) {
	rb_io_check_readable(fptr);
	f = fptr-&gt;f;
	READ_CHECK(f);
	clearerr(f);
	TRAP_BEG;
	c = getc(f);
	TRAP_END;
	if (c == EOF) {
	    if (ferror(f)) {
		clearerr(f);
		if (!rb_io_wait_readable(fileno(f)))
		    rb_sys_fail(fptr-&gt;path);
		continue;
	    }
	    break;
	}
	rb_yield(INT2FIX(c &amp; 0xff));
    }
    if (ferror(f)) rb_sys_fail(fptr-&gt;path);
    return io;
}

VALUE rb_io_getc _((VALUE));

/*
 *  call-seq:
 *     ios.each_char {|c| block }  =&gt; ios
 *
 *  Calls the given block once for each character in &lt;em&gt;ios&lt;/em&gt;,
 *  passing the character as an argument. The stream must be opened for
 *  reading or an &lt;code&gt;IOError&lt;/code&gt; will be raised.  Multibyte
 *  characters are dealt with according to $KCODE.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.each_char {|c| print c, ' ' }   #=&gt; #&lt;File:testfile&gt;
 */

static VALUE
rb_io_each_char(io)
    VALUE io;
{
    VALUE ch;

    RETURN_ENUMERATOR(io, 0, 0);

    while (!NIL_P(ch = rb_io_getc(io))) {
	unsigned char c;
	int n;
	VALUE str;

	c= FIX2INT(ch);
	n = mbclen(c);
	str = rb_tainted_str_new((const char *)&amp;c, 1);

	while (--n &gt; 0) {
	    if (NIL_P(ch = rb_io_getc(io))) {
		rb_yield(str);
		return io;
	    }
	    c = FIX2INT(ch);
	    rb_str_cat(str, (const char *)&amp;c, 1);
	}
	rb_yield(str);
    }
    return io;
}

/*
 *  call-seq:
 *     ios.lines(sep=$/)     =&gt; anEnumerator
 *     ios.lines(limit)      =&gt; anEnumerator
 *     ios.lines(sep, limit) =&gt; anEnumerator
 *
 *  Returns an enumerator that gives each line in &lt;em&gt;ios&lt;/em&gt;.
 *  The stream must be opened for reading or an &lt;code&gt;IOError&lt;/code&gt;
 *  will be raised.
 *
 *     f = File.new(&quot;testfile&quot;)
 *     f.lines.to_a  #=&gt; [&quot;foo\n&quot;, &quot;bar\n&quot;]
 *     f.rewind
 *     f.lines.sort  #=&gt; [&quot;bar\n&quot;, &quot;foo\n&quot;]
 */

static VALUE
rb_io_lines(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    return rb_enumeratorize(io, ID2SYM(rb_intern(&quot;each_line&quot;)), argc, argv);
}

/*
 *  call-seq:
 *     ios.bytes   =&gt; anEnumerator
 *
 *  Returns an enumerator that gives each byte (0..255) in &lt;em&gt;ios&lt;/em&gt;.
 *  The stream must be opened for reading or an &lt;code&gt;IOError&lt;/code&gt;
 *  will be raised.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.bytes.to_a  #=&gt; [104, 101, 108, 108, 111]
 *     f.rewind
 *     f.bytes.sort  #=&gt; [101, 104, 108, 108, 111]
 */

static VALUE
rb_io_bytes(io)
    VALUE io;
{
    return rb_enumeratorize(io, ID2SYM(rb_intern(&quot;each_byte&quot;)), 0, 0);
}

/*
 *  call-seq:
 *     ios.getc   =&gt; fixnum or nil
 *  
 *  Gets the next 8-bit byte (0..255) from &lt;em&gt;ios&lt;/em&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if called at end of file.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.getc   #=&gt; 84
 *     f.getc   #=&gt; 104
 */

VALUE
rb_io_getc(io)
    VALUE io;
{
    rb_io_t *fptr;
    FILE *f;
    int c;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);
    f = fptr-&gt;f;

  retry:
    READ_CHECK(f);
    clearerr(f);
    TRAP_BEG;
    c = getc(f);
    TRAP_END;

    if (c == EOF) {
	if (ferror(f)) {
	    clearerr(f);
	    if (!rb_io_wait_readable(fileno(f)))
		rb_sys_fail(fptr-&gt;path);
	    goto retry;
	}
	return Qnil;
    }
    return INT2FIX(c &amp; 0xff);
}

int
rb_getc(f)
    FILE *f;
{
    int c;

    if (!READ_DATA_PENDING(f)) {
	rb_thread_wait_fd(fileno(f));
    }
    clearerr(f);
    TRAP_BEG;
    c = getc(f);
    TRAP_END;

    return c;
}

/*
 *  call-seq:
 *     ios.readchar   =&gt; fixnum
 *  
 *  Reads a character as with &lt;code&gt;IO#getc&lt;/code&gt;, but raises an
 *  &lt;code&gt;EOFError&lt;/code&gt; on end of file.
 */

static VALUE
rb_io_readchar(io)
    VALUE io;
{
    VALUE c = rb_io_getc(io);

    if (NIL_P(c)) {
	rb_eof_error();
    }
    return c;
}

/*
 *  call-seq:
 *     ios.ungetc(integer)   =&gt; nil
 *  
 *  Pushes back one character (passed as a parameter) onto &lt;em&gt;ios&lt;/em&gt;,
 *  such that a subsequent buffered read will return it. Only one character
 *  may be pushed back before a subsequent read operation (that is,
 *  you will be able to read only the last of several characters that have been pushed
 *  back). Has no effect with unbuffered reads (such as &lt;code&gt;IO#sysread&lt;/code&gt;).
 *     
 *     f = File.new(&quot;testfile&quot;)   #=&gt; #&lt;File:testfile&gt;
 *     c = f.getc                 #=&gt; 84
 *     f.ungetc(c)                #=&gt; nil
 *     f.getc                     #=&gt; 84
 */

VALUE
rb_io_ungetc(io, c)
    VALUE io, c;
{
    rb_io_t *fptr;
    int cc = NUM2INT(c);

    GetOpenFile(io, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_RBUF))
	rb_raise(rb_eIOError, &quot;unread stream&quot;);
    rb_io_check_readable(fptr);

    if (ungetc(cc, fptr-&gt;f) == EOF &amp;&amp; cc != EOF) {
	rb_raise(rb_eIOError, &quot;ungetc failed&quot;);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     ios.isatty   =&gt; true or false
 *     ios.tty?     =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;ios&lt;/em&gt; is associated with a
 *  terminal device (tty), &lt;code&gt;false&lt;/code&gt; otherwise.
 *     
 *     File.new(&quot;testfile&quot;).isatty   #=&gt; false
 *     File.new(&quot;/dev/tty&quot;).isatty   #=&gt; true
 */

static VALUE
rb_io_isatty(io)
    VALUE io;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (isatty(fileno(fptr-&gt;f)) == 0)
	return Qfalse;
    return Qtrue;
}

static void
fptr_finalize(fptr, noraise)
    rb_io_t *fptr;
    int noraise;
{
    int n1 = 0, n2 = 0, f1, f2 = -1;

    errno = 0;
    if (fptr-&gt;f2) {
	f2 = fileno(fptr-&gt;f2);
	while (n2 = 0, fflush(fptr-&gt;f2) &lt; 0) {
	    n2 = errno;
	    if (!rb_io_wait_writable(f2)) {
		break;
	    }
	    if (!fptr-&gt;f2) break;
	}
	if (fclose(fptr-&gt;f2) &lt; 0 &amp;&amp; n2 == 0) {
	    n2 = errno;
	}
	fptr-&gt;f2 = 0;
    }
    if (fptr-&gt;f) {
	f1 = fileno(fptr-&gt;f);
	if ((f2 == -1) &amp;&amp; (fptr-&gt;mode &amp; FMODE_WBUF)) {
	    while (n1 = 0, fflush(fptr-&gt;f) &lt; 0) {
		n1 = errno;
		if (!rb_io_wait_writable(f1)) break;
		if (!fptr-&gt;f) break;
	    }
	}
	if (fclose(fptr-&gt;f) &lt; 0 &amp;&amp; n1 == 0) {
	    n1 = errno;
	}
	fptr-&gt;f = 0;
	if (n1 == EBADF &amp;&amp; f1 == f2) {
	    n1 = 0;
	}
    }
    if (!noraise &amp;&amp; (n1 || n2)) {
	errno = (n1 ? n1 : n2);
	rb_sys_fail(fptr-&gt;path);
    }
}

static void
rb_io_fptr_cleanup(fptr, noraise)
    rb_io_t *fptr;
    int noraise;
{
    if (fptr-&gt;finalize) {
	(*fptr-&gt;finalize)(fptr, noraise);
    }
    else {
	fptr_finalize(fptr, noraise);
    }
}

void
rb_io_fptr_finalize(fptr)
    rb_io_t *fptr;
{
    if (!fptr) return;
    if (fptr-&gt;path) {
	free(fptr-&gt;path);
    }
    if (!fptr-&gt;f &amp;&amp; !fptr-&gt;f2) return;
    if (fileno(fptr-&gt;f) &lt; 3) return;

    rb_io_fptr_cleanup(fptr, Qtrue);
}

VALUE
rb_io_close(io)
    VALUE io;
{
    rb_io_t *fptr;
    int fd, fd2;

    fptr = RFILE(io)-&gt;fptr;
    if (!fptr) return Qnil;
    if (fptr-&gt;f2) {
	fd2 = fileno(fptr-&gt;f2);
    }
    else {
	if (!fptr-&gt;f) return Qnil;
	fd2 = -1;
    }

    fd = fileno(fptr-&gt;f);
    rb_io_fptr_cleanup(fptr, Qfalse);
    rb_thread_fd_close(fd);
    if (fd2 &gt;= 0) rb_thread_fd_close(fd2);

    if (fptr-&gt;pid) {
	rb_syswait(fptr-&gt;pid);
	fptr-&gt;pid = 0;
    }

    return Qnil;
}

/*
 *  call-seq:
 *     ios.close   =&gt; nil
 *  
 *  Closes &lt;em&gt;ios&lt;/em&gt; and flushes any pending writes to the operating
 *  system. The stream is unavailable for any further data operations;
 *  an &lt;code&gt;IOError&lt;/code&gt; is raised if such an attempt is made. I/O
 *  streams are automatically closed when they are claimed by the
 *  garbage collector.
 *
 *  If &lt;em&gt;ios&lt;/em&gt; is opened by &lt;code&gt;IO.popen&lt;/code&gt;,
 *  &lt;code&gt;close&lt;/code&gt; sets &lt;code&gt;$?&lt;/code&gt;.
 */

static VALUE
rb_io_close_m(io)
    VALUE io;
{
    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(io)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't close&quot;);
    }
    rb_io_check_closed(RFILE(io)-&gt;fptr);
    rb_io_close(io);
    return Qnil;
}

static VALUE
io_call_close(io)
    VALUE io;
{
    return rb_funcall(io, rb_intern(&quot;close&quot;), 0, 0);
}

static VALUE
io_close(io)
    VALUE io;
{
    return rb_rescue(io_call_close, io, 0, 0);
}

/*
 *  call-seq:
 *     ios.closed?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;ios&lt;/em&gt; is completely closed (for
 *  duplex streams, both reader and writer), &lt;code&gt;false&lt;/code&gt;
 *  otherwise.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.close         #=&gt; nil
 *     f.closed?       #=&gt; true
 *     f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
 *     f.close_write   #=&gt; nil
 *     f.closed?       #=&gt; false
 *     f.close_read    #=&gt; nil
 *     f.closed?       #=&gt; true
 */

static VALUE
rb_io_closed(io)
    VALUE io;
{
    rb_io_t *fptr;

    fptr = RFILE(io)-&gt;fptr;
    rb_io_check_initialized(fptr);
    return (fptr-&gt;f || fptr-&gt;f2)?Qfalse:Qtrue;
}

/*
 *  call-seq:
 *     ios.close_read    =&gt; nil
 *  
 *  Closes the read end of a duplex I/O stream (i.e., one that contains
 *  both a read and a write stream, such as a pipe). Will raise an
 *  &lt;code&gt;IOError&lt;/code&gt; if the stream is not duplexed.
 *     
 *     f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
 *     f.close_read
 *     f.readlines
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     prog.rb:3:in `readlines': not opened for reading (IOError)
 *     	from prog.rb:3
 */

static VALUE
rb_io_close_read(io)
    VALUE io;
{
    rb_io_t *fptr;
    int n;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(io)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't close&quot;);
    }
    GetOpenFile(io, fptr);
    if (fptr-&gt;f2 == 0 &amp;&amp; (fptr-&gt;mode &amp; FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, &quot;closing non-duplex IO for reading&quot;);
    }
    if (fptr-&gt;f2 == 0) {
	return rb_io_close(io);
    }
    n = fclose(fptr-&gt;f);
    fptr-&gt;mode &amp;= ~FMODE_READABLE;
    fptr-&gt;f = fptr-&gt;f2;
    fptr-&gt;f2 = 0;
    if (n != 0) rb_sys_fail(fptr-&gt;path);

    return Qnil;
}

/*
 *  call-seq:
 *     ios.close_write   =&gt; nil
 *  
 *  Closes the write end of a duplex I/O stream (i.e., one that contains
 *  both a read and a write stream, such as a pipe). Will raise an
 *  &lt;code&gt;IOError&lt;/code&gt; if the stream is not duplexed.
 *     
 *     f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)
 *     f.close_write
 *     f.print &quot;nowhere&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     prog.rb:3:in `write': not opened for writing (IOError)
 *     	from prog.rb:3:in `print'
 *     	from prog.rb:3
 */

static VALUE
rb_io_close_write(io)
    VALUE io;
{
    rb_io_t *fptr;
    int n;

    if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(io)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't close&quot;);
    }
    GetOpenFile(io, fptr);
    if (fptr-&gt;f2 == 0 &amp;&amp; (fptr-&gt;mode &amp; FMODE_READABLE)) {
	rb_raise(rb_eIOError, &quot;closing non-duplex IO for writing&quot;);
    }
    if (fptr-&gt;f2 == 0) {
	return rb_io_close(io);
    }
    n = fclose(fptr-&gt;f2);
    fptr-&gt;f2 = 0;
    fptr-&gt;mode &amp;= ~FMODE_WRITABLE;
    if (n != 0) rb_sys_fail(fptr-&gt;path);

    return Qnil;
}

/*
 *  call-seq:
 *     ios.sysseek(offset, whence=SEEK_SET)   =&gt; integer
 *  
 *  Seeks to a given &lt;i&gt;offset&lt;/i&gt; in the stream according to the value
 *  of &lt;i&gt;whence&lt;/i&gt; (see &lt;code&gt;IO#seek&lt;/code&gt; for values of
 *  &lt;i&gt;whence&lt;/i&gt;). Returns the new offset into the file.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.sysseek(-13, IO::SEEK_END)   #=&gt; 53
 *     f.sysread(10)                  #=&gt; &quot;And so on.&quot;
 */

static VALUE
rb_io_sysseek(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE offset, ptrname;
    int whence = SEEK_SET;
    rb_io_t *fptr;
    off_t pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;offset, &amp;ptrname) == 2) {
	whence = NUM2INT(ptrname);
    }
    pos = NUM2OFFT(offset);
    GetOpenFile(io, fptr);
    if ((fptr-&gt;mode &amp; FMODE_READABLE) &amp;&amp; READ_DATA_BUFFERED(fptr-&gt;f)) {
	rb_raise(rb_eIOError, &quot;sysseek for buffered IO&quot;);
    }
    if ((fptr-&gt;mode &amp; FMODE_WRITABLE) &amp;&amp; (fptr-&gt;mode &amp; FMODE_WBUF)) {
	rb_warn(&quot;sysseek for buffered IO&quot;);
    }
    pos = lseek(fileno(fptr-&gt;f), pos, whence);
    if (pos == -1) rb_sys_fail(fptr-&gt;path);
    clearerr(fptr-&gt;f);

    return OFFT2NUM(pos);
}

/*
 *  call-seq:
 *     ios.syswrite(string)   =&gt; integer
 *  
 *  Writes the given string to &lt;em&gt;ios&lt;/em&gt; using a low-level write.
 *  Returns the number of bytes written. Do not mix with other methods
 *  that write to &lt;em&gt;ios&lt;/em&gt; or you may get unpredictable results.
 *  Raises &lt;code&gt;SystemCallError&lt;/code&gt; on error.
 *     
 *     f = File.new(&quot;out&quot;, &quot;w&quot;)
 *     f.syswrite(&quot;ABCDEF&quot;)   #=&gt; 6
 */

static VALUE
rb_io_syswrite(io, str)
    VALUE io, str;
{
    rb_io_t *fptr;
    FILE *f;
    long n;

    rb_secure(4);
    if (TYPE(str) != T_STRING)
	str = rb_obj_as_string(str);

    GetOpenFile(io, fptr);
    rb_io_check_writable(fptr);
    f = GetWriteFile(fptr);

    if (fptr-&gt;mode &amp; FMODE_WBUF) {
	rb_warn(&quot;syswrite for buffered IO&quot;);
    }
    if (!rb_thread_fd_writable(fileno(f))) {
        rb_io_check_closed(fptr);
    }
    TRAP_BEG;
    n = write(fileno(f), RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len);
    TRAP_END;

    if (n == -1) rb_sys_fail(fptr-&gt;path);

    return LONG2FIX(n);
}

/*
 *  call-seq:
 *     ios.sysread(integer )    =&gt; string
 *  
 *  Reads &lt;i&gt;integer&lt;/i&gt; bytes from &lt;em&gt;ios&lt;/em&gt; using a low-level
 *  read and returns them as a string. Do not mix with other methods
 *  that read from &lt;em&gt;ios&lt;/em&gt; or you may get unpredictable results.
 *  Raises &lt;code&gt;SystemCallError&lt;/code&gt; on error and
 *  &lt;code&gt;EOFError&lt;/code&gt; at end of file.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     f.sysread(16)   #=&gt; &quot;This is line one&quot;
 */

static VALUE
rb_io_sysread(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE len, str;
    rb_io_t *fptr;
    long n, ilen;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;len, &amp;str);
    ilen = NUM2LONG(len);

    if (NIL_P(str)) {
	str = rb_str_new(0, ilen);
    }
    else {
	StringValue(str);
	rb_str_modify(str);
	rb_str_resize(str, ilen);
    }
    if (ilen == 0) return str;

    GetOpenFile(io, fptr);
    rb_io_check_readable(fptr);

    if (READ_DATA_BUFFERED(fptr-&gt;f)) {
	rb_raise(rb_eIOError, &quot;sysread for buffered IO&quot;);
    }
    rb_str_locktmp(str);

    n = fileno(fptr-&gt;f);
    rb_thread_wait_fd(fileno(fptr-&gt;f));
    rb_io_check_closed(fptr);
    if (RSTRING(str)-&gt;len != ilen) {
	rb_raise(rb_eRuntimeError, &quot;buffer string modified&quot;);
    }
    TRAP_BEG;
    n = read(fileno(fptr-&gt;f), RSTRING(str)-&gt;ptr, ilen);
    TRAP_END;

    rb_str_unlocktmp(str);
    if (n == -1) {
	rb_sys_fail(fptr-&gt;path);
    }
    rb_str_resize(str, n);
    if (n == 0 &amp;&amp; ilen &gt; 0) {
	rb_eof_error();
    }
    RSTRING(str)-&gt;len = n;
    RSTRING(str)-&gt;ptr[n] = '\0';
    OBJ_TAINT(str);

    return str;
}

/*
 *  call-seq:
 *     ios.binmode    =&gt; ios
 *  
 *  Puts &lt;em&gt;ios&lt;/em&gt; into binary mode. This is useful only in
 *  MS-DOS/Windows environments. Once a stream is in binary mode, it
 *  cannot be reset to nonbinary mode.
 */

VALUE
rb_io_binmode(io)
    VALUE io;
{
#if defined(_WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__) || defined(__EMX__)
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
#ifdef __human68k__
    if (fptr-&gt;f)
	fmode(fptr-&gt;f, _IOBIN);
    if (fptr-&gt;f2)
	fmode(fptr-&gt;f2, _IOBIN);
#else
    if (fptr-&gt;f &amp;&amp; setmode(fileno(fptr-&gt;f), O_BINARY) == -1)
	rb_sys_fail(fptr-&gt;path);
    if (fptr-&gt;f2 &amp;&amp; setmode(fileno(fptr-&gt;f2), O_BINARY) == -1)
	rb_sys_fail(fptr-&gt;path);
#endif

    fptr-&gt;mode |= FMODE_BINMODE;
#endif
    return io;
}

const char*
rb_io_flags_mode(flags)
    int flags;
{
#ifdef O_BINARY
# define MODE_BINMODE(a,b) ((flags &amp; FMODE_BINMODE) ? (b) : (a))
#else
# define MODE_BINMODE(a,b) (a)
#endif
    if (flags &amp; FMODE_APPEND) {
	if ((flags &amp; FMODE_READWRITE) == FMODE_READWRITE) {
	    return MODE_BINMODE(&quot;a+&quot;, &quot;ab+&quot;);
	}
	return MODE_BINMODE(&quot;a&quot;, &quot;ab&quot;);
    }
    switch (flags &amp; FMODE_READWRITE) {
      case FMODE_READABLE:
	return MODE_BINMODE(&quot;r&quot;, &quot;rb&quot;);
      case FMODE_WRITABLE:
	return MODE_BINMODE(&quot;w&quot;, &quot;wb&quot;);
      case FMODE_READWRITE:
	if (flags &amp; FMODE_CREATE) {
	    return MODE_BINMODE(&quot;w+&quot;, &quot;wb+&quot;);
	}
	return MODE_BINMODE(&quot;r+&quot;, &quot;rb+&quot;);
    }
    rb_raise(rb_eArgError, &quot;illegal access modenum %o&quot;, flags);
    return NULL;		/* not reached */
}

int
rb_io_mode_flags(mode)
    const char *mode;
{
    int flags = 0;
    const char *m = mode;

    switch (*m++) {
      case 'r':
	flags |= FMODE_READABLE;
	break;
      case 'w':
	flags |= FMODE_WRITABLE | FMODE_CREATE;
	break;
      case 'a':
	flags |= FMODE_WRITABLE | FMODE_APPEND | FMODE_CREATE;
	break;
      default:
      error:
	rb_raise(rb_eArgError, &quot;illegal access mode %s&quot;, mode);
    }

    while (*m) {
        switch (*m++) {
        case 'b':
            flags |= FMODE_BINMODE;
            break;
        case '+':
            flags |= FMODE_READWRITE;
            break;
        case ':':
            /* forward compatibility */
            rb_warning(&quot;encoding options not supported in 1.8: %s&quot;, mode);
            goto end;
        default:
            goto error;
        }
    }

 end:
    return flags;
}

int
rb_io_modenum_flags(mode)
    int mode;
{
    int flags = 0;

    switch (mode &amp; (O_RDONLY|O_WRONLY|O_RDWR)) {
      case O_RDONLY:
	flags = FMODE_READABLE;
	break;
      case O_WRONLY:
	flags = FMODE_WRITABLE;
	break;
      case O_RDWR:
	flags = FMODE_READWRITE;
	break;
    }

    if (mode &amp; O_APPEND) {
	flags |= FMODE_APPEND;
    }
    if (mode &amp; O_CREAT) {
	flags |= FMODE_CREATE;
    }
#ifdef O_BINARY
    if (mode &amp; O_BINARY) {
	flags |= FMODE_BINMODE;
    }
#endif

    return flags;
}

static int
rb_io_mode_modenum(mode)
    const char *mode;
{
    int flags = 0;
    const char *m = mode;

    switch (*m++) {
      case 'r':
	flags |= O_RDONLY;
	break;
      case 'w':
	flags |= O_WRONLY | O_CREAT | O_TRUNC;
	break;
      case 'a':
	flags |= O_WRONLY | O_CREAT | O_APPEND;
	break;
      default:
      error:
	rb_raise(rb_eArgError, &quot;illegal access mode %s&quot;, mode);
    }

    while (*m) {
        switch (*m++) {
        case 'b':
#ifdef O_BINARY
            flags |= O_BINARY;
#endif
            break;
        case '+':
            flags = (flags &amp; ~O_ACCMODE) | O_RDWR;
            break;
        case ':':
            /* forward compatibility */
            rb_warning(&quot;encoding options not supported in 1.8: %s&quot;, mode);
            goto end;
        default:
            goto error;
        }
    }

 end:
    return flags;
}

#define MODENUM_MAX 4

static const char*
rb_io_modenum_mode(flags)
    int flags;
{
#ifdef O_BINARY
# define MODE_BINARY(a,b) ((flags &amp; O_BINARY) ? (b) : (a))
#else
# define MODE_BINARY(a,b) (a)
#endif
    if (flags &amp; O_APPEND) {
	if ((flags &amp; O_RDWR) == O_RDWR) {
	    return MODE_BINARY(&quot;a+&quot;, &quot;ab+&quot;);
	}
	return MODE_BINARY(&quot;a&quot;, &quot;ab&quot;);
    }
    switch (flags &amp; (O_RDONLY|O_WRONLY|O_RDWR)) {
      case O_RDONLY:
	return MODE_BINARY(&quot;r&quot;, &quot;rb&quot;);
      case O_WRONLY:
	return MODE_BINARY(&quot;w&quot;, &quot;wb&quot;);
      case O_RDWR:
	return MODE_BINARY(&quot;r+&quot;, &quot;rb+&quot;);
    }
    rb_raise(rb_eArgError, &quot;illegal access modenum %o&quot;, flags);
    return NULL;		/* not reached */
}

static int
rb_sysopen(fname, flags, mode)
    char *fname;
    int flags;
    unsigned int mode;
{
    int fd;

    fd = open(fname, flags, mode);
    if (fd &lt; 0) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    fd = open(fname, flags, mode);
	}
	if (fd &lt; 0) {
	    rb_sys_fail(fname);
	}
    }
    return fd;
}

FILE *
rb_fopen(fname, mode)
    const char *fname;
    const char *mode;
{
    FILE *file;

    file = fopen(fname, mode);
    if (!file) {
	if (errno == EMFILE || errno == ENFILE) {
	    rb_gc();
	    file = fopen(fname, mode);
	}
	if (!file) {
	    rb_sys_fail(fname);
	}
    }
#ifdef USE_SETVBUF
    if (setvbuf(file, NULL, _IOFBF, 0) != 0)
	rb_warn(&quot;setvbuf() can't be honoured for %s&quot;, fname);
#endif
#ifdef __human68k__
    fmode(file, _IOTEXT);
#endif
    return file;
}

FILE *
rb_fdopen(fd, mode)
    int fd;
    const char *mode;
{
    FILE *file;

#if defined(sun)
    errno = 0;
#endif
    file = fdopen(fd, mode);
    if (!file) {
#if defined(sun)
	if (errno == 0 || errno == EMFILE || errno == ENFILE) {
#else
	if (errno == EMFILE || errno == ENFILE) {
#endif
	    rb_gc();
#if defined(sun)
	    errno = 0;
#endif
	    file = fdopen(fd, mode);
	}
	if (!file) {
#ifdef _WIN32
	    if (errno == 0) errno = EINVAL;
#endif
#if defined(sun)
	    if (errno == 0) errno = EMFILE;
#endif
	    rb_sys_fail(0);
	}
    }

#ifdef USE_SETVBUF
    if (setvbuf(file, NULL, _IOFBF, 0) != 0)
	rb_warn(&quot;setvbuf() can't be honoured (fd=%d)&quot;, fd);
#endif
    return file;
}

static VALUE
rb_file_open_internal(io, fname, mode)
    VALUE io;
    const char *fname, *mode;
{
    rb_io_t *fptr;

    MakeOpenFile(io, fptr);

    fptr-&gt;mode = rb_io_mode_flags(mode);
    fptr-&gt;path = strdup(fname);
    fptr-&gt;f = rb_fopen(fptr-&gt;path, rb_io_flags_mode(fptr-&gt;mode));

    return io;
}

VALUE
rb_file_open(fname, mode)
    const char *fname, *mode;
{
    return rb_file_open_internal(io_alloc(rb_cFile), fname, mode);
}

static VALUE
rb_file_sysopen_internal(io, fname, flags, mode)
    VALUE io;
    char *fname;
    int flags, mode;
{
    rb_io_t *fptr;
    int fd;
    const char *m;

    MakeOpenFile(io, fptr);

    fptr-&gt;path = strdup(fname);
    m = rb_io_modenum_mode(flags);
    fptr-&gt;mode = rb_io_modenum_flags(flags);
    fd = rb_sysopen(fptr-&gt;path, flags, mode);
    fptr-&gt;f = rb_fdopen(fd, m);

    return io;
}

VALUE
rb_file_sysopen(fname, flags, mode)
    const char *fname;
    int flags, mode;
{
    return rb_file_sysopen_internal(io_alloc(rb_cFile), fname, flags, mode);
}

#if defined (_WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__) || defined(__VMS)
static struct pipe_list {
    rb_io_t *fptr;
    struct pipe_list *next;
} *pipe_list;

static void
pipe_add_fptr(fptr)
    rb_io_t *fptr;
{
    struct pipe_list *list;

    list = ALLOC(struct pipe_list);
    list-&gt;fptr = fptr;
    list-&gt;next = pipe_list;
    pipe_list = list;
}

static void
pipe_del_fptr(fptr)
    rb_io_t *fptr;
{
    struct pipe_list *list = pipe_list;
    struct pipe_list *tmp;

    if (list-&gt;fptr == fptr) {
	pipe_list = list-&gt;next;
	free(list);
	return;
    }

    while (list-&gt;next) {
	if (list-&gt;next-&gt;fptr == fptr) {
	    tmp = list-&gt;next;
	    list-&gt;next = list-&gt;next-&gt;next;
	    free(tmp);
	    return;
	}
	list = list-&gt;next;
    }
}

static void
pipe_atexit _((void))
{
    struct pipe_list *list = pipe_list;
    struct pipe_list *tmp;

    while (list) {
	tmp = list-&gt;next;
	rb_io_fptr_finalize(list-&gt;fptr);
	list = tmp;
    }
}

static void pipe_finalize _((rb_io_t *fptr,int));

static void
pipe_finalize(fptr, noraise)
    rb_io_t *fptr;
    int noraise;
{
#if !defined (__CYGWIN__) &amp;&amp; !defined(_WIN32)
    extern VALUE rb_last_status;
    int status;
    if (fptr-&gt;f) {
	status = pclose(fptr-&gt;f);
    }
    if (fptr-&gt;f2) {
	status = pclose(fptr-&gt;f2);
    }
    fptr-&gt;f = fptr-&gt;f2 = 0;
#if defined DJGPP
    status &lt;&lt;= 8;
#endif
    rb_last_status = INT2FIX(status);
#else
    fptr_finalize(fptr, noraise);
#endif
    pipe_del_fptr(fptr);
}
#endif

void
rb_io_synchronized(fptr)
    rb_io_t *fptr;
{
    fptr-&gt;mode |= FMODE_SYNC;
}

void
rb_io_unbuffered(fptr)
    rb_io_t *fptr;
{
    rb_io_synchronized(fptr);
}

static VALUE pipe_open(VALUE pstr, const char *pname, const char *mode);

static VALUE
pipe_open(pstr, pname, mode)
    VALUE pstr;
    const char *pname, *mode;
{
    int modef = rb_io_mode_flags(mode);
    rb_io_t *fptr;
#if defined(DJGPP) || defined(__human68k__) || defined(__VMS)
    FILE *f;
#else
    int pid;
#ifdef _WIN32
    FILE *fpr, *fpw;
#else
    int pr[2], pw[2];
#endif
#endif
    volatile int doexec;

    if (!pname) pname = StringValueCStr(pstr);
    doexec = (strcmp(&quot;-&quot;, pname) != 0);

#if defined(DJGPP) || defined(__human68k__) || defined(__VMS) || defined(_WIN32)
    if (!doexec) {
	rb_raise(rb_eNotImpError,
		 &quot;fork() function is unimplemented on this machine&quot;);
    }
#endif

#if defined(DJGPP) || defined(__human68k__) || defined(__VMS)
    f = popen(pname, mode);
    
    if (!f) rb_sys_fail(pname);
    else {
	VALUE port = io_alloc(rb_cIO);

	MakeOpenFile(port, fptr);
	fptr-&gt;finalize = pipe_finalize;
	fptr-&gt;mode = modef;

	pipe_add_fptr(fptr);
	if (modef &amp; FMODE_READABLE) fptr-&gt;f  = f;
	if (modef &amp; FMODE_WRITABLE) {
	    if (fptr-&gt;f) fptr-&gt;f2 = f;
	    else fptr-&gt;f = f;
	    rb_io_synchronized(fptr);
	}
	return (VALUE)port;
    }
#else
#ifdef _WIN32
retry:
    pid = pipe_exec(pname, rb_io_mode_modenum(mode), &amp;fpr, &amp;fpw);
    if (pid == -1) {		/* exec failed */
	if (errno == EAGAIN) {
	    rb_thread_sleep(1);
	    goto retry;
	}
	rb_sys_fail(pname);
    }
    else {
        VALUE port = io_alloc(rb_cIO);

	MakeOpenFile(port, fptr);
	fptr-&gt;mode = modef;
	fptr-&gt;mode |= FMODE_SYNC;
	fptr-&gt;pid = pid;

	if (modef &amp; FMODE_READABLE) {
	    fptr-&gt;f = fpr;
	}
	if (modef &amp; FMODE_WRITABLE) {
	    if (fptr-&gt;f) fptr-&gt;f2 = fpw;
	    else fptr-&gt;f = fpw;
	}
	fptr-&gt;finalize = pipe_finalize;
	pipe_add_fptr(fptr);
	return (VALUE)port;
    }
#else
    if (((modef &amp; FMODE_READABLE) &amp;&amp; pipe(pr) == -1) ||
	((modef &amp; FMODE_WRITABLE) &amp;&amp; pipe(pw) == -1))
	rb_sys_fail(pname);

    if (!doexec) {
	fflush(stdin);		/* is it really needed? */
	fflush(stdout);
	fflush(stderr);
    }

  retry:
    switch ((pid = fork())) {
      case 0:			/* child */
	if (modef &amp; FMODE_READABLE) {
	    close(pr[0]);
	    if (pr[1] != 1) {
		dup2(pr[1], 1);
		close(pr[1]);
	    }
	}
	if (modef &amp; FMODE_WRITABLE) {
	    close(pw[1]);
	    if (pw[0] != 0) {
		dup2(pw[0], 0);
		close(pw[0]);
	    }
	}

	if (doexec) {
	    int fd;

	    for (fd = 3; fd &lt; NOFILE; fd++)
		close(fd);
	    rb_proc_exec(pname);
	    fprintf(stderr, &quot;%s:%d: command not found: %s\n&quot;,
		    ruby_sourcefile, ruby_sourceline, pname);
	    _exit(127);
	}
	rb_io_synchronized(RFILE(orig_stdout)-&gt;fptr);
	rb_io_synchronized(RFILE(orig_stderr)-&gt;fptr);
	return Qnil;

      case -1:			/* fork failed */
	if (errno == EAGAIN) {
	    rb_thread_sleep(1);
	    goto retry;
	}
	else {
	    int e = errno;
	    if ((modef &amp; FMODE_READABLE)) {
		close(pr[0]);
		close(pr[1]);
	    }
	    if ((modef &amp; FMODE_WRITABLE)) {
		close(pw[0]);
		close(pw[1]);
	    }
	    errno = e;
	    rb_sys_fail(pname);
	}
	break;

      default:			/* parent */
	if (pid &lt; 0) rb_sys_fail(pname);
	else {
	    VALUE port = io_alloc(rb_cIO);

	    MakeOpenFile(port, fptr);
	    fptr-&gt;mode = modef;
	    fptr-&gt;mode |= FMODE_SYNC;
	    fptr-&gt;pid = pid;

	    if (modef &amp; FMODE_READABLE) {
		close(pr[1]);
		fptr-&gt;f  = rb_fdopen(pr[0], &quot;r&quot;);
	    }
	    if (modef &amp; FMODE_WRITABLE) {
		FILE *f = rb_fdopen(pw[1], &quot;w&quot;);

		close(pw[0]);
		if (fptr-&gt;f) fptr-&gt;f2 = f;
		else fptr-&gt;f = f;
	    }
#if defined (__CYGWIN__)
	    fptr-&gt;finalize = pipe_finalize;
	    pipe_add_fptr(fptr);
#endif
	    return port;
	}
    }
#endif
#endif
}

/*
 *  call-seq:
 *     IO.popen(cmd_string, mode=&quot;r&quot; )               =&gt; io
 *     IO.popen(cmd_string, mode=&quot;r&quot; ) {|io| block } =&gt; obj
 *  
 *  Runs the specified command string as a subprocess; the subprocess's
 *  standard input and output will be connected to the returned
 *  &lt;code&gt;IO&lt;/code&gt; object. If &lt;i&gt;cmd_string&lt;/i&gt; starts with a
 *  ``&lt;code&gt;-&lt;/code&gt;'', then a new instance of Ruby is started as the
 *  subprocess. The default mode for the new file object is ``r'', but
 *  &lt;i&gt;mode&lt;/i&gt; may be set to any of the modes listed in the description
 *  for class IO.
 *     
 *  If a block is given, Ruby will run the command as a child connected
 *  to Ruby with a pipe. Ruby's end of the pipe will be passed as a
 *  parameter to the block.
 *  At the end of block, Ruby close the pipe and sets &lt;code&gt;$?&lt;/code&gt;.
 *  In this case &lt;code&gt;IO::popen&lt;/code&gt; returns
 *  the value of the block.
 *     
 *  If a block is given with a &lt;i&gt;cmd_string&lt;/i&gt; of ``&lt;code&gt;-&lt;/code&gt;'',
 *  the block will be run in two separate processes: once in the parent,
 *  and once in a child. The parent process will be passed the pipe
 *  object as a parameter to the block, the child version of the block
 *  will be passed &lt;code&gt;nil&lt;/code&gt;, and the child's standard in and
 *  standard out will be connected to the parent through the pipe. Not
 *  available on all platforms.
 *     
 *     f = IO.popen(&quot;uname&quot;)
 *     p f.readlines
 *     puts &quot;Parent is #{Process.pid}&quot;
 *     IO.popen (&quot;date&quot;) { |f| puts f.gets }
 *     IO.popen(&quot;-&quot;) {|f| $stderr.puts &quot;#{Process.pid} is here, f is #{f}&quot;}
 *     p $?
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     [&quot;Linux\n&quot;]
 *     Parent is 26166
 *     Wed Apr  9 08:53:52 CDT 2003
 *     26169 is here, f is
 *     26166 is here, f is #&lt;IO:0x401b3d44&gt;
 *     #&lt;Process::Status: pid=26166,exited(0)&gt;
 */

static VALUE
rb_io_s_popen(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    const char *mode;
    VALUE pname, pmode, port;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;pname, &amp;pmode) == 1) {
	mode = &quot;r&quot;;
    }
    else if (FIXNUM_P(pmode)) {
	mode = rb_io_modenum_mode(FIX2INT(pmode));
    }
    else {
	mode = rb_io_flags_mode(rb_io_mode_flags(StringValueCStr(pmode)));
    }
    SafeStringValue(pname);
    port = pipe_open(pname, 0, mode);
    if (NIL_P(port)) {
	/* child */
	if (rb_block_given_p()) {
	    rb_yield(Qnil);
	    fflush(stdout);
	    fflush(stderr);
	    _exit(0);
	}
	return Qnil;
    }
    RBASIC(port)-&gt;klass = klass;
    if (rb_block_given_p()) {
	return rb_ensure(rb_yield, port, io_close, port);
    }
    return port;
}

static VALUE
rb_open_file(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fname, vmode, perm;
    const char *path, *mode;
    int flags;
    unsigned int fmode;

    rb_scan_args(argc, argv, &quot;12&quot;, &amp;fname, &amp;vmode, &amp;perm);
    SafeStringValue(fname);

    path = StringValueCStr(fname);
    if (FIXNUM_P(vmode) || !NIL_P(perm)) {
	if (FIXNUM_P(vmode)) {
	    flags = FIX2INT(vmode);
	}
	else {
	    SafeStringValue(vmode);
	    flags = rb_io_mode_modenum(RSTRING(vmode)-&gt;ptr);
	}
	fmode = NIL_P(perm) ? 0666 :  NUM2UINT(perm);

	rb_file_sysopen_internal(io, path, flags, fmode);
    }
    else {
	mode = NIL_P(vmode) ? &quot;r&quot; : StringValueCStr(vmode);
	rb_file_open_internal(io, path, mode);
    }
    return io;
}

/*
 *  call-seq:
 *     IO.open(fd, mode_string=&quot;r&quot; )               =&gt; io
 *     IO.open(fd, mode_string=&quot;r&quot; ) {|io| block } =&gt; obj
 *  
 *  With no associated block, &lt;code&gt;open&lt;/code&gt; is a synonym for
 *  &lt;code&gt;IO::new&lt;/code&gt;. If the optional code block is given, it will
 *  be passed &lt;i&gt;io&lt;/i&gt; as an argument, and the IO object will
 *  automatically be closed when the block terminates. In this instance,
 *  &lt;code&gt;IO::open&lt;/code&gt; returns the value of the block.
 *     
 */

static VALUE
rb_io_s_open(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE io = rb_class_new_instance(argc, argv, klass);

    if (rb_block_given_p()) {
	return rb_ensure(rb_yield, io, io_close, io);
    }

    return io;
}

/*
 *  call-seq:
 *     IO.sysopen(path, [mode, [perm]])  =&gt; fixnum
 *  
 *  Opens the given path, returning the underlying file descriptor as a
 *  &lt;code&gt;Fixnum&lt;/code&gt;.
 *     
 *     IO.sysopen(&quot;testfile&quot;)   #=&gt; 3
 *     
 */

static VALUE
rb_io_s_sysopen(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, vmode, perm;
    int flags, fd;
    unsigned int fmode;
    char *path;

    rb_scan_args(argc, argv, &quot;12&quot;, &amp;fname, &amp;vmode, &amp;perm);
    SafeStringValue(fname);

    if (NIL_P(vmode)) flags = O_RDONLY;
    else if (FIXNUM_P(vmode)) flags = FIX2INT(vmode);
    else {
	SafeStringValue(vmode);
	flags = rb_io_mode_modenum(RSTRING(vmode)-&gt;ptr);
    }
    if (NIL_P(perm)) fmode = 0666;
    else             fmode = NUM2UINT(perm);

    path = ALLOCA_N(char, strlen(RSTRING(fname)-&gt;ptr)+1);
    strcpy(path, RSTRING(fname)-&gt;ptr);
    fd = rb_sysopen(path, flags, fmode);
    return INT2NUM(fd);
}

/*
 *  call-seq:
 *     open(path [, mode [, perm]] )                =&gt; io or nil
 *     open(path [, mode [, perm]] ) {|io| block }  =&gt; obj
 *  
 *  Creates an &lt;code&gt;IO&lt;/code&gt; object connected to the given stream,
 *  file, or subprocess.
 *     
 *  If &lt;i&gt;path&lt;/i&gt; does not start with a pipe character
 *  (``&lt;code&gt;|&lt;/code&gt;''), treat it as the name of a file to open using
 *  the specified mode (defaulting to ``&lt;code&gt;r&lt;/code&gt;''). (See the table
 *  of valid modes on page 331.) If a file is being created, its initial
 *  permissions may be set using the integer third parameter.
 *     
 *  If a block is specified, it will be invoked with the
 *  &lt;code&gt;File&lt;/code&gt; object as a parameter, and the file will be
 *  automatically closed when the block terminates. The call
 *  returns the value of the block.
 *     
 *  If &lt;i&gt;path&lt;/i&gt; starts with a pipe character, a subprocess is
 *  created, connected to the caller by a pair of pipes. The returned
 *  &lt;code&gt;IO&lt;/code&gt; object may be used to write to the standard input
 *  and read from the standard output of this subprocess. If the command
 *  following the ``&lt;code&gt;|&lt;/code&gt;'' is a single minus sign, Ruby forks,
 *  and this subprocess is connected to the parent. In the subprocess,
 *  the &lt;code&gt;open&lt;/code&gt; call returns &lt;code&gt;nil&lt;/code&gt;. If the command
 *  is not ``&lt;code&gt;-&lt;/code&gt;'', the subprocess runs the command. If a
 *  block is associated with an &lt;code&gt;open(&quot;|-&quot;)&lt;/code&gt; call, that block
 *  will be run twice---once in the parent and once in the child. The
 *  block parameter will be an &lt;code&gt;IO&lt;/code&gt; object in the parent and
 *  &lt;code&gt;nil&lt;/code&gt; in the child. The parent's &lt;code&gt;IO&lt;/code&gt; object
 *  will be connected to the child's &lt;code&gt;$stdin&lt;/code&gt; and
 *  &lt;code&gt;$stdout&lt;/code&gt;. The subprocess will be terminated at the end
 *  of the block.
 *     
 *     open(&quot;testfile&quot;) do |f|
 *       print f.gets
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     This is line one
 *     
 *  Open a subprocess and read its output:
 *     
 *     cmd = open(&quot;|date&quot;)
 *     print cmd.gets
 *     cmd.close
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Wed Apr  9 08:56:31 CDT 2003
 *     
 *  Open a subprocess running the same Ruby program:
 *     
 *     f = open(&quot;|-&quot;, &quot;w+&quot;)
 *     if f == nil
 *       puts &quot;in Child&quot;
 *       exit
 *     else
 *       puts &quot;Got: #{f.gets}&quot;
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Got: in Child
 *     
 *  Open a subprocess using a block to receive the I/O object:
 *     
 *     open(&quot;|-&quot;) do |f|
 *       if f == nil
 *         puts &quot;in Child&quot;
 *       else
 *         puts &quot;Got: #{f.gets}&quot;
 *       end
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Got: in Child
 */

static VALUE
rb_f_open(argc, argv)
    int argc;
    VALUE *argv;
{
    if (argc &gt;= 1) {
	char *str = StringValuePtr(argv[0]);

	if (str[0] == '|') {
	    VALUE tmp = rb_str_new(str+1, RSTRING(argv[0])-&gt;len-1);
	    OBJ_INFECT(tmp, argv[0]);
	    argv[0] = tmp;
	    return rb_io_s_popen(argc, argv, rb_cIO);
	}
    }
    return rb_io_s_open(argc, argv, rb_cFile);
}

static VALUE
rb_io_open(fname, mode)
    char *fname, *mode;
{
    if (fname[0] == '|') {
	return pipe_open(0, fname+1, mode);
    }
    else {
	return rb_file_open(fname, mode);
    }
}

static VALUE
rb_io_get_io(io)
    VALUE io;
{
    return rb_convert_type(io, T_FILE, &quot;IO&quot;, &quot;to_io&quot;);
}

static VALUE
rb_io_check_io(io)
    VALUE io;
{
    return rb_check_convert_type(io, T_FILE, &quot;IO&quot;, &quot;to_io&quot;);
}

static const char*
rb_io_mode_string(fptr)
    rb_io_t *fptr;
{
    switch (fptr-&gt;mode &amp; FMODE_READWRITE) {
      case FMODE_READABLE:
      default:
	return &quot;r&quot;;
      case FMODE_WRITABLE:
	return &quot;w&quot;;
      case FMODE_READWRITE:
	return &quot;r+&quot;;
    }
}

static VALUE
io_reopen(io, nfile)
    VALUE io, nfile;
{
    rb_io_t *fptr, *orig;
    const char *mode;
    int fd, fd2;
    off_t pos = 0;

    nfile = rb_io_get_io(nfile);
    if (rb_safe_level() &gt;= 4 &amp;&amp; (!OBJ_TAINTED(io) || !OBJ_TAINTED(nfile))) {
	rb_raise(rb_eSecurityError, &quot;Insecure: can't reopen&quot;);
    }
    GetOpenFile(io, fptr);
    GetOpenFile(nfile, orig);

    if (fptr == orig) return io;
    if (orig-&gt;mode &amp; FMODE_READABLE) {
	pos = io_tell(orig);
    }
    if (orig-&gt;f2) {
	io_fflush(orig-&gt;f2, orig);
    }
    else if (orig-&gt;mode &amp; FMODE_WRITABLE) {
	io_fflush(orig-&gt;f, orig);
    }
    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
	io_fflush(GetWriteFile(fptr), fptr);
    }

    /* copy rb_io_t structure */
    fptr-&gt;mode = orig-&gt;mode;
    fptr-&gt;pid = orig-&gt;pid;
    fptr-&gt;lineno = orig-&gt;lineno;
    if (fptr-&gt;path) free(fptr-&gt;path);
    if (orig-&gt;path) fptr-&gt;path = strdup(orig-&gt;path);
    else fptr-&gt;path = 0;
    fptr-&gt;finalize = orig-&gt;finalize;

    mode = rb_io_mode_string(fptr);
    fd = fileno(fptr-&gt;f);
    fd2 = fileno(orig-&gt;f);
    if (fd != fd2) {
	if (fptr-&gt;f == stdin || fptr-&gt;f == stdout || fptr-&gt;f == stderr) {
	    clearerr(fptr-&gt;f);
	    /* need to keep stdio objects */
	    if (dup2(fd2, fd) &lt; 0)
		rb_sys_fail(orig-&gt;path);
	}
	else {
	    FILE *f2 = fptr-&gt;f2;
	    int m = fptr-&gt;mode;
	    fclose(fptr-&gt;f);
	    fptr-&gt;f = f2;
	    fptr-&gt;f2 = NULL;
	    fptr-&gt;mode &amp;= (m &amp; FMODE_READABLE) ? ~FMODE_READABLE : ~FMODE_WRITABLE;
	    if (dup2(fd2, fd) &lt; 0)
		rb_sys_fail(orig-&gt;path);
	    if (f2) {
		fptr-&gt;f = rb_fdopen(fd, &quot;r&quot;);
		fptr-&gt;f2 = f2;
	    }
	    else {
		fptr-&gt;f = rb_fdopen(fd, mode);
	    }
	    fptr-&gt;mode = m;
	}
	rb_thread_fd_close(fd);
	if ((orig-&gt;mode &amp; FMODE_READABLE) &amp;&amp; pos &gt;= 0) {
	    io_seek(fptr, pos, SEEK_SET);
	    io_seek(orig, pos, SEEK_SET);
	}
    }

    if (fptr-&gt;f2 &amp;&amp; fd != fileno(fptr-&gt;f2)) {
	fd = fileno(fptr-&gt;f2);
	if (!orig-&gt;f2) {
	    fclose(fptr-&gt;f2);
	    rb_thread_fd_close(fd);
	    fptr-&gt;f2 = 0;
	}
	else if (fd != (fd2 = fileno(orig-&gt;f2))) {
	    fclose(fptr-&gt;f2);
	    rb_thread_fd_close(fd);
	    if (dup2(fd2, fd) &lt; 0)
		rb_sys_fail(orig-&gt;path);
	    fptr-&gt;f2 = rb_fdopen(fd, &quot;w&quot;);
	}
    }

    if (fptr-&gt;mode &amp; FMODE_BINMODE) {
	rb_io_binmode(io);
    }

    RBASIC(io)-&gt;klass = RBASIC(nfile)-&gt;klass;
    return io;
}

/*
 *  call-seq:
 *     ios.reopen(other_IO)         =&gt; ios 
 *     ios.reopen(path, mode_str)   =&gt; ios
 *  
 *  Reassociates &lt;em&gt;ios&lt;/em&gt; with the I/O stream given in
 *  &lt;i&gt;other_IO&lt;/i&gt; or to a new stream opened on &lt;i&gt;path&lt;/i&gt;. This may
 *  dynamically change the actual class of this stream.
 *     
 *     f1 = File.new(&quot;testfile&quot;)
 *     f2 = File.new(&quot;testfile&quot;)
 *     f2.readlines[0]   #=&gt; &quot;This is line one\n&quot;
 *     f2.reopen(f1)     #=&gt; #&lt;File:testfile&gt;
 *     f2.readlines[0]   #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_io_reopen(argc, argv, file)
    int argc;
    VALUE *argv;
    VALUE file;
{
    VALUE fname, nmode;
    const char *mode;
    rb_io_t *fptr;

    rb_secure(4);
    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;fname, &amp;nmode) == 1) {
	VALUE tmp = rb_io_check_io(fname);
	if (!NIL_P(tmp)) {
	    return io_reopen(file, tmp);
	}
    }

    SafeStringValue(fname);
    rb_io_taint_check(file);
    fptr = RFILE(file)-&gt;fptr;
    if (!fptr) {
	fptr = RFILE(file)-&gt;fptr = ALLOC(rb_io_t);
	MEMZERO(fptr, rb_io_t, 1);
    }

    if (!NIL_P(nmode)) {
	fptr-&gt;mode = rb_io_mode_flags(StringValueCStr(nmode));
    }

    if (fptr-&gt;path) {
	free(fptr-&gt;path);
	fptr-&gt;path = 0;
    }

    fptr-&gt;path = strdup(StringValueCStr(fname));
    mode = rb_io_flags_mode(fptr-&gt;mode);
    if (!fptr-&gt;f) {
	fptr-&gt;f = rb_fopen(fptr-&gt;path, mode);
	if (fptr-&gt;f2) {
	    fclose(fptr-&gt;f2);
	    fptr-&gt;f2 = 0;
	}
	return file;
    }

    if (freopen(fptr-&gt;path, mode, fptr-&gt;f) == 0) {
	rb_sys_fail(fptr-&gt;path);
    }
#ifdef USE_SETVBUF
    if (setvbuf(fptr-&gt;f, NULL, _IOFBF, 0) != 0)
	rb_warn(&quot;setvbuf() can't be honoured for %s&quot;, fptr-&gt;path);
#endif

    if (fptr-&gt;f2) {
	if (freopen(fptr-&gt;path, &quot;w&quot;, fptr-&gt;f2) == 0) {
	    rb_sys_fail(fptr-&gt;path);
	}
    }

    return file;
}

/* :nodoc: */
static VALUE
rb_io_init_copy(dest, io)
    VALUE dest, io;
{
    rb_io_t *fptr, *orig;
    int fd;
    const char *mode;

    io = rb_io_get_io(io);
    if (dest == io) return dest;
    GetOpenFile(io, orig);
    MakeOpenFile(dest, fptr);

    if (orig-&gt;f2) {
	io_fflush(orig-&gt;f2, orig);
	fseeko(orig-&gt;f, 0L, SEEK_CUR);
    }
    else if (orig-&gt;mode &amp; FMODE_WRITABLE) {
	io_fflush(orig-&gt;f, orig);
    }
    else {
	fseeko(orig-&gt;f, 0L, SEEK_CUR);
    }

    /* copy rb_io_t structure */
    fptr-&gt;mode = orig-&gt;mode;
    fptr-&gt;pid = orig-&gt;pid;
    fptr-&gt;lineno = orig-&gt;lineno;
    if (orig-&gt;path) fptr-&gt;path = strdup(orig-&gt;path);
    fptr-&gt;finalize = orig-&gt;finalize;

    switch (fptr-&gt;mode &amp; FMODE_READWRITE) {
      case FMODE_READABLE:
      default:
	mode = &quot;r&quot;; break;
      case FMODE_WRITABLE:
	mode = &quot;w&quot;; break;
      case FMODE_READWRITE:
	if (orig-&gt;f2) mode = &quot;r&quot;;
	else          mode = &quot;r+&quot;;
	break;
    }
    fd = ruby_dup(fileno(orig-&gt;f));
    fptr-&gt;f = rb_fdopen(fd, mode);
    fseeko(fptr-&gt;f, ftello(orig-&gt;f), SEEK_SET);
    if (orig-&gt;f2) {
	if (fileno(orig-&gt;f) != fileno(orig-&gt;f2)) {
	    fd = ruby_dup(fileno(orig-&gt;f2));
	}
	fptr-&gt;f2 = rb_fdopen(fd, &quot;w&quot;);
	fseeko(fptr-&gt;f2, ftello(orig-&gt;f2), SEEK_SET);
    }
    if (fptr-&gt;mode &amp; FMODE_BINMODE) {
	rb_io_binmode(dest);
    }

    return dest;
}

/*
 *  call-seq:
 *     ios.printf(format_string [, obj, ...] )   =&gt; nil
 *  
 *  Formats and writes to &lt;em&gt;ios&lt;/em&gt;, converting parameters under
 *  control of the format string. See &lt;code&gt;Kernel#sprintf&lt;/code&gt;
 *  for details.
 */

VALUE
rb_io_printf(argc, argv, out)
    int argc;
    VALUE argv[];
    VALUE out;
{
    rb_io_write(out, rb_f_sprintf(argc, argv));
    return Qnil;
}

/*
 *  call-seq:
 *     printf(io, string [, obj ... ] )    =&gt; nil
 *     printf(string [, obj ... ] )        =&gt; nil
 *  
 *  Equivalent to:
 *     io.write(sprintf(string, obj, ...)
 *  or
 *     $stdout.write(sprintf(string, obj, ...)
 */

static VALUE
rb_f_printf(argc, argv)
    int argc;
    VALUE argv[];
{
    VALUE out;

    if (argc == 0) return Qnil;
    if (TYPE(argv[0]) == T_STRING) {
	out = rb_stdout;
    }
    else {
	out = argv[0];
	argv++;
	argc--;
    }
    rb_io_write(out, rb_f_sprintf(argc, argv));

    return Qnil;
}

/*
 *  call-seq:
 *     ios.print()             =&gt; nil
 *     ios.print(obj, ...)     =&gt; nil
 *  
 *  Writes the given object(s) to &lt;em&gt;ios&lt;/em&gt;. The stream must be
 *  opened for writing. If the output record separator (&lt;code&gt;$\\&lt;/code&gt;)
 *  is not &lt;code&gt;nil&lt;/code&gt;, it will be appended to the output. If no
 *  arguments are given, prints &lt;code&gt;$_&lt;/code&gt;. Objects that aren't
 *  strings will be converted by calling their &lt;code&gt;to_s&lt;/code&gt; method.
 *  With no argument, prints the contents of the variable &lt;code&gt;$_&lt;/code&gt;.
 *  Returns &lt;code&gt;nil&lt;/code&gt;.
 *     
 *     $stdout.print(&quot;This is &quot;, 100, &quot; percent.\n&quot;)
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     This is 100 percent.
 */

VALUE
rb_io_print(argc, argv, out)
    int argc;
    VALUE *argv;
    VALUE out;
{
    int i;
    VALUE line;

    /* if no argument given, print `$_' */
    if (argc == 0) {
	argc = 1;
	line = rb_lastline_get();
	argv = &amp;line;
    }
    for (i=0; i&lt;argc; i++) {
	if (!NIL_P(rb_output_fs) &amp;&amp; i&gt;0) {
	    rb_io_write(out, rb_output_fs);
	}
	switch (TYPE(argv[i])) {
	  case T_NIL:
	    rb_io_write(out, rb_str_new2(&quot;nil&quot;));
	    break;
	  default:
	    rb_io_write(out, argv[i]);
	    break;
	}
    }
    if (!NIL_P(rb_output_rs)) {
	rb_io_write(out, rb_output_rs);
    }

    return Qnil;
}

/*
 *  call-seq:
 *     print(obj, ...)    =&gt; nil
 *  
 *  Prints each object in turn to &lt;code&gt;$stdout&lt;/code&gt;. If the output
 *  field separator (&lt;code&gt;$,&lt;/code&gt;) is not +nil+, its
 *  contents will appear between each field. If the output record
 *  separator (&lt;code&gt;$\\&lt;/code&gt;) is not +nil+, it will be
 *  appended to the output. If no arguments are given, prints
 *  &lt;code&gt;$_&lt;/code&gt;. Objects that aren't strings will be converted by
 *  calling their &lt;code&gt;to_s&lt;/code&gt; method.
 *     
 *     print &quot;cat&quot;, [1,2,3], 99, &quot;\n&quot;
 *     $, = &quot;, &quot;
 *     $\ = &quot;\n&quot;
 *     print &quot;cat&quot;, [1,2,3], 99
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     cat12399
 *     cat, 1, 2, 3, 99
 */

static VALUE
rb_f_print(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_io_print(argc, argv, rb_stdout);
    return Qnil;
}

/*
 *  call-seq:
 *     ios.putc(obj)    =&gt; obj
 *  
 *  If &lt;i&gt;obj&lt;/i&gt; is &lt;code&gt;Numeric&lt;/code&gt;, write the character whose
 *  code is &lt;i&gt;obj&lt;/i&gt;, otherwise write the first character of the
 *  string representation of  &lt;i&gt;obj&lt;/i&gt; to &lt;em&gt;ios&lt;/em&gt;.
 *     
 *     $stdout.putc &quot;A&quot;
 *     $stdout.putc 65
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     AA
 */

static VALUE
rb_io_putc(io, ch)
    VALUE io, ch;
{
    char c = NUM2CHR(ch);

    rb_io_write(io, rb_str_new(&amp;c, 1));
    return ch;
}

/*
 *  call-seq:
 *     putc(int)   =&gt; int
 *  
 *  Equivalent to:
 *
 *    $stdout.putc(int)
 */

static VALUE
rb_f_putc(recv, ch)
    VALUE recv, ch;
{
    return rb_io_putc(rb_stdout, ch);
}

static VALUE
io_puts_ary(ary, out)
    VALUE ary, out;
{
    VALUE tmp;
    long i;

    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	tmp = RARRAY(ary)-&gt;ptr[i];
	if (rb_inspecting_p(tmp)) {
	    tmp = rb_str_new2(&quot;[...]&quot;);
	}
	rb_io_puts(1, &amp;tmp, out);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     ios.puts(obj, ...)    =&gt; nil
 *  
 *  Writes the given objects to &lt;em&gt;ios&lt;/em&gt; as with
 *  &lt;code&gt;IO#print&lt;/code&gt;. Writes a record separator (typically a
 *  newline) after any that do not already end with a newline sequence.
 *  If called with an array argument, writes each element on a new line.
 *  If called without arguments, outputs a single record separator.
 *     
 *     $stdout.puts(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;)
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     this
 *     is
 *     a
 *     test
 */

VALUE
rb_io_puts(argc, argv, out)
    int argc;
    VALUE *argv;
    VALUE out;
{
    int i;
    VALUE line;

    /* if no argument given, print newline. */
    if (argc == 0) {
	rb_io_write(out, rb_default_rs);
	return Qnil;
    }
    for (i=0; i&lt;argc; i++) {
	if (NIL_P(argv[i])) {
	    line = rb_str_new2(&quot;nil&quot;);
	}
	else {
	    line = rb_check_array_type(argv[i]);
	    if (!NIL_P(line)) {
		rb_protect_inspect(io_puts_ary, line, out);
		continue;
	    }
	    line = rb_obj_as_string(argv[i]);
	}
	rb_io_write(out, line);
	if (RSTRING(line)-&gt;len == 0 ||
            RSTRING(line)-&gt;ptr[RSTRING(line)-&gt;len-1] != '\n') {
	    rb_io_write(out, rb_default_rs);
	}
    }

    return Qnil;
}

/*
 *  call-seq:
 *     puts(obj, ...)    =&gt; nil
 *  
 *  Equivalent to 
 *
 *      $stdout.puts(obj, ...)
 */

static VALUE
rb_f_puts(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_io_puts(argc, argv, rb_stdout);
    return Qnil;
}

void
rb_p(obj)			/* for debug print within C code */
    VALUE obj;
{
    rb_io_write(rb_stdout, rb_obj_as_string(rb_inspect(obj)));
    rb_io_write(rb_stdout, rb_default_rs);
}

/*
 *  call-seq:
 *     p(obj, ...)    =&gt; nil
 *  
 *  For each object, directly writes
 *  _obj_.+inspect+ followed by the current output
 *  record separator to the program's standard output.
 *     
 *     S = Struct.new(:name, :state)
 *     s = S['dave', 'TX']
 *     p s
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     #&lt;S name=&quot;dave&quot;, state=&quot;TX&quot;&gt;
 */

static VALUE
rb_f_p(argc, argv)
    int argc;
    VALUE *argv;
{
    int i;

    for (i=0; i&lt;argc; i++) {
	rb_p(argv[i]);
    }
    if (TYPE(rb_stdout) == T_FILE) {
	rb_io_flush(rb_stdout);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     obj.display(port=$&gt;)    =&gt; nil
 *  
 *  Prints &lt;i&gt;obj&lt;/i&gt; on the given port (default &lt;code&gt;$&gt;&lt;/code&gt;).
 *  Equivalent to:
 *     
 *     def display(port=$&gt;)
 *       port.write self
 *     end
 *     
 *  For example:
 *     
 *     1.display
 *     &quot;cat&quot;.display
 *     [ 4, 5, 6 ].display
 *     puts
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     1cat456
 */

static VALUE
rb_obj_display(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE out;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;out) == 0) {
	out = rb_stdout;
    }

    rb_io_write(out, self);

    return Qnil;
}

void
rb_write_error2(mesg, len)
    const char *mesg;
    long len;
{
    rb_io_write(rb_stderr, rb_str_new(mesg, len));
}

void
rb_write_error(mesg)
    const char *mesg;
{
    rb_write_error2(mesg, strlen(mesg));
}

static void
must_respond_to(mid, val, id)
    ID mid;
    VALUE val;
    ID id;
{
    if (!rb_respond_to(val, mid)) {
	rb_raise(rb_eTypeError, &quot;%s must have %s method, %s given&quot;,
		 rb_id2name(id), rb_id2name(mid),
		 rb_obj_classname(val));
    }
}

static void
stdout_setter(val, id, variable)
    VALUE val;
    ID id;
    VALUE *variable;
{
    must_respond_to(id_write, val, id);
    *variable = val;
}

static void
defout_setter(val, id, variable)
    VALUE val;
    ID id;
    VALUE *variable;
{
    stdout_setter(val, id, variable);
    rb_warn(&quot;$defout is obsolete; use $stdout instead&quot;);
}

static void
deferr_setter(val, id, variable)
    VALUE val;
    ID id;
    VALUE *variable;
{
    stdout_setter(val, id, variable);
    rb_warn(&quot;$deferr is obsolete; use $stderr instead&quot;);
}

static VALUE
prep_stdio(f, mode, klass)
    FILE *f;
    int mode;
    VALUE klass;
{
    rb_io_t *fp;
    VALUE io = io_alloc(klass);

    MakeOpenFile(io, fp);
#ifdef __CYGWIN__
    if (!isatty(fileno(f))) {
	mode |= O_BINARY;
	setmode(fileno(f), O_BINARY);
    }
#endif
    fp-&gt;f = f;
    fp-&gt;mode = mode;

    return io;
}

static void
prep_path(io, path)
    VALUE io;
    char *path;
{
    rb_io_t *fptr;

    GetOpenFile(io, fptr);
    if (fptr-&gt;path) rb_bug(&quot;illegal prep_path() call&quot;);
    fptr-&gt;path = strdup(path);
}

/*
 *  call-seq:
 *     IO.new(fd, mode)   =&gt; io
 *  
 *  Returns a new &lt;code&gt;IO&lt;/code&gt; object (a stream) for the given
 *  integer file descriptor and mode string. See also
 *  &lt;code&gt;IO#fileno&lt;/code&gt; and &lt;code&gt;IO::for_fd&lt;/code&gt;.
 *     
 *     a = IO.new(2,&quot;w&quot;)      # '2' is standard error
 *     $stderr.puts &quot;Hello&quot;
 *     a.puts &quot;World&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Hello
 *     World
 */

static VALUE
rb_io_initialize(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fnum, mode;
    rb_io_t *fp;
    int fd, flags;

    rb_secure(4);
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;fnum, &amp;mode);
    fd = NUM2INT(fnum);
    if (argc == 2) {
	if (FIXNUM_P(mode)) {
	    flags = FIX2LONG(mode);
	}
	else {
	    SafeStringValue(mode);
	    flags = rb_io_mode_modenum(StringValueCStr(mode));
	}
    }
    else {
#if defined(HAVE_FCNTL) &amp;&amp; defined(F_GETFL)
	flags = fcntl(fd, F_GETFL);
	if (flags == -1) rb_sys_fail(0);
#else
	flags = O_RDONLY;
#endif
    }
    MakeOpenFile(io, fp);
    fp-&gt;mode = rb_io_modenum_flags(flags);
    fp-&gt;f = rb_fdopen(fd, rb_io_modenum_mode(flags));

    return io;
}

/*
 *  call-seq:
 *     File.new(filename, mode=&quot;r&quot;)            =&gt; file
 *     File.new(filename [, mode [, perm]])    =&gt; file
 *  

 *  Opens the file named by _filename_ according to
 *  _mode_ (default is ``r'') and returns a new
 *  &lt;code&gt;File&lt;/code&gt; object. See the description of class +IO+ for
 *  a description of _mode_. The file mode may optionally be
 *  specified as a +Fixnum+ by _or_-ing together the
 *  flags (O_RDONLY etc, again described under +IO+). Optional
 *  permission bits may be given in _perm_. These mode and permission
 *  bits are platform dependent; on Unix systems, see
 *  &lt;code&gt;open(2)&lt;/code&gt; for details.
 *
 *     f = File.new(&quot;testfile&quot;, &quot;r&quot;)
 *     f = File.new(&quot;newfile&quot;,  &quot;w+&quot;)
 *     f = File.new(&quot;newfile&quot;, File::CREAT|File::TRUNC|File::RDWR, 0644)
 */

static VALUE
rb_file_initialize(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    if (RFILE(io)-&gt;fptr) {
	rb_raise(rb_eRuntimeError, &quot;reinitializing File&quot;);
    }
    if (0 &lt; argc &amp;&amp; argc &lt; 3) {
	VALUE fd = rb_check_convert_type(argv[0], T_FIXNUM, &quot;Fixnum&quot;, &quot;to_int&quot;);

	if (!NIL_P(fd)) {
	    argv[0] = fd;
	    return rb_io_initialize(argc, argv, io);
	}
    }
    rb_open_file(argc, argv, io);

    return io;
}

/*
 *  call-seq:
 *     IO.new(fd, mode_string)   =&gt; io
 *  
 *  Returns a new &lt;code&gt;IO&lt;/code&gt; object (a stream) for the given
 *  integer file descriptor and mode string. See also
 *  &lt;code&gt;IO#fileno&lt;/code&gt; and &lt;code&gt;IO::for_fd&lt;/code&gt;.
 *     
 *     a = IO.new(2,&quot;w&quot;)      # '2' is standard error
 *     $stderr.puts &quot;Hello&quot;
 *     a.puts &quot;World&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Hello
 *     World
 */

static VALUE
rb_io_s_new(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    if (rb_block_given_p()) {
	const char *cname = rb_class2name(klass);

	rb_warn(&quot;%s::new() does not take block; use %s::open() instead&quot;,
		cname, cname);
    }
    return rb_class_new_instance(argc, argv, klass);
}

/*
 *  call-seq:
 *     IO.for_fd(fd, mode)    =&gt; io
 *  
 *  Synonym for &lt;code&gt;IO::new&lt;/code&gt;.
 *     
 */

static VALUE
rb_io_s_for_fd(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE io = rb_obj_alloc(klass);
    rb_io_initialize(argc, argv, io);
    return io;
}

static int binmode = 0;

static VALUE
argf_forward(int argc, VALUE *argv)
{
    return rb_funcall3(current_file, ruby_frame-&gt;last_func, argc, argv);
}

#define ARGF_FORWARD(argc, argv) do {\
  if (TYPE(current_file) != T_FILE)\
     return argf_forward(argc, argv);\
} while (0)
#define NEXT_ARGF_FORWARD(argc, argv) do {\
     if (!next_argv()) return Qnil;\
     ARGF_FORWARD(argc, argv);\
} while (0)

static void
argf_close(file)
    VALUE file;
{
    if (TYPE(file) == T_FILE)
	rb_io_close(file);
    else
	rb_funcall3(file, rb_intern(&quot;close&quot;), 0, 0);
}

static int
next_argv()
{
    extern VALUE rb_argv;
    char *fn;
    rb_io_t *fptr;
    int stdout_binmode = 0;

    if (TYPE(rb_stdout) == T_FILE) {
        GetOpenFile(rb_stdout, fptr);
        if (fptr-&gt;mode &amp; FMODE_BINMODE)
            stdout_binmode = 1;
    }

    if (init_p == 0) {
	if (RARRAY(rb_argv)-&gt;len &gt; 0) {
	    next_p = 1;
	}
	else {
	    next_p = -1;
	}
	init_p = 1;
	gets_lineno = 0;
    }

    if (next_p == 1) {
	next_p = 0;
      retry:
	if (RARRAY(rb_argv)-&gt;len &gt; 0) {
	    filename = rb_ary_shift(rb_argv);
	    fn = StringValueCStr(filename);
	    if (strlen(fn) == 1 &amp;&amp; fn[0] == '-') {
		current_file = rb_stdin;
		if (ruby_inplace_mode) {
		    rb_warn(&quot;Can't do inplace edit for stdio; skipping&quot;);
		    goto retry;
		}
	    }
	    else {
		FILE *fr = rb_fopen(fn, &quot;r&quot;);

		if (ruby_inplace_mode) {
		    struct stat st;
#ifndef NO_SAFE_RENAME
		    struct stat st2;
#endif
		    VALUE str;
		    FILE *fw;

		    if (TYPE(rb_stdout) == T_FILE &amp;&amp; rb_stdout != orig_stdout) {
			rb_io_close(rb_stdout);
		    }
		    fstat(fileno(fr), &amp;st);
		    if (*ruby_inplace_mode) {
			str = rb_str_new2(fn);
#ifdef NO_LONG_FNAME
                        ruby_add_suffix(str, ruby_inplace_mode);
#else
			rb_str_cat2(str, ruby_inplace_mode);
#endif
#ifdef NO_SAFE_RENAME
			(void)fclose(fr);
			(void)unlink(RSTRING(str)-&gt;ptr);
			(void)rename(fn, RSTRING(str)-&gt;ptr);
			fr = rb_fopen(RSTRING(str)-&gt;ptr, &quot;r&quot;);
#else
			if (rename(fn, RSTRING(str)-&gt;ptr) &lt; 0) {
			    rb_warn(&quot;Can't rename %s to %s: %s, skipping file&quot;,
				    fn, RSTRING(str)-&gt;ptr, strerror(errno));
			    fclose(fr);
			    goto retry;
			}
#endif
		    }
		    else {
#ifdef NO_SAFE_RENAME
			rb_fatal(&quot;Can't do inplace edit without backup&quot;);
#else
			if (unlink(fn) &lt; 0) {
			    rb_warn(&quot;Can't remove %s: %s, skipping file&quot;,
				    fn, strerror(errno));
			    fclose(fr);
			    goto retry;
			}
#endif
		    }
		    fw = rb_fopen(fn, &quot;w&quot;);
#ifndef NO_SAFE_RENAME
		    fstat(fileno(fw), &amp;st2);
#ifdef HAVE_FCHMOD
		    fchmod(fileno(fw), st.st_mode);
#else
		    chmod(fn, st.st_mode);
#endif
		    if (st.st_uid!=st2.st_uid || st.st_gid!=st2.st_gid) {
			fchown(fileno(fw), st.st_uid, st.st_gid);
		    }
#endif
		    rb_stdout = prep_stdio(fw, FMODE_WRITABLE, rb_cFile);
		    prep_path(rb_stdout, fn);
		    if (stdout_binmode) rb_io_binmode(rb_stdout);
		}
		current_file = prep_stdio(fr, FMODE_READABLE, rb_cFile);
		prep_path(current_file, fn);
	    }
	    if (binmode) rb_io_binmode(current_file);
	}
	else {
	    next_p = 1;
	    return Qfalse;
	}
    }
    else if (next_p == -1) {
	current_file = rb_stdin;
	filename = rb_str_new2(&quot;-&quot;);
	if (ruby_inplace_mode) {
	    rb_warn(&quot;Can't do inplace edit for stdio&quot;);
	    rb_stdout = orig_stdout;
	}
    }
    return Qtrue;
}

static VALUE
argf_getline(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line;

  retry:
    if (!next_argv()) return Qnil;
    if (argc == 0 &amp;&amp; rb_rs == rb_default_rs) {
	line = rb_io_gets(current_file);
    }
    else {
	VALUE rs;

	if (argc == 0) {
	    rs = rb_rs;
	}
	else {
	    rb_scan_args(argc, argv, &quot;1&quot;, &amp;rs);
	    if (!NIL_P(rs)) StringValue(rs);
	}
	line = rb_io_getline(rs, current_file);
    }
    if (NIL_P(line) &amp;&amp; next_p != -1) {
	argf_close(current_file);
	next_p = 1;
	goto retry;
    }
    if (!NIL_P(line)) {
	gets_lineno++;
	lineno = INT2FIX(gets_lineno);
    }
    return line;
}

/*
 *  call-seq:
 *     gets(separator=$/)    =&gt; string or nil
 *  
 *  Returns (and assigns to &lt;code&gt;$_&lt;/code&gt;) the next line from the list
 *  of files in +ARGV+ (or &lt;code&gt;$*&lt;/code&gt;), or from standard
 *  input if no files are present on the command line. Returns
 *  +nil+ at end of file. The optional argument specifies the
 *  record separator. The separator is included with the contents of
 *  each record. A separator of +nil+ reads the entire
 *  contents, and a zero-length separator reads the input one paragraph
 *  at a time, where paragraphs are divided by two consecutive newlines.
 *  If multiple filenames are present in +ARGV+,
 *  +gets(nil)+ will read the contents one file at a time.
 *     
 *     ARGV &lt;&lt; &quot;testfile&quot;
 *     print while gets
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     This is line one
 *     This is line two
 *     This is line three
 *     And so on...
 *     
 *  The style of programming using &lt;code&gt;$_&lt;/code&gt; as an implicit
 *  parameter is gradually losing favor in the Ruby community.
 */

static VALUE
rb_f_gets(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line;

    if (!next_argv()) return Qnil;
    if (TYPE(current_file) != T_FILE) {
	line = rb_funcall3(current_file, rb_intern(&quot;gets&quot;), argc, argv);
    }
    else {
	line = argf_getline(argc, argv);
    }
    rb_lastline_set(line);
    return line;
}

VALUE
rb_gets()
{
    VALUE line;

    if (rb_rs != rb_default_rs) {
	return rb_f_gets(0, 0);
    }

  retry:
    if (!next_argv()) return Qnil;
    line = rb_io_gets(current_file);
    if (NIL_P(line) &amp;&amp; next_p != -1) {
	argf_close(current_file);
	next_p = 1;
	goto retry;
    }
    rb_lastline_set(line);
    if (!NIL_P(line)) {
	gets_lineno++;
	lineno = INT2FIX(gets_lineno);
    }

    return line;
}

/*
 *  call-seq:
 *     readline(separator=$/)   =&gt; string
 *  
 *  Equivalent to &lt;code&gt;Kernel::gets&lt;/code&gt;, except
 *  +readline+ raises +EOFError+ at end of file.
 */

static VALUE
rb_f_readline(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line;

    if (!next_argv()) rb_eof_error();
    ARGF_FORWARD(argc, argv);
    line = rb_f_gets(argc, argv);
    if (NIL_P(line)) {
	rb_eof_error();
    }

    return line;
}

/*
 * obsolete
 */

static VALUE
rb_f_getc()
{
    rb_warn(&quot;getc is obsolete; use STDIN.getc instead&quot;);
    if (TYPE(rb_stdin) != T_FILE) {
	return rb_funcall3(rb_stdin, rb_intern(&quot;getc&quot;), 0, 0);
    }
    return rb_io_getc(rb_stdin);
}

/*
 *  call-seq:
 *     readlines(separator=$/)    =&gt; array
 *  
 *  Returns an array containing the lines returned by calling
 *  &lt;code&gt;Kernel.gets(&lt;i&gt;separator&lt;/i&gt;)&lt;/code&gt; until the end of file.
 */

static VALUE
rb_f_readlines(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE line, ary;

    NEXT_ARGF_FORWARD(argc, argv);
    ary = rb_ary_new();
    while (!NIL_P(line = argf_getline(argc, argv))) {
	rb_ary_push(ary, line);
    }

    return ary;
}

/*
 *  call-seq:
 *     `cmd`    =&gt; string
 *  
 *  Returns the standard output of running _cmd_ in a subshell.
 *  The built-in syntax &lt;code&gt;%x{...}&lt;/code&gt; uses
 *  this method. Sets &lt;code&gt;$?&lt;/code&gt; to the process status.
 *     
 *     `date`                   #=&gt; &quot;Wed Apr  9 08:56:30 CDT 2003\n&quot;
 *     `ls testdir`.split[1]    #=&gt; &quot;main.rb&quot;
 *     `echo oops &amp;&amp; exit 99`   #=&gt; &quot;oops\n&quot;
 *     $?.exitstatus            #=&gt; 99
 */

static VALUE
rb_f_backquote(obj, str)
    VALUE obj, str;
{
    volatile VALUE port;
    VALUE result;
    rb_io_t *fptr;

    SafeStringValue(str);
    port = pipe_open(str, 0, &quot;r&quot;);
    if (NIL_P(port)) return rb_str_new(0,0);

    GetOpenFile(port, fptr);
    result = read_all(fptr, remain_size(fptr), Qnil);
    rb_io_close(port);

    return result;
}

#ifdef HAVE_SYS_SELECT_H
#include &lt;sys/select.h&gt;
#endif

/*
 *  call-seq:
 *     IO.select(read_array 
 *               [, write_array 
 *               [, error_array 
 *               [, timeout]]] ) =&gt;  array  or  nil
 *  
 *  See &lt;code&gt;Kernel#select&lt;/code&gt;.
 */

static VALUE
rb_f_select(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE read, write, except, timeout, res, list;
    fd_set rset, wset, eset, pset;
    fd_set *rp, *wp, *ep;
    struct timeval *tp, timerec;
    rb_io_t *fptr;
    long i;
    int max = 0, n;
    int interrupt_flag = 0;
    int pending = 0;

    rb_scan_args(argc, argv, &quot;13&quot;, &amp;read, &amp;write, &amp;except, &amp;timeout);
    if (NIL_P(timeout)) {
	tp = 0;
    }
    else {
	timerec = rb_time_interval(timeout);
	tp = &amp;timerec;
    }

    FD_ZERO(&amp;pset);
    if (!NIL_P(read)) {
	Check_Type(read, T_ARRAY);
	rp = &amp;rset;
	FD_ZERO(rp);
	for (i=0; i&lt;RARRAY(read)-&gt;len; i++) {
	    GetOpenFile(rb_io_get_io(RARRAY(read)-&gt;ptr[i]), fptr);
	    FD_SET(fileno(fptr-&gt;f), rp);
	    if (READ_DATA_PENDING(fptr-&gt;f)) { /* check for buffered data */
		pending++;
		FD_SET(fileno(fptr-&gt;f), &amp;pset);
	    }
	    if (max &lt; fileno(fptr-&gt;f)) max = fileno(fptr-&gt;f);
	}
	if (pending) {		/* no blocking if there's buffered data */
	    timerec.tv_sec = timerec.tv_usec = 0;
	    tp = &amp;timerec;
	}
    }
    else
	rp = 0;

    if (!NIL_P(write)) {
	Check_Type(write, T_ARRAY);
	wp = &amp;wset;
	FD_ZERO(wp);
	for (i=0; i&lt;RARRAY(write)-&gt;len; i++) {
	    GetOpenFile(rb_io_get_io(RARRAY(write)-&gt;ptr[i]), fptr);
	    FD_SET(fileno(fptr-&gt;f), wp);
	    if (max &lt; fileno(fptr-&gt;f)) max = fileno(fptr-&gt;f);
	    if (fptr-&gt;f2) {
		FD_SET(fileno(fptr-&gt;f2), wp);
		if (max &lt; fileno(fptr-&gt;f2)) max = fileno(fptr-&gt;f2);
	    }
	}
    }
    else
	wp = 0;

    if (!NIL_P(except)) {
	Check_Type(except, T_ARRAY);
	ep = &amp;eset;
	FD_ZERO(ep);
	for (i=0; i&lt;RARRAY(except)-&gt;len; i++) {
	    GetOpenFile(rb_io_get_io(RARRAY(except)-&gt;ptr[i]), fptr);
	    FD_SET(fileno(fptr-&gt;f), ep);
	    if (max &lt; fileno(fptr-&gt;f)) max = fileno(fptr-&gt;f);
	    if (fptr-&gt;f2) {
		FD_SET(fileno(fptr-&gt;f2), ep);
		if (max &lt; fileno(fptr-&gt;f2)) max = fileno(fptr-&gt;f2);
	    }
	}
    }
    else {
	ep = 0;
    }

    max++;

    n = rb_thread_select(max, rp, wp, ep, tp);
    if (n &lt; 0) {
	rb_sys_fail(0);
    }
    if (!pending &amp;&amp; n == 0) return Qnil; /* returns nil on timeout */

    res = rb_ary_new2(3);
    rb_ary_push(res, rp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, wp?rb_ary_new():rb_ary_new2(0));
    rb_ary_push(res, ep?rb_ary_new():rb_ary_new2(0));

    if (interrupt_flag == 0) {
	if (rp) {
	    list = RARRAY(res)-&gt;ptr[0];
	    for (i=0; i&lt; RARRAY(read)-&gt;len; i++) {
		GetOpenFile(rb_io_get_io(RARRAY(read)-&gt;ptr[i]), fptr);
		if (FD_ISSET(fileno(fptr-&gt;f), rp)
		    || FD_ISSET(fileno(fptr-&gt;f), &amp;pset)) {
		    rb_ary_push(list, rb_ary_entry(read, i));
		}
	    }
	}

	if (wp) {
	    list = RARRAY(res)-&gt;ptr[1];
	    for (i=0; i&lt; RARRAY(write)-&gt;len; i++) {
		GetOpenFile(rb_io_get_io(RARRAY(write)-&gt;ptr[i]), fptr);
		if (FD_ISSET(fileno(fptr-&gt;f), wp)) {
		    rb_ary_push(list, rb_ary_entry(write, i));
		}
		else if (fptr-&gt;f2 &amp;&amp; FD_ISSET(fileno(fptr-&gt;f2), wp)) {
		    rb_ary_push(list, rb_ary_entry(write, i));
		}
	    }
	}

	if (ep) {
	    list = RARRAY(res)-&gt;ptr[2];
	    for (i=0; i&lt; RARRAY(except)-&gt;len; i++) {
		GetOpenFile(rb_io_get_io(RARRAY(except)-&gt;ptr[i]), fptr);
		if (FD_ISSET(fileno(fptr-&gt;f), ep)) {
		    rb_ary_push(list, rb_ary_entry(except, i));
		}
		else if (fptr-&gt;f2 &amp;&amp; FD_ISSET(fileno(fptr-&gt;f2), ep)) {
		    rb_ary_push(list, rb_ary_entry(except, i));
		}
	    }
	}
    }

    return res;			/* returns an empty array on interrupt */
}

#if !defined(MSDOS) &amp;&amp; !defined(__human68k__)
static int
io_cntl(fd, cmd, narg, io_p)
    int fd, cmd, io_p;
    long narg;
{
    int retval;

#ifdef HAVE_FCNTL
    TRAP_BEG;
# if defined(__CYGWIN__)
    retval = io_p?ioctl(fd, cmd, (void*)narg):fcntl(fd, cmd, narg);
# else
    retval = io_p?ioctl(fd, cmd, narg):fcntl(fd, cmd, narg);
# endif
    TRAP_END;
#else
    if (!io_p) {
	rb_notimplement();
    }
    TRAP_BEG;
    retval = ioctl(fd, cmd, narg);
    TRAP_END;
#endif
    return retval;
}
#endif

static VALUE
rb_io_ctl(io, req, arg, io_p)
    VALUE io, req, arg;
    int io_p;
{
#if !defined(MSDOS) &amp;&amp; !defined(__human68k__)
    int cmd = NUM2ULONG(req);
    rb_io_t *fptr;
    long len = 0;
    long narg = 0;
    int retval;

    rb_secure(2);

    if (NIL_P(arg) || arg == Qfalse) {
	narg = 0;
    }
    else if (FIXNUM_P(arg)) {
	narg = FIX2LONG(arg);
    }
    else if (arg == Qtrue) {
	narg = 1;
    }
    else {
	VALUE tmp = rb_check_string_type(arg);

	if (NIL_P(tmp)) {
	    narg = NUM2LONG(arg);
	}
	else {
	    arg = tmp;
#ifdef IOCPARM_MASK
#ifndef IOCPARM_LEN
#define IOCPARM_LEN(x)  (((x) &gt;&gt; 16) &amp; IOCPARM_MASK)
#endif
#endif
#ifdef IOCPARM_LEN
	    len = IOCPARM_LEN(cmd);	/* on BSDish systems we're safe */
#else
	    len = 256;		/* otherwise guess at what's safe */
#endif
	    rb_str_modify(arg);

	    if (len &lt;= RSTRING(arg)-&gt;len) {
		len = RSTRING(arg)-&gt;len;
	    }
	    if (RSTRING(arg)-&gt;len &lt; len) {
		rb_str_resize(arg, len+1);
	    }
	    RSTRING(arg)-&gt;ptr[len] = 17;	/* a little sanity check here */
	    narg = (long)RSTRING(arg)-&gt;ptr;
	}
    }
    GetOpenFile(io, fptr);
    retval = io_cntl(fileno(fptr-&gt;f), cmd, narg, io_p);
    if (retval &lt; 0) rb_sys_fail(fptr-&gt;path);
    if (TYPE(arg) == T_STRING &amp;&amp; RSTRING(arg)-&gt;ptr[len] != 17) {
	rb_raise(rb_eArgError, &quot;return value overflowed string&quot;);
    }

    if (fptr-&gt;f2 &amp;&amp; fileno(fptr-&gt;f) != fileno(fptr-&gt;f2)) {
	/* call on f2 too; ignore result */
	io_cntl(fileno(fptr-&gt;f2), cmd, narg, io_p);
    }

    if (!io_p &amp;&amp; cmd == F_SETFL) {
      if (narg &amp; O_NONBLOCK) {
        fptr-&gt;mode |= FMODE_WSPLIT_INITIALIZED;
        fptr-&gt;mode &amp;= ~FMODE_WSPLIT;
      }
      else {
        fptr-&gt;mode &amp;= ~(FMODE_WSPLIT_INITIALIZED|FMODE_WSPLIT);
      }
    }

    return INT2NUM(retval);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

/*
 *  call-seq:
 *     ios.ioctl(integer_cmd, arg)    =&gt; integer
 *  
 *  Provides a mechanism for issuing low-level commands to control or
 *  query I/O devices. Arguments and results are platform dependent. If
 *  &lt;i&gt;arg&lt;/i&gt; is a number, its value is passed directly. If it is a
 *  string, it is interpreted as a binary sequence of bytes. On Unix
 *  platforms, see &lt;code&gt;ioctl(2)&lt;/code&gt; for details. Not implemented on
 *  all platforms.
 */

static VALUE
rb_io_ioctl(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE req, arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;req, &amp;arg);
    return rb_io_ctl(io, req, arg, 1);
}

/*
 *  call-seq:
 *     ios.fcntl(integer_cmd, arg)    =&gt; integer
 *  
 *  Provides a mechanism for issuing low-level commands to control or
 *  query file-oriented I/O streams. Arguments and results are platform
 *  dependent. If &lt;i&gt;arg&lt;/i&gt; is a number, its value is passed
 *  directly. If it is a string, it is interpreted as a binary sequence
 *  of bytes (&lt;code&gt;Array#pack&lt;/code&gt; might be a useful way to build this
 *  string). On Unix platforms, see &lt;code&gt;fcntl(2)&lt;/code&gt; for details.
 *  Not implemented on all platforms.
 */

static VALUE
rb_io_fcntl(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
#ifdef HAVE_FCNTL
    VALUE req, arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;req, &amp;arg);
    return rb_io_ctl(io, req, arg, 0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

/*
 *  call-seq:
 *     syscall(fixnum [, args...])   =&gt; integer
 *  
 *  Calls the operating system function identified by _fixnum_,
 *  passing in the arguments, which must be either +String+
 *  objects, or +Integer+ objects that ultimately fit within
 *  a native +long+. Up to nine parameters may be passed (14
 *  on the Atari-ST). The function identified by _fixnum_ is system
 *  dependent. On some Unix systems, the numbers may be obtained from a
 *  header file called &lt;code&gt;syscall.h&lt;/code&gt;.
 *     
 *     syscall 4, 1, &quot;hello\n&quot;, 6   # '4' is write(2) on our box
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     hello
 */

static VALUE
rb_f_syscall(argc, argv)
    int argc;
    VALUE *argv;
{
#if defined(HAVE_SYSCALL) &amp;&amp; !defined(__CHECKER__)
#ifdef atarist
    unsigned long arg[14]; /* yes, we really need that many ! */
#else
    unsigned long arg[8];
#endif
    int retval = -1;
    int i = 1;
    int items = argc - 1;

    /* This probably won't work on machines where sizeof(long) != sizeof(int)
     * or where sizeof(long) != sizeof(char*).  But such machines will
     * not likely have syscall implemented either, so who cares?
     */

    rb_secure(2);
    if (argc == 0)
	rb_raise(rb_eArgError, &quot;too few arguments for syscall&quot;);
    if (argc &gt; sizeof(arg) / sizeof(arg[0]))
	rb_raise(rb_eArgError, &quot;too many arguments for syscall&quot;);
    arg[0] = NUM2LONG(argv[0]); argv++;
    while (items--) {
	VALUE v = rb_check_string_type(*argv);

	if (!NIL_P(v)) {
	    StringValue(v);
	    rb_str_modify(v);
	    arg[i] = (unsigned long)StringValueCStr(v);
	}
	else {
	    arg[i] = (unsigned long)NUM2LONG(*argv);
	}
	argv++;
	i++;
    }
    TRAP_BEG;
    switch (argc) {
      case 1:
	retval = syscall(arg[0]);
	break;
      case 2:
	retval = syscall(arg[0],arg[1]);
	break;
      case 3:
	retval = syscall(arg[0],arg[1],arg[2]);
	break;
      case 4:
	retval = syscall(arg[0],arg[1],arg[2],arg[3]);
	break;
      case 5:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4]);
	break;
      case 6:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5]);
	break;
      case 7:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6]);
	break;
      case 8:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7]);
	break;
#ifdef atarist
      case 9:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8]);
	break;
      case 10:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9]);
	break;
      case 11:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10]);
	break;
      case 12:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10], arg[11]);
	break;
      case 13:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10], arg[11], arg[12]);
	break;
      case 14:
	retval = syscall(arg[0],arg[1],arg[2],arg[3],arg[4],arg[5],arg[6],
	  arg[7], arg[8], arg[9], arg[10], arg[11], arg[12], arg[13]);
	break;
#endif /* atarist */
    }
    TRAP_END;
    if (retval &lt; 0) rb_sys_fail(0);
    return INT2NUM(retval);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static VALUE io_new_instance _((VALUE));
static VALUE
io_new_instance(args)
    VALUE args;
{
    return rb_class_new_instance(2, (VALUE*)args+1, *(VALUE*)args);
}

/*
 *  call-seq:
 *     IO.pipe -&gt; array
 *  
 *  Creates a pair of pipe endpoints (connected to each other) and
 *  returns them as a two-element array of &lt;code&gt;IO&lt;/code&gt; objects:
 *  &lt;code&gt;[&lt;/code&gt; &lt;i&gt;read_file&lt;/i&gt;, &lt;i&gt;write_file&lt;/i&gt; &lt;code&gt;]&lt;/code&gt;. Not
 *  available on all platforms.
 *     
 *  In the example below, the two processes close the ends of the pipe
 *  that they are not using. This is not just a cosmetic nicety. The
 *  read end of a pipe will not generate an end of file condition if
 *  there are any writers with the pipe still open. In the case of the
 *  parent process, the &lt;code&gt;rd.read&lt;/code&gt; will never return if it
 *  does not first issue a &lt;code&gt;wr.close&lt;/code&gt;.
 *     
 *     rd, wr = IO.pipe
 *     
 *     if fork
 *       wr.close
 *       puts &quot;Parent got: &lt;#{rd.read}&gt;&quot;
 *       rd.close
 *       Process.wait
 *     else
 *       rd.close
 *       puts &quot;Sending message to parent&quot;
 *       wr.write &quot;Hi Dad&quot;
 *       wr.close
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Sending message to parent
 *     Parent got: &lt;Hi Dad&gt;
 */

static VALUE
rb_io_s_pipe(klass)
    VALUE klass;
{
#ifndef __human68k__
    int pipes[2], state;
    VALUE r, w, args[3];

#ifdef _WIN32
    if (_pipe(pipes, 1024, O_BINARY) == -1)
#else
    if (pipe(pipes) == -1)
#endif
	rb_sys_fail(0);

    args[0] = klass;
    args[1] = INT2NUM(pipes[0]);
    args[2] = INT2FIX(O_RDONLY);
    r = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
	close(pipes[0]);
	close(pipes[1]);
	rb_jump_tag(state);
    }
    args[1] = INT2NUM(pipes[1]);
    args[2] = INT2FIX(O_WRONLY);
    w = rb_protect(io_new_instance, (VALUE)args, &amp;state);
    if (state) {
	close(pipes[1]);
	if (!NIL_P(r)) rb_io_close(r);
	rb_jump_tag(state);
    }
    rb_io_synchronized(RFILE(w)-&gt;fptr);

    return rb_assoc_new(r, w);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

struct foreach_arg {
    int argc;
    VALUE sep;
    VALUE io;
};

static VALUE
io_s_foreach(arg)
    struct foreach_arg *arg;
{
    VALUE str;

    while (!NIL_P(str = rb_io_getline(arg-&gt;sep, arg-&gt;io))) {
	rb_yield(str);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     IO.foreach(name, sep_string=$/) {|line| block }   =&gt; nil
 *  
 *  Executes the block for every line in the named I/O port, where lines
 *  are separated by &lt;em&gt;sep_string&lt;/em&gt;.
 *     
 *     IO.foreach(&quot;testfile&quot;) {|x| print &quot;GOT &quot;, x }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     GOT This is line one
 *     GOT This is line two
 *     GOT This is line three
 *     GOT And so on...
 */     

static VALUE
rb_io_s_foreach(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    VALUE fname;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;fname, &amp;arg.sep);
    RETURN_ENUMERATOR(self, argc, argv);
    SafeStringValue(fname);

    if (argc == 1) {
	arg.sep = rb_default_rs;
    }
    else if (!NIL_P(arg.sep)) {
	StringValue(arg.sep);
    }
    arg.io = rb_io_open(StringValueCStr(fname), &quot;r&quot;);
    if (NIL_P(arg.io)) return Qnil;

    return rb_ensure(io_s_foreach, (VALUE)&amp;arg, rb_io_close, arg.io);
}

static VALUE
io_s_readlines(arg)
    struct foreach_arg *arg;
{
    return rb_io_readlines(arg-&gt;argc, &amp;arg-&gt;sep, arg-&gt;io);
}

/*
 *  call-seq:
 *     IO.readlines(name, sep_string=$/)   =&gt; array
 *  
 *  Reads the entire file specified by &lt;i&gt;name&lt;/i&gt; as individual
 *  lines, and returns those lines in an array. Lines are separated by
 *  &lt;i&gt;sep_string&lt;/i&gt;.
 *     
 *     a = IO.readlines(&quot;testfile&quot;)
 *     a[0]   #=&gt; &quot;This is line one\n&quot;
 *     
 */

static VALUE
rb_io_s_readlines(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fname;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;fname, &amp;arg.sep);
    SafeStringValue(fname);

    arg.argc = argc - 1;
    arg.io = rb_io_open(StringValueCStr(fname), &quot;r&quot;);
    if (NIL_P(arg.io)) return Qnil;
    return rb_ensure(io_s_readlines, (VALUE)&amp;arg, rb_io_close, arg.io);
}

static VALUE
io_s_read(arg)
    struct foreach_arg *arg;
{
    return io_read(arg-&gt;argc, &amp;arg-&gt;sep, arg-&gt;io);
}

/*
 *  call-seq:
 *     IO.read(name, [length [, offset]] )   =&gt; string
 *  
 *  Opens the file, optionally seeks to the given offset, then returns
 *  &lt;i&gt;length&lt;/i&gt; bytes (defaulting to the rest of the file).
 *  &lt;code&gt;read&lt;/code&gt; ensures the file is closed before returning.
 *     
 *     IO.read(&quot;testfile&quot;)           #=&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;
 *     IO.read(&quot;testfile&quot;, 20)       #=&gt; &quot;This is line one\nThi&quot;
 *     IO.read(&quot;testfile&quot;, 20, 10)   #=&gt; &quot;ne one\nThis is line &quot;
 */

static VALUE
rb_io_s_read(argc, argv, io)
    int argc;
    VALUE *argv;
    VALUE io;
{
    VALUE fname, offset;
    struct foreach_arg arg;

    rb_scan_args(argc, argv, &quot;12&quot;, &amp;fname, &amp;arg.sep, &amp;offset);
    SafeStringValue(fname);

    arg.argc = argc ? 1 : 0;
    arg.io = rb_io_open(StringValueCStr(fname), &quot;r&quot;);
    if (NIL_P(arg.io)) return Qnil;
    if (!NIL_P(offset)) {
	rb_io_seek(arg.io, offset, SEEK_SET);
    }
    return rb_ensure(io_s_read, (VALUE)&amp;arg, rb_io_close, arg.io);
}

static VALUE
argf_tell()
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, &quot;no stream to tell&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_tell(current_file);
}

static VALUE
argf_seek_m(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, &quot;no stream to seek&quot;);
    }
    ARGF_FORWARD(argc, argv);
    return rb_io_seek_m(argc, argv, current_file);
}

static VALUE
argf_set_pos(self, offset)
     VALUE self, offset;
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, &quot;no stream to set position&quot;);
    }
    ARGF_FORWARD(1, &amp;offset);
    return rb_io_set_pos(current_file, offset);
}

static VALUE
argf_rewind()
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, &quot;no stream to rewind&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_rewind(current_file);
}

static VALUE
argf_fileno()
{
    if (!next_argv()) {
	rb_raise(rb_eArgError, &quot;no stream&quot;);
    }
    ARGF_FORWARD(0, 0);
    return rb_io_fileno(current_file);
}

static VALUE
argf_to_io()
{
    next_argv();
    ARGF_FORWARD(0, 0);
    return current_file;
}

static VALUE
argf_eof()
{
    if (current_file) {
	if (init_p == 0) return Qtrue;
	ARGF_FORWARD(0, 0);
	if (rb_io_eof(current_file)) {
	    return Qtrue;
	}
    }
    return Qfalse;
}

static VALUE
argf_read(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE tmp, str, length;
    long len = 0;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;length, &amp;str);
    if (!NIL_P(length)) {
	len = NUM2LONG(argv[0]);
    }
    if (!NIL_P(str)) {
	StringValue(str);
	rb_str_resize(str,0);
	argv[1] = Qnil;
    }

  retry:
    if (!next_argv()) {
	return str;
    }
    if (TYPE(current_file) != T_FILE) {
	tmp = argf_forward(argc, argv);
    }
    else {
	tmp = io_read(argc, argv, current_file);
    }
    if (NIL_P(str)) str = tmp;
    else if (!NIL_P(tmp)) rb_str_append(str, tmp);
    if (NIL_P(tmp) || NIL_P(length)) {
	if (next_p != -1) {
	    argf_close(current_file);
	    next_p = 1;
	    goto retry;
	}
    }
    else if (argc &gt;= 1) {
	if (RSTRING(str)-&gt;len &lt; len) {
	    len -= RSTRING(str)-&gt;len;
	    argv[0] = INT2NUM(len);
	    goto retry;
	}
    }
    return str;
}

static VALUE
argf_getc()
{
    VALUE byte;

  retry:
    if (!next_argv()) return Qnil;
    if (TYPE(current_file) != T_FILE) {
	byte = rb_funcall3(current_file, rb_intern(&quot;getc&quot;), 0, 0);
    }
    else {
	byte = rb_io_getc(current_file);
    }
    if (NIL_P(byte) &amp;&amp; next_p != -1) {
	argf_close(current_file);
	next_p = 1;
	goto retry;
    }

    return byte;
}

static VALUE
argf_readchar()
{
    VALUE c;

    NEXT_ARGF_FORWARD(0, 0);
    c = argf_getc();
    if (NIL_P(c)) {
	rb_eof_error();
    }
    return c;
}

static VALUE
argf_each_line(argc, argv, argf)
    int argc;
    VALUE *argv;
    VALUE argf;
{
    VALUE str;

    RETURN_ENUMERATOR(argf, argc, argv);
    if (!next_argv()) return Qnil;
    if (TYPE(current_file) != T_FILE) {
	for (;;) {
	    if (!next_argv()) return argf;
	    rb_iterate(rb_each, current_file, rb_yield, 0);
	    next_p = 1;
	}
    }
    while (!NIL_P(str = argf_getline(argc, argv))) {
	rb_yield(str);
    }
    return argf;
}

static VALUE
argf_each_byte(argf)
    VALUE argf;
{
    VALUE byte;

    RETURN_ENUMERATOR(argf, 0, 0);
    while (!NIL_P(byte = argf_getc())) {
	rb_yield(byte);
    }
    return argf;
}

static VALUE
argf_each_char(argf)
    VALUE argf;
{
    VALUE ch;

    RETURN_ENUMERATOR(argf, 0, 0);

    while (!NIL_P(ch = argf_getc())) {
	unsigned char c;
	int n;
	VALUE str, file;

      first_char:
	c = FIX2INT(ch);
	n = mbclen(c);
	str = rb_tainted_str_new((const char *)&amp;c, 1);
	file = current_file;

	while (--n &gt; 0) {
	    if (NIL_P(ch = argf_getc())) {
		rb_yield(str);
		return argf;
	    }
	    if (current_file != file) {
		rb_yield(str);
		goto first_char;
	    }
	    c = FIX2INT(ch);
	    rb_str_cat(str, (const char *)&amp;c, 1);
	}
	rb_yield(str);
    }
    return argf;
}

static VALUE
argf_filename()
{
    next_argv();
    return filename;
}

static VALUE
argf_file()
{
    next_argv();
    return current_file;
}

static VALUE
argf_binmode()
{
    binmode = 1;
    next_argv();
    ARGF_FORWARD(0, 0);
    rb_io_binmode(current_file);
    return argf;
}

static VALUE
argf_skip()
{
    if (next_p != -1) {
	argf_close(current_file);
	next_p = 1;
    }
    return argf;
}

static VALUE
argf_close_m()
{
    next_argv();
    argf_close(current_file);
    if (next_p != -1) {
	next_p = 1;
    }
    gets_lineno = 0;
    return argf;
}

static VALUE
argf_closed()
{
    next_argv();
    ARGF_FORWARD(0, 0);
    return rb_io_closed(current_file);
}

static VALUE
argf_to_s()
{
    return rb_str_new2(&quot;ARGF&quot;);
}

static VALUE
opt_i_get()
{
    if (!ruby_inplace_mode) return Qnil;
    return rb_str_new2(ruby_inplace_mode);
}

static void
opt_i_set(val)
    VALUE val;
{
    if (!RTEST(val)) {
	if (ruby_inplace_mode) free(ruby_inplace_mode);
	ruby_inplace_mode = 0;
	return;
    }
    StringValue(val);
    if (ruby_inplace_mode) free(ruby_inplace_mode);
    ruby_inplace_mode = 0;
    ruby_inplace_mode = strdup(StringValueCStr(val));
}

/*
 *  Class &lt;code&gt;IO&lt;/code&gt; is the basis for all input and output in Ruby.
 *  An I/O stream may be &lt;em&gt;duplexed&lt;/em&gt; (that is, bidirectional), and
 *  so may use more than one native operating system stream.
 *     
 *  Many of the examples in this section use class &lt;code&gt;File&lt;/code&gt;,
 *  the only standard subclass of &lt;code&gt;IO&lt;/code&gt;. The two classes are
 *  closely associated.
 *     
 *  As used in this section, &lt;em&gt;portname&lt;/em&gt; may take any of the
 *  following forms.
 *     
 *  * A plain string represents a filename suitable for the underlying
 *    operating system.
 *     
 *  * A string starting with ``&lt;code&gt;|&lt;/code&gt;'' indicates a subprocess.
 *    The remainder of the string following the ``&lt;code&gt;|&lt;/code&gt;'' is
 *    invoked as a process with appropriate input/output channels
 *    connected to it.
 *     
 *  * A string equal to ``&lt;code&gt;|-&lt;/code&gt;'' will create another Ruby
 *    instance as a subprocess.
 *     
 *  Ruby will convert pathnames between different operating system
 *  conventions if possible. For instance, on a Windows system the
 *  filename ``&lt;code&gt;/gumby/ruby/test.rb&lt;/code&gt;'' will be opened as
 *  ``&lt;code&gt;\gumby\ruby\test.rb&lt;/code&gt;''. When specifying a
 *  Windows-style filename in a Ruby string, remember to escape the
 *  backslashes:
 *     
 *     &quot;c:\\gumby\\ruby\\test.rb&quot;
 *     
 *  Our examples here will use the Unix-style forward slashes;
 *  &lt;code&gt;File::SEPARATOR&lt;/code&gt; can be used to get the
 *  platform-specific separator character.
 *     
 *  I/O ports may be opened in any one of several different modes, which
 *  are shown in this section as &lt;em&gt;mode&lt;/em&gt;. The mode may
 *  either be a Fixnum or a String. If numeric, it should be
 *  one of the operating system specific constants (O_RDONLY,
 *  O_WRONLY, O_RDWR, O_APPEND and so on). See man open(2) for
 *  more information.
 *
 *  If the mode is given as a String, it must be one of the
 *  values listed in the following table.
 *
 *    Mode |  Meaning
 *    -----+--------------------------------------------------------
 *    &quot;r&quot;  |  Read-only, starts at beginning of file  (default mode).
 *    -----+--------------------------------------------------------
 *    &quot;r+&quot; |  Read-write, starts at beginning of file.
 *    -----+--------------------------------------------------------
 *    &quot;w&quot;  |  Write-only, truncates existing file 
 *         |  to zero length or creates a new file for writing.
 *    -----+--------------------------------------------------------
 *    &quot;w+&quot; |  Read-write, truncates existing file to zero length
 *         |  or creates a new file for reading and writing.
 *    -----+--------------------------------------------------------
 *    &quot;a&quot;  |  Write-only, starts at end of file if file exists,
 *         |  otherwise creates a new file for writing.
 *    -----+--------------------------------------------------------
 *    &quot;a+&quot; |  Read-write, starts at end of file if file exists,
 *         |  otherwise creates a new file for reading and 
 *         |  writing.
 *    -----+--------------------------------------------------------
 *     &quot;b&quot; |  (DOS/Windows only) Binary file mode (may appear with 
 *         |  any of the key letters listed above).
 *
 *
 *  The global constant ARGF (also accessible as $&lt;) provides an
 *  IO-like stream which allows access to all files mentioned on the
 *  command line (or STDIN if no files are mentioned). ARGF provides
 *  the methods &lt;code&gt;#path&lt;/code&gt; and &lt;code&gt;#filename&lt;/code&gt; to access
 *  the name of the file currently being read.
 */

void
Init_IO()
{
#ifdef __CYGWIN__ 
#include &lt;sys/cygwin.h&gt;
    static struct __cygwin_perfile pf[] =
    {
	{&quot;&quot;, O_RDONLY | O_BINARY},
	{&quot;&quot;, O_WRONLY | O_BINARY},
	{&quot;&quot;, O_RDWR | O_BINARY},
	{&quot;&quot;, O_APPEND | O_BINARY},
	{NULL, 0}
    };
    cygwin_internal(CW_PERFILE, pf);
#endif

    rb_eIOError = rb_define_class(&quot;IOError&quot;, rb_eStandardError);
    rb_eEOFError = rb_define_class(&quot;EOFError&quot;, rb_eIOError);

    id_write = rb_intern(&quot;write&quot;);
    id_read = rb_intern(&quot;read&quot;);
    id_getc = rb_intern(&quot;getc&quot;);

    rb_define_global_function(&quot;syscall&quot;, rb_f_syscall, -1);

    rb_define_global_function(&quot;open&quot;, rb_f_open, -1);
    rb_define_global_function(&quot;printf&quot;, rb_f_printf, -1);
    rb_define_global_function(&quot;print&quot;, rb_f_print, -1);
    rb_define_global_function(&quot;putc&quot;, rb_f_putc, 1);
    rb_define_global_function(&quot;puts&quot;, rb_f_puts, -1);
    rb_define_global_function(&quot;gets&quot;, rb_f_gets, -1);
    rb_define_global_function(&quot;readline&quot;, rb_f_readline, -1);
    rb_define_global_function(&quot;getc&quot;, rb_f_getc, 0);
    rb_define_global_function(&quot;select&quot;, rb_f_select, -1);

    rb_define_global_function(&quot;readlines&quot;, rb_f_readlines, -1);

    rb_define_global_function(&quot;`&quot;, rb_f_backquote, 1);

    rb_define_global_function(&quot;p&quot;, rb_f_p, -1);
    rb_define_method(rb_mKernel, &quot;display&quot;, rb_obj_display, -1);

    rb_cIO = rb_define_class(&quot;IO&quot;, rb_cObject);
    rb_include_module(rb_cIO, rb_mEnumerable);

    rb_define_alloc_func(rb_cIO, io_alloc);
    rb_define_singleton_method(rb_cIO, &quot;new&quot;, rb_io_s_new, -1);
    rb_define_singleton_method(rb_cIO, &quot;open&quot;,  rb_io_s_open, -1);
    rb_define_singleton_method(rb_cIO, &quot;sysopen&quot;,  rb_io_s_sysopen, -1);
    rb_define_singleton_method(rb_cIO, &quot;for_fd&quot;, rb_io_s_for_fd, -1);
    rb_define_singleton_method(rb_cIO, &quot;popen&quot;, rb_io_s_popen, -1);
    rb_define_singleton_method(rb_cIO, &quot;foreach&quot;, rb_io_s_foreach, -1);
    rb_define_singleton_method(rb_cIO, &quot;readlines&quot;, rb_io_s_readlines, -1);
    rb_define_singleton_method(rb_cIO, &quot;read&quot;, rb_io_s_read, -1);
    rb_define_singleton_method(rb_cIO, &quot;select&quot;, rb_f_select, -1);
    rb_define_singleton_method(rb_cIO, &quot;pipe&quot;, rb_io_s_pipe, 0);

    rb_define_method(rb_cIO, &quot;initialize&quot;, rb_io_initialize, -1);

    rb_output_fs = Qnil;
    rb_define_hooked_variable(&quot;$,&quot;, &amp;rb_output_fs, 0, rb_str_setter);

    rb_global_variable(&amp;rb_default_rs);
    rb_rs = rb_default_rs = rb_str_new2(&quot;\n&quot;);
    rb_output_rs = Qnil;
    OBJ_FREEZE(rb_default_rs);	/* avoid modifying RS_default */
    rb_define_hooked_variable(&quot;$/&quot;, &amp;rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable(&quot;$-0&quot;, &amp;rb_rs, 0, rb_str_setter);
    rb_define_hooked_variable(&quot;$\\&quot;, &amp;rb_output_rs, 0, rb_str_setter);

    rb_define_hooked_variable(&quot;$.&quot;, &amp;lineno, 0, lineno_setter);
    rb_define_virtual_variable(&quot;$_&quot;, rb_lastline_get, rb_lastline_set);

    rb_define_method(rb_cIO, &quot;initialize_copy&quot;, rb_io_init_copy, 1);
    rb_define_method(rb_cIO, &quot;reopen&quot;, rb_io_reopen, -1);

    rb_define_method(rb_cIO, &quot;print&quot;, rb_io_print, -1);
    rb_define_method(rb_cIO, &quot;putc&quot;, rb_io_putc, 1);
    rb_define_method(rb_cIO, &quot;puts&quot;, rb_io_puts, -1);
    rb_define_method(rb_cIO, &quot;printf&quot;, rb_io_printf, -1);

    rb_define_method(rb_cIO, &quot;each&quot;,  rb_io_each_line, -1);
    rb_define_method(rb_cIO, &quot;each_line&quot;,  rb_io_each_line, -1);
    rb_define_method(rb_cIO, &quot;each_byte&quot;,  rb_io_each_byte, 0);
    rb_define_method(rb_cIO, &quot;each_char&quot;,  rb_io_each_char, 0);
    rb_define_method(rb_cIO, &quot;lines&quot;,  rb_io_lines, -1);
    rb_define_method(rb_cIO, &quot;bytes&quot;,  rb_io_bytes, 0);
    rb_define_method(rb_cIO, &quot;chars&quot;,  rb_io_each_char, 0);

    rb_define_method(rb_cIO, &quot;syswrite&quot;, rb_io_syswrite, 1);
    rb_define_method(rb_cIO, &quot;sysread&quot;,  rb_io_sysread, -1);

    rb_define_method(rb_cIO, &quot;fileno&quot;, rb_io_fileno, 0);
    rb_define_alias(rb_cIO, &quot;to_i&quot;, &quot;fileno&quot;);
    rb_define_method(rb_cIO, &quot;to_io&quot;, rb_io_to_io, 0);

    rb_define_method(rb_cIO, &quot;fsync&quot;,   rb_io_fsync, 0);
    rb_define_method(rb_cIO, &quot;sync&quot;,   rb_io_sync, 0);
    rb_define_method(rb_cIO, &quot;sync=&quot;,  rb_io_set_sync, 1);

    rb_define_method(rb_cIO, &quot;lineno&quot;,   rb_io_lineno, 0);
    rb_define_method(rb_cIO, &quot;lineno=&quot;,  rb_io_set_lineno, 1);

    rb_define_method(rb_cIO, &quot;readlines&quot;,  rb_io_readlines, -1);

    rb_define_method(rb_cIO, &quot;read_nonblock&quot;,  io_read_nonblock, -1);
    rb_define_method(rb_cIO, &quot;write_nonblock&quot;, rb_io_write_nonblock, 1);
    rb_define_method(rb_cIO, &quot;readpartial&quot;,  io_readpartial, -1);
    rb_define_method(rb_cIO, &quot;read&quot;,  io_read, -1);
    rb_define_method(rb_cIO, &quot;write&quot;, io_write, 1);
    rb_define_method(rb_cIO, &quot;gets&quot;,  rb_io_gets_m, -1);
    rb_define_method(rb_cIO, &quot;readline&quot;,  rb_io_readline, -1);
    rb_define_method(rb_cIO, &quot;getc&quot;,  rb_io_getc, 0);
    rb_define_method(rb_cIO, &quot;getbyte&quot;,  rb_io_getc, 0);
    rb_define_method(rb_cIO, &quot;readchar&quot;,  rb_io_readchar, 0);
    rb_define_method(rb_cIO, &quot;readbyte&quot;,  rb_io_readchar, 0);
    rb_define_method(rb_cIO, &quot;ungetc&quot;,rb_io_ungetc, 1);
    rb_define_method(rb_cIO, &quot;&lt;&lt;&quot;,    rb_io_addstr, 1);
    rb_define_method(rb_cIO, &quot;flush&quot;, rb_io_flush, 0);
    rb_define_method(rb_cIO, &quot;tell&quot;, rb_io_tell, 0);
    rb_define_method(rb_cIO, &quot;seek&quot;, rb_io_seek_m, -1);
    rb_define_const(rb_cIO, &quot;SEEK_SET&quot;, INT2FIX(SEEK_SET));
    rb_define_const(rb_cIO, &quot;SEEK_CUR&quot;, INT2FIX(SEEK_CUR));
    rb_define_const(rb_cIO, &quot;SEEK_END&quot;, INT2FIX(SEEK_END));
    rb_define_method(rb_cIO, &quot;rewind&quot;, rb_io_rewind, 0);
    rb_define_method(rb_cIO, &quot;pos&quot;, rb_io_tell, 0);
    rb_define_method(rb_cIO, &quot;pos=&quot;, rb_io_set_pos, 1);
    rb_define_method(rb_cIO, &quot;eof&quot;, rb_io_eof, 0);
    rb_define_method(rb_cIO, &quot;eof?&quot;, rb_io_eof, 0);

    rb_define_method(rb_cIO, &quot;close&quot;, rb_io_close_m, 0);
    rb_define_method(rb_cIO, &quot;closed?&quot;, rb_io_closed, 0);
    rb_define_method(rb_cIO, &quot;close_read&quot;, rb_io_close_read, 0);
    rb_define_method(rb_cIO, &quot;close_write&quot;, rb_io_close_write, 0);

    rb_define_method(rb_cIO, &quot;isatty&quot;, rb_io_isatty, 0);
    rb_define_method(rb_cIO, &quot;tty?&quot;, rb_io_isatty, 0);
    rb_define_method(rb_cIO, &quot;binmode&quot;,  rb_io_binmode, 0);
    rb_define_method(rb_cIO, &quot;sysseek&quot;, rb_io_sysseek, -1);

    rb_define_method(rb_cIO, &quot;ioctl&quot;, rb_io_ioctl, -1);
    rb_define_method(rb_cIO, &quot;fcntl&quot;, rb_io_fcntl, -1);
    rb_define_method(rb_cIO, &quot;pid&quot;, rb_io_pid, 0);
    rb_define_method(rb_cIO, &quot;inspect&quot;,  rb_io_inspect, 0);

    rb_define_variable(&quot;$stdin&quot;, &amp;rb_stdin);
    rb_stdin = prep_stdio(stdin, FMODE_READABLE, rb_cIO);
    rb_define_hooked_variable(&quot;$stdout&quot;, &amp;rb_stdout, 0, stdout_setter);
    rb_stdout = prep_stdio(stdout, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable(&quot;$stderr&quot;, &amp;rb_stderr, 0, stdout_setter);
    rb_stderr = prep_stdio(stderr, FMODE_WRITABLE, rb_cIO);
    rb_define_hooked_variable(&quot;$&gt;&quot;, &amp;rb_stdout, 0, stdout_setter);
    orig_stdout = rb_stdout;
    rb_deferr = orig_stderr = rb_stderr;

    /* variables to be removed in 1.8.1 */
    rb_define_hooked_variable(&quot;$defout&quot;, &amp;rb_stdout, 0, defout_setter);
    rb_define_hooked_variable(&quot;$deferr&quot;, &amp;rb_stderr, 0, deferr_setter);

    /* constants to hold original stdin/stdout/stderr */
    rb_define_global_const(&quot;STDIN&quot;, rb_stdin);
    rb_define_global_const(&quot;STDOUT&quot;, rb_stdout);
    rb_define_global_const(&quot;STDERR&quot;, rb_stderr);

    rb_define_readonly_variable(&quot;$&lt;&quot;, &amp;argf);
    argf = rb_obj_alloc(rb_cObject);
    rb_extend_object(argf, rb_mEnumerable);
    rb_define_global_const(&quot;ARGF&quot;, argf);

    rb_define_singleton_method(argf, &quot;to_s&quot;, argf_to_s, 0);

    rb_define_singleton_method(argf, &quot;fileno&quot;, argf_fileno, 0);
    rb_define_singleton_method(argf, &quot;to_i&quot;, argf_fileno, 0);
    rb_define_singleton_method(argf, &quot;to_io&quot;, argf_to_io, 0);
    rb_define_singleton_method(argf, &quot;each&quot;,  argf_each_line, -1);
    rb_define_singleton_method(argf, &quot;each_line&quot;,  argf_each_line, -1);
    rb_define_singleton_method(argf, &quot;each_byte&quot;,  argf_each_byte, 0);
    rb_define_singleton_method(argf, &quot;each_char&quot;,  argf_each_char, 0);
    rb_define_singleton_method(argf, &quot;lines&quot;,  argf_each_line, -1);
    rb_define_singleton_method(argf, &quot;bytes&quot;,  argf_each_byte, 0);
    rb_define_singleton_method(argf, &quot;chars&quot;,  argf_each_char, 0);

    rb_define_singleton_method(argf, &quot;read&quot;,  argf_read, -1);
    rb_define_singleton_method(argf, &quot;readlines&quot;, rb_f_readlines, -1);
    rb_define_singleton_method(argf, &quot;to_a&quot;, rb_f_readlines, -1);
    rb_define_singleton_method(argf, &quot;gets&quot;, rb_f_gets, -1);
    rb_define_singleton_method(argf, &quot;readline&quot;, rb_f_readline, -1);
    rb_define_singleton_method(argf, &quot;getc&quot;, argf_getc, 0);
    rb_define_singleton_method(argf, &quot;getbyte&quot;, argf_getc, 0);
    rb_define_singleton_method(argf, &quot;readchar&quot;, argf_readchar, 0);
    rb_define_singleton_method(argf, &quot;readbyte&quot;, argf_readchar, 0);
    rb_define_singleton_method(argf, &quot;tell&quot;, argf_tell, 0);
    rb_define_singleton_method(argf, &quot;seek&quot;, argf_seek_m, -1);
    rb_define_singleton_method(argf, &quot;rewind&quot;, argf_rewind, 0);
    rb_define_singleton_method(argf, &quot;pos&quot;, argf_tell, 0);
    rb_define_singleton_method(argf, &quot;pos=&quot;, argf_set_pos, 1);
    rb_define_singleton_method(argf, &quot;eof&quot;, argf_eof, 0);
    rb_define_singleton_method(argf, &quot;eof?&quot;, argf_eof, 0);
    rb_define_singleton_method(argf, &quot;binmode&quot;, argf_binmode, 0);

    rb_define_singleton_method(argf, &quot;filename&quot;, argf_filename, 0);
    rb_define_singleton_method(argf, &quot;path&quot;, argf_filename, 0);
    rb_define_singleton_method(argf, &quot;file&quot;, argf_file, 0);
    rb_define_singleton_method(argf, &quot;skip&quot;, argf_skip, 0);
    rb_define_singleton_method(argf, &quot;close&quot;, argf_close_m, 0);
    rb_define_singleton_method(argf, &quot;closed?&quot;, argf_closed, 0);

    rb_define_singleton_method(argf, &quot;lineno&quot;,   argf_lineno, 0);
    rb_define_singleton_method(argf, &quot;lineno=&quot;,  argf_set_lineno, 1);

    rb_global_variable(&amp;current_file);
    rb_define_readonly_variable(&quot;$FILENAME&quot;, &amp;filename);
    filename = rb_str_new2(&quot;-&quot;);

    rb_define_virtual_variable(&quot;$-i&quot;, opt_i_get, opt_i_set);

#if defined (_WIN32) || defined(DJGPP) || defined(__CYGWIN__) || defined(__human68k__)
    atexit(pipe_atexit);
#endif

    Init_File();

    rb_define_method(rb_cFile, &quot;initialize&quot;,  rb_file_initialize, -1);

    rb_file_const(&quot;RDONLY&quot;, INT2FIX(O_RDONLY));
    rb_file_const(&quot;WRONLY&quot;, INT2FIX(O_WRONLY));
    rb_file_const(&quot;RDWR&quot;, INT2FIX(O_RDWR));
    rb_file_const(&quot;APPEND&quot;, INT2FIX(O_APPEND));
    rb_file_const(&quot;CREAT&quot;, INT2FIX(O_CREAT));
    rb_file_const(&quot;EXCL&quot;, INT2FIX(O_EXCL));
#if defined(O_NDELAY) || defined(O_NONBLOCK)
#   ifdef O_NONBLOCK
    rb_file_const(&quot;NONBLOCK&quot;, INT2FIX(O_NONBLOCK));
#   else
    rb_file_const(&quot;NONBLOCK&quot;, INT2FIX(O_NDELAY));
#   endif
#endif
    rb_file_const(&quot;TRUNC&quot;, INT2FIX(O_TRUNC));
#ifdef O_NOCTTY
    rb_file_const(&quot;NOCTTY&quot;, INT2FIX(O_NOCTTY));
#endif
#ifdef O_BINARY
    rb_file_const(&quot;BINARY&quot;, INT2FIX(O_BINARY));
#endif
#ifdef O_SYNC
    rb_file_const(&quot;SYNC&quot;, INT2FIX(O_SYNC));
#endif
}
</pre>
    </div>