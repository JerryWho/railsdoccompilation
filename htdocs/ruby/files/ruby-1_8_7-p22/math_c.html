  <div id="fileHeader">
    <h1>math.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/math.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jan 25 07:34:13 -0600 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  math.c -

  $Author: mame $
  $Date: 2008-01-25 22:34:13 +0900 (Fri, 25 Jan 2008) $
  created at: Tue Jan 25 14:12:56 JST 1994

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;
#include &lt;math.h&gt;
#include &lt;errno.h&gt;

VALUE rb_mMath;

#define Need_Float(x) (x) = rb_Float(x)
#define Need_Float2(x,y) do {\
    Need_Float(x);\
    Need_Float(y);\
} while (0)

static void
domain_check(x, msg)
    double x;
    char *msg;
{
    while(1) {
	if (errno) {
	    rb_sys_fail(msg);
	}
	if (isnan(x)) {
#if defined(EDOM)
	    errno = EDOM;
#elif define(ERANGE)
	    errno = ERANGE;
#endif
	    continue;
	}
	break;
    }
}


/*
 *  call-seq:
 *     Math.atan2(y, x)  =&gt; float
 *  
 *  Computes the arc tangent given &lt;i&gt;y&lt;/i&gt; and &lt;i&gt;x&lt;/i&gt;. Returns
 *  -PI..PI.
 *     
 */

static VALUE
math_atan2(obj, y, x)
    VALUE obj, x, y;
{
    Need_Float2(y, x);
    return rb_float_new(atan2(RFLOAT(y)-&gt;value, RFLOAT(x)-&gt;value));
}


/*
 *  call-seq:
 *     Math.cos(x)    =&gt; float
 *  
 *  Computes the cosine of &lt;i&gt;x&lt;/i&gt; (expressed in radians). Returns
 *  -1..1.
 */

static VALUE
math_cos(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(cos(RFLOAT(x)-&gt;value));
}

/*
 *  call-seq:
 *     Math.sin(x)    =&gt; float
 *  
 *  Computes the sine of &lt;i&gt;x&lt;/i&gt; (expressed in radians). Returns
 *  -1..1.
 */

static VALUE
math_sin(obj, x)
    VALUE obj, x;
{
    Need_Float(x);

    return rb_float_new(sin(RFLOAT(x)-&gt;value));
}


/*
 *  call-seq:
 *     Math.tan(x)    =&gt; float
 *  
 *  Returns the tangent of &lt;i&gt;x&lt;/i&gt; (expressed in radians).
 */

static VALUE
math_tan(obj, x)
    VALUE obj, x;
{
    Need_Float(x);

    return rb_float_new(tan(RFLOAT(x)-&gt;value));
}

/*
 *  call-seq:
 *     Math.acos(x)    =&gt; float
 *  
 *  Computes the arc cosine of &lt;i&gt;x&lt;/i&gt;. Returns 0..PI.
 */

static VALUE
math_acos(obj, x)
    VALUE obj, x;
{
    double d;

    Need_Float(x);
    errno = 0;
    d = acos(RFLOAT(x)-&gt;value);
    domain_check(d, &quot;acos&quot;);
    return rb_float_new(d);
}

/*
 *  call-seq:
 *     Math.asin(x)    =&gt; float
 *  
 *  Computes the arc sine of &lt;i&gt;x&lt;/i&gt;. Returns -{PI/2} .. {PI/2}.
 */

static VALUE
math_asin(obj, x)
    VALUE obj, x;
{
    double d;

    Need_Float(x);
    errno = 0;
    d = asin(RFLOAT(x)-&gt;value);
    domain_check(d, &quot;asin&quot;);
    return rb_float_new(d);
}

/*
 *  call-seq:
 *     Math.atan(x)    =&gt; float
 *  
 *  Computes the arc tangent of &lt;i&gt;x&lt;/i&gt;. Returns -{PI/2} .. {PI/2}.
 */

static VALUE
math_atan(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(atan(RFLOAT(x)-&gt;value));
}

#ifndef HAVE_COSH
double
cosh(x)
    double x;
{
    return (exp(x) + exp(-x)) / 2;
}
#endif

/*
 *  call-seq:
 *     Math.cosh(x)    =&gt; float
 *  
 *  Computes the hyperbolic cosine of &lt;i&gt;x&lt;/i&gt; (expressed in radians).
 */

static VALUE
math_cosh(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    
    return rb_float_new(cosh(RFLOAT(x)-&gt;value));
}

#ifndef HAVE_SINH
double
sinh(x)
    double x;
{
    return (exp(x) - exp(-x)) / 2;
}
#endif

/*
 *  call-seq:
 *     Math.sinh(x)    =&gt; float
 *  
 *  Computes the hyperbolic sine of &lt;i&gt;x&lt;/i&gt; (expressed in
 *  radians).
 */

static VALUE
math_sinh(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(sinh(RFLOAT(x)-&gt;value));
}

#ifndef HAVE_TANH
double
tanh(x)
    double x;
{
    return sinh(x) / cosh(x);
}
#endif

/*
 *  call-seq:
 *     Math.tanh()    =&gt; float
 *  
 *  Computes the hyperbolic tangent of &lt;i&gt;x&lt;/i&gt; (expressed in
 *  radians).
 */

static VALUE
math_tanh(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(tanh(RFLOAT(x)-&gt;value));
}

/*
 *  call-seq:
 *     Math.acosh(x)    =&gt; float
 *  
 *  Computes the inverse hyperbolic cosine of &lt;i&gt;x&lt;/i&gt;.
 */

static VALUE
math_acosh(obj, x)
    VALUE obj, x;
{
    double d;

    Need_Float(x);
    errno = 0;
    d = acosh(RFLOAT(x)-&gt;value);
    domain_check(d, &quot;acosh&quot;);
    return rb_float_new(d);
}

/*
 *  call-seq:
 *     Math.asinh(x)    =&gt; float
 *  
 *  Computes the inverse hyperbolic sine of &lt;i&gt;x&lt;/i&gt;.
 */

static VALUE
math_asinh(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(asinh(RFLOAT(x)-&gt;value));
}

/*
 *  call-seq:
 *     Math.atanh(x)    =&gt; float
 *  
 *  Computes the inverse hyperbolic tangent of &lt;i&gt;x&lt;/i&gt;.
 */

static VALUE
math_atanh(obj, x)
    VALUE obj, x;
{
    double d;

    Need_Float(x);
    errno = 0;
    d = atanh(RFLOAT(x)-&gt;value);
    domain_check(d, &quot;atanh&quot;);
    return rb_float_new(d);
}

/*
 *  call-seq:
 *     Math.exp(x)    =&gt; float
 *  
 *  Returns e**x.
 */

static VALUE
math_exp(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(exp(RFLOAT(x)-&gt;value));
}

#if defined __CYGWIN__
# include &lt;cygwin/version.h&gt;
# if CYGWIN_VERSION_DLL_MAJOR &lt; 1005
#  define nan(x) nan()
# endif
# define log(x) ((x) &lt; 0.0 ? nan(&quot;&quot;) : log(x))
# define log10(x) ((x) &lt; 0.0 ? nan(&quot;&quot;) : log10(x))
#endif

/*
 *  call-seq:
 *     Math.log(numeric)    =&gt; float
 *  
 *  Returns the natural logarithm of &lt;i&gt;numeric&lt;/i&gt;.
 */

static VALUE
math_log(obj, x)
    VALUE obj, x;
{
    double d;

    Need_Float(x);
    errno = 0;
    d = log(RFLOAT(x)-&gt;value);
    domain_check(d, &quot;log&quot;);
    return rb_float_new(d);
}

/*
 *  call-seq:
 *     Math.log10(numeric)    =&gt; float
 *  
 *  Returns the base 10 logarithm of &lt;i&gt;numeric&lt;/i&gt;.
 */

static VALUE
math_log10(obj, x)
    VALUE obj, x;
{
    double d;

    Need_Float(x);
    errno = 0;
    d = log10(RFLOAT(x)-&gt;value);
    domain_check(d, &quot;log10&quot;);
    return rb_float_new(d);
}

/*
 *  call-seq:
 *     Math.sqrt(numeric)    =&gt; float
 *  
 *  Returns the non-negative square root of &lt;i&gt;numeric&lt;/i&gt;.
 */

static VALUE
math_sqrt(obj, x)
    VALUE obj, x;
{
    double d;

    Need_Float(x);
    errno = 0;
    d = sqrt(RFLOAT(x)-&gt;value);
    domain_check(d, &quot;sqrt&quot;);
    return rb_float_new(d);
}

/*
 *  call-seq:
 *     Math.frexp(numeric)    =&gt; [ fraction, exponent ]
 *  
 *  Returns a two-element array containing the normalized fraction (a
 *  &lt;code&gt;Float&lt;/code&gt;) and exponent (a &lt;code&gt;Fixnum&lt;/code&gt;) of
 *  &lt;i&gt;numeric&lt;/i&gt;.
 *     
 *     fraction, exponent = Math.frexp(1234)   #=&gt; [0.6025390625, 11]
 *     fraction * 2**exponent                  #=&gt; 1234.0
 */

static VALUE
math_frexp(obj, x)
    VALUE obj, x;
{
    double d;
    int exp;

    Need_Float(x);
    
    d = frexp(RFLOAT(x)-&gt;value, &amp;exp);
    return rb_assoc_new(rb_float_new(d), INT2NUM(exp));
}

/*
 *  call-seq:
 *     Math.ldexp(flt, int) -&gt; float
 *  
 *  Returns the value of &lt;i&gt;flt&lt;/i&gt;*(2**&lt;i&gt;int&lt;/i&gt;).
 *     
 *     fraction, exponent = Math.frexp(1234)
 *     Math.ldexp(fraction, exponent)   #=&gt; 1234.0
 */

static VALUE
math_ldexp(obj, x, n)
    VALUE obj, x, n;
{
    Need_Float(x);
    return rb_float_new(ldexp(RFLOAT(x)-&gt;value, NUM2INT(n)));
}

/*
 *  call-seq:
 *     Math.hypot(x, y)    =&gt; float
 *  
 *  Returns sqrt(x**2 + y**2), the hypotenuse of a right-angled triangle
 *  with sides &lt;i&gt;x&lt;/i&gt; and &lt;i&gt;y&lt;/i&gt;.
 *     
 *     Math.hypot(3, 4)   #=&gt; 5.0
 */

static VALUE
math_hypot(obj, x, y)
    VALUE obj, x, y;
{
    Need_Float2(x, y);
    return rb_float_new(hypot(RFLOAT(x)-&gt;value, RFLOAT(y)-&gt;value));
}

/*
 * call-seq:
 *    Math.erf(x)  =&gt; float
 *
 *  Calculates the error function of x.
 */

static VALUE
math_erf(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(erf(RFLOAT(x)-&gt;value));
}

/*
 * call-seq:
 *    Math.erfc(x)  =&gt; float
 *
 *  Calculates the complementary error function of x.
 */

static VALUE
math_erfc(obj, x)
    VALUE obj, x;
{
    Need_Float(x);
    return rb_float_new(erfc(RFLOAT(x)-&gt;value));
}

/*
 *  The &lt;code&gt;Math&lt;/code&gt; module contains module functions for basic
 *  trigonometric and transcendental functions. See class
 *  &lt;code&gt;Float&lt;/code&gt; for a list of constants that
 *  define Ruby's floating point accuracy.
 */     


void
Init_Math()
{
    rb_mMath = rb_define_module(&quot;Math&quot;);

#ifdef M_PI
    rb_define_const(rb_mMath, &quot;PI&quot;, rb_float_new(M_PI));
#else
    rb_define_const(rb_mMath, &quot;PI&quot;, rb_float_new(atan(1.0)*4.0));
#endif

#ifdef M_E
    rb_define_const(rb_mMath, &quot;E&quot;, rb_float_new(M_E));
#else
    rb_define_const(rb_mMath, &quot;E&quot;, rb_float_new(exp(1.0)));
#endif

    rb_define_module_function(rb_mMath, &quot;atan2&quot;, math_atan2, 2);
    rb_define_module_function(rb_mMath, &quot;cos&quot;, math_cos, 1);
    rb_define_module_function(rb_mMath, &quot;sin&quot;, math_sin, 1);
    rb_define_module_function(rb_mMath, &quot;tan&quot;, math_tan, 1);

    rb_define_module_function(rb_mMath, &quot;acos&quot;, math_acos, 1);
    rb_define_module_function(rb_mMath, &quot;asin&quot;, math_asin, 1);
    rb_define_module_function(rb_mMath, &quot;atan&quot;, math_atan, 1);

    rb_define_module_function(rb_mMath, &quot;cosh&quot;, math_cosh, 1);
    rb_define_module_function(rb_mMath, &quot;sinh&quot;, math_sinh, 1);
    rb_define_module_function(rb_mMath, &quot;tanh&quot;, math_tanh, 1);

    rb_define_module_function(rb_mMath, &quot;acosh&quot;, math_acosh, 1);
    rb_define_module_function(rb_mMath, &quot;asinh&quot;, math_asinh, 1);
    rb_define_module_function(rb_mMath, &quot;atanh&quot;, math_atanh, 1);

    rb_define_module_function(rb_mMath, &quot;exp&quot;, math_exp, 1);
    rb_define_module_function(rb_mMath, &quot;log&quot;, math_log, 1);
    rb_define_module_function(rb_mMath, &quot;log10&quot;, math_log10, 1);
    rb_define_module_function(rb_mMath, &quot;sqrt&quot;, math_sqrt, 1);

    rb_define_module_function(rb_mMath, &quot;frexp&quot;, math_frexp, 1);
    rb_define_module_function(rb_mMath, &quot;ldexp&quot;, math_ldexp, 2);

    rb_define_module_function(rb_mMath, &quot;hypot&quot;, math_hypot, 2);

    rb_define_module_function(rb_mMath, &quot;erf&quot;,  math_erf,  1);
    rb_define_module_function(rb_mMath, &quot;erfc&quot;, math_erfc, 1);
}
</pre>
    </div>