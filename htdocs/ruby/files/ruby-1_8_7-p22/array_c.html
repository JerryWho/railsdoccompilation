  <div id="fileHeader">
    <h1>array.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/array.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 20 02:38:15 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  array.c -

  $Author: shyouhei $
  $Date: 2008-06-20 16:38:15 +0900 (Fri, 20 Jun 2008) $
  created at: Fri Aug  6 09:46:12 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;util.h&quot;
#include &quot;st.h&quot;

VALUE rb_cArray;
static ID id_cmp;

#define ARY_DEFAULT_SIZE 16
#define ARY_MAX_SIZE (LONG_MAX / sizeof(VALUE))

void
rb_mem_clear(mem, size)
    register VALUE *mem;
    register long size;
{
    while (size--) {
	*mem++ = Qnil;
    }
}

static inline void
memfill(mem, size, val)
    register VALUE *mem;
    register long size;
    register VALUE val;
{
    while (size--) {
	*mem++ = val;
    }
}

#define ARY_TMPLOCK  FL_USER1

static inline void
rb_ary_modify_check(ary)
    VALUE ary;
{
    if (OBJ_FROZEN(ary)) rb_error_frozen(&quot;array&quot;);
    if (FL_TEST(ary, ARY_TMPLOCK))
	rb_raise(rb_eRuntimeError, &quot;can't modify array during iteration&quot;);
    if (!OBJ_TAINTED(ary) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't modify array&quot;);
}

static void
rb_ary_modify(ary)
    VALUE ary;
{
    VALUE *ptr;

    rb_ary_modify_check(ary);
    if (FL_TEST(ary, ELTS_SHARED)) {
	ptr = ALLOC_N(VALUE, RARRAY(ary)-&gt;len);
	FL_UNSET(ary, ELTS_SHARED);
	RARRAY(ary)-&gt;aux.capa = RARRAY(ary)-&gt;len;
	MEMCPY(ptr, RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;len);
	RARRAY(ary)-&gt;ptr = ptr;
    }
}

VALUE
rb_ary_freeze(ary)
    VALUE ary;
{
    return rb_obj_freeze(ary);
}

/*
 *  call-seq:
 *     array.frozen?  -&gt; true or false
 *
 *  Return &lt;code&gt;true&lt;/code&gt; if this array is frozen (or temporarily frozen
 *  while being sorted).
 */

static VALUE
rb_ary_frozen_p(ary)
    VALUE ary;
{
    if (OBJ_FROZEN(ary)) return Qtrue;
    if (FL_TEST(ary, ARY_TMPLOCK)) return Qtrue;
    return Qfalse;
}

static VALUE ary_alloc _((VALUE));
static VALUE
ary_alloc(klass)
    VALUE klass;
{
    NEWOBJ(ary, struct RArray);
    OBJSETUP(ary, klass, T_ARRAY);

    ary-&gt;len = 0;
    ary-&gt;ptr = 0;
    ary-&gt;aux.capa = 0;

    return (VALUE)ary;
}

static VALUE
ary_new(klass, len)
    VALUE klass;
    long len;
{
    VALUE ary = ary_alloc(klass);

    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;negative array size (or size too big)&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
	rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    if (len == 0) len++;
    RARRAY(ary)-&gt;ptr = ALLOC_N(VALUE, len);
    RARRAY(ary)-&gt;aux.capa = len;

    return ary;
}

VALUE
rb_ary_new2(len)
    long len;
{
    return ary_new(rb_cArray, len);
}


VALUE
rb_ary_new()
{
    return rb_ary_new2(ARY_DEFAULT_SIZE);
}

#ifdef HAVE_STDARG_PROTOTYPES
#include &lt;stdarg.h&gt;
#define va_init_list(a,b) va_start(a,b)
#else
#include &lt;varargs.h&gt;
#define va_init_list(a,b) va_start(a)
#endif

VALUE
#ifdef HAVE_STDARG_PROTOTYPES
rb_ary_new3(long n, ...)
#else
rb_ary_new3(n, va_alist)
    long n;
    va_dcl
#endif
{
    va_list ar;
    VALUE ary;
    long i;

    ary = rb_ary_new2(n);

    va_init_list(ar, n);
    for (i=0; i&lt;n; i++) {
	RARRAY(ary)-&gt;ptr[i] = va_arg(ar, VALUE);
    }
    va_end(ar);

    RARRAY(ary)-&gt;len = n;
    return ary;
}

VALUE
rb_ary_new4(n, elts)
    long n;
    const VALUE *elts;
{
    VALUE ary;

    ary = rb_ary_new2(n);
    if (n &gt; 0 &amp;&amp; elts) {
	MEMCPY(RARRAY(ary)-&gt;ptr, elts, VALUE, n);
    }

    /* This assignment to len will be moved to the above &quot;if&quot; block in Ruby 1.9 */
    RARRAY(ary)-&gt;len = n;

    return ary;
}

static VALUE
ary_make_shared(ary)
    VALUE ary;
{
    if (!FL_TEST(ary, ELTS_SHARED)) {
	NEWOBJ(shared, struct RArray);
	OBJSETUP(shared, rb_cArray, T_ARRAY);

	shared-&gt;len = RARRAY(ary)-&gt;len;
	shared-&gt;ptr = RARRAY(ary)-&gt;ptr;
	shared-&gt;aux.capa = RARRAY(ary)-&gt;aux.capa;
	RARRAY(ary)-&gt;aux.shared = (VALUE)shared;
	FL_SET(ary, ELTS_SHARED);
	OBJ_FREEZE(shared);
	return (VALUE)shared;
    }
    else {
	return RARRAY(ary)-&gt;aux.shared;
    }
}

VALUE
rb_assoc_new(car, cdr)
    VALUE car, cdr;
{
    VALUE ary;

    ary = rb_ary_new2(2);
    RARRAY(ary)-&gt;ptr[0] = car;
    RARRAY(ary)-&gt;ptr[1] = cdr;
    RARRAY(ary)-&gt;len = 2;

    return ary;
}

static VALUE
to_ary(ary)
    VALUE ary;
{
    return rb_convert_type(ary, T_ARRAY, &quot;Array&quot;, &quot;to_ary&quot;);
}

VALUE
rb_check_array_type(ary)
    VALUE ary;
{
    return rb_check_convert_type(ary, T_ARRAY, &quot;Array&quot;, &quot;to_ary&quot;);
}

static VALUE rb_ary_replace _((VALUE, VALUE));

/*
 *  call-seq:
 *     Array.new(size=0, obj=nil)
 *     Array.new(array)
 *     Array.new(size) {|index| block }
 *
 *  Returns a new array. In the first form, the new array is
 *  empty. In the second it is created with _size_ copies of _obj_
 *  (that is, _size_ references to the same
 *  _obj_). The third form creates a copy of the array
 *  passed as a parameter (the array is generated by calling
 *  to_ary  on the parameter). In the last form, an array
 *  of the given size is created. Each element in this array is
 *  calculated by passing the element's index to the given block and
 *  storing the return value.
 *
 *     Array.new
 *     Array.new(2)
 *     Array.new(5, &quot;A&quot;)
 * 
 *     # only one copy of the object is created
 *     a = Array.new(2, Hash.new)
 *     a[0]['cat'] = 'feline'
 *     a
 *     a[1]['cat'] = 'Felix'
 *     a
 * 
 *     # here multiple copies are created
 *     a = Array.new(2) { Hash.new }
 *     a[0]['cat'] = 'feline'
 *     a
 * 
 *     squares = Array.new(5) {|i| i*i}
 *     squares
 * 
 *     copy = Array.new(squares)
 */

static VALUE
rb_ary_initialize(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (rb_scan_args(argc, argv, &quot;02&quot;, &amp;size, &amp;val) == 0) {
	RARRAY(ary)-&gt;len = 0;
	if (rb_block_given_p()) {
	    rb_warning(&quot;given block not used&quot;);
	}
	return ary;
    }

    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
	val = rb_check_array_type(size);
	if (!NIL_P(val)) {
	    rb_ary_replace(ary, val);
	    return ary;
	}
    }

    len = NUM2LONG(size);
    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (len &gt; ARY_MAX_SIZE) {
	rb_raise(rb_eArgError, &quot;array size too big&quot;);
    }
    if (len &gt; RARRAY(ary)-&gt;aux.capa) {
	REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, len);
	RARRAY(ary)-&gt;aux.capa = len;
    }
    if (rb_block_given_p()) {
	long i;

	if (argc == 2) {
	    rb_warn(&quot;block supersedes default value argument&quot;);
	}
	for (i=0; i&lt;len; i++) {
	    rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
	    RARRAY(ary)-&gt;len = i + 1;
	}
    }
    else {
	memfill(RARRAY(ary)-&gt;ptr, len, val);
	RARRAY(ary)-&gt;len = len;
    }

    return ary;
}


/* 
* Returns a new array populated with the given objects. 
*
*   Array.[]( 1, 'a', /^A/ )
*   Array[ 1, 'a', /^A/ ]
*   [ 1, 'a', /^A/ ]
*/

static VALUE
rb_ary_s_create(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE ary = ary_alloc(klass);

    if (argc &gt; 0) {
	RARRAY(ary)-&gt;ptr = ALLOC_N(VALUE, argc);
	MEMCPY(RARRAY(ary)-&gt;ptr, argv, VALUE, argc);
    }
    RARRAY(ary)-&gt;len = RARRAY(ary)-&gt;aux.capa = argc;

    return ary;
}

void
rb_ary_store(ary, idx, val)
    VALUE ary;
    long idx;
    VALUE val;
{
    if (idx &lt; 0) {
	idx += RARRAY(ary)-&gt;len;
	if (idx &lt; 0) {
	    rb_raise(rb_eIndexError, &quot;index %ld out of array&quot;,
		    idx - RARRAY(ary)-&gt;len);
	}
    }
    else if (idx &gt;= ARY_MAX_SIZE) {
	rb_raise(rb_eIndexError, &quot;index %ld too big&quot;, idx);
    }

    rb_ary_modify(ary);
    if (idx &gt;= RARRAY(ary)-&gt;aux.capa) {
	long new_capa = RARRAY(ary)-&gt;aux.capa / 2;

	if (new_capa &lt; ARY_DEFAULT_SIZE) {
	    new_capa = ARY_DEFAULT_SIZE;
	}
	if (new_capa &gt;= ARY_MAX_SIZE - idx) {
	    new_capa = (ARY_MAX_SIZE - idx) / 2;
	}
	new_capa += idx;
	REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, new_capa);
	RARRAY(ary)-&gt;aux.capa = new_capa;
    }
    if (idx &gt; RARRAY(ary)-&gt;len) {
	rb_mem_clear(RARRAY(ary)-&gt;ptr + RARRAY(ary)-&gt;len,
		     idx-RARRAY(ary)-&gt;len + 1);
    }

    if (idx &gt;= RARRAY(ary)-&gt;len) {
	RARRAY(ary)-&gt;len = idx + 1;
    }
    RARRAY(ary)-&gt;ptr[idx] = val;
}

static VALUE
ary_shared_array(klass, ary)
    VALUE klass;
    VALUE ary;
{
    VALUE val = ary_alloc(klass);

    ary_make_shared(ary);
    RARRAY(val)-&gt;ptr = RARRAY(ary)-&gt;ptr;
    RARRAY(val)-&gt;len = RARRAY(ary)-&gt;len;
    RARRAY(val)-&gt;aux.shared = RARRAY(ary)-&gt;aux.shared;
    FL_SET(val, ELTS_SHARED);
    return val;
}

static VALUE
ary_shared_first(argc, argv, ary, last)
    int argc;
    VALUE *argv;
    VALUE ary;
    int last;
{
    VALUE nv, result;
    long n;
    long offset = 0;

    rb_scan_args(argc, argv, &quot;1&quot;, &amp;nv);
    n = NUM2LONG(nv);
    if (n &gt; RARRAY(ary)-&gt;len) {
	n = RARRAY(ary)-&gt;len;
    }
    else if (n &lt; 0) {
	rb_raise(rb_eArgError, &quot;negative array size&quot;);
    }
    if (last) {
	offset = RARRAY(ary)-&gt;len - n;
    }
    result = ary_shared_array(rb_cArray, ary);
    RARRAY(result)-&gt;ptr += offset;
    RARRAY(result)-&gt;len = n;

    return result;
}

/*
 *  call-seq:
 *     array &lt;&lt; obj            -&gt; array
 *  
 *  Append---Pushes the given object on to the end of this array. This
 *  expression returns the array itself, so several appends
 *  may be chained together.
 *
 *     [ 1, 2 ] &lt;&lt; &quot;c&quot; &lt;&lt; &quot;d&quot; &lt;&lt; [ 3, 4 ]
 *             #=&gt;  [ 1, 2, &quot;c&quot;, &quot;d&quot;, [ 3, 4 ] ]
 *
 */

VALUE
rb_ary_push(ary, item)
    VALUE ary;
    VALUE item;
{
    rb_ary_store(ary, RARRAY(ary)-&gt;len, item);
    return ary;
}

/* 
 *  call-seq:
 *     array.push(obj, ... )   -&gt; array
 *  
 *  Append---Pushes the given object(s) on to the end of this array. This
 *  expression returns the array itself, so several appends
 *  may be chained together.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.push(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)  
 *             #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
 */

static VALUE
rb_ary_push_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    while (argc--) {
	rb_ary_push(ary, *argv++);
    }
    return ary;
}

VALUE
rb_ary_pop(ary)
    VALUE ary;
{
    rb_ary_modify_check(ary);
    if (RARRAY(ary)-&gt;len == 0) return Qnil;
    if (!FL_TEST(ary, ELTS_SHARED) &amp;&amp;
	    RARRAY(ary)-&gt;len * 3 &lt; RARRAY(ary)-&gt;aux.capa &amp;&amp;
	    RARRAY(ary)-&gt;aux.capa &gt; ARY_DEFAULT_SIZE) {
	RARRAY(ary)-&gt;aux.capa = RARRAY(ary)-&gt;len * 2;
	REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;aux.capa);
    }
    return RARRAY(ary)-&gt;ptr[--RARRAY(ary)-&gt;len];
}

/*
 *  call-seq:
 *     array.pop    -&gt; obj or nil
 *     array.pop(n) -&gt; array
 *  
 *  Removes the last element from &lt;i&gt;self&lt;/i&gt; and returns it, or
 *  &lt;code&gt;nil&lt;/code&gt; if the array is empty.
 *
 *  If a number _n_ is given, returns an array of the last n elements
 *  (or less) just like &lt;code&gt;array.slice!(-n, n)&lt;/code&gt; does.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.pop     #=&gt; &quot;d&quot;
 *     a.pop(2)  #=&gt; [&quot;b&quot;, &quot;c&quot;]
 *     a         #=&gt; [&quot;a&quot;]
 */

static VALUE
rb_ary_pop_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE result;

    if (argc == 0) {
	return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_shared_first(argc, argv, ary, Qtrue);
    RARRAY(ary)-&gt;len -= RARRAY(result)-&gt;len;
    return result;
}

VALUE
rb_ary_shift(ary)
    VALUE ary;
{
    VALUE top;

    rb_ary_modify_check(ary);
    if (RARRAY(ary)-&gt;len == 0) return Qnil;
    top = RARRAY(ary)-&gt;ptr[0];
    if (!FL_TEST(ary, ELTS_SHARED)) {
        if (RARRAY(ary)-&gt;len &lt; ARY_DEFAULT_SIZE) {
            MEMMOVE(RARRAY(ary)-&gt;ptr, RARRAY(ary)-&gt;ptr+1, VALUE, RARRAY(ary)-&gt;len-1);
	    RARRAY(ary)-&gt;len--;
            return top;
        }
        RARRAY(ary)-&gt;ptr[0] = Qnil;
	ary_make_shared(ary);
    }
    RARRAY(ary)-&gt;ptr++;		/* shift ptr */
    RARRAY(ary)-&gt;len--;

    return top;
}

/*
 *  call-seq:
 *     array.shift    -&gt; obj or nil
 *     array.shift(n) -&gt; array
 *  
 *  Returns the first element of &lt;i&gt;self&lt;/i&gt; and removes it (shifting all
 *  other elements down by one). Returns &lt;code&gt;nil&lt;/code&gt; if the array
 *  is empty.
 *
 *  If a number _n_ is given, returns an array of the first n elements
 *  (or less) just like &lt;code&gt;array.slice!(0, n)&lt;/code&gt; does.
 *     
 *     args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
 *     args.shift     #=&gt; &quot;-m&quot;
 *     args           #=&gt; [&quot;-q&quot;, &quot;filename&quot;]
 *
 *     args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]
 *     args.shift(2)  #=&gt; [&quot;-m&quot;, &quot;-q&quot;]
 *     args           #=&gt; [&quot;filename&quot;]
 */

static VALUE
rb_ary_shift_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE result;
    long n;

    if (argc == 0) {
	return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_shared_first(argc, argv, ary, Qfalse);
    n = RARRAY(result)-&gt;len;
    if (FL_TEST(ary, ELTS_SHARED)) {
	RARRAY(ary)-&gt;ptr += n;
	RARRAY(ary)-&gt;len -= n;
	}
    else {
	MEMMOVE(RARRAY(ary)-&gt;ptr, RARRAY(ary)-&gt;ptr+n, VALUE, RARRAY(ary)-&gt;len-n);
	RARRAY(ary)-&gt;len -= n;
    }

    return result;
}

VALUE
rb_ary_unshift(ary, item)
    VALUE ary, item;
{
    rb_ary_modify(ary);
    if (RARRAY(ary)-&gt;len == RARRAY(ary)-&gt;aux.capa) {
	long capa_inc = RARRAY(ary)-&gt;aux.capa / 2;
	if (capa_inc &lt; ARY_DEFAULT_SIZE) {
	    capa_inc = ARY_DEFAULT_SIZE;
	}
	RARRAY(ary)-&gt;aux.capa += capa_inc;
	REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;aux.capa);
    }

    /* sliding items */
    MEMMOVE(RARRAY(ary)-&gt;ptr + 1, RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;len);

    RARRAY(ary)-&gt;len++;
    RARRAY(ary)-&gt;ptr[0] = item;

    return ary;
}

/*
 *  call-seq:
 *     array.unshift(obj, ...)  -&gt; array
 *  
 *  Prepends objects to the front of &lt;i&gt;array&lt;/i&gt;.
 *  other elements up one.
 *     
 *     a = [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.unshift(&quot;a&quot;)   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 *     a.unshift(1, 2)  #=&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 */

static VALUE
rb_ary_unshift_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long len = RARRAY(ary)-&gt;len;

    if (argc == 0) return ary;

    /* make rooms by setting the last item */
    rb_ary_store(ary, len + argc - 1, Qnil);

    /* sliding items */
    MEMMOVE(RARRAY(ary)-&gt;ptr + argc, RARRAY(ary)-&gt;ptr, VALUE, len);
    MEMCPY(RARRAY(ary)-&gt;ptr, argv, VALUE, argc);
    
    return ary;
}

/* faster version - use this if you don't need to treat negative offset */
static inline VALUE
rb_ary_elt(ary, offset)
    VALUE ary;
    long offset;
{
    if (RARRAY(ary)-&gt;len == 0) return Qnil;
    if (offset &lt; 0 || RARRAY(ary)-&gt;len &lt;= offset) {
	return Qnil;
    }
    return RARRAY(ary)-&gt;ptr[offset];
}

VALUE
rb_ary_entry(ary, offset)
    VALUE ary;
    long offset;
{
    if (offset &lt; 0) {
	offset += RARRAY(ary)-&gt;len;
    }
    return rb_ary_elt(ary, offset);
}

static VALUE
rb_ary_subseq(ary, beg, len)
    VALUE ary;
    long beg, len;
{
    VALUE klass, ary2, shared;
    VALUE *ptr;

    if (beg &gt; RARRAY(ary)-&gt;len) return Qnil;
    if (beg &lt; 0 || len &lt; 0) return Qnil;

    if (RARRAY(ary)-&gt;len &lt; len || RARRAY(ary)-&gt;len &lt; beg + len) {
	len = RARRAY(ary)-&gt;len - beg;
	if (len &lt; 0)
	    len = 0;
    }
    klass = rb_obj_class(ary);
    if (len == 0) return ary_new(klass, 0);

    shared = ary_make_shared(ary);
    ptr = RARRAY(ary)-&gt;ptr;
    ary2 = ary_alloc(klass);
    RARRAY(ary2)-&gt;ptr = ptr + beg;
    RARRAY(ary2)-&gt;len = len;
    RARRAY(ary2)-&gt;aux.shared = shared;
    FL_SET(ary2, ELTS_SHARED);

    return ary2;
}

/* 
 *  call-seq:
 *     array[index]                -&gt; obj      or nil
 *     array[start, length]        -&gt; an_array or nil
 *     array[range]                -&gt; an_array or nil
 *     array.slice(index)          -&gt; obj      or nil
 *     array.slice(start, length)  -&gt; an_array or nil
 *     array.slice(range)          -&gt; an_array or nil
 *
 *  Element Reference---Returns the element at _index_,
 *  or returns a subarray starting at _start_ and
 *  continuing for _length_ elements, or returns a subarray
 *  specified by _range_.
 *  Negative indices count backward from the end of the
 *  array (-1 is the last element). Returns nil if the index
 *  (or starting index) are out of range.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a[2] +  a[0] + a[1]    #=&gt; &quot;cab&quot;
 *     a[6]                   #=&gt; nil
 *     a[1, 2]                #=&gt; [ &quot;b&quot;, &quot;c&quot; ]
 *     a[1..3]                #=&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a[4..7]                #=&gt; [ &quot;e&quot; ]
 *     a[6..10]               #=&gt; nil
 *     a[-3, 3]               #=&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     # special cases
 *     a[5]                   #=&gt; nil
 *     a[5, 1]                #=&gt; []
 *     a[5..10]               #=&gt; []
 *
 */

VALUE
rb_ary_aref(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE arg;
    long beg, len;

    if (argc == 2) {
	if (SYMBOL_P(argv[0])) {
	    rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
	}
	beg = NUM2LONG(argv[0]);
	len = NUM2LONG(argv[1]);
	if (beg &lt; 0) {
	    beg += RARRAY(ary)-&gt;len;
	}
	return rb_ary_subseq(ary, beg, len);
    }
    if (argc != 1) {
	rb_scan_args(argc, argv, &quot;11&quot;, 0, 0);
    }
    arg = argv[0];
    /* special case - speeding up */
    if (FIXNUM_P(arg)) {
	return rb_ary_entry(ary, FIX2LONG(arg));
    }
    if (SYMBOL_P(arg)) {
	rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
    }
    /* check if idx is Range */
    switch (rb_range_beg_len(arg, &amp;beg, &amp;len, RARRAY(ary)-&gt;len, 0)) {
      case Qfalse:
	break;
      case Qnil:
	return Qnil;
      default:
	return rb_ary_subseq(ary, beg, len);
    }
    return rb_ary_entry(ary, NUM2LONG(arg));
}

/* 
 *  call-seq:
 *     array.at(index)   -&gt;   obj  or nil
 *
 *  Returns the element at _index_. A
 *  negative index counts from the end of _self_.  Returns +nil+
 *  if the index is out of range. See also &lt;code&gt;Array#[]&lt;/code&gt;.
 *  (&lt;code&gt;Array#at&lt;/code&gt; is slightly faster than &lt;code&gt;Array#[]&lt;/code&gt;,
 *  as it does not accept ranges and so on.)
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a.at(0)     #=&gt; &quot;a&quot;
 *     a.at(-1)    #=&gt; &quot;e&quot;
 */

static VALUE
rb_ary_at(ary, pos)
    VALUE ary, pos;
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}

/*
 *  call-seq:
 *     array.first   -&gt;   obj or nil
 *     array.first(n) -&gt; an_array
 *
 *  Returns the first element, or the first +n+ elements, of the array.
 *  If the array is empty, the first form returns &lt;code&gt;nil&lt;/code&gt;, and the
 *  second form returns an empty array.
 *
 *     a = [ &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot; ]
 *     a.first    #=&gt; &quot;q&quot;
 *     a.first(1) #=&gt; [&quot;q&quot;]
 *     a.first(3) #=&gt; [&quot;q&quot;, &quot;r&quot;, &quot;s&quot;]
 */

static VALUE
rb_ary_first(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    if (argc == 0) {
	if (RARRAY(ary)-&gt;len == 0) return Qnil;
	return RARRAY(ary)-&gt;ptr[0];
    }
    else {
	return ary_shared_first(argc, argv, ary, Qfalse);
    }
}

/*
 *  call-seq:
 *     array.last     -&gt;  obj or nil
 *     array.last(n)  -&gt;  an_array
 *  
 *  Returns the last element(s) of &lt;i&gt;self&lt;/i&gt;. If the array is empty,
 *  the first form returns &lt;code&gt;nil&lt;/code&gt;.
 *     
 *     [ &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ].last   #=&gt; &quot;z&quot;
 */

static VALUE
rb_ary_last(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    if (argc == 0) {
	if (RARRAY(ary)-&gt;len == 0) return Qnil;
	return RARRAY(ary)-&gt;ptr[RARRAY(ary)-&gt;len-1];
    }
    else {
	return ary_shared_first(argc, argv, ary, Qtrue);
    }
}

/*
 *  call-seq:
 *     array.fetch(index)                    -&gt; obj
 *     array.fetch(index, default )          -&gt; obj
 *     array.fetch(index) {|index| block }   -&gt; obj
 *  
 *  Tries to return the element at position &lt;i&gt;index&lt;/i&gt;. If the index
 *  lies outside the array, the first form throws an
 *  &lt;code&gt;IndexError&lt;/code&gt; exception, the second form returns
 *  &lt;i&gt;default&lt;/i&gt;, and the third form returns the value of invoking
 *  the block, passing in the index. Negative values of &lt;i&gt;index&lt;/i&gt;
 *  count from the end of the array.
 *     
 *     a = [ 11, 22, 33, 44 ]
 *     a.fetch(1)               #=&gt; 22
 *     a.fetch(-1)              #=&gt; 44
 *     a.fetch(4, 'cat')        #=&gt; &quot;cat&quot;
 *     a.fetch(4) { |i| i*i }   #=&gt; 16
 */

static VALUE
rb_ary_fetch(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
	rb_warn(&quot;block supersedes default value argument&quot;);
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
	idx +=  RARRAY(ary)-&gt;len;
    }
    if (idx &lt; 0 || RARRAY(ary)-&gt;len &lt;= idx) {
	if (block_given) return rb_yield(pos);
	if (argc == 1) {
	    rb_raise(rb_eIndexError, &quot;index %ld out of array&quot;, idx);
	}
	return ifnone;
    }
    return RARRAY(ary)-&gt;ptr[idx];
}

/*
 *  call-seq:
 *     array.index(obj)           -&gt;  int or nil
 *     array.index {|item| block} -&gt;  int or nil
 *  
 *  Returns the index of the first object in &lt;i&gt;self&lt;/i&gt; such that is
 *  &lt;code&gt;==&lt;/code&gt; to &lt;i&gt;obj&lt;/i&gt;. If a block is given instead of an
 *  argument, returns first object for which &lt;em&gt;block&lt;/em&gt; is true.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no match is found.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.index(&quot;b&quot;)        #=&gt; 1
 *     a.index(&quot;z&quot;)        #=&gt; nil
 *     a.index{|x|x==&quot;b&quot;}  #=&gt; 1
 *
 *  This is an alias of &lt;code&gt;#find_index&lt;/code&gt;.
 */

static VALUE
rb_ary_index(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE val;
    long i;

    if (argc  == 0) {
	RETURN_ENUMERATOR(ary, 0, 0);
	for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	    if (RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) {
		return LONG2NUM(i);
	    }
	}
	return Qnil;
    }
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;val);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	if (rb_equal(RARRAY(ary)-&gt;ptr[i], val))
	    return LONG2NUM(i);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     array.rindex(obj)    -&gt;  int or nil
 *  
 *  Returns the index of the last object in &lt;i&gt;array&lt;/i&gt;
 *  &lt;code&gt;==&lt;/code&gt; to &lt;i&gt;obj&lt;/i&gt;. If a block is given instead of an
 *  argument, returns first object for which &lt;em&gt;block&lt;/em&gt; is
 *  true. Returns &lt;code&gt;nil&lt;/code&gt; if no match is found.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.rindex(&quot;b&quot;)        #=&gt; 3
 *     a.rindex(&quot;z&quot;)        #=&gt; nil
 *     a.rindex{|x|x==&quot;b&quot;}  #=&gt; 3
 */

static VALUE
rb_ary_rindex(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE val;
    long i = RARRAY(ary)-&gt;len;

    if (argc == 0) {
	RETURN_ENUMERATOR(ary, 0, 0);
	while (i--) {
	    if (RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i])))
		return LONG2NUM(i);
	    if (i &gt; RARRAY(ary)-&gt;len) {
		i = RARRAY(ary)-&gt;len;
	    }
	}
	return Qnil;
    }
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;val);
    while (i--) {
	if (rb_equal(RARRAY(ary)-&gt;ptr[i], val))
	    return LONG2NUM(i);
	if (i &gt; RARRAY(ary)-&gt;len) {
	    i = RARRAY(ary)-&gt;len;
	}
    }
    return Qnil;
}

/*
 *  call-seq:
 *     array.indexes( i1, i2, ... iN )   -&gt; an_array
 *     array.indices( i1, i2, ... iN )   -&gt; an_array
 *  
 *  Deprecated; use &lt;code&gt;Array#values_at&lt;/code&gt;.
 */

static VALUE
rb_ary_indexes(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE new_ary;
    long i;

    rb_warn(&quot;Array#%s is deprecated; use Array#values_at&quot;, rb_id2name(rb_frame_last_func()));
    new_ary = rb_ary_new2(argc);
    for (i=0; i&lt;argc; i++) {
	rb_ary_push(new_ary, rb_ary_aref(1, argv+i, ary));
    }

    return new_ary;
}

VALUE
rb_ary_to_ary(obj)
    VALUE obj;
{
    if (TYPE(obj) == T_ARRAY) {
	return obj;
    }
    if (rb_respond_to(obj, rb_intern(&quot;to_ary&quot;))) {
	return rb_convert_type(obj, T_ARRAY, &quot;Array&quot;, &quot;to_ary&quot;);
    }
    return rb_ary_new3(1, obj);
}

static void
rb_ary_splice(ary, beg, len, rpl)
    VALUE ary;
    long beg, len;
    VALUE rpl;
{
    long rlen;

    if (len &lt; 0) rb_raise(rb_eIndexError, &quot;negative length (%ld)&quot;, len);
    if (beg &lt; 0) {
	beg += RARRAY(ary)-&gt;len;
	if (beg &lt; 0) {
	    beg -= RARRAY(ary)-&gt;len;
	    rb_raise(rb_eIndexError, &quot;index %ld out of array&quot;, beg);
	}
    }
    if (RARRAY(ary)-&gt;len &lt; len || RARRAY(ary)-&gt;len &lt; beg + len) {
	len = RARRAY(ary)-&gt;len - beg;
    }

    if (NIL_P(rpl)) {
	rlen = 0;
    }
    else {
	rpl = rb_ary_to_ary(rpl);
	rlen = RARRAY(rpl)-&gt;len;
    }
    rb_ary_modify(ary);

    if (beg &gt;= RARRAY(ary)-&gt;len) {
	if (beg &gt; ARY_MAX_SIZE - rlen) {
	    rb_raise(rb_eIndexError, &quot;index %ld too big&quot;, beg);
	}
	len = beg + rlen;
	if (len &gt;= RARRAY(ary)-&gt;aux.capa) {
	    REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, len);
	    RARRAY(ary)-&gt;aux.capa = len;
	}
	rb_mem_clear(RARRAY(ary)-&gt;ptr + RARRAY(ary)-&gt;len, beg - RARRAY(ary)-&gt;len);
	if (rlen &gt; 0) {
	    MEMCPY(RARRAY(ary)-&gt;ptr + beg, RARRAY(rpl)-&gt;ptr, VALUE, rlen);
	}
	RARRAY(ary)-&gt;len = len;
    }
    else {
	long alen;

	if (beg + len &gt; RARRAY(ary)-&gt;len) {
	    len = RARRAY(ary)-&gt;len - beg;
	}

	alen = RARRAY(ary)-&gt;len + rlen - len;
	if (alen &gt;= RARRAY(ary)-&gt;aux.capa) {
	    REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, alen);
	    RARRAY(ary)-&gt;aux.capa = alen;
	}

	if (len != rlen) {
	    MEMMOVE(RARRAY(ary)-&gt;ptr + beg + rlen, RARRAY(ary)-&gt;ptr + beg + len,
		    VALUE, RARRAY(ary)-&gt;len - (beg + len));
	    RARRAY(ary)-&gt;len = alen;
	}
	if (rlen &gt; 0) {
	    MEMMOVE(RARRAY(ary)-&gt;ptr + beg, RARRAY(rpl)-&gt;ptr, VALUE, rlen);
	}
    }
}

/* 
 *  call-seq:
 *     array[index]         = obj                     -&gt;  obj
 *     array[start, length] = obj or an_array or nil  -&gt;  obj or an_array or nil
 *     array[range]         = obj or an_array or nil  -&gt;  obj or an_array or nil
 *
 *  Element Assignment---Sets the element at _index_,
 *  or replaces a subarray starting at _start_ and
 *  continuing for _length_ elements, or replaces a subarray
 *  specified by _range_.  If indices are greater than
 *  the current capacity of the array, the array grows
 *  automatically. A negative indices will count backward
 *  from the end of the array. Inserts elements if _length_ is
 *  zero. If +nil+ is used in the second and third form,
 *  deletes elements from _self_. An +IndexError+ is raised if a
 *  negative index points past the beginning of the array. See also
 *  &lt;code&gt;Array#push&lt;/code&gt;, and &lt;code&gt;Array#unshift&lt;/code&gt;.
 * 
 *     a = Array.new
 *     a[4] = &quot;4&quot;;                 #=&gt; [nil, nil, nil, nil, &quot;4&quot;]
 *     a[0, 3] = [ 'a', 'b', 'c' ] #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, nil, &quot;4&quot;]
 *     a[1..2] = [ 1, 2 ]          #=&gt; [&quot;a&quot;, 1, 2, nil, &quot;4&quot;]
 *     a[0, 2] = &quot;?&quot;               #=&gt; [&quot;?&quot;, 2, nil, &quot;4&quot;]
 *     a[0..2] = &quot;A&quot;               #=&gt; [&quot;A&quot;, &quot;4&quot;]
 *     a[-1]   = &quot;Z&quot;               #=&gt; [&quot;A&quot;, &quot;Z&quot;]
 *     a[1..-1] = nil              #=&gt; [&quot;A&quot;]
 */

static VALUE
rb_ary_aset(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long offset, beg, len;

    if (argc == 3) {
	if (SYMBOL_P(argv[0])) {
	    rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
	}
	if (SYMBOL_P(argv[1])) {
	    rb_raise(rb_eTypeError, &quot;Symbol as subarray length&quot;);
	}
	rb_ary_splice(ary, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
	return argv[2];
    }
    if (argc != 2) {
	rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2)&quot;, argc);
    }
    if (FIXNUM_P(argv[0])) {
	offset = FIX2LONG(argv[0]);
	goto fixnum;
    }
    if (SYMBOL_P(argv[0])) {
	rb_raise(rb_eTypeError, &quot;Symbol as array index&quot;);
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY(ary)-&gt;len, 1)) {
	/* check if idx is Range */
	rb_ary_splice(ary, beg, len, argv[1]);
	return argv[1];
    }

    offset = NUM2LONG(argv[0]);
fixnum:
    rb_ary_store(ary, offset, argv[1]);
    return argv[1];
}

/*
 *  call-seq:
 *     array.insert(index, obj...)  -&gt; array
 *  
 *  Inserts the given values before the element with the given index
 *  (which may be negative).
 *     
 *     a = %w{ a b c d }
 *     a.insert(2, 99)         #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]
 *     a.insert(-2, 1, 2, 3)   #=&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]
 */

static VALUE
rb_ary_insert(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long pos;

    if (argc == 1) return ary;
    if (argc &lt; 1) {
	rb_raise(rb_eArgError, &quot;wrong number of arguments (at least 1)&quot;);
    }
    pos = NUM2LONG(argv[0]);
    if (pos == -1) {
	pos = RARRAY(ary)-&gt;len;
    }
    if (pos &lt; 0) {
	pos++;
    }
    rb_ary_splice(ary, pos, 0, rb_ary_new4(argc - 1, argv + 1));
    return ary;
}

/*
 *  call-seq:
 *     array.each {|item| block }   -&gt;   array
 *  
 *  Calls &lt;i&gt;block&lt;/i&gt; once for each element in &lt;i&gt;self&lt;/i&gt;, passing that
 *  element as a parameter.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.each {|x| print x, &quot; -- &quot; }
 *     
 *  produces:
 *     
 *     a -- b -- c --
 */

VALUE
rb_ary_each(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	rb_yield(RARRAY(ary)-&gt;ptr[i]);
    }
    return ary;
}

/*
 *  call-seq:
 *     array.each_index {|index| block }  -&gt;  array
 *  
 *  Same as &lt;code&gt;Array#each&lt;/code&gt;, but passes the index of the element
 *  instead of the element itself.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.each_index {|x| print x, &quot; -- &quot; }
 *     
 *  produces:
 *     
 *     0 -- 1 -- 2 --
 */

static VALUE
rb_ary_each_index(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	rb_yield(LONG2NUM(i));
    }
    return ary;
}

/*
 *  call-seq:
 *     array.reverse_each {|item| block } 
 *  
 *  Same as &lt;code&gt;Array#each&lt;/code&gt;, but traverses &lt;i&gt;self&lt;/i&gt; in reverse
 *  order.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.reverse_each {|x| print x, &quot; &quot; }
 *     
 *  produces:
 *     
 *     c b a
 */

static VALUE
rb_ary_reverse_each(ary)
    VALUE ary;
{
    long len;

    RETURN_ENUMERATOR(ary, 0, 0);
    len = RARRAY(ary)-&gt;len;
    while (len--) {
	rb_yield(RARRAY(ary)-&gt;ptr[len]);
	if (RARRAY(ary)-&gt;len &lt; len) {
	    len = RARRAY(ary)-&gt;len;
	}
    }
    return ary;
}

/*
 *  call-seq:
 *     array.length -&gt; int
 *  
 *  Returns the number of elements in &lt;i&gt;self&lt;/i&gt;. May be zero.
 *     
 *     [ 1, 2, 3, 4, 5 ].length   #=&gt; 5
 */

static VALUE
rb_ary_length(ary)
    VALUE ary;
{
    return LONG2NUM(RARRAY(ary)-&gt;len);
}

/*
 *  call-seq:
 *     array.empty?   -&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;self&lt;/i&gt; array contains no elements.
 *     
 *     [].empty?   #=&gt; true
 */

static VALUE
rb_ary_empty_p(ary)
    VALUE ary;
{
    if (RARRAY(ary)-&gt;len == 0)
	return Qtrue;
    return Qfalse;
}

VALUE
rb_ary_dup(ary)
    VALUE ary;
{
    VALUE dup = rb_ary_new2(RARRAY(ary)-&gt;len);

    DUPSETUP(dup, ary);
    MEMCPY(RARRAY(dup)-&gt;ptr, RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;len);
    RARRAY(dup)-&gt;len = RARRAY(ary)-&gt;len;
    return dup;
}

extern VALUE rb_output_fs;

static VALUE
inspect_join(ary, arg)
    VALUE ary;
    VALUE *arg;
{
    return rb_ary_join(arg[0], arg[1]);
}

VALUE
rb_ary_join(ary, sep)
    VALUE ary, sep;
{
    long len = 1, i;
    int taint = Qfalse;
    VALUE result, tmp;

    if (RARRAY(ary)-&gt;len == 0) return rb_str_new(0, 0);
    if (OBJ_TAINTED(ary) || OBJ_TAINTED(sep)) taint = Qtrue;

    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	tmp = rb_check_string_type(RARRAY(ary)-&gt;ptr[i]);
	len += NIL_P(tmp) ? 10 : RSTRING(tmp)-&gt;len;
    }
    if (!NIL_P(sep)) {
	StringValue(sep);
	len += RSTRING(sep)-&gt;len * (RARRAY(ary)-&gt;len - 1);
    }
    result = rb_str_buf_new(len);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	tmp = RARRAY(ary)-&gt;ptr[i];
	switch (TYPE(tmp)) {
	  case T_STRING:
	    break;
	  case T_ARRAY:
	    if (rb_inspecting_p(tmp)) {
		tmp = rb_str_new2(&quot;[...]&quot;);
	    }
	    else {
		VALUE args[2];

		args[0] = tmp;
		args[1] = sep;
		tmp = rb_protect_inspect(inspect_join, ary, (VALUE)args);
	    }
	    break;
	  default:
	    tmp = rb_obj_as_string(tmp);
	}
	if (i &gt; 0 &amp;&amp; !NIL_P(sep))
	    rb_str_buf_append(result, sep);
	rb_str_buf_append(result, tmp);
	if (OBJ_TAINTED(tmp)) taint = Qtrue;
    }

    if (taint) OBJ_TAINT(result);
    return result;
}

/*
 *  call-seq:
 *     array.join(sep=$,)    -&gt; str
 *  
 *  Returns a string created by converting each element of the array to
 *  a string, separated by &lt;i&gt;sep&lt;/i&gt;.
 *     
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        #=&gt; &quot;abc&quot;
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   #=&gt; &quot;a-b-c&quot;
 */

static VALUE
rb_ary_join_m(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE sep;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;sep);
    if (NIL_P(sep)) sep = rb_output_fs;
    
    return rb_ary_join(ary, sep);
}

/*
 *  call-seq:
 *     array.to_s -&gt; string
 *  
 *  Returns _self_&lt;code&gt;.join&lt;/code&gt;.
 *     
 *     [ &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot; ].to_s   #=&gt; &quot;aeio&quot;
 *
 */

VALUE
rb_ary_to_s(ary)
    VALUE ary;
{
    if (RARRAY(ary)-&gt;len == 0) return rb_str_new(0, 0);
    
    return rb_ary_join(ary, rb_output_fs);
}

static ID inspect_key;

struct inspect_arg {
    VALUE (*func)();
    VALUE arg1, arg2;
};

static VALUE
inspect_call(arg)
    struct inspect_arg *arg;
{
    return (*arg-&gt;func)(arg-&gt;arg1, arg-&gt;arg2);
}

static VALUE
get_inspect_tbl(create)
    int create;
{
    VALUE inspect_tbl = rb_thread_local_aref(rb_thread_current(), inspect_key);

    if (NIL_P(inspect_tbl)) {
	if (create) {
	  tbl_init:
	    inspect_tbl = rb_ary_new();
	    rb_thread_local_aset(rb_thread_current(), inspect_key, inspect_tbl);
	}
    }
    else if (TYPE(inspect_tbl) != T_ARRAY) {
	rb_warn(&quot;invalid inspect_tbl value&quot;);
	if (create) goto tbl_init;
	rb_thread_local_aset(rb_thread_current(), inspect_key, Qnil);
	return Qnil;
    }
    return inspect_tbl;
}

static VALUE
inspect_ensure(obj)
    VALUE obj;
{
    VALUE inspect_tbl;

    inspect_tbl = get_inspect_tbl(Qfalse);
    if (!NIL_P(inspect_tbl)) {
	rb_ary_pop(inspect_tbl);
    }
    return 0;
}

VALUE
rb_protect_inspect(func, obj, arg)
    VALUE (*func)(ANYARGS);
    VALUE obj, arg;
{
    struct inspect_arg iarg;
    VALUE inspect_tbl;
    VALUE id;

    inspect_tbl = get_inspect_tbl(Qtrue);
    id = rb_obj_id(obj);
    if (rb_ary_includes(inspect_tbl, id)) {
	return (*func)(obj, arg);
    }
    rb_ary_push(inspect_tbl, id);
    iarg.func = func;
    iarg.arg1 = obj;
    iarg.arg2 = arg;

    return rb_ensure(inspect_call, (VALUE)&amp;iarg, inspect_ensure, obj);
}

VALUE
rb_inspecting_p(obj)
    VALUE obj;
{
    VALUE inspect_tbl;

    inspect_tbl = get_inspect_tbl(Qfalse);
    if (NIL_P(inspect_tbl)) return Qfalse;
    return rb_ary_includes(inspect_tbl, rb_obj_id(obj));
}

static VALUE
inspect_ary(ary)
    VALUE ary;
{
    int tainted = OBJ_TAINTED(ary);
    long i;
    VALUE s, str;

    str = rb_str_buf_new2(&quot;[&quot;);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	s = rb_inspect(RARRAY(ary)-&gt;ptr[i]);
	if (OBJ_TAINTED(s)) tainted = Qtrue;
	if (i &gt; 0) rb_str_buf_cat2(str, &quot;, &quot;);
	rb_str_buf_append(str, s);
    }
    rb_str_buf_cat2(str, &quot;]&quot;);
    if (tainted) OBJ_TAINT(str);
    return str;
}

/*
 *  call-seq:
 *     array.inspect  -&gt; string
 *
 *  Create a printable version of &lt;i&gt;array&lt;/i&gt;.
 */

static VALUE
rb_ary_inspect(ary)
    VALUE ary;
{
    if (RARRAY(ary)-&gt;len == 0) return rb_str_new2(&quot;[]&quot;);
    if (rb_inspecting_p(ary)) return rb_str_new2(&quot;[...]&quot;);
    return rb_protect_inspect(inspect_ary, ary, 0);
}

/*
 *  call-seq:
 *     array.to_a     -&gt; array
 *  
 *  Returns _self_. If called on a subclass of Array, converts
 *  the receiver to an Array object.
 */

static VALUE
rb_ary_to_a(ary)
    VALUE ary;
{
    if (rb_obj_class(ary) != rb_cArray) {
	VALUE dup = rb_ary_new2(RARRAY(ary)-&gt;len);
	rb_ary_replace(dup, ary);
	return dup;
    }
    return ary;
}

/*
 *  call-seq:
 *     array.to_ary -&gt; array
 *  
 *  Returns _self_.
 */

static VALUE
rb_ary_to_ary_m(ary)
    VALUE ary;
{
    return ary;
}

VALUE
rb_ary_reverse(ary)
    VALUE ary;
{
    VALUE *p1, *p2;
    VALUE tmp;

    rb_ary_modify(ary);
    if (RARRAY(ary)-&gt;len &gt; 1) {
	p1 = RARRAY(ary)-&gt;ptr;
	p2 = p1 + RARRAY(ary)-&gt;len - 1;	/* points last item */

	while (p1 &lt; p2) {
	    tmp = *p1;
	    *p1++ = *p2;
	    *p2-- = tmp;
	}
    }
    return ary;
}

/*
 *  call-seq:
 *     array.reverse!   -&gt; array 
 *  
 *  Reverses _self_ in place.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.reverse!       #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 *     a                #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 */

static VALUE
rb_ary_reverse_bang(ary)
    VALUE ary;
{
    return rb_ary_reverse(ary);
}

/*
 *  call-seq:
 *     array.reverse -&gt; an_array
 *  
 *  Returns a new array containing &lt;i&gt;self&lt;/i&gt;'s elements in reverse order.
 *     
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].reverse   #=&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 *     [ 1 ].reverse               #=&gt; [1]
 */

static VALUE
rb_ary_reverse_m(ary)
    VALUE ary;
{
    return rb_ary_reverse(rb_ary_dup(ary));
}

struct ary_sort_data {
    VALUE ary;
    VALUE *ptr;
    long len;
};

static void
ary_sort_check(data)
    struct ary_sort_data *data;
{
    if (RARRAY(data-&gt;ary)-&gt;ptr != data-&gt;ptr || RARRAY(data-&gt;ary)-&gt;len != data-&gt;len) {
	rb_raise(rb_eArgError, &quot;array modified during sort&quot;);
    }
}

static int
sort_1(a, b, data)
    VALUE *a, *b;
    struct ary_sort_data *data;
{
    VALUE retval = rb_yield_values(2, *a, *b);
    int n;

    n = rb_cmpint(retval, *a, *b);
    ary_sort_check(data);
    return n;
}

static int
sort_2(ap, bp, data)
    VALUE *ap, *bp;
    struct ary_sort_data *data;
{
    VALUE retval;
    VALUE a = *ap, b = *bp;
    int n;

    if (FIXNUM_P(a) &amp;&amp; FIXNUM_P(b)) {
	if ((long)a &gt; (long)b) return 1;
	if ((long)a &lt; (long)b) return -1;
	return 0;
    }
    if (TYPE(a) == T_STRING) {
	if (TYPE(b) == T_STRING) return rb_str_cmp(a, b);
    }

    retval = rb_funcall(a, id_cmp, 1, b);
    n = rb_cmpint(retval, a, b);
    ary_sort_check(data);

    return n;
}

static VALUE
sort_internal(ary)
    VALUE ary;
{
    struct ary_sort_data data;

    data.ary = ary;
    data.ptr = RARRAY(ary)-&gt;ptr; data.len = RARRAY(ary)-&gt;len;
    qsort(RARRAY(ary)-&gt;ptr, RARRAY(ary)-&gt;len, sizeof(VALUE),
	  rb_block_given_p()?sort_1:sort_2, &amp;data);
    return ary;
}

static VALUE
sort_unlock(ary)
    VALUE ary;
{
    FL_UNSET(ary, ARY_TMPLOCK);
    return ary;
}

/*
 *  call-seq:
 *     array.sort!                   -&gt; array
 *     array.sort! {| a,b | block }  -&gt; array 
 *  
 *  Sorts _self_. Comparisons for
 *  the sort will be done using the &lt;code&gt;&lt;=&gt;&lt;/code&gt; operator or using
 *  an optional code block. The block implements a comparison between
 *  &lt;i&gt;a&lt;/i&gt; and &lt;i&gt;b&lt;/i&gt;, returning -1, 0, or +1. See also
 *  &lt;code&gt;Enumerable#sort_by&lt;/code&gt;.
 *     
 *     a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
 *     a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
 *     a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 */

VALUE
rb_ary_sort_bang(ary)
    VALUE ary;
{
    rb_ary_modify(ary);
    if (RARRAY(ary)-&gt;len &gt; 1) {
	FL_SET(ary, ARY_TMPLOCK);	/* prohibit modification during sort */
	rb_ensure(sort_internal, ary, sort_unlock, ary);
    }
    return ary;
}

/*
 *  call-seq:
 *     array.sort                   -&gt; an_array 
 *     array.sort {| a,b | block }  -&gt; an_array 
 *  
 *  Returns a new array created by sorting &lt;i&gt;self&lt;/i&gt;. Comparisons for
 *  the sort will be done using the &lt;code&gt;&lt;=&gt;&lt;/code&gt; operator or using
 *  an optional code block. The block implements a comparison between
 *  &lt;i&gt;a&lt;/i&gt; and &lt;i&gt;b&lt;/i&gt;, returning -1, 0, or +1. See also
 *  &lt;code&gt;Enumerable#sort_by&lt;/code&gt;.
 *     
 *     a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]
 *     a.sort                    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
 *     a.sort {|x,y| y &lt;=&gt; x }   #=&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]
 */

VALUE
rb_ary_sort(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}

/*
 *  call-seq:
 *     array.collect {|item| block }  -&gt; an_array
 *     array.map     {|item| block }  -&gt; an_array
 *  
 *  Invokes &lt;i&gt;block&lt;/i&gt; once for each element of &lt;i&gt;self&lt;/i&gt;. Creates a 
 *  new array containing the values returned by the block.
 *  See also &lt;code&gt;Enumerable#collect&lt;/code&gt;.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.collect {|x| x + &quot;!&quot; }   #=&gt; [&quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot;]
 *     a                          #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
 */

static VALUE
rb_ary_collect(ary)
    VALUE ary;
{
    long i;
    VALUE collect;

    if (!rb_block_given_p()) {
	return rb_ary_new4(RARRAY(ary)-&gt;len, RARRAY(ary)-&gt;ptr);
    }

    collect = rb_ary_new2(RARRAY(ary)-&gt;len);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
	rb_ary_push(collect, rb_yield(RARRAY(ary)-&gt;ptr[i]));
    }
    return collect;
}

/* 
 *  call-seq:
 *     array.collect! {|item| block }   -&gt;   array
 *     array.map!     {|item| block }   -&gt;   array
 *
 *  Invokes the block once for each element of _self_, replacing the
 *  element with the value returned by _block_.
 *  See also &lt;code&gt;Enumerable#collect&lt;/code&gt;.
 *   
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.collect! {|x| x + &quot;!&quot; }
 *     a             #=&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]
 */

static VALUE
rb_ary_collect_bang(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
	rb_ary_store(ary, i, rb_yield(RARRAY(ary)-&gt;ptr[i]));
    }
    return ary;
}

VALUE
rb_values_at(obj, olen, argc, argv, func)
    VALUE obj;
    long olen;
    int argc;
    VALUE *argv;
    VALUE (*func) _((VALUE,long));
{
    VALUE result = rb_ary_new2(argc);
    long beg, len, i, j;

    for (i=0; i&lt;argc; i++) {
	if (FIXNUM_P(argv[i])) {
	    rb_ary_push(result, (*func)(obj, FIX2LONG(argv[i])));
	    continue;
	}
	/* check if idx is Range */
	switch (rb_range_beg_len(argv[i], &amp;beg, &amp;len, olen, 0)) {
	  case Qfalse:
	    break;
	  case Qnil:
	    continue;
	  default:
	    for (j=0; j&lt;len; j++) {
		rb_ary_push(result, (*func)(obj, j+beg));
	    }
	    continue;
	}
	rb_ary_push(result, (*func)(obj, NUM2LONG(argv[i])));
    }
    return result;
}

/* 
 *  call-seq:
 *     array.values_at(selector,... )  -&gt; an_array
 *
 *  Returns an array containing the elements in
 *  _self_ corresponding to the given selector(s). The selectors
 *  may be either integer indices or ranges. 
 *  See also &lt;code&gt;Array#select&lt;/code&gt;.
 * 
 *     a = %w{ a b c d e f }
 *     a.values_at(1, 3, 5)
 *     a.values_at(1, 3, 5, 7)
 *     a.values_at(-1, -3, -5, -7)
 *     a.values_at(1..3, 2...5)
 */

static VALUE
rb_ary_values_at(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    return rb_values_at(ary, RARRAY(ary)-&gt;len, argc, argv, rb_ary_entry);
}

/*
 *  call-seq:
 *     array.select {|item| block } -&gt; an_array
 *  
 *  Invokes the block passing in successive elements from &lt;i&gt;array&lt;/i&gt;,
 *  returning an array containing those elements for which the block
 *  returns a true value (equivalent to &lt;code&gt;Enumerable#select&lt;/code&gt;).
 *     
 *     a = %w{ a b c d e f }
 *     a.select {|v| v =~ /[aeiou]/}   #=&gt; [&quot;a&quot;, &quot;e&quot;]
 */

static VALUE
rb_ary_select(ary)
    VALUE ary;
{
    VALUE result;
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    result = rb_ary_new2(RARRAY(ary)-&gt;len);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
	if (RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) {
	    rb_ary_push(result, rb_ary_elt(ary, i));
	}
    }
    return result;
}

/*
 *  call-seq:
 *     array.delete(obj)            -&gt; obj or nil 
 *     array.delete(obj) { block }  -&gt; obj or nil
 *  
 *  Deletes items from &lt;i&gt;self&lt;/i&gt; that are equal to &lt;i&gt;obj&lt;/i&gt;. If
 *  the item is not found, returns &lt;code&gt;nil&lt;/code&gt;. If the optional
 *  code block is given, returns the result of &lt;i&gt;block&lt;/i&gt; if the item
 *  is not found.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.delete(&quot;b&quot;)                   #=&gt; &quot;b&quot;
 *     a                               #=&gt; [&quot;a&quot;, &quot;c&quot;]
 *     a.delete(&quot;z&quot;)                   #=&gt; nil
 *     a.delete(&quot;z&quot;) { &quot;not found&quot; }   #=&gt; &quot;not found&quot;
 */

VALUE
rb_ary_delete(ary, item)
    VALUE ary;
    VALUE item;
{
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY(ary)-&gt;len; i1++) {
	VALUE e = RARRAY(ary)-&gt;ptr[i1];

	if (rb_equal(e, item)) continue;
	if (i1 != i2) {
	    rb_ary_store(ary, i2, e);
	}
	i2++;
    }
    if (RARRAY(ary)-&gt;len == i2) {
	if (rb_block_given_p()) {
	    return rb_yield(item);
	}
	return Qnil;
    }

    rb_ary_modify(ary);
    if (RARRAY(ary)-&gt;len &gt; i2) {
	RARRAY(ary)-&gt;len = i2;
	if (i2 * 2 &lt; RARRAY(ary)-&gt;aux.capa &amp;&amp;
	    RARRAY(ary)-&gt;aux.capa &gt; ARY_DEFAULT_SIZE) {
	    REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, i2 * 2);
	    RARRAY(ary)-&gt;aux.capa = i2 * 2;
	}
    }

    return item;
}

VALUE
rb_ary_delete_at(ary, pos)
    VALUE ary;
    long pos;
{
    long i, len = RARRAY(ary)-&gt;len;
    VALUE del;

    if (pos &gt;= len) return Qnil;
    if (pos &lt; 0) {
	pos += len;
	if (pos &lt; 0) return Qnil;
    }

    rb_ary_modify(ary);
    del = RARRAY(ary)-&gt;ptr[pos];
    for (i = pos + 1; i &lt; len; i++, pos++) {
	RARRAY(ary)-&gt;ptr[pos] = RARRAY(ary)-&gt;ptr[i];
    }
    RARRAY(ary)-&gt;len = pos;

    return del;
}

/*
 *  call-seq:
 *     array.delete_at(index)  -&gt; obj or nil
 *  
 *  Deletes the element at the specified index, returning that element,
 *  or &lt;code&gt;nil&lt;/code&gt; if the index is out of range. See also
 *  &lt;code&gt;Array#slice!&lt;/code&gt;.
 *     
 *     a = %w( ant bat cat dog )
 *     a.delete_at(2)    #=&gt; &quot;cat&quot;
 *     a                 #=&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]
 *     a.delete_at(99)   #=&gt; nil
 */

static VALUE
rb_ary_delete_at_m(ary, pos)
    VALUE ary, pos;
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}

/*
 *  call-seq:
 *     array.slice!(index)         -&gt; obj or nil
 *     array.slice!(start, length) -&gt; sub_array or nil
 *     array.slice!(range)         -&gt; sub_array or nil 
 *  
 *  Deletes the element(s) given by an index (optionally with a length)
 *  or by a range. Returns the deleted object, subarray, or
 *  &lt;code&gt;nil&lt;/code&gt; if the index is out of range. Equivalent to:
 *     
 *     def slice!(*args)
 *       result = self[*args]
 *       self[*args] = nil
 *       result
 *     end
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.slice!(1)     #=&gt; &quot;b&quot;
 *     a               #=&gt; [&quot;a&quot;, &quot;c&quot;]
 *     a.slice!(-1)    #=&gt; &quot;c&quot;
 *     a               #=&gt; [&quot;a&quot;]
 *     a.slice!(100)   #=&gt; nil
 *     a               #=&gt; [&quot;a&quot;]
 */

static VALUE
rb_ary_slice_bang(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE arg1, arg2;
    long pos, len, orig_len;

    rb_ary_modify_check(ary);
    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;arg1, &amp;arg2) == 2) {
	pos = NUM2LONG(arg1);
	len = NUM2LONG(arg2);
      delete_pos_len:
	if (len &lt; 0) return Qnil;
	orig_len = RARRAY_LEN(ary);
	if (pos &lt; 0) {
	    pos += orig_len;
	    if (pos &lt; 0) return Qnil;
	}
	else if (orig_len &lt; pos) return Qnil;
	if (orig_len &lt; pos + len) {
	    len = orig_len - pos;
	}
	if (len == 0) return rb_ary_new2(0);
	arg2 = rb_ary_new4(len, RARRAY_PTR(ary)+pos);
	RBASIC(arg2)-&gt;klass = rb_obj_class(ary);
	rb_ary_splice(ary, pos, len, Qnil);	/* Qundef in 1.9 */
	return arg2;
    }

    if (!FIXNUM_P(arg1)) {
	switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
	  case Qtrue:
	    /* valid range */
	    goto delete_pos_len;
	  case Qnil:
	    /* invalid range */
	    return Qnil;
	  default:
	    /* not a range */
	    break;
	}
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}

/*
 *  call-seq:
 *     array.reject! {|item| block }  -&gt; array or nil
 *  
 *  Equivalent to &lt;code&gt;Array#delete_if&lt;/code&gt;, deleting elements from
 *  _self_ for which the block evaluates to true, but returns
 *  &lt;code&gt;nil&lt;/code&gt; if no changes were made. Also see
 *  &lt;code&gt;Enumerable#reject&lt;/code&gt;.
 */

static VALUE
rb_ary_reject_bang(ary)
    VALUE ary;
{
    long i1, i2;

    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_modify(ary);
    for (i1 = i2 = 0; i1 &lt; RARRAY(ary)-&gt;len; i1++) {
	VALUE v = RARRAY(ary)-&gt;ptr[i1];
	if (RTEST(rb_yield(v))) continue;
	if (i1 != i2) {
	    rb_ary_store(ary, i2, v);
	}
	i2++;
    }
    if (RARRAY(ary)-&gt;len == i2) return Qnil;
    if (i2 &lt; RARRAY(ary)-&gt;len)
	RARRAY(ary)-&gt;len = i2;

    return ary;
}

/*
 *  call-seq:
 *     array.reject {|item| block }  -&gt; an_array
 *  
 *  Returns a new array containing the items in _self_
 *  for which the block is not true.
 */

static VALUE
rb_ary_reject(ary)
    VALUE ary;
{
    RETURN_ENUMERATOR(ary, 0, 0);
    ary = rb_ary_dup(ary);
    rb_ary_reject_bang(ary);
    return ary;
}

/*
 *  call-seq:
 *     array.delete_if {|item| block }  -&gt; array
 *  
 *  Deletes every element of &lt;i&gt;self&lt;/i&gt; for which &lt;i&gt;block&lt;/i&gt; evaluates
 *  to &lt;code&gt;true&lt;/code&gt;.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.delete_if {|x| x &gt;= &quot;b&quot; }   #=&gt; [&quot;a&quot;]
 */

static VALUE
rb_ary_delete_if(ary)
    VALUE ary;
{
    RETURN_ENUMERATOR(ary, 0, 0);
    rb_ary_reject_bang(ary);
    return ary;
}

/*
 *  call-seq:
 *     array.zip(arg, ...)                   -&gt; an_array
 *     array.zip(arg, ...) {| arr | block }  -&gt; nil
 *  
 *  Converts any arguments to arrays, then merges elements of
 *  &lt;i&gt;self&lt;/i&gt; with corresponding elements from each argument. This
 *  generates a sequence of &lt;code&gt;self.size&lt;/code&gt; &lt;em&gt;n&lt;/em&gt;-element
 *  arrays, where &lt;em&gt;n&lt;/em&gt; is one more that the count of arguments. If
 *  the size of any argument is less than &lt;code&gt;enumObj.size&lt;/code&gt;,
 *  &lt;code&gt;nil&lt;/code&gt; values are supplied. If a block given, it is
 *  invoked for each output array, otherwise an array of arrays is
 *  returned.
 *     
 *     a = [ 4, 5, 6 ]
 *     b = [ 7, 8, 9 ]
 *     
 *     [1,2,3].zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
 *     [1,2].zip(a,b)         #=&gt; [[1, 4, 7], [2, 5, 8]]
 *     a.zip([1,2],[8])       #=&gt; [[4,1,8], [5,2,nil], [6,nil,nil]]
 */

static VALUE
rb_ary_zip(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int i, j;
    long len;
    VALUE result;

    for (i=0; i&lt;argc; i++) {
	argv[i] = to_ary(argv[i]);
    }
    if (rb_block_given_p()) {
	for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	    VALUE tmp = rb_ary_new2(argc+1);

	    rb_ary_push(tmp, rb_ary_elt(ary, i));
	    for (j=0; j&lt;argc; j++) {
		rb_ary_push(tmp, rb_ary_elt(argv[j], i));
	    }
	    rb_yield(tmp);
	}
	return Qnil;
    }
    len = RARRAY(ary)-&gt;len;
    result = rb_ary_new2(len);
    for (i=0; i&lt;len; i++) {
	VALUE tmp = rb_ary_new2(argc+1);

	rb_ary_push(tmp, rb_ary_elt(ary, i));
	for (j=0; j&lt;argc; j++) {
	    rb_ary_push(tmp, rb_ary_elt(argv[j], i));
	}
	rb_ary_push(result, tmp);
    }
    return result;
}

/*
 *  call-seq:
 *     array.transpose -&gt; an_array
 *  
 *  Assumes that &lt;i&gt;self&lt;/i&gt; is an array of arrays and transposes the
 *  rows and columns.
 *     
 *     a = [[1,2], [3,4], [5,6]]
 *     a.transpose   #=&gt; [[1, 3, 5], [2, 4, 6]]
 */

static VALUE
rb_ary_transpose(ary)
    VALUE ary;
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY(ary)-&gt;len;
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
	tmp = to_ary(rb_ary_elt(ary, i));
	if (elen &lt; 0) {		/* first element */
	    elen = RARRAY(tmp)-&gt;len;
	    result = rb_ary_new2(elen);
	    for (j=0; j&lt;elen; j++) {
		rb_ary_store(result, j, rb_ary_new2(alen));
	    }
	}
	else if (elen != RARRAY(tmp)-&gt;len) {
	    rb_raise(rb_eIndexError, &quot;element size differs (%d should be %d)&quot;,
		     RARRAY(tmp)-&gt;len, elen);
	}
	for (j=0; j&lt;elen; j++) {
	    rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
	}
    }
    return result;
}

/*
 *  call-seq:
 *     array.replace(other_array)  -&gt; array
 *  
 *  Replaces the contents of &lt;i&gt;self&lt;/i&gt; with the contents of
 *  &lt;i&gt;other_array&lt;/i&gt;, truncating or expanding if necessary.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 *     a                              #=&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]
 */

static VALUE
rb_ary_replace(copy, orig)
    VALUE copy, orig;
{
    VALUE shared;

    rb_ary_modify(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;
    shared = ary_make_shared(orig);
    if (RARRAY(copy)-&gt;ptr &amp;&amp; !FL_TEST(copy, ELTS_SHARED))
	free(RARRAY(copy)-&gt;ptr);
    RARRAY(copy)-&gt;ptr = RARRAY(orig)-&gt;ptr;
    RARRAY(copy)-&gt;len = RARRAY(orig)-&gt;len;
    RARRAY(copy)-&gt;aux.shared = shared;
    FL_SET(copy, ELTS_SHARED);

    return copy;
}

/* 
 *  call-seq:
 *     array.clear    -&gt;  array
 *
 *  Removes all elements from _self_.
 *
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]
 *     a.clear    #=&gt; [ ]
 */

VALUE
rb_ary_clear(ary)
    VALUE ary;
{
    rb_ary_modify(ary);
    RARRAY(ary)-&gt;len = 0;
    if (ARY_DEFAULT_SIZE * 2 &lt; RARRAY(ary)-&gt;aux.capa) {
	REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, ARY_DEFAULT_SIZE * 2);
	RARRAY(ary)-&gt;aux.capa = ARY_DEFAULT_SIZE * 2;
    }
    return ary;
}

/*
 *  call-seq:
 *     array.fill(obj)                                -&gt; array
 *     array.fill(obj, start [, length])              -&gt; array
 *     array.fill(obj, range )                        -&gt; array
 *     array.fill {|index| block }                    -&gt; array
 *     array.fill(start [, length] ) {|index| block } -&gt; array
 *     array.fill(range) {|index| block }             -&gt; array
 *  
 *  The first three forms set the selected elements of &lt;i&gt;self&lt;/i&gt; (which
 *  may be the entire array) to &lt;i&gt;obj&lt;/i&gt;. A &lt;i&gt;start&lt;/i&gt; of
 *  &lt;code&gt;nil&lt;/code&gt; is equivalent to zero. A &lt;i&gt;length&lt;/i&gt; of
 *  &lt;code&gt;nil&lt;/code&gt; is equivalent to &lt;i&gt;self.length&lt;/i&gt;. The last three
 *  forms fill the array with the value of the block. The block is
 *  passed the absolute index of each element to be filled.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 *     a.fill(&quot;x&quot;)              #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]
 *     a.fill(&quot;z&quot;, 2, 2)        #=&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]
 *     a.fill(&quot;y&quot;, 0..1)        #=&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]
 *     a.fill {|i| i*i}         #=&gt; [0, 1, 4, 9]
 *     a.fill(-2) {|i| i*i*i}   #=&gt; [0, 1, 8, 27]
 */

static VALUE
rb_ary_fill(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE item, arg1, arg2;
    long beg = 0, end = 0, len = 0;
    VALUE *p, *pend;
    int block_p = Qfalse;

    if (rb_block_given_p()) {
	block_p = Qtrue;
	rb_scan_args(argc, argv, &quot;02&quot;, &amp;arg1, &amp;arg2);
	argc += 1;		/* hackish */
    }
    else {
	rb_scan_args(argc, argv, &quot;12&quot;, &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
	beg = 0;
	len = RARRAY(ary)-&gt;len;
	break;
      case 2:
	if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY(ary)-&gt;len, 1)) {
	    break;
	}
	/* fall through */
      case 3:
	beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
	if (beg &lt; 0) {
	    beg = RARRAY(ary)-&gt;len + beg;
	    if (beg &lt; 0) beg = 0;
	}
	len = NIL_P(arg2) ? RARRAY(ary)-&gt;len - beg : NUM2LONG(arg2);
	break;
    }
    rb_ary_modify(ary);
    end = beg + len;
    if (end &lt; 0) {
	rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    if (end &gt; RARRAY(ary)-&gt;len) {
	if (end &gt;= RARRAY(ary)-&gt;aux.capa) {
	    REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, end);
	    RARRAY(ary)-&gt;aux.capa = end;
	}
	rb_mem_clear(RARRAY(ary)-&gt;ptr + RARRAY(ary)-&gt;len, end - RARRAY(ary)-&gt;len);
	RARRAY(ary)-&gt;len = end;
    }

    if (block_p) {
	VALUE v;
	long i;

	for (i=beg; i&lt;end; i++) {
	    v = rb_yield(LONG2NUM(i));
	    if (i&gt;=RARRAY(ary)-&gt;len) break;
	    RARRAY(ary)-&gt;ptr[i] = v;
	}
    }
    else {
	p = RARRAY(ary)-&gt;ptr + beg;
	pend = p + len;
	while (p &lt; pend) {
	    *p++ = item;
	}
    }
    return ary;
}

/* 
 *  call-seq:
 *     array + other_array   -&gt; an_array
 *
 *  Concatenation---Returns a new array built by concatenating the
 *  two arrays together to produce a third array.
 * 
 *     [ 1, 2, 3 ] + [ 4, 5 ]    #=&gt; [ 1, 2, 3, 4, 5 ]
 */

VALUE
rb_ary_plus(x, y)
    VALUE x, y;
{
    VALUE z;
    long len;

    y = to_ary(y);
    len = RARRAY(x)-&gt;len + RARRAY(y)-&gt;len;
    z = rb_ary_new2(len);
    MEMCPY(RARRAY(z)-&gt;ptr, RARRAY(x)-&gt;ptr, VALUE, RARRAY(x)-&gt;len);
    MEMCPY(RARRAY(z)-&gt;ptr + RARRAY(x)-&gt;len, RARRAY(y)-&gt;ptr, VALUE, RARRAY(y)-&gt;len);
    RARRAY(z)-&gt;len = len;
    return z;
}

/* 
 *  call-seq:
 *     array.concat(other_array)   -&gt;  array
 *
 *  Appends the elements in other_array to _self_.
 *  
 *     [ &quot;a&quot;, &quot;b&quot; ].concat( [&quot;c&quot;, &quot;d&quot;] ) #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 */


VALUE
rb_ary_concat(x, y)
    VALUE x, y;
{
    y = to_ary(y);
    if (RARRAY(y)-&gt;len &gt; 0) {
	rb_ary_splice(x, RARRAY(x)-&gt;len, 0, y);
    }
    return x;
}


/* 
 *  call-seq:
 *     array * int     -&gt;    an_array
 *     array * str     -&gt;    a_string
 *
 *  Repetition---With a String argument, equivalent to
 *  self.join(str). Otherwise, returns a new array
 *  built by concatenating the _int_ copies of _self_.
 *
 *
 *     [ 1, 2, 3 ] * 3    #=&gt; [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
 *     [ 1, 2, 3 ] * &quot;,&quot;  #=&gt; &quot;1,2,3&quot;
 *
 */

static VALUE
rb_ary_times(ary, times)
    VALUE ary, times;
{
    VALUE ary2, tmp;
    long i, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
	return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) return ary_new(rb_obj_class(ary), 0);
    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY(ary)-&gt;len) {
	rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }
    len *= RARRAY(ary)-&gt;len;

    ary2 = ary_new(rb_obj_class(ary), len);
    RARRAY(ary2)-&gt;len = len;

    for (i=0; i&lt;len; i+=RARRAY(ary)-&gt;len) {
	MEMCPY(RARRAY(ary2)-&gt;ptr+i, RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;len);
    }
    OBJ_INFECT(ary2, ary);

    return ary2;
}

/* 
 *  call-seq:
 *     array.assoc(obj)   -&gt;  an_array  or  nil
 *
 *  Searches through an array whose elements are also arrays
 *  comparing _obj_ with the first element of each contained array
 *  using obj.==.
 *  Returns the first contained array that matches (that
 *  is, the first associated array),
 *  or +nil+ if no match is found.
 *  See also &lt;code&gt;Array#rassoc&lt;/code&gt;.
 *
 *     s1 = [ &quot;colors&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ]
 *     s2 = [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     s3 = &quot;foo&quot;
 *     a  = [ s1, s2, s3 ]
 *     a.assoc(&quot;letters&quot;)  #=&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.assoc(&quot;foo&quot;)      #=&gt; nil
 */

VALUE
rb_ary_assoc(ary, key)
    VALUE ary, key;
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY(ary)-&gt;len; ++i) {
	v = rb_check_array_type(RARRAY(ary)-&gt;ptr[i]);
	if (!NIL_P(v) &amp;&amp; RARRAY(v)-&gt;len &gt; 0 &amp;&amp;
	    rb_equal(RARRAY(v)-&gt;ptr[0], key))
	    return v;
    }
    return Qnil;
}

/*
 *  call-seq:
 *     array.rassoc(key) -&gt; an_array or nil
 *  
 *  Searches through the array whose elements are also arrays. Compares
 *  &lt;em&gt;key&lt;/em&gt; with the second element of each contained array using
 *  &lt;code&gt;==&lt;/code&gt;. Returns the first contained array that matches. See
 *  also &lt;code&gt;Array#assoc&lt;/code&gt;.
 *     
 *     a = [ [ 1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [&quot;ii&quot;, &quot;two&quot;] ]
 *     a.rassoc(&quot;two&quot;)    #=&gt; [2, &quot;two&quot;]
 *     a.rassoc(&quot;four&quot;)   #=&gt; nil
 */

VALUE
rb_ary_rassoc(ary, value)
    VALUE ary, value;
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY(ary)-&gt;len; ++i) {
	v = RARRAY(ary)-&gt;ptr[i];
	if (TYPE(v) == T_ARRAY &amp;&amp;
	    RARRAY(v)-&gt;len &gt; 1 &amp;&amp;
	    rb_equal(RARRAY(v)-&gt;ptr[1], value))
	    return v;
    }
    return Qnil;
}

static VALUE recursive_equal _((VALUE, VALUE, int));
static VALUE
recursive_equal(ary1, ary2, recur)
    VALUE ary1, ary2;
    int recur;
{
    long i;

    if (recur) return Qfalse;
    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
	if (!rb_equal(rb_ary_elt(ary1, i), rb_ary_elt(ary2, i)))
	    return Qfalse;
    }
    return Qtrue;
}

/* 
 *  call-seq:
 *     array == other_array   -&gt;   bool
 *
 *  Equality---Two arrays are equal if they contain the same number
 *  of elements and if each element is equal to (according to
 *  Object.==) the corresponding element in the other array.
 *
 *     [ &quot;a&quot;, &quot;c&quot; ]    == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; false
 *     [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;c&quot;, 7 ]     #=&gt; true
 *     [ &quot;a&quot;, &quot;c&quot;, 7 ] == [ &quot;a&quot;, &quot;d&quot;, &quot;f&quot; ]   #=&gt; false
 *
 */

static VALUE
rb_ary_equal(ary1, ary2)
    VALUE ary1, ary2;
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) {
	if (!rb_respond_to(ary2, rb_intern(&quot;to_ary&quot;))) {
	    return Qfalse;
	}
	return rb_equal(ary2, ary1);
    }
    if (RARRAY(ary1)-&gt;len != RARRAY(ary2)-&gt;len) return Qfalse;
    return rb_exec_recursive(recursive_equal, ary1, ary2);
}

static VALUE recursive_eql _((VALUE, VALUE, int));
static VALUE
recursive_eql(ary1, ary2, recur)
    VALUE ary1, ary2;
    int recur;
{
    long i;

    if (recur) return Qfalse;
    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
	if (!rb_eql(rb_ary_elt(ary1, i), rb_ary_elt(ary2, i)))
	    return Qfalse;
    }
    return Qtrue;
}

/*
 *  call-seq:
 *     array.eql?(other)  -&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if _array_ and _other_ are the same object,
 *  or are both arrays with the same content.
 */

static VALUE
rb_ary_eql(ary1, ary2)
    VALUE ary1, ary2;
{
    if (ary1 == ary2) return Qtrue;
    if (TYPE(ary2) != T_ARRAY) return Qfalse;
    if (RARRAY(ary1)-&gt;len != RARRAY(ary2)-&gt;len) return Qfalse;
    return rb_exec_recursive(recursive_eql, ary1, ary2);
}

static VALUE recursive_hash _((VALUE, VALUE, int));
static VALUE
recursive_hash(ary, dummy, recur)
    VALUE ary;
    VALUE dummy;
    int recur;
{
    long i, h;
    VALUE n;

    if (recur) {
	return LONG2FIX(0);
    }

    h = RARRAY(ary)-&gt;len;
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	h = (h &lt;&lt; 1) | (h&lt;0 ? 1 : 0);
	n = rb_hash(RARRAY(ary)-&gt;ptr[i]);
	h ^= NUM2LONG(n);
    }
    return LONG2FIX(h);
}

/*
 *  call-seq:
 *     array.hash   -&gt; fixnum
 *
 *  Compute a hash-code for this array. Two arrays with the same content
 *  will have the same hash code (and will compare using &lt;code&gt;eql?&lt;/code&gt;).
 */

static VALUE
rb_ary_hash(ary)
    VALUE ary;
{
    return rb_exec_recursive(recursive_hash, ary, 0);
}

/*
 *  call-seq:
 *     array.include?(obj)   -&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if the given object is present in
 *  &lt;i&gt;self&lt;/i&gt; (that is, if any object &lt;code&gt;==&lt;/code&gt; &lt;i&gt;anObject&lt;/i&gt;),
 *  &lt;code&gt;false&lt;/code&gt; otherwise.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.include?(&quot;b&quot;)   #=&gt; true
 *     a.include?(&quot;z&quot;)   #=&gt; false
 */

VALUE
rb_ary_includes(ary, item)
    VALUE ary;
    VALUE item;
{
    long i;
    
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	if (rb_equal(RARRAY(ary)-&gt;ptr[i], item)) {
	    return Qtrue;
	}
    }
    return Qfalse;
}


static VALUE recursive_cmp _((VALUE, VALUE, int));
static VALUE
recursive_cmp(ary1, ary2, recur)
    VALUE ary1;
    VALUE ary2;
    int recur;
{
    long i, len;

    if (recur) return Qnil;
    len = RARRAY(ary1)-&gt;len;
    if (len &gt; RARRAY(ary2)-&gt;len) {
	len = RARRAY(ary2)-&gt;len;
    }
    for (i=0; i&lt;len; i++) {
	VALUE v = rb_funcall(rb_ary_elt(ary1, i), id_cmp, 1, rb_ary_elt(ary2, i));
	if (v != INT2FIX(0)) {
	    return v;
	}
    }
    return Qundef;
}

/* 
 *  call-seq:
 *     array &lt;=&gt; other_array   -&gt;  -1, 0, +1
 *
 *  Comparison---Returns an integer (-1, 0,
 *  or +1) if this array is less than, equal to, or greater than
 *  other_array.  Each object in each array is compared
 *  (using &lt;=&gt;). If any value isn't
 *  equal, then that inequality is the return value. If all the
 *  values found are equal, then the return is based on a
 *  comparison of the array lengths.  Thus, two arrays are
 *  ``equal'' according to &lt;code&gt;Array#&lt;=&gt;&lt;/code&gt; if and only if they have
 *  the same length and the value of each element is equal to the
 *  value of the corresponding element in the other array.
 *  
 *     [ &quot;a&quot;, &quot;a&quot;, &quot;c&quot; ]    &lt;=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]   #=&gt; -1
 *     [ 1, 2, 3, 4, 5, 6 ] &lt;=&gt; [ 1, 2 ]            #=&gt; +1
 *
 */

VALUE
rb_ary_cmp(ary1, ary2)
    VALUE ary1, ary2;
{
    long len;
    VALUE v;

    ary2 = to_ary(ary2);
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive(recursive_cmp, ary1, ary2);
    if (v != Qundef) return v;
    len = RARRAY(ary1)-&gt;len - RARRAY(ary2)-&gt;len;
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}

static VALUE
ary_make_hash(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash = rb_hash_new();
    long i;

    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
	rb_hash_aset(hash, RARRAY(ary1)-&gt;ptr[i], Qtrue);
    }
    if (ary2) {
	for (i=0; i&lt;RARRAY(ary2)-&gt;len; i++) {
	    rb_hash_aset(hash, RARRAY(ary2)-&gt;ptr[i], Qtrue);
	}
    }
    return hash;
}

/* 
 *  call-seq:
 *     array - other_array    -&gt; an_array
 *
 *  Array Difference---Returns a new array that is a copy of
 *  the original array, removing any items that also appear in
 *  other_array. (If you need set-like behavior, see the
 *  library class Set.)
 *
 *     [ 1, 1, 2, 2, 3, 3, 4, 5 ] - [ 1, 2, 4 ]  #=&gt;  [ 3, 3, 5 ]
 */

static VALUE
rb_ary_diff(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE ary3;
    volatile VALUE hash;
    long i;

    hash = ary_make_hash(to_ary(ary2), 0);
    ary3 = rb_ary_new();

    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
	if (st_lookup(RHASH(hash)-&gt;tbl, RARRAY(ary1)-&gt;ptr[i], 0)) continue;
	rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }
    return ary3;
}

/* 
 *  call-seq:
 *     array &amp; other_array
 *
 *  Set Intersection---Returns a new array
 *  containing elements common to the two arrays, with no duplicates.
 *
 *     [ 1, 1, 3, 5 ] &amp; [ 1, 2, 3 ]   #=&gt; [ 1, 3 ]
 */


static VALUE
rb_ary_and(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash, ary3, v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY(ary1)-&gt;len &lt; RARRAY(ary2)-&gt;len ?
	    RARRAY(ary1)-&gt;len : RARRAY(ary2)-&gt;len);
    hash = ary_make_hash(ary2, 0);

    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
	v = vv = rb_ary_elt(ary1, i);
	if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
	    rb_ary_push(ary3, v);
	}
    }

    return ary3;
}

/* 
 *  call-seq:
 *     array | other_array     -&gt;  an_array
 *
 *  Set Union---Returns a new array by joining this array with
 *  other_array, removing duplicates.
 *
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] | [ &quot;c&quot;, &quot;d&quot;, &quot;a&quot; ]
 *            #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]
 */

static VALUE
rb_ary_or(ary1, ary2)
    VALUE ary1, ary2;
{
    VALUE hash, ary3;
    VALUE v, vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new2(RARRAY(ary1)-&gt;len+RARRAY(ary2)-&gt;len);
    hash = ary_make_hash(ary1, ary2);

    for (i=0; i&lt;RARRAY(ary1)-&gt;len; i++) {
	v = vv = rb_ary_elt(ary1, i);
	if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
	    rb_ary_push(ary3, v);
	}
    }
    for (i=0; i&lt;RARRAY(ary2)-&gt;len; i++) {
	v = vv = rb_ary_elt(ary2, i);
	if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
	    rb_ary_push(ary3, v);
	}
    }
    return ary3;
}

/*
 *  call-seq:
 *     array.uniq! -&gt; array or nil
 *  
 *  Removes duplicate elements from _self_.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no changes are made (that is, no
 *  duplicates are found).
 *     
 *     a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.uniq!   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     b = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     b.uniq!   #=&gt; nil
 */

static VALUE
rb_ary_uniq_bang(ary)
    VALUE ary;
{
    VALUE hash, v, vv;
    long i, j;

    hash = ary_make_hash(ary, 0);

    if (RARRAY(ary)-&gt;len == RHASH(hash)-&gt;tbl-&gt;num_entries) {
	return Qnil;
    }
    for (i=j=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	v = vv = rb_ary_elt(ary, i);
	if (st_delete(RHASH(hash)-&gt;tbl, (st_data_t*)&amp;vv, 0)) {
	    rb_ary_store(ary, j++, v);
	}
    }
    RARRAY(ary)-&gt;len = j;

    return ary;
}

/*
 *  call-seq:
 *     array.uniq   -&gt; an_array
 *  
 *  Returns a new array by removing duplicate values in &lt;i&gt;self&lt;/i&gt;.
 *     
 *     a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.uniq   #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 */

static VALUE
rb_ary_uniq(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_uniq_bang(ary);
    return ary;
}

/* 
 *  call-seq:
 *     array.compact!    -&gt;   array  or  nil
 *
 *  Removes +nil+ elements from array.
 *  Returns +nil+ if no changes were made.
 *
 *     [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot; ].compact! #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].compact!           #=&gt; nil
 */

static VALUE
rb_ary_compact_bang(ary)
    VALUE ary;
{
    VALUE *p, *t, *end;

    rb_ary_modify(ary);
    p = t = RARRAY(ary)-&gt;ptr;
    end = p + RARRAY(ary)-&gt;len;
    
    while (t &lt; end) {
	if (NIL_P(*t)) t++;
	else *p++ = *t++;
    }
    if (RARRAY(ary)-&gt;len == (p - RARRAY(ary)-&gt;ptr)) {
	return Qnil;
    }
    RARRAY(ary)-&gt;len = RARRAY(ary)-&gt;aux.capa = (p - RARRAY(ary)-&gt;ptr);
    REALLOC_N(RARRAY(ary)-&gt;ptr, VALUE, RARRAY(ary)-&gt;len);

    return ary;
}

/*
 *  call-seq:
 *     array.compact     -&gt;  an_array
 *
 *  Returns a copy of _self_ with all +nil+ elements removed.
 *
 *     [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot;, nil ].compact
 *                       #=&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 */

static VALUE
rb_ary_compact(ary)
    VALUE ary;
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}

/*
 *  call-seq:
 *     array.nitems -&gt; int
 *  
 *  Returns the number of non-&lt;code&gt;nil&lt;/code&gt; elements in _self_.
 *
 *  May be zero.
 *     
 *     [ 1, nil, 3, nil, 5 ].nitems   #=&gt; 3
 */

static VALUE
rb_ary_nitems(ary)
    VALUE ary;
{
    long n = 0;
    VALUE *p, *pend;

    for (p = RARRAY(ary)-&gt;ptr, pend = p + RARRAY(ary)-&gt;len; p &lt; pend; p++) {
	if (!NIL_P(*p)) n++;
    }
    return LONG2NUM(n);
}

/*
 *  call-seq:
 *     array.count      -&gt; int
 *     array.count(obj) -&gt; int
 *     array.count { |item| block }  -&gt; int
 *  
 *  Returns the number of elements.  If an argument is given, counts
 *  the number of elements which equals to &lt;i&gt;obj&lt;/i&gt;.  If a block is
 *  given, counts the number of elements yielding a true value.
 *
 *     ary = [1, 2, 4, 2]
 *     ary.count             # =&gt; 4
 *     ary.count(2)          # =&gt; 2
 *     ary.count{|x|x%2==0}  # =&gt; 3
 *
 */

static VALUE
rb_ary_count(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long n = 0;

    if (argc == 0) {
	VALUE *p, *pend;

	if (!rb_block_given_p())
	    return LONG2NUM(RARRAY_LEN(ary));

	for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
	    if (RTEST(rb_yield(*p))) n++;
	}
    }
    else {
	VALUE obj, *p, *pend;

	rb_scan_args(argc, argv, &quot;1&quot;, &amp;obj);
	if (rb_block_given_p()) {
	    rb_warn(&quot;given block not used&quot;);
	}
	for (p = RARRAY_PTR(ary), pend = p + RARRAY_LEN(ary); p &lt; pend; p++) {
	    if (rb_equal(*p, obj)) n++;
	}
    }

    return LONG2NUM(n);
}

static VALUE
flatten(ary, level, modified)
    VALUE ary;
    int level;
    int *modified;
{
    long i = 0;
    VALUE stack, result, tmp, elt;
    st_table *memo;
    st_data_t id;

    stack = ary_new(0, ARY_DEFAULT_SIZE);
    result = ary_new(0, RARRAY_LEN(ary));
    memo = st_init_numtable();
    st_insert(memo, (st_data_t)ary, (st_data_t)Qtrue);
    *modified = 0;

    while (1) {
	while (i &lt; RARRAY(ary)-&gt;len) {
	    elt = RARRAY(ary)-&gt;ptr[i++];
	    tmp = rb_check_array_type(elt);
	    if (RBASIC(result)-&gt;klass) {
		rb_raise(rb_eRuntimeError, &quot;flatten reentered&quot;);
	    }
	    if (NIL_P(tmp) || (level &gt;= 0 &amp;&amp; RARRAY(stack)-&gt;len / 2 &gt;= level)) {
		rb_ary_push(result, elt);
	    }
	    else {
		*modified = 1;
		id = (st_data_t)tmp;
		if (st_lookup(memo, id, 0)) {
		    st_free_table(memo);
		    rb_raise(rb_eArgError, &quot;tried to flatten recursive array&quot;);
		}
		st_insert(memo, id, (st_data_t)Qtrue);
		rb_ary_push(stack, ary);
		rb_ary_push(stack, LONG2NUM(i));
		ary = tmp;
		i = 0;
	    }
	}
	if (RARRAY(stack)-&gt;len == 0) {
	    break;
	}
	id = (st_data_t)ary;
	st_delete(memo, &amp;id, 0);
	tmp = rb_ary_pop(stack);
	i = NUM2LONG(tmp);
	ary = rb_ary_pop(stack);
    }

    st_free_table(memo);

    RBASIC(result)-&gt;klass = rb_class_of(ary);
    return result;
}

/*
 *  call-seq:
 *     array.flatten! -&gt; array or nil
 *     array.flatten!(level) -&gt; array or nil
 *  
 *  Flattens _self_ in place.
 *  Returns &lt;code&gt;nil&lt;/code&gt; if no modifications were made (i.e.,
 *  &lt;i&gt;array&lt;/i&gt; contains no subarrays.)  If the optional &lt;i&gt;level&lt;/i&gt;
 *  argument determines the level of recursion to flatten.
 *     
 *     a = [ 1, 2, [3, [4, 5] ] ]
 *     a.flatten!   #=&gt; [1, 2, 3, 4, 5]
 *     a.flatten!   #=&gt; nil
 *     a            #=&gt; [1, 2, 3, 4, 5]
 *     a = [ 1, 2, [3, [4, 5] ] ]
 *     a.flatten!(1) #=&gt; [1, 2, 3, [4, 5]]
 */

static VALUE
rb_ary_flatten_bang(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return ary;

    result = flatten(ary, level, &amp;mod);
    if (mod == 0) return Qnil;
    rb_ary_replace(ary, result);

    return ary;
}

/*
 *  call-seq:
 *     array.flatten -&gt; an_array
 *     array.flatten(level) -&gt; an_array
 *  
 *  Returns a new array that is a one-dimensional flattening of this
 *  array (recursively). That is, for every element that is an array,
 *  extract its elements into the new array.  If the optional
 *  &lt;i&gt;level&lt;/i&gt; argument determines the level of recursion to flatten.
 *     
 *     s = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
 *     t = [ 4, 5, 6, [7, 8] ]   #=&gt; [4, 5, 6, [7, 8]]
 *     a = [ s, t, 9, 10 ]       #=&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]
 *     a.flatten                 #=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 *     a = [ 1, 2, [3, [4, 5] ] ]
 *     a.flatten(1)              #=&gt; [1, 2, 3, [4, 5]]
 */

static VALUE
rb_ary_flatten(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int mod = 0, level = -1;
    VALUE result, lv;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;lv);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return ary;

    result = flatten(ary, level, &amp;mod);
    if (OBJ_TAINTED(ary)) OBJ_TAINT(result);

    return result;
}

/*
 *  call-seq:
 *     array.shuffle!        -&gt; array or nil
 *  
 *  Shuffles elements in _self_ in place.
 */


static VALUE
rb_ary_shuffle_bang(ary)
    VALUE ary;
{
    long i = RARRAY(ary)-&gt;len;

    rb_ary_modify(ary);
    while (i) {
	long j = rb_genrand_real()*i;
	VALUE tmp = RARRAY(ary)-&gt;ptr[--i];
	RARRAY(ary)-&gt;ptr[i] = RARRAY(ary)-&gt;ptr[j];
	RARRAY(ary)-&gt;ptr[j] = tmp;
    }
    return ary;
}


/*
 *  call-seq:
 *     array.shuffle -&gt; an_array
 *  
 *  Returns a new array with elements of this array shuffled.
 *     
 *     a = [ 1, 2, 3 ]           #=&gt; [1, 2, 3]
 *     a.shuffle                 #=&gt; [2, 3, 1]
 */

static VALUE
rb_ary_shuffle(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_shuffle_bang(ary);
    return ary;
}


/*
 *  call-seq:
 *     array.choice        -&gt; obj
 *  
 *  Choose a random element from an array.
 */


static VALUE
rb_ary_choice(ary)
    VALUE ary;
{
    long i, j;

    i = RARRAY(ary)-&gt;len;
    if (i == 0) return Qnil;
    j = rb_genrand_real()*i;
    return RARRAY(ary)-&gt;ptr[j];
}


/*
 *  call-seq:
 *     ary.cycle {|obj| block }
 *     ary.cycle(n) {|obj| block }
 *  
 *  Calls &lt;i&gt;block&lt;/i&gt; for each element repeatedly _n_ times or
 *  forever if none or nil is given.  If a non-positive number is
 *  given or the array is empty, does nothing.  Returns nil if the
 *  loop has finished without getting interrupted.
 *     
 *     a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
 *     a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.
 *     
 */

static VALUE
rb_ary_cycle(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    long n, i;
    VALUE nv = Qnil;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(ary, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY(ary)-&gt;len &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
            rb_yield(RARRAY(ary)-&gt;ptr[i]);
        }
    }
    return Qnil;
}

#define tmpbuf(n, size) rb_str_tmp_new((n)*(size))

/*
 * Recursively compute permutations of r elements of the set [0..n-1].
 * When we have a complete permutation of array indexes, copy the values
 * at those indexes into a new array and yield that array. 
 *
 * n: the size of the set 
 * r: the number of elements in each permutation
 * p: the array (of size r) that we're filling in
 * index: what index we're filling in now
 * used: an array of booleans: whether a given index is already used
 * values: the Ruby array that holds the actual values to permute
 */
static void
permute0(n, r, p, index, used, values)
    long n, r, *p, index;
    int *used;
    VALUE values;
{
    long i,j;
    for (i = 0; i &lt; n; i++) {
	if (used[i] == 0) {
	    p[index] = i;
	    if (index &lt; r-1) {             /* if not done yet */
		used[i] = 1;               /* mark index used */
		permute0(n, r, p, index+1, /* recurse */
			 used, values);  
		used[i] = 0;               /* index unused */
	    }
	    else {
		/* We have a complete permutation of array indexes */
		/* Build a ruby array of the corresponding values */
		/* And yield it to the associated block */
		VALUE result = rb_ary_new2(r);
		VALUE *result_array = RARRAY(result)-&gt;ptr;
		const VALUE *values_array = RARRAY(values)-&gt;ptr;

		for (j = 0; j &lt; r; j++) result_array[j] = values_array[p[j]];
		RARRAY(result)-&gt;len = r;
		rb_yield(result);
	    }
	}
    }
}

/*
 *  call-seq:
 *     ary.permutation { |p| block }          -&gt; array
 *     ary.permutation                        -&gt; enumerator
 *     ary.permutation(n) { |p| block }       -&gt; array
 *     ary.permutation(n)                     -&gt; enumerator
 *  
 * When invoked with a block, yield all permutations of length &lt;i&gt;n&lt;/i&gt;
 * of the elements of &lt;i&gt;ary&lt;/i&gt;, then return the array itself.
 * If &lt;i&gt;n&lt;/i&gt; is not specified, yield all permutations of all elements.
 * The implementation makes no guarantees about the order in which 
 * the permutations are yielded.
 *
 * When invoked without a block, return an enumerator object instead.
 * 
 * Examples:
 *
 *     a = [1, 2, 3]
 *     a.permutation.to_a     #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 *     a.permutation(1).to_a  #=&gt; [[1],[2],[3]]
 *     a.permutation(2).to_a  #=&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
 *     a.permutation(3).to_a  #=&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 *     a.permutation(0).to_a  #=&gt; [[]] # one permutation of length 0
 *     a.permutation(4).to_a  #=&gt; []   # no permutations of length 4
 */

static VALUE
rb_ary_permutation(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    VALUE num;
    long r, n, i;

    n = RARRAY(ary)-&gt;len;                  /* Array length */
    RETURN_ENUMERATOR(ary, argc, argv);   /* Return enumerator if no block */
    rb_scan_args(argc, argv, &quot;01&quot;, &amp;num);
    r = NIL_P(num) ? n : NUM2LONG(num);   /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) { 
	/* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
	rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
	for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
	    rb_yield(rb_ary_new3(1, RARRAY(ary)-&gt;ptr[i]));
	}
    }
    else {             /* this is the general case */
	volatile VALUE t0 = tmpbuf(n,sizeof(long));
	long *p = (long*)RSTRING(t0)-&gt;ptr;
	volatile VALUE t1 = tmpbuf(n,sizeof(int));
	int *used = (int*)RSTRING(t1)-&gt;ptr;
	VALUE ary0 = ary_make_shared(ary); /* private defensive copy of ary */

	for (i = 0; i &lt; n; i++) used[i] = 0; /* initialize array */

	permute0(n, r, p, 0, used, ary0); /* compute and yield permutations */
	RB_GC_GUARD(t0);
	RB_GC_GUARD(t1);
    }
    return ary;
}

static long
combi_len(n, k)
    long n, k;
{
    long i, val = 1;

    if (k*2 &gt; n) k = n-k;
    if (k == 0) return 1;
    if (k &lt; 0) return 0;
    val = 1;
    for (i=1; i &lt;= k; i++,n--) {
	long m = val;
	val *= n;
	if (val &lt; m) {
	    rb_raise(rb_eRangeError, &quot;too big for combination&quot;);
	}
	val /= i;
    }
    return val;
}

/*
 *  call-seq:
 *     ary.combination(n) { |c| block }    -&gt; ary
 *     ary.combination(n)                  -&gt; enumerator
 *  
 * When invoked with a block, yields all combinations of length &lt;i&gt;n&lt;/i&gt; 
 * of elements from &lt;i&gt;ary&lt;/i&gt; and then returns &lt;i&gt;ary&lt;/i&gt; itself.
 * The implementation makes no guarantees about the order in which 
 * the combinations are yielded.
 *
 * When invoked without a block, returns an enumerator object instead.
 *     
 * Examples:
 *
 *     a = [1, 2, 3, 4]
 *     a.combination(1).to_a  #=&gt; [[1],[2],[3],[4]]
 *     a.combination(2).to_a  #=&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
 *     a.combination(3).to_a  #=&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]
 *     a.combination(4).to_a  #=&gt; [[1,2,3,4]]
 *     a.combination(0).to_a  #=&gt; [[]] # one combination of length 0
 *     a.combination(5).to_a  #=&gt; []   # no combinations of length 5
 *     
 */

static VALUE
rb_ary_combination(ary, num)
    VALUE ary;
    VALUE num;
{
    long n, i, len;

    n = NUM2LONG(num);
    RETURN_ENUMERATOR(ary, 1, &amp;num);
    len = RARRAY(ary)-&gt;len;
    if (n &lt; 0 || len &lt; n) {
	/* yield nothing */
    }
    else if (n == 0) {
	rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
	for (i = 0; i &lt; len; i++) {
	    rb_yield(rb_ary_new3(1, RARRAY(ary)-&gt;ptr[i]));
	}
    }
    else {
	volatile VALUE t0 = tmpbuf(n+1, sizeof(long));
	long *stack = (long*)RSTRING(t0)-&gt;ptr;
	long nlen = combi_len(len, n);
	volatile VALUE cc = rb_ary_new2(n);
	VALUE *chosen = RARRAY(cc)-&gt;ptr;
	long lev = 0;

	RBASIC(cc)-&gt;klass = 0;
	MEMZERO(stack, long, n);
	stack[0] = -1;
	for (i = 0; i &lt; nlen; i++) {
	    chosen[lev] = RARRAY(ary)-&gt;ptr[stack[lev+1]];
	    for (lev++; lev &lt; n; lev++) {
		chosen[lev] = RARRAY(ary)-&gt;ptr[stack[lev+1] = stack[lev]+1];
	    }
	    rb_yield(rb_ary_new4(n, chosen));
	    do {
		stack[lev--]++;
	    } while (lev &amp;&amp; (stack[lev+1]+n == len+lev+1));
	}
    }
    return ary;
}

/*
 *  call-seq:
 *     ary.product(other_ary, ...)
 *  
 *  Returns an array of all combinations of elements from all arrays.
 *  The length of the returned array is the product of the length
 *  of ary and the argument arrays
 *     
 *     [1,2,3].product([4,5])     # =&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
 *     [1,2].product([1,2])       # =&gt; [[1,1],[1,2],[2,1],[2,2]]
 *     [1,2].product([3,4],[5,6]) # =&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],
 *                                #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]
 *     [1,2].product()            # =&gt; [[1],[2]]
 *     [1,2].product([])          # =&gt; []
 */

static VALUE
rb_ary_product(argc, argv, ary)
    int argc;
    VALUE *argv;
    VALUE ary;
{
    int n = argc+1;    /* How many arrays we're operating on */
    volatile VALUE t0 = tmpbuf(n, sizeof(VALUE));
    volatile VALUE t1 = tmpbuf(n, sizeof(int));
    VALUE *arrays = (VALUE*)RSTRING(t0)-&gt;ptr; /* The arrays we're computing the product of */
    int *counters = (int*)RSTRING(t1)-&gt;ptr; /* The current position in each one */
    VALUE result;      /* The array we'll be returning */
    long i,j;
    long resultlen = 1;

    RBASIC(t0)-&gt;klass = 0;
    RBASIC(t1)-&gt;klass = 0;

    /* initialize the arrays of arrays */
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);
    
    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Compute the length of the result array; return [] if any is empty */
    for (i = 0; i &lt; n; i++) {
	long k = RARRAY(arrays[i])-&gt;len, l = resultlen;
	if (k == 0) return rb_ary_new2(0);
	resultlen *= k;
	if (resultlen &lt; k || resultlen &lt; l || resultlen / k != l) {
	    rb_raise(rb_eRangeError, &quot;too big to product&quot;);
	}
    }

    /* Otherwise, allocate and fill in an array of results */
    result = rb_ary_new2(resultlen);
    for (i = 0; i &lt; resultlen; i++) {
	int m;
	/* fill in one subarray */
	VALUE subarray = rb_ary_new2(n);
	for (j = 0; j &lt; n; j++) {
	    rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
	}

	/* put it on the result array */
	rb_ary_push(result, subarray);

	/*
	 * Increment the last counter.  If it overflows, reset to 0
	 * and increment the one before it.
	 */
	m = n-1;
	counters[m]++;
	while (m &gt; 0 &amp;&amp; counters[m] == RARRAY(arrays[m])-&gt;len) {
	    counters[m] = 0;
	    m--;
	    counters[m]++;
	}
    }

    return result;
}

/*
 *  call-seq:
 *     ary.take(n)               =&gt; array
 *  
 *  Returns first n elements from &lt;i&gt;ary&lt;/i&gt;.
 *     
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take(3)             # =&gt; [1, 2, 3]
 *     
 */

static VALUE
rb_ary_take(obj, n)
    VALUE obj;
    VALUE n;
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    return rb_ary_subseq(obj, 0, len);
}

/*
 *  call-seq:
 *     ary.take_while {|arr| block }   =&gt; array
 *  
 *  Passes elements to the block until the block returns nil or false,
 *  then stops iterating and returns an array of all prior elements.
 *     
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take_while {|i| i &lt; 3 }   # =&gt; [1, 2]
 *     
 */

static VALUE
rb_ary_take_while(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
	if (!RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}

/*
 *  call-seq:
 *     ary.drop(n)               =&gt; array
 *  
 *  Drops first n elements from &lt;i&gt;ary&lt;/i&gt;, and returns rest elements
 *  in an array.
 *     
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop(3)             # =&gt; [4, 5, 0]
 *     
 */

static VALUE
rb_ary_drop(ary, n)
    VALUE ary;
    VALUE n;
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
	rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    result = rb_ary_subseq(ary, pos, RARRAY(ary)-&gt;len);
    if (result == Qnil) result = rb_ary_new();
    return result;
}

/*
 *  call-seq:
 *     ary.drop_while {|arr| block }   =&gt; array
 *  
 *  Drops elements up to, but not including, the first element for
 *  which the block returns nil or false and returns an array
 *  containing the remaining elements.
 *     
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop_while {|i| i &lt; 3 }   # =&gt; [3, 4, 5, 0]
 *     
 */

static VALUE
rb_ary_drop_while(ary)
    VALUE ary;
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY(ary)-&gt;len; i++) {
	if (!RTEST(rb_yield(RARRAY(ary)-&gt;ptr[i]))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}



/* Arrays are ordered, integer-indexed collections of any object. 
 * Array indexing starts at 0, as in C or Java.  A negative index is 
 * assumed to be relative to the end of the array---that is, an index of -1 
 * indicates the last element of the array, -2 is the next to last 
 * element in the array, and so on. 
 */

void
Init_Array()
{
    rb_cArray  = rb_define_class(&quot;Array&quot;, rb_cObject);
    rb_include_module(rb_cArray, rb_mEnumerable);

    rb_define_alloc_func(rb_cArray, ary_alloc);
    rb_define_singleton_method(rb_cArray, &quot;[]&quot;, rb_ary_s_create, -1);
    rb_define_method(rb_cArray, &quot;initialize&quot;, rb_ary_initialize, -1);
    rb_define_method(rb_cArray, &quot;initialize_copy&quot;, rb_ary_replace, 1);

    rb_define_method(rb_cArray, &quot;to_s&quot;, rb_ary_to_s, 0);
    rb_define_method(rb_cArray, &quot;inspect&quot;, rb_ary_inspect, 0);
    rb_define_method(rb_cArray, &quot;to_a&quot;, rb_ary_to_a, 0);
    rb_define_method(rb_cArray, &quot;to_ary&quot;, rb_ary_to_ary_m, 0);
    rb_define_method(rb_cArray, &quot;frozen?&quot;,  rb_ary_frozen_p, 0);

    rb_define_method(rb_cArray, &quot;==&quot;, rb_ary_equal, 1);
    rb_define_method(rb_cArray, &quot;eql?&quot;, rb_ary_eql, 1);
    rb_define_method(rb_cArray, &quot;hash&quot;, rb_ary_hash, 0);

    rb_define_method(rb_cArray, &quot;[]&quot;, rb_ary_aref, -1);
    rb_define_method(rb_cArray, &quot;[]=&quot;, rb_ary_aset, -1);
    rb_define_method(rb_cArray, &quot;at&quot;, rb_ary_at, 1);
    rb_define_method(rb_cArray, &quot;fetch&quot;, rb_ary_fetch, -1);
    rb_define_method(rb_cArray, &quot;first&quot;, rb_ary_first, -1);
    rb_define_method(rb_cArray, &quot;last&quot;, rb_ary_last, -1);
    rb_define_method(rb_cArray, &quot;concat&quot;, rb_ary_concat, 1);
    rb_define_method(rb_cArray, &quot;&lt;&lt;&quot;, rb_ary_push, 1);
    rb_define_method(rb_cArray, &quot;push&quot;, rb_ary_push_m, -1);
    rb_define_method(rb_cArray, &quot;pop&quot;, rb_ary_pop_m, -1);
    rb_define_method(rb_cArray, &quot;shift&quot;, rb_ary_shift_m, -1);
    rb_define_method(rb_cArray, &quot;unshift&quot;, rb_ary_unshift_m, -1);
    rb_define_method(rb_cArray, &quot;insert&quot;, rb_ary_insert, -1);
    rb_define_method(rb_cArray, &quot;each&quot;, rb_ary_each, 0);
    rb_define_method(rb_cArray, &quot;each_index&quot;, rb_ary_each_index, 0);
    rb_define_method(rb_cArray, &quot;reverse_each&quot;, rb_ary_reverse_each, 0);
    rb_define_method(rb_cArray, &quot;length&quot;, rb_ary_length, 0);
    rb_define_alias(rb_cArray,  &quot;size&quot;, &quot;length&quot;);
    rb_define_method(rb_cArray, &quot;empty?&quot;, rb_ary_empty_p, 0);
    rb_define_method(rb_cArray, &quot;find_index&quot;, rb_ary_index, -1);
    rb_define_method(rb_cArray, &quot;index&quot;, rb_ary_index, -1);
    rb_define_method(rb_cArray, &quot;rindex&quot;, rb_ary_rindex, -1);
    rb_define_method(rb_cArray, &quot;indexes&quot;, rb_ary_indexes, -1);
    rb_define_method(rb_cArray, &quot;indices&quot;, rb_ary_indexes, -1);
    rb_define_method(rb_cArray, &quot;join&quot;, rb_ary_join_m, -1);
    rb_define_method(rb_cArray, &quot;reverse&quot;, rb_ary_reverse_m, 0);
    rb_define_method(rb_cArray, &quot;reverse!&quot;, rb_ary_reverse_bang, 0);
    rb_define_method(rb_cArray, &quot;sort&quot;, rb_ary_sort, 0);
    rb_define_method(rb_cArray, &quot;sort!&quot;, rb_ary_sort_bang, 0);
    rb_define_method(rb_cArray, &quot;collect&quot;, rb_ary_collect, 0);
    rb_define_method(rb_cArray, &quot;collect!&quot;, rb_ary_collect_bang, 0);
    rb_define_method(rb_cArray, &quot;map&quot;, rb_ary_collect, 0);
    rb_define_method(rb_cArray, &quot;map!&quot;, rb_ary_collect_bang, 0);
    rb_define_method(rb_cArray, &quot;select&quot;, rb_ary_select, 0);
    rb_define_method(rb_cArray, &quot;values_at&quot;, rb_ary_values_at, -1);
    rb_define_method(rb_cArray, &quot;delete&quot;, rb_ary_delete, 1);
    rb_define_method(rb_cArray, &quot;delete_at&quot;, rb_ary_delete_at_m, 1);
    rb_define_method(rb_cArray, &quot;delete_if&quot;, rb_ary_delete_if, 0);
    rb_define_method(rb_cArray, &quot;reject&quot;, rb_ary_reject, 0);
    rb_define_method(rb_cArray, &quot;reject!&quot;, rb_ary_reject_bang, 0);
    rb_define_method(rb_cArray, &quot;zip&quot;, rb_ary_zip, -1);
    rb_define_method(rb_cArray, &quot;transpose&quot;, rb_ary_transpose, 0);
    rb_define_method(rb_cArray, &quot;replace&quot;, rb_ary_replace, 1);
    rb_define_method(rb_cArray, &quot;clear&quot;, rb_ary_clear, 0);
    rb_define_method(rb_cArray, &quot;fill&quot;, rb_ary_fill, -1);
    rb_define_method(rb_cArray, &quot;include?&quot;, rb_ary_includes, 1);
    rb_define_method(rb_cArray, &quot;&lt;=&gt;&quot;, rb_ary_cmp, 1);

    rb_define_method(rb_cArray, &quot;slice&quot;, rb_ary_aref, -1);
    rb_define_method(rb_cArray, &quot;slice!&quot;, rb_ary_slice_bang, -1);

    rb_define_method(rb_cArray, &quot;assoc&quot;, rb_ary_assoc, 1);
    rb_define_method(rb_cArray, &quot;rassoc&quot;, rb_ary_rassoc, 1);

    rb_define_method(rb_cArray, &quot;+&quot;, rb_ary_plus, 1);
    rb_define_method(rb_cArray, &quot;*&quot;, rb_ary_times, 1);

    rb_define_method(rb_cArray, &quot;-&quot;, rb_ary_diff, 1);
    rb_define_method(rb_cArray, &quot;&amp;&quot;, rb_ary_and, 1);
    rb_define_method(rb_cArray, &quot;|&quot;, rb_ary_or, 1);

    rb_define_method(rb_cArray, &quot;uniq&quot;, rb_ary_uniq, 0);
    rb_define_method(rb_cArray, &quot;uniq!&quot;, rb_ary_uniq_bang, 0);
    rb_define_method(rb_cArray, &quot;compact&quot;, rb_ary_compact, 0);
    rb_define_method(rb_cArray, &quot;compact!&quot;, rb_ary_compact_bang, 0);
    rb_define_method(rb_cArray, &quot;flatten&quot;, rb_ary_flatten, -1);
    rb_define_method(rb_cArray, &quot;flatten!&quot;, rb_ary_flatten_bang, -1);
    rb_define_method(rb_cArray, &quot;nitems&quot;, rb_ary_nitems, 0);
    rb_define_method(rb_cArray, &quot;count&quot;, rb_ary_count, -1);
    rb_define_method(rb_cArray, &quot;shuffle!&quot;, rb_ary_shuffle_bang, 0);
    rb_define_method(rb_cArray, &quot;shuffle&quot;, rb_ary_shuffle, 0);
    rb_define_method(rb_cArray, &quot;choice&quot;, rb_ary_choice, 0);
    rb_define_method(rb_cArray, &quot;cycle&quot;, rb_ary_cycle, -1);
    rb_define_method(rb_cArray, &quot;permutation&quot;, rb_ary_permutation, -1);
    rb_define_method(rb_cArray, &quot;combination&quot;, rb_ary_combination, 1);
    rb_define_method(rb_cArray, &quot;product&quot;, rb_ary_product, -1);

    rb_define_method(rb_cArray, &quot;take&quot;, rb_ary_take, 1);
    rb_define_method(rb_cArray, &quot;take_while&quot;, rb_ary_take_while, 0);
    rb_define_method(rb_cArray, &quot;drop&quot;, rb_ary_drop, 1);
    rb_define_method(rb_cArray, &quot;drop_while&quot;, rb_ary_drop_while, 0);

    id_cmp = rb_intern(&quot;&lt;=&gt;&quot;);
    inspect_key = rb_intern(&quot;__inspect_key__&quot;);
}
</pre>
    </div>