  <div id="fileHeader">
    <h1>enum.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/enum.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat May 31 06:44:49 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  enum.c -

  $Author: knu $
  $Date: 2008-05-31 20:44:49 +0900 (Sat, 31 May 2008) $
  created at: Fri Oct  1 15:15:19 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;node.h&quot;
#include &quot;util.h&quot;

VALUE rb_mEnumerable;
static ID id_each, id_eqq, id_cmp, id_size;

struct iter_method_arg {
    VALUE obj;
    ID mid;
    int argc;
    VALUE *argv;
};

static VALUE iterate_method _((VALUE obj));
static VALUE
iterate_method(obj)
    VALUE obj;
{
    struct iter_method_arg *arg;

    arg = (struct iter_method_arg *)obj;
    return rb_funcall2(arg-&gt;obj, arg-&gt;mid, arg-&gt;argc, arg-&gt;argv);
}

VALUE
rb_block_call(obj, mid, argc, argv, bl_proc, data2)
    VALUE obj;
    ID mid;
    int argc;
    VALUE *argv;
    VALUE (*bl_proc) (ANYARGS);
    VALUE data2;
{
    struct iter_method_arg arg;

    arg.obj = obj;
    arg.mid = mid;
    arg.argc = argc;
    arg.argv = argv;
    return rb_iterate(iterate_method, (VALUE)&amp;arg, bl_proc, data2);
}

VALUE
rb_each(obj)
    VALUE obj;
{
    return rb_funcall(obj, id_each, 0, 0);
}

static VALUE
grep_i(i, arg)
    VALUE i, *arg;
{
    if (RTEST(rb_funcall(arg[0], id_eqq, 1, i))) {
	rb_ary_push(arg[1], i);
    }
    return Qnil;
}

static VALUE
grep_iter_i(i, arg)
    VALUE i, *arg;
{
    if (RTEST(rb_funcall(arg[0], id_eqq, 1, i))) {
	rb_ary_push(arg[1], rb_yield(i));
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.grep(pattern)                   =&gt; array
 *     enum.grep(pattern) {| obj | block }  =&gt; array
 *
 *  Returns an array of every element in &lt;i&gt;enum&lt;/i&gt; for which
 *  &lt;code&gt;Pattern === element&lt;/code&gt;. If the optional &lt;em&gt;block&lt;/em&gt; is
 *  supplied, each matching element is passed to it, and the block's
 *  result is stored in the output array.
 *
 *     (1..100).grep 38..44   #=&gt; [38, 39, 40, 41, 42, 43, 44]
 *     c = IO.constants
 *     c.grep(/SEEK/)         #=&gt; [&quot;SEEK_END&quot;, &quot;SEEK_SET&quot;, &quot;SEEK_CUR&quot;]
 *     res = c.grep(/SEEK/) {|v| IO.const_get(v) }
 *     res                    #=&gt; [2, 0, 1]
 *
 */

static VALUE
enum_grep(obj, pat)
    VALUE obj, pat;
{
    VALUE ary = rb_ary_new();
    VALUE arg[2];

    arg[0] = pat;
    arg[1] = ary;

    rb_iterate(rb_each, obj, rb_block_given_p() ? grep_iter_i : grep_i, (VALUE)arg);

    return ary;
}

static VALUE count_i _((VALUE, VALUE));
static VALUE
count_i(i, memop)
    VALUE i, memop;
{
    VALUE *memo = (VALUE*)memop;

    if (rb_equal(i, memo[1])) {
	memo[0]++;
    }
    return Qnil;
}

static VALUE count_iter_i _((VALUE, VALUE));
static VALUE
count_iter_i(i, memop)
    VALUE i, memop;
{
    VALUE *memo = (VALUE*)memop;

    if (RTEST(rb_yield(i))) {
	memo[0]++;
    }
    return Qnil;
}

static VALUE count_all_i _((VALUE, VALUE));
static VALUE
count_all_i(i, memop)
    VALUE i, memop;
{
    VALUE *memo = (VALUE*)memop;

    memo[0]++;
    return Qnil;
}

/*
 *  call-seq:
 *     enum.count                   =&gt; int
 *     enum.count(item)             =&gt; int
 *     enum.count {| obj | block }  =&gt; int
 *
 *  Returns the number of items in &lt;i&gt;enum&lt;/i&gt;, where #size is called
 *  if it responds to it, otherwise the items are counted through
 *  enumeration.  If an argument is given, counts the number of items
 *  in &lt;i&gt;enum&lt;/i&gt;, for which equals to &lt;i&gt;item&lt;/i&gt;.  If a block is
 *  given, counts the number of elements yielding a true value.
 *
 *     ary = [1, 2, 4, 2]
 *     ary.count             # =&gt; 4
 *     ary.count(2)          # =&gt; 2
 *     ary.count{|x|x%2==0}  # =&gt; 3
 *
 */

static VALUE
enum_count(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE memo[2];	/* [count, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
	if (rb_block_given_p()) {
	    func = count_iter_i;
	}
	else {
	    if (rb_respond_to(obj, id_size)) {
		return rb_funcall(obj, id_size, 0, 0);
	    }
	    func = count_all_i;
	}
    }
    else {
	rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[1]);
	if (rb_block_given_p()) {
	    rb_warn(&quot;given block not used&quot;);
	}
        func = count_i;
    }

    memo[0] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)&amp;memo);
    return INT2NUM(memo[0]);
}

static VALUE
find_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    if (RTEST(rb_yield(i))) {
	*memo = i;
	rb_iter_break();
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.detect(ifnone = nil) {| obj | block }  =&gt; obj or nil
 *     enum.find(ifnone = nil)   {| obj | block }  =&gt; obj or nil
 *
 *  Passes each entry in &lt;i&gt;enum&lt;/i&gt; to &lt;em&gt;block&lt;/em&gt;. Returns the
 *  first for which &lt;em&gt;block&lt;/em&gt; is not &lt;code&gt;false&lt;/code&gt;.  If no
 *  object matches, calls &lt;i&gt;ifnone&lt;/i&gt; and returns its result when it
 *  is specified, or returns &lt;code&gt;nil&lt;/code&gt;
 *
 *     (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
 *     (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 35
 *
 */

static VALUE
enum_find(argc, argv, obj)
    int argc;
    VALUE* argv;
    VALUE obj;
{
    VALUE memo = Qundef;
    VALUE if_none;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;if_none);
    RETURN_ENUMERATOR(obj, argc, argv);
    rb_iterate(rb_each, obj, find_i, (VALUE)&amp;memo);
    if (memo != Qundef) {
	return memo;
    }
    if (!NIL_P(if_none)) {
	return rb_funcall(if_none, rb_intern(&quot;call&quot;), 0, 0);
    }
    return Qnil;
}

static VALUE find_index_i _((VALUE, VALUE));
static VALUE
find_index_i(i, memop)
    VALUE i;
    VALUE memop;
{
    VALUE *memo = (VALUE*)memop;

    if (rb_equal(i, memo[2])) {
	memo[0] = UINT2NUM(memo[1]);
	rb_iter_break();
    }
    memo[1]++;
    return Qnil;
}

static VALUE find_index_iter_i _((VALUE, VALUE));
static VALUE
find_index_iter_i(i, memop)
    VALUE i;
    VALUE memop;
{
    VALUE *memo = (VALUE*)memop;

    if (RTEST(rb_yield(i))) {
	memo[0] = UINT2NUM(memo[1]);
	rb_iter_break();
    }
    memo[1]++;
    return Qnil;
}

/*
 *  call-seq:
 *     enum.find_index(value)            =&gt; int or nil
 *     enum.find_index {| obj | block }  =&gt; int or nil
 *
 *  Compares each entry in &lt;i&gt;enum&lt;/i&gt; with &lt;em&gt;value&lt;/em&gt; or passes
 *  to &lt;em&gt;block&lt;/em&gt;.  Returns the index for the first for which the
 *  evaluated value is non-false.  If no object matches, returns
 *  &lt;code&gt;nil&lt;/code&gt;
 *
 *     (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; nil
 *     (1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   #=&gt; 34
 *     (1..100).find_index(50)                                #=&gt; 49
 *
 */

static VALUE
enum_find_index(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE memo[3];	/* [return value, current index, condition value] */
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
	rb_scan_args(argc, argv, &quot;1&quot;, &amp;memo[2]);
	if (rb_block_given_p()) {
	    rb_warn(&quot;given block not used&quot;);
	}
        func = find_index_i;
    }

    memo[0] = Qnil;
    memo[1] = 0;
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo[0];
}

static VALUE
find_all_i(i, ary)
    VALUE i, ary;
{
    if (RTEST(rb_yield(i))) {
	rb_ary_push(ary, i);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.find_all {| obj | block }  =&gt; array
 *     enum.select   {| obj | block }  =&gt; array
 *
 *  Returns an array containing all elements of &lt;i&gt;enum&lt;/i&gt; for which
 *  &lt;em&gt;block&lt;/em&gt; is not &lt;code&gt;false&lt;/code&gt; (see also
 *  &lt;code&gt;Enumerable#reject&lt;/code&gt;).
 *
 *     (1..10).find_all {|i|  i % 3 == 0 }   #=&gt; [3, 6, 9]
 *
 */

static VALUE
enum_find_all(obj)
    VALUE obj;
{
    VALUE ary = rb_ary_new();

    RETURN_ENUMERATOR(obj, 0, 0);
    rb_iterate(rb_each, obj, find_all_i, ary);

    return ary;
}

static VALUE
reject_i(i, ary)
    VALUE i, ary;
{
    if (!RTEST(rb_yield(i))) {
	rb_ary_push(ary, i);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.reject {| obj | block }  =&gt; array
 *
 *  Returns an array for all elements of &lt;i&gt;enum&lt;/i&gt; for which
 *  &lt;em&gt;block&lt;/em&gt; is false (see also &lt;code&gt;Enumerable#find_all&lt;/code&gt;).
 *
 *     (1..10).reject {|i|  i % 3 == 0 }   #=&gt; [1, 2, 4, 5, 7, 8, 10]
 *
 */

static VALUE
enum_reject(obj)
    VALUE obj;
{
    VALUE ary = rb_ary_new();

    RETURN_ENUMERATOR(obj, 0, 0);
    rb_iterate(rb_each, obj, reject_i, ary);

    return ary;
}

static VALUE
collect_i(i, ary)
    VALUE i, ary;
{
    rb_ary_push(ary, rb_yield(i));

    return Qnil;
}

static VALUE
collect_all(i, ary)
    VALUE i, ary;
{
    rb_ary_push(ary, i);

    return Qnil;
}

/*
 *  call-seq:
 *     enum.collect {| obj | block }  =&gt; array
 *     enum.map     {| obj | block }  =&gt; array
 *
 *  Returns a new array with the results of running &lt;em&gt;block&lt;/em&gt; once
 *  for every element in &lt;i&gt;enum&lt;/i&gt;.
 *
 *     (1..4).collect {|i| i*i }   #=&gt; [1, 4, 9, 16]
 *     (1..4).collect { &quot;cat&quot;  }   #=&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]
 *
 */

static VALUE
enum_collect(obj)
    VALUE obj;
{
    VALUE ary = rb_ary_new();

    rb_iterate(rb_each, obj, rb_block_given_p() ? collect_i : collect_all, ary);

    return ary;
}

/*
 *  call-seq:
 *     enum.to_a      =&gt;    array
 *     enum.entries   =&gt;    array
 *
 *  Returns an array containing the items in &lt;i&gt;enum&lt;/i&gt;.
 *
 *     (1..7).to_a                       #=&gt; [1, 2, 3, 4, 5, 6, 7]
 *     { 'a'=&gt;1, 'b'=&gt;2, 'c'=&gt;3 }.to_a   #=&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]
 */
static VALUE
enum_to_a(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE ary = rb_ary_new();

    rb_block_call(obj, id_each, argc, argv, collect_all, ary);

    return ary;
}

static VALUE inject_i _((VALUE, VALUE));
static VALUE
inject_i(i, p)
    VALUE i;
    VALUE p;
{
    VALUE *memo = (VALUE *)p;
    if (memo[0] == Qundef) {
	memo[0] = i;
    }
    else {
	memo[0] = rb_yield_values(2, memo[0], i);
    }
    return Qnil;
}

static VALUE inject_op_i _((VALUE, VALUE));
static VALUE
inject_op_i(i, p)
    VALUE i;
    VALUE p;
{
    VALUE *memo = (VALUE *)p;

    if (memo[0] == Qundef) {
	memo[0] = i;
    }
    else {
	memo[0] = rb_funcall(memo[0], (ID)memo[1], 1, i);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.inject(initial, sym) =&gt; obj
 *     enum.inject(sym)          =&gt; obj
 *     enum.inject(initial) {| memo, obj | block }  =&gt; obj
 *     enum.inject          {| memo, obj | block }  =&gt; obj
 *
 *     enum.reduce(initial, sym) =&gt; obj
 *     enum.reduce(sym)          =&gt; obj
 *     enum.reduce(initial) {| memo, obj | block }  =&gt; obj
 *     enum.reduce          {| memo, obj | block }  =&gt; obj
 *
 *  Combines all elements of &lt;i&gt;enum&lt;/i&gt; by applying a binary
 *  operation, specified by a block or a symbol that names a
 *  method or operator.
 *
 *  If you specify a block, then for each element in &lt;i&gt;enum&lt;i&gt;
 *  the block is passed an accumulator value (&lt;i&gt;memo&lt;/i&gt;) and the element.
 *  If you specify a symbol instead, then each element in the collection
 *  will be passed to the named method of &lt;i&gt;memo&lt;/i&gt;.
 *  In either case, the result becomes the new value for &lt;i&gt;memo&lt;/i&gt;.
 *  At the end of the iteration, the final value of &lt;i&gt;memo&lt;/i&gt; is the
 *  return value fo the method.
 *
 *  If you do not explicitly specify an &lt;i&gt;initial&lt;/i&gt; value for &lt;i&gt;memo&lt;/i&gt;,
 *  then uses the first element of collection is used as the initial value
 *  of &lt;i&gt;memo&lt;/i&gt;.
 *
 *  Examples:
 *
 *     # Sum some numbers
 *     (5..10).reduce(:+)                            #=&gt; 45
 *     # Same using a block and inject
 *     (5..10).inject {|sum, n| sum + n }            #=&gt; 45
 *     # Multiply some numbers
 *     (5..10).reduce(1, :*)                         #=&gt; 151200
 *     # Same using a block
 *     (5..10).inject(1) {|product, n| product * n } #=&gt; 151200
 *     # find the longest word
 *     longest = %w{ cat sheep bear }.inject do |memo,word|
 *        memo.length &gt; word.length ? memo : word
 *     end
 *     longest                                       #=&gt; &quot;sheep&quot;
 *
 */
static VALUE
enum_inject(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE memo[2];
    rb_block_call_func *iter = inject_i;

    switch (rb_scan_args(argc, argv, &quot;02&quot;, &amp;memo[0], &amp;memo[1])) {
      case 0:
	memo[0] = Qundef;
	break;
      case 1:
	if (rb_block_given_p()) {
	    break;
	}
	memo[1] = (VALUE)rb_to_id(memo[0]);
	memo[0] = Qundef;
	iter = inject_op_i;
	break;
      case 2:
	if (rb_block_given_p()) {
	    rb_warning(&quot;given block not used&quot;);
	}
	memo[1] = (VALUE)rb_to_id(memo[1]);
	iter = inject_op_i;
	break;
    }
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (memo[0] == Qundef) return Qnil;
    return memo[0];
}

static VALUE
partition_i(i, ary)
    VALUE i, *ary;
{
    if (RTEST(rb_yield(i))) {
	rb_ary_push(ary[0], i);
    }
    else {
	rb_ary_push(ary[1], i);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.partition {| obj | block }  =&gt; [ true_array, false_array ]
 *
 *  Returns two arrays, the first containing the elements of
 *  &lt;i&gt;enum&lt;/i&gt; for which the block evaluates to true, the second
 *  containing the rest.
 *
 *     (1..6).partition {|i| (i&amp;1).zero?}   #=&gt; [[2, 4, 6], [1, 3, 5]]
 *
 */

static VALUE
enum_partition(obj)
    VALUE obj;
{
    VALUE ary[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    ary[0] = rb_ary_new();
    ary[1] = rb_ary_new();
    rb_iterate(rb_each, obj, partition_i, (VALUE)ary);

    return rb_assoc_new(ary[0], ary[1]);
}

static VALUE
group_by_i(i, hash)
    VALUE i;
    VALUE hash;
{
    VALUE group = rb_yield(i);
    VALUE values;

    values = rb_hash_aref(hash, group);
    if (NIL_P(values)) {
	values = rb_ary_new3(1, i);
	rb_hash_aset(hash, group, values);
    }
    else {
	rb_ary_push(values, i);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.group_by {| obj | block }  =&gt; a_hash
 *
 *  Returns a hash, which keys are evaluated result from the
 *  block, and values are arrays of elements in &lt;i&gt;enum&lt;/i&gt;
 *  corresponding to the key.
 *
 *     (1..6).group_by {|i| i%3}   #=&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}
 *
 */

static VALUE
enum_group_by(obj)
    VALUE obj;
{
    VALUE hash;

    RETURN_ENUMERATOR(obj, 0, 0);

    hash = rb_hash_new();
    rb_block_call(obj, id_each, 0, 0, group_by_i, hash);

    return hash;
}

static VALUE
first_i(i, ary)
    VALUE i;
    VALUE *ary;
{
    if (NIL_P(ary[0])) {
	ary[1] = i;
	rb_iter_break();
    }
    else {
	long n = NUM2LONG(ary[0]);

	if (n &lt;= 0) {
	    rb_iter_break();
	}
	rb_ary_push(ary[1], i);
	n--;
	ary[0] = INT2NUM(n);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.first      -&gt; obj or nil
 *     enum.first(n)   -&gt; an_array
 *
 *  Returns the first element, or the first +n+ elements, of the enumerable.
 *  If the enumerable is empty, the first form returns &lt;code&gt;nil&lt;/code&gt;, and the
 *  second form returns an empty array.
 *
 */

static VALUE
enum_first(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE n, ary[2];

    if (argc == 0) {
	ary[0] = ary[1] = Qnil;
    }
    else {
	rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
	ary[0] = n;
	ary[1] = rb_ary_new2(NUM2LONG(n));
    }
    rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)ary);

    return ary[1];
}


/*
 *  call-seq:
 *     enum.sort                     =&gt; array
 *     enum.sort {| a, b | block }   =&gt; array
 *
 *  Returns an array containing the items in &lt;i&gt;enum&lt;/i&gt; sorted,
 *  either according to their own &lt;code&gt;&lt;=&gt;&lt;/code&gt; method, or by using
 *  the results of the supplied block. The block should return -1, 0, or
 *  +1 depending on the comparison between &lt;i&gt;a&lt;/i&gt; and &lt;i&gt;b&lt;/i&gt;. As of
 *  Ruby 1.8, the method &lt;code&gt;Enumerable#sort_by&lt;/code&gt; implements a
 *  built-in Schwartzian Transform, useful when key computation or
 *  comparison is expensive..
 *
 *     %w(rhea kea flea).sort         #=&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]
 *     (1..10).sort {|a,b| b &lt;=&gt; a}   #=&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
 */

static VALUE
enum_sort(obj)
    VALUE obj;
{
    return rb_ary_sort(enum_to_a(0, 0, obj));
}

static VALUE
sort_by_i(i, ary)
    VALUE i, ary;
{
    VALUE v;
    NODE *memo;

    v = rb_yield(i);
    if (RBASIC(ary)-&gt;klass) {
	rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    memo = rb_node_newnode(NODE_MEMO, v, i, 0);
    rb_ary_push(ary, (VALUE)memo);
    return Qnil;
}

static int
sort_by_cmp(aa, bb, data)
    NODE **aa, **bb;
    void *data;
{
    VALUE a = aa[0]-&gt;u1.value;
    VALUE b = bb[0]-&gt;u1.value;
    VALUE ary = (VALUE)data;

    if (RBASIC(ary)-&gt;klass) {
	rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    return rb_cmpint(rb_funcall(a, id_cmp, 1, b), a, b);
}

/*
 *  call-seq:
 *     enum.sort_by {| obj | block }    =&gt; array
 *
 *  Sorts &lt;i&gt;enum&lt;/i&gt; using a set of keys generated by mapping the
 *  values in &lt;i&gt;enum&lt;/i&gt; through the given block.
 *
 *     %w{ apple pear fig }.sort_by {|word| word.length}
                    #=&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]
 *
 *  The current implementation of &lt;code&gt;sort_by&lt;/code&gt; generates an
 *  array of tuples containing the original collection element and the
 *  mapped value. This makes &lt;code&gt;sort_by&lt;/code&gt; fairly expensive when
 *  the keysets are simple
 *
 *     require 'benchmark'
 *     include Benchmark
 *
 *     a = (1..100000).map {rand(100000)}
 *
 *     bm(10) do |b|
 *       b.report(&quot;Sort&quot;)    { a.sort }
 *       b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }
 *     end
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     user     system      total        real
 *     Sort        0.180000   0.000000   0.180000 (  0.175469)
 *     Sort by     1.980000   0.040000   2.020000 (  2.013586)
 *
 *  However, consider the case where comparing the keys is a non-trivial
 *  operation. The following code sorts some files on modification time
 *  using the basic &lt;code&gt;sort&lt;/code&gt; method.
 *
 *     files = Dir[&quot;*&quot;]
 *     sorted = files.sort {|a,b| File.new(a).mtime &lt;=&gt; File.new(b).mtime}
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *
 *  This sort is inefficient: it generates two new &lt;code&gt;File&lt;/code&gt;
 *  objects during every comparison. A slightly better technique is to
 *  use the &lt;code&gt;Kernel#test&lt;/code&gt; method to generate the modification
 *  times directly.
 *
 *     files = Dir[&quot;*&quot;]
 *     sorted = files.sort { |a,b|
 *       test(?M, a) &lt;=&gt; test(?M, b)
 *     }
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *
 *  This still generates many unnecessary &lt;code&gt;Time&lt;/code&gt; objects. A
 *  more efficient technique is to cache the sort keys (modification
 *  times in this case) before the sort. Perl users often call this
 *  approach a Schwartzian Transform, after Randal Schwartz. We
 *  construct a temporary array, where each element is an array
 *  containing our sort key along with the filename. We sort this array,
 *  and then extract the filename from the result.
 *
 *     sorted = Dir[&quot;*&quot;].collect { |f|
 *        [test(?M, f), f]
 *     }.sort.collect { |f| f[1] }
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 *
 *  This is exactly what &lt;code&gt;sort_by&lt;/code&gt; does internally.
 *
 *     sorted = Dir[&quot;*&quot;].sort_by {|f| test(?M, f)}
 *     sorted   #=&gt; [&quot;mon&quot;, &quot;tues&quot;, &quot;wed&quot;, &quot;thurs&quot;]
 */

static VALUE
enum_sort_by(obj)
    VALUE obj;
{
    VALUE ary;
    long i;

    RETURN_ENUMERATOR(obj, 0, 0);

    if (TYPE(obj) == T_ARRAY) {
	ary  = rb_ary_new2(RARRAY(obj)-&gt;len);
    }
    else {
	ary = rb_ary_new();
    }
    RBASIC(ary)-&gt;klass = 0;
    rb_iterate(rb_each, obj, sort_by_i, ary);
    if (RARRAY(ary)-&gt;len &gt; 1) {
	qsort(RARRAY(ary)-&gt;ptr, RARRAY(ary)-&gt;len, sizeof(VALUE),
	      sort_by_cmp, (void *)ary);
    }
    if (RBASIC(ary)-&gt;klass) {
	rb_raise(rb_eRuntimeError, &quot;sort_by reentered&quot;);
    }
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	RARRAY(ary)-&gt;ptr[i] = RNODE(RARRAY(ary)-&gt;ptr[i])-&gt;u2.value;
    }
    RBASIC(ary)-&gt;klass = rb_cArray;
    return ary;
}

static VALUE
all_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    if (!RTEST(i)) {
	*memo = Qfalse;
	rb_iter_break();
    }
    return Qnil;
}

static VALUE
all_iter_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    return all_i(rb_yield(i), memo);
}

/*
 *  call-seq:
 *     enum.all? [{|obj| block } ]   =&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block never returns
 *  &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. If the block is not given,
 *  Ruby adds an implicit block of &lt;code&gt;{|obj| obj}&lt;/code&gt; (that is
 *  &lt;code&gt;all?&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; only if none of the
 *  collection members are &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.)
 *
 *     %w{ ant bear cat}.all? {|word| word.length &gt;= 3}   #=&gt; true
 *     %w{ ant bear cat}.all? {|word| word.length &gt;= 4}   #=&gt; false
 *     [ nil, true, 99 ].all?                             #=&gt; false
 *
 */

static VALUE
enum_all(obj)
    VALUE obj;
{
    VALUE result = Qtrue;

    rb_iterate(rb_each, obj, rb_block_given_p() ? all_iter_i : all_i, (VALUE)&amp;result);
    return result;
}

static VALUE
any_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    if (RTEST(i)) {
	*memo = Qtrue;
	rb_iter_break();
    }
    return Qnil;
}

static VALUE
any_iter_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    return any_i(rb_yield(i), memo);
}

/*
 *  call-seq:
 *     enum.any? [{|obj| block } ]   =&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block ever returns a value other
 *  than &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;. If the block is not
 *  given, Ruby adds an implicit block of &lt;code&gt;{|obj| obj}&lt;/code&gt; (that
 *  is &lt;code&gt;any?&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt; if at least one
 *  of the collection members is not &lt;code&gt;false&lt;/code&gt; or
 *  &lt;code&gt;nil&lt;/code&gt;.
 *
 *     %w{ ant bear cat}.any? {|word| word.length &gt;= 3}   #=&gt; true
 *     %w{ ant bear cat}.any? {|word| word.length &gt;= 4}   #=&gt; true
 *     [ nil, true, 99 ].any?                             #=&gt; true
 *
 */

static VALUE
enum_any(obj)
    VALUE obj;
{
    VALUE result = Qfalse;

    rb_iterate(rb_each, obj, rb_block_given_p() ? any_iter_i : any_i, (VALUE)&amp;result);
    return result;
}

static VALUE
one_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    if (RTEST(i)) {
	if (*memo == Qundef) {
	    *memo = Qtrue;
	}
	else if (*memo == Qtrue) {
	    *memo = Qfalse;
	    rb_iter_break();
	}
    }
    return Qnil;
}

static VALUE
one_iter_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    return one_i(rb_yield(i), memo);
}

/*
 *  call-seq:
 *     enum.one? [{|obj| block }]   =&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block returns &lt;code&gt;true&lt;/code&gt;
 *  exactly once. If the block is not given, &lt;code&gt;one?&lt;/code&gt; will return
 *  &lt;code&gt;true&lt;/code&gt; only if exactly one of the collection members is
 *  true.
 *
 *     %w{ant bear cat}.one? {|word| word.length == 4}   #=&gt; true
 *     %w{ant bear cat}.one? {|word| word.length &gt; 4}    #=&gt; false
 *     %w{ant bear cat}.one? {|word| word.length &lt; 4}    #=&gt; false
 *     [ nil, true, 99 ].one?                            #=&gt; false
 *     [ nil, true, false ].one?                         #=&gt; true
 *
 */

static VALUE
enum_one(obj)
    VALUE obj;
{
    VALUE result = Qundef;

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? one_iter_i : one_i, (VALUE)&amp;result);
    if (result == Qundef) return Qfalse;
    return result;
}

static VALUE
none_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    if (RTEST(i)) {
	*memo = Qfalse;
	rb_iter_break();
    }
    return Qnil;
}

static VALUE
none_iter_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    return none_i(rb_yield(i), memo);
}

/*
 *  call-seq:
 *     enum.none? [{|obj| block }]   =&gt; true or false
 *
 *  Passes each element of the collection to the given block. The method
 *  returns &lt;code&gt;true&lt;/code&gt; if the block never returns &lt;code&gt;true&lt;/code&gt;
 *  for all elements. If the block is not given, &lt;code&gt;none?&lt;/code&gt; will return
 *  &lt;code&gt;true&lt;/code&gt; only if none of the collection members is true.
 *
 *     %w{ant bear cat}.none? {|word| word.length == 5}  #=&gt; true
 *     %w{ant bear cat}.none? {|word| word.length &gt;= 4}  #=&gt; false
 *     [].none?                                          #=&gt; true
 *     [nil].none?                                       #=&gt; true
 *     [nil,false].none?                                 #=&gt; true
 */
static VALUE
enum_none(obj)
    VALUE obj;
{
    VALUE result = Qtrue;

    rb_block_call(obj, id_each, 0, 0, rb_block_given_p() ? none_iter_i : none_i, (VALUE)&amp;result);
    return result;
}

static VALUE
min_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    VALUE cmp;

    if (*memo == Qundef) {
	*memo = i;
    }
    else {
	cmp = rb_funcall(i, id_cmp, 1, *memo);
	if (rb_cmpint(cmp, i, *memo) &lt; 0) {
	    *memo = i;
	}
    }
    return Qnil;
}

static VALUE
min_ii(i, memo)
    VALUE i;
    VALUE *memo;
{
    VALUE cmp;

    if (*memo == Qundef) {
	*memo = i;
    }
    else {
	cmp = rb_yield_values(2, i, *memo);
	if (rb_cmpint(cmp, i, *memo) &lt; 0) {
	    *memo = i;
	}
    }
    return Qnil;
}


/*
 *  call-seq:
 *     enum.min                    =&gt; obj
 *     enum.min {| a,b | block }   =&gt; obj
 *
 *  Returns the object in &lt;i&gt;enum&lt;/i&gt; with the minimum value. The
 *  first form assumes all objects implement &lt;code&gt;Comparable&lt;/code&gt;;
 *  the second uses the block to return &lt;em&gt;a &lt;=&gt; b&lt;/em&gt;.
 *
 *     a = %w(albatross dog horse)
 *     a.min                                  #=&gt; &quot;albatross&quot;
 *     a.min {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;dog&quot;
 */

static VALUE
enum_min(obj)
    VALUE obj;
{
    VALUE result = Qundef;

    rb_iterate(rb_each, obj, rb_block_given_p() ? min_ii : min_i, (VALUE)&amp;result);
    if (result == Qundef) return Qnil;
    return result;
}

/*
 *  call-seq:
 *     enum.max                    =&gt; obj
 *     enum.max {| a,b | block }   =&gt; obj
 *
 *  Returns the object in &lt;i&gt;enum&lt;/i&gt; with the maximum value. The
 *  first form assumes all objects implement &lt;code&gt;Comparable&lt;/code&gt;;
 *  the second uses the block to return &lt;em&gt;a &lt;=&gt; b&lt;/em&gt;.
 *
 *     a = %w(albatross dog horse)
 *     a.max                                  #=&gt; &quot;horse&quot;
 *     a.max {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;albatross&quot;
 */

static VALUE
max_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    VALUE cmp;

    if (*memo == Qundef) {
	*memo = i;
    }
    else {
	cmp = rb_funcall(i, id_cmp, 1, *memo);
	if (rb_cmpint(cmp, i, *memo) &gt; 0) {
	    *memo = i;
	}
    }
    return Qnil;
}

static VALUE
max_ii(i, memo)
    VALUE i;
    VALUE *memo;
{
    VALUE cmp;

    if (*memo == Qundef) {
	*memo = i;
    }
    else {
	cmp = rb_yield_values(2, i, *memo);
	if (rb_cmpint(cmp, i, *memo) &gt; 0) {
	    *memo = i;
	}
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.max                   =&gt; obj
 *     enum.max {|a,b| block }    =&gt; obj
 *
 *  Returns the object in _enum_ with the maximum value. The
 *  first form assumes all objects implement &lt;code&gt;Comparable&lt;/code&gt;;
 *  the second uses the block to return &lt;em&gt;a &lt;=&gt; b&lt;/em&gt;.
 *
 *     a = %w(albatross dog horse)
 *     a.max                                  #=&gt; &quot;horse&quot;
 *     a.max {|a,b| a.length &lt;=&gt; b.length }   #=&gt; &quot;albatross&quot;
 */

static VALUE
enum_max(obj)
    VALUE obj;
{
    VALUE result = Qundef;

    rb_iterate(rb_each, obj, rb_block_given_p() ? max_ii : max_i, (VALUE)&amp;result);
    if (result == Qundef) return Qnil;
    return result;
}

static VALUE
minmax_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    int n;

    if (memo[0] == Qundef) {
	memo[0] = i;
	memo[1] = i;
    }
    else {
	n = rb_cmpint(rb_funcall(i, id_cmp, 1, memo[0]), i, memo[0]);
	if (n &lt; 0) {
	    memo[0] = i;
	}
	n = rb_cmpint(rb_funcall(i, id_cmp, 1, memo[1]), i, memo[1]);
	if (n &gt; 0) {
	    memo[1] = i;
	}
    }
    return Qnil;
}

static VALUE
minmax_ii(i, memo)
    VALUE i;
    VALUE *memo;
{
    int n;

    if (memo[0] == Qundef) {
	memo[0] = i;
	memo[1] = i;
    }
    else {
	VALUE ary = memo[2];

	RARRAY(ary)-&gt;ptr[0] = i;
	RARRAY(ary)-&gt;ptr[1] = memo[0];
	n = rb_cmpint(rb_yield(ary), i, memo[0]);
	if (n &lt; 0) {
	    memo[0] = i;
	}
	RARRAY(ary)-&gt;ptr[0] = i;
	RARRAY(ary)-&gt;ptr[1] = memo[1];
	n = rb_cmpint(rb_yield(ary), i, memo[1]);
	if (n &gt; 0) {
	    memo[1] = i;
	}
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.minmax                   =&gt; [min,max]
 *     enum.minmax {|a,b| block }    =&gt; [min,max]
 *
 *  Returns two elements array which contains the minimum and the
 *  maximum value in the enumerable.  The first form assumes all
 *  objects implement &lt;code&gt;Comparable&lt;/code&gt;; the second uses the
 *  block to return &lt;em&gt;a &lt;=&gt; b&lt;/em&gt;.
 *
 *     a = %w(albatross dog horse)
 *     a.minmax                                  #=&gt; [&quot;albatross&quot;, &quot;horse&quot;]
 *     a.minmax {|a,b| a.length &lt;=&gt; b.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]
 */

static VALUE
enum_minmax(obj)
    VALUE obj;
{
    VALUE result[3];
    VALUE ary = rb_ary_new3(2, Qnil, Qnil);

    result[0] = Qundef;
    if (rb_block_given_p()) {
	result[2] = ary;
	rb_block_call(obj, id_each, 0, 0, minmax_ii, (VALUE)result);
    }
    else {
	rb_block_call(obj, id_each, 0, 0, minmax_i, (VALUE)result);
    }
    if (result[0] != Qundef) {
        RARRAY(ary)-&gt;ptr[0] = result[0];
        RARRAY(ary)-&gt;ptr[1] = result[1];
    }
    return ary;
}

static VALUE
min_by_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    VALUE v;

    v = rb_yield(i);
    if (memo[0] == Qundef) {
	memo[0] = v;
	memo[1] = i;
    }
    else if (rb_cmpint(rb_funcall(v, id_cmp, 1, memo[0]), v, memo[0]) &lt; 0) {
	memo[0] = v;
	memo[1] = i;
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.min_by {| obj| block }   =&gt; obj
 *
 *  Returns the object in &lt;i&gt;enum&lt;/i&gt; that gives the minimum
 *  value from the given block.
 *
 *     a = %w(albatross dog horse)
 *     a.min_by {|x| x.length }   #=&gt; &quot;dog&quot;
 */

static VALUE
enum_min_by(obj)
    VALUE obj;
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo[1];
}

static VALUE
max_by_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    VALUE v;

    v = rb_yield(i);
    if (memo[0] == Qundef) {
	memo[0] = v;
	memo[1] = i;
    }
    else if (rb_cmpint(rb_funcall(v, id_cmp, 1, memo[0]), v, memo[0]) &gt; 0) {
	memo[0] = v;
	memo[1] = i;
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.max_by {| obj| block }   =&gt; obj
 *
 *  Returns the object in &lt;i&gt;enum&lt;/i&gt; that gives the maximum
 *  value from the given block.
 *
 *     a = %w(albatross dog horse)
 *     a.max_by {|x| x.length }   #=&gt; &quot;albatross&quot;
 */

static VALUE
enum_max_by(obj)
    VALUE obj;
{
    VALUE memo[2];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qnil;
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo[1];
}

static VALUE
minmax_by_i(i, memo)
    VALUE i;
    VALUE *memo;
{
    VALUE v;

    v = rb_yield(i);
    if (memo[0] == Qundef) {
	memo[0] = v;
	memo[1] = v;
	memo[2] = i;
	memo[3] = i;
    }
    else {
	if (rb_cmpint(rb_funcall(v, id_cmp, 1, memo[0]), v, memo[0]) &lt; 0) {
	    memo[0] = v;
	    memo[2] = i;
	}
	if (rb_cmpint(rb_funcall(v, id_cmp, 1, memo[1]), v, memo[1]) &gt; 0) {
	    memo[1] = v;
	    memo[3] = i;
	}
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.minmax_by {| obj| block }   =&gt; [min, max]
 *
 *  Returns two elements array array containing the objects in
 *  &lt;i&gt;enum&lt;/i&gt; that gives the minimum and maximum values respectively
 *  from the given block.
 *
 *     a = %w(albatross dog horse)
 *     a.minmax_by {|x| x.length }   #=&gt; [&quot;dog&quot;, &quot;albatross&quot;]
 */

static VALUE
enum_minmax_by(obj)
    VALUE obj;
{
    VALUE memo[4];

    RETURN_ENUMERATOR(obj, 0, 0);

    memo[0] = Qundef;
    memo[1] = Qundef;
    memo[2] = Qnil;
    memo[3] = Qnil;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, (VALUE)memo);
    return rb_assoc_new(memo[2], memo[3]);
}

static VALUE
member_i(item, memo)
    VALUE item;
    VALUE *memo;
{
    if (rb_equal(item, memo[0])) {
	memo[1] = Qtrue;
	rb_iter_break();
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.include?(obj)     =&gt; true or false
 *     enum.member?(obj)      =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if any member of &lt;i&gt;enum&lt;/i&gt; equals
 *  &lt;i&gt;obj&lt;/i&gt;. Equality is tested using &lt;code&gt;==&lt;/code&gt;.
 *
 *     IO.constants.include? &quot;SEEK_SET&quot;          #=&gt; true
 *     IO.constants.include? &quot;SEEK_NO_FURTHER&quot;   #=&gt; false
 *
 */

static VALUE
enum_member(obj, val)
    VALUE obj, val;
{
    VALUE memo[2];

    memo[0] = val;
    memo[1] = Qfalse;
    rb_iterate(rb_each, obj, member_i, (VALUE)memo);
    return memo[1];
}

static VALUE
each_with_index_i(val, memo)
    VALUE val;
    VALUE *memo;
{
    rb_yield_values(2, val, INT2FIX(*memo));
    ++*memo;
    return Qnil;
}

/*
 *  call-seq:
 *     enum.each_with_index {|obj, i| block }  -&gt; enum
 *
 *  Calls &lt;em&gt;block&lt;/em&gt; with two arguments, the item and its index, for
 *  each item in &lt;i&gt;enum&lt;/i&gt;.
 *
 *     hash = Hash.new
 *     %w(cat dog wombat).each_with_index {|item, index|
 *       hash[item] = index
 *     }
 *     hash   #=&gt; {&quot;cat&quot;=&gt;0, &quot;wombat&quot;=&gt;2, &quot;dog&quot;=&gt;1}
 *
 */

static VALUE
enum_each_with_index(obj)
    VALUE obj;
{
    VALUE memo;

    RETURN_ENUMERATOR(obj, 0, 0);

    memo = 0;
    rb_iterate(rb_each, obj, each_with_index_i, (VALUE)&amp;memo);
    return obj;
}

/*
 *  call-seq:
 *     enum.reverse_each {|item| block } 
 *  
 *  Traverses &lt;i&gt;enum&lt;/i&gt; in reverse order.
 */

static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long i;

    RETURN_ENUMERATOR(obj, argc, argv);

    ary = enum_to_a(argc, argv, obj);

    for (i = RARRAY_LEN(ary); --i &gt;= 0; ) {
	rb_yield(RARRAY_PTR(ary)[i]);
    }

    return obj;
}


static VALUE
zip_i(val, memo)
    VALUE val;
    VALUE *memo;
{
    VALUE result = memo[0];
    VALUE args = memo[1];
    int idx = memo[2]++;
    VALUE tmp;
    int i;

    tmp = rb_ary_new2(RARRAY(args)-&gt;len + 1);
    rb_ary_store(tmp, 0, val);
    for (i=0; i&lt;RARRAY(args)-&gt;len; i++) {
	rb_ary_push(tmp, rb_ary_entry(RARRAY(args)-&gt;ptr[i], idx));
    }
    if (rb_block_given_p()) {
	rb_yield(tmp);
    }
    else {
	rb_ary_push(result, tmp);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.zip(arg, ...)                   =&gt; array
 *     enum.zip(arg, ...) {|arr| block }    =&gt; nil
 *
 *  Converts any arguments to arrays, then merges elements of
 *  &lt;i&gt;enum&lt;/i&gt; with corresponding elements from each argument. This
 *  generates a sequence of &lt;code&gt;enum#size&lt;/code&gt; &lt;em&gt;n&lt;/em&gt;-element
 *  arrays, where &lt;em&gt;n&lt;/em&gt; is one more that the count of arguments. If
 *  the size of any argument is less than &lt;code&gt;enum#size&lt;/code&gt;,
 *  &lt;code&gt;nil&lt;/code&gt; values are supplied. If a block given, it is
 *  invoked for each output array, otherwise an array of arrays is
 *  returned.
 *
 *     a = [ 4, 5, 6 ]
 *     b = [ 7, 8, 9 ]
 *
 *     (1..3).zip(a, b)      #=&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]
 *     &quot;cat\ndog&quot;.zip([1])   #=&gt; [[&quot;cat\n&quot;, 1], [&quot;dog&quot;, nil]]
 *     (1..3).zip            #=&gt; [[1], [2], [3]]
 *
 */

static VALUE
enum_zip(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    int i;
    VALUE result;
    VALUE memo[3];

    for (i=0; i&lt;argc; i++) {
	argv[i] = rb_convert_type(argv[i], T_ARRAY, &quot;Array&quot;, &quot;to_a&quot;);
    }
    result = rb_block_given_p() ? Qnil : rb_ary_new();
    memo[0] = result;
    memo[1] = rb_ary_new4(argc, argv);
    memo[2] = 0;
    rb_iterate(rb_each, obj, zip_i, (VALUE)memo);

    return result;
}

static VALUE
take_i(i, arg)
    VALUE i;
    VALUE *arg;
{
    if (arg[1]-- == 0) rb_iter_break();
    rb_ary_push(arg[0], i);
    return Qnil;
}

/*
 *  call-seq:
 *     enum.take(n)               =&gt; array
 *
 *  Returns first n elements from &lt;i&gt;enum&lt;/i&gt;.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take(3)             # =&gt; [1, 2, 3]
 *
 */

static VALUE
enum_take(obj, n)
    VALUE obj;
    VALUE n;
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;attempt to take negative size&quot;);
    }

    args[1] = len;
    args[0] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)args);
    return args[0];
}


static VALUE
take_while_i(i, ary)
    VALUE i;
    VALUE *ary;
{
    if (!RTEST(rb_yield(i))) rb_iter_break();
    rb_ary_push(*ary, i);
    return Qnil;
}

/*
 *  call-seq:
 *     enum.take_while {|arr| block }   =&gt; array
 *
 *  Passes elements to the block until the block returns nil or false,
 *  then stops iterating and returns an array of all prior elements.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.take_while {|i| i &lt; 3 }   # =&gt; [1, 2]
 *
 */

static VALUE
enum_take_while(obj)
    VALUE obj;
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, (VALUE)&amp;ary);
    return ary;
}

static VALUE
drop_i(i, arg)
    VALUE i;
    VALUE *arg;
{
    if (arg[1] == 0) {
	rb_ary_push(arg[0], i);
    }
    else {
	arg[1]--;
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.drop(n)               =&gt; array
 *
 *  Drops first n elements from &lt;i&gt;enum&lt;/i&gt;, and returns rest elements
 *  in an array.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop(3)             # =&gt; [4, 5, 0]
 *
 */

static VALUE
enum_drop(obj, n)
    VALUE obj;
    VALUE n;
{
    VALUE args[2];
    long len = NUM2LONG(n);

    if (len &lt; 0) {
	rb_raise(rb_eArgError, &quot;attempt to drop negative size&quot;);
    }

    args[1] = len;
    args[0] = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)args);
    return args[0];
}


static VALUE
drop_while_i(i, args)
    VALUE i;
    VALUE *args;
{
    if (!args[1] &amp;&amp; !RTEST(rb_yield(i))) {
	args[1] = Qtrue;
    }
    if (args[1]) {
	rb_ary_push(args[0], i);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     enum.drop_while {|arr| block }   =&gt; array
 *
 *  Drops elements up to, but not including, the first element for
 *  which the block returns nil or false and returns an array
 *  containing the remaining elements.
 *
 *     a = [1, 2, 3, 4, 5, 0]
 *     a.drop_while {|i| i &lt; 3 }   # =&gt; [3, 4, 5, 0]
 *
 */

static VALUE
enum_drop_while(obj)
    VALUE obj;
{
    VALUE args[2];

    RETURN_ENUMERATOR(obj, 0, 0);
    args[0] = rb_ary_new();
    args[1] = Qfalse;
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)args);
    return args[0];
}

static VALUE
cycle_i(i, ary)
    VALUE i;
    VALUE ary;
{
    rb_ary_push(ary, i);
    rb_yield(i);
    return Qnil;
}

/*
 *  call-seq:
 *     enum.cycle {|obj| block }
 *     enum.cycle(n) {|obj| block }
 *
 *  Calls &lt;i&gt;block&lt;/i&gt; for each element of &lt;i&gt;enum&lt;/i&gt; repeatedly _n_
 *  times or forever if none or nil is given.  If a non-positive
 *  number is given or the collection is empty, does nothing.  Returns
 *  nil if the loop has finished without getting interrupted.
 *
 *  Enumerable#cycle saves elements in an internal array so changes
 *  to &lt;i&gt;enum&lt;/i&gt; after the first pass have no effect.
 *
 *     a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.
 *     a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c.
 *
 */

static VALUE
enum_cycle(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;nv);

    RETURN_ENUMERATOR(obj, argc, argv);
    if (NIL_P(nv)) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC(ary)-&gt;klass = 0;
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY(ary)-&gt;len;
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            rb_yield(RARRAY(ary)-&gt;ptr[i]);
        }
    }
    return Qnil;		/* not reached */
}

/*
 *  The &lt;code&gt;Enumerable&lt;/code&gt; mixin provides collection classes with
 *  several traversal and searching methods, and with the ability to
 *  sort. The class must provide a method &lt;code&gt;each&lt;/code&gt;, which
 *  yields successive members of the collection. If
 *  &lt;code&gt;Enumerable#max&lt;/code&gt;, &lt;code&gt;#min&lt;/code&gt;, or
 *  &lt;code&gt;#sort&lt;/code&gt; is used, the objects in the collection must also
 *  implement a meaningful &lt;code&gt;&lt;=&gt;&lt;/code&gt; operator, as these methods
 *  rely on an ordering between members of the collection.
 */

void
Init_Enumerable()
{
    rb_mEnumerable = rb_define_module(&quot;Enumerable&quot;);

    rb_define_method(rb_mEnumerable, &quot;to_a&quot;, enum_to_a, -1);
    rb_define_method(rb_mEnumerable, &quot;entries&quot;, enum_to_a, -1);

    rb_define_method(rb_mEnumerable, &quot;sort&quot;, enum_sort, 0);
    rb_define_method(rb_mEnumerable, &quot;sort_by&quot;, enum_sort_by, 0);
    rb_define_method(rb_mEnumerable, &quot;grep&quot;, enum_grep, 1);
    rb_define_method(rb_mEnumerable, &quot;count&quot;, enum_count, -1);
    rb_define_method(rb_mEnumerable, &quot;find&quot;, enum_find, -1);
    rb_define_method(rb_mEnumerable, &quot;detect&quot;, enum_find, -1);
    rb_define_method(rb_mEnumerable, &quot;find_index&quot;, enum_find_index, -1);
    rb_define_method(rb_mEnumerable, &quot;find_all&quot;, enum_find_all, 0);
    rb_define_method(rb_mEnumerable, &quot;select&quot;, enum_find_all, 0);
    rb_define_method(rb_mEnumerable, &quot;reject&quot;, enum_reject, 0);
    rb_define_method(rb_mEnumerable, &quot;collect&quot;, enum_collect, 0);
    rb_define_method(rb_mEnumerable, &quot;map&quot;, enum_collect, 0);
    rb_define_method(rb_mEnumerable, &quot;inject&quot;, enum_inject, -1);
    rb_define_method(rb_mEnumerable, &quot;reduce&quot;, enum_inject, -1);
    rb_define_method(rb_mEnumerable, &quot;partition&quot;, enum_partition, 0);
    rb_define_method(rb_mEnumerable, &quot;group_by&quot;, enum_group_by, 0);
    rb_define_method(rb_mEnumerable, &quot;first&quot;, enum_first, -1);
    rb_define_method(rb_mEnumerable, &quot;all?&quot;, enum_all, 0);
    rb_define_method(rb_mEnumerable, &quot;any?&quot;, enum_any, 0);
    rb_define_method(rb_mEnumerable, &quot;one?&quot;, enum_one, 0);
    rb_define_method(rb_mEnumerable, &quot;none?&quot;, enum_none, 0);
    rb_define_method(rb_mEnumerable, &quot;min&quot;, enum_min, 0);
    rb_define_method(rb_mEnumerable, &quot;max&quot;, enum_max, 0);
    rb_define_method(rb_mEnumerable, &quot;minmax&quot;, enum_minmax, 0);
    rb_define_method(rb_mEnumerable, &quot;min_by&quot;, enum_min_by, 0);
    rb_define_method(rb_mEnumerable, &quot;max_by&quot;, enum_max_by, 0);
    rb_define_method(rb_mEnumerable, &quot;minmax_by&quot;, enum_minmax_by, 0);
    rb_define_method(rb_mEnumerable, &quot;member?&quot;, enum_member, 1);
    rb_define_method(rb_mEnumerable, &quot;include?&quot;, enum_member, 1);
    rb_define_method(rb_mEnumerable, &quot;each_with_index&quot;, enum_each_with_index, 0);
    rb_define_method(rb_mEnumerable, &quot;enum_with_index&quot;, enum_each_with_index, 0);
    rb_define_method(rb_mEnumerable, &quot;reverse_each&quot;, enum_reverse_each, -1);
    rb_define_method(rb_mEnumerable, &quot;zip&quot;, enum_zip, -1);
    rb_define_method(rb_mEnumerable, &quot;take&quot;, enum_take, 1);
    rb_define_method(rb_mEnumerable, &quot;take_while&quot;, enum_take_while, 0);
    rb_define_method(rb_mEnumerable, &quot;drop&quot;, enum_drop, 1);
    rb_define_method(rb_mEnumerable, &quot;drop_while&quot;, enum_drop_while, 0);
    rb_define_method(rb_mEnumerable, &quot;cycle&quot;, enum_cycle, -1);

    id_eqq  = rb_intern(&quot;===&quot;);
    id_each = rb_intern(&quot;each&quot;);
    id_cmp  = rb_intern(&quot;&lt;=&gt;&quot;);
    id_size = rb_intern(&quot;size&quot;);
}

</pre>
    </div>