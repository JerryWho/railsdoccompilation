  <div id="fileHeader">
    <h1>variable.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/variable.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat May 31 06:44:49 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  variable.c -

  $Author: knu $
  $Date: 2008-05-31 20:44:49 +0900 (Sat, 31 May 2008) $
  created at: Tue Apr 19 23:55:15 JST 1994

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;env.h&quot;
#include &quot;node.h&quot;
#include &quot;st.h&quot;
#include &quot;util.h&quot;

st_table *rb_global_tbl;
st_table *rb_class_tbl;
static ID autoload, classpath, tmp_classpath;

void
Init_var_tables()
{
    rb_global_tbl = st_init_numtable();
    rb_class_tbl = st_init_numtable();
    autoload = rb_intern(&quot;__autoload__&quot;);
    classpath = rb_intern(&quot;__classpath__&quot;);
    tmp_classpath = rb_intern(&quot;__tmp_classpath__&quot;);
}

struct fc_result {
    ID name;
    VALUE klass;
    VALUE path;
    VALUE track;
    struct fc_result *prev;
};

static VALUE
fc_path(fc, name)
    struct fc_result *fc;
    ID name;
{
    VALUE path, tmp;

    path = rb_str_new2(rb_id2name(name));
    while (fc) {
	if (fc-&gt;track == rb_cObject) break;
	if (ROBJECT(fc-&gt;track)-&gt;iv_tbl &amp;&amp;
	    st_lookup(ROBJECT(fc-&gt;track)-&gt;iv_tbl, classpath, &amp;tmp)) {
	    tmp = rb_str_dup(tmp);
	    rb_str_cat2(tmp, &quot;::&quot;);
	    rb_str_append(tmp, path);

	    return tmp;
	}
	tmp = rb_str_new2(rb_id2name(fc-&gt;name));
	rb_str_cat2(tmp, &quot;::&quot;);
	rb_str_append(tmp, path);
	path = tmp;
	fc = fc-&gt;prev;
    }
    return path;
}

static int
fc_i(key, value, res)
    ID key;
    VALUE value;
    struct fc_result *res;
{
    if (!rb_is_const_id(key)) return ST_CONTINUE;

    if (value == res-&gt;klass) {
	res-&gt;path = fc_path(res, key);
	return ST_STOP;
    }
    switch (TYPE(value)) {
      case T_MODULE:
      case T_CLASS:
	if (!RCLASS(value)-&gt;iv_tbl) return ST_CONTINUE;
	else {
	    struct fc_result arg;
	    struct fc_result *list;

	    list = res;
	    while (list) {
		if (list-&gt;track == value) return ST_CONTINUE;
		list = list-&gt;prev;
	    }

	    arg.name = key;
	    arg.path = 0;
	    arg.klass = res-&gt;klass;
	    arg.track = value;
	    arg.prev = res;
	    st_foreach_safe(RCLASS(value)-&gt;iv_tbl, fc_i, (st_data_t)&amp;arg);
	    if (arg.path) {
		res-&gt;path = arg.path;
		return ST_STOP;
	    }
	}
	break;

      default:
	break;
    }
    return ST_CONTINUE;
}

static VALUE
find_class_path(klass)
    VALUE klass;
{
    struct fc_result arg;

    arg.name = 0;
    arg.path = 0;
    arg.klass = klass;
    arg.track = rb_cObject;
    arg.prev = 0;
    if (RCLASS(rb_cObject)-&gt;iv_tbl) {
	st_foreach_safe(RCLASS(rb_cObject)-&gt;iv_tbl, fc_i, (st_data_t)&amp;arg);
    }
    if (arg.path == 0) {
	st_foreach(rb_class_tbl, fc_i, (st_data_t)&amp;arg);
    }
    if (arg.path) {
	if (!ROBJECT(klass)-&gt;iv_tbl) {
	    ROBJECT(klass)-&gt;iv_tbl = st_init_numtable();
	}
	st_insert(ROBJECT(klass)-&gt;iv_tbl, classpath, arg.path);
	st_delete(RCLASS(klass)-&gt;iv_tbl, &amp;tmp_classpath, 0);
	return arg.path;
    }
    return Qnil;
}

static VALUE
classname(klass)
    VALUE klass;
{
    VALUE path = Qnil;

    if (!klass) klass = rb_cObject;
    if (ROBJECT(klass)-&gt;iv_tbl) {
	if (!st_lookup(ROBJECT(klass)-&gt;iv_tbl, classpath, &amp;path)) {
	    ID classid = rb_intern(&quot;__classid__&quot;);

	    if (!st_lookup(ROBJECT(klass)-&gt;iv_tbl, classid, &amp;path)) {
		return find_class_path(klass);
	    }
	    path = rb_str_new2(rb_id2name(SYM2ID(path)));
	    st_insert(ROBJECT(klass)-&gt;iv_tbl, classpath, path);
	    st_delete(RCLASS(klass)-&gt;iv_tbl, (st_data_t*)&amp;classid, 0);
	}
	if (TYPE(path) != T_STRING) {
	    rb_bug(&quot;class path is not set properly&quot;);
	}
	return path;
    }
    return find_class_path(klass);
}

/*
 *  call-seq:
 *     mod.name    =&gt; string
 *  
 *  Returns the name of the module &lt;i&gt;mod&lt;/i&gt;.
 */

VALUE
rb_mod_name(mod)
    VALUE mod;
{
    VALUE path = classname(mod);

    if (!NIL_P(path)) return rb_str_dup(path);
    return rb_str_new(0,0);
}

VALUE
rb_class_path(klass)
    VALUE klass;
{
    VALUE path = classname(klass);

    if (!NIL_P(path)) return path;
    if (RCLASS(klass)-&gt;iv_tbl &amp;&amp; st_lookup(RCLASS(klass)-&gt;iv_tbl,
					   tmp_classpath, &amp;path)) {
	return path;
    }
    else {
	const char *s = &quot;Class&quot;;
	size_t len;

	if (TYPE(klass) == T_MODULE) {
	    if (rb_obj_class(klass) == rb_cModule) {
		s = &quot;Module&quot;;
	    }
	    else {
		s = rb_class2name(RBASIC(klass)-&gt;klass);
	    }
	}
	len = 2 + strlen(s) + 3 + 2 * SIZEOF_LONG + 1;
	path = rb_str_new(0, len);
	snprintf(RSTRING(path)-&gt;ptr, len+1, &quot;#&lt;%s:0x%lx&gt;&quot;, s, klass);
	RSTRING(path)-&gt;len = strlen(RSTRING(path)-&gt;ptr);
	rb_ivar_set(klass, tmp_classpath, path);

	return path;
    }
}

void
rb_set_class_path(klass, under, name)
    VALUE klass, under;
    const char *name;
{
    VALUE str;

    if (under == rb_cObject) {
	str = rb_str_new2(name);
    }
    else {
	str = rb_str_dup(rb_class_path(under));
	rb_str_cat2(str, &quot;::&quot;);
	rb_str_cat2(str, name);
    }
    rb_ivar_set(klass, classpath, str);
}

VALUE
rb_path2class(path)
    const char *path;
{
    const char *pbeg, *p;
    ID id;
    VALUE c = rb_cObject;
    VALUE str = 0;

    if (path[0] == '#') {
	rb_raise(rb_eArgError, &quot;can't retrieve anonymous class %s&quot;, path);
    }
    pbeg = p = path;
    while (*p) {
	while (*p &amp;&amp; *p != ':') p++;
	if (str) {
	    RSTRING(str)-&gt;len = 0;
	    rb_str_cat(str, pbeg, p-pbeg);
	}
	else {
	    str = rb_str_new(pbeg, p-pbeg);
	}
	id = rb_intern(RSTRING(str)-&gt;ptr);
	if (p[0] == ':') {
	    if (p[1] != ':') goto undefined_class;
	    p += 2;
	    pbeg = p;
	}
	if (!rb_const_defined(c, id)) {
	  undefined_class:
	    rb_raise(rb_eArgError, &quot;undefined class/module %.*s&quot;, p-path, path);
	}
	c = rb_const_get_at(c, id);
	switch (TYPE(c)) {
	  case T_MODULE:
	  case T_CLASS:
	    break;
	  default:
	    rb_raise(rb_eTypeError, &quot;%s does not refer class/module&quot;, path);
	}
    }

    return c;
}

void
rb_name_class(klass, id)
    VALUE klass;
    ID id;
{
    rb_iv_set(klass, &quot;__classid__&quot;, ID2SYM(id));
}

VALUE
rb_class_name(klass)
    VALUE klass;
{
    return rb_class_path(rb_class_real(klass));
}

const char *
rb_class2name(klass)
    VALUE klass;
{
    return RSTRING(rb_class_name(klass))-&gt;ptr;
}

const char *
rb_obj_classname(obj)
    VALUE obj;
{
    return rb_class2name(CLASS_OF(obj));
}

struct trace_var {
    int removed;
    void (*func)();
    VALUE data;
    struct trace_var *next;
};

struct global_variable {
    int   counter;
    void *data;
    VALUE (*getter)();
    void  (*setter)();
    void  (*marker)();
    int block_trace;
    struct trace_var *trace;
};

struct global_entry {
    struct global_variable *var;
    ID id;
};

static VALUE undef_getter();
static void  undef_setter();
static void  undef_marker();

static VALUE val_getter();
static void  val_setter();
static void  val_marker();

static VALUE var_getter();
static void  var_setter();
static void  var_marker();

struct global_entry*
rb_global_entry(id)
    ID id;
{
    struct global_entry *entry;
    st_data_t data;

    if (!st_lookup(rb_global_tbl, id, &amp;data)) {
	struct global_variable *var;
	entry = ALLOC(struct global_entry);
	var = ALLOC(struct global_variable);
	entry-&gt;id = id;
	entry-&gt;var = var;
	var-&gt;counter = 1;
	var-&gt;data = 0;
	var-&gt;getter = undef_getter;
	var-&gt;setter = undef_setter;
	var-&gt;marker = undef_marker;

	var-&gt;block_trace = 0;
	var-&gt;trace = 0;
	st_add_direct(rb_global_tbl, id, (st_data_t)entry);
    }
    else {
	entry = (struct global_entry *)data;
    }
    return entry;
}

static VALUE
undef_getter(id)
    ID id;
{
    rb_warning(&quot;global variable `%s' not initialized&quot;, rb_id2name(id));

    return Qnil;
}

static void
undef_setter(val, id, data, var)
    VALUE val;
    ID id;
    void *data;
    struct global_variable *var;
{
    var-&gt;getter = val_getter;
    var-&gt;setter = val_setter;
    var-&gt;marker = val_marker;

    var-&gt;data = (void*)val;
}

static void
undef_marker()
{
}

static VALUE
val_getter(id, val)
    ID id;
    VALUE val;
{
    return val;
}

static void
val_setter(val, id, data, var)
    VALUE val;
    ID id;
    void *data;
    struct global_variable *var;
{
    var-&gt;data = (void*)val;
}

static void
val_marker(data)
    VALUE data;
{
    if (data) rb_gc_mark_maybe(data);
}

static VALUE
var_getter(id, var)
    ID id;
    VALUE *var;
{
    if (!var) return Qnil;
    return *var;
}

static void
var_setter(val, id, var)
    VALUE val;
    ID id;
    VALUE *var;
{
    *var = val;
}

static void
var_marker(var)
    VALUE *var;
{
    if (var) rb_gc_mark_maybe(*var);
}

static void
readonly_setter(val, id, var)
    VALUE val;
    ID id;
    void *var;
{
    rb_name_error(id, &quot;%s is a read-only variable&quot;, rb_id2name(id));
}

static int
mark_global_entry(key, entry)
    ID key;
    struct global_entry *entry;
{
    struct trace_var *trace;
    struct global_variable *var = entry-&gt;var;

    (*var-&gt;marker)(var-&gt;data);
    trace = var-&gt;trace;
    while (trace) {
	if (trace-&gt;data) rb_gc_mark_maybe(trace-&gt;data);
	trace = trace-&gt;next;
    }
    return ST_CONTINUE;
}

void
rb_gc_mark_global_tbl()
{
    if (rb_global_tbl) {
	st_foreach(rb_global_tbl, mark_global_entry, 0);
    }
}

static ID
global_id(name)
    const char *name;
{
    ID id;

    if (name[0] == '$') id = rb_intern(name);
    else {
	char *buf = ALLOCA_N(char, strlen(name)+2);
	buf[0] = '$';
	strcpy(buf+1, name);
	id = rb_intern(buf);
    }
    return id;
}

void
rb_define_hooked_variable(name, var, getter, setter)
    const char  *name;
    VALUE *var;
    VALUE (*getter)();
    void  (*setter)();
{
    struct global_variable *gvar;
    ID id = global_id(name);

    gvar = rb_global_entry(id)-&gt;var;
    gvar-&gt;data = (void*)var;
    gvar-&gt;getter = getter?getter:var_getter;
    gvar-&gt;setter = setter?setter:var_setter;
    gvar-&gt;marker = var_marker;
}

void
rb_define_variable(name, var)
    const char  *name;
    VALUE *var;
{
    rb_define_hooked_variable(name, var, 0, 0);
}

void
rb_define_readonly_variable(name, var)
    const char  *name;
    VALUE *var;
{
    rb_define_hooked_variable(name, var, 0, readonly_setter);
}

void
rb_define_virtual_variable(name, getter, setter)
    const char  *name;
    VALUE (*getter)();
    void  (*setter)();
{
    if (!getter) getter = val_getter;
    if (!setter) setter = readonly_setter;
    rb_define_hooked_variable(name, 0, getter, setter);
}

static void
rb_trace_eval(cmd, val)
    VALUE cmd, val;
{
    rb_eval_cmd(cmd, rb_ary_new3(1, val), 0);
}

/*
 *  call-seq:
 *     trace_var(symbol, cmd )             =&gt; nil
 *     trace_var(symbol) {|val| block }    =&gt; nil
 *  
 *  Controls tracing of assignments to global variables. The parameter
 *  +symbol_ identifies the variable (as either a string name or a
 *  symbol identifier). _cmd_ (which may be a string or a
 *  +Proc+ object) or block is executed whenever the variable
 *  is assigned. The block or +Proc+ object receives the
 *  variable's new value as a parameter. Also see
 *  &lt;code&gt;Kernel::untrace_var&lt;/code&gt;.
 *     
 *     trace_var :$_, proc {|v| puts &quot;$_ is now '#{v}'&quot; }
 *     $_ = &quot;hello&quot;
 *     $_ = ' there'
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     $_ is now 'hello'
 *     $_ is now ' there'
 */

VALUE
rb_f_trace_var(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE var, cmd;
    struct global_entry *entry;
    struct trace_var *trace;

    rb_secure(4);
    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;var, &amp;cmd) == 1) {
	cmd = rb_block_proc();
    }
    if (NIL_P(cmd)) {
	return rb_f_untrace_var(argc, argv);
    }
    entry = rb_global_entry(rb_to_id(var));
    if (OBJ_TAINTED(cmd)) {
	rb_raise(rb_eSecurityError, &quot;Insecure: tainted variable trace&quot;);
    }
    trace = ALLOC(struct trace_var);
    trace-&gt;next = entry-&gt;var-&gt;trace;
    trace-&gt;func = rb_trace_eval;
    trace-&gt;data = cmd;
    trace-&gt;removed = 0;
    entry-&gt;var-&gt;trace = trace;

    return Qnil;
}

static void
remove_trace(var)
    struct global_variable *var;
{
    struct trace_var *trace = var-&gt;trace;
    struct trace_var t;
    struct trace_var *next;

    t.next = trace;
    trace = &amp;t;
    while (trace-&gt;next) {
	next = trace-&gt;next;
	if (next-&gt;removed) {
	    trace-&gt;next = next-&gt;next;
	    free(next);
	}
	else {
	    trace = next;
	}
    }
    var-&gt;trace = t.next;
}

/*
 *  call-seq:
 *     untrace_var(symbol [, cmd] )   =&gt; array or nil
 *  
 *  Removes tracing for the specified command on the given global
 *  variable and returns +nil+. If no command is specified,
 *  removes all tracing for that variable and returns an array
 *  containing the commands actually removed.
 */

VALUE
rb_f_untrace_var(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE var, cmd;
    ID id;
    struct global_entry *entry;
    struct trace_var *trace;
    st_data_t data;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;var, &amp;cmd);
    id = rb_to_id(var);
    if (!st_lookup(rb_global_tbl, id, &amp;data)) {
	rb_name_error(id, &quot;undefined global variable %s&quot;, rb_id2name(id));
    }

    trace = (entry = (struct global_entry *)data)-&gt;var-&gt;trace;
    if (NIL_P(cmd)) {
	VALUE ary = rb_ary_new();

	while (trace) {
	    struct trace_var *next = trace-&gt;next;
	    rb_ary_push(ary, (VALUE)trace-&gt;data);
	    trace-&gt;removed = 1;
	    trace = next;
	}

	if (!entry-&gt;var-&gt;block_trace) remove_trace(entry-&gt;var);
	return ary;
    }
    else {
	while (trace) {
	    if (trace-&gt;data == cmd) {
		trace-&gt;removed = 1;
		if (!entry-&gt;var-&gt;block_trace) remove_trace(entry-&gt;var);
		return rb_ary_new3(1, cmd);
	    }
	    trace = trace-&gt;next;
	}
    }
    return Qnil;
}

VALUE
rb_gvar_get(entry)
    struct global_entry *entry;
{
    struct global_variable *var = entry-&gt;var;
    return (*var-&gt;getter)(entry-&gt;id, var-&gt;data, var);
}

struct trace_data {
    struct trace_var *trace;
    VALUE val;
};

static VALUE
trace_ev(data)
    struct trace_data *data;
{
    struct trace_var *trace = data-&gt;trace;

    while (trace) {
	(*trace-&gt;func)(trace-&gt;data, data-&gt;val);
	trace = trace-&gt;next;
    }
    return Qnil;		/* not reached */
}

static VALUE
trace_en(var)
    struct global_variable *var;
{
    var-&gt;block_trace = 0;
    remove_trace(var);
    return Qnil;		/* not reached */
}

VALUE
rb_gvar_set(entry, val)
    struct global_entry *entry;
    VALUE val;
{
    struct trace_data trace;
    struct global_variable *var = entry-&gt;var;

    if (rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't change global variable value&quot;);
    (*var-&gt;setter)(val, entry-&gt;id, var-&gt;data, var);

    if (var-&gt;trace &amp;&amp; !var-&gt;block_trace) {
	var-&gt;block_trace = 1;
	trace.trace = var-&gt;trace;
	trace.val = val;
	rb_ensure(trace_ev, (VALUE)&amp;trace, trace_en, (VALUE)var);
    }
    return val;
}

VALUE
rb_gv_set(name, val)
    const char *name;
    VALUE val;
{
    struct global_entry *entry;

    entry = rb_global_entry(global_id(name));
    return rb_gvar_set(entry, val);
}

VALUE
rb_gv_get(name)
    const char *name;
{
    struct global_entry *entry;

    entry = rb_global_entry(global_id(name));
    return rb_gvar_get(entry);
}

VALUE
rb_gvar_defined(entry)
    struct global_entry *entry;
{
    if (entry-&gt;var-&gt;getter == undef_getter) return Qfalse;
    return Qtrue;
}

static int
gvar_i(key, entry, ary)
    ID key;
    struct global_entry *entry;
    VALUE ary;
{
    rb_ary_push(ary, rb_str_new2(rb_id2name(key)));
    return ST_CONTINUE;
}

/*
 *  call-seq:
 *     global_variables    =&gt; array
 *  
 *  Returns an array of the names of global variables.
 *     
 *     global_variables.grep /std/   #=&gt; [&quot;$stderr&quot;, &quot;$stdout&quot;, &quot;$stdin&quot;]
 */

VALUE
rb_f_global_variables()
{
    VALUE ary = rb_ary_new();
    char buf[4];
    const char *s = &quot;&amp;`'+123456789&quot;;

    st_foreach(rb_global_tbl, gvar_i, ary);
    if (!NIL_P(rb_backref_get())) {
	while (*s) {
	    sprintf(buf, &quot;$%c&quot;, *s++);
	    rb_ary_push(ary, rb_str_new2(buf));
	}
    }
    return ary;
}

void
rb_alias_variable(name1, name2)
    ID name1;
    ID name2;
{
    struct global_entry *entry1, *entry2;
    st_data_t data1;

    if (rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't alias global variable&quot;);

    entry2 = rb_global_entry(name2);
    if (!st_lookup(rb_global_tbl, name1, &amp;data1)) {
	entry1 = ALLOC(struct global_entry);
	entry1-&gt;id = name1;
	st_add_direct(rb_global_tbl, name1, (st_data_t)entry1);
    }
    else if ((entry1 = (struct global_entry *)data1)-&gt;var != entry2-&gt;var) {
	struct global_variable *var = entry1-&gt;var;
	if (var-&gt;block_trace) {
	    rb_raise(rb_eRuntimeError, &quot;can't alias in tracer&quot;);
	}
	var-&gt;counter--;
	if (var-&gt;counter == 0) {
	    struct trace_var *trace = var-&gt;trace;
	    while (trace) {
		struct trace_var *next = trace-&gt;next;
		free(trace);
		trace = next;
	    }
	    free(var);
	}
    }
    else {
	return;
    }
    entry2-&gt;var-&gt;counter++;
    entry1-&gt;var = entry2-&gt;var;
}

static int special_generic_ivar = 0;
static st_table *generic_iv_tbl;

st_table*
rb_generic_ivar_table(obj)
    VALUE obj;
{
    st_data_t tbl;

    if (!FL_TEST(obj, FL_EXIVAR)) return 0;
    if (!generic_iv_tbl) return 0;
    if (!st_lookup(generic_iv_tbl, obj, &amp;tbl)) return 0;
    return (st_table *)tbl;
}

static VALUE
generic_ivar_get(obj, id, warn)
    VALUE obj;
    ID id;
    int warn;
{
    st_data_t tbl;
    VALUE val;

    if (generic_iv_tbl) {
	if (st_lookup(generic_iv_tbl, obj, &amp;tbl)) {
	    if (st_lookup((st_table *)tbl, id, &amp;val)) {
		return val;
	    }
	}
    }
    if (warn) {
	rb_warning(&quot;instance variable %s not initialized&quot;, rb_id2name(id));
    }
    return Qnil;
}

static void
generic_ivar_set(obj, id, val)
    VALUE obj;
    ID id;
    VALUE val;
{
    st_table *tbl;
    st_data_t data;

    if (rb_special_const_p(obj)) {
	special_generic_ivar = 1;
    }
    if (!generic_iv_tbl) {
	generic_iv_tbl = st_init_numtable();
    }

    if (!st_lookup(generic_iv_tbl, obj, &amp;data)) {
	FL_SET(obj, FL_EXIVAR);
	tbl = st_init_numtable();
	st_add_direct(generic_iv_tbl, obj, (st_data_t)tbl);
	st_add_direct(tbl, id, val);
	return;
    }
    st_insert((st_table *)data, id, val);
}

static VALUE
generic_ivar_defined(obj, id)
    VALUE obj;
    ID id;
{
    st_table *tbl;
    st_data_t data;
    VALUE val;

    if (!generic_iv_tbl) return Qfalse;
    if (!st_lookup(generic_iv_tbl, obj, &amp;data)) return Qfalse;
    tbl = (st_table *)data;
    if (st_lookup(tbl, id, &amp;val)) {
	return Qtrue;
    }
    return Qfalse;
}

static int
generic_ivar_remove(obj, id, valp)
    VALUE obj;
    ID id;
    VALUE *valp;
{
    st_table *tbl;
    st_data_t data;
    int status;

    if (!generic_iv_tbl) return 0;
    if (!st_lookup(generic_iv_tbl, obj, &amp;data)) return 0;
    tbl = (st_table *)data;
    status = st_delete(tbl, &amp;id, valp);
    if (tbl-&gt;num_entries == 0) {
	st_delete(generic_iv_tbl, &amp;obj, &amp;data);
	st_free_table((st_table *)data);
    }
    return status;
}

void
rb_mark_generic_ivar(obj)
    VALUE obj;
{
    st_data_t tbl;

    if (!generic_iv_tbl) return;
    if (st_lookup(generic_iv_tbl, obj, &amp;tbl)) {
	rb_mark_tbl((st_table *)tbl);
    }
}

static int
givar_mark_i(key, value)
    ID key;
    VALUE value;
{
    rb_gc_mark(value);
    return ST_CONTINUE;
}

static int
givar_i(obj, tbl)
    VALUE obj;
    st_table *tbl;
{
    if (rb_special_const_p(obj)) {
	st_foreach(tbl, givar_mark_i, 0);
    }
    return ST_CONTINUE;
}

void
rb_mark_generic_ivar_tbl()
{
    if (!generic_iv_tbl) return;
    if (special_generic_ivar == 0) return;
    st_foreach_safe(generic_iv_tbl, givar_i, 0);
}

void
rb_free_generic_ivar(obj)
    VALUE obj;
{
    st_data_t tbl;

    if (!generic_iv_tbl) return;
    if (st_delete(generic_iv_tbl, &amp;obj, &amp;tbl))
	st_free_table((st_table *)tbl);
}

void
rb_copy_generic_ivar(clone, obj)
    VALUE clone, obj;
{
    st_data_t data;

    if (!generic_iv_tbl) return;
    if (!FL_TEST(obj, FL_EXIVAR)) return;
    if (st_lookup(generic_iv_tbl, obj, &amp;data)) {
	st_table *tbl = (st_table *)data;

	if (st_lookup(generic_iv_tbl, clone, &amp;data)) {
	    st_free_table((st_table *)data);
	    st_insert(generic_iv_tbl, clone, (st_data_t)st_copy(tbl));
	}
	else {
	    st_add_direct(generic_iv_tbl, clone, (st_data_t)st_copy(tbl));
	}
    }
}

static VALUE
ivar_get(obj, id, warn)
    VALUE obj;
    ID id;
    int warn;
{
    VALUE val;

    switch (TYPE(obj)) {
      case T_OBJECT:
      case T_CLASS:
      case T_MODULE:
	if (ROBJECT(obj)-&gt;iv_tbl &amp;&amp; st_lookup(ROBJECT(obj)-&gt;iv_tbl, id, &amp;val))
	    return val;
	break;
      default:
	if (FL_TEST(obj, FL_EXIVAR) || rb_special_const_p(obj))
	    return generic_ivar_get(obj, id, warn);
	break;
    }
    if (warn) {
	rb_warning(&quot;instance variable %s not initialized&quot;, rb_id2name(id));
    }
    return Qnil;
}

VALUE
rb_ivar_get(obj, id)
    VALUE obj;
    ID id;
{
    return ivar_get(obj, id, Qtrue);
}

VALUE
rb_attr_get(obj, id)
    VALUE obj;
    ID id;
{
    return ivar_get(obj, id, Qfalse);
}

VALUE
rb_ivar_set(obj, id, val)
    VALUE obj;
    ID id;
    VALUE val;
{
    if (!OBJ_TAINTED(obj) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't modify instance variable&quot;);
    if (OBJ_FROZEN(obj)) rb_error_frozen(&quot;object&quot;);
    switch (TYPE(obj)) {
      case T_OBJECT:
      case T_CLASS:
      case T_MODULE:
	if (!ROBJECT(obj)-&gt;iv_tbl) ROBJECT(obj)-&gt;iv_tbl = st_init_numtable();
	st_insert(ROBJECT(obj)-&gt;iv_tbl, id, val);
	break;
      default:
	generic_ivar_set(obj, id, val);
	break;
    }
    return val;
}

VALUE
rb_ivar_defined(obj, id)
    VALUE obj;
    ID id;
{
    switch (TYPE(obj)) {
      case T_OBJECT:
      case T_CLASS:
      case T_MODULE:
	if (ROBJECT(obj)-&gt;iv_tbl &amp;&amp; st_lookup(ROBJECT(obj)-&gt;iv_tbl, id, 0))
	    return Qtrue;
	break;
      default:
	if (FL_TEST(obj, FL_EXIVAR) || rb_special_const_p(obj))
	    return generic_ivar_defined(obj, id);
	break;
    }
    return Qfalse;
}

static int
ivar_i(key, entry, ary)
    ID key;
    struct global_entry *entry;
    VALUE ary;
{
    if (rb_is_instance_id(key)) {
	rb_ary_push(ary, rb_str_new2(rb_id2name(key)));
    }
    return ST_CONTINUE;
}

/*
 *  call-seq:
 *     obj.instance_variables    =&gt; array
 *  
 *  Returns an array of instance variable names for the receiver. Note
 *  that simply defining an accessor does not create the corresponding
 *  instance variable.
 *     
 *     class Fred
 *       attr_accessor :a1
 *       def initialize
 *         @iv = 3
 *       end
 *     end
 *     Fred.new.instance_variables   #=&gt; [&quot;@iv&quot;]
 */

VALUE
rb_obj_instance_variables(obj)
    VALUE obj;
{
    VALUE ary;

    ary = rb_ary_new();
    switch (TYPE(obj)) {
      case T_OBJECT:
      case T_CLASS:
      case T_MODULE:
	if (ROBJECT(obj)-&gt;iv_tbl) {
	    st_foreach_safe(ROBJECT(obj)-&gt;iv_tbl, ivar_i, ary);
	}
	break;
      default:
	if (!generic_iv_tbl) break;
	if (FL_TEST(obj, FL_EXIVAR) || rb_special_const_p(obj)) {
	    st_data_t tbl;

	    if (st_lookup(generic_iv_tbl, obj, &amp;tbl)) {
		st_foreach_safe((st_table *)tbl, ivar_i, ary);
	    }
	}
	break;
    }
    return ary;
}

/*
 *  call-seq:
 *     obj.remove_instance_variable(symbol)    =&gt; obj
 *  
 *  Removes the named instance variable from &lt;i&gt;obj&lt;/i&gt;, returning that
 *  variable's value.
 *     
 *     class Dummy
 *       attr_reader :var
 *       def initialize
 *         @var = 99
 *       end
 *       def remove
 *         remove_instance_variable(:@var)
 *       end
 *     end
 *     d = Dummy.new
 *     d.var      #=&gt; 99
 *     d.remove   #=&gt; 99
 *     d.var      #=&gt; nil
 */

VALUE
rb_obj_remove_instance_variable(obj, name)
    VALUE obj, name;
{
    VALUE val = Qnil;
    ID id = rb_to_id(name);

    if (!OBJ_TAINTED(obj) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't modify instance variable&quot;);
    if (OBJ_FROZEN(obj)) rb_error_frozen(&quot;object&quot;);
    if (!rb_is_instance_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as an instance variable name&quot;, rb_id2name(id));
    }

    switch (TYPE(obj)) {
      case T_OBJECT:
      case T_CLASS:
      case T_MODULE:
	if (ROBJECT(obj)-&gt;iv_tbl &amp;&amp; st_delete(ROBJECT(obj)-&gt;iv_tbl, (st_data_t*)&amp;id, &amp;val)) {
	    return val;
	}
	break;
      default:
	if (FL_TEST(obj, FL_EXIVAR) || rb_special_const_p(obj)) {
	    if (generic_ivar_remove(obj, id, &amp;val)) {
		return val;
	    }
	}
	break;
    }
    rb_name_error(id, &quot;instance variable %s not defined&quot;, rb_id2name(id));
    return Qnil;		/* not reached */
}

NORETURN(static void uninitialized_constant _((VALUE, ID)));
static void
uninitialized_constant(klass, id)
    VALUE klass;
    ID id;
{
    if (klass &amp;&amp; klass != rb_cObject)
	rb_name_error(id, &quot;uninitialized constant %s::%s&quot;,
		      rb_class2name(klass),
		      rb_id2name(id));
    else {
	rb_name_error(id, &quot;uninitialized constant %s&quot;, rb_id2name(id));
    }
}

static VALUE
const_missing(klass, id)
    VALUE klass;
    ID id;
{
    return rb_funcall(klass, rb_intern(&quot;const_missing&quot;), 1, ID2SYM(id));
}


/*
 * call-seq:
 *    mod.const_missing(sym)    =&gt; obj
 *
 *  Invoked when a reference is made to an undefined constant in
 *  &lt;i&gt;mod&lt;/i&gt;. It is passed a symbol for the undefined constant, and
 *  returns a value to be used for that constant. The
 *  following code is a (very bad) example: if reference is made to
 *  an undefined constant, it attempts to load a file whose name is
 *  the lowercase version of the constant (thus class &lt;code&gt;Fred&lt;/code&gt; is
 *  assumed to be in file &lt;code&gt;fred.rb&lt;/code&gt;). If found, it returns the
 *  value of the loaded class. It therefore implements a perverse
 *  kind of autoload facility.
 *  
 *    def Object.const_missing(name)
 *      @looked_for ||= {}
 *      str_name = name.to_s
 *      raise &quot;Class not found: #{name}&quot; if @looked_for[str_name]
 *      @looked_for[str_name] = 1
 *      file = str_name.downcase
 *      require file
 *      klass = const_get(name)
 *      return klass if klass
 *      raise &quot;Class not found: #{name}&quot;
 *    end
 *  
 */

VALUE
rb_mod_const_missing(klass, name)
    VALUE klass, name;
{
    ruby_frame = ruby_frame-&gt;prev; /* pop frame for &quot;const_missing&quot; */
    uninitialized_constant(klass, rb_to_id(name));
    return Qnil;		/* not reached */
}

static struct st_table *
check_autoload_table(av)
    VALUE av;
{
    Check_Type(av, T_DATA);
    if (RDATA(av)-&gt;dmark != (RUBY_DATA_FUNC)rb_mark_tbl ||
	RDATA(av)-&gt;dfree != (RUBY_DATA_FUNC)st_free_table) {
	rb_raise(rb_eTypeError, &quot;wrong autoload table: %s&quot;, RSTRING(rb_inspect(av))-&gt;ptr);
    }
    return (struct st_table *)DATA_PTR(av);
}

void
rb_autoload(mod, id, file)
    VALUE mod;
    ID id;
    const char *file;
{
    VALUE av, fn;
    struct st_table *tbl;

    if (!rb_is_const_id(id)) {
	rb_raise(rb_eNameError, &quot;autoload must be constant name&quot;, rb_id2name(id));
    }
    if (!file || !*file) {
	rb_raise(rb_eArgError, &quot;empty file name&quot;);
    }

    if ((tbl = RCLASS(mod)-&gt;iv_tbl) &amp;&amp; st_lookup(tbl, id, &amp;av) &amp;&amp; av != Qundef)
	return;

    rb_const_set(mod, id, Qundef);
    tbl = RCLASS(mod)-&gt;iv_tbl;
    if (st_lookup(tbl, autoload, &amp;av)) {
	tbl = check_autoload_table(av);
    }
    else {
	av = Data_Wrap_Struct(0 , rb_mark_tbl, st_free_table, 0);
	st_add_direct(tbl, autoload, av);
	DATA_PTR(av) = tbl = st_init_numtable();
    }
    fn = rb_str_new2(file);
    FL_UNSET(fn, FL_TAINT);
    OBJ_FREEZE(fn);
    st_insert(tbl, id, (st_data_t)rb_node_newnode(NODE_MEMO, fn, ruby_safe_level, 0));
}

static NODE*
autoload_delete(mod, id)
    VALUE mod;
    ID id;
{
    VALUE val;
    st_data_t load = 0;

    st_delete(RCLASS(mod)-&gt;iv_tbl, (st_data_t*)&amp;id, 0);
    if (st_lookup(RCLASS(mod)-&gt;iv_tbl, autoload, &amp;val)) {
	struct st_table *tbl = check_autoload_table(val);

	st_delete(tbl, (st_data_t*)&amp;id, &amp;load);

	if (tbl-&gt;num_entries == 0) {
	    DATA_PTR(val) = 0;
	    st_free_table(tbl);
	    id = autoload;
	    if (st_delete(RCLASS(mod)-&gt;iv_tbl, (st_data_t*)&amp;id, &amp;val)) {
		rb_gc_force_recycle(val);
	    }
	}
    }

    return (NODE *)load;
}

VALUE
rb_autoload_load(klass, id)
    VALUE klass;
    ID id;
{
    VALUE file;
    NODE *load = autoload_delete(klass, id);

    if (!load || !(file = load-&gt;nd_lit) || rb_provided(RSTRING(file)-&gt;ptr)) {
	return Qfalse;
    }
    return rb_require_safe(file, load-&gt;nd_nth);
}

static VALUE
autoload_file(mod, id)
    VALUE mod;
    ID id;
{
    VALUE val, file;
    struct st_table *tbl;
    st_data_t load;

    if (!st_lookup(RCLASS(mod)-&gt;iv_tbl, autoload, &amp;val) ||
	!(tbl = check_autoload_table(val)) || !st_lookup(tbl, id, &amp;load)) {
	return Qnil;
    }
    file = ((NODE *)load)-&gt;nd_lit;
    Check_Type(file, T_STRING);
    if (!RSTRING(file)-&gt;ptr || !*RSTRING(file)-&gt;ptr) {
	rb_raise(rb_eArgError, &quot;empty file name&quot;);
    }
    if (!rb_provided(RSTRING(file)-&gt;ptr)) {
	return file;
    }

    /* already loaded but not defined */
    st_delete(tbl, (st_data_t*)&amp;id, 0);
    if (!tbl-&gt;num_entries) {
	DATA_PTR(val) = 0;
	st_free_table(tbl);
	id = autoload;
	if (st_delete(RCLASS(mod)-&gt;iv_tbl, (st_data_t*)&amp;id, &amp;val)) {
	    rb_gc_force_recycle(val);
	}
    }
    return Qnil;
}

VALUE
rb_autoload_p(mod, id)
    VALUE mod;
    ID id;
{
    struct st_table *tbl = RCLASS(mod)-&gt;iv_tbl;
    VALUE val;

    if (!tbl || !st_lookup(tbl, id, &amp;val) || val != Qundef) {
	return Qnil;
    }
    return autoload_file(mod, id);
}

static VALUE
rb_const_get_0(klass, id, exclude, recurse)
    VALUE klass;
    ID id;
    int exclude, recurse;
{
    VALUE value, tmp;
    int mod_retry = 0;

    tmp = klass;
  retry:
    while (tmp) {
	while (RCLASS(tmp)-&gt;iv_tbl &amp;&amp; st_lookup(RCLASS(tmp)-&gt;iv_tbl,id,&amp;value)) {
	    if (value == Qundef) {
		if (!RTEST(rb_autoload_load(tmp, id))) break;
		continue;
	    }
	    if (exclude &amp;&amp; tmp == rb_cObject &amp;&amp; klass != rb_cObject) {
		rb_warn(&quot;toplevel constant %s referenced by %s::%s&quot;,
			rb_id2name(id), rb_class2name(klass), rb_id2name(id));
	    }
	    return value;
	}
	if (!recurse &amp;&amp; klass != rb_cObject) break;
	tmp = RCLASS(tmp)-&gt;super;
    }
    if (!exclude &amp;&amp; !mod_retry &amp;&amp; BUILTIN_TYPE(klass) == T_MODULE) {
	mod_retry = 1;
	tmp = rb_cObject;
	goto retry;
    }

    return const_missing(klass, id);
}

VALUE
rb_const_get_from(klass, id)
    VALUE klass;
    ID id;
{
    return rb_const_get_0(klass, id, Qtrue, Qtrue);
}

VALUE
rb_const_get(klass, id)
    VALUE klass;
    ID id;
{
    return rb_const_get_0(klass, id, Qfalse, Qtrue);
}

VALUE
rb_const_get_at(klass, id)
    VALUE klass;
    ID id;
{
    return rb_const_get_0(klass, id, Qtrue, Qfalse);
}

/*
 *  call-seq:
 *     remove_const(sym)   =&gt; obj
 *  
 *  Removes the definition of the given constant, returning that
 *  constant's value. Predefined classes and singleton objects (such as
 *  &lt;i&gt;true&lt;/i&gt;) cannot be removed.
 */

VALUE
rb_mod_remove_const(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);
    VALUE val;

    if (!rb_is_const_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as a constant name&quot;, rb_id2name(id));
    }
    if (!OBJ_TAINTED(mod) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't remove constant&quot;);
    if (OBJ_FROZEN(mod)) rb_error_frozen(&quot;class/module&quot;);

    if (RCLASS(mod)-&gt;iv_tbl &amp;&amp; st_delete(ROBJECT(mod)-&gt;iv_tbl, (st_data_t*)&amp;id, &amp;val)) {
	if (val == Qundef) {
	    autoload_delete(mod, id);
	    val = Qnil;
	}
	return val;
    }
    if (rb_const_defined_at(mod, id)) {
	rb_name_error(id, &quot;cannot remove %s::%s&quot;,
		 rb_class2name(mod), rb_id2name(id));
    }
    rb_name_error(id, &quot;constant %s::%s not defined&quot;,
		  rb_class2name(mod), rb_id2name(id));
    return Qnil;		/* not reached */
}

static int
sv_i(key, value, tbl)
    ID key;
    VALUE value;
    st_table *tbl;
{
    if (rb_is_const_id(key)) {
	if (!st_lookup(tbl, key, 0)) {
	    st_insert(tbl, key, key);
	}
    }
    return ST_CONTINUE;
}

void*
rb_mod_const_at(mod, data)
    VALUE mod;
    void *data;
{
    st_table *tbl = data;
    if (!tbl) {
	tbl = st_init_numtable();
    }
    if (RCLASS(mod)-&gt;iv_tbl) {
	st_foreach_safe(RCLASS(mod)-&gt;iv_tbl, sv_i, (st_data_t)tbl);
    }
    return tbl;
}

void*
rb_mod_const_of(mod, data)
    VALUE mod;
    void *data;
{
    VALUE tmp = mod;
    for (;;) {
	data = rb_mod_const_at(tmp, data);
	tmp = RCLASS(tmp)-&gt;super;
	if (!tmp) break;
	if (tmp == rb_cObject &amp;&amp; mod != rb_cObject) break;
    }
    return data;
}

static int
list_i(key, value, ary)
    ID key, value;
    VALUE ary;
{
    rb_ary_push(ary, rb_str_new2(rb_id2name(key)));
    return ST_CONTINUE;
}

VALUE
rb_const_list(data)
    void *data;
{
    st_table *tbl = data;
    VALUE ary;

    if (!tbl) return rb_ary_new2(0);
    ary = rb_ary_new2(tbl-&gt;num_entries);
    st_foreach(tbl, list_i, ary);
    st_free_table(tbl);

    return ary;
}

/*
 *  call-seq:
 *     mod.constants    =&gt; array
 *  
 *  Returns an array of the names of the constants accessible in
 *  &lt;i&gt;mod&lt;/i&gt;. This includes the names of constants in any included
 *  modules (example at start of section).
 */

VALUE
rb_mod_constants(mod)
    VALUE mod;
{
    return rb_const_list(rb_mod_const_of(mod, 0));
}

static int
rb_const_defined_0(klass, id, exclude, recurse)
    VALUE klass;
    ID id;
    int exclude, recurse;
{
    VALUE value, tmp;
    int mod_retry = 0;

    tmp = klass;
  retry:
    while (tmp) {
	if (RCLASS(tmp)-&gt;iv_tbl &amp;&amp; st_lookup(RCLASS(tmp)-&gt;iv_tbl, id, &amp;value)) {
	    if (value == Qundef &amp;&amp; NIL_P(autoload_file(klass, id)))
		return Qfalse;
	    return Qtrue;
	}
	if (!recurse &amp;&amp; klass != rb_cObject) break;
	tmp = RCLASS(tmp)-&gt;super;
    }
    if (!exclude &amp;&amp; !mod_retry &amp;&amp; BUILTIN_TYPE(klass) == T_MODULE) {
	mod_retry = 1;
	tmp = rb_cObject;
	goto retry;
    }
    return Qfalse;
}

int
rb_const_defined_from(klass, id)
    VALUE klass;
    ID id;
{
    return rb_const_defined_0(klass, id, Qtrue, Qtrue);
}

int
rb_const_defined(klass, id)
    VALUE klass;
    ID id;
{
    return rb_const_defined_0(klass, id, Qfalse, Qtrue);
}

int
rb_const_defined_at(klass, id)
    VALUE klass;
    ID id;
{
    return rb_const_defined_0(klass, id, Qtrue, Qfalse);
}

static void
mod_av_set(klass, id, val, isconst)
    VALUE klass;
    ID id;
    VALUE val;
    int isconst;
{
    const char *dest = isconst ? &quot;constant&quot; : &quot;class variable&quot;;

    if (!OBJ_TAINTED(klass) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't set %s&quot;, dest);
    if (OBJ_FROZEN(klass)) {
	if (BUILTIN_TYPE(klass) == T_MODULE) {
	    rb_error_frozen(&quot;module&quot;);
	}
	else {
	    rb_error_frozen(&quot;class&quot;);
	}
    }
    if (!RCLASS(klass)-&gt;iv_tbl) {
	RCLASS(klass)-&gt;iv_tbl = st_init_numtable();
    }
    else if (isconst) {
	VALUE value = Qfalse;

	if (st_lookup(RCLASS(klass)-&gt;iv_tbl, id, &amp;value)) {
	    if (value == Qundef)
		autoload_delete(klass, id);
	    else
		rb_warn(&quot;already initialized %s %s&quot;, dest, rb_id2name(id));
	}
    }

    st_insert(RCLASS(klass)-&gt;iv_tbl, id, val);
}

void
rb_const_set(klass, id, val)
    VALUE klass;
    ID id;
    VALUE val;
{
    if (NIL_P(klass)) {
	rb_raise(rb_eTypeError, &quot;no class/module to define constant %s&quot;,
		 rb_id2name(id));
    }
    mod_av_set(klass, id, val, Qtrue);
}

void
rb_define_const(klass, name, val)
    VALUE klass;
    const char *name;
    VALUE val;
{
    ID id = rb_intern(name);

    if (!rb_is_const_id(id)) {
	rb_warn(&quot;rb_define_const: invalid name `%s' for constant&quot;, name);
    }
    if (klass == rb_cObject) {
	rb_secure(4);
    }
    rb_const_set(klass, id, val);
}

void
rb_define_global_const(name, val)
    const char *name;
    VALUE val;
{
    rb_define_const(rb_cObject, name, val);
}

static VALUE
original_module(c)
    VALUE c;
{
    if (TYPE(c) == T_ICLASS)
	return RBASIC(c)-&gt;klass;
    return c;
}

static void
cvar_override_check(id, a)
    ID id;
    VALUE a;
{
    VALUE base = original_module(a);

    a = RCLASS(a)-&gt;super;
    while (a) {
	if (RCLASS(a)-&gt;iv_tbl) {
	    if (st_lookup(RCLASS(a)-&gt;iv_tbl,id,0)) {
		rb_warning(&quot;class variable %s of %s is overridden by %s&quot;,
			   rb_id2name(id), rb_class2name(original_module(a)),
			   rb_class2name(base));
	    }
	}
	a = RCLASS(a)-&gt;super;
    }
}

void
rb_cvar_set(klass, id, val, warn)
    VALUE klass;
    ID id;
    VALUE val;
    int warn;
{
    VALUE tmp;

    tmp = klass;
    while (tmp) {
	if (RCLASS(tmp)-&gt;iv_tbl &amp;&amp; st_lookup(RCLASS(tmp)-&gt;iv_tbl,id,0)) {
	    if (OBJ_FROZEN(tmp)) rb_error_frozen(&quot;class/module&quot;);
	    if (!OBJ_TAINTED(tmp) &amp;&amp; rb_safe_level() &gt;= 4)
		rb_raise(rb_eSecurityError, &quot;Insecure: can't modify class variable&quot;);
	    if (warn &amp;&amp; RTEST(ruby_verbose) &amp;&amp; klass != tmp) {
		rb_warning(&quot;already initialized class variable %s&quot;, rb_id2name(id));
	    }
	    st_insert(RCLASS(tmp)-&gt;iv_tbl,id,val);
	    if (RTEST(ruby_verbose)) {
		cvar_override_check(id, tmp);
	    }
	    return;
	}
	tmp = RCLASS(tmp)-&gt;super;
    }

    mod_av_set(klass, id, val, Qfalse);
}

VALUE
rb_cvar_get(klass, id)
    VALUE klass;
    ID id;
{
    VALUE value;
    VALUE tmp;

    tmp = klass;
    while (tmp) {
	if (RCLASS(tmp)-&gt;iv_tbl) {
	    if (st_lookup(RCLASS(tmp)-&gt;iv_tbl,id,&amp;value)) {
		if (RTEST(ruby_verbose)) {
		    cvar_override_check(id, tmp);
		}
		return value;
	    }
	}
	tmp = RCLASS(tmp)-&gt;super;
    }

    rb_name_error(id,&quot;uninitialized class variable %s in %s&quot;,
		  rb_id2name(id), rb_class2name(klass));
    return Qnil;		/* not reached */
}

VALUE
rb_cvar_defined(klass, id)
    VALUE klass;
    ID id;
{
    VALUE tmp;

    tmp = klass;
    while (tmp) {
	if (RCLASS(tmp)-&gt;iv_tbl &amp;&amp; st_lookup(RCLASS(tmp)-&gt;iv_tbl,id,0)) {
	    return Qtrue;
	}
	tmp = RCLASS(tmp)-&gt;super;
    }

    return Qfalse;
}

void
rb_cv_set(klass, name, val)
    VALUE klass;
    const char *name;
    VALUE val;
{
    ID id = rb_intern(name);
    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;wrong class variable name %s&quot;, name);
    }
    rb_cvar_set(klass, id, val, Qfalse);
}

VALUE
rb_cv_get(klass, name)
    VALUE klass;
    const char *name;
{
    ID id = rb_intern(name);
    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;wrong class variable name %s&quot;, name);
    }
    return rb_cvar_get(klass, id);
}

void
rb_define_class_variable(klass, name, val)
    VALUE klass;
    const char *name;
    VALUE val;
{
    ID id = rb_intern(name);

    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;wrong class variable name %s&quot;, name);
    }
    rb_cvar_set(klass, id, val, Qtrue);
}

static int
cv_i(key, value, ary)
    ID key;
    VALUE value;
    VALUE ary;
{
    if (rb_is_class_id(key)) {
	VALUE kval = rb_str_new2(rb_id2name(key));
	if (!rb_ary_includes(ary, kval)) {
	    rb_ary_push(ary, kval);
	}
    }
    return ST_CONTINUE;
}

/*
 *  call-seq:
 *     mod.class_variables   =&gt; array
 *  
 *  Returns an array of the names of class variables in &lt;i&gt;mod&lt;/i&gt; and
 *  the ancestors of &lt;i&gt;mod&lt;/i&gt;.
 *     
 *     class One
 *       @@var1 = 1
 *     end
 *     class Two &lt; One
 *       @@var2 = 2
 *     end
 *     One.class_variables   #=&gt; [&quot;@@var1&quot;]
 *     Two.class_variables   #=&gt; [&quot;@@var2&quot;, &quot;@@var1&quot;]
 */

VALUE
rb_mod_class_variables(obj)
    VALUE obj;
{
    VALUE ary = rb_ary_new();

    for (;;) {
	if (RCLASS(obj)-&gt;iv_tbl) {
	    st_foreach_safe(RCLASS(obj)-&gt;iv_tbl, cv_i, ary);
	}
	obj = RCLASS(obj)-&gt;super;
	if (!obj) break;
    }
    return ary;
}

/*
 *  call-seq:
 *     remove_class_variable(sym)    =&gt; obj
 *  
 *  Removes the definition of the &lt;i&gt;sym&lt;/i&gt;, returning that
 *  constant's value.
 *     
 *     class Dummy
 *       @@var = 99
 *       puts @@var
 *       remove_class_variable(:@@var)
 *       puts(defined? @@var)
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     99
 *     nil
 */

VALUE
rb_mod_remove_cvar(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);
    VALUE val;

    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;wrong class variable name %s&quot;, rb_id2name(id));
    }
    if (!OBJ_TAINTED(mod) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't remove class variable&quot;);
    if (OBJ_FROZEN(mod)) rb_error_frozen(&quot;class/module&quot;);

    if (RCLASS(mod)-&gt;iv_tbl &amp;&amp; st_delete(ROBJECT(mod)-&gt;iv_tbl, (st_data_t*)&amp;id, &amp;val)) {
	return val;
    }
    if (rb_cvar_defined(mod, id)) {
	rb_name_error(id, &quot;cannot remove %s for %s&quot;,
		 rb_id2name(id), rb_class2name(mod));
    }
    rb_name_error(id, &quot;class variable %s not defined for %s&quot;,
		  rb_id2name(id), rb_class2name(mod));
    return Qnil;		/* not reached */
}

VALUE
rb_iv_get(obj, name)
    VALUE obj;
    const char *name;
{
    ID id = rb_intern(name);

    return rb_ivar_get(obj, id);
}

VALUE
rb_iv_set(obj, name, val)
    VALUE obj;
    const char *name;
    VALUE val;
{
    ID id = rb_intern(name);

    return rb_ivar_set(obj, id, val);
}
</pre>
    </div>