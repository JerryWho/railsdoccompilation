  <div id="fileHeader">
    <h1>object.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/object.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  object.c -

  $Author: knu $
  $Date: 2008-06-06 17:05:24 +0900 (Fri, 06 Jun 2008) $
  created at: Thu Jul 15 12:01:24 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;st.h&quot;
#include &quot;util.h&quot;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;

VALUE rb_mKernel;
VALUE rb_cObject;
VALUE rb_cModule;
VALUE rb_cClass;
VALUE rb_cData;

VALUE rb_cNilClass;
VALUE rb_cTrueClass;
VALUE rb_cFalseClass;
VALUE rb_cSymbol;

static ID id_eq, id_eql, id_inspect, id_init_copy;

/*
 *  call-seq:
 *     obj === other   =&gt; true or false
 *  
 *  Case Equality---For class &lt;code&gt;Object&lt;/code&gt;, effectively the same
 *  as calling  &lt;code&gt;#==&lt;/code&gt;, but typically overridden by descendents
 *  to provide meaningful semantics in &lt;code&gt;case&lt;/code&gt; statements.
 */

VALUE
rb_equal(obj1, obj2)
    VALUE obj1, obj2;
{
    VALUE result;

    if (obj1 == obj2) return Qtrue;
    result = rb_funcall(obj1, id_eq, 1, obj2);
    if (RTEST(result)) return Qtrue;
    return Qfalse;
}

int
rb_eql(obj1, obj2)
    VALUE obj1, obj2;
{
    return RTEST(rb_funcall(obj1, id_eql, 1, obj2));
}

/*
 *  call-seq:
 *     obj == other        =&gt; true or false
 *     obj.equal?(other)   =&gt; true or false
 *     obj.eql?(other)     =&gt; true or false
 *  
 *  Equality---At the &lt;code&gt;Object&lt;/code&gt; level, &lt;code&gt;==&lt;/code&gt; returns
 *  &lt;code&gt;true&lt;/code&gt; only if &lt;i&gt;obj&lt;/i&gt; and &lt;i&gt;other&lt;/i&gt; are the
 *  same object. Typically, this method is overridden in descendent
 *  classes to provide class-specific meaning.
 *
 *  Unlike &lt;code&gt;==&lt;/code&gt;, the &lt;code&gt;equal?&lt;/code&gt; method should never be
 *  overridden by subclasses: it is used to determine object identity
 *  (that is, &lt;code&gt;a.equal?(b)&lt;/code&gt; iff &lt;code&gt;a&lt;/code&gt; is the same
 *  object as &lt;code&gt;b&lt;/code&gt;).
 *
 *  The &lt;code&gt;eql?&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if
    &lt;i&gt;obj&lt;/i&gt; and &lt;i&gt;anObject&lt;/i&gt; have the
 *  same value. Used by &lt;code&gt;Hash&lt;/code&gt; to test members for equality.
 *  For objects of class &lt;code&gt;Object&lt;/code&gt;, &lt;code&gt;eql?&lt;/code&gt; is
 *  synonymous with &lt;code&gt;==&lt;/code&gt;. Subclasses normally continue this
 *  tradition, but there are exceptions. &lt;code&gt;Numeric&lt;/code&gt; types, for
 *  example, perform type conversion across &lt;code&gt;==&lt;/code&gt;, but not
 *  across &lt;code&gt;eql?&lt;/code&gt;, so:
 *     
 *     1 == 1.0     #=&gt; true
 *     1.eql? 1.0   #=&gt; false
 */

static VALUE
rb_obj_equal(obj1, obj2)
    VALUE obj1, obj2;
{
    if (obj1 == obj2) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     obj.id    =&gt; fixnum
 *  
 *  Soon-to-be deprecated version of &lt;code&gt;Object#object_id&lt;/code&gt;.
 */

VALUE
rb_obj_id_obsolete(obj)
    VALUE obj;
{
    rb_warn(&quot;Object#id will be deprecated; use Object#object_id&quot;);
    return rb_obj_id(obj);
}

VALUE
rb_class_real(cl)
    VALUE cl;
{
    while (FL_TEST(cl, FL_SINGLETON) || TYPE(cl) == T_ICLASS) {
	cl = RCLASS(cl)-&gt;super;
    }
    return cl;
}

/*
 *  call-seq:
 *     obj.type   =&gt; class
 *  
 *  Deprecated synonym for &lt;code&gt;Object#class&lt;/code&gt;.
 */

VALUE
rb_obj_type(obj)
    VALUE obj;
{
    rb_warn(&quot;Object#type is deprecated; use Object#class&quot;);
    return rb_class_real(CLASS_OF(obj));
}


/*
 *  call-seq:
 *     obj.class    =&gt; class
 *  
 *  Returns the class of &lt;i&gt;obj&lt;/i&gt;, now preferred over
 *  &lt;code&gt;Object#type&lt;/code&gt;, as an object's type in Ruby is only
 *  loosely tied to that object's class. This method must always be
 *  called with an explicit receiver, as &lt;code&gt;class&lt;/code&gt; is also a
 *  reserved word in Ruby.
 *     
 *     1.class      #=&gt; Fixnum
 *     self.class   #=&gt; Object
 */

VALUE
rb_obj_class(obj)
    VALUE obj;
{
    return rb_class_real(CLASS_OF(obj));
}

static void
init_copy(dest, obj)
    VALUE dest, obj;
{
    if (OBJ_FROZEN(dest)) {
        rb_raise(rb_eTypeError, &quot;[bug] frozen object (%s) allocated&quot;, rb_obj_classname(dest));
    }
    RBASIC(dest)-&gt;flags &amp;= ~(T_MASK|FL_EXIVAR);
    RBASIC(dest)-&gt;flags |= RBASIC(obj)-&gt;flags &amp; (T_MASK|FL_EXIVAR|FL_TAINT);
    if (FL_TEST(obj, FL_EXIVAR)) {
	rb_copy_generic_ivar(dest, obj);
    }
    rb_gc_copy_finalizer(dest, obj);
    switch (TYPE(obj)) {
      case T_OBJECT:
      case T_CLASS:
      case T_MODULE:
	if (ROBJECT(dest)-&gt;iv_tbl) {
	    st_free_table(ROBJECT(dest)-&gt;iv_tbl);
	    ROBJECT(dest)-&gt;iv_tbl = 0;
	}
	if (ROBJECT(obj)-&gt;iv_tbl) {
	    ROBJECT(dest)-&gt;iv_tbl = st_copy(ROBJECT(obj)-&gt;iv_tbl);
	}
    }
    rb_funcall(dest, id_init_copy, 1, obj);
}

/*
 *  call-seq:
 *     obj.clone -&gt; an_object
 *  
 *  Produces a shallow copy of &lt;i&gt;obj&lt;/i&gt;---the instance variables of
 *  &lt;i&gt;obj&lt;/i&gt; are copied, but not the objects they reference. Copies
 *  the frozen and tainted state of &lt;i&gt;obj&lt;/i&gt;. See also the discussion
 *  under &lt;code&gt;Object#dup&lt;/code&gt;.
 *     
 *     class Klass
 *        attr_accessor :str
 *     end
 *     s1 = Klass.new      #=&gt; #&lt;Klass:0x401b3a38&gt;
 *     s1.str = &quot;Hello&quot;    #=&gt; &quot;Hello&quot;
 *     s2 = s1.clone       #=&gt; #&lt;Klass:0x401b3998 @str=&quot;Hello&quot;&gt;
 *     s2.str[1,4] = &quot;i&quot;   #=&gt; &quot;i&quot;
 *     s1.inspect          #=&gt; &quot;#&lt;Klass:0x401b3a38 @str=\&quot;Hi\&quot;&gt;&quot;
 *     s2.inspect          #=&gt; &quot;#&lt;Klass:0x401b3998 @str=\&quot;Hi\&quot;&gt;&quot;
 *
 *  This method may have class-specific behavior.  If so, that
 *  behavior will be documented under the #+initialize_copy+ method of
 *  the class.
 */

VALUE
rb_obj_clone(obj)
    VALUE obj;
{
    VALUE clone;

    if (rb_special_const_p(obj)) {
        rb_raise(rb_eTypeError, &quot;can't clone %s&quot;, rb_obj_classname(obj));
    }
    clone = rb_obj_alloc(rb_obj_class(obj));
    RBASIC(clone)-&gt;klass = rb_singleton_class_clone(obj);
    RBASIC(clone)-&gt;flags = (RBASIC(obj)-&gt;flags | FL_TEST(clone, FL_TAINT)) &amp; ~(FL_FREEZE|FL_FINALIZE);
    init_copy(clone, obj);
    RBASIC(clone)-&gt;flags |= RBASIC(obj)-&gt;flags &amp; FL_FREEZE;

    return clone;
}

/*
 *  call-seq:
 *     obj.dup -&gt; an_object
 *  
 *  Produces a shallow copy of &lt;i&gt;obj&lt;/i&gt;---the instance variables of
 *  &lt;i&gt;obj&lt;/i&gt; are copied, but not the objects they reference.
 *  &lt;code&gt;dup&lt;/code&gt; copies the tainted state of &lt;i&gt;obj&lt;/i&gt;. See also
 *  the discussion under &lt;code&gt;Object#clone&lt;/code&gt;. In general,
 *  &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;dup&lt;/code&gt; may have different semantics
 *  in descendent classes. While &lt;code&gt;clone&lt;/code&gt; is used to duplicate
 *  an object, including its internal state, &lt;code&gt;dup&lt;/code&gt; typically
 *  uses the class of the descendent object to create the new instance.
 *
 *  This method may have class-specific behavior.  If so, that
 *  behavior will be documented under the #+initialize_copy+ method of
 *  the class.
 */

VALUE
rb_obj_dup(obj)
    VALUE obj;
{
    VALUE dup;

    if (rb_special_const_p(obj)) {
        rb_raise(rb_eTypeError, &quot;can't dup %s&quot;, rb_obj_classname(obj));
    }
    dup = rb_obj_alloc(rb_obj_class(obj));
    init_copy(dup, obj);

    return dup;
}

/* :nodoc: */
VALUE
rb_obj_init_copy(obj, orig)
    VALUE obj, orig;
{
    if (obj == orig) return obj;
    rb_check_frozen(obj);
    if (TYPE(obj) != TYPE(orig) || rb_obj_class(obj) != rb_obj_class(orig)) {
	rb_raise(rb_eTypeError, &quot;initialize_copy should take same class object&quot;);
    }
    return obj;
}

/*
 *  call-seq:
 *     obj.to_a -&gt; anArray
 *  
 *  Returns an array representation of &lt;i&gt;obj&lt;/i&gt;. For objects of class
 *  &lt;code&gt;Object&lt;/code&gt; and others that don't explicitly override the
 *  method, the return value is an array containing &lt;code&gt;self&lt;/code&gt;. 
 *  However, this latter behavior will soon be obsolete.
 *     
 *     self.to_a       #=&gt; -:1: warning: default `to_a' will be obsolete
 *     &quot;hello&quot;.to_a    #=&gt; [&quot;hello&quot;]
 *     Time.new.to_a   #=&gt; [39, 54, 8, 9, 4, 2003, 3, 99, true, &quot;CDT&quot;]
 */


static VALUE
rb_any_to_a(obj)
    VALUE obj;
{
    rb_warn(&quot;default `to_a' will be obsolete&quot;);
    return rb_ary_new3(1, obj);
}


/*
 *  call-seq:
 *     obj.to_s    =&gt; string
 *  
 *  Returns a string representing &lt;i&gt;obj&lt;/i&gt;. The default
 *  &lt;code&gt;to_s&lt;/code&gt; prints the object's class and an encoding of the
 *  object id. As a special case, the top-level object that is the
 *  initial execution context of Ruby programs returns ``main.''
 */

VALUE
rb_any_to_s(obj)
    VALUE obj;
{
    const char *cname = rb_obj_classname(obj);
    size_t len;
    VALUE str;

    len = strlen(cname)+6+16;
    str = rb_str_new(0, len); /* 6:tags 16:addr */
    snprintf(RSTRING(str)-&gt;ptr, len+1, &quot;#&lt;%s:0x%lx&gt;&quot;, cname, obj);
    RSTRING(str)-&gt;len = strlen(RSTRING(str)-&gt;ptr);
    if (OBJ_TAINTED(obj)) OBJ_TAINT(str);

    return str;
}

VALUE
rb_inspect(obj)
    VALUE obj;
{
    return rb_obj_as_string(rb_funcall(obj, id_inspect, 0, 0));
}

static int
inspect_i(id, value, str)
    ID id;
    VALUE value;
    VALUE str;
{
    VALUE str2;
    const char *ivname;

    /* need not to show internal data */
    if (CLASS_OF(value) == 0) return ST_CONTINUE;
    if (!rb_is_instance_id(id)) return ST_CONTINUE;
    if (RSTRING(str)-&gt;ptr[0] == '-') { /* first element */
	RSTRING(str)-&gt;ptr[0] = '#';
	rb_str_cat2(str, &quot; &quot;);
    }
    else {
	rb_str_cat2(str, &quot;, &quot;);
    }
    ivname = rb_id2name(id);
    rb_str_cat2(str, ivname);
    rb_str_cat2(str, &quot;=&quot;);
    str2 = rb_inspect(value);
    rb_str_append(str, str2);
    OBJ_INFECT(str, str2);

    return ST_CONTINUE;
}

static VALUE
inspect_obj(obj, str)
    VALUE obj, str;
{
    st_foreach_safe(ROBJECT(obj)-&gt;iv_tbl, inspect_i, str);
    rb_str_cat2(str, &quot;&gt;&quot;);
    RSTRING(str)-&gt;ptr[0] = '#';
    OBJ_INFECT(str, obj);

    return str;
}

/*
 *  call-seq:
 *     obj.inspect   =&gt; string
 *  
 *  Returns a string containing a human-readable representation of
 *  &lt;i&gt;obj&lt;/i&gt;. If not overridden, uses the &lt;code&gt;to_s&lt;/code&gt; method to
 *  generate the string.
 *     
 *     [ 1, 2, 3..4, 'five' ].inspect   #=&gt; &quot;[1, 2, 3..4, \&quot;five\&quot;]&quot;
 *     Time.new.inspect                 #=&gt; &quot;Wed Apr 09 08:54:39 CDT 2003&quot;
 */


static VALUE
rb_obj_inspect(obj)
    VALUE obj;
{
    if (TYPE(obj) == T_OBJECT
	&amp;&amp; ROBJECT(obj)-&gt;iv_tbl
	&amp;&amp; ROBJECT(obj)-&gt;iv_tbl-&gt;num_entries &gt; 0) {
	VALUE str;
	size_t len;
	const char *c = rb_obj_classname(obj);

	if (rb_inspecting_p(obj)) {
	    len = strlen(c)+10+16+1;
	    str = rb_str_new(0, len); /* 10:tags 16:addr 1:nul */
	    snprintf(RSTRING(str)-&gt;ptr, len, &quot;#&lt;%s:0x%lx ...&gt;&quot;, c, obj);
	    RSTRING(str)-&gt;len = strlen(RSTRING(str)-&gt;ptr);
	    return str;
	}
	len = strlen(c)+6+16+1;
	str = rb_str_new(0, len);     /* 6:tags 16:addr 1:nul */
	snprintf(RSTRING(str)-&gt;ptr, len, &quot;-&lt;%s:0x%lx&quot;, c, obj);
	RSTRING(str)-&gt;len = strlen(RSTRING(str)-&gt;ptr);
	return rb_protect_inspect(inspect_obj, obj, str);
    }
    return rb_funcall(obj, rb_intern(&quot;to_s&quot;), 0, 0);
}


/*
 *  call-seq:
 *     obj.instance_of?(class)    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;obj&lt;/i&gt; is an instance of the given
 *  class. See also &lt;code&gt;Object#kind_of?&lt;/code&gt;.
 */

VALUE
rb_obj_is_instance_of(obj, c)
    VALUE obj, c;
{
    switch (TYPE(c)) {
      case T_MODULE:
      case T_CLASS:
      case T_ICLASS:
	break;
      default:
	rb_raise(rb_eTypeError, &quot;class or module required&quot;);
    }

    if (rb_obj_class(obj) == c) return Qtrue;
    return Qfalse;
}


/*
 *  call-seq:
 *     obj.is_a?(class)       =&gt; true or false
 *     obj.kind_of?(class)    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;class&lt;/i&gt; is the class of
 *  &lt;i&gt;obj&lt;/i&gt;, or if &lt;i&gt;class&lt;/i&gt; is one of the superclasses of
 *  &lt;i&gt;obj&lt;/i&gt; or modules included in &lt;i&gt;obj&lt;/i&gt;.
 *     
 *     module M;    end
 *     class A
 *       include M
 *     end
 *     class B &lt; A; end
 *     class C &lt; B; end
 *     b = B.new
 *     b.instance_of? A   #=&gt; false
 *     b.instance_of? B   #=&gt; true
 *     b.instance_of? C   #=&gt; false
 *     b.instance_of? M   #=&gt; false
 *     b.kind_of? A       #=&gt; true
 *     b.kind_of? B       #=&gt; true
 *     b.kind_of? C       #=&gt; false
 *     b.kind_of? M       #=&gt; true
 */

VALUE
rb_obj_is_kind_of(obj, c)
    VALUE obj, c;
{
    VALUE cl = CLASS_OF(obj);

    switch (TYPE(c)) {
      case T_MODULE:
      case T_CLASS:
      case T_ICLASS:
	break;

      default:
	rb_raise(rb_eTypeError, &quot;class or module required&quot;);
    }

    while (cl) {
	if (cl == c || RCLASS(cl)-&gt;m_tbl == RCLASS(c)-&gt;m_tbl)
	    return Qtrue;
	cl = RCLASS(cl)-&gt;super;
    }
    return Qfalse;
}


/*
 *  call-seq:
 *     obj.tap{|x|...}    =&gt; obj
 *  
 *  Yields &lt;code&gt;x&lt;/code&gt; to the block, and then returns &lt;code&gt;x&lt;/code&gt;.
 *  The primary purpose of this method is to &quot;tap into&quot; a method chain,
 *  in order to perform operations on intermediate results within the chain.
 *
 *	(1..10).tap {
 *	  |x| puts &quot;original: #{x.inspect}&quot;
 *	}.to_a.tap {
 *	  |x| puts &quot;array: #{x.inspect}&quot;
 *	}.select {|x| x%2==0}.tap {
 *	  |x| puts &quot;evens: #{x.inspect}&quot;
 *	}.map {|x| x*x}.tap {
 *	  |x| puts &quot;squares: #{x.inspect}&quot;
 *	}
 *
 */

VALUE
rb_obj_tap(obj)
    VALUE obj;
{
    rb_yield(obj);
    return obj;
}


/*
 * Document-method: inherited
 *
 * call-seq:
 *    inherited(subclass)
 *
 * Callback invoked whenever a subclass of the current class is created.
 *
 * Example:
 *
 *    class Foo
 *       def self.inherited(subclass)
 *          puts &quot;New subclass: #{subclass}&quot;
 *       end
 *    end
 *
 *    class Bar &lt; Foo
 *    end
 *
 *    class Baz &lt; Bar
 *    end
 *
 * produces:
 *
 *    New subclass: Bar
 *    New subclass: Baz
 */

/*
 * Document-method: singleton_method_added
 *
 *  call-seq:
 *     singleton_method_added(symbol)
 *  
 *  Invoked as a callback whenever a singleton method is added to the
 *  receiver.
 *     
 *     module Chatty
 *       def Chatty.singleton_method_added(id)
 *         puts &quot;Adding #{id.id2name}&quot;
 *       end
 *       def self.one()     end
 *       def two()          end
 *       def Chatty.three() end
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Adding singleton_method_added
 *     Adding one
 *     Adding three
 *     
 */

/*
 * Document-method: singleton_method_removed
 *
 *  call-seq:
 *     singleton_method_removed(symbol)
 *  
 *  Invoked as a callback whenever a singleton method is removed from
 *  the receiver.
 *     
 *     module Chatty
 *       def Chatty.singleton_method_removed(id)
 *         puts &quot;Removing #{id.id2name}&quot;
 *       end
 *       def self.one()     end
 *       def two()          end
 *       def Chatty.three() end
 *       class &lt;&lt;self
 *         remove_method :three
 *         remove_method :one
 *       end
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Removing three
 *     Removing one
 */

/*
 * Document-method: singleton_method_undefined
 *
 *  call-seq:
 *     singleton_method_undefined(symbol)
 *  
 *  Invoked as a callback whenever a singleton method is undefined in
 *  the receiver.
 *     
 *     module Chatty
 *       def Chatty.singleton_method_undefined(id)
 *         puts &quot;Undefining #{id.id2name}&quot;
 *       end
 *       def Chatty.one()   end
 *       class &lt;&lt; self
 *          undef_method(:one)
 *       end
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Undefining one
 */


/*
 * Document-method: included
 *
 * call-seq:
 *    included( othermod )
 *
 * Callback invoked whenever the receiver is included in another
 * module or class. This should be used in preference to
 * &lt;tt&gt;Module.append_features&lt;/tt&gt; if your code wants to perform some
 * action when a module is included in another.
 *
 *        module A
 *          def A.included(mod)
 *            puts &quot;#{self} included in #{mod}&quot;
 *          end
 *        end
 *        module Enumerable
 *          include A
 *        end
 */


/*
 * Not documented
 */

static VALUE
rb_obj_dummy()
{
    return Qnil;
}

/*
 *  call-seq:
 *     obj.tainted?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if the object is tainted.
 */

VALUE
rb_obj_tainted(obj)
    VALUE obj;
{
    if (OBJ_TAINTED(obj))
	return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     obj.taint -&gt; obj
 *  
 *  Marks &lt;i&gt;obj&lt;/i&gt; as tainted---if the &lt;code&gt;$SAFE&lt;/code&gt; level is
 *  set appropriately, many method calls which might alter the running
 *  programs environment will refuse to accept tainted strings.
 */

VALUE
rb_obj_taint(obj)
    VALUE obj;
{
    rb_secure(4);
    if (!OBJ_TAINTED(obj)) {
	if (OBJ_FROZEN(obj)) {
	    rb_error_frozen(&quot;object&quot;);
	}
	OBJ_TAINT(obj);
    }
    return obj;
}


/*
 *  call-seq:
 *     obj.untaint    =&gt; obj
 *  
 *  Removes the taint from &lt;i&gt;obj&lt;/i&gt;.
 */

VALUE
rb_obj_untaint(obj)
    VALUE obj;
{
    rb_secure(3);
    if (OBJ_TAINTED(obj)) {
	if (OBJ_FROZEN(obj)) {
	    rb_error_frozen(&quot;object&quot;);
	}
	FL_UNSET(obj, FL_TAINT);
    }
    return obj;
}

void
rb_obj_infect(obj1, obj2)
    VALUE obj1, obj2;
{
    OBJ_INFECT(obj1, obj2);
}


/*
 *  call-seq:
 *     obj.freeze    =&gt; obj
 *  
 *  Prevents further modifications to &lt;i&gt;obj&lt;/i&gt;. A
 *  &lt;code&gt;TypeError&lt;/code&gt; will be raised if modification is attempted.
 *  There is no way to unfreeze a frozen object. See also
 *  &lt;code&gt;Object#frozen?&lt;/code&gt;.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.freeze
 *     a &lt;&lt; &quot;z&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     prog.rb:3:in `&lt;&lt;': can't modify frozen array (TypeError)
 *     	from prog.rb:3
 */

VALUE
rb_obj_freeze(obj)
    VALUE obj;
{
    if (!OBJ_FROZEN(obj)) {
	if (rb_safe_level() &gt;= 4 &amp;&amp; !OBJ_TAINTED(obj)) {
	    rb_raise(rb_eSecurityError, &quot;Insecure: can't freeze object&quot;);
	}
	OBJ_FREEZE(obj);
    }
    return obj;
}

/*
 *  call-seq:
 *     obj.frozen?    =&gt; true or false
 *  
 *  Returns the freeze status of &lt;i&gt;obj&lt;/i&gt;.
 *     
 *     a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]
 *     a.freeze    #=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
 *     a.frozen?   #=&gt; true
 */

static VALUE
rb_obj_frozen_p(obj)
    VALUE obj;
{
    if (OBJ_FROZEN(obj)) return Qtrue;
    return Qfalse;
}


/*
 * Document-class: NilClass
 *
 *  The class of the singleton object &lt;code&gt;nil&lt;/code&gt;.
 */

/*
 *  call-seq:
 *     nil.to_i =&gt; 0
 *  
 *  Always returns zero.
 *     
 *     nil.to_i   #=&gt; 0
 */


static VALUE
nil_to_i(obj)
    VALUE obj;
{
    return INT2FIX(0);
}

/*
 *  call-seq:
 *     nil.to_f    =&gt; 0.0
 *  
 *  Always returns zero.
 *     
 *     nil.to_f   #=&gt; 0.0
 */

static VALUE
nil_to_f(obj)
    VALUE obj;
{
    return rb_float_new(0.0);
}

/*
 *  call-seq:
 *     nil.to_s    =&gt; &quot;&quot;
 *  
 *  Always returns the empty string.
 *     
 *     nil.to_s   #=&gt; &quot;&quot;
 */

static VALUE
nil_to_s(obj)
    VALUE obj;
{
    return rb_str_new2(&quot;&quot;);
}

/*
 *  call-seq:
 *     nil.to_a    =&gt; []
 *  
 *  Always returns an empty array.
 *     
 *     nil.to_a   #=&gt; []
 */

static VALUE
nil_to_a(obj)
    VALUE obj;
{
    return rb_ary_new2(0);
}

/*
 *  call-seq:
 *    nil.inspect  =&gt; &quot;nil&quot;
 *
 *  Always returns the string &quot;nil&quot;.
 */

static VALUE
nil_inspect(obj)
    VALUE obj;
{
    return rb_str_new2(&quot;nil&quot;);
}

static VALUE
main_to_s(obj)
    VALUE obj;
{
    return rb_str_new2(&quot;main&quot;);
}


/***********************************************************************
 *  Document-class: TrueClass
 *
 *  The global value &lt;code&gt;true&lt;/code&gt; is the only instance of class
 *  &lt;code&gt;TrueClass&lt;/code&gt; and represents a logically true value in
 *  boolean expressions. The class provides operators allowing
 *  &lt;code&gt;true&lt;/code&gt; to be used in logical expressions.
 */


/*
 * call-seq:
 *   true.to_s   =&gt;  &quot;true&quot;
 *
 * The string representation of &lt;code&gt;true&lt;/code&gt; is &quot;true&quot;.
 */

static VALUE
true_to_s(obj)
    VALUE obj;
{
    return rb_str_new2(&quot;true&quot;);
}


/*
 *  call-seq:
 *     true &amp; obj    =&gt; true or false
 *  
 *  And---Returns &lt;code&gt;false&lt;/code&gt; if &lt;i&gt;obj&lt;/i&gt; is
 *  &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; otherwise.
 */

static VALUE
true_and(obj, obj2)
    VALUE obj, obj2;
{
    return RTEST(obj2)?Qtrue:Qfalse;
}

/*
 *  call-seq:
 *     true | obj   =&gt; true
 *  
 *  Or---Returns &lt;code&gt;true&lt;/code&gt;. As &lt;i&gt;anObject&lt;/i&gt; is an argument to
 *  a method call, it is always evaluated; there is no short-circuit
 *  evaluation in this case.
 *     
 *     true |  puts(&quot;or&quot;)
 *     true || puts(&quot;logical or&quot;)
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     or
 */

static VALUE
true_or(obj, obj2)
    VALUE obj, obj2;
{
    return Qtrue;
}


/*
 *  call-seq:
 *     true ^ obj   =&gt; !obj
 *  
 *  Exclusive Or---Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;obj&lt;/i&gt; is
 *  &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;
 *  otherwise.
 */

static VALUE
true_xor(obj, obj2)
    VALUE obj, obj2;
{
    return RTEST(obj2)?Qfalse:Qtrue;
}


/*
 *  Document-class: FalseClass
 *
 *  The global value &lt;code&gt;false&lt;/code&gt; is the only instance of class
 *  &lt;code&gt;FalseClass&lt;/code&gt; and represents a logically false value in
 *  boolean expressions. The class provides operators allowing
 *  &lt;code&gt;false&lt;/code&gt; to participate correctly in logical expressions.
 *     
 */

/*
 * call-seq:
 *   false.to_s   =&gt;  &quot;false&quot;
 *
 * 'nuf said...
 */

static VALUE
false_to_s(obj)
    VALUE obj;
{
    return rb_str_new2(&quot;false&quot;);
}

/*
 *  call-seq:
 *     false &amp; obj   =&gt; false
 *     nil &amp; obj     =&gt; false
 *  
 *  And---Returns &lt;code&gt;false&lt;/code&gt;. &lt;i&gt;obj&lt;/i&gt; is always
 *  evaluated as it is the argument to a method call---there is no
 *  short-circuit evaluation in this case.
 */

static VALUE
false_and(obj, obj2)
    VALUE obj, obj2;
{
    return Qfalse;
}


/*
 *  call-seq:
 *     false | obj   =&gt;   true or false
 *     nil   | obj   =&gt;   true or false
 *  
 *  Or---Returns &lt;code&gt;false&lt;/code&gt; if &lt;i&gt;obj&lt;/i&gt; is
 *  &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; &lt;code&gt;true&lt;/code&gt; otherwise.
 */

static VALUE
false_or(obj, obj2)
    VALUE obj, obj2;
{
    return RTEST(obj2)?Qtrue:Qfalse;
}



/*
 *  call-seq:
 *     false ^ obj    =&gt; true or false
 *     nil   ^ obj    =&gt; true or false
 *  
 *  Exclusive Or---If &lt;i&gt;obj&lt;/i&gt; is &lt;code&gt;nil&lt;/code&gt; or
 *  &lt;code&gt;false&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;; otherwise, returns
 *  &lt;code&gt;true&lt;/code&gt;.
 *     
 */

static VALUE
false_xor(obj, obj2)
    VALUE obj, obj2;
{
    return RTEST(obj2)?Qtrue:Qfalse;
}

/*
 * call_seq:
 *   nil.nil?               =&gt; true
 *
 * Only the object &lt;i&gt;nil&lt;/i&gt; responds &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;nil?&lt;/code&gt;.
 */

static VALUE
rb_true(obj)
    VALUE obj;
{
    return Qtrue;
}

/*
 * call_seq:
 *   nil.nil?               =&gt; true
 *   &lt;anything_else&gt;.nil?   =&gt; false
 *
 * Only the object &lt;i&gt;nil&lt;/i&gt; responds &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;nil?&lt;/code&gt;.
 */


static VALUE
rb_false(obj)
    VALUE obj;
{
    return Qfalse;
}


/*
 *  call-seq:
 *     obj =~ other  =&gt; false
 *  
 *  Pattern Match---Overridden by descendents (notably
 *  &lt;code&gt;Regexp&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;) to provide meaningful
 *  pattern-match semantics.
 */

static VALUE
rb_obj_pattern_match(obj1, obj2)
    VALUE obj1, obj2;
{
    return Qfalse;
}

/**********************************************************************
 * Document-class: Symbol
 *
 *  &lt;code&gt;Symbol&lt;/code&gt; objects represent names and some strings
 *  inside the Ruby
 *  interpreter. They are generated using the &lt;code&gt;:name&lt;/code&gt; and
 *  &lt;code&gt;:&quot;string&quot;&lt;/code&gt; literals
 *  syntax, and by the various &lt;code&gt;to_sym&lt;/code&gt; methods. The same
 *  &lt;code&gt;Symbol&lt;/code&gt; object will be created for a given name or string
 *  for the duration of a program's execution, regardless of the context
 *  or meaning of that name. Thus if &lt;code&gt;Fred&lt;/code&gt; is a constant in
 *  one context, a method in another, and a class in a third, the
 *  &lt;code&gt;Symbol&lt;/code&gt; &lt;code&gt;:Fred&lt;/code&gt; will be the same object in
 *  all three contexts.
 *     
 *     module One
 *       class Fred
 *       end
 *       $f1 = :Fred
 *     end
 *     module Two
 *       Fred = 1
 *       $f2 = :Fred
 *     end
 *     def Fred()
 *     end
 *     $f3 = :Fred
 *     $f1.id   #=&gt; 2514190
 *     $f2.id   #=&gt; 2514190
 *     $f3.id   #=&gt; 2514190
 *     
 */

/*
 *  call-seq:
 *     sym.to_i      =&gt; fixnum
 *  
 *  Returns an integer that is unique for each symbol within a
 *  particular execution of a program.
 *     
 *     :fred.to_i           #=&gt; 9809
 *     &quot;fred&quot;.to_sym.to_i   #=&gt; 9809
 */

static VALUE
sym_to_i(sym)
    VALUE sym;
{
    ID id = SYM2ID(sym);

    return LONG2FIX(id);
}


/* :nodoc: */

static VALUE
sym_to_int(sym)
    VALUE sym;
{
    rb_warning(&quot;treating Symbol as an integer&quot;);
    return sym_to_i(sym);
}


/*
 *  call-seq:
 *     sym.inspect    =&gt; string
 *  
 *  Returns the representation of &lt;i&gt;sym&lt;/i&gt; as a symbol literal.
 *     
 *     :fred.inspect   #=&gt; &quot;:fred&quot;
 */

static VALUE
sym_inspect(sym)
    VALUE sym;
{
    VALUE str;
    const char *name;
    ID id = SYM2ID(sym);

    name = rb_id2name(id);
    str = rb_str_new(0, strlen(name)+1);
    RSTRING(str)-&gt;ptr[0] = ':';
    strcpy(RSTRING(str)-&gt;ptr+1, name);
    if (!rb_symname_p(name)) {
	str = rb_str_dump(str);
	strncpy(RSTRING(str)-&gt;ptr, &quot;:\&quot;&quot;, 2);
    }
    return str;
}


/*
 *  call-seq:
 *     sym.id2name   =&gt; string
 *     sym.to_s      =&gt; string
 *  
 *  Returns the name or string corresponding to &lt;i&gt;sym&lt;/i&gt;.
 *     
 *     :fred.id2name   #=&gt; &quot;fred&quot;
 */


static VALUE
sym_to_s(sym)
    VALUE sym;
{
    return rb_str_new2(rb_id2name(SYM2ID(sym)));
}


/*
 * call-seq:
 *   sym.to_sym   =&gt; sym
 *
 * In general, &lt;code&gt;to_sym&lt;/code&gt; returns the &lt;code&gt;Symbol&lt;/code&gt; corresponding
 * to an object. As &lt;i&gt;sym&lt;/i&gt; is already a symbol, &lt;code&gt;self&lt;/code&gt; is returned
 * in this case.
 */

static VALUE
sym_to_sym(sym)
    VALUE sym;
{
    return sym;
}


static VALUE
sym_call(args, mid)
    VALUE args, mid;
{
    VALUE obj;

    if (RARRAY(args)-&gt;len &lt; 1) {
	rb_raise(rb_eArgError, &quot;no receiver given&quot;);
    }
    obj = rb_ary_shift(args);
    return rb_apply(obj, (ID)mid, args);
}

VALUE rb_proc_new _((VALUE (*)(ANYARGS/* VALUE yieldarg[, VALUE procarg] */), VALUE));

/*
 * call-seq:
 *   sym.to_proc
 *
 * Returns a _Proc_ object which respond to the given method by _sym_.
 *
 *   (1..3).collect(&amp;:to_s)  #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]
 */

static VALUE
sym_to_proc(VALUE sym)
{
    return rb_proc_new(sym_call, (VALUE)SYM2ID(sym));
}


/***********************************************************************
 *
 * Document-class: Module
 *
 *  A &lt;code&gt;Module&lt;/code&gt; is a collection of methods and constants. The
 *  methods in a module may be instance methods or module methods.
 *  Instance methods appear as methods in a class when the module is
 *  included, module methods do not. Conversely, module methods may be
 *  called without creating an encapsulating object, while instance
 *  methods may not. (See &lt;code&gt;Module#module_function&lt;/code&gt;)
 *     
 *  In the descriptions that follow, the parameter &lt;i&gt;syml&lt;/i&gt; refers
 *  to a symbol, which is either a quoted string or a
 *  &lt;code&gt;Symbol&lt;/code&gt; (such as &lt;code&gt;:name&lt;/code&gt;).
 *     
 *     module Mod
 *       include Math
 *       CONST = 1
 *       def meth
 *         #  ...
 *       end
 *     end
 *     Mod.class              #=&gt; Module
 *     Mod.constants          #=&gt; [&quot;E&quot;, &quot;PI&quot;, &quot;CONST&quot;]
 *     Mod.instance_methods   #=&gt; [&quot;meth&quot;]
 *     
 */

/*
 * call-seq:
 *   mod.to_s   =&gt; string
 *
 * Return a string representing this module or class. For basic
 * classes and modules, this is the name. For singletons, we
 * show information on the thing we're attached to as well.
 */

static VALUE
rb_mod_to_s(klass)
    VALUE klass;

{
    if (FL_TEST(klass, FL_SINGLETON)) {
	VALUE s = rb_str_new2(&quot;#&lt;&quot;);
	VALUE v = rb_iv_get(klass, &quot;__attached__&quot;);

	rb_str_cat2(s, &quot;Class:&quot;);
	switch (TYPE(v)) {
	  case T_CLASS: case T_MODULE:
	    rb_str_append(s, rb_inspect(v));
	    break;
	  default:
	    rb_str_append(s, rb_any_to_s(v));
	    break;
	}
	rb_str_cat2(s, &quot;&gt;&quot;);

	return s;
    }
    return rb_str_dup(rb_class_name(klass));
}

/*
 *  call-seq:
 *     mod.freeze
 *  
 *  Prevents further modifications to &lt;i&gt;mod&lt;/i&gt;.
 */

static VALUE
rb_mod_freeze(mod)
    VALUE mod;
{
    rb_mod_to_s(mod);
    return rb_obj_freeze(mod);
}

/*
 *  call-seq:
 *     mod === obj    =&gt; true or false
 *  
 *  Case Equality---Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;anObject&lt;/i&gt; is an
 *  instance of &lt;i&gt;mod&lt;/i&gt; or one of &lt;i&gt;mod&lt;/i&gt;'s descendents. Of
 *  limited use for modules, but can be used in &lt;code&gt;case&lt;/code&gt;
 *  statements to classify objects by class.
 */

static VALUE
rb_mod_eqq(mod, arg)
    VALUE mod, arg;
{
    return rb_obj_is_kind_of(arg, mod);
}

/*
 * call-seq:
 *   mod &lt;= other   =&gt;  true, false, or nil
 *
 * Returns true if &lt;i&gt;mod&lt;/i&gt; is a subclass of &lt;i&gt;other&lt;/i&gt; or
 * is the same as &lt;i&gt;other&lt;/i&gt;. Returns 
 * &lt;code&gt;nil&lt;/code&gt; if there's no relationship between the two. 
 * (Think of the relationship in terms of the class definition: 
 * &quot;class A&lt;B&quot; implies &quot;A&lt;B&quot;).
 *
 */

VALUE
rb_class_inherited_p(mod, arg)
    VALUE mod, arg;
{
    VALUE start = mod;

    if (mod == arg) return Qtrue;
    switch (TYPE(arg)) {
      case T_MODULE:
      case T_CLASS:
	break;
      default:
	rb_raise(rb_eTypeError, &quot;compared with non class/module&quot;);
    }

    if (FL_TEST(mod, FL_SINGLETON)) {
	if (RCLASS(mod)-&gt;m_tbl == RCLASS(arg)-&gt;m_tbl)
	    return Qtrue;
	mod = RBASIC(mod)-&gt;klass;
    }
    while (mod) {
	if (RCLASS(mod)-&gt;m_tbl == RCLASS(arg)-&gt;m_tbl)
	    return Qtrue;
	mod = RCLASS(mod)-&gt;super;
    }
    /* not mod &lt; arg; check if mod &gt; arg */
    while (arg) {
	if (RCLASS(arg)-&gt;m_tbl == RCLASS(start)-&gt;m_tbl)
	    return Qfalse;
	arg = RCLASS(arg)-&gt;super;
    }
    return Qnil;
}

/*
 * call-seq:
 *   mod &lt; other   =&gt;  true, false, or nil
 *
 * Returns true if &lt;i&gt;mod&lt;/i&gt; is a subclass of &lt;i&gt;other&lt;/i&gt;. Returns 
 * &lt;code&gt;nil&lt;/code&gt; if there's no relationship between the two. 
 * (Think of the relationship in terms of the class definition: 
 * &quot;class A&lt;B&quot; implies &quot;A&lt;B&quot;).
 *
 */

static VALUE
rb_mod_lt(mod, arg)
    VALUE mod, arg;
{
    if (mod == arg) return Qfalse;
    return rb_class_inherited_p(mod, arg);
}


/*
 * call-seq:
 *   mod &gt;= other   =&gt;  true, false, or nil
 *
 * Returns true if &lt;i&gt;mod&lt;/i&gt; is an ancestor of &lt;i&gt;other&lt;/i&gt;, or the
 * two modules are the same. Returns 
 * &lt;code&gt;nil&lt;/code&gt; if there's no relationship between the two. 
 * (Think of the relationship in terms of the class definition: 
 * &quot;class A&lt;B&quot; implies &quot;B&gt;A&quot;).
 *
 */

static VALUE
rb_mod_ge(mod, arg)
    VALUE mod, arg;
{
    switch (TYPE(arg)) {
      case T_MODULE:
      case T_CLASS:
	break;
      default:
	rb_raise(rb_eTypeError, &quot;compared with non class/module&quot;);
    }

    return rb_class_inherited_p(arg, mod);
}

/*
 * call-seq:
 *   mod &gt; other   =&gt;  true, false, or nil
 *
 * Returns true if &lt;i&gt;mod&lt;/i&gt; is an ancestor of &lt;i&gt;other&lt;/i&gt;. Returns 
 * &lt;code&gt;nil&lt;/code&gt; if there's no relationship between the two. 
 * (Think of the relationship in terms of the class definition: 
 * &quot;class A&lt;B&quot; implies &quot;B&gt;A&quot;).
 *
 */

static VALUE
rb_mod_gt(mod, arg)
    VALUE mod, arg;
{
    if (mod == arg) return Qfalse;
    return rb_mod_ge(mod, arg);
}

/*
 *  call-seq:
 *     mod &lt;=&gt; other_mod   =&gt; -1, 0, +1, or nil
 *  
 *  Comparison---Returns -1 if &lt;i&gt;mod&lt;/i&gt; includes &lt;i&gt;other_mod&lt;/i&gt;, 0 if
 *  &lt;i&gt;mod&lt;/i&gt; is the same as &lt;i&gt;other_mod&lt;/i&gt;, and +1 if &lt;i&gt;mod&lt;/i&gt; is
 *  included by &lt;i&gt;other_mod&lt;/i&gt; or if &lt;i&gt;mod&lt;/i&gt; has no relationship with
 *  &lt;i&gt;other_mod&lt;/i&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if &lt;i&gt;other_mod&lt;/i&gt; is
 *  not a module.
 */

static VALUE
rb_mod_cmp(mod, arg)
    VALUE mod, arg;
{
    VALUE cmp;

    if (mod == arg) return INT2FIX(0);
    switch (TYPE(arg)) {
      case T_MODULE:
      case T_CLASS:
	break;
      default:
	return Qnil;
    }

    cmp = rb_class_inherited_p(mod, arg);
    if (NIL_P(cmp)) return Qnil;
    if (cmp) {
	return INT2FIX(-1);
    }
    return INT2FIX(1);
}

static VALUE rb_module_s_alloc _((VALUE));
static VALUE
rb_module_s_alloc(klass)
    VALUE klass;
{
    VALUE mod = rb_module_new();

    RBASIC(mod)-&gt;klass = klass;
    return mod;
}

static VALUE rb_class_s_alloc _((VALUE));
static VALUE
rb_class_s_alloc(klass)
    VALUE klass;
{
    return rb_class_boot(0);
}

/*
 *  call-seq:
 *    Module.new                  =&gt; mod
 *    Module.new {|mod| block }   =&gt; mod
 *  
 *  Creates a new anonymous module. If a block is given, it is passed
 *  the module object, and the block is evaluated in the context of this
 *  module using &lt;code&gt;module_eval&lt;/code&gt;.
 *     
 *     Fred = Module.new do
 *       def meth1
 *         &quot;hello&quot;
 *       end
 *       def meth2
 *         &quot;bye&quot;
 *       end
 *     end
 *     a = &quot;my string&quot;
 *     a.extend(Fred)   #=&gt; &quot;my string&quot;
 *     a.meth1          #=&gt; &quot;hello&quot;
 *     a.meth2          #=&gt; &quot;bye&quot;
 */

static VALUE
rb_mod_initialize(module)
    VALUE module;
{
    if (rb_block_given_p()) {
	rb_mod_module_eval(0, 0, module);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     Class.new(super_class=Object)   =&gt;    a_class
 *  
 *  Creates a new anonymous (unnamed) class with the given superclass
 *  (or &lt;code&gt;Object&lt;/code&gt; if no parameter is given). You can give a
 *  class a name by assigning the class object to a constant.
 *     
 */

static VALUE
rb_class_initialize(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE super;

    if (RCLASS(klass)-&gt;super != 0) {
	rb_raise(rb_eTypeError, &quot;already initialized class&quot;);
    }
    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;super) == 0) {
	super = rb_cObject;
    }
    else {
	rb_check_inheritable(super);
    }
    RCLASS(klass)-&gt;super = super;
    rb_make_metaclass(klass, RBASIC(super)-&gt;klass);
    rb_mod_initialize(klass);
    rb_class_inherited(super, klass);

    return klass;
}

/*
 *  call-seq:
 *     class.allocate()   =&gt;   obj
 *  
 *  Allocates space for a new object of &lt;i&gt;class&lt;/i&gt;'s class and does not
 *  call initialize on the new instance. The returned object must be an
 *  instance of &lt;i&gt;class&lt;/i&gt;.
 *  
 *      klass = Class.new do
 *        def initialize(*args)
 *          @initialized = true
 *        end
 *      
 *        def initialized?
 *          @initialized || false
 *        end
 *      end
 *      
 *      klass.allocate.initialized? #=&gt; false
 *     
 */

VALUE
rb_obj_alloc(klass)
    VALUE klass;
{
    VALUE obj;

    if (RCLASS(klass)-&gt;super == 0) {
	rb_raise(rb_eTypeError, &quot;can't instantiate uninitialized class&quot;);
    }
    if (FL_TEST(klass, FL_SINGLETON)) {
	rb_raise(rb_eTypeError, &quot;can't create instance of virtual class&quot;);
    }
    obj = rb_funcall(klass, ID_ALLOCATOR, 0, 0);
    if (rb_obj_class(obj) != rb_class_real(klass)) {
	rb_raise(rb_eTypeError, &quot;wrong instance allocation&quot;);
    }
    return obj;
}

static VALUE rb_class_allocate_instance _((VALUE));
static VALUE
rb_class_allocate_instance(klass)
    VALUE klass;
{
    NEWOBJ(obj, struct RObject);
    OBJSETUP(obj, klass, T_OBJECT);
    return (VALUE)obj;
}

/*
 *  call-seq:
 *     class.new(args, ...)    =&gt;  obj
 *  
 *  Calls &lt;code&gt;allocate&lt;/code&gt; to create a new object of
 *  &lt;i&gt;class&lt;/i&gt;'s class, then invokes that object's
 *  &lt;code&gt;initialize&lt;/code&gt; method, passing it &lt;i&gt;args&lt;/i&gt;.
 *  This is the method that ends up getting called whenever
 *  an object is constructed using .new.
 *     
 */

VALUE
rb_class_new_instance(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE obj;

    obj = rb_obj_alloc(klass);
    rb_obj_call_init(obj, argc, argv);

    return obj;
}

/*
 *  call-seq:
 *     class.superclass -&gt; a_super_class or nil
 *  
 *  Returns the superclass of &lt;i&gt;class&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt;.
 *     
 *     File.superclass     #=&gt; IO
 *     IO.superclass       #=&gt; Object
 *     Object.superclass   #=&gt; nil
 *     
 */

static VALUE
rb_class_superclass(klass)
    VALUE klass;
{
    VALUE super = RCLASS(klass)-&gt;super;

    if (!super) {
	rb_raise(rb_eTypeError, &quot;uninitialized class&quot;);
    }
    if (FL_TEST(klass, FL_SINGLETON)) {
	super = RBASIC(klass)-&gt;klass;
    }
    while (TYPE(super) == T_ICLASS) {
	super = RCLASS(super)-&gt;super;
    }
    if (!super) {
	return Qnil;
    }
    return super;
}

static ID
str_to_id(str)
    VALUE str;
{
    VALUE sym = rb_str_intern(str);

    return SYM2ID(sym);
}

ID
rb_to_id(name)
    VALUE name;
{
    VALUE tmp;
    ID id;

    switch (TYPE(name)) {
      case T_STRING:
	return str_to_id(name);
      case T_FIXNUM:
	rb_warn(&quot;do not use Fixnums as Symbols&quot;);
	id = FIX2LONG(name);
	if (!rb_id2name(id)) {
	    rb_raise(rb_eArgError, &quot;%ld is not a symbol&quot;, id);
	}
	break;
      case T_SYMBOL:
	id = SYM2ID(name);
	break;
      default:
	tmp = rb_check_string_type(name);
	if (!NIL_P(tmp)) {
	    return str_to_id(tmp);
	}
	rb_raise(rb_eTypeError, &quot;%s is not a symbol&quot;, RSTRING(rb_inspect(name))-&gt;ptr);
    }
    return id;
}

/*
 *  call-seq:
 *     attr(symbol, writable=false)    =&gt; nil
 *  
 *  Defines a named attribute for this module, where the name is
 *  &lt;i&gt;symbol.&lt;/i&gt;&lt;code&gt;id2name&lt;/code&gt;, creating an instance variable
 *  (&lt;code&gt;@name&lt;/code&gt;) and a corresponding access method to read it.
 *  If the optional &lt;i&gt;writable&lt;/i&gt; argument is &lt;code&gt;true&lt;/code&gt;, also
 *  creates a method called &lt;code&gt;name=&lt;/code&gt; to set the attribute.
 *     
 *     module Mod
 *       attr  :size, true
 *     end
 *     
 *  &lt;em&gt;is equivalent to:&lt;/em&gt;
 *     
 *     module Mod
 *       def size
 *         @size
 *       end
 *       def size=(val)
 *         @size = val
 *       end
 *     end
 */

static VALUE
rb_mod_attr(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE name, pub;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;name, &amp;pub);
    rb_attr(klass, rb_to_id(name), 1, RTEST(pub), Qtrue);
    return Qnil;
}

/*
 *  call-seq:
 *     attr_reader(symbol, ...)    =&gt; nil
 *  
 *  Creates instance variables and corresponding methods that return the
 *  value of each instance variable. Equivalent to calling
 *  ``&lt;code&gt;attr&lt;/code&gt;&lt;i&gt;:name&lt;/i&gt;'' on each name in turn.
 */

static VALUE
rb_mod_attr_reader(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    int i;

    for (i=0; i&lt;argc; i++) {
	rb_attr(klass, rb_to_id(argv[i]), 1, 0, Qtrue);
    }
    return Qnil;
}

/*
 *  call-seq:
 *      attr_writer(symbol, ...)    =&gt; nil
 *  
 *  Creates an accessor method to allow assignment to the attribute
 *  &lt;i&gt;aSymbol&lt;/i&gt;&lt;code&gt;.id2name&lt;/code&gt;.
 */

static VALUE
rb_mod_attr_writer(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    int i;

    for (i=0; i&lt;argc; i++) {
	rb_attr(klass, rb_to_id(argv[i]), 0, 1, Qtrue);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     attr_accessor(symbol, ...)    =&gt; nil
 *  
 *  Equivalent to calling ``&lt;code&gt;attr&lt;/code&gt;&lt;i&gt;symbol&lt;/i&gt;&lt;code&gt;,
 *  true&lt;/code&gt;'' on each &lt;i&gt;symbol&lt;/i&gt; in turn.
 *     
 *     module Mod
 *       attr_accessor(:one, :two)
 *     end
 *     Mod.instance_methods.sort   #=&gt; [&quot;one&quot;, &quot;one=&quot;, &quot;two&quot;, &quot;two=&quot;]
 */

static VALUE
rb_mod_attr_accessor(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    int i;

    for (i=0; i&lt;argc; i++) {
	rb_attr(klass, rb_to_id(argv[i]), 1, 1, Qtrue);
    }
    return Qnil;
}

/*
 *  call-seq:
 *     mod.const_get(sym)    =&gt; obj
 *  
 *  Returns the value of the named constant in &lt;i&gt;mod&lt;/i&gt;.
 *     
 *     Math.const_get(:PI)   #=&gt; 3.14159265358979
 */

static VALUE
rb_mod_const_get(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);

    if (!rb_is_const_id(id)) {
	rb_name_error(id, &quot;wrong constant name %s&quot;, rb_id2name(id));
    }
    return rb_const_get(mod, id);
}

/*
 *  call-seq:
 *     mod.const_set(sym, obj)    =&gt; obj
 *  
 *  Sets the named constant to the given object, returning that object.
 *  Creates a new constant if no constant with the given name previously
 *  existed.
 *     
 *     Math.const_set(&quot;HIGH_SCHOOL_PI&quot;, 22.0/7.0)   #=&gt; 3.14285714285714
 *     Math::HIGH_SCHOOL_PI - Math::PI              #=&gt; 0.00126448926734968
 */

static VALUE
rb_mod_const_set(mod, name, value)
    VALUE mod, name, value;
{
    ID id = rb_to_id(name);

    if (!rb_is_const_id(id)) {
	rb_name_error(id, &quot;wrong constant name %s&quot;, rb_id2name(id));
    }
    rb_const_set(mod, id, value);
    return value;
}

/*
 *  call-seq:
 *     mod.const_defined?(sym)   =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if a constant with the given name is
 *  defined by &lt;i&gt;mod&lt;/i&gt;.
 *     
 *     Math.const_defined? &quot;PI&quot;   #=&gt; true
 */

static VALUE
rb_mod_const_defined(mod, name)
    VALUE mod, name;
{
    ID id = rb_to_id(name);

    if (!rb_is_const_id(id)) {
	rb_name_error(id, &quot;wrong constant name %s&quot;, rb_id2name(id));
    }
    return rb_const_defined_at(mod, id);
}

/*
 *  call-seq:
 *     obj.methods    =&gt; array
 *  
 *  Returns a list of the names of methods publicly accessible in
 *  &lt;i&gt;obj&lt;/i&gt;. This will include all the methods accessible in
 *  &lt;i&gt;obj&lt;/i&gt;'s ancestors.
 *     
 *     class Klass
 *       def kMethod()
 *       end
 *     end
 *     k = Klass.new
 *     k.methods[0..9]    #=&gt; [&quot;kMethod&quot;, &quot;freeze&quot;, &quot;nil?&quot;, &quot;is_a?&quot;, 
 *                             &quot;class&quot;, &quot;instance_variable_set&quot;,
 *                              &quot;methods&quot;, &quot;extend&quot;, &quot;__send__&quot;, &quot;instance_eval&quot;]
 *     k.methods.length   #=&gt; 42
 */

static VALUE
rb_obj_methods(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
  retry:
    if (argc == 0) {
	VALUE args[1];

	args[0] = Qtrue;
	return rb_class_instance_methods(1, args, CLASS_OF(obj));
    }
    else {
	VALUE recur;

	rb_scan_args(argc, argv, &quot;1&quot;, &amp;recur);
	if (RTEST(recur)) {
	    argc = 0;
	    goto retry;
	}
	return rb_obj_singleton_methods(argc, argv, obj);
    }
}

/*
 *  call-seq:
 *     obj.protected_methods(all=true)   =&gt; array
 *  
 *  Returns the list of protected methods accessible to &lt;i&gt;obj&lt;/i&gt;. If
 *  the &lt;i&gt;all&lt;/i&gt; parameter is set to &lt;code&gt;false&lt;/code&gt;, only those methods
 *  in the receiver will be listed.
 */

static VALUE
rb_obj_protected_methods(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    if (argc == 0) {		/* hack to stop warning */
	VALUE args[1];

	args[0] = Qtrue;
	return rb_class_protected_instance_methods(1, args, CLASS_OF(obj));
    }
    return rb_class_protected_instance_methods(argc, argv, CLASS_OF(obj));
}

/*
 *  call-seq:
 *     obj.private_methods(all=true)   =&gt; array
 *  
 *  Returns the list of private methods accessible to &lt;i&gt;obj&lt;/i&gt;. If
 *  the &lt;i&gt;all&lt;/i&gt; parameter is set to &lt;code&gt;false&lt;/code&gt;, only those methods
 *  in the receiver will be listed.
 */

static VALUE
rb_obj_private_methods(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    if (argc == 0) {		/* hack to stop warning */
	VALUE args[1];

	args[0] = Qtrue;
	return rb_class_private_instance_methods(1, args, CLASS_OF(obj));
    }
    return rb_class_private_instance_methods(argc, argv, CLASS_OF(obj));
}

/*
 *  call-seq:
 *     obj.public_methods(all=true)   =&gt; array
 *  
 *  Returns the list of public methods accessible to &lt;i&gt;obj&lt;/i&gt;. If
 *  the &lt;i&gt;all&lt;/i&gt; parameter is set to &lt;code&gt;false&lt;/code&gt;, only those methods
 *  in the receiver will be listed.
 */

static VALUE
rb_obj_public_methods(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    if (argc == 0) {		/* hack to stop warning */
	VALUE args[1];

	args[0] = Qtrue;
	return rb_class_public_instance_methods(1, args, CLASS_OF(obj));
    }
    return rb_class_public_instance_methods(argc, argv, CLASS_OF(obj));
}

/*
 *  call-seq:
 *     obj.instance_variable_get(symbol)    =&gt; obj
 *
 *  Returns the value of the given instance variable, or nil if the
 *  instance variable is not set. The &lt;code&gt;@&lt;/code&gt; part of the
 *  variable name should be included for regular instance
 *  variables. Throws a &lt;code&gt;NameError&lt;/code&gt; exception if the
 *  supplied symbol is not valid as an instance variable name.
 *     
 *     class Fred
 *       def initialize(p1, p2)
 *         @a, @b = p1, p2
 *       end
 *     end
 *     fred = Fred.new('cat', 99)
 *     fred.instance_variable_get(:@a)    #=&gt; &quot;cat&quot;
 *     fred.instance_variable_get(&quot;@b&quot;)   #=&gt; 99
 */

static VALUE
rb_obj_ivar_get(obj, iv)
    VALUE obj, iv;
{
    ID id = rb_to_id(iv);

    if (!rb_is_instance_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as an instance variable name&quot;, rb_id2name(id));
    }
    return rb_ivar_get(obj, id);
}

/*
 *  call-seq:
 *     obj.instance_variable_set(symbol, obj)    =&gt; obj
 *  
 *  Sets the instance variable names by &lt;i&gt;symbol&lt;/i&gt; to
 *  &lt;i&gt;object&lt;/i&gt;, thereby frustrating the efforts of the class's
 *  author to attempt to provide proper encapsulation. The variable
 *  did not have to exist prior to this call.
 *     
 *     class Fred
 *       def initialize(p1, p2)
 *         @a, @b = p1, p2
 *       end
 *     end
 *     fred = Fred.new('cat', 99)
 *     fred.instance_variable_set(:@a, 'dog')   #=&gt; &quot;dog&quot;
 *     fred.instance_variable_set(:@c, 'cat')   #=&gt; &quot;cat&quot;
 *     fred.inspect                             #=&gt; &quot;#&lt;Fred:0x401b3da8 @a=\&quot;dog\&quot;, @b=99, @c=\&quot;cat\&quot;&gt;&quot;
 */

static VALUE
rb_obj_ivar_set(obj, iv, val)
    VALUE obj, iv, val;
{
    ID id = rb_to_id(iv);

    if (!rb_is_instance_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as an instance variable name&quot;, rb_id2name(id));
    }
    return rb_ivar_set(obj, id, val);
}

/*
 *  call-seq:
 *     obj.instance_variable_defined?(symbol)    =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if the given instance variable is
 *  defined in &lt;i&gt;obj&lt;/i&gt;.
 *
 *     class Fred
 *       def initialize(p1, p2)
 *         @a, @b = p1, p2
 *       end
 *     end
 *     fred = Fred.new('cat', 99)
 *     fred.instance_variable_defined?(:@a)    #=&gt; true
 *     fred.instance_variable_defined?(&quot;@b&quot;)   #=&gt; true
 *     fred.instance_variable_defined?(&quot;@c&quot;)   #=&gt; false
 */

static VALUE
rb_obj_ivar_defined(obj, iv)
    VALUE obj, iv;
{
    ID id = rb_to_id(iv);

    if (!rb_is_instance_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as an instance variable name&quot;, rb_id2name(id));
    }
    return rb_ivar_defined(obj, id);
}

/*
 *  call-seq:
 *     mod.class_variable_get(symbol)    =&gt; obj
 *  
 *  Returns the value of the given class variable (or throws a
 *  &lt;code&gt;NameError&lt;/code&gt; exception). The &lt;code&gt;@@&lt;/code&gt; part of the
 *  variable name should be included for regular class variables
 *     
 *     class Fred
 *       @@foo = 99
 *     end
 *
 *     def Fred.foo
 *       class_variable_get(:@@foo)     #=&gt; 99
 *     end
 */

static VALUE
rb_mod_cvar_get(obj, iv)
    VALUE obj, iv;
{
    ID id = rb_to_id(iv);

    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as a class variable name&quot;, rb_id2name(id));
    }
    return rb_cvar_get(obj, id);
}

/*
 *  call-seq:
 *     obj.class_variable_set(symbol, obj)    =&gt; obj
 *  
 *  Sets the class variable names by &lt;i&gt;symbol&lt;/i&gt; to
 *  &lt;i&gt;object&lt;/i&gt;.
 *     
 *     class Fred
 *       @@foo = 99
 *       def foo
 *         @@foo
 *       end
 *     end
 *
 *     def Fred.foo
 *       class_variable_set(:@@foo, 101)      #=&gt; 101
 *     end
 *     Fred.foo
 *     Fred.new.foo                             #=&gt; 101
 */

static VALUE
rb_mod_cvar_set(obj, iv, val)
    VALUE obj, iv, val;
{
    ID id = rb_to_id(iv);

    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as a class variable name&quot;, rb_id2name(id));
    }
    rb_cvar_set(obj, id, val, Qfalse);
    return val;
}

/*
 *  call-seq:
 *     obj.class_variable_defined?(symbol)    =&gt; true or false
 *
 *  Returns &lt;code&gt;true&lt;/code&gt; if the given class variable is defined
 *  in &lt;i&gt;obj&lt;/i&gt;.
 *
 *     class Fred
 *       @@foo = 99
 *     end
 *     Fred.class_variable_defined?(:@@foo)    #=&gt; true
 *     Fred.class_variable_defined?(:@@bar)    #=&gt; false
 */

static VALUE
rb_mod_cvar_defined(obj, iv)
    VALUE obj, iv;
{
    ID id = rb_to_id(iv);

    if (!rb_is_class_id(id)) {
	rb_name_error(id, &quot;`%s' is not allowed as a class variable name&quot;, rb_id2name(id));
    }
    return rb_cvar_defined(obj, id);
}

static VALUE
convert_type(val, tname, method, raise)
    VALUE val;
    const char *tname, *method;
    int raise;
{
    ID m;

    m = rb_intern(method);
    if (!rb_obj_respond_to(val, m, Qtrue)) {
	if (raise) {
	    rb_raise(rb_eTypeError, &quot;can't convert %s into %s&quot;,
		     NIL_P(val) ? &quot;nil&quot; :
		     val == Qtrue ? &quot;true&quot; :
		     val == Qfalse ? &quot;false&quot; :
		     rb_obj_classname(val), 
		     tname);
	}
	else {
	    return Qnil;
	}
    }
    return rb_funcall(val, m, 0);
}

VALUE
rb_convert_type(val, type, tname, method)
    VALUE val;
    int type;
    const char *tname, *method;
{
    VALUE v;

    if (TYPE(val) == type) return val;
    v = convert_type(val, tname, method, Qtrue);
    if (TYPE(v) != type) {
	rb_raise(rb_eTypeError, &quot;%s#%s should return %s&quot;,
		 rb_obj_classname(val), method, tname);
    }
    return v;
}

VALUE
rb_check_convert_type(val, type, tname, method)
    VALUE val;
    int type;
    const char *tname, *method;
{
    VALUE v;

    /* always convert T_DATA */
    if (TYPE(val) == type &amp;&amp; type != T_DATA) return val;
    v = convert_type(val, tname, method, Qfalse);
    if (NIL_P(v)) return Qnil;
    if (TYPE(v) != type) {
	rb_raise(rb_eTypeError, &quot;%s#%s should return %s&quot;,
		 rb_obj_classname(val), method, tname);
    }
    return v;
}


static VALUE
rb_to_integer(val, method)
    VALUE val;
    const char *method;
{
    VALUE v = convert_type(val, &quot;Integer&quot;, method, Qtrue);
    if (!rb_obj_is_kind_of(v, rb_cInteger)) {
	rb_raise(rb_eTypeError, &quot;%s#%s should return Integer&quot;,
		 rb_obj_classname(val), method);
    }
    return v;
}

VALUE
rb_check_to_integer(VALUE val, const char *method)
{
    VALUE v;

    if (FIXNUM_P(val)) return val;
    v = convert_type(val, &quot;Integer&quot;, method, Qfalse);
    if (!rb_obj_is_kind_of(v, rb_cInteger)) {
	return Qnil;
    }
    return v;
}

VALUE
rb_to_int(val)
    VALUE val;
{
    return rb_to_integer(val, &quot;to_int&quot;);
}

VALUE
rb_Integer(val)
    VALUE val;
{
    VALUE tmp;

    switch (TYPE(val)) {
      case T_FLOAT:
	if (RFLOAT(val)-&gt;value &lt;= (double)FIXNUM_MAX
	    &amp;&amp; RFLOAT(val)-&gt;value &gt;= (double)FIXNUM_MIN) {
	    break;
	}
	return rb_dbl2big(RFLOAT(val)-&gt;value);

      case T_FIXNUM:
      case T_BIGNUM:
	return val;

      case T_STRING:
	return rb_str_to_inum(val, 0, Qtrue);

      default:
	break;
    }
    tmp = convert_type(val, &quot;Integer&quot;, &quot;to_int&quot;, Qfalse);
    if (NIL_P(tmp)) {
	return rb_to_integer(val, &quot;to_i&quot;);
    }
    return tmp;
}

/*
 *  call-seq:
 *     Integer(arg)    =&gt; integer
 *  
 *  Converts &lt;i&gt;arg&lt;/i&gt; to a &lt;code&gt;Fixnum&lt;/code&gt; or &lt;code&gt;Bignum&lt;/code&gt;.
 *  Numeric types are converted directly (with floating point numbers
 *  being truncated). If &lt;i&gt;arg&lt;/i&gt; is a &lt;code&gt;String&lt;/code&gt;, leading
 *  radix indicators (&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0b&lt;/code&gt;, and
 *  &lt;code&gt;0x&lt;/code&gt;) are honored. Others are converted using
 *  &lt;code&gt;to_int&lt;/code&gt; and &lt;code&gt;to_i&lt;/code&gt;. This behavior is
 *  different from that of &lt;code&gt;String#to_i&lt;/code&gt;.
 *     
 *     Integer(123.999)    #=&gt; 123
 *     Integer(&quot;0x1a&quot;)     #=&gt; 26
 *     Integer(Time.new)   #=&gt; 1049896590
 */

static VALUE
rb_f_integer(obj, arg)
    VALUE obj, arg;
{
    return rb_Integer(arg);
}

double
rb_cstr_to_dbl(p, badcheck)
    const char *p;
    int badcheck;
{
    const char *q;
    char *end;
    double d;
    const char *ellipsis = &quot;&quot;;
    int w;
#define OutOfRange() (((w = end - p) &gt; 20) ? (w = 20, ellipsis = &quot;...&quot;) : (ellipsis = &quot;&quot;))

    if (!p) return 0.0;
    q = p;
    if (badcheck) {
	while (ISSPACE(*p)) p++;
    }
    else {
	while (ISSPACE(*p) || *p == '_') p++;
    }
    errno = 0;
    d = strtod(p, &amp;end);
    if (errno == ERANGE) {
	OutOfRange();
	rb_warn(&quot;Float %.*s%s out of range&quot;, w, p, ellipsis);
	errno = 0;
    }
    if (p == end) {
	if (badcheck) {
	  bad:
	    rb_invalid_str(q, &quot;Float()&quot;);
	}
	return d;
    }
    if (*end) {
	char *buf = ALLOCA_N(char, strlen(p)+1);
	char *n = buf;

	while (p &lt; end) *n++ = *p++;
	while (*p) {
	    if (*p == '_') {
		/* remove underscores between digits */
		if (badcheck) {
		    if (n == buf || !ISDIGIT(n[-1])) goto bad;
		    ++p;
		    if (!ISDIGIT(*p)) goto bad;
		}
		else {
		    while (*++p == '_');
		    continue;
		}
	    }
	    *n++ = *p++;
	}
	*n = '\0';
	p = buf;
	d = strtod(p, &amp;end);
	if (errno == ERANGE) {
	    OutOfRange();
	    rb_warn(&quot;Float %.*s%s out of range&quot;, w, p, ellipsis);
	    errno = 0;
	}
	if (badcheck) {
	    if (!end || p == end) goto bad;
	    while (*end &amp;&amp; ISSPACE(*end)) end++;
	    if (*end) goto bad;
	}
    }
    if (errno == ERANGE) {
	errno = 0;
	OutOfRange();
	rb_raise(rb_eArgError, &quot;Float %.*s%s out of range&quot;, w, q, ellipsis);
    }
    return d;
}

double
rb_str_to_dbl(str, badcheck)
    VALUE str;
    int badcheck;
{
    char *s;
    long len;

    StringValue(str);
    s = RSTRING(str)-&gt;ptr;
    len = RSTRING(str)-&gt;len;
    if (s) {
	if (s[len]) {		/* no sentinel somehow */
	    char *p = ALLOCA_N(char, len+1);

	    MEMCPY(p, s, char, len);
	    p[len] = '\0';
	    s = p;
	}
	if (badcheck &amp;&amp; len != strlen(s)) {
	    rb_raise(rb_eArgError, &quot;string for Float contains null byte&quot;);
	}
    }
    return rb_cstr_to_dbl(s, badcheck);
}

VALUE
rb_Float(val)
    VALUE val;
{
    switch (TYPE(val)) {
      case T_FIXNUM:
	return rb_float_new((double)FIX2LONG(val));

      case T_FLOAT:
	return val;

      case T_BIGNUM:
	return rb_float_new(rb_big2dbl(val));

      case T_STRING:
	return rb_float_new(rb_str_to_dbl(val, Qtrue));

      case T_NIL:
	rb_raise(rb_eTypeError, &quot;can't convert nil into Float&quot;);
	break;

      default:
      {
	  VALUE f = rb_convert_type(val, T_FLOAT, &quot;Float&quot;, &quot;to_f&quot;);
	  if (isnan(RFLOAT(f)-&gt;value)) {
	      rb_raise(rb_eArgError, &quot;invalid value for Float()&quot;);
	  }
	  return f;
      }
    }
}

/*
 *  call-seq:
 *     Float(arg)    =&gt; float
 *  
 *  Returns &lt;i&gt;arg&lt;/i&gt; converted to a float. Numeric types are converted
 *  directly, the rest are converted using &lt;i&gt;arg&lt;/i&gt;.to_f. As of Ruby
 *  1.8, converting &lt;code&gt;nil&lt;/code&gt; generates a &lt;code&gt;TypeError&lt;/code&gt;.
 *     
 *     Float(1)           #=&gt; 1.0
 *     Float(&quot;123.456&quot;)   #=&gt; 123.456
 */

static VALUE
rb_f_float(obj, arg)
    VALUE obj, arg;
{
    return rb_Float(arg);
}

double
rb_num2dbl(val)
    VALUE val;
{
    switch (TYPE(val)) {
      case T_FLOAT:
	return RFLOAT(val)-&gt;value;

      case T_STRING:
	rb_raise(rb_eTypeError, &quot;no implicit conversion to float from string&quot;);
	break;

      case T_NIL:
	rb_raise(rb_eTypeError, &quot;no implicit conversion to float from nil&quot;);
	break;

      default:
	break;
    }

    return RFLOAT(rb_Float(val))-&gt;value;
}

char*
rb_str2cstr(str, len)
    VALUE str;
    long *len;
{
    StringValue(str);
    if (len) *len = RSTRING(str)-&gt;len;
    else if (RTEST(ruby_verbose) &amp;&amp; RSTRING(str)-&gt;len != strlen(RSTRING(str)-&gt;ptr)) {
	rb_warn(&quot;string contains \\0 character&quot;);
    }
    return RSTRING(str)-&gt;ptr;
}

VALUE
rb_String(val)
    VALUE val;
{
    return rb_convert_type(val, T_STRING, &quot;String&quot;, &quot;to_s&quot;);
}


/*
 *  call-seq:
 *     String(arg)   =&gt; string
 *  
 *  Converts &lt;i&gt;arg&lt;/i&gt; to a &lt;code&gt;String&lt;/code&gt; by calling its
 *  &lt;code&gt;to_s&lt;/code&gt; method.
 *     
 *     String(self)        #=&gt; &quot;main&quot;
 *     String(self.class   #=&gt; &quot;Object&quot;
 *     String(123456)      #=&gt; &quot;123456&quot;
 */

static VALUE
rb_f_string(obj, arg)
    VALUE obj, arg;
{
    return rb_String(arg);
}

#if 0
VALUE
rb_Array(val)
    VALUE val;
{
    VALUE tmp = rb_check_array_type(val);

    if (NIL_P(tmp)) {
	tmp = rb_check_convert_type(val, T_ARRAY, &quot;Array&quot;, &quot;to_a&quot;);
	if (NIL_P(tmp)) {
	    return rb_ary_new3(1, val);
	}
    }
    return tmp;
}
#endif

/*
 *  call-seq:
 *     Array(arg)    =&gt; array
 *  
 *  Returns &lt;i&gt;arg&lt;/i&gt; as an &lt;code&gt;Array&lt;/code&gt;. First tries to call
 *  &lt;i&gt;arg&lt;/i&gt;&lt;code&gt;.to_ary&lt;/code&gt;, then &lt;i&gt;arg&lt;/i&gt;&lt;code&gt;.to_a&lt;/code&gt;.
 *  If both fail, creates a single element array containing &lt;i&gt;arg&lt;/i&gt;
 *  (unless &lt;i&gt;arg&lt;/i&gt; is &lt;code&gt;nil&lt;/code&gt;).
 *     
 *     Array(1..5)   #=&gt; [1, 2, 3, 4, 5]
 */

static VALUE
rb_f_array(obj, arg)
    VALUE obj, arg;
{
    return rb_Array(arg);
}

static VALUE
boot_defclass(name, super)
    char *name;
    VALUE super;
{
    extern st_table *rb_class_tbl;
    VALUE obj = rb_class_boot(super);
    ID id = rb_intern(name);

    rb_name_class(obj, id);
    st_add_direct(rb_class_tbl, id, obj);
    rb_const_set((rb_cObject ? rb_cObject : obj), id, obj);
    return obj;
}

VALUE ruby_top_self;

/*
 *  Document-class: Class
 *
 *  Classes in Ruby are first-class objects---each is an instance of
 *  class &lt;code&gt;Class&lt;/code&gt;.
 *     
 *  When a new class is created (typically using &lt;code&gt;class Name ...
 *  end&lt;/code&gt;), an object of type &lt;code&gt;Class&lt;/code&gt; is created and
 *  assigned to a global constant (&lt;code&gt;Name&lt;/code&gt; in this case). When
 *  &lt;code&gt;Name.new&lt;/code&gt; is called to create a new object, the
 *  &lt;code&gt;new&lt;/code&gt; method in &lt;code&gt;Class&lt;/code&gt; is run by default.
 *  This can be demonstrated by overriding &lt;code&gt;new&lt;/code&gt; in
 *  &lt;code&gt;Class&lt;/code&gt;:
 *     
 *     class Class
 *        alias oldNew  new
 *        def new(*args)
 *          print &quot;Creating a new &quot;, self.name, &quot;\n&quot;
 *          oldNew(*args)
 *        end
 *      end
 *     
 *     
 *      class Name
 *      end
 *     
 *     
 *      n = Name.new
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Creating a new Name
 *     
 *  Classes, modules, and objects are interrelated. In the diagram
 *  that follows, the vertical arrows represent inheritance, and the
 *  parentheses meta-classes. All metaclasses are instances 
 *  of the class `Class'.
 *
 *                            +------------------+
 *                            |                  |
 *              Object----&gt;(Object)              |
 *               ^  ^        ^  ^                |
 *               |  |        |  |                |
 *               |  |  +-----+  +---------+      |
 *               |  |  |                  |      |
 *               |  +-----------+         |      |
 *               |     |        |         |      |
 *        +------+     |     Module---&gt;(Module)  |
 *        |            |        ^         ^      |
 *   OtherClass--&gt;(OtherClass)  |         |      |
 *                              |         |      |
 *                            Class----&gt;(Class)  |
 *                              ^                |
 *                              |                |
 *                              +----------------+
 */


/*
 *  &lt;code&gt;Object&lt;/code&gt; is the parent class of all classes in Ruby. Its
 *  methods are therefore available to all objects unless explicitly
 *  overridden.
 *     
 *  &lt;code&gt;Object&lt;/code&gt; mixes in the &lt;code&gt;Kernel&lt;/code&gt; module, making
 *  the built-in kernel functions globally accessible. Although the
 *  instance methods of &lt;code&gt;Object&lt;/code&gt; are defined by the
 *  &lt;code&gt;Kernel&lt;/code&gt; module, we have chosen to document them here for
 *  clarity.
 *     
 *  In the descriptions of Object's methods, the parameter &lt;i&gt;symbol&lt;/i&gt; refers
 *  to a symbol, which is either a quoted string or a
 *  &lt;code&gt;Symbol&lt;/code&gt; (such as &lt;code&gt;:name&lt;/code&gt;).
 */

void
Init_Object()
{
    VALUE metaclass;

    rb_cObject = boot_defclass(&quot;Object&quot;, 0);
    rb_cModule = boot_defclass(&quot;Module&quot;, rb_cObject);
    rb_cClass =  boot_defclass(&quot;Class&quot;,  rb_cModule);

    metaclass = rb_make_metaclass(rb_cObject, rb_cClass);
    metaclass = rb_make_metaclass(rb_cModule, metaclass);
    metaclass = rb_make_metaclass(rb_cClass, metaclass);

    rb_mKernel = rb_define_module(&quot;Kernel&quot;);
    rb_include_module(rb_cObject, rb_mKernel);
    rb_define_alloc_func(rb_cObject, rb_class_allocate_instance);
    rb_define_private_method(rb_cObject, &quot;initialize&quot;, rb_obj_dummy, 0);
    rb_define_private_method(rb_cClass, &quot;inherited&quot;, rb_obj_dummy, 1);
    rb_define_private_method(rb_cModule, &quot;included&quot;, rb_obj_dummy, 1);
    rb_define_private_method(rb_cModule, &quot;extended&quot;, rb_obj_dummy, 1);
    rb_define_private_method(rb_cModule, &quot;method_added&quot;, rb_obj_dummy, 1);
    rb_define_private_method(rb_cModule, &quot;method_removed&quot;, rb_obj_dummy, 1);
    rb_define_private_method(rb_cModule, &quot;method_undefined&quot;, rb_obj_dummy, 1);


    rb_define_method(rb_mKernel, &quot;nil?&quot;, rb_false, 0);
    rb_define_method(rb_mKernel, &quot;==&quot;, rb_obj_equal, 1);
    rb_define_method(rb_mKernel, &quot;equal?&quot;, rb_obj_equal, 1);
    rb_define_method(rb_mKernel, &quot;===&quot;, rb_equal, 1); 
    rb_define_method(rb_mKernel, &quot;=~&quot;, rb_obj_pattern_match, 1);

    rb_define_method(rb_mKernel, &quot;eql?&quot;, rb_obj_equal, 1);

    rb_define_method(rb_mKernel, &quot;id&quot;, rb_obj_id_obsolete, 0);
    rb_define_method(rb_mKernel, &quot;type&quot;, rb_obj_type, 0);
    rb_define_method(rb_mKernel, &quot;class&quot;, rb_obj_class, 0);

    rb_define_method(rb_mKernel, &quot;clone&quot;, rb_obj_clone, 0);
    rb_define_method(rb_mKernel, &quot;dup&quot;, rb_obj_dup, 0);
    rb_define_method(rb_mKernel, &quot;initialize_copy&quot;, rb_obj_init_copy, 1);

    rb_define_method(rb_mKernel, &quot;taint&quot;, rb_obj_taint, 0);
    rb_define_method(rb_mKernel, &quot;tainted?&quot;, rb_obj_tainted, 0);
    rb_define_method(rb_mKernel, &quot;untaint&quot;, rb_obj_untaint, 0);
    rb_define_method(rb_mKernel, &quot;freeze&quot;, rb_obj_freeze, 0);
    rb_define_method(rb_mKernel, &quot;frozen?&quot;, rb_obj_frozen_p, 0);

    rb_define_method(rb_mKernel, &quot;to_a&quot;, rb_any_to_a, 0); /* to be removed */
    rb_define_method(rb_mKernel, &quot;to_s&quot;, rb_any_to_s, 0);
    rb_define_method(rb_mKernel, &quot;inspect&quot;, rb_obj_inspect, 0);
    rb_define_method(rb_mKernel, &quot;methods&quot;, rb_obj_methods, -1);
    rb_define_method(rb_mKernel, &quot;singleton_methods&quot;, 
		     rb_obj_singleton_methods, -1); /* in class.c */
    rb_define_method(rb_mKernel, &quot;protected_methods&quot;, 
		     rb_obj_protected_methods, -1);
    rb_define_method(rb_mKernel, &quot;private_methods&quot;, rb_obj_private_methods, -1);
    rb_define_method(rb_mKernel, &quot;public_methods&quot;, rb_obj_public_methods, -1);
    rb_define_method(rb_mKernel, &quot;instance_variables&quot;, 
		     rb_obj_instance_variables, 0); /* in variable.c */
    rb_define_method(rb_mKernel, &quot;instance_variable_get&quot;, rb_obj_ivar_get, 1);
    rb_define_method(rb_mKernel, &quot;instance_variable_set&quot;, rb_obj_ivar_set, 2);
    rb_define_method(rb_mKernel, &quot;instance_variable_defined?&quot;, rb_obj_ivar_defined, 1);
    rb_define_private_method(rb_mKernel, &quot;remove_instance_variable&quot;,
			     rb_obj_remove_instance_variable, 1); /* in variable.c */

    rb_define_method(rb_mKernel, &quot;instance_of?&quot;, rb_obj_is_instance_of, 1);
    rb_define_method(rb_mKernel, &quot;kind_of?&quot;, rb_obj_is_kind_of, 1);
    rb_define_method(rb_mKernel, &quot;is_a?&quot;, rb_obj_is_kind_of, 1);
    rb_define_method(rb_mKernel, &quot;tap&quot;, rb_obj_tap, 0);

    rb_define_private_method(rb_mKernel, &quot;singleton_method_added&quot;, rb_obj_dummy, 1);
    rb_define_private_method(rb_mKernel, &quot;singleton_method_removed&quot;, rb_obj_dummy, 1);
    rb_define_private_method(rb_mKernel, &quot;singleton_method_undefined&quot;, rb_obj_dummy, 1);

    rb_define_global_function(&quot;sprintf&quot;, rb_f_sprintf, -1); /* in sprintf.c */
    rb_define_global_function(&quot;format&quot;, rb_f_sprintf, -1);  /* in sprintf.c  */

    rb_define_global_function(&quot;Integer&quot;, rb_f_integer, 1);
    rb_define_global_function(&quot;Float&quot;, rb_f_float, 1);

    rb_define_global_function(&quot;String&quot;, rb_f_string, 1);
    rb_define_global_function(&quot;Array&quot;, rb_f_array, 1);

    rb_cNilClass = rb_define_class(&quot;NilClass&quot;, rb_cObject);
    rb_define_method(rb_cNilClass, &quot;to_i&quot;, nil_to_i, 0);
    rb_define_method(rb_cNilClass, &quot;to_f&quot;, nil_to_f, 0);
    rb_define_method(rb_cNilClass, &quot;to_s&quot;, nil_to_s, 0);
    rb_define_method(rb_cNilClass, &quot;to_a&quot;, nil_to_a, 0);
    rb_define_method(rb_cNilClass, &quot;inspect&quot;, nil_inspect, 0);
    rb_define_method(rb_cNilClass, &quot;&amp;&quot;, false_and, 1);
    rb_define_method(rb_cNilClass, &quot;|&quot;, false_or, 1);
    rb_define_method(rb_cNilClass, &quot;^&quot;, false_xor, 1);

    rb_define_method(rb_cNilClass, &quot;nil?&quot;, rb_true, 0);
    rb_undef_alloc_func(rb_cNilClass);
    rb_undef_method(CLASS_OF(rb_cNilClass), &quot;new&quot;);
    rb_define_global_const(&quot;NIL&quot;, Qnil);

    rb_cSymbol = rb_define_class(&quot;Symbol&quot;, rb_cObject);
    rb_define_singleton_method(rb_cSymbol, &quot;all_symbols&quot;, 
			       rb_sym_all_symbols, 0); /* in parse.y */
    rb_undef_alloc_func(rb_cSymbol);
    rb_undef_method(CLASS_OF(rb_cSymbol), &quot;new&quot;);

    rb_define_method(rb_cSymbol, &quot;to_i&quot;, sym_to_i, 0);
    rb_define_method(rb_cSymbol, &quot;to_int&quot;, sym_to_int, 0);
    rb_define_method(rb_cSymbol, &quot;inspect&quot;, sym_inspect, 0);
    rb_define_method(rb_cSymbol, &quot;to_s&quot;, sym_to_s, 0);
    rb_define_method(rb_cSymbol, &quot;id2name&quot;, sym_to_s, 0);
    rb_define_method(rb_cSymbol, &quot;to_sym&quot;, sym_to_sym, 0);
    rb_define_method(rb_cSymbol, &quot;to_proc&quot;, sym_to_proc, 0);
    rb_define_method(rb_cSymbol, &quot;===&quot;, rb_obj_equal, 1); 

    rb_define_method(rb_cModule, &quot;freeze&quot;, rb_mod_freeze, 0);
    rb_define_method(rb_cModule, &quot;===&quot;, rb_mod_eqq, 1);
    rb_define_method(rb_cModule, &quot;==&quot;, rb_obj_equal, 1);
    rb_define_method(rb_cModule, &quot;&lt;=&gt;&quot;,  rb_mod_cmp, 1);
    rb_define_method(rb_cModule, &quot;&lt;&quot;,  rb_mod_lt, 1);
    rb_define_method(rb_cModule, &quot;&lt;=&quot;, rb_class_inherited_p, 1);
    rb_define_method(rb_cModule, &quot;&gt;&quot;,  rb_mod_gt, 1);
    rb_define_method(rb_cModule, &quot;&gt;=&quot;, rb_mod_ge, 1);
    rb_define_method(rb_cModule, &quot;initialize_copy&quot;, rb_mod_init_copy, 1); /* in class.c */
    rb_define_method(rb_cModule, &quot;to_s&quot;, rb_mod_to_s, 0);
    rb_define_method(rb_cModule, &quot;included_modules&quot;, 
		     rb_mod_included_modules, 0); /* in class.c */
    rb_define_method(rb_cModule, &quot;include?&quot;, rb_mod_include_p, 1); /* in class.c */
    rb_define_method(rb_cModule, &quot;name&quot;, rb_mod_name, 0);  /* in variable.c */
    rb_define_method(rb_cModule, &quot;ancestors&quot;, rb_mod_ancestors, 0); /* in class.c */

    rb_define_private_method(rb_cModule, &quot;attr&quot;, rb_mod_attr, -1);
    rb_define_private_method(rb_cModule, &quot;attr_reader&quot;, rb_mod_attr_reader, -1);
    rb_define_private_method(rb_cModule, &quot;attr_writer&quot;, rb_mod_attr_writer, -1);
    rb_define_private_method(rb_cModule, &quot;attr_accessor&quot;, rb_mod_attr_accessor, -1);

    rb_define_alloc_func(rb_cModule, rb_module_s_alloc);
    rb_define_method(rb_cModule, &quot;initialize&quot;, rb_mod_initialize, 0);
    rb_define_method(rb_cModule, &quot;instance_methods&quot;, 
		     rb_class_instance_methods, -1);           /* in class.c */
    rb_define_method(rb_cModule, &quot;public_instance_methods&quot;, 
		     rb_class_public_instance_methods, -1);    /* in class.c */
    rb_define_method(rb_cModule, &quot;protected_instance_methods&quot;, 
		     rb_class_protected_instance_methods, -1); /* in class.c */
    rb_define_method(rb_cModule, &quot;private_instance_methods&quot;, 
		     rb_class_private_instance_methods, -1);   /* in class.c */

    rb_define_method(rb_cModule, &quot;class_variable_defined?&quot;, rb_mod_cvar_defined, 1);
    rb_define_method(rb_cModule, &quot;constants&quot;, rb_mod_constants, 0); /* in variable.c */
    rb_define_method(rb_cModule, &quot;const_get&quot;, rb_mod_const_get, 1);
    rb_define_method(rb_cModule, &quot;const_set&quot;, rb_mod_const_set, 2);
    rb_define_method(rb_cModule, &quot;const_defined?&quot;, rb_mod_const_defined, 1);
    rb_define_private_method(rb_cModule, &quot;remove_const&quot;, 
			     rb_mod_remove_const, 1); /* in variable.c */
    rb_define_method(rb_cModule, &quot;const_missing&quot;, 
		     rb_mod_const_missing, 1); /* in variable.c */
    rb_define_method(rb_cModule, &quot;class_variables&quot;, 
		     rb_mod_class_variables, 0); /* in variable.c */
    rb_define_private_method(rb_cModule, &quot;remove_class_variable&quot;, 
			     rb_mod_remove_cvar, 1); /* in variable.c */
    rb_define_private_method(rb_cModule, &quot;class_variable_get&quot;, rb_mod_cvar_get, 1);
    rb_define_private_method(rb_cModule, &quot;class_variable_set&quot;, rb_mod_cvar_set, 2);

    rb_define_method(rb_cClass, &quot;allocate&quot;, rb_obj_alloc, 0);
    rb_define_method(rb_cClass, &quot;new&quot;, rb_class_new_instance, -1);
    rb_define_method(rb_cClass, &quot;initialize&quot;, rb_class_initialize, -1);
    rb_define_method(rb_cClass, &quot;initialize_copy&quot;, rb_class_init_copy, 1); /* in class.c */
    rb_define_method(rb_cClass, &quot;superclass&quot;, rb_class_superclass, 0);
    rb_define_alloc_func(rb_cClass, rb_class_s_alloc);
    rb_undef_method(rb_cClass, &quot;extend_object&quot;);
    rb_undef_method(rb_cClass, &quot;append_features&quot;);

    rb_cData = rb_define_class(&quot;Data&quot;, rb_cObject);
    rb_undef_alloc_func(rb_cData);

    rb_global_variable(&amp;ruby_top_self);
    ruby_top_self = rb_obj_alloc(rb_cObject);
    rb_define_singleton_method(ruby_top_self, &quot;to_s&quot;, main_to_s, 0);

    rb_cTrueClass = rb_define_class(&quot;TrueClass&quot;, rb_cObject);
    rb_define_method(rb_cTrueClass, &quot;to_s&quot;, true_to_s, 0);
    rb_define_method(rb_cTrueClass, &quot;&amp;&quot;, true_and, 1);
    rb_define_method(rb_cTrueClass, &quot;|&quot;, true_or, 1);
    rb_define_method(rb_cTrueClass, &quot;^&quot;, true_xor, 1);
    rb_undef_alloc_func(rb_cTrueClass);
    rb_undef_method(CLASS_OF(rb_cTrueClass), &quot;new&quot;);
    rb_define_global_const(&quot;TRUE&quot;, Qtrue);

    rb_cFalseClass = rb_define_class(&quot;FalseClass&quot;, rb_cObject);
    rb_define_method(rb_cFalseClass, &quot;to_s&quot;, false_to_s, 0);
    rb_define_method(rb_cFalseClass, &quot;&amp;&quot;, false_and, 1);
    rb_define_method(rb_cFalseClass, &quot;|&quot;, false_or, 1);
    rb_define_method(rb_cFalseClass, &quot;^&quot;, false_xor, 1);
    rb_undef_alloc_func(rb_cFalseClass);
    rb_undef_method(CLASS_OF(rb_cFalseClass), &quot;new&quot;);
    rb_define_global_const(&quot;FALSE&quot;, Qfalse);

    id_eq = rb_intern(&quot;==&quot;);
    id_eql = rb_intern(&quot;eql?&quot;);
    id_inspect = rb_intern(&quot;inspect&quot;);
    id_init_copy = rb_intern(&quot;initialize_copy&quot;);
}
</pre>
    </div>