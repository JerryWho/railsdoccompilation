  <div id="fileHeader">
    <h1>ns.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/xsd/ns.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># XSD4R - XML Schema Namespace library
# Copyright (C) 2000-2003, 2005  NAKAMURA, Hiroshi &lt;nahi@ruby-lang.org&gt;.

# This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
# redistribute it and/or modify it under the same terms of Ruby's license;
# either the dual license version in 2003, or any later version.


require 'xsd/datatypes'


module XSD


class NS
  class Assigner
    def initialize
      @count = 0
    end

    def assign(ns)
      @count += 1
      &quot;n#{@count}&quot;
    end
  end

  attr_reader :default_namespace

  class FormatError &lt; Error; end

public

  def initialize(tag2ns = {})
    @tag2ns = tag2ns
    @assigner = nil
    @ns2tag = {}
    @tag2ns.each do |tag, ns|
      @ns2tag[ns] = tag
    end
    @default_namespace = nil
  end

  def assign(ns, tag = nil)
    if (tag == '')
      @default_namespace = ns
      tag
    else
      @assigner ||= Assigner.new
      tag ||= @assigner.assign(ns)
      @ns2tag[ns] = tag
      @tag2ns[tag] = ns
      tag
    end
  end

  def assigned?(ns)
    @default_namespace == ns or @ns2tag.key?(ns)
  end

  def assigned_tag?(tag)
    @tag2ns.key?(tag)
  end

  def clone_ns
    cloned = NS.new(@tag2ns.dup)
    cloned.assigner = @assigner
    cloned.assign(@default_namespace, '') if @default_namespace
    cloned
  end

  def name(name)
    if (name.namespace == @default_namespace)
      name.name
    elsif @ns2tag.key?(name.namespace)
      &quot;#{@ns2tag[name.namespace]}:#{name.name}&quot;
    else
      raise FormatError.new(&quot;namespace: #{name.namespace} not defined yet&quot;)
    end
  end

  def compare(ns, name, rhs)
    if (ns == @default_namespace)
      return true if (name == rhs)
    end
    @tag2ns.each do |assigned_tag, assigned_ns|
      if assigned_ns == ns &amp;&amp; &quot;#{assigned_tag}:#{name}&quot; == rhs
	return true
      end
    end
    false
  end

  # $1 and $2 are necessary.
  ParseRegexp = Regexp.new('^([^:]+)(?::(.+))?$')

  def parse(str, local = false)
    if ParseRegexp =~ str
      if (name = $2) and (ns = @tag2ns[$1])
        return XSD::QName.new(ns, name)
      end
    end
    XSD::QName.new(local ? nil : @default_namespace, str)
  end

  # For local attribute key parsing
  #   &lt;foo xmlns=&quot;urn:a&quot; xmlns:n1=&quot;urn:a&quot; bar=&quot;1&quot; n1:baz=&quot;2&quot; /&gt;
  #     =&gt;
  #   {}bar, {urn:a}baz
  def parse_local(elem)
    ParseRegexp =~ elem
    if $2
      ns = @tag2ns[$1]
      name = $2
      if !ns
	raise FormatError.new(&quot;unknown namespace qualifier: #{$1}&quot;)
      end
    elsif $1
      ns = nil
      name = $1
    else
      raise FormatError.new(&quot;illegal element format: #{elem}&quot;)
    end
    XSD::QName.new(ns, name)
  end

  def each_ns
    @ns2tag.each do |ns, tag|
      yield(ns, tag)
    end
  end

protected

  def assigner=(assigner)
    @assigner = assigner
  end
end


end
</pre>
    </div>