  <div id="fileHeader">
    <h1>classdef.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/xsd/codegen/classdef.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># XSD4R - Generating class definition code
# Copyright (C) 2004  NAKAMURA, Hiroshi &lt;nahi@ruby-lang.org&gt;.

# This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
# redistribute it and/or modify it under the same terms of Ruby's license;
# either the dual license version in 2003, or any later version.


require 'xsd/codegen/gensupport'
require 'xsd/codegen/moduledef'
require 'xsd/codegen/methoddef'


module XSD
module CodeGen


class ClassDef &lt; ModuleDef
  include GenSupport

  def initialize(name, baseclass = nil)
    super(name)
    @baseclass = baseclass
    @classvar = []
    @attrdef = []
  end

  def def_classvar(var, value)
    var = var.sub(/\A@@/, &quot;&quot;)
    unless safevarname?(var)
      raise ArgumentError.new(&quot;#{var} seems to be unsafe&quot;)
    end
    @classvar &lt;&lt; [var, value]
  end

  def def_attr(attrname, writable = true, varname = nil)
    unless safevarname?(varname || attrname)
      raise ArgumentError.new(&quot;#{varname || attrname} seems to be unsafe&quot;)
    end
    @attrdef &lt;&lt; [attrname, writable, varname]
  end

  def dump
    buf = &quot;&quot;
    unless @requirepath.empty?
      buf &lt;&lt; dump_requirepath 
    end
    buf &lt;&lt; dump_emptyline unless buf.empty?
    package = @name.split(/::/)[0..-2]
    buf &lt;&lt; dump_package_def(package) unless package.empty?
    buf &lt;&lt; dump_comment if @comment
    buf &lt;&lt; dump_class_def
    spacer = false
    unless @classvar.empty?
      spacer = true
      buf &lt;&lt; dump_classvar
    end
    unless @const.empty?
      buf &lt;&lt; dump_emptyline if spacer
      spacer = true
      buf &lt;&lt; dump_const
    end
    unless @code.empty?
      buf &lt;&lt; dump_emptyline if spacer
      spacer = true
      buf &lt;&lt; dump_code
    end
    unless @attrdef.empty?
      buf &lt;&lt; dump_emptyline if spacer
      spacer = true
      buf &lt;&lt; dump_attributes
    end
    unless @methoddef.empty?
      buf &lt;&lt; dump_emptyline if spacer
      spacer = true
      buf &lt;&lt; dump_methods
    end
    buf &lt;&lt; dump_class_def_end
    buf &lt;&lt; dump_package_def_end(package) unless package.empty?
    buf.gsub(/^\s+$/, '')
  end

private

  def dump_class_def
    name = @name.to_s.split(/::/)
    if @baseclass
      format(&quot;class #{name.last} &lt; #{@baseclass}&quot;)
    else
      format(&quot;class #{name.last}&quot;)
    end
  end

  def dump_class_def_end
    str = format(&quot;end&quot;)
  end

  def dump_classvar
    dump_static(
      @classvar.collect { |var, value|
        %Q(@@#{var.sub(/^@@/, &quot;&quot;)} = #{dump_value(value)})
      }.join(&quot;\n&quot;)
    )
  end

  def dump_attributes
    str = &quot;&quot;
    @attrdef.each do |attrname, writable, varname|
      varname ||= attrname
      if attrname == varname
        str &lt;&lt; format(dump_accessor(attrname, writable), 2)
      end
    end
    @attrdef.each do |attrname, writable, varname|
      varname ||= attrname
      if attrname != varname
        str &lt;&lt; &quot;\n&quot; unless str.empty?
        str &lt;&lt; format(dump_attribute(attrname, writable, varname), 2)
      end
    end
    str
  end

  def dump_accessor(attrname, writable)
    if writable
      &quot;attr_accessor :#{attrname}&quot;
    else
      &quot;attr_reader :#{attrname}&quot;
    end
  end

  def dump_attribute(attrname, writable, varname)
    str = nil
    mr = MethodDef.new(attrname)
    mr.definition = &quot;@#{varname}&quot;
    str = mr.dump
    if writable
      mw = MethodDef.new(attrname + &quot;=&quot;, 'value')
      mw.definition = &quot;@#{varname} = value&quot;
      str &lt;&lt; &quot;\n&quot; + mw.dump
    end
    str
  end
end


end
end


if __FILE__ == $0
  require 'xsd/codegen/classdef'
  include XSD::CodeGen
  c = ClassDef.new(&quot;Foo::Bar::HobbitName&quot;, String)
  c.def_require(&quot;foo/bar&quot;)
  c.comment = &lt;&lt;-EOD
      foo
    bar
      baz
  EOD
  c.def_const(&quot;FOO&quot;, 1)
  c.def_classvar(&quot;@@foo&quot;, &quot;var&quot;.dump)
  c.def_classvar(&quot;baz&quot;, &quot;1&quot;.dump)
  c.def_attr(&quot;Foo&quot;, true, &quot;foo&quot;)
  c.def_attr(&quot;bar&quot;)
  c.def_attr(&quot;baz&quot;, true)
  c.def_attr(&quot;Foo2&quot;, true, &quot;foo2&quot;)
  c.def_attr(&quot;foo3&quot;, false, &quot;foo3&quot;)
  c.def_method(&quot;foo&quot;) do
    &lt;&lt;-EOD
        foo.bar = 1
\tbaz.each do |ele|
\t  ele
        end
    EOD
  end
  c.def_method(&quot;baz&quot;, &quot;qux&quot;) do
    &lt;&lt;-EOD
      [1, 2, 3].each do |i|
        p i
      end
    EOD
  end

  m = MethodDef.new(&quot;qux&quot;, &quot;quxx&quot;, &quot;quxxx&quot;) do
    &lt;&lt;-EOD
    p quxx + quxxx
    EOD
  end
  m.comment = &quot;hello world\n123&quot;
  c.add_method(m)
  c.def_code &lt;&lt;-EOD
    Foo.new
    Bar.z
  EOD
  c.def_code &lt;&lt;-EOD
    Foo.new
    Bar.z
  EOD
  c.def_privatemethod(&quot;foo&quot;, &quot;baz&quot;, &quot;*arg&quot;, &quot;&amp;block&quot;)

  puts c.dump
end
</pre>
    </div>