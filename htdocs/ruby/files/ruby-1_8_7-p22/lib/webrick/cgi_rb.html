  <div id="fileHeader">
    <h1>cgi.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/webrick/cgi.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# cgi.rb -- Yet another CGI library
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers. All rights
# reserved.
#
# $Id: cgi.rb 11708 2007-02-12 23:01:19Z shyouhei $

require &quot;webrick/httprequest&quot;
require &quot;webrick/httpresponse&quot;
require &quot;webrick/config&quot;
require &quot;stringio&quot;

module WEBrick
  class CGI
    CGIError = Class.new(StandardError)

    attr_reader :config, :logger

    def initialize(*args)
      if defined?(MOD_RUBY)
        unless ENV.has_key?(&quot;GATEWAY_INTERFACE&quot;)
          Apache.request.setup_cgi_env
        end
      end
      if %r{HTTP/(\d+\.\d+)} =~ ENV[&quot;SERVER_PROTOCOL&quot;]
        httpv = $1
      end
      @config = WEBrick::Config::HTTP.dup.update(
        :ServerSoftware =&gt; ENV[&quot;SERVER_SOFTWARE&quot;] || &quot;null&quot;,
        :HTTPVersion    =&gt; HTTPVersion.new(httpv || &quot;1.0&quot;),
        :RunOnCGI       =&gt; true,   # to detect if it runs on CGI.
        :NPH            =&gt; false   # set true to run as NPH script.
      )
      if config = args.shift
        @config.update(config)
      end
      @config[:Logger] ||= WEBrick::BasicLog.new($stderr)
      @logger = @config[:Logger]
      @options = args
    end

    def [](key)
      @config[key]
    end

    def start(env=ENV, stdin=$stdin, stdout=$stdout)
      sock = WEBrick::CGI::Socket.new(@config, env, stdin, stdout)
      req = HTTPRequest.new(@config)
      res = HTTPResponse.new(@config)
      unless @config[:NPH] or defined?(MOD_RUBY)
        def res.setup_header
          unless @header[&quot;status&quot;]
            phrase = HTTPStatus::reason_phrase(@status)
            @header[&quot;status&quot;] = &quot;#{@status} #{phrase}&quot;
          end
          super
        end
        def res.status_line
          &quot;&quot;
        end
      end

      begin
        req.parse(sock)
        req.script_name = (env[&quot;SCRIPT_NAME&quot;] || File.expand_path($0)).dup
        req.path_info = (env[&quot;PATH_INFO&quot;] || &quot;&quot;).dup
        req.query_string = env[&quot;QUERY_STRING&quot;]
        req.user = env[&quot;REMOTE_USER&quot;]
        res.request_method = req.request_method
        res.request_uri = req.request_uri
        res.request_http_version = req.http_version
        res.keep_alive = req.keep_alive?
        self.service(req, res)
      rescue HTTPStatus::Error =&gt; ex
        res.set_error(ex)
      rescue HTTPStatus::Status =&gt; ex
        res.status = ex.code
      rescue Exception =&gt; ex 
        @logger.error(ex)
        res.set_error(ex, true)
      ensure
        req.fixup
        if defined?(MOD_RUBY)
          res.setup_header
          Apache.request.status_line = &quot;#{res.status} #{res.reason_phrase}&quot;
          Apache.request.status = res.status
          table = Apache.request.headers_out
          res.header.each{|key, val|
            case key
            when /^content-encoding$/i
              Apache::request.content_encoding = val
            when /^content-type$/i
              Apache::request.content_type = val
            else
              table[key] = val.to_s
            end
          }
          res.cookies.each{|cookie|
            table.add(&quot;Set-Cookie&quot;, cookie.to_s)
          }
          Apache.request.send_http_header
          res.send_body(sock)
        else
          res.send_response(sock)
        end
      end
    end

    def service(req, res)
      method_name = &quot;do_&quot; + req.request_method.gsub(/-/, &quot;_&quot;)
      if respond_to?(method_name)
        __send__(method_name, req, res)
      else
        raise HTTPStatus::MethodNotAllowed,
              &quot;unsupported method `#{req.request_method}'.&quot;
      end
    end

    class Socket
      include Enumerable

      private
  
      def initialize(config, env, stdin, stdout)
        @config = config
        @env = env
        @header_part = StringIO.new
        @body_part = stdin
        @out_port = stdout
        @out_port.binmode
  
        @server_addr = @env[&quot;SERVER_ADDR&quot;] || &quot;0.0.0.0&quot;
        @server_name = @env[&quot;SERVER_NAME&quot;]
        @server_port = @env[&quot;SERVER_PORT&quot;]
        @remote_addr = @env[&quot;REMOTE_ADDR&quot;]
        @remote_host = @env[&quot;REMOTE_HOST&quot;] || @remote_addr
        @remote_port = @env[&quot;REMOTE_PORT&quot;] || 0

        begin
          @header_part &lt;&lt; request_line &lt;&lt; CRLF
          setup_header
          @header_part &lt;&lt; CRLF
          @header_part.rewind
        rescue Exception =&gt; ex
          raise CGIError, &quot;invalid CGI environment&quot;
        end
      end

      def request_line
        meth = @env[&quot;REQUEST_METHOD&quot;] || &quot;GET&quot;
        unless url = @env[&quot;REQUEST_URI&quot;]
          url = (@env[&quot;SCRIPT_NAME&quot;] || File.expand_path($0)).dup
          url &lt;&lt; @env[&quot;PATH_INFO&quot;].to_s
          url = WEBrick::HTTPUtils.escape_path(url)
          if query_string = @env[&quot;QUERY_STRING&quot;]
            unless query_string.empty?
              url &lt;&lt; &quot;?&quot; &lt;&lt; query_string
            end
          end
        end
        # we cannot get real HTTP version of client ;)
        httpv = @config[:HTTPVersion]
        return &quot;#{meth} #{url} HTTP/#{httpv}&quot;
      end
  
      def setup_header
        add_header(&quot;CONTENT_TYPE&quot;, &quot;Content-Type&quot;)
        add_header(&quot;CONTENT_LENGTH&quot;, &quot;Content-length&quot;)
        @env.each_key{|name|
          if /^HTTP_(.*)/ =~ name
            add_header(name, $1.gsub(/_/, &quot;-&quot;))
          end
        }
      end
  
      def add_header(envname, hdrname)
        if value = @env[envname]
          unless value.empty?
            @header_part &lt;&lt; hdrname &lt;&lt; &quot;: &quot; &lt;&lt; value &lt;&lt; CRLF
          end
        end
      end

      def input
        @header_part.eof? ? @body_part : @header_part
      end
  
      public
  
      def peeraddr
        [nil, @remote_port, @remote_host, @remote_addr]
      end
  
      def addr
        [nil, @server_port, @server_name, @server_addr]
      end
  
      def gets(eol=LF)
        input.gets(eol)
      end
  
      def read(size=nil)
        input.read(size)
      end

      def each
        input.each{|line| yield(line) }
      end
  
      def &lt;&lt;(data)
        @out_port &lt;&lt; data
      end

      def cert
        return nil unless defined?(OpenSSL)
        if pem = @env[&quot;SSL_SERVER_CERT&quot;]
          OpenSSL::X509::Certificate.new(pem) unless pem.empty?
        end
      end

      def peer_cert
        return nil unless defined?(OpenSSL)
        if pem = @env[&quot;SSL_CLIENT_CERT&quot;]
          OpenSSL::X509::Certificate.new(pem) unless pem.empty?
        end
      end

      def peer_cert_chain
        return nil unless defined?(OpenSSL)
        if @env[&quot;SSL_CLIENT_CERT_CHAIN_0&quot;]
          keys = @env.keys
          certs = keys.sort.collect{|k|
            if /^SSL_CLIENT_CERT_CHAIN_\d+$/ =~ k
              if pem = @env[k]
                OpenSSL::X509::Certificate.new(pem) unless pem.empty?
              end
            end
          }
          certs.compact
        end
      end

      def cipher
        return nil unless defined?(OpenSSL)
        if cipher = @env[&quot;SSL_CIPHER&quot;]
          ret = [ cipher ]
          ret &lt;&lt; @env[&quot;SSL_PROTOCOL&quot;]
          ret &lt;&lt; @env[&quot;SSL_CIPHER_USEKEYSIZE&quot;]
          ret &lt;&lt; @env[&quot;SSL_CIPHER_ALGKEYSIZE&quot;]
          ret
        end
      end
    end
  end 
end  
</pre>
    </div>