  <div id="fileHeader">
    <h1>httputils.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/webrick/httputils.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# httputils.rb -- HTTPUtils Module
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httputils.rb,v 1.34 2003/06/05 21:34:08 gotoyuzo Exp $

require 'socket'
require 'tempfile'

module WEBrick
  CR   = &quot;\x0d&quot;
  LF   = &quot;\x0a&quot;
  CRLF = &quot;\x0d\x0a&quot;

  module HTTPUtils

    def normalize_path(path)
      raise &quot;abnormal path `#{path}'&quot; if path[0] != ?/
      ret = path.dup

      ret.gsub!(%r{/+}o, '/')                    # //      =&gt; /
      while ret.sub!(%r{/\.(/|\Z)}o, '/'); end   # /.      =&gt; /
      begin                                      # /foo/.. =&gt; /foo
        match = ret.sub!(%r{/([^/]+)/\.\.(/|\Z)}o){
          if $1 == &quot;..&quot;
            raise &quot;abnormal path `#{path}'&quot;
          else
            &quot;/&quot;
          end
        }
      end while match

      raise &quot;abnormal path `#{path}'&quot; if %r{/\.\.(/|\Z)} =~ ret
      ret
    end
    module_function :normalize_path

    #####

    DefaultMimeTypes = {
      &quot;ai&quot;    =&gt; &quot;application/postscript&quot;,
      &quot;asc&quot;   =&gt; &quot;text/plain&quot;,
      &quot;avi&quot;   =&gt; &quot;video/x-msvideo&quot;,
      &quot;bin&quot;   =&gt; &quot;application/octet-stream&quot;,
      &quot;bmp&quot;   =&gt; &quot;image/bmp&quot;,
      &quot;class&quot; =&gt; &quot;application/octet-stream&quot;,
      &quot;cer&quot;   =&gt; &quot;application/pkix-cert&quot;,
      &quot;crl&quot;   =&gt; &quot;application/pkix-crl&quot;,
      &quot;crt&quot;   =&gt; &quot;application/x-x509-ca-cert&quot;,
     #&quot;crl&quot;   =&gt; &quot;application/x-pkcs7-crl&quot;,
      &quot;css&quot;   =&gt; &quot;text/css&quot;,
      &quot;dms&quot;   =&gt; &quot;application/octet-stream&quot;,
      &quot;doc&quot;   =&gt; &quot;application/msword&quot;,
      &quot;dvi&quot;   =&gt; &quot;application/x-dvi&quot;,
      &quot;eps&quot;   =&gt; &quot;application/postscript&quot;,
      &quot;etx&quot;   =&gt; &quot;text/x-setext&quot;,
      &quot;exe&quot;   =&gt; &quot;application/octet-stream&quot;,
      &quot;gif&quot;   =&gt; &quot;image/gif&quot;,
      &quot;htm&quot;   =&gt; &quot;text/html&quot;,
      &quot;html&quot;  =&gt; &quot;text/html&quot;,
      &quot;jpe&quot;   =&gt; &quot;image/jpeg&quot;,
      &quot;jpeg&quot;  =&gt; &quot;image/jpeg&quot;,
      &quot;jpg&quot;   =&gt; &quot;image/jpeg&quot;,
      &quot;lha&quot;   =&gt; &quot;application/octet-stream&quot;,
      &quot;lzh&quot;   =&gt; &quot;application/octet-stream&quot;,
      &quot;mov&quot;   =&gt; &quot;video/quicktime&quot;,
      &quot;mpe&quot;   =&gt; &quot;video/mpeg&quot;,
      &quot;mpeg&quot;  =&gt; &quot;video/mpeg&quot;,
      &quot;mpg&quot;   =&gt; &quot;video/mpeg&quot;,
      &quot;pbm&quot;   =&gt; &quot;image/x-portable-bitmap&quot;,
      &quot;pdf&quot;   =&gt; &quot;application/pdf&quot;,
      &quot;pgm&quot;   =&gt; &quot;image/x-portable-graymap&quot;,
      &quot;png&quot;   =&gt; &quot;image/png&quot;,
      &quot;pnm&quot;   =&gt; &quot;image/x-portable-anymap&quot;,
      &quot;ppm&quot;   =&gt; &quot;image/x-portable-pixmap&quot;,
      &quot;ppt&quot;   =&gt; &quot;application/vnd.ms-powerpoint&quot;,
      &quot;ps&quot;    =&gt; &quot;application/postscript&quot;,
      &quot;qt&quot;    =&gt; &quot;video/quicktime&quot;,
      &quot;ras&quot;   =&gt; &quot;image/x-cmu-raster&quot;,
      &quot;rb&quot;    =&gt; &quot;text/plain&quot;,
      &quot;rd&quot;    =&gt; &quot;text/plain&quot;,
      &quot;rtf&quot;   =&gt; &quot;application/rtf&quot;,
      &quot;sgm&quot;   =&gt; &quot;text/sgml&quot;,
      &quot;sgml&quot;  =&gt; &quot;text/sgml&quot;,
      &quot;tif&quot;   =&gt; &quot;image/tiff&quot;,
      &quot;tiff&quot;  =&gt; &quot;image/tiff&quot;,
      &quot;txt&quot;   =&gt; &quot;text/plain&quot;,
      &quot;xbm&quot;   =&gt; &quot;image/x-xbitmap&quot;,
      &quot;xls&quot;   =&gt; &quot;application/vnd.ms-excel&quot;,
      &quot;xml&quot;   =&gt; &quot;text/xml&quot;,
      &quot;xpm&quot;   =&gt; &quot;image/x-xpixmap&quot;,
      &quot;xwd&quot;   =&gt; &quot;image/x-xwindowdump&quot;,
      &quot;zip&quot;   =&gt; &quot;application/zip&quot;,
    }

    # Load Apache compatible mime.types file.
    def load_mime_types(file)
      open(file){ |io|
        hash = Hash.new
        io.each{ |line|
          next if /^#/ =~ line
          line.chomp!
          mimetype, ext0 = line.split(/\s+/, 2)
          next unless ext0   
          next if ext0.empty?
          ext0.split(/\s+/).each{ |ext| hash[ext] = mimetype }
        }
        hash
      }
    end
    module_function :load_mime_types

    def mime_type(filename, mime_tab)
      suffix1 = (/\.(\w+)$/ =~ filename &amp;&amp; $1.downcase)
      suffix2 = (/\.(\w+)\.[\w\-]+$/ =~ filename &amp;&amp; $1.downcase)
      mime_tab[suffix1] || mime_tab[suffix2] || &quot;application/octet-stream&quot;
    end
    module_function :mime_type

    #####

    def parse_header(raw)
      header = Hash.new([].freeze)
      field = nil
      raw.each{|line|
        case line
        when /^([A-Za-z0-9!\#$%&amp;'*+\-.^_`|~]+):\s*(.*?)\s*\z/om
          field, value = $1, $2
          field.downcase!
          header[field] = [] unless header.has_key?(field)
          header[field] &lt;&lt; value
        when /^\s+(.*?)\s*\z/om
          value = $1
          unless field
            raise &quot;bad header '#{line.inspect}'.&quot;
          end
          header[field][-1] &lt;&lt; &quot; &quot; &lt;&lt; value
        else
          raise &quot;bad header '#{line.inspect}'.&quot;
        end
      }
      header.each{|key, values|
        values.each{|value|
          value.strip!
          value.gsub!(/\s+/, &quot; &quot;)
        }
      }
      header
    end
    module_function :parse_header

    def split_header_value(str)
      str.scan(/((?:&quot;(?:\\.|[^&quot;])+?&quot;|[^&quot;,]+)+)
                (?:,\s*|\Z)/xn).collect{|v| v[0] }
    end
    module_function :split_header_value

    def parse_range_header(ranges_specifier)
      if /^bytes=(.*)/ =~ ranges_specifier
        byte_range_set = split_header_value($1)
        byte_range_set.collect{|range_spec|
          case range_spec
          when /^(\d+)-(\d+)/ then $1.to_i .. $2.to_i
          when /^(\d+)-/      then $1.to_i .. -1
          when /^-(\d+)/      then -($1.to_i) .. -1
          else return nil
          end
        }
      end
    end
    module_function :parse_range_header

    def parse_qvalues(value)
      tmp = []
      if value
        parts = value.split(/,\s*/)
        parts.each {|part|
          if m = %r{^([^\s,]+?)(?:;\s*q=(\d+(?:\.\d+)?))?$}.match(part)
            val = m[1]
            q = (m[2] or 1).to_f
            tmp.push([val, q])
          end
        }
        tmp = tmp.sort_by{|val, q| -q}
        tmp.collect!{|val, q| val}
      end
      return tmp
    end
    module_function :parse_qvalues

    #####

    def dequote(str)
      ret = (/\A&quot;(.*)&quot;\Z/ =~ str) ? $1 : str.dup
      ret.gsub!(/\\(.)/, &quot;\\1&quot;)
      ret
    end
    module_function :dequote

    def quote(str)
      '&quot;' &lt;&lt; str.gsub(/[\\\&quot;]/o, &quot;\\\1&quot;) &lt;&lt; '&quot;'
    end
    module_function :quote

    #####

    class FormData &lt; String
      EmptyRawHeader = [].freeze
      EmptyHeader = {}.freeze

      attr_accessor :name, :filename, :next_data
      protected :next_data

      def initialize(*args)
        @name = @filename = @next_data = nil
        if args.empty?
          @raw_header = []
          @header = nil
          super(&quot;&quot;)
        else
          @raw_header = EmptyRawHeader
          @header = EmptyHeader 
          super(args.shift)
          unless args.empty?
            @next_data = self.class.new(*args)
          end
        end
      end

      def [](*key)
        begin
          @header[key[0].downcase].join(&quot;, &quot;)
        rescue StandardError, NameError
          super
        end
      end

      def &lt;&lt;(str)
        if @header
          super
        elsif str == CRLF
          @header = HTTPUtils::parse_header(@raw_header)
          if cd = self['content-disposition']
            if /\s+name=&quot;(.*?)&quot;/ =~ cd then @name = $1 end
            if /\s+filename=&quot;(.*?)&quot;/ =~ cd then @filename = $1 end
          end
        else
          @raw_header &lt;&lt; str
        end
        self
      end

      def append_data(data)
        tmp = self
        while tmp
          unless tmp.next_data 
            tmp.next_data = data
            break
          end
          tmp = tmp.next_data
        end
        self
      end

      def each_data
        tmp = self
        while tmp
          next_data = tmp.next_data
          yield(tmp)
          tmp = next_data
        end
      end

      def list
        ret = []
        each_data{|data|
          ret &lt;&lt; data.to_s
        }
        ret
      end

      alias :to_ary :list

      def to_s
        String.new(self)
      end
    end

    def parse_query(str)
      query = Hash.new
      if str
        str.split(/[&amp;;]/).each{|x|
          next if x.empty? 
          key, val = x.split(/=/,2)
          key = unescape_form(key)
          val = unescape_form(val.to_s)
          val = FormData.new(val)
          val.name = key
          if query.has_key?(key)
            query[key].append_data(val)
            next
          end
          query[key] = val
        }
      end
      query
    end
    module_function :parse_query

    def parse_form_data(io, boundary)
      boundary_regexp = /\A--#{boundary}(--)?#{CRLF}\z/
      form_data = Hash.new
      return form_data unless io
      data = nil
      io.each{|line|
        if boundary_regexp =~ line
          if data
            data.chop!
            key = data.name
            if form_data.has_key?(key)
              form_data[key].append_data(data)
            else
              form_data[key] = data 
            end
          end
          data = FormData.new
          next
        else
          if data
            data &lt;&lt; line
          end
        end
      }
      return form_data
    end
    module_function :parse_form_data

    #####

    reserved = ';/?:@&amp;=+$,'
    num      = '0123456789'
    lowalpha = 'abcdefghijklmnopqrstuvwxyz'
    upalpha  = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    mark     = '-_.!~*\'()'
    unreserved = num + lowalpha + upalpha + mark
    control  = (0x0..0x1f).collect{|c| c.chr }.join + &quot;\x7f&quot;
    space    = &quot; &quot;
    delims   = '&lt;&gt;#%&quot;'
    unwise   = '{}|\\^[]`'
    nonascii = (0x80..0xff).collect{|c| c.chr }.join

    module_function

    def _make_regex(str) /([#{Regexp.escape(str)}])/n end
    def _make_regex!(str) /([^#{Regexp.escape(str)}])/n end
    def _escape(str, regex) str.gsub(regex){ &quot;%%%02X&quot; % $1[0] } end
    def _unescape(str, regex) str.gsub(regex){ $1.hex.chr } end

    UNESCAPED = _make_regex(control+space+delims+unwise+nonascii)
    UNESCAPED_FORM = _make_regex(reserved+control+delims+unwise+nonascii)
    NONASCII  = _make_regex(nonascii)
    ESCAPED   = /%([0-9a-fA-F]{2})/
    UNESCAPED_PCHAR = _make_regex!(unreserved+&quot;:@&amp;=+$,&quot;)

    def escape(str)
      _escape(str, UNESCAPED)
    end

    def unescape(str)
      _unescape(str, ESCAPED)
    end

    def escape_form(str)
      ret = _escape(str, UNESCAPED_FORM)
      ret.gsub!(/ /, &quot;+&quot;)
      ret
    end

    def unescape_form(str)
      _unescape(str.gsub(/\+/, &quot; &quot;), ESCAPED)
    end

    def escape_path(str)
      result = &quot;&quot;
      str.scan(%r{/([^/]*)}).each{|i|
        result &lt;&lt; &quot;/&quot; &lt;&lt; _escape(i[0], UNESCAPED_PCHAR)
      }
      return result
    end

    def escape8bit(str)
      _escape(str, NONASCII)
    end
  end
end
</pre>
    </div>