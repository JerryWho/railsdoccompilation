  <div id="fileHeader">
    <h1>cgihandler.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/webrick/httpservlet/cgihandler.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed May 28 02:16:25 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># 
# cgihandler.rb -- CGIHandler Class
#       
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#   
# $IPR: cgihandler.rb,v 1.27 2003/03/21 19:56:01 gotoyuzo Exp $

require 'rbconfig'
require 'tempfile'
require 'webrick/config'
require 'webrick/httpservlet/abstract'

module WEBrick
  module HTTPServlet

    class CGIHandler &lt; AbstractServlet
      Ruby = File::join(::Config::CONFIG['bindir'],
                        ::Config::CONFIG['ruby_install_name'])
      Ruby &lt;&lt; ::Config::CONFIG['EXEEXT']
      CGIRunner = &quot;\&quot;#{Ruby}\&quot; \&quot;#{Config::LIBDIR}/httpservlet/cgi_runner.rb\&quot;&quot;

      def initialize(server, name)
        super
        @script_filename = name
        @tempdir = server[:TempDir]
        @cgicmd = &quot;#{CGIRunner} #{server[:CGIInterpreter]}&quot;
      end

      def do_GET(req, res)
        data = nil
        status = -1

        cgi_in = IO::popen(@cgicmd, &quot;wb&quot;)
        cgi_out = Tempfile.new(&quot;webrick.cgiout.&quot;, @tempdir)
        cgi_err = Tempfile.new(&quot;webrick.cgierr.&quot;, @tempdir)
        begin
          cgi_in.sync = true
          meta = req.meta_vars
          meta[&quot;SCRIPT_FILENAME&quot;] = @script_filename
          meta[&quot;PATH&quot;] = @config[:CGIPathEnv]
          if /mswin|bccwin|mingw/ =~ RUBY_PLATFORM
            meta[&quot;SystemRoot&quot;] = ENV[&quot;SystemRoot&quot;]
          end
          dump = Marshal.dump(meta)

          cgi_in.write(&quot;%8d&quot; % cgi_out.path.size)
          cgi_in.write(cgi_out.path)
          cgi_in.write(&quot;%8d&quot; % cgi_err.path.size)
          cgi_in.write(cgi_err.path)
          cgi_in.write(&quot;%8d&quot; % dump.size)
          cgi_in.write(dump)

          if req.body and req.body.size &gt; 0
            cgi_in.write(req.body)
          end
        ensure
          cgi_in.close
          status = $?.exitstatus
          sleep 0.1 if /mswin|bccwin|mingw/ =~ RUBY_PLATFORM
          data = cgi_out.read
          cgi_out.close(true)
          if errmsg = cgi_err.read
            if errmsg.size &gt; 0
              @logger.error(&quot;CGIHandler: #{@script_filename}:\n&quot; + errmsg)
            end
          end 
          cgi_err.close(true)
        end
        
        if status != 0
          @logger.error(&quot;CGIHandler: #{@script_filename} exit with #{status}&quot;)
        end

        data = &quot;&quot; unless data
        raw_header, body = data.split(/^[\xd\xa]+/on, 2) 
        raise HTTPStatus::InternalServerError,
          &quot;Premature end of script headers: #{@script_filename}&quot; if body.nil?

        begin
          header = HTTPUtils::parse_header(raw_header)
          if /^(\d+)/ =~ header['status'][0]
            res.status = $1.to_i
            header.delete('status')
          end
          if header.has_key?('location')
            # RFC 3875 6.2.3, 6.2.4
            res.status = 302 unless (300...400) === res.status
          end
          if header.has_key?('set-cookie')
            header['set-cookie'].each{|k|
              res.cookies &lt;&lt; Cookie.parse_set_cookie(k)
            }
            header.delete('set-cookie')
          end
          header.each{|key, val| res[key] = val.join(&quot;, &quot;) }
        rescue =&gt; ex
          raise HTTPStatus::InternalServerError, ex.message
        end
        res.body = body
      end
      alias do_POST do_GET
    end

  end
end
</pre>
    </div>