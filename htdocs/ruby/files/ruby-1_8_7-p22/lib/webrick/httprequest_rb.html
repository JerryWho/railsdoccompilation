  <div id="fileHeader">
    <h1>httprequest.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/webrick/httprequest.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# httprequest.rb -- HTTPRequest Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httprequest.rb,v 1.64 2003/07/13 17:18:22 gotoyuzo Exp $

require 'timeout'
require 'uri'

require 'webrick/httpversion'
require 'webrick/httpstatus'
require 'webrick/httputils'
require 'webrick/cookie'

module WEBrick

  class HTTPRequest
    BODY_CONTAINABLE_METHODS = [ &quot;POST&quot;, &quot;PUT&quot; ]
    BUFSIZE = 1024*4

    # Request line
    attr_reader :request_line
    attr_reader :request_method, :unparsed_uri, :http_version

    # Request-URI
    attr_reader :request_uri, :host, :port, :path
    attr_accessor :script_name, :path_info, :query_string

    # Header and entity body
    attr_reader :raw_header, :header, :cookies
    attr_reader :accept, :accept_charset
    attr_reader :accept_encoding, :accept_language

    # Misc
    attr_accessor :user
    attr_reader :addr, :peeraddr
    attr_reader :attributes
    attr_reader :keep_alive
    attr_reader :request_time

    def initialize(config)
      @config = config
      @logger = config[:Logger]

      @request_line = @request_method =
        @unparsed_uri = @http_version = nil

      @request_uri = @host = @port = @path = nil
      @script_name = @path_info = nil
      @query_string = nil
      @query = nil
      @form_data = nil

      @raw_header = Array.new
      @header = nil
      @cookies = []
      @accept = []
      @accept_charset = []
      @accept_encoding = []
      @accept_language = []
      @body = &quot;&quot;

      @addr = @peeraddr = nil
      @attributes = {}
      @user = nil
      @keep_alive = false
      @request_time = nil

      @remaining_size = nil
      @socket = nil
    end

    def parse(socket=nil)
      @socket = socket
      begin
        @peeraddr = socket.respond_to?(:peeraddr) ? socket.peeraddr : []
        @addr = socket.respond_to?(:addr) ? socket.addr : []
      rescue Errno::ENOTCONN
        raise HTTPStatus::EOFError
      end

      read_request_line(socket)
      if @http_version.major &gt; 0
        read_header(socket)
        @header['cookie'].each{|cookie|
          @cookies += Cookie::parse(cookie)
        }
        @accept = HTTPUtils.parse_qvalues(self['accept'])
        @accept_charset = HTTPUtils.parse_qvalues(self['accept-charset'])
        @accept_encoding = HTTPUtils.parse_qvalues(self['accept-encoding'])
        @accept_language = HTTPUtils.parse_qvalues(self['accept-language'])
      end
      return if @request_method == &quot;CONNECT&quot;
      return if @unparsed_uri == &quot;*&quot;

      begin
        @request_uri = parse_uri(@unparsed_uri)
        @path = HTTPUtils::unescape(@request_uri.path)
        @path = HTTPUtils::normalize_path(@path)
        @host = @request_uri.host
        @port = @request_uri.port
        @query_string = @request_uri.query
        @script_name = &quot;&quot;
        @path_info = @path.dup
      rescue
        raise HTTPStatus::BadRequest, &quot;bad URI `#{@unparsed_uri}'.&quot;
      end

      if /close/io =~ self[&quot;connection&quot;]
        @keep_alive = false
      elsif /keep-alive/io =~ self[&quot;connection&quot;]
        @keep_alive = true
      elsif @http_version &lt; &quot;1.1&quot;
        @keep_alive = false
      else
        @keep_alive = true
      end
    end

    def body(&amp;block)
      block ||= Proc.new{|chunk| @body &lt;&lt; chunk }
      read_body(@socket, block)
      @body.empty? ? nil : @body
    end

    def query
      unless @query
        parse_query()
      end
      @query
    end

    def content_length
      return Integer(self['content-length'])
    end

    def content_type
      return self['content-type']
    end

    def [](header_name)
      if @header
        value = @header[header_name.downcase]
        value.empty? ? nil : value.join(&quot;, &quot;)
      end
    end

    def each
      @header.each{|k, v|
        value = @header[k]
        yield(k, value.empty? ? nil : value.join(&quot;, &quot;))
      }
    end

    def keep_alive?
      @keep_alive
    end

    def to_s
      ret = @request_line.dup
      @raw_header.each{|line| ret &lt;&lt; line }
      ret &lt;&lt; CRLF
      ret &lt;&lt; body if body
      ret
    end

    def fixup()
      begin
        body{|chunk| }   # read remaining body
      rescue HTTPStatus::Error =&gt; ex
        @logger.error(&quot;HTTPRequest#fixup: #{ex.class} occured.&quot;)
        @keep_alive = false
      rescue =&gt; ex
        @logger.error(ex)
        @keep_alive = false
      end
    end

    def meta_vars
      # This method provides the metavariables defined by the revision 3
      # of ``The WWW Common Gateway Interface Version 1.1''.
      # (http://Web.Golux.Com/coar/cgi/)

      meta = Hash.new

      cl = self[&quot;Content-Length&quot;]
      ct = self[&quot;Content-Type&quot;]
      meta[&quot;CONTENT_LENGTH&quot;]    = cl if cl.to_i &gt; 0
      meta[&quot;CONTENT_TYPE&quot;]      = ct.dup if ct
      meta[&quot;GATEWAY_INTERFACE&quot;] = &quot;CGI/1.1&quot;
      meta[&quot;PATH_INFO&quot;]         = @path_info ? @path_info.dup : &quot;&quot;
     #meta[&quot;PATH_TRANSLATED&quot;]   = nil      # no plan to be provided
      meta[&quot;QUERY_STRING&quot;]      = @query_string ? @query_string.dup : &quot;&quot;
      meta[&quot;REMOTE_ADDR&quot;]       = @peeraddr[3]
      meta[&quot;REMOTE_HOST&quot;]       = @peeraddr[2]
     #meta[&quot;REMOTE_IDENT&quot;]      = nil      # no plan to be provided
      meta[&quot;REMOTE_USER&quot;]       = @user
      meta[&quot;REQUEST_METHOD&quot;]    = @request_method.dup
      meta[&quot;REQUEST_URI&quot;]       = @request_uri.to_s
      meta[&quot;SCRIPT_NAME&quot;]       = @script_name.dup
      meta[&quot;SERVER_NAME&quot;]       = @host
      meta[&quot;SERVER_PORT&quot;]       = @port.to_s
      meta[&quot;SERVER_PROTOCOL&quot;]   = &quot;HTTP/&quot; + @config[:HTTPVersion].to_s
      meta[&quot;SERVER_SOFTWARE&quot;]   = @config[:ServerSoftware].dup

      self.each{|key, val|
        next if /^content-type$/i =~ key
        next if /^content-length$/i =~ key
        name = &quot;HTTP_&quot; + key
        name.gsub!(/-/o, &quot;_&quot;)
        name.upcase!
        meta[name] = val
      }

      meta
    end

    private

    def read_request_line(socket)
      @request_line = read_line(socket) if socket
      @request_time = Time.now
      raise HTTPStatus::EOFError unless @request_line
      if /^(\S+)\s+(\S+)(?:\s+HTTP\/(\d+\.\d+))?\r?\n/mo =~ @request_line
        @request_method = $1
        @unparsed_uri   = $2
        @http_version   = HTTPVersion.new($3 ? $3 : &quot;0.9&quot;)
      else
        rl = @request_line.sub(/\x0d?\x0a\z/o, '')
        raise HTTPStatus::BadRequest, &quot;bad Request-Line `#{rl}'.&quot;
      end
    end

    def read_header(socket)
      if socket
        while line = read_line(socket)
          break if /\A(#{CRLF}|#{LF})\z/om =~ line
          @raw_header &lt;&lt; line
        end
      end
      begin
        @header = HTTPUtils::parse_header(@raw_header)
      rescue =&gt; ex
        raise  HTTPStatus::BadRequest, ex.message
      end
    end

    def parse_uri(str, scheme=&quot;http&quot;)
      if @config[:Escape8bitURI]
        str = HTTPUtils::escape8bit(str)
      end
      uri = URI::parse(str)
      return uri if uri.absolute?
      if self[&quot;host&quot;]
        pattern = /\A(#{URI::REGEXP::PATTERN::HOST})(?::(\d+))?\z/n
        host, port = *self['host'].scan(pattern)[0]
      elsif @addr.size &gt; 0
        host, port = @addr[2], @addr[1]
      else
        host, port = @config[:ServerName], @config[:Port]
      end
      uri.scheme = scheme
      uri.host = host
      uri.port = port ? port.to_i : nil
      return URI::parse(uri.to_s)
    end

    def read_body(socket, block)
      return unless socket
      if tc = self['transfer-encoding']
        case tc
        when /chunked/io then read_chunked(socket, block)
        else raise HTTPStatus::NotImplemented, &quot;Transfer-Encoding: #{tc}.&quot;
        end
      elsif self['content-length'] || @remaining_size
        @remaining_size ||= self['content-length'].to_i
        while @remaining_size &gt; 0 
          sz = BUFSIZE &lt; @remaining_size ? BUFSIZE : @remaining_size
          break unless buf = read_data(socket, sz)
          @remaining_size -= buf.size
          block.call(buf)
        end
        if @remaining_size &gt; 0 &amp;&amp; @socket.eof?
          raise HTTPStatus::BadRequest, &quot;invalid body size.&quot;
        end
      elsif BODY_CONTAINABLE_METHODS.member?(@request_method)
        raise HTTPStatus::LengthRequired
      end
      return @body
    end

    def read_chunk_size(socket)
      line = read_line(socket)
      if /^([0-9a-fA-F]+)(?:;(\S+))?/ =~ line
        chunk_size = $1.hex
        chunk_ext = $2
        [ chunk_size, chunk_ext ]
      else
        raise HTTPStatus::BadRequest, &quot;bad chunk `#{line}'.&quot;
      end
    end

    def read_chunked(socket, block)
      chunk_size, = read_chunk_size(socket)
      while chunk_size &gt; 0
        data = &quot;&quot;
        while data.size &lt; chunk_size
          tmp = read_data(socket, chunk_size-data.size) # read chunk-data
          break unless tmp
          data &lt;&lt; tmp
        end
        if data.nil? || data.size != chunk_size
          raise BadRequest, &quot;bad chunk data size.&quot;
        end
        read_line(socket)                    # skip CRLF
        block.call(data)
        chunk_size, = read_chunk_size(socket)
      end
      read_header(socket)                    # trailer + CRLF
      @header.delete(&quot;transfer-encoding&quot;)
      @remaining_size = 0
    end

    def _read_data(io, method, arg)
      begin
        timeout(@config[:RequestTimeout]){
          return io.__send__(method, arg)
        }
      rescue Errno::ECONNRESET
        return nil
      rescue TimeoutError
        raise HTTPStatus::RequestTimeout
      end
    end

    def read_line(io)
      _read_data(io, :gets, LF)
    end

    def read_data(io, size)
      _read_data(io, :read, size)
    end

    def parse_query()
      begin
        if @request_method == &quot;GET&quot; || @request_method == &quot;HEAD&quot;
          @query = HTTPUtils::parse_query(@query_string)
        elsif self['content-type'] =~ /^application\/x-www-form-urlencoded/
          @query = HTTPUtils::parse_query(body)
        elsif self['content-type'] =~ /^multipart\/form-data; boundary=(.+)/
          boundary = HTTPUtils::dequote($1)
          @query = HTTPUtils::parse_form_data(body, boundary)
        else
          @query = Hash.new
        end
      rescue =&gt; ex
        raise HTTPStatus::BadRequest, ex.message
      end
    end
  end
end
</pre>
    </div>