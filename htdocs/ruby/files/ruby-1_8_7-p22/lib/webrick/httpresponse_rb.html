  <div id="fileHeader">
    <h1>httpresponse.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/webrick/httpresponse.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# httpresponse.rb -- HTTPResponse Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2000, 2001 TAKAHASHI Masayoshi, GOTOU Yuuzou
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpresponse.rb,v 1.45 2003/07/11 11:02:25 gotoyuzo Exp $

require 'time'
require 'webrick/httpversion'
require 'webrick/htmlutils'
require 'webrick/httputils'
require 'webrick/httpstatus'

module WEBrick
  class HTTPResponse
    BUFSIZE = 1024*4

    attr_reader :http_version, :status, :header
    attr_reader :cookies
    attr_accessor :reason_phrase
    attr_accessor :body

    attr_accessor :request_method, :request_uri, :request_http_version
    attr_accessor :filename
    attr_accessor :keep_alive
    attr_reader :config, :sent_size

    def initialize(config)
      @config = config
      @logger = config[:Logger]
      @header = Hash.new
      @status = HTTPStatus::RC_OK
      @reason_phrase = nil
      @http_version = HTTPVersion::convert(@config[:HTTPVersion])
      @body = ''
      @keep_alive = true
      @cookies = []
      @request_method = nil
      @request_uri = nil
      @request_http_version = @http_version  # temporary
      @chunked = false
      @filename = nil
      @sent_size = 0
    end

    def status_line
      &quot;HTTP/#@http_version #@status #@reason_phrase #{CRLF}&quot;
    end

    def status=(status)
      @status = status
      @reason_phrase = HTTPStatus::reason_phrase(status)
    end

    def [](field)
      @header[field.downcase]
    end

    def []=(field, value)
      @header[field.downcase] = value.to_s
    end

    def content_length
      if len = self['content-length']
        return Integer(len)
      end
    end

    def content_length=(len)
      self['content-length'] = len.to_s
    end

    def content_type
      self['content-type']
    end

    def content_type=(type)
      self['content-type'] = type
    end

    def each
      @header.each{|k, v|  yield(k, v) }
    end

    def chunked?
      @chunked
    end

    def chunked=(val)
      @chunked = val ? true : false
    end

    def keep_alive?
      @keep_alive
    end

    def send_response(socket)
      begin
        setup_header()
        send_header(socket)
        send_body(socket)
      rescue Errno::EPIPE, Errno::ECONNRESET, Errno::ENOTCONN =&gt; ex
        @logger.debug(ex)
        @keep_alive = false
      rescue Exception =&gt; ex
        @logger.error(ex)
        @keep_alive = false
      end
    end

    def setup_header()
      @reason_phrase    ||= HTTPStatus::reason_phrase(@status)
      @header['server'] ||= @config[:ServerSoftware]
      @header['date']   ||= Time.now.httpdate

      # HTTP/0.9 features
      if @request_http_version &lt; &quot;1.0&quot;
        @http_version = HTTPVersion.new(&quot;0.9&quot;)
        @keep_alive = false
      end

      # HTTP/1.0 features
      if @request_http_version &lt; &quot;1.1&quot;
        if chunked?
          @chunked = false
          ver = @request_http_version.to_s
          msg = &quot;chunked is set for an HTTP/#{ver} request. (ignored)&quot;
          @logger.warn(msg)
        end
      end

      # Determine the message length (RFC2616 -- 4.4 Message Length)
      if @status == 304 || @status == 204 || HTTPStatus::info?(@status)
        @header.delete('content-length')
        @body = &quot;&quot;
      elsif chunked?
        @header[&quot;transfer-encoding&quot;] = &quot;chunked&quot;
        @header.delete('content-length')
      elsif %r{^multipart/byteranges} =~ @header['content-type']
        @header.delete('content-length')
      elsif @header['content-length'].nil?
        unless @body.is_a?(IO)
          @header['content-length'] = @body ? @body.size : 0
        end
      end

      # Keep-Alive connection.
      if @header['connection'] == &quot;close&quot;
         @keep_alive = false
      elsif keep_alive?
        if chunked? || @header['content-length']
          @header['connection'] = &quot;Keep-Alive&quot;
        end
      else
        @header['connection'] = &quot;close&quot;
      end

      # Location is a single absoluteURI.
      if location = @header['location']
        if @request_uri
          @header['location'] = @request_uri.merge(location)
        end
      end
    end

    def send_header(socket)
      if @http_version.major &gt; 0
        data = status_line()
        @header.each{|key, value|
          tmp = key.gsub(/\bwww|^te$|\b\w/){|s| s.upcase }
          data &lt;&lt; &quot;#{tmp}: #{value}&quot; &lt;&lt; CRLF
        }
        @cookies.each{|cookie|
          data &lt;&lt; &quot;Set-Cookie: &quot; &lt;&lt; cookie.to_s &lt;&lt; CRLF
        }
        data &lt;&lt; CRLF
        _write_data(socket, data)
      end
    end

    def send_body(socket)
      case @body
      when IO then send_body_io(socket)
      else send_body_string(socket)
      end
    end

    def to_s
      ret = &quot;&quot;
      send_response(ret)
      ret
    end

    def set_redirect(status, url)
      @body = &quot;&lt;HTML&gt;&lt;A HREF=\&quot;#{url.to_s}\&quot;&gt;#{url.to_s}&lt;/A&gt;.&lt;/HTML&gt;\n&quot;
      @header['location'] = url.to_s
      raise status
    end

    def set_error(ex, backtrace=false)
      case ex
      when HTTPStatus::Status 
        @keep_alive = false if HTTPStatus::error?(ex.code)
        self.status = ex.code
      else 
        @keep_alive = false
        self.status = HTTPStatus::RC_INTERNAL_SERVER_ERROR
      end
      @header['content-type'] = &quot;text/html&quot;

      if respond_to?(:create_error_page)
        create_error_page()
        return
      end

      if @request_uri
        host, port = @request_uri.host, @request_uri.port
      else
        host, port = @config[:ServerName], @config[:Port]
      end

      @body = ''
      @body &lt;&lt; &lt;&lt;-_end_of_html_
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0//EN&quot;&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;&lt;TITLE&gt;#{HTMLUtils::escape(@reason_phrase)}&lt;/TITLE&gt;&lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;H1&gt;#{HTMLUtils::escape(@reason_phrase)}&lt;/H1&gt;
    #{HTMLUtils::escape(ex.message)}
    &lt;HR&gt;
      _end_of_html_

      if backtrace &amp;&amp; $DEBUG
        @body &lt;&lt; &quot;backtrace of `#{HTMLUtils::escape(ex.class.to_s)}' &quot;
        @body &lt;&lt; &quot;#{HTMLUtils::escape(ex.message)}&quot;
        @body &lt;&lt; &quot;&lt;PRE&gt;&quot;
        ex.backtrace.each{|line| @body &lt;&lt; &quot;\t#{line}\n&quot;}
        @body &lt;&lt; &quot;&lt;/PRE&gt;&lt;HR&gt;&quot;
      end

      @body &lt;&lt; &lt;&lt;-_end_of_html_
    &lt;ADDRESS&gt;
     #{HTMLUtils::escape(@config[:ServerSoftware])} at
     #{host}:#{port}
    &lt;/ADDRESS&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
      _end_of_html_
    end

    private

    def send_body_io(socket)
      begin
        if @request_method == &quot;HEAD&quot;
          # do nothing
        elsif chunked?
          while buf = @body.read(BUFSIZE)
            next if buf.empty?
            data = &quot;&quot;
            data &lt;&lt; format(&quot;%x&quot;, buf.size) &lt;&lt; CRLF
            data &lt;&lt; buf &lt;&lt; CRLF
            _write_data(socket, data)
            @sent_size += buf.size
          end
          _write_data(socket, &quot;0#{CRLF}#{CRLF}&quot;)
        else
          size = @header['content-length'].to_i
          _send_file(socket, @body, 0, size)
          @sent_size = size
        end
      ensure
        @body.close
      end
    end

    def send_body_string(socket)
      if @request_method == &quot;HEAD&quot;
        # do nothing
      elsif chunked?
        remain = body ? @body.size : 0
        while buf = @body[@sent_size, BUFSIZE]
          break if buf.empty?
          data = &quot;&quot;
          data &lt;&lt; format(&quot;%x&quot;, buf.size) &lt;&lt; CRLF
          data &lt;&lt; buf &lt;&lt; CRLF
          _write_data(socket, data)
          @sent_size += buf.size
        end
        _write_data(socket, &quot;0#{CRLF}#{CRLF}&quot;)
      else
        if @body &amp;&amp; @body.size &gt; 0
          _write_data(socket, @body)
          @sent_size = @body.size
        end
      end
    end

    def _send_file(output, input, offset, size)
      while offset &gt; 0
        sz = BUFSIZE &lt; offset ? BUFSIZE : offset
        buf = input.read(sz)
        offset -= buf.size
      end

      if size == 0
        while buf = input.read(BUFSIZE)
          _write_data(output, buf)
        end
      else
        while size &gt; 0
          sz = BUFSIZE &lt; size ? BUFSIZE : size
          buf = input.read(sz)
          _write_data(output, buf)
          size -= buf.size
        end
      end
    end

    def _write_data(socket, data)
      socket &lt;&lt; data
    end
  end
end
</pre>
    </div>