  <div id="fileHeader">
    <h1>httpproxy.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/webrick/httpproxy.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# httpproxy.rb -- HTTPProxy Class
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2002 GOTO Kentaro
# Copyright (c) 2002 Internet Programming with Ruby writers. All rights
# reserved.
#
# $IPR: httpproxy.rb,v 1.18 2003/03/08 18:58:10 gotoyuzo Exp $
# $kNotwork: straw.rb,v 1.3 2002/02/12 15:13:07 gotoken Exp $

require &quot;webrick/httpserver&quot;
require &quot;net/http&quot;

Net::HTTP::version_1_2 if RUBY_VERSION &lt; &quot;1.7&quot;

module WEBrick
  NullReader = Object.new
  class &lt;&lt; NullReader
    def read(*args)
      nil
    end
    alias gets read
  end

  class HTTPProxyServer &lt; HTTPServer
    def initialize(config)
      super
      c = @config
      @via = &quot;#{c[:HTTPVersion]} #{c[:ServerName]}:#{c[:Port]}&quot;
    end

    def service(req, res)
      if req.request_method == &quot;CONNECT&quot;
        proxy_connect(req, res)
      elsif req.unparsed_uri =~ %r!^http://!
        proxy_service(req, res)
      else
        super(req, res)
      end
    end

    def proxy_auth(req, res)
      if proc = @config[:ProxyAuthProc]
        proc.call(req, res)
      end
      req.header.delete(&quot;proxy-authorization&quot;)
    end

    # Some header fields should not be transferred.
    HopByHop = %w( connection keep-alive proxy-authenticate upgrade
                   proxy-authorization te trailers transfer-encoding )
    ShouldNotTransfer = %w( set-cookie proxy-connection )
    def split_field(f) f ? f.split(/,\s+/).collect{|i| i.downcase } : [] end

    def choose_header(src, dst)
      connections = split_field(src['connection'])
      src.each{|key, value|
        key = key.downcase
        if HopByHop.member?(key)          || # RFC2616: 13.5.1
           connections.member?(key)       || # RFC2616: 14.10
           ShouldNotTransfer.member?(key)    # pragmatics
          @logger.debug(&quot;choose_header: `#{key}: #{value}'&quot;)
          next
        end
        dst[key] = value
      }
    end

    # Net::HTTP is stupid about the multiple header fields.
    # Here is workaround:
    def set_cookie(src, dst)
      if str = src['set-cookie']
        cookies = []
        str.split(/,\s*/).each{|token|
          if /^[^=]+;/o =~ token
            cookies[-1] &lt;&lt; &quot;, &quot; &lt;&lt; token
          elsif /=/o =~ token
            cookies &lt;&lt; token
          else
            cookies[-1] &lt;&lt; &quot;, &quot; &lt;&lt; token
          end
        }
        dst.cookies.replace(cookies)
      end
    end

    def set_via(h)
      if @config[:ProxyVia]
        if  h['via']
          h['via'] &lt;&lt; &quot;, &quot; &lt;&lt; @via
        else
          h['via'] = @via
        end
      end
    end

    def proxy_uri(req, res)
      @config[:ProxyURI]
    end

    def proxy_service(req, res)
      # Proxy Authentication
      proxy_auth(req, res)      

      # Create Request-URI to send to the origin server
      uri  = req.request_uri
      path = uri.path.dup
      path &lt;&lt; &quot;?&quot; &lt;&lt; uri.query if uri.query

      # Choose header fields to transfer
      header = Hash.new
      choose_header(req, header)
      set_via(header)

      # select upstream proxy server
      if proxy = proxy_uri(req, res)
        proxy_host = proxy.host
        proxy_port = proxy.port
        if proxy.userinfo
          credentials = &quot;Basic &quot; + [proxy.userinfo].pack(&quot;m*&quot;)
          credentials.chomp!
          header['proxy-authorization'] = credentials
        end
      end

      response = nil
      begin
        http = Net::HTTP.new(uri.host, uri.port, proxy_host, proxy_port)
        http.start{
          if @config[:ProxyTimeout]
            ##################################   these issues are 
            http.open_timeout = 30   # secs  #   necessary (maybe bacause
            http.read_timeout = 60   # secs  #   Ruby's bug, but why?)
            ##################################
          end
          case req.request_method
          when &quot;GET&quot;  then response = http.get(path, header)
          when &quot;POST&quot; then response = http.post(path, req.body || &quot;&quot;, header)
          when &quot;HEAD&quot; then response = http.head(path, header)
          else
            raise HTTPStatus::MethodNotAllowed,
              &quot;unsupported method `#{req.request_method}'.&quot;
          end
        }
      rescue =&gt; err
        logger.debug(&quot;#{err.class}: #{err.message}&quot;)
        raise HTTPStatus::ServiceUnavailable, err.message
      end
  
      # Persistent connction requirements are mysterious for me.
      # So I will close the connection in every response.
      res['proxy-connection'] = &quot;close&quot;
      res['connection'] = &quot;close&quot;

      # Convert Net::HTTP::HTTPResponse to WEBrick::HTTPProxy
      res.status = response.code.to_i
      choose_header(response, res)
      set_cookie(response, res)
      set_via(res)
      res.body = response.body

      # Process contents
      if handler = @config[:ProxyContentHandler]
        handler.call(req, res)
      end
    end

    def proxy_connect(req, res)
      # Proxy Authentication
      proxy_auth(req, res)

      ua = Thread.current[:WEBrickSocket]  # User-Agent
      raise HTTPStatus::InternalServerError,
        &quot;[BUG] cannot get socket&quot; unless ua

      host, port = req.unparsed_uri.split(&quot;:&quot;, 2)
      # Proxy authentication for upstream proxy server
      if proxy = proxy_uri(req, res)
        proxy_request_line = &quot;CONNECT #{host}:#{port} HTTP/1.0&quot;
        if proxy.userinfo
          credentials = &quot;Basic &quot; + [proxy.userinfo].pack(&quot;m*&quot;)
          credentials.chomp!
        end
        host, port = proxy.host, proxy.port
      end

      begin
        @logger.debug(&quot;CONNECT: upstream proxy is `#{host}:#{port}'.&quot;)
        os = TCPSocket.new(host, port)     # origin server

        if proxy
          @logger.debug(&quot;CONNECT: sending a Request-Line&quot;)
          os &lt;&lt; proxy_request_line &lt;&lt; CRLF
          @logger.debug(&quot;CONNECT: &gt; #{proxy_request_line}&quot;)
          if credentials
            @logger.debug(&quot;CONNECT: sending a credentials&quot;)
            os &lt;&lt; &quot;Proxy-Authorization: &quot; &lt;&lt; credentials &lt;&lt; CRLF
          end
          os &lt;&lt; CRLF
          proxy_status_line = os.gets(LF)
          @logger.debug(&quot;CONNECT: read a Status-Line form the upstream server&quot;)
          @logger.debug(&quot;CONNECT: &lt; #{proxy_status_line}&quot;)
          if %r{^HTTP/\d+\.\d+\s+200\s*} =~ proxy_status_line
            while line = os.gets(LF)
              break if /\A(#{CRLF}|#{LF})\z/om =~ line
            end
          else
            raise HTTPStatus::BadGateway
          end
        end
        @logger.debug(&quot;CONNECT #{host}:#{port}: succeeded&quot;)
        res.status = HTTPStatus::RC_OK
      rescue =&gt; ex
        @logger.debug(&quot;CONNECT #{host}:#{port}: failed `#{ex.message}'&quot;)
        res.set_error(ex)
        raise HTTPStatus::EOFError
      ensure
        if handler = @config[:ProxyContentHandler]
          handler.call(req, res)
        end
        res.send_response(ua)
        access_log(@config, req, res)

        # Should clear request-line not to send the sesponse twice.
        # see: HTTPServer#run
        req.parse(NullReader) rescue nil
      end

      begin
        while fds = IO::select([ua, os])
          if fds[0].member?(ua)
            buf = ua.sysread(1024);
            @logger.debug(&quot;CONNECT: #{buf.size} byte from User-Agent&quot;)
            os.syswrite(buf)
          elsif fds[0].member?(os)
            buf = os.sysread(1024);
            @logger.debug(&quot;CONNECT: #{buf.size} byte from #{host}:#{port}&quot;)
            ua.syswrite(buf)
          end
        end
      rescue =&gt; ex
        os.close
        @logger.debug(&quot;CONNECT #{host}:#{port}: closed&quot;)
      end

      raise HTTPStatus::EOFError
    end

    def do_OPTIONS(req, res)
      res['allow'] = &quot;GET,HEAD,POST,OPTIONS,CONNECT&quot;
    end
  end
end
</pre>
    </div>