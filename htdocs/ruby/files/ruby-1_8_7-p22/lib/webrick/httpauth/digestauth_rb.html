  <div id="fileHeader">
    <h1>digestauth.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/webrick/httpauth/digestauth.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# httpauth/digestauth.rb -- HTTP digest access authentication
#
# Author: IPR -- Internet Programming with Ruby -- writers
# Copyright (c) 2003 Internet Programming with Ruby writers.
# Copyright (c) 2003 H.M.
#
# The original implementation is provided by H.M.
#   URL: http://rwiki.jin.gr.jp/cgi-bin/rw-cgi.rb?cmd=view;name=
#        %C7%A7%BE%DA%B5%A1%C7%BD%A4%F2%B2%FE%C2%A4%A4%B7%A4%C6%A4%DF%A4%EB
#
# $IPR: digestauth.rb,v 1.5 2003/02/20 07:15:47 gotoyuzo Exp $

require 'webrick/config'
require 'webrick/httpstatus'
require 'webrick/httpauth/authenticator'
require 'digest/md5'
require 'digest/sha1'

module WEBrick
  module HTTPAuth
    class DigestAuth
      include Authenticator

      AuthScheme = &quot;Digest&quot;
      OpaqueInfo = Struct.new(:time, :nonce, :nc)
      attr_reader :algorithm, :qop

      def self.make_passwd(realm, user, pass)
        pass ||= &quot;&quot;
        Digest::MD5::hexdigest([user, realm, pass].join(&quot;:&quot;))
      end

      def initialize(config, default=Config::DigestAuth)
        check_init(config)
        @config                 = default.dup.update(config)
        @algorithm              = @config[:Algorithm]
        @domain                 = @config[:Domain]
        @qop                    = @config[:Qop]
        @use_opaque             = @config[:UseOpaque]
        @use_next_nonce         = @config[:UseNextNonce]
        @check_nc               = @config[:CheckNc]
        @use_auth_info_header   = @config[:UseAuthenticationInfoHeader]
        @nonce_expire_period    = @config[:NonceExpirePeriod]
        @nonce_expire_delta     = @config[:NonceExpireDelta]
        @internet_explorer_hack = @config[:InternetExplorerHack]
        @opera_hack             = @config[:OperaHack]

        case @algorithm
        when 'MD5','MD5-sess'
          @h = Digest::MD5
        when 'SHA1','SHA1-sess'  # it is a bonus feature :-)
          @h = Digest::SHA1
        else
          msg = format('Alogrithm &quot;%s&quot; is not supported.', @algorithm)
          raise ArgumentError.new(msg)
        end

        @instance_key = hexdigest(self.__id__, Time.now.to_i, Process.pid)
        @opaques = {}
        @last_nonce_expire = Time.now
        @mutex = Mutex.new
      end

      def authenticate(req, res)
        unless result = @mutex.synchronize{ _authenticate(req, res) }
          challenge(req, res)
        end
        if result == :nonce_is_stale
          challenge(req, res, true)
        end
        return true
      end

      def challenge(req, res, stale=false)
        nonce = generate_next_nonce(req)
        if @use_opaque
          opaque = generate_opaque(req)
          @opaques[opaque].nonce = nonce
        end

        param = Hash.new
        param[&quot;realm&quot;]  = HTTPUtils::quote(@realm)
        param[&quot;domain&quot;] = HTTPUtils::quote(@domain.to_a.join(&quot; &quot;)) if @domain
        param[&quot;nonce&quot;]  = HTTPUtils::quote(nonce)
        param[&quot;opaque&quot;] = HTTPUtils::quote(opaque) if opaque
        param[&quot;stale&quot;]  = stale.to_s
        param[&quot;algorithm&quot;] = @algorithm
        param[&quot;qop&quot;]    = HTTPUtils::quote(@qop.to_a.join(&quot;,&quot;)) if @qop

        res[@response_field] =
          &quot;#{@auth_scheme} &quot; + param.map{|k,v| &quot;#{k}=#{v}&quot; }.join(&quot;, &quot;)
        info(&quot;%s: %s&quot;, @response_field, res[@response_field]) if $DEBUG
        raise @auth_exception
      end

      private

      MustParams = ['username','realm','nonce','uri','response']
      MustParamsAuth = ['cnonce','nc']

      def _authenticate(req, res)
        unless digest_credentials = check_scheme(req)
          return false
        end

        auth_req = split_param_value(digest_credentials)
        if auth_req['qop'] == &quot;auth&quot; || auth_req['qop'] == &quot;auth-int&quot;
          req_params = MustParams + MustParamsAuth
        else
          req_params = MustParams
        end
        req_params.each{|key|
          unless auth_req.has_key?(key)
            error('%s: parameter missing. &quot;%s&quot;', auth_req['username'], key)
            raise HTTPStatus::BadRequest
          end
        }

        if !check_uri(req, auth_req)
          raise HTTPStatus::BadRequest  
        end

        if auth_req['realm'] != @realm  
          error('%s: realm unmatch. &quot;%s&quot; for &quot;%s&quot;',
                auth_req['username'], auth_req['realm'], @realm)
          return false
        end

        auth_req['algorithm'] ||= 'MD5' 
        if auth_req['algorithm'] != @algorithm &amp;&amp;
           (@opera_hack &amp;&amp; auth_req['algorithm'] != @algorithm.upcase)
          error('%s: algorithm unmatch. &quot;%s&quot; for &quot;%s&quot;',
                auth_req['username'], auth_req['algorithm'], @algorithm)
          return false
        end

        if (@qop.nil? &amp;&amp; auth_req.has_key?('qop')) ||
           (@qop &amp;&amp; (! @qop.member?(auth_req['qop'])))
          error('%s: the qop is not allowed. &quot;%s&quot;',
                auth_req['username'], auth_req['qop'])
          return false
        end

        password = @userdb.get_passwd(@realm, auth_req['username'], @reload_db)
        unless password
          error('%s: the user is not allowd.', auth_req['username'])
          return false
        end

        nonce_is_invalid = false
        if @use_opaque
          info(&quot;@opaque = %s&quot;, @opaque.inspect) if $DEBUG
          if !(opaque = auth_req['opaque'])
            error('%s: opaque is not given.', auth_req['username'])
            nonce_is_invalid = true
          elsif !(opaque_struct = @opaques[opaque])
            error('%s: invalid opaque is given.', auth_req['username'])
            nonce_is_invalid = true
          elsif !check_opaque(opaque_struct, req, auth_req)
            @opaques.delete(auth_req['opaque'])
            nonce_is_invalid = true
          end
        elsif !check_nonce(req, auth_req)
          nonce_is_invalid = true
        end

        if /-sess$/ =~ auth_req['algorithm'] ||
           (@opera_hack &amp;&amp; /-SESS$/ =~ auth_req['algorithm'])
          ha1 = hexdigest(password, auth_req['nonce'], auth_req['cnonce'])
        else
          ha1 = password
        end

        if auth_req['qop'] == &quot;auth&quot; || auth_req['qop'] == nil
          ha2 = hexdigest(req.request_method, auth_req['uri'])
          ha2_res = hexdigest(&quot;&quot;, auth_req['uri'])
        elsif auth_req['qop'] == &quot;auth-int&quot;
          ha2 = hexdigest(req.request_method, auth_req['uri'],
                          hexdigest(req.body))
          ha2_res = hexdigest(&quot;&quot;, auth_req['uri'], hexdigest(res.body))
        end

        if auth_req['qop'] == &quot;auth&quot; || auth_req['qop'] == &quot;auth-int&quot;
          param2 = ['nonce', 'nc', 'cnonce', 'qop'].map{|key|
            auth_req[key]
          }.join(':')
          digest     = hexdigest(ha1, param2, ha2)
          digest_res = hexdigest(ha1, param2, ha2_res)
        else
          digest     = hexdigest(ha1, auth_req['nonce'], ha2)
          digest_res = hexdigest(ha1, auth_req['nonce'], ha2_res)
        end

        if digest != auth_req['response']
          error(&quot;%s: digest unmatch.&quot;, auth_req['username'])
          return false
        elsif nonce_is_invalid
          error('%s: digest is valid, but nonce is not valid.',
                auth_req['username'])
          return :nonce_is_stale
        elsif @use_auth_info_header
          auth_info = {
            'nextnonce' =&gt; generate_next_nonce(req),
            'rspauth'   =&gt; digest_res
          }
          if @use_opaque
            opaque_struct.time  = req.request_time
            opaque_struct.nonce = auth_info['nextnonce']
            opaque_struct.nc    = &quot;%08x&quot; % (auth_req['nc'].hex + 1)
          end
          if auth_req['qop'] == &quot;auth&quot; || auth_req['qop'] == &quot;auth-int&quot;
            ['qop','cnonce','nc'].each{|key|
              auth_info[key] = auth_req[key]
            }
          end
          res[@resp_info_field] = auth_info.keys.map{|key|
            if key == 'nc'
              key + '=' + auth_info[key]
            else
              key + &quot;=&quot; + HTTPUtils::quote(auth_info[key])
            end
          }.join(', ')
        end
        info('%s: authentication scceeded.', auth_req['username'])
        req.user = auth_req['username']
        return true
      end

      def split_param_value(string)
        ret = {}
        while string.size != 0
          case string           
          when /^\s*([\w\-\.\*\%\!]+)=\s*\&quot;((\\.|[^\&quot;])*)\&quot;\s*,?/
            key = $1
            matched = $2
            string = $'
            ret[key] = matched.gsub(/\\(.)/, &quot;\\1&quot;)
          when /^\s*([\w\-\.\*\%\!]+)=\s*([^,\&quot;]*),?/
            key = $1
            matched = $2
            string = $'
            ret[key] = matched.clone
          when /^s*^,/
            string = $'
          else
            break
          end
        end
        ret
      end

      def generate_next_nonce(req)
        now = &quot;%012d&quot; % req.request_time.to_i
        pk  = hexdigest(now, @instance_key)[0,32]
        nonce = [now + &quot;:&quot; + pk].pack(&quot;m*&quot;).chop # it has 60 length of chars.
        nonce
      end

      def check_nonce(req, auth_req)
        username = auth_req['username']
        nonce = auth_req['nonce']

        pub_time, pk = nonce.unpack(&quot;m*&quot;)[0].split(&quot;:&quot;, 2)
        if (!pub_time || !pk)
          error(&quot;%s: empty nonce is given&quot;, username)
          return false
        elsif (hexdigest(pub_time, @instance_key)[0,32] != pk)
          error(&quot;%s: invalid private-key: %s for %s&quot;,
                username, hexdigest(pub_time, @instance_key)[0,32], pk)
          return false
        end

        diff_time = req.request_time.to_i - pub_time.to_i
        if (diff_time &lt; 0)
          error(&quot;%s: difference of time-stamp is negative.&quot;, username)
          return false
        elsif diff_time &gt; @nonce_expire_period
          error(&quot;%s: nonce is expired.&quot;, username)
          return false
        end

        return true
      end

      def generate_opaque(req)
        @mutex.synchronize{
          now = req.request_time
          if now - @last_nonce_expire &gt; @nonce_expire_delta
            @opaques.delete_if{|key,val|
              (now - val.time) &gt; @nonce_expire_period
            }
            @last_nonce_expire = now
          end
          begin
            opaque = Utils::random_string(16)
          end while @opaques[opaque]
          @opaques[opaque] = OpaqueInfo.new(now, nil, '00000001')
          opaque
        }
      end

      def check_opaque(opaque_struct, req, auth_req)
        if (@use_next_nonce &amp;&amp; auth_req['nonce'] != opaque_struct.nonce)
          error('%s: nonce unmatched. &quot;%s&quot; for &quot;%s&quot;',
                auth_req['username'], auth_req['nonce'], opaque_struct.nonce)
          return false
        elsif !check_nonce(req, auth_req)
          return false
        end
        if (@check_nc &amp;&amp; auth_req['nc'] != opaque_struct.nc)
          error('%s: nc unmatched.&quot;%s&quot; for &quot;%s&quot;',
                auth_req['username'], auth_req['nc'], opaque_struct.nc)
          return false
        end
        true
      end

      def check_uri(req, auth_req)
        uri = auth_req['uri']
        if uri != req.request_uri.to_s &amp;&amp; uri != req.unparsed_uri &amp;&amp;
           (@internet_explorer_hack &amp;&amp; uri != req.path)
          error('%s: uri unmatch. &quot;%s&quot; for &quot;%s&quot;', auth_req['username'], 
                auth_req['uri'], req.request_uri.to_s)
          return false
        end
        true
      end

      def hexdigest(*args)
        @h.hexdigest(args.join(&quot;:&quot;))
      end
    end

    class ProxyDigestAuth &lt; DigestAuth
      include ProxyAuthenticator

      def check_uri(req, auth_req)
        return true
      end
    end
  end
end
</pre>
    </div>