  <div id="fileHeader">
    <h1>streamlistener.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/streamlistener.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module REXML
	# A template for stream parser listeners.
	# Note that the declarations (attlistdecl, elementdecl, etc) are trivially
	# processed; REXML doesn't yet handle doctype entity declarations, so you 
	# have to parse them out yourself.
	module StreamListener
		# Called when a tag is encountered.
		# @p name the tag name
		# @p attrs an array of arrays of attribute/value pairs, suitable for
		# use with assoc or rassoc.  IE, &lt;tag attr1=&quot;value1&quot; attr2=&quot;value2&quot;&gt;
		# will result in 
		# tag_start( &quot;tag&quot;, # [[&quot;attr1&quot;,&quot;value1&quot;],[&quot;attr2&quot;,&quot;value2&quot;]])
		def tag_start name, attrs
		end
		# Called when the end tag is reached.  In the case of &lt;tag/&gt;, tag_end
		# will be called immidiately after tag_start
		# @p the name of the tag
		def tag_end name
		end
		# Called when text is encountered in the document
		# @p text the text content.
		def text text
		end
		# Called when an instruction is encountered.  EG: &lt;?xsl sheet='foo'?&gt;
		# @p name the instruction name; in the example, &quot;xsl&quot;
		# @p instruction the rest of the instruction.  In the example,
		# &quot;sheet='foo'&quot;
		def instruction name, instruction
		end
		# Called when a comment is encountered.
		# @p comment The content of the comment
		def comment comment
		end
		# Handles a doctype declaration. Any attributes of the doctype which are
		# not supplied will be nil.  # EG, &lt;!DOCTYPE me PUBLIC &quot;foo&quot; &quot;bar&quot;&gt;
		# @p name the name of the doctype; EG, &quot;me&quot;
		# @p pub_sys &quot;PUBLIC&quot;, &quot;SYSTEM&quot;, or nil.  EG, &quot;PUBLIC&quot;
		# @p long_name the supplied long name, or nil.  EG, &quot;foo&quot;
		# @p uri the uri of the doctype, or nil.  EG, &quot;bar&quot;
		def doctype name, pub_sys, long_name, uri
		end
		# Called when the doctype is done
		def doctype_end
		end
		# If a doctype includes an ATTLIST declaration, it will cause this
		# method to be called.  The content is the declaration itself, unparsed.
		# EG, &lt;!ATTLIST el attr CDATA #REQUIRED&gt; will come to this method as &quot;el
		# attr CDATA #REQUIRED&quot;.  This is the same for all of the .*decl
		# methods.
		def attlistdecl element_name, attributes, raw_content
		end
		# &lt;!ELEMENT ...&gt;
		def elementdecl content
		end
		# &lt;!ENTITY ...&gt;
		# The argument passed to this method is an array of the entity
		# declaration.  It can be in a number of formats, but in general it
		# returns (example, result):
		#  &lt;!ENTITY % YN '&quot;Yes&quot;'&gt;  
		#  [&quot;%&quot;, &quot;YN&quot;, &quot;'\&quot;Yes\&quot;'&quot;, &quot;\&quot;&quot;]
		#  &lt;!ENTITY % YN 'Yes'&gt;
		#  [&quot;%&quot;, &quot;YN&quot;, &quot;'Yes'&quot;, &quot;s&quot;]
		#  &lt;!ENTITY WhatHeSaid &quot;He said %YN;&quot;&gt;
		#  [&quot;WhatHeSaid&quot;, &quot;\&quot;He said %YN;\&quot;&quot;, &quot;YN&quot;]
		#  &lt;!ENTITY open-hatch SYSTEM &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;
		#  [&quot;open-hatch&quot;, &quot;SYSTEM&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]
		#  &lt;!ENTITY open-hatch PUBLIC &quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN&quot; &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;
		#  [&quot;open-hatch&quot;, &quot;PUBLIC&quot;, &quot;\&quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN\&quot;&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]
		#  &lt;!ENTITY hatch-pic SYSTEM &quot;../grafix/OpenHatch.gif&quot; NDATA gif&gt;
		#  [&quot;hatch-pic&quot;, &quot;SYSTEM&quot;, &quot;\&quot;../grafix/OpenHatch.gif\&quot;&quot;, &quot;\n\t\t\t\t\t\t\tNDATA gif&quot;, &quot;gif&quot;]
		def entitydecl content
		end
		# &lt;!NOTATION ...&gt;
		def notationdecl content
		end
		# Called when %foo; is encountered in a doctype declaration.
		# @p content &quot;foo&quot;
		def entity content
		end
		# Called when &lt;![CDATA[ ... ]]&gt; is encountered in a document.
		# @p content &quot;...&quot;
		def cdata content
		end
		# Called when an XML PI is encountered in the document.
		# EG: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf&quot;?&gt;
		# @p version the version attribute value.  EG, &quot;1.0&quot;
		# @p encoding the encoding attribute value, or nil.  EG, &quot;utf&quot;
		# @p standalone the standalone attribute value, or nil.  EG, nil
		def xmldecl version, encoding, standalone
		end
	end
end
</pre>
    </div>