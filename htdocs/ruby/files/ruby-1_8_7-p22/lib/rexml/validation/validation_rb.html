  <div id="fileHeader">
    <h1>validation.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/validation/validation.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/validation/validationexception'

module REXML
  module Validation
    module Validator
      NILEVENT = [ nil ]
      def reset
        @current = @root
        @root.reset
        @root.previous = true
        @attr_stack = []
        self
      end
      def dump
        puts @root.inspect
      end
      def validate( event ) 
        #puts &quot;Current: #@current&quot;
        #puts &quot;Event: #{event.inspect}&quot;
        @attr_stack = [] unless defined? @attr_stack
        match = @current.next(event)
        raise ValidationException.new( &quot;Validation error.  Expected: &quot;+
          @current.expected.join( &quot; or &quot; )+&quot; from #{@current.inspect} &quot;+
          &quot; but got #{Event.new( event[0], event[1] ).inspect}&quot; ) unless match
        @current = match

        # Check for attributes
        case event[0]
        when :start_element
          #puts &quot;Checking attributes&quot;
          @attr_stack &lt;&lt; event[2]
          begin
            sattr = [:start_attribute, nil]
            eattr = [:end_attribute]
            text = [:text, nil]
            k,v = event[2].find { |k,v| 
              sattr[1] = k
              #puts &quot;Looking for #{sattr.inspect}&quot;
              m = @current.next( sattr )
              #puts &quot;Got #{m.inspect}&quot;
              if m 
                # If the state has text children...
                #puts &quot;Looking for #{eattr.inspect}&quot;
                #puts &quot;Expect #{m.expected}&quot;
                if m.matches?( eattr )
                  #puts &quot;Got end&quot;
                  @current = m
                else
                  #puts &quot;Didn't get end&quot;
                  text[1] = v
                  #puts &quot;Looking for #{text.inspect}&quot;
                  m = m.next( text )
                  #puts &quot;Got #{m.inspect}&quot;
                  text[1] = nil
                  return false unless m
                  @current = m if m
                end
                m = @current.next( eattr )
                if m
                  @current = m
                  true
                else
                  false
                end
              else
                false
              end
            }
            event[2].delete(k) if k
          end while k
        when :end_element
          attrs = @attr_stack.pop
          raise ValidationException.new( &quot;Validation error.  Illegal &quot;+
            &quot; attributes: #{attrs.inspect}&quot;) if attrs.length &gt; 0
        end
      end
    end

    class Event
      def initialize(event_type, event_arg=nil )
        @event_type = event_type
        @event_arg = event_arg
      end

      attr_reader :event_type
      attr_accessor :event_arg

      def done?
        @done
      end

      def single?
        return (@event_type != :start_element and @event_type != :start_attribute)
      end

      def matches?( event )
        #puts &quot;#@event_type =? #{event[0]} &amp;&amp; #@event_arg =? #{event[1]} &quot;
        return false unless event[0] == @event_type
        case event[0]
        when nil
          return true
        when :start_element
          return true if event[1] == @event_arg
        when :end_element
          return true
        when :start_attribute
          return true if event[1] == @event_arg
        when :end_attribute
          return true
        when :end_document
          return true
        when :text
          return (@event_arg.nil? or @event_arg == event[1])
=begin
        when :processing_instruction
          false
        when :xmldecl
          false
        when :start_doctype
          false
        when :end_doctype
          false
        when :externalentity
          false
        when :elementdecl
          false
        when :entity
          false
        when :attlistdecl
          false
        when :notationdecl
          false
        when :end_doctype
          false
=end
        else
          false
        end
      end

      def ==( other )
        return false unless other.kind_of? Event
        @event_type == other.event_type and @event_arg == other.event_arg
      end

      def to_s
        inspect
      end

      def inspect
        &quot;#{@event_type.inspect}( #@event_arg )&quot;
      end
    end
  end
end
</pre>
    </div>