  <div id="fileHeader">
    <h1>doctype.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/doctype.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Apr 18 02:22:13 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;rexml/parent&quot;
require &quot;rexml/parseexception&quot;
require &quot;rexml/namespace&quot;
require 'rexml/entity'
require 'rexml/attlistdecl'
require 'rexml/xmltokens'

module REXML
  # Represents an XML DOCTYPE declaration; that is, the contents of &lt;!DOCTYPE
  # ... &gt;.  DOCTYPES can be used to declare the DTD of a document, as well as
  # being used to declare entities used in the document.
  class DocType &lt; Parent
    include XMLTokens
    START = &quot;&lt;!DOCTYPE&quot;
    STOP = &quot;&gt;&quot;
    SYSTEM = &quot;SYSTEM&quot;
    PUBLIC = &quot;PUBLIC&quot;
    DEFAULT_ENTITIES = { 
      'gt'=&gt;EntityConst::GT, 
      'lt'=&gt;EntityConst::LT, 
      'quot'=&gt;EntityConst::QUOT, 
      &quot;apos&quot;=&gt;EntityConst::APOS 
    }

    # name is the name of the doctype
    # external_id is the referenced DTD, if given
    attr_reader :name, :external_id, :entities, :namespaces

    # Constructor
    #
    #   dt = DocType.new( 'foo', '-//I/Hate/External/IDs' )
    #   # &lt;!DOCTYPE foo '-//I/Hate/External/IDs'&gt;
    #   dt = DocType.new( doctype_to_clone )
    #   # Incomplete.  Shallow clone of doctype
    #
    # +Note+ that the constructor: 
    #
    #  Doctype.new( Source.new( &quot;&lt;!DOCTYPE foo 'bar'&gt;&quot; ) )
    #
    # is _deprecated_.  Do not use it.  It will probably disappear.
    def initialize( first, parent=nil )
      @entities = DEFAULT_ENTITIES
      @long_name = @uri = nil
      if first.kind_of? String
        super()
        @name = first
        @external_id = parent
      elsif first.kind_of? DocType
        super( parent )
        @name = first.name
        @external_id = first.external_id
      elsif first.kind_of? Array
        super( parent )
        @name = first[0]
        @external_id = first[1]
        @long_name = first[2]
        @uri = first[3]
      elsif first.kind_of? Source
        super( parent )
        parser = Parsers::BaseParser.new( first )
        event = parser.pull
        if event[0] == :start_doctype
          @name, @external_id, @long_name, @uri, = event[1..-1]
        end
      else
        super()
      end
    end

    def node_type
      :doctype
    end

    def attributes_of element
      rv = []
      each do |child|
        child.each do |key,val|
          rv &lt;&lt; Attribute.new(key,val)
        end if child.kind_of? AttlistDecl and child.element_name == element
      end
      rv
    end

    def attribute_of element, attribute
      att_decl = find do |child|
        child.kind_of? AttlistDecl and
        child.element_name == element and
        child.include? attribute
      end
      return nil unless att_decl
      att_decl[attribute]
    end

    def clone
      DocType.new self
    end

    # output::
    #   Where to write the string
    # indent::
    #   An integer.  If -1, no indentation will be used; otherwise, the
    #   indentation will be this number of spaces, and children will be
    #   indented an additional amount.
    # transitive::
    #   Ignored
    # ie_hack::
    #   Ignored
    def write( output, indent=0, transitive=false, ie_hack=false )
      f = REXML::Formatters::Default.new
      indent( output, indent )
      output &lt;&lt; START
      output &lt;&lt; ' '
      output &lt;&lt; @name
      output &lt;&lt; &quot; #@external_id&quot; if @external_id
      output &lt;&lt; &quot; #{@long_name.inspect}&quot; if @long_name
      output &lt;&lt; &quot; #{@uri.inspect}&quot; if @uri
      unless @children.empty?
        next_indent = indent + 1
        output &lt;&lt; ' ['
        child = nil    # speed
        @children.each { |child|
          output &lt;&lt; &quot;\n&quot;
          f.write( child, output )
        }
        output &lt;&lt; &quot;\n]&quot;
      end
      output &lt;&lt; STOP
    end

    def context
      @parent.context
    end

    def entity( name )
      @entities[name].unnormalized if @entities[name]
    end

    def add child
      super(child)
      @entities = DEFAULT_ENTITIES.clone if @entities == DEFAULT_ENTITIES
      @entities[ child.name ] = child if child.kind_of? Entity
    end
    
    # This method retrieves the public identifier identifying the document's 
    # DTD.
    #
    # Method contributed by Henrik Martensson
    def public
      case @external_id
      when &quot;SYSTEM&quot;
        nil
      when &quot;PUBLIC&quot;
        strip_quotes(@long_name)
      end
    end
    
    # This method retrieves the system identifier identifying the document's DTD
    #
    # Method contributed by Henrik Martensson
    def system
      case @external_id
      when &quot;SYSTEM&quot;
        strip_quotes(@long_name)
      when &quot;PUBLIC&quot;
        @uri.kind_of?(String) ? strip_quotes(@uri) : nil
      end
    end
    
    # This method returns a list of notations that have been declared in the
    # _internal_ DTD subset. Notations in the external DTD subset are not 
    # listed.
    #
    # Method contributed by Henrik Martensson
    def notations
      children().select {|node| node.kind_of?(REXML::NotationDecl)}
    end
    
    # Retrieves a named notation. Only notations declared in the internal
    # DTD subset can be retrieved.
    #
    # Method contributed by Henrik Martensson
    def notation(name)
      notations.find { |notation_decl|
        notation_decl.name == name
      }
    end
    
    private
    
    # Method contributed by Henrik Martensson
    def strip_quotes(quoted_string)
      quoted_string =~ /^[\'\&quot;].*[\Â´\&quot;]$/ ?
        quoted_string[1, quoted_string.length-2] :
        quoted_string
    end
  end

  # We don't really handle any of these since we're not a validating
  # parser, so we can be pretty dumb about them.  All we need to be able
  # to do is spew them back out on a write()

  # This is an abstract class.  You never use this directly; it serves as a
  # parent class for the specific declarations.
  class Declaration &lt; Child
    def initialize src
      super()
      @string = src
    end

    def to_s
      @string+'&gt;'
    end

    # == DEPRECATED
    # See REXML::Formatters
    #
    def write( output, indent )
      output &lt;&lt; to_s
    end
  end
  
  public
  class ElementDecl &lt; Declaration
    def initialize( src )
      super
    end
  end

  class ExternalEntity &lt; Child
    def initialize( src )
      super()
      @entity = src
    end
    def to_s
      @entity
    end
    def write( output, indent )
      output &lt;&lt; @entity
    end
  end

  class NotationDecl &lt; Child
    attr_accessor :public, :system
    def initialize name, middle, pub, sys
      super(nil)
      @name = name
      @middle = middle
      @public = pub
      @system = sys
    end

    def to_s
      &quot;&lt;!NOTATION #@name #@middle#{
        @public ? ' ' + public.inspect : '' 
      }#{
        @system ? ' ' +@system.inspect : ''
      }&gt;&quot;
    end

    def write( output, indent=-1 )
      output &lt;&lt; to_s
    end
    
    # This method retrieves the name of the notation.
    #
    # Method contributed by Henrik Martensson
    def name
      @name
    end
  end
end
</pre>
    </div>