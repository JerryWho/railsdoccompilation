  <div id="fileHeader">
    <h1>attlistdecl.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/attlistdecl.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#vim:ts=2 sw=2 noexpandtab:
require 'rexml/child'
require 'rexml/source'

module REXML
	# This class needs:
	# * Documentation
	# * Work!  Not all types of attlists are intelligently parsed, so we just
	# spew back out what we get in.  This works, but it would be better if
	# we formatted the output ourselves.
	#
	# AttlistDecls provide *just* enough support to allow namespace
	# declarations.  If you need some sort of generalized support, or have an
	# interesting idea about how to map the hideous, terrible design of DTD
	# AttlistDecls onto an intuitive Ruby interface, let me know.  I'm desperate
	# for anything to make DTDs more palateable.
	class AttlistDecl &lt; Child
		include Enumerable

		# What is this?  Got me.
		attr_reader :element_name

		# Create an AttlistDecl, pulling the information from a Source.  Notice
		# that this isn't very convenient; to create an AttlistDecl, you basically
		# have to format it yourself, and then have the initializer parse it.
		# Sorry, but for the forseeable future, DTD support in REXML is pretty
		# weak on convenience.  Have I mentioned how much I hate DTDs?
		def initialize(source)
			super()
			if (source.kind_of? Array)
				@element_name, @pairs, @contents = *source
			end
		end
	
		# Access the attlist attribute/value pairs.
		#  value = attlist_decl[ attribute_name ]
		def [](key)
			@pairs[key]
		end

		# Whether an attlist declaration includes the given attribute definition
		#  if attlist_decl.include? &quot;xmlns:foobar&quot;
		def include?(key)
			@pairs.keys.include? key
		end

		# Iterate over the key/value pairs:
		#  attlist_decl.each { |attribute_name, attribute_value| ... }
		def each(&amp;block)
			@pairs.each(&amp;block)
		end

		# Write out exactly what we got in.
		def write out, indent=-1
			out &lt;&lt; @contents
		end

		def node_type
			:attlistdecl
		end
	end
end
</pre>
    </div>