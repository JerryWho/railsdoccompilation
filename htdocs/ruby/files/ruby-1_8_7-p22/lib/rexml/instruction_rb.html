  <div id="fileHeader">
    <h1>instruction.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/instruction.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Apr 18 02:22:13 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;rexml/child&quot;
require &quot;rexml/source&quot;

module REXML
	# Represents an XML Instruction; IE, &lt;? ... ?&gt;
	# TODO: Add parent arg (3rd arg) to constructor
	class Instruction &lt; Child
		START = '&lt;\?'
		STOP = '\?&gt;'

		# target is the &quot;name&quot; of the Instruction; IE, the &quot;tag&quot; in &lt;?tag ...?&gt;
		# content is everything else.
		attr_accessor :target, :content

		# Constructs a new Instruction
		# @param target can be one of a number of things.  If String, then 
		# the target of this instruction is set to this.  If an Instruction,
		# then the Instruction is shallowly cloned (target and content are
		# copied).  If a Source, then the source is scanned and parsed for
		# an Instruction declaration.
		# @param content Must be either a String, or a Parent.  Can only
		# be a Parent if the target argument is a Source.  Otherwise, this
		# String is set as the content of this instruction.
		def initialize(target, content=nil)
			if target.kind_of? String
				super()
				@target = target
				@content = content
			elsif target.kind_of? Instruction
				super(content)
				@target = target.target
				@content = target.content
			end
			@content.strip! if @content
		end

		def clone
			Instruction.new self
		end
		
    # == DEPRECATED
    # See the rexml/formatters package
    #
		def write writer, indent=-1, transitive=false, ie_hack=false
      Kernel.warn( &quot;#{self.class.name}.write is deprecated&quot; )
			indent(writer, indent)
			writer &lt;&lt; START.sub(/\\/u, '')
			writer &lt;&lt; @target
			writer &lt;&lt; ' '
			writer &lt;&lt; @content
			writer &lt;&lt; STOP.sub(/\\/u, '')
		end

		# @return true if other is an Instruction, and the content and target
		# of the other matches the target and content of this object.
		def ==( other )
			other.kind_of? Instruction and
			other.target == @target and
			other.content == @content
		end

    def node_type
      :processing_instruction
    end

    def inspect
      &quot;&lt;?p-i #{target} ...?&gt;&quot;
    end
	end
end
</pre>
    </div>