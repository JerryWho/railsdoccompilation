  <div id="fileHeader">
    <h1>baseparser.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/parsers/baseparser.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Apr 18 02:22:13 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/parseexception'
require 'rexml/undefinednamespaceexception'
require 'rexml/source'
require 'set'

module REXML
  module Parsers
    # = Using the Pull Parser
    # &lt;em&gt;This API is experimental, and subject to change.&lt;/em&gt;
    #  parser = PullParser.new( &quot;&lt;a&gt;text&lt;b att='val'/&gt;txet&lt;/a&gt;&quot; )
    #  while parser.has_next?
    #    res = parser.next
    #    puts res[1]['att'] if res.start_tag? and res[0] == 'b'
    #  end
    # See the PullEvent class for information on the content of the results.
    # The data is identical to the arguments passed for the various events to
    # the StreamListener API.
    #
    # Notice that:
    #  parser = PullParser.new( &quot;&lt;a&gt;BAD DOCUMENT&quot; )
    #  while parser.has_next?
    #    res = parser.next
    #    raise res[1] if res.error?
    #  end
    #
    # Nat Price gave me some good ideas for the API.
    class BaseParser
      NCNAME_STR= '[\w:][\-\w\d.]*'
      NAME_STR= &quot;(?:(#{NCNAME_STR}):)?(#{NCNAME_STR})&quot;
      UNAME_STR= &quot;(?:#{NCNAME_STR}:)?#{NCNAME_STR}&quot;

      NAMECHAR = '[\-\w\d\.:]'
      NAME = &quot;([\\w:]#{NAMECHAR}*)&quot;
      NMTOKEN = &quot;(?:#{NAMECHAR})+&quot;
      NMTOKENS = &quot;#{NMTOKEN}(\\s+#{NMTOKEN})*&quot;
      REFERENCE = &quot;(?:&amp;#{NAME};|&amp;#\\d+;|&amp;#x[0-9a-fA-F]+;)&quot;
      REFERENCE_RE = /#{REFERENCE}/

      DOCTYPE_START = /\A\s*&lt;!DOCTYPE\s/um
      DOCTYPE_PATTERN = /\s*&lt;!DOCTYPE\s+(.*?)(\[|&gt;)/um
      ATTRIBUTE_PATTERN = /\s*(#{NAME_STR})\s*=\s*([&quot;'])(.*?)\4/um
      COMMENT_START = /\A&lt;!--/u
      COMMENT_PATTERN = /&lt;!--(.*?)--&gt;/um
      CDATA_START = /\A&lt;!\[CDATA\[/u
      CDATA_END = /^\s*\]\s*&gt;/um
      CDATA_PATTERN = /&lt;!\[CDATA\[(.*?)\]\]&gt;/um
      XMLDECL_START = /\A&lt;\?xml\s/u;
      XMLDECL_PATTERN = /&lt;\?xml\s+(.*?)\?&gt;/um
      INSTRUCTION_START = /\A&lt;\?/u
      INSTRUCTION_PATTERN = /&lt;\?(.*?)(\s+.*?)?\?&gt;/um
      TAG_MATCH = /^&lt;((?&gt;#{NAME_STR}))\s*((?&gt;\s+#{UNAME_STR}\s*=\s*([&quot;']).*?\5)*)\s*(\/)?&gt;/um
      CLOSE_MATCH = /^\s*&lt;\/(#{NAME_STR})\s*&gt;/um

      VERSION = /\bversion\s*=\s*[&quot;'](.*?)['&quot;]/um
      ENCODING = /\bencoding\s*=\s*[&quot;'](.*?)['&quot;]/um
      STANDALONE = /\bstandalone\s*=\s[&quot;'](.*?)['&quot;]/um

      ENTITY_START = /^\s*&lt;!ENTITY/
      IDENTITY = /^([!\*\w\-]+)(\s+#{NCNAME_STR})?(\s+[&quot;'](.*?)['&quot;])?(\s+['&quot;](.*?)[&quot;'])?/u
      ELEMENTDECL_START = /^\s*&lt;!ELEMENT/um
      ELEMENTDECL_PATTERN = /^\s*(&lt;!ELEMENT.*?)&gt;/um
      SYSTEMENTITY = /^\s*(%.*?;)\s*$/um
      ENUMERATION = &quot;\\(\\s*#{NMTOKEN}(?:\\s*\\|\\s*#{NMTOKEN})*\\s*\\)&quot;
      NOTATIONTYPE = &quot;NOTATION\\s+\\(\\s*#{NAME}(?:\\s*\\|\\s*#{NAME})*\\s*\\)&quot;
      ENUMERATEDTYPE = &quot;(?:(?:#{NOTATIONTYPE})|(?:#{ENUMERATION}))&quot;
      ATTTYPE = &quot;(CDATA|ID|IDREF|IDREFS|ENTITY|ENTITIES|NMTOKEN|NMTOKENS|#{ENUMERATEDTYPE})&quot;
      ATTVALUE = &quot;(?:\&quot;((?:[^&lt;&amp;\&quot;]|#{REFERENCE})*)\&quot;)|(?:'((?:[^&lt;&amp;']|#{REFERENCE})*)')&quot;
      DEFAULTDECL = &quot;(#REQUIRED|#IMPLIED|(?:(#FIXED\\s+)?#{ATTVALUE}))&quot;
      ATTDEF = &quot;\\s+#{NAME}\\s+#{ATTTYPE}\\s+#{DEFAULTDECL}&quot;
      ATTDEF_RE = /#{ATTDEF}/
      ATTLISTDECL_START = /^\s*&lt;!ATTLIST/um
      ATTLISTDECL_PATTERN = /^\s*&lt;!ATTLIST\s+#{NAME}(?:#{ATTDEF})*\s*&gt;/um
      NOTATIONDECL_START = /^\s*&lt;!NOTATION/um
      PUBLIC = /^\s*&lt;!NOTATION\s+(\w[\-\w]*)\s+(PUBLIC)\s+([&quot;'])(.*?)\3(?:\s+([&quot;'])(.*?)\5)?\s*&gt;/um
      SYSTEM = /^\s*&lt;!NOTATION\s+(\w[\-\w]*)\s+(SYSTEM)\s+([&quot;'])(.*?)\3\s*&gt;/um

      TEXT_PATTERN = /\A([^&lt;]*)/um

      # Entity constants
      PUBIDCHAR = &quot;\x20\x0D\x0Aa-zA-Z0-9\\-()+,./:=?;!*@$_%#&quot;
      SYSTEMLITERAL = %Q{((?:&quot;[^&quot;]*&quot;)|(?:'[^']*'))}
      PUBIDLITERAL = %Q{(&quot;[#{PUBIDCHAR}']*&quot;|'[#{PUBIDCHAR}]*')}
      EXTERNALID = &quot;(?:(?:(SYSTEM)\\s+#{SYSTEMLITERAL})|(?:(PUBLIC)\\s+#{PUBIDLITERAL}\\s+#{SYSTEMLITERAL}))&quot;
      NDATADECL = &quot;\\s+NDATA\\s+#{NAME}&quot;
      PEREFERENCE = &quot;%#{NAME};&quot;
      ENTITYVALUE = %Q{((?:&quot;(?:[^%&amp;&quot;]|#{PEREFERENCE}|#{REFERENCE})*&quot;)|(?:'([^%&amp;']|#{PEREFERENCE}|#{REFERENCE})*'))}
      PEDEF = &quot;(?:#{ENTITYVALUE}|#{EXTERNALID})&quot;
      ENTITYDEF = &quot;(?:#{ENTITYVALUE}|(?:#{EXTERNALID}(#{NDATADECL})?))&quot;
      PEDECL = &quot;&lt;!ENTITY\\s+(%)\\s+#{NAME}\\s+#{PEDEF}\\s*&gt;&quot;
      GEDECL = &quot;&lt;!ENTITY\\s+#{NAME}\\s+#{ENTITYDEF}\\s*&gt;&quot;
      ENTITYDECL = /\s*(?:#{GEDECL})|(?:#{PEDECL})/um

      EREFERENCE = /&amp;(?!#{NAME};)/

      DEFAULT_ENTITIES = { 
        'gt' =&gt; [/&amp;gt;/, '&amp;gt;', '&gt;', /&gt;/], 
        'lt' =&gt; [/&amp;lt;/, '&amp;lt;', '&lt;', /&lt;/], 
        'quot' =&gt; [/&amp;quot;/, '&amp;quot;', '&quot;', /&quot;/], 
        &quot;apos&quot; =&gt; [/&amp;apos;/, &quot;&amp;apos;&quot;, &quot;'&quot;, /'/] 
      }


      ######################################################################
      # These are patterns to identify common markup errors, to make the
      # error messages more informative.
      ######################################################################
      MISSING_ATTRIBUTE_QUOTES = /^&lt;#{NAME_STR}\s+#{NAME_STR}\s*=\s*[^&quot;']/um

      def initialize( source )
        self.stream = source
      end

      def add_listener( listener )
        if !defined?(@listeners) or !@listeners
          @listeners = []
          instance_eval &lt;&lt;-EOL
            alias :_old_pull :pull
            def pull
              event = _old_pull
              @listeners.each do |listener|
                listener.receive event
              end
              event
            end
          EOL
        end
        @listeners &lt;&lt; listener
      end

      attr_reader :source

      def stream=( source )
        @source = SourceFactory.create_from( source )
        @closed = nil
        @document_status = nil
        @tags = []
        @stack = []
        @entities = []
        @nsstack = []
      end

      def position
        if @source.respond_to? :position
          @source.position
        else
          # FIXME
          0
        end
      end

      # Returns true if there are no more events
      def empty?
        return (@source.empty? and @stack.empty?)
      end

      # Returns true if there are more events.  Synonymous with !empty?
      def has_next?
        return !(@source.empty? and @stack.empty?)
      end

      # Push an event back on the head of the stream.  This method
      # has (theoretically) infinite depth.
      def unshift token
        @stack.unshift(token)
      end

      # Peek at the +depth+ event in the stack.  The first element on the stack
      # is at depth 0.  If +depth+ is -1, will parse to the end of the input
      # stream and return the last event, which is always :end_document.
      # Be aware that this causes the stream to be parsed up to the +depth+ 
      # event, so you can effectively pre-parse the entire document (pull the 
      # entire thing into memory) using this method.  
      def peek depth=0
        raise %Q[Illegal argument &quot;#{depth}&quot;] if depth &lt; -1
        temp = []
        if depth == -1
          temp.push(pull()) until empty?
        else
          while @stack.size+temp.size &lt; depth+1
            temp.push(pull())
          end
        end
        @stack += temp if temp.size &gt; 0
        @stack[depth]
      end

      # Returns the next event.  This is a +PullEvent+ object.
      def pull
        if @closed
          x, @closed = @closed, nil
          return [ :end_element, x ]
        end
        return [ :end_document ] if empty?
        return @stack.shift if @stack.size &gt; 0
        #STDERR.puts @source.encoding
        @source.read if @source.buffer.size&lt;2
        #STDERR.puts &quot;BUFFER = #{@source.buffer.inspect}&quot;
        if @document_status == nil
          #@source.consume( /^\s*/um )
          word = @source.match( /^((?:\s+)|(?:&lt;[^&gt;]*&gt;))/um )
          word = word[1] unless word.nil?
          #STDERR.puts &quot;WORD = #{word.inspect}&quot;
          case word
          when COMMENT_START
            return [ :comment, @source.match( COMMENT_PATTERN, true )[1] ]
          when XMLDECL_START
            #STDERR.puts &quot;XMLDECL&quot;
            results = @source.match( XMLDECL_PATTERN, true )[1]
            version = VERSION.match( results )
            version = version[1] unless version.nil?
            encoding = ENCODING.match(results)
            encoding = encoding[1] unless encoding.nil?
            @source.encoding = encoding
            standalone = STANDALONE.match(results)
            standalone = standalone[1] unless standalone.nil?
            return [ :xmldecl, version, encoding, standalone ]
          when INSTRUCTION_START
            return [ :processing_instruction, *@source.match(INSTRUCTION_PATTERN, true)[1,2] ]
          when DOCTYPE_START
            md = @source.match( DOCTYPE_PATTERN, true )
            @nsstack.unshift(curr_ns=Set.new)
            identity = md[1]
            close = md[2]
            identity =~ IDENTITY
            name = $1
            raise REXML::ParseException.new(&quot;DOCTYPE is missing a name&quot;) if name.nil?
            pub_sys = $2.nil? ? nil : $2.strip
            long_name = $4.nil? ? nil : $4.strip
            uri = $6.nil? ? nil : $6.strip
            args = [ :start_doctype, name, pub_sys, long_name, uri ]
            if close == &quot;&gt;&quot;
              @document_status = :after_doctype
              @source.read if @source.buffer.size&lt;2
              md = @source.match(/^\s*/um, true)
              @stack &lt;&lt; [ :end_doctype ]
            else
              @document_status = :in_doctype
            end
            return args
          when /^\s+/
          else
            @document_status = :after_doctype
            @source.read if @source.buffer.size&lt;2
            md = @source.match(/\s*/um, true)
          end
        end
        if @document_status == :in_doctype
          md = @source.match(/\s*(.*?&gt;)/um)
          case md[1]
          when SYSTEMENTITY 
            match = @source.match( SYSTEMENTITY, true )[1]
            return [ :externalentity, match ]

          when ELEMENTDECL_START
            return [ :elementdecl, @source.match( ELEMENTDECL_PATTERN, true )[1] ]

          when ENTITY_START
            match = @source.match( ENTITYDECL, true ).to_a.compact
            match[0] = :entitydecl
            ref = false
            if match[1] == '%'
              ref = true
              match.delete_at 1
            end
            # Now we have to sort out what kind of entity reference this is
            if match[2] == 'SYSTEM'
              # External reference
              match[3] = match[3][1..-2] # PUBID
              match.delete_at(4) if match.size &gt; 4 # Chop out NDATA decl
              # match is [ :entity, name, SYSTEM, pubid(, ndata)? ]
            elsif match[2] == 'PUBLIC'
              # External reference
              match[3] = match[3][1..-2] # PUBID
              match[4] = match[4][1..-2] # HREF
              # match is [ :entity, name, PUBLIC, pubid, href ]
            else
              match[2] = match[2][1..-2]
              match.pop if match.size == 4
              # match is [ :entity, name, value ]
            end
            match &lt;&lt; '%' if ref
            return match
          when ATTLISTDECL_START
            md = @source.match( ATTLISTDECL_PATTERN, true )
            raise REXML::ParseException.new( &quot;Bad ATTLIST declaration!&quot;, @source ) if md.nil?
            element = md[1]
            contents = md[0]

            pairs = {}
            values = md[0].scan( ATTDEF_RE )
            values.each do |attdef|
              unless attdef[3] == &quot;#IMPLIED&quot;
                attdef.compact!
                val = attdef[3]
                val = attdef[4] if val == &quot;#FIXED &quot;
                pairs[attdef[0]] = val
                if attdef[0] =~ /^xmlns:(.*)/
                  @nsstack[0] &lt;&lt; $1
                end
              end
            end
            return [ :attlistdecl, element, pairs, contents ]
          when NOTATIONDECL_START
            md = nil
            if @source.match( PUBLIC )
              md = @source.match( PUBLIC, true )
              vals = [md[1],md[2],md[4],md[6]]
            elsif @source.match( SYSTEM )
              md = @source.match( SYSTEM, true )
              vals = [md[1],md[2],nil,md[4]]
            else
              raise REXML::ParseException.new( &quot;error parsing notation: no matching pattern&quot;, @source )
            end
            return [ :notationdecl, *vals ]
          when CDATA_END
            @document_status = :after_doctype
            @source.match( CDATA_END, true )
            return [ :end_doctype ]
          end
        end
        begin
          if @source.buffer[0] == ?&lt;
            if @source.buffer[1] == ?/
              @nsstack.shift
              last_tag = @tags.pop
              #md = @source.match_to_consume( '&gt;', CLOSE_MATCH)
              md = @source.match( CLOSE_MATCH, true )
              raise REXML::ParseException.new( &quot;Missing end tag for &quot;+
                &quot;'#{last_tag}' (got \&quot;#{md[1]}\&quot;)&quot;, 
                @source) unless last_tag == md[1]
              return [ :end_element, last_tag ]
            elsif @source.buffer[1] == ?!
              md = @source.match(/\A(\s*[^&gt;]*&gt;)/um)
              #STDERR.puts &quot;SOURCE BUFFER = #{source.buffer}, #{source.buffer.size}&quot;
              raise REXML::ParseException.new(&quot;Malformed node&quot;, @source) unless md
              if md[0][2] == ?-
                md = @source.match( COMMENT_PATTERN, true )
                return [ :comment, md[1] ] if md
              else
                md = @source.match( CDATA_PATTERN, true )
                return [ :cdata, md[1] ] if md
              end
              raise REXML::ParseException.new( &quot;Declarations can only occur &quot;+
                &quot;in the doctype declaration.&quot;, @source)
            elsif @source.buffer[1] == ??
              md = @source.match( INSTRUCTION_PATTERN, true )
              return [ :processing_instruction, md[1], md[2] ] if md
              raise REXML::ParseException.new( &quot;Bad instruction declaration&quot;,
                @source)
            else
              # Get the next tag
              md = @source.match(TAG_MATCH, true)
              unless md
                # Check for missing attribute quotes
                raise REXML::ParseException.new(&quot;missing attribute quote&quot;, @source) if @source.match(MISSING_ATTRIBUTE_QUOTES )
                raise REXML::ParseException.new(&quot;malformed XML: missing tag start&quot;, @source) 
              end
              attributes = {}
              prefixes = Set.new
              prefixes &lt;&lt; md[2] if md[2]
              @nsstack.unshift(curr_ns=Set.new)
              if md[4].size &gt; 0
                attrs = md[4].scan( ATTRIBUTE_PATTERN )
                raise REXML::ParseException.new( &quot;error parsing attributes: [#{attrs.join ', '}], excess = \&quot;#$'\&quot;&quot;, @source) if $' and $'.strip.size &gt; 0
                attrs.each { |a,b,c,d,e| 
                  if b == &quot;xmlns&quot;
                    if c == &quot;xml&quot;
                      if d != &quot;http://www.w3.org/XML/1998/namespace&quot;
                        msg = &quot;The 'xml' prefix must not be bound to any other namespace &quot;+
                        &quot;(http://www.w3.org/TR/REC-xml-names/#ns-decl)&quot;
                        raise REXML::ParseException.new( msg, @source, self )
                      end
                    elsif c == &quot;xmlns&quot;
                      msg = &quot;The 'xmlns' prefix must not be declared &quot;+
                      &quot;(http://www.w3.org/TR/REC-xml-names/#ns-decl)&quot;
                      raise REXML::ParseException.new( msg, @source, self)
                    end
                    curr_ns &lt;&lt; c
                  elsif b
                    prefixes &lt;&lt; b unless b == &quot;xml&quot;
                  end
                  attributes[a] = e 
                }
              end
        
              # Verify that all of the prefixes have been defined
              for prefix in prefixes
                unless @nsstack.find{|k| k.member?(prefix)}
                  raise UndefinedNamespaceException.new(prefix,@source,self)
                end
              end

              if md[6]
                @closed = md[1]
                @nsstack.shift
              else
                @tags.push( md[1] )
              end
              return [ :start_element, md[1], attributes ]
            end
          else
            md = @source.match( TEXT_PATTERN, true )
            if md[0].length == 0
              @source.match( /(\s+)/, true )
            end
            #STDERR.puts &quot;GOT #{md[1].inspect}&quot; unless md[0].length == 0
            #return [ :text, &quot;&quot; ] if md[0].length == 0
            # unnormalized = Text::unnormalize( md[1], self )
            # return PullEvent.new( :text, md[1], unnormalized )
            return [ :text, md[1] ]
          end
        rescue REXML::UndefinedNamespaceException
          raise
        rescue REXML::ParseException
          raise
        rescue Exception, NameError =&gt; error
          raise REXML::ParseException.new( &quot;Exception parsing&quot;,
            @source, self, (error ? error : $!) )
        end
        return [ :dummy ]
      end

      def entity( reference, entities )
        value = nil
        value = entities[ reference ] if entities
        if not value
          value = DEFAULT_ENTITIES[ reference ]
          value = value[2] if value
        end
        unnormalize( value, entities ) if value
      end

      # Escapes all possible entities
      def normalize( input, entities=nil, entity_filter=nil )
        copy = input.clone
        # Doing it like this rather than in a loop improves the speed
        copy.gsub!( EREFERENCE, '&amp;amp;' )
        entities.each do |key, value|
          copy.gsub!( value, &quot;&amp;#{key};&quot; ) unless entity_filter and 
                                      entity_filter.include?(entity)
        end if entities
        copy.gsub!( EREFERENCE, '&amp;amp;' )
        DEFAULT_ENTITIES.each do |key, value|
          copy.gsub!( value[3], value[1] )
        end
        copy
      end

      # Unescapes all possible entities
      def unnormalize( string, entities=nil, filter=nil )
        rv = string.clone
        rv.gsub!( /\r\n?/, &quot;\n&quot; )
        matches = rv.scan( REFERENCE_RE )
        return rv if matches.size == 0
        rv.gsub!( /&amp;#0*((?:\d+)|(?:x[a-fA-F0-9]+));/ ) {|m|
          m=$1
          m = &quot;0#{m}&quot; if m[0] == ?x
          [Integer(m)].pack('U*')
        }
        matches.collect!{|x|x[0]}.compact!
        if matches.size &gt; 0
          matches.each do |entity_reference|
            unless filter and filter.include?(entity_reference)
              entity_value = entity( entity_reference, entities )
              if entity_value
                re = /&amp;#{entity_reference};/
                rv.gsub!( re, entity_value )
              end
            end
          end
          matches.each do |entity_reference|
            unless filter and filter.include?(entity_reference)
              er = DEFAULT_ENTITIES[entity_reference]
              rv.gsub!( er[0], er[2] ) if er
            end
          end
          rv.gsub!( /&amp;amp;/, '&amp;' )
        end
        rv
      end
    end
  end
end

=begin
  case event[0]
  when :start_element
  when :text
  when :end_element
  when :processing_instruction
  when :cdata
  when :comment
  when :xmldecl
  when :start_doctype
  when :end_doctype
  when :externalentity
  when :elementdecl
  when :entity
  when :attlistdecl
  when :notationdecl
  when :end_doctype
  end
=end
</pre>
    </div>