  <div id="fileHeader">
    <h1>xpathparser.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/parsers/xpathparser.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Apr 18 02:22:13 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/namespace'
require 'rexml/xmltokens'

module REXML
  module Parsers
    # You don't want to use this class.  Really.  Use XPath, which is a wrapper
    # for this class.  Believe me.  You don't want to poke around in here.
    # There is strange, dark magic at work in this code.  Beware.  Go back!  Go
    # back while you still can!
    class XPathParser
      include XMLTokens
      LITERAL    = /^'([^']*)'|^&quot;([^&quot;]*)&quot;/u

      def namespaces=( namespaces )
        Functions::namespace_context = namespaces
        @namespaces = namespaces
      end

      def parse path
        path.gsub!(/([\(\[])\s+/, '\1') # Strip ignorable spaces
        path.gsub!( /\s+([\]\)])/, '\1' )
        parsed = []
        path = OrExpr(path, parsed)
        parsed
      end

      def predicate path
        parsed = []
        Predicate( &quot;[#{path}]&quot;, parsed )
        parsed
      end

      def abbreviate( path )
        path = path.kind_of?(String) ? parse( path ) : path
        string = &quot;&quot;
        document = false
        while path.size &gt; 0
          op = path.shift
          case op
          when :node
          when :attribute
						string &lt;&lt; &quot;/&quot; if string.size &gt; 0
						string &lt;&lt; &quot;@&quot;
          when :child
						string &lt;&lt; &quot;/&quot; if string.size &gt; 0
          when :descendant_or_self
            string &lt;&lt; &quot;/&quot;
          when :self
            string &lt;&lt; &quot;.&quot;
          when :parent
            string &lt;&lt; &quot;..&quot;
          when :any
            string &lt;&lt; &quot;*&quot;
					when :text
						string &lt;&lt; &quot;text()&quot;
          when :following, :following_sibling, 
                :ancestor, :ancestor_or_self, :descendant, 
                :namespace, :preceding, :preceding_sibling
            string &lt;&lt; &quot;/&quot; unless string.size == 0
            string &lt;&lt; op.to_s.tr(&quot;_&quot;, &quot;-&quot;)
            string &lt;&lt; &quot;::&quot;
          when :qname
            prefix = path.shift
            name = path.shift
            string &lt;&lt; prefix+&quot;:&quot; if prefix.size &gt; 0
            string &lt;&lt; name
          when :predicate
            string &lt;&lt; '['
            string &lt;&lt; predicate_to_string( path.shift ) {|x| abbreviate( x ) }
            string &lt;&lt; ']'
          when :document
            document = true
					when :function
						string &lt;&lt; path.shift
						string &lt;&lt; &quot;( &quot;
						string &lt;&lt; predicate_to_string( path.shift[0] ) {|x| abbreviate( x )}
						string &lt;&lt; &quot; )&quot;
					when :literal
						string &lt;&lt; %Q{ &quot;#{path.shift}&quot; }
          else
            string &lt;&lt; &quot;/&quot; unless string.size == 0
            string &lt;&lt; &quot;UNKNOWN(&quot;
            string &lt;&lt; op.inspect
            string &lt;&lt; &quot;)&quot;
          end
        end
				string = &quot;/&quot;+string if document
        return string
      end

      def expand( path )
        path = path.kind_of?(String) ? parse( path ) : path
        string = &quot;&quot;
        document = false
        while path.size &gt; 0
          op = path.shift
          case op
          when :node
            string &lt;&lt; &quot;node()&quot;
          when :attribute, :child, :following, :following_sibling, 
                :ancestor, :ancestor_or_self, :descendant, :descendant_or_self,
                :namespace, :preceding, :preceding_sibling, :self, :parent
            string &lt;&lt; &quot;/&quot; unless string.size == 0
            string &lt;&lt; op.to_s.tr(&quot;_&quot;, &quot;-&quot;)
            string &lt;&lt; &quot;::&quot;
          when :any
            string &lt;&lt; &quot;*&quot;
          when :qname
            prefix = path.shift
            name = path.shift
            string &lt;&lt; prefix+&quot;:&quot; if prefix.size &gt; 0
            string &lt;&lt; name
          when :predicate
            string &lt;&lt; '['
            string &lt;&lt; predicate_to_string( path.shift ) { |x| expand(x) }
            string &lt;&lt; ']'
          when :document
            document = true
          else
            string &lt;&lt; &quot;/&quot; unless string.size == 0
            string &lt;&lt; &quot;UNKNOWN(&quot;
            string &lt;&lt; op.inspect
            string &lt;&lt; &quot;)&quot;
          end
        end
        string = &quot;/&quot;+string if document
        return string
      end

      def predicate_to_string( path, &amp;block )
        string = &quot;&quot;
        case path[0]
        when :and, :or, :mult, :plus, :minus, :neq, :eq, :lt, :gt, :lteq, :gteq, :div, :mod, :union
          op = path.shift
          case op
          when :eq
            op = &quot;=&quot;
          when :lt
            op = &quot;&lt;&quot;
          when :gt
            op = &quot;&gt;&quot;
          when :lteq
            op = &quot;&lt;=&quot;
          when :gteq
            op = &quot;&gt;=&quot;
          when :neq
            op = &quot;!=&quot;
          when :union
            op = &quot;|&quot;
          end
          left = predicate_to_string( path.shift, &amp;block )
          right = predicate_to_string( path.shift, &amp;block )
          string &lt;&lt; &quot; &quot;
          string &lt;&lt; left
          string &lt;&lt; &quot; &quot;
          string &lt;&lt; op.to_s
          string &lt;&lt; &quot; &quot;
          string &lt;&lt; right
          string &lt;&lt; &quot; &quot;
        when :function
          path.shift
          name = path.shift
          string &lt;&lt; name
          string &lt;&lt; &quot;( &quot;
          string &lt;&lt; predicate_to_string( path.shift, &amp;block )
          string &lt;&lt; &quot; )&quot;
        when :literal
          path.shift
          string &lt;&lt; &quot; &quot;
          string &lt;&lt; path.shift.inspect
          string &lt;&lt; &quot; &quot;
        else
          string &lt;&lt; &quot; &quot;
          string &lt;&lt; yield( path )
          string &lt;&lt; &quot; &quot;
        end
        return string.squeeze(&quot; &quot;)
      end

      private
      #LocationPath
      #  | RelativeLocationPath
      #  | '/' RelativeLocationPath?
      #  | '//' RelativeLocationPath
      def LocationPath path, parsed
        #puts &quot;LocationPath '#{path}'&quot;
        path = path.strip
        if path[0] == ?/
          parsed &lt;&lt; :document
          if path[1] == ?/
            parsed &lt;&lt; :descendant_or_self
            parsed &lt;&lt; :node
            path = path[2..-1]
          else
            path = path[1..-1]
          end
        end
        #puts parsed.inspect
        return RelativeLocationPath( path, parsed ) if path.size &gt; 0
      end

      #RelativeLocationPath
      #  |                                                    Step
      #    | (AXIS_NAME '::' | '@' | '')                     AxisSpecifier
      #      NodeTest
      #        Predicate
      #    | '.' | '..'                                      AbbreviatedStep
      #  |  RelativeLocationPath '/' Step
      #  | RelativeLocationPath '//' Step
      AXIS = /^(ancestor|ancestor-or-self|attribute|child|descendant|descendant-or-self|following|following-sibling|namespace|parent|preceding|preceding-sibling|self)::/
      def RelativeLocationPath path, parsed
        #puts &quot;RelativeLocationPath #{path}&quot;
        while path.size &gt; 0
          # (axis or @ or &lt;child::&gt;) nodetest predicate  &gt;
          # OR                                          &gt;  / Step
          # (. or ..)                                    &gt;
          if path[0] == ?.
            if path[1] == ?.
              parsed &lt;&lt; :parent
              parsed &lt;&lt; :node
              path = path[2..-1]
            else
              parsed &lt;&lt; :self
              parsed &lt;&lt; :node
              path = path[1..-1]
            end
          else
            if path[0] == ?@
              #puts &quot;ATTRIBUTE&quot;
              parsed &lt;&lt; :attribute
              path = path[1..-1]
              # Goto Nodetest
            elsif path =~ AXIS
              parsed &lt;&lt; $1.tr('-','_').intern
              path = $'
              # Goto Nodetest
            else
              parsed &lt;&lt; :child
            end

            #puts &quot;NODETESTING '#{path}'&quot;
            n = []
            path = NodeTest( path, n)
            #puts &quot;NODETEST RETURNED '#{path}'&quot;

            if path[0] == ?[
              path = Predicate( path, n )
            end

            parsed.concat(n)
          end
          
          if path.size &gt; 0
            if path[0] == ?/
              if path[1] == ?/
                parsed &lt;&lt; :descendant_or_self
                parsed &lt;&lt; :node
                path = path[2..-1]
              else
                path = path[1..-1]
              end
            else
              return path
            end
          end
        end
        return path
      end

      # Returns a 1-1 map of the nodeset
      # The contents of the resulting array are either:
      #   true/false, if a positive match
      #   String, if a name match
      #NodeTest
      #  | ('*' | NCNAME ':' '*' | QNAME)                NameTest
      #  | NODE_TYPE '(' ')'                              NodeType
      #  | PI '(' LITERAL ')'                            PI
      #    | '[' expr ']'                                Predicate
      NCNAMETEST= /^(#{NCNAME_STR}):\*/u
      QNAME     = Namespace::NAMESPLIT
      NODE_TYPE  = /^(comment|text|node)\(\s*\)/m
      PI        = /^processing-instruction\(/
      def NodeTest path, parsed
        #puts &quot;NodeTest with #{path}&quot;
        res = nil
        case path
        when /^\*/
          path = $'
          parsed &lt;&lt; :any
        when NODE_TYPE
          type = $1
          path = $'
          parsed &lt;&lt; type.tr('-', '_').intern
        when PI
          path = $'
          literal = nil
          if path !~ /^\s*\)/
            path =~ LITERAL
            literal = $1
            path = $'
            raise ParseException.new(&quot;Missing ')' after processing instruction&quot;) if path[0] != ?)
            path = path[1..-1]
          end
          parsed &lt;&lt; :processing_instruction
          parsed &lt;&lt; (literal || '')
        when NCNAMETEST
          #puts &quot;NCNAMETEST&quot;
          prefix = $1
          path = $'
          parsed &lt;&lt; :namespace
          parsed &lt;&lt; prefix
        when QNAME
          #puts &quot;QNAME&quot;
          prefix = $1
          name = $2
          path = $'
          prefix = &quot;&quot; unless prefix
          parsed &lt;&lt; :qname
          parsed &lt;&lt; prefix
          parsed &lt;&lt; name
        end
        return path
      end

      # Filters the supplied nodeset on the predicate(s)
      def Predicate path, parsed
        #puts &quot;PREDICATE with #{path}&quot;
        return nil unless path[0] == ?[
        predicates = []
        while path[0] == ?[
          path, expr = get_group(path)
          predicates &lt;&lt; expr[1..-2] if expr
        end
        #puts &quot;PREDICATES = #{predicates.inspect}&quot;
        predicates.each{ |expr| 
          #puts &quot;ORING #{expr}&quot;
          preds = []
          parsed &lt;&lt; :predicate
          parsed &lt;&lt; preds
          OrExpr(expr, preds) 
        }
        #puts &quot;PREDICATES = #{predicates.inspect}&quot;
        path
      end

      # The following return arrays of true/false, a 1-1 mapping of the
      # supplied nodeset, except for axe(), which returns a filtered
      # nodeset

      #| OrExpr S 'or' S AndExpr
      #| AndExpr
      def OrExpr path, parsed
        #puts &quot;OR &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = AndExpr( path, n )
        #puts &quot;OR &lt;&lt;&lt; #{rest}&quot;
        if rest != path
          while rest =~ /^\s*( or )/
            n = [ :or, n, [] ]
            rest = AndExpr( $', n[-1] )
          end
        end
        if parsed.size == 0 and n.size != 0
          parsed.replace(n)
        elsif n.size &gt; 0
          parsed &lt;&lt; n
        end
        rest
      end

      #| AndExpr S 'and' S EqualityExpr
      #| EqualityExpr
      def AndExpr path, parsed
        #puts &quot;AND &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = EqualityExpr( path, n )
        #puts &quot;AND &lt;&lt;&lt; #{rest}&quot;
        if rest != path
          while rest =~ /^\s*( and )/
            n = [ :and, n, [] ]
            #puts &quot;AND &gt;&gt;&gt; #{rest}&quot;
            rest = EqualityExpr( $', n[-1] )
            #puts &quot;AND &lt;&lt;&lt; #{rest}&quot;
          end
        end
        if parsed.size == 0 and n.size != 0
          parsed.replace(n)
        elsif n.size &gt; 0
          parsed &lt;&lt; n
        end
        rest
      end

      #| EqualityExpr ('=' | '!=')  RelationalExpr
      #| RelationalExpr
      def EqualityExpr path, parsed
        #puts &quot;EQUALITY &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = RelationalExpr( path, n )
        #puts &quot;EQUALITY &lt;&lt;&lt; #{rest}&quot;
        if rest != path
          while rest =~ /^\s*(!?=)\s*/
            if $1[0] == ?!
              n = [ :neq, n, [] ]
            else
              n = [ :eq, n, [] ]
            end
            rest = RelationalExpr( $', n[-1] )
          end
        end
        if parsed.size == 0 and n.size != 0
          parsed.replace(n)
        elsif n.size &gt; 0
          parsed &lt;&lt; n
        end
        rest
      end

      #| RelationalExpr ('&lt;' | '&gt;' | '&lt;=' | '&gt;=') AdditiveExpr
      #| AdditiveExpr
      def RelationalExpr path, parsed
        #puts &quot;RELATION &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = AdditiveExpr( path, n )
        #puts &quot;RELATION &lt;&lt;&lt; #{rest}&quot;
        if rest != path
          while rest =~ /^\s*([&lt;&gt;]=?)\s*/
            if $1[0] == ?&lt;
              sym = &quot;lt&quot;
            else
              sym = &quot;gt&quot;
            end
            sym &lt;&lt; &quot;eq&quot; if $1[-1] == ?=
            n = [ sym.intern, n, [] ]
            rest = AdditiveExpr( $', n[-1] )
          end
        end
        if parsed.size == 0 and n.size != 0
          parsed.replace(n)
        elsif n.size &gt; 0
          parsed &lt;&lt; n
        end
        rest
      end

      #| AdditiveExpr ('+' | S '-') MultiplicativeExpr
      #| MultiplicativeExpr
      def AdditiveExpr path, parsed
        #puts &quot;ADDITIVE &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = MultiplicativeExpr( path, n )
        #puts &quot;ADDITIVE &lt;&lt;&lt; #{rest}&quot;
        if rest != path
          while rest =~ /^\s*(\+| -)\s*/
            if $1[0] == ?+
              n = [ :plus, n, [] ]
            else
              n = [ :minus, n, [] ]
            end
            rest = MultiplicativeExpr( $', n[-1] )
          end
        end
        if parsed.size == 0 and n.size != 0
          parsed.replace(n)
        elsif n.size &gt; 0
          parsed &lt;&lt; n
        end
        rest
      end

      #| MultiplicativeExpr ('*' | S ('div' | 'mod') S) UnaryExpr
      #| UnaryExpr
      def MultiplicativeExpr path, parsed
        #puts &quot;MULT &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = UnaryExpr( path, n )
        #puts &quot;MULT &lt;&lt;&lt; #{rest}&quot;
        if rest != path
          while rest =~ /^\s*(\*| div | mod )\s*/
            if $1[0] == ?*
              n = [ :mult, n, [] ]
            elsif $1.include?( &quot;div&quot; )
              n = [ :div, n, [] ]
            else
              n = [ :mod, n, [] ]
            end
            rest = UnaryExpr( $', n[-1] )
          end
        end
        if parsed.size == 0 and n.size != 0
          parsed.replace(n)
        elsif n.size &gt; 0
          parsed &lt;&lt; n
        end
        rest
      end

      #| '-' UnaryExpr
      #| UnionExpr
      def UnaryExpr path, parsed
        path =~ /^(\-*)/
        path = $'
        if $1 and (($1.size % 2) != 0)
          mult = -1
        else
          mult = 1
        end
        parsed &lt;&lt; :neg if mult &lt; 0

        #puts &quot;UNARY &gt;&gt;&gt; #{path}&quot;
        n = []
        path = UnionExpr( path, n )
        #puts &quot;UNARY &lt;&lt;&lt; #{path}&quot;
        parsed.concat( n )
        path
      end

      #| UnionExpr '|' PathExpr
      #| PathExpr
      def UnionExpr path, parsed
        #puts &quot;UNION &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = PathExpr( path, n )
        #puts &quot;UNION &lt;&lt;&lt; #{rest}&quot;
        if rest != path
          while rest =~ /^\s*(\|)\s*/
            n = [ :union, n, [] ]
            rest = PathExpr( $', n[-1] )
          end
        end
        if parsed.size == 0 and n.size != 0
          parsed.replace( n )
        elsif n.size &gt; 0
          parsed &lt;&lt; n
        end
        rest
      end

      #| LocationPath
      #| FilterExpr ('/' | '//') RelativeLocationPath
      def PathExpr path, parsed
        path =~ /^\s*/
        path = $'
        #puts &quot;PATH &gt;&gt;&gt; #{path}&quot;
        n = []
        rest = FilterExpr( path, n )
        #puts &quot;PATH &lt;&lt;&lt; '#{rest}'&quot;
        if rest != path
          if rest and rest[0] == ?/
            return RelativeLocationPath(rest, n)
          end
        end
        #puts &quot;BEFORE WITH '#{rest}'&quot;
        rest = LocationPath(rest, n) if rest =~ /\A[\/\.\@\[\w_*]/
        parsed.concat(n)
        return rest
      end

      #| FilterExpr Predicate
      #| PrimaryExpr
      def FilterExpr path, parsed
        #puts &quot;FILTER &gt;&gt;&gt; #{path}&quot;
        n = []
        path = PrimaryExpr( path, n )
        #puts &quot;FILTER &lt;&lt;&lt; #{path}&quot;
        path = Predicate(path, n) if path and path[0] == ?[
        #puts &quot;FILTER &lt;&lt;&lt; #{path}&quot;
        parsed.concat(n)
        path
      end

      #| VARIABLE_REFERENCE
      #| '(' expr ')'
      #| LITERAL
      #| NUMBER
      #| FunctionCall
      VARIABLE_REFERENCE  = /^\$(#{NAME_STR})/u
      NUMBER              = /^(\d*\.?\d+)/
      NT        = /^comment|text|processing-instruction|node$/
      def PrimaryExpr path, parsed
        arry = []
        case path
        when VARIABLE_REFERENCE
          varname = $1
          path = $'
          parsed &lt;&lt; :variable
          parsed &lt;&lt; varname
          #arry &lt;&lt; @variables[ varname ]
        when /^(\w[-\w]*)(?:\()/
          #puts &quot;PrimaryExpr :: Function &gt;&gt;&gt; #$1 -- '#$''&quot;
          fname = $1
          tmp = $'
          #puts &quot;#{fname} =~ #{NT.inspect}&quot;
          return path if fname =~ NT
          path = tmp
          parsed &lt;&lt; :function
          parsed &lt;&lt; fname
          path = FunctionCall(path, parsed)
        when NUMBER
          #puts &quot;LITERAL or NUMBER: #$1&quot;
          varname = $1.nil? ? $2 : $1
          path = $'
          parsed &lt;&lt; :literal 
          parsed &lt;&lt; (varname.include?('.') ? varname.to_f : varname.to_i)
        when LITERAL
          #puts &quot;LITERAL or NUMBER: #$1&quot;
          varname = $1.nil? ? $2 : $1
          path = $'
          parsed &lt;&lt; :literal 
          parsed &lt;&lt; varname
        when /^\(/                                               #/
          path, contents = get_group(path)
          contents = contents[1..-2]
          n = []
          OrExpr( contents, n )
          parsed.concat(n)
        end
        path
      end

      #| FUNCTION_NAME '(' ( expr ( ',' expr )* )? ')'
      def FunctionCall rest, parsed
        path, arguments = parse_args(rest)
        argset = []
        for argument in arguments
          args = []
          OrExpr( argument, args )
          argset &lt;&lt; args
        end
        parsed &lt;&lt; argset
        path
      end

      # get_group( '[foo]bar' ) -&gt; ['bar', '[foo]']
      def get_group string
        ind = 0
        depth = 0
        st = string[0,1]
        en = (st == &quot;(&quot; ? &quot;)&quot; : &quot;]&quot;)
        begin
          case string[ind,1]
          when st
            depth += 1
          when en
            depth -= 1
          end
          ind += 1
        end while depth &gt; 0 and ind &lt; string.length
        return nil unless depth==0
        [string[ind..-1], string[0..ind-1]]
      end
      
      def parse_args( string )
        arguments = []
        ind = 0
				inquot = false
				inapos = false
        depth = 1
        begin
          case string[ind]
          when ?&quot;
          	inquot = !inquot unless inapos
          when ?'
          	inapos = !inapos unless inquot
          else
          	unless inquot or inapos
          		case string[ind]
							when ?(
								depth += 1
                if depth == 1
                	string = string[1..-1]
                	ind -= 1
                end
							when ?)
								depth -= 1
								if depth == 0
									s = string[0,ind].strip
									arguments &lt;&lt; s unless s == &quot;&quot;
									string = string[ind+1..-1]
								end
							when ?,
								if depth == 1
									s = string[0,ind].strip
									arguments &lt;&lt; s unless s == &quot;&quot;
									string = string[ind+1..-1]
									ind = -1 
								end
							end
            end
          end
          ind += 1
        end while depth &gt; 0 and ind &lt; string.length
        return nil unless depth==0
        [string,arguments]
      end
    end
  end
end
</pre>
    </div>