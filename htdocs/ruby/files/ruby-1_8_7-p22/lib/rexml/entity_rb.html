  <div id="fileHeader">
    <h1>entity.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/entity.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Apr 18 02:22:13 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/child'
require 'rexml/source'
require 'rexml/xmltokens'

module REXML
	# God, I hate DTDs.  I really do.  Why this idiot standard still
	# plagues us is beyond me.
	class Entity &lt; Child
		include XMLTokens
		PUBIDCHAR = &quot;\x20\x0D\x0Aa-zA-Z0-9\\-()+,./:=?;!*@$_%#&quot;
		SYSTEMLITERAL = %Q{((?:&quot;[^&quot;]*&quot;)|(?:'[^']*'))}
		PUBIDLITERAL = %Q{(&quot;[#{PUBIDCHAR}']*&quot;|'[#{PUBIDCHAR}]*')}
		EXTERNALID = &quot;(?:(?:(SYSTEM)\\s+#{SYSTEMLITERAL})|(?:(PUBLIC)\\s+#{PUBIDLITERAL}\\s+#{SYSTEMLITERAL}))&quot;
		NDATADECL = &quot;\\s+NDATA\\s+#{NAME}&quot;
		PEREFERENCE = &quot;%#{NAME};&quot;
		ENTITYVALUE = %Q{((?:&quot;(?:[^%&amp;&quot;]|#{PEREFERENCE}|#{REFERENCE})*&quot;)|(?:'([^%&amp;']|#{PEREFERENCE}|#{REFERENCE})*'))}
		PEDEF = &quot;(?:#{ENTITYVALUE}|#{EXTERNALID})&quot;
		ENTITYDEF = &quot;(?:#{ENTITYVALUE}|(?:#{EXTERNALID}(#{NDATADECL})?))&quot;
		PEDECL = &quot;&lt;!ENTITY\\s+(%)\\s+#{NAME}\\s+#{PEDEF}\\s*&gt;&quot;
		GEDECL = &quot;&lt;!ENTITY\\s+#{NAME}\\s+#{ENTITYDEF}\\s*&gt;&quot;
		ENTITYDECL = /\s*(?:#{GEDECL})|(?:#{PEDECL})/um

		attr_reader :name, :external, :ref, :ndata, :pubid

		# Create a new entity.  Simple entities can be constructed by passing a
		# name, value to the constructor; this creates a generic, plain entity
		# reference. For anything more complicated, you have to pass a Source to
		# the constructor with the entity definiton, or use the accessor methods.
		# +WARNING+: There is no validation of entity state except when the entity
		# is read from a stream.  If you start poking around with the accessors,
		# you can easily create a non-conformant Entity.  The best thing to do is
		# dump the stupid DTDs and use XMLSchema instead.
		# 
		#  e = Entity.new( 'amp', '&amp;' )
		def initialize stream, value=nil, parent=nil, reference=false
			super(parent)
			@ndata = @pubid = @value = @external = nil
			if stream.kind_of? Array
				@name = stream[1]
				if stream[-1] == '%'
					@reference = true 
					stream.pop
				else
					@reference = false
				end
				if stream[2] =~ /SYSTEM|PUBLIC/
					@external = stream[2]
					if @external == 'SYSTEM'
						@ref = stream[3]
						@ndata = stream[4] if stream.size == 5
					else
						@pubid = stream[3]
						@ref = stream[4]
					end
				else
					@value = stream[2]
				end
			else
				@reference = reference
				@external = nil
				@name = stream
				@value = value
			end
		end

		# Evaluates whether the given string matchs an entity definition,
		# returning true if so, and false otherwise.
		def Entity::matches? string
			(ENTITYDECL =~ string) == 0
		end

		# Evaluates to the unnormalized value of this entity; that is, replacing
		# all entities -- both %ent; and &amp;ent; entities.  This differs from
		# +value()+ in that +value+ only replaces %ent; entities.
		def unnormalized
			v = value()
			return nil if v.nil?
			@unnormalized = Text::unnormalize(v, parent)
			@unnormalized
		end

		#once :unnormalized

		# Returns the value of this entity unprocessed -- raw.  This is the
		# normalized value; that is, with all %ent; and &amp;ent; entities intact
		def normalized
			@value
		end

		# Write out a fully formed, correct entity definition (assuming the Entity
		# object itself is valid.)
    #
    # out::
    #   An object implementing &lt;TT&gt;&amp;lt;&amp;lt;&lt;TT&gt; to which the entity will be
    #   output
    # indent::
    #   *DEPRECATED* and ignored
		def write out, indent=-1
			out &lt;&lt; '&lt;!ENTITY '
			out &lt;&lt; '% ' if @reference
			out &lt;&lt; @name
			out &lt;&lt; ' '
			if @external
				out &lt;&lt; @external &lt;&lt; ' '
				if @pubid
					q = @pubid.include?('&quot;')?&quot;'&quot;:'&quot;'
					out &lt;&lt; q &lt;&lt; @pubid &lt;&lt; q &lt;&lt; ' '
				end
				q = @ref.include?('&quot;')?&quot;'&quot;:'&quot;'
				out &lt;&lt; q &lt;&lt; @ref &lt;&lt; q
				out &lt;&lt; ' NDATA ' &lt;&lt; @ndata if @ndata
			else
				q = @value.include?('&quot;')?&quot;'&quot;:'&quot;'
				out &lt;&lt; q &lt;&lt; @value &lt;&lt; q
			end
			out &lt;&lt; '&gt;'
		end

		# Returns this entity as a string.  See write().
		def to_s
			rv = ''
			write rv
			rv
		end

		PEREFERENCE_RE = /#{PEREFERENCE}/um
		# Returns the value of this entity.  At the moment, only internal entities
		# are processed.  If the value contains internal references (IE,
		# %blah;), those are replaced with their values.  IE, if the doctype
		# contains:
		#  &lt;!ENTITY % foo &quot;bar&quot;&gt;
		#  &lt;!ENTITY yada &quot;nanoo %foo; nanoo&gt;
		# then:
		#  doctype.entity('yada').value   #-&gt; &quot;nanoo bar nanoo&quot;
		def value
			if @value
				matches = @value.scan(PEREFERENCE_RE)
				rv = @value.clone
				if @parent
					matches.each do |entity_reference|
						entity_value = @parent.entity( entity_reference[0] )
						rv.gsub!( /%#{entity_reference};/um, entity_value )
					end
				end
				return rv
			end
			nil
		end
	end

	# This is a set of entity constants -- the ones defined in the XML
	# specification.  These are +gt+, +lt+, +amp+, +quot+ and +apos+.
	module EntityConst
		# +&gt;+
		GT = Entity.new( 'gt', '&gt;' )
		# +&lt;+
		LT = Entity.new( 'lt', '&lt;' )
		# +&amp;+
		AMP = Entity.new( 'amp', '&amp;' )
		# +&quot;+
		QUOT = Entity.new( 'quot', '&quot;' )
		# +'+
		APOS = Entity.new( 'apos', &quot;'&quot; )
	end
end
</pre>
    </div>