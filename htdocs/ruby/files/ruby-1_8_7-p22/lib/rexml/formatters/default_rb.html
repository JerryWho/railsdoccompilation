  <div id="fileHeader">
    <h1>default.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/formatters/default.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 29 21:26:17 -0500 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module REXML
  module Formatters
    class Default
      # Prints out the XML document with no formatting -- except if id_hack is
      # set.
      #
      # ie_hack::
      #   If set to true, then inserts whitespace before the close of an empty
      #   tag, so that IE's bad XML parser doesn't choke.
      def initialize( ie_hack=false )
        @ie_hack = ie_hack
      end

      # Writes the node to some output.
      #
      # node::
      #   The node to write
      # output::
      #   A class implementing &lt;TT&gt;&amp;lt;&amp;lt;&lt;/TT&gt;.  Pass in an Output object to
      #   change the output encoding.
      def write( node, output )
        case node

        when Document 
          if node.xml_decl.encoding != &quot;UTF-8&quot; &amp;&amp; !output.kind_of?(Output)
            output = Output.new( output, node.xml_decl.encoding )
          end
          write_document( node, output )

        when Element
          write_element( node, output )

        when Declaration, ElementDecl, NotationDecl, ExternalEntity, Entity,
             Attribute, AttlistDecl
          node.write( output,-1 )

        when Instruction
          write_instruction( node, output )

        when DocType, XMLDecl
          node.write( output )

        when Comment
          write_comment( node, output )

        when CData
          write_cdata( node, output )

        when Text
          write_text( node, output )

        else
          raise Exception.new(&quot;XML FORMATTING ERROR&quot;)

        end
      end

      protected
      def write_document( node, output )
        node.children.each { |child| write( child, output ) }
      end

      def write_element( node, output )
        output &lt;&lt; &quot;&lt;#{node.expanded_name}&quot;

        node.attributes.each_attribute do |attr|
          output &lt;&lt; &quot; &quot;
          attr.write( output )
        end unless node.attributes.empty?

        if node.children.empty?
          output &lt;&lt; &quot; &quot; if @ie_hack
          output &lt;&lt; &quot;/&quot; 
        else
          output &lt;&lt; &quot;&gt;&quot;
          node.children.each { |child|
            write( child, output )
          }
          output &lt;&lt; &quot;&lt;/#{node.expanded_name}&quot;
        end
        output &lt;&lt; &quot;&gt;&quot;
      end

      def write_text( node, output )
        output &lt;&lt; node.to_s()
      end

      def write_comment( node, output )
        output &lt;&lt; Comment::START
        output &lt;&lt; node.to_s
        output &lt;&lt; Comment::STOP
      end

      def write_cdata( node, output )
        output &lt;&lt; CData::START
        output &lt;&lt; node.to_s
        output &lt;&lt; CData::STOP
      end

      def write_instruction( node, output )
        output &lt;&lt; Instruction::START.sub(/\\/u, '')
        output &lt;&lt; node.target
        output &lt;&lt; ' '
        output &lt;&lt; node.content
        output &lt;&lt; Instruction::STOP.sub(/\\/u, '')
      end
    end
  end
end
</pre>
    </div>