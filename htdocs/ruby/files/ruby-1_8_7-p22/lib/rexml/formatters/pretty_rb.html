  <div id="fileHeader">
    <h1>pretty.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/formatters/pretty.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/formatters/default'

module REXML
  module Formatters
    # Pretty-prints an XML document.  This destroys whitespace in text nodes
    # and will insert carriage returns and indentations.
    #
    # TODO: Add an option to print attributes on new lines
    class Pretty &lt; Default

      # If compact is set to true, then the formatter will attempt to use as
      # little space as possible
      attr_accessor :compact
      # The width of a page.  Used for formatting text
      attr_accessor :width

      # Create a new pretty printer.
      #
      # output::
      #   An object implementing '&lt;&lt;(String)', to which the output will be written.
      # indentation::
      #   An integer greater than 0.  The indentation of each level will be
      #   this number of spaces.  If this is &lt; 1, the behavior of this object
      #   is undefined.  Defaults to 2.
      # ie_hack::
      #   If true, the printer will insert whitespace before closing empty
      #   tags, thereby allowing Internet Explorer's feeble XML parser to
      #   function. Defaults to false.
      def initialize( indentation=2, ie_hack=false )
        @indentation = indentation
        @level = 0
        @ie_hack = ie_hack
        @width = 80
      end

      protected
      def write_element(node, output)
        output &lt;&lt; ' '*@level
        output &lt;&lt; &quot;&lt;#{node.expanded_name}&quot;

        node.attributes.each_attribute do |attr|
          output &lt;&lt; &quot; &quot;
          attr.write( output )
        end unless node.attributes.empty?

        if node.children.empty?
          if @ie_hack
            output &lt;&lt; &quot; &quot;
          end
          output &lt;&lt; &quot;/&quot; 
        else
          output &lt;&lt; &quot;&gt;&quot;
          # If compact and all children are text, and if the formatted output
          # is less than the specified width, then try to print everything on
          # one line
          skip = false
          if compact
            if node.children.inject(true) {|s,c| s &amp; c.kind_of?(Text)}
              string = &quot;&quot;
              old_level = @level
              @level = 0
              node.children.each { |child| write( child, string ) }
              @level = old_level
              if string.length &lt; @width
                output &lt;&lt; string
                skip = true
              end
            end
          end
          unless skip
            output &lt;&lt; &quot;\n&quot;
            @level += @indentation
            node.children.each { |child|
              next if child.kind_of?(Text) and child.to_s.strip.length == 0
              write( child, output )
              output &lt;&lt; &quot;\n&quot;
            }
            @level -= @indentation
            output &lt;&lt; ' '*@level
          end
          output &lt;&lt; &quot;&lt;/#{node.expanded_name}&quot;
        end
        output &lt;&lt; &quot;&gt;&quot;
      end

      def write_text( node, output )
        s = node.to_s()
        s.gsub!(/\s/,' ')
        s.squeeze!(&quot; &quot;)
        s = wrap(s, 80-@level)
        s = indent_text(s, @level, &quot; &quot;, true)
        output &lt;&lt; (' '*@level + s)
      end

      def write_comment( node, output)
        output &lt;&lt; ' ' * @level
        super
      end

      def write_cdata( node, output)
        output &lt;&lt; ' ' * @level
        super
      end

      def write_document( node, output )
        # Ok, this is a bit odd.  All XML documents have an XML declaration,
        # but it may not write itself if the user didn't specifically add it,
        # either through the API or in the input document.  If it doesn't write
        # itself, then we don't need a carriage return... which makes this
        # logic more complex.
        node.children.each { |child|
          next if child == node.children[-1] and child.instance_of?(Text)
          unless child == node.children[0] or child.instance_of?(Text) or
            (child == node.children[1] and !node.children[0].writethis)
            output &lt;&lt; &quot;\n&quot;
          end
          write( child, output )
        }
      end

      private
      def indent_text(string, level=1, style=&quot;\t&quot;, indentfirstline=true)
        return string if level &lt; 0
        string.gsub(/\n/, &quot;\n#{style*level}&quot;)
      end

      def wrap(string, width)
        # Recursively wrap string at width.
        return string if string.length &lt;= width
        place = string.rindex(' ', width) # Position in string with last ' ' before cutoff
        return string[0,place] + &quot;\n&quot; + wrap(string[place+1..-1], width)
      end

    end
  end
end

</pre>
    </div>