  <div id="fileHeader">
    <h1>xpath.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/xpath.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/functions'
require 'rexml/xpath_parser'

module REXML
	# Wrapper class.  Use this class to access the XPath functions.
	class XPath
		include Functions
		EMPTY_HASH = {}

		# Finds and returns the first node that matches the supplied xpath.
		# element::
		# 	The context element
		# path::
		# 	The xpath to search for.  If not supplied or nil, returns the first
		# 	node matching '*'.
		# namespaces::
		# 	If supplied, a Hash which defines a namespace mapping.
		#
		#  XPath.first( node )
		#  XPath.first( doc, &quot;//b&quot;} )
		#  XPath.first( node, &quot;a/x:b&quot;, { &quot;x&quot;=&gt;&quot;http://doofus&quot; } )
    def XPath::first element, path=nil, namespaces=nil, variables={}
      raise &quot;The namespaces argument, if supplied, must be a hash object.&quot; unless namespaces.nil? or namespaces.kind_of?(Hash)
      raise &quot;The variables argument, if supplied, must be a hash object.&quot; unless variables.kind_of?(Hash)
			parser = XPathParser.new
			parser.namespaces = namespaces
			parser.variables = variables
			path = &quot;*&quot; unless path
			element = [element] unless element.kind_of? Array
			parser.parse(path, element).flatten[0]
		end

		# Iterates over nodes that match the given path, calling the supplied
		# block with the match.
		# element::
		#   The context element
		# path::
		#   The xpath to search for.  If not supplied or nil, defaults to '*'
		# namespaces::
		# 	If supplied, a Hash which defines a namespace mapping
		#
		#  XPath.each( node ) { |el| ... }
		#  XPath.each( node, '/*[@attr='v']' ) { |el| ... }
		#  XPath.each( node, 'ancestor::x' ) { |el| ... }
		def XPath::each element, path=nil, namespaces=nil, variables={}, &amp;block
      raise &quot;The namespaces argument, if supplied, must be a hash object.&quot; unless namespaces.nil? or namespaces.kind_of?(Hash)
      raise &quot;The variables argument, if supplied, must be a hash object.&quot; unless variables.kind_of?(Hash)
			parser = XPathParser.new
			parser.namespaces = namespaces
			parser.variables = variables
			path = &quot;*&quot; unless path
			element = [element] unless element.kind_of? Array
			parser.parse(path, element).each( &amp;block )
		end

		# Returns an array of nodes matching a given XPath.  
		def XPath::match element, path=nil, namespaces=nil, variables={}
			parser = XPathParser.new
			parser.namespaces = namespaces
			parser.variables = variables
			path = &quot;*&quot; unless path
			element = [element] unless element.kind_of? Array
			parser.parse(path,element)
		end
	end
end
</pre>
    </div>