  <div id="fileHeader">
    <h1>node.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/node.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Apr 18 02:37:32 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;rexml/parseexception&quot;
require &quot;rexml/formatters/pretty&quot;
require &quot;rexml/formatters/default&quot;

module REXML
	# Represents a node in the tree.  Nodes are never encountered except as
	# superclasses of other objects.  Nodes have siblings.
	module Node
		# @return the next sibling (nil if unset)
		def next_sibling_node
			return nil if @parent.nil?
			@parent[ @parent.index(self) + 1 ]
		end

		# @return the previous sibling (nil if unset)
		def previous_sibling_node
			return nil if @parent.nil?
			ind = @parent.index(self)
			return nil if ind == 0
			@parent[ ind - 1 ]
		end

    # indent::
    #   *DEPRECATED* This parameter is now ignored.  See the formatters in the
    #   REXML::Formatters package for changing the output style.
		def to_s indent=nil
      unless indent.nil?
        Kernel.warn( &quot;#{self.class.name}.to_s(indent) parameter is deprecated&quot; )
        f = REXML::Formatters::Pretty.new( indent )
        f.write( self, rv = &quot;&quot; )
      else
        f = REXML::Formatters::Default.new
        f.write( self, rv = &quot;&quot; )
      end
      return rv
		end

		def indent to, ind
 			if @parent and @parent.context and not @parent.context[:indentstyle].nil? then
 				indentstyle = @parent.context[:indentstyle]
 			else
 				indentstyle = '  '
 			end
 			to &lt;&lt; indentstyle*ind unless ind&lt;1
		end

		def parent?
			false;
		end


		# Visit all subnodes of +self+ recursively
		def each_recursive(&amp;block) # :yields: node
			self.elements.each {|node|
				block.call(node)
				node.each_recursive(&amp;block)
			}
		end

		# Find (and return) first subnode (recursively) for which the block 
    # evaluates to true. Returns +nil+ if none was found.
		def find_first_recursive(&amp;block) # :yields: node
      each_recursive {|node|
        return node if block.call(node)
      }
      return nil
    end

    # Returns the position that +self+ holds in its parent's array, indexed
    # from 1.
    def index_in_parent
      parent.index(self)+1
    end
	end
end
</pre>
    </div>