  <div id="fileHeader">
    <h1>text.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rexml/text.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/entity'
require 'rexml/doctype'
require 'rexml/child'
require 'rexml/doctype'
require 'rexml/parseexception'

module REXML
  # Represents text nodes in an XML document
  class Text &lt; Child
    include Comparable
    # The order in which the substitutions occur
    SPECIALS = [ /&amp;(?!#?[\w-]+;)/u, /&lt;/u, /&gt;/u, /&quot;/u, /'/u, /\r/u ]
    SUBSTITUTES = ['&amp;amp;', '&amp;lt;', '&amp;gt;', '&amp;quot;', '&amp;apos;', '&amp;#13;']
    # Characters which are substituted in written strings
    SLAICEPS = [ '&lt;', '&gt;', '&quot;', &quot;'&quot;, '&amp;' ]
    SETUTITSBUS = [ /&amp;lt;/u, /&amp;gt;/u, /&amp;quot;/u, /&amp;apos;/u, /&amp;amp;/u ]

    # If +raw+ is true, then REXML leaves the value alone
    attr_accessor :raw

    ILLEGAL = /(&lt;|&amp;(?!(#{Entity::NAME})|(#0*((?:\d+)|(?:x[a-fA-F0-9]+)));))/um
    NUMERICENTITY = /&amp;#0*((?:\d+)|(?:x[a-fA-F0-9]+));/ 

    # Constructor
    # +arg+ if a String, the content is set to the String.  If a Text,
    # the object is shallowly cloned.  
    #
    # +respect_whitespace+ (boolean, false) if true, whitespace is
    # respected
    #
    # +parent+ (nil) if this is a Parent object, the parent
    # will be set to this.  
    #
    # +raw+ (nil) This argument can be given three values.
    # If true, then the value of used to construct this object is expected to 
    # contain no unescaped XML markup, and REXML will not change the text. If 
    # this value is false, the string may contain any characters, and REXML will
    # escape any and all defined entities whose values are contained in the
    # text.  If this value is nil (the default), then the raw value of the 
    # parent will be used as the raw value for this node.  If there is no raw
    # value for the parent, and no value is supplied, the default is false.
    # Use this field if you have entities defined for some text, and you don't
    # want REXML to escape that text in output.
    #   Text.new( &quot;&lt;&amp;&quot;, false, nil, false ) #-&gt; &quot;&amp;lt;&amp;amp;&quot;
    #   Text.new( &quot;&amp;lt;&amp;amp;&quot;, false, nil, false ) #-&gt; &quot;&amp;amp;lt;&amp;amp;amp;&quot;
    #   Text.new( &quot;&lt;&amp;&quot;, false, nil, true )  #-&gt; Parse exception
    #   Text.new( &quot;&amp;lt;&amp;amp;&quot;, false, nil, true )  #-&gt; &quot;&amp;lt;&amp;amp;&quot;
    #   # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;
    #   # and that the entity    &quot;r&quot; is defined to be &quot;russell&quot;
    #   Text.new( &quot;sean russell&quot; )          #-&gt; &quot;&amp;s; &amp;r;&quot;
    #   Text.new( &quot;sean russell&quot;, false, nil, true ) #-&gt; &quot;sean russell&quot;
    #
    # +entity_filter+ (nil) This can be an array of entities to match in the
    # supplied text.  This argument is only useful if +raw+ is set to false.
    #   Text.new( &quot;sean russell&quot;, false, nil, false, [&quot;s&quot;] ) #-&gt; &quot;&amp;s; russell&quot;
    #   Text.new( &quot;sean russell&quot;, false, nil, true, [&quot;s&quot;] ) #-&gt; &quot;sean russell&quot;
    # In the last example, the +entity_filter+ argument is ignored.
    #
    # +pattern+ INTERNAL USE ONLY
    def initialize(arg, respect_whitespace=false, parent=nil, raw=nil, 
      entity_filter=nil, illegal=ILLEGAL )

      @raw = false

      if parent
        super( parent )
        @raw = parent.raw 
      else
        @parent = nil
      end

      @raw = raw unless raw.nil?
      @entity_filter = entity_filter
      @normalized = @unnormalized = nil

      if arg.kind_of? String
        @string = arg.clone
        @string.squeeze!(&quot; \n\t&quot;) unless respect_whitespace
      elsif arg.kind_of? Text
        @string = arg.to_s
        @raw = arg.raw
      elsif
        raise &quot;Illegal argument of type #{arg.type} for Text constructor (#{arg})&quot;
      end

      @string.gsub!( /\r\n?/, &quot;\n&quot; )

      # check for illegal characters
      if @raw
        if @string =~ illegal
          raise &quot;Illegal character '#{$1}' in raw string \&quot;#{@string}\&quot;&quot;
        end
      end
    end

    def node_type
      :text
    end

    def empty?
      @string.size==0
    end


    def clone
      return Text.new(self)
    end


    # Appends text to this text node.  The text is appended in the +raw+ mode
    # of this text node.
    def &lt;&lt;( to_append )
      @string &lt;&lt; to_append.gsub( /\r\n?/, &quot;\n&quot; )
    end


    # +other+ a String or a Text
    # +returns+ the result of (to_s &lt;=&gt; arg.to_s)
    def &lt;=&gt;( other )
      to_s() &lt;=&gt; other.to_s
    end

    REFERENCE = /#{Entity::REFERENCE}/
    # Returns the string value of this text node.  This string is always
    # escaped, meaning that it is a valid XML text node string, and all
    # entities that can be escaped, have been inserted.  This method respects
    # the entity filter set in the constructor.
    #   
    #   # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;, and that the 
    #   # entity &quot;r&quot; is defined to be &quot;russell&quot;
    #   t = Text.new( &quot;&lt; &amp; sean russell&quot;, false, nil, false, ['s'] ) 
    #   t.to_s   #-&gt; &quot;&amp;lt; &amp;amp; &amp;s; russell&quot;
    #   t = Text.new( &quot;&lt; &amp; &amp;s; russell&quot;, false, nil, false ) 
    #   t.to_s   #-&gt; &quot;&amp;lt; &amp;amp; &amp;s; russell&quot;
    #   u = Text.new( &quot;sean russell&quot;, false, nil, true )
    #   u.to_s   #-&gt; &quot;sean russell&quot;
    def to_s
      return @string if @raw
      return @normalized if @normalized

      doctype = nil
      if @parent
        doc = @parent.document
        doctype = doc.doctype if doc
      end

      @normalized = Text::normalize( @string, doctype, @entity_filter )
    end

    def inspect
      @string.inspect
    end

    # Returns the string value of this text.  This is the text without
    # entities, as it might be used programmatically, or printed to the
    # console.  This ignores the 'raw' attribute setting, and any
    # entity_filter.
    #
    #   # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;, and that the 
    #   # entity &quot;r&quot; is defined to be &quot;russell&quot;
    #   t = Text.new( &quot;&lt; &amp; sean russell&quot;, false, nil, false, ['s'] ) 
    #   t.value   #-&gt; &quot;&lt; &amp; sean russell&quot;
    #   t = Text.new( &quot;&lt; &amp; &amp;s; russell&quot;, false, nil, false )
    #   t.value   #-&gt; &quot;&lt; &amp; sean russell&quot;
    #   u = Text.new( &quot;sean russell&quot;, false, nil, true )
    #   u.value   #-&gt; &quot;sean russell&quot;
    def value
      @unnormalized if @unnormalized
      doctype = nil
      if @parent
        doc = @parent.document
        doctype = doc.doctype if doc
      end
      @unnormalized = Text::unnormalize( @string, doctype )
    end

    # Sets the contents of this text node.  This expects the text to be 
    # unnormalized.  It returns self.
    #
    #   e = Element.new( &quot;a&quot; )
    #   e.add_text( &quot;foo&quot; )   # &lt;a&gt;foo&lt;/a&gt;
    #   e[0].value = &quot;bar&quot;    # &lt;a&gt;bar&lt;/a&gt;
    #   e[0].value = &quot;&lt;a&gt;&quot;    # &lt;a&gt;&amp;lt;a&amp;gt;&lt;/a&gt;
    def value=( val )
      @string = val.gsub( /\r\n?/, &quot;\n&quot; )
      @unnormalized = nil
      @normalized = nil
      @raw = false
    end
 
     def wrap(string, width, addnewline=false)
       # Recursively wrap string at width.
       return string if string.length &lt;= width
       place = string.rindex(' ', width) # Position in string with last ' ' before cutoff
       if addnewline then
         return &quot;\n&quot; + string[0,place] + &quot;\n&quot; + wrap(string[place+1..-1], width)
       else
         return string[0,place] + &quot;\n&quot; + wrap(string[place+1..-1], width)
       end
     end

    def indent_text(string, level=1, style=&quot;\t&quot;, indentfirstline=true)
      return string if level &lt; 0
      new_string = ''
      string.each { |line|
        indent_string = style * level
        new_line = (indent_string + line).sub(/[\s]+$/,'')
        new_string &lt;&lt; new_line
      }
      new_string.strip! unless indentfirstline
      return new_string
    end
 
    # == DEPRECATED
    # See REXML::Formatters
    #
    def write( writer, indent=-1, transitive=false, ie_hack=false ) 
      Kernel.warn(&quot;#{self.class.name}.write is deprecated.  See REXML::Formatters&quot;)
      formatter = if indent &gt; -1
          REXML::Formatters::Pretty.new( indent )
        else
          REXML::Formatters::Default.new
        end
      formatter.write( self, writer )
    end

    # FIXME
    # This probably won't work properly
    def xpath
      path = @parent.xpath
      path += &quot;/text()&quot;
      return path
    end

    # Writes out text, substituting special characters beforehand.
    # +out+ A String, IO, or any other object supporting &lt;&lt;( String )
    # +input+ the text to substitute and the write out
    #
    #   z=utf8.unpack(&quot;U*&quot;)
    #   ascOut=&quot;&quot;
    #   z.each{|r|
    #     if r &lt;  0x100
    #       ascOut.concat(r.chr)
    #     else
    #       ascOut.concat(sprintf(&quot;&amp;#x%x;&quot;, r))
    #     end
    #   }
    #   puts ascOut
    def write_with_substitution out, input
      copy = input.clone
      # Doing it like this rather than in a loop improves the speed
      copy.gsub!( SPECIALS[0], SUBSTITUTES[0] )
      copy.gsub!( SPECIALS[1], SUBSTITUTES[1] )
      copy.gsub!( SPECIALS[2], SUBSTITUTES[2] )
      copy.gsub!( SPECIALS[3], SUBSTITUTES[3] )
      copy.gsub!( SPECIALS[4], SUBSTITUTES[4] )
      copy.gsub!( SPECIALS[5], SUBSTITUTES[5] )
      out &lt;&lt; copy
    end

    # Reads text, substituting entities
    def Text::read_with_substitution( input, illegal=nil )
      copy = input.clone

      if copy =~ illegal
        raise ParseException.new( &quot;malformed text: Illegal character #$&amp; in \&quot;#{copy}\&quot;&quot; )
      end if illegal
      
      copy.gsub!( /\r\n?/, &quot;\n&quot; )
      if copy.include? ?&amp;
        copy.gsub!( SETUTITSBUS[0], SLAICEPS[0] )
        copy.gsub!( SETUTITSBUS[1], SLAICEPS[1] )
        copy.gsub!( SETUTITSBUS[2], SLAICEPS[2] )
        copy.gsub!( SETUTITSBUS[3], SLAICEPS[3] )
        copy.gsub!( SETUTITSBUS[4], SLAICEPS[4] )
        copy.gsub!( /&amp;#0*((?:\d+)|(?:x[a-f0-9]+));/ ) {|m|
          m=$1
          #m='0' if m==''
          m = &quot;0#{m}&quot; if m[0] == ?x
          [Integer(m)].pack('U*')
        }
      end
      copy
    end

    EREFERENCE = /&amp;(?!#{Entity::NAME};)/
    # Escapes all possible entities
    def Text::normalize( input, doctype=nil, entity_filter=nil )
      copy = input
      # Doing it like this rather than in a loop improves the speed
      #copy = copy.gsub( EREFERENCE, '&amp;amp;' )
      copy = copy.gsub( &quot;&amp;&quot;, &quot;&amp;amp;&quot; )
      if doctype
        # Replace all ampersands that aren't part of an entity
        doctype.entities.each_value do |entity|
          copy = copy.gsub( entity.value, 
            &quot;&amp;#{entity.name};&quot; ) if entity.value and 
              not( entity_filter and entity_filter.include?(entity) )
        end
      else
        # Replace all ampersands that aren't part of an entity
        DocType::DEFAULT_ENTITIES.each_value do |entity|
          copy = copy.gsub(entity.value, &quot;&amp;#{entity.name};&quot; )
        end
      end
      copy
    end

    # Unescapes all possible entities
    def Text::unnormalize( string, doctype=nil, filter=nil, illegal=nil )
      rv = string.clone
      rv.gsub!( /\r\n?/, &quot;\n&quot; )
      matches = rv.scan( REFERENCE )
      return rv if matches.size == 0
      rv.gsub!( NUMERICENTITY ) {|m|
        m=$1
        m = &quot;0#{m}&quot; if m[0] == ?x
        [Integer(m)].pack('U*')
      }
      matches.collect!{|x|x[0]}.compact!
      if matches.size &gt; 0
        if doctype
          matches.each do |entity_reference|
            unless filter and filter.include?(entity_reference)
              entity_value = doctype.entity( entity_reference )
              re = /&amp;#{entity_reference};/
              rv.gsub!( re, entity_value ) if entity_value
            end
          end
        else
          matches.each do |entity_reference|
            unless filter and filter.include?(entity_reference)
              entity_value = DocType::DEFAULT_ENTITIES[ entity_reference ]
              re = /&amp;#{entity_reference};/
              rv.gsub!( re, entity_value.value ) if entity_value
            end
          end
        end
        rv.gsub!( /&amp;amp;/, '&amp;' )
      end
      rv
    end
  end
end
</pre>
    </div>