  <div id="fileHeader">
    <h1>cgi-lib.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/cgi-lib.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>warn &quot;Warning:#{caller[0].sub(/:in `.*'\z/, '')}: cgi-lib is deprecated after Ruby 1.8.1; use cgi instead&quot;

=begin

= simple CGI support library

= example

== get form values

	require &quot;cgi-lib.rb&quot;
	query = CGI.new
	query['field']   # &lt;== value of 'field'
	query.keys       # &lt;== array of fields

and query has Hash class methods


== get cookie values

	require &quot;cgi-lib.rb&quot;
	query = CGI.new
	query.cookie['name']  # &lt;== cookie value of 'name'
	query.cookie.keys     # &lt;== all cookie names

and query.cookie has Hash class methods


== print HTTP header and HTML string to $&gt;

	require &quot;cgi-lib.rb&quot;
	CGI::print{
	  CGI::tag(&quot;HTML&quot;){
	    CGI::tag(&quot;HEAD&quot;){ CGI::tag(&quot;TITLE&quot;){&quot;TITLE&quot;} } +
	    CGI::tag(&quot;BODY&quot;){
	      CGI::tag(&quot;FORM&quot;, {&quot;ACTION&quot;=&gt;&quot;test.rb&quot;, &quot;METHOD&quot;=&gt;&quot;POST&quot;}){
	        CGI::tag(&quot;INPUT&quot;, {&quot;TYPE&quot;=&gt;&quot;submit&quot;, &quot;VALUE&quot;=&gt;&quot;submit&quot;})
	      } +
	      CGI::tag(&quot;HR&quot;)
	    }
	  }
	}


== make raw cookie string

	require &quot;cgi-lib.rb&quot;
	cookie1 = CGI::cookie({'name'    =&gt; 'name',
	                       'value'   =&gt; 'value',
	                       'path'    =&gt; 'path',   # optional
	                       'domain'  =&gt; 'domain', # optional
	                       'expires' =&gt; Time.now, # optional
	                       'secure'  =&gt; true      # optional
	                      })

	CGI::print(&quot;Content-Type: text/html&quot;, cookie1, cookie2){ &quot;string&quot; }


== print HTTP header and string to $&gt;

	require &quot;cgi-lib.rb&quot;
	CGI::print{ &quot;string&quot; }
	  # == CGI::print(&quot;Content-Type: text/html&quot;){ &quot;string&quot; }
	CGI::print(&quot;Content-Type: text/html&quot;, cookie1, cookie2){ &quot;string&quot; }


=== NPH (no-parse-header) mode

	require &quot;cgi-lib.rb&quot;
	CGI::print(&quot;nph&quot;){ &quot;string&quot; }
	  # == CGI::print(&quot;nph&quot;, &quot;Content-Type: text/html&quot;){ &quot;string&quot; }
	CGI::print(&quot;nph&quot;, &quot;Content-Type: text/html&quot;, cookie1, cookie2){ &quot;string&quot; }


== make HTML tag string

	require &quot;cgi-lib.rb&quot;
	CGI::tag(&quot;element&quot;, {&quot;attribute_name&quot;=&gt;&quot;attribute_value&quot;}){&quot;content&quot;}


== make HTTP header string

	require &quot;cgi-lib.rb&quot;
	CGI::header # == CGI::header(&quot;Content-Type: text/html&quot;)
	CGI::header(&quot;Content-Type: text/html&quot;, cookie1, cookie2)


=== NPH (no-parse-header) mode

	CGI::header(&quot;nph&quot;) # == CGI::header(&quot;nph&quot;, &quot;Content-Type: text/html&quot;)
	CGI::header(&quot;nph&quot;, &quot;Content-Type: text/html&quot;, cookie1, cookie2)


== escape url encode

	require &quot;cgi-lib.rb&quot;
	url_encoded_string = CGI::escape(&quot;string&quot;)


== unescape url encoded

	require &quot;cgi-lib.rb&quot;
	string = CGI::unescape(&quot;url encoded string&quot;)


== escape HTML &amp;&quot;&lt;&gt;

	require &quot;cgi-lib.rb&quot;
	CGI::escapeHTML(&quot;string&quot;)


=end

require &quot;delegate&quot;

class CGI &lt; SimpleDelegator

  CR  = &quot;\015&quot;
  LF  = &quot;\012&quot;
  EOL = CR + LF

  RFC822_DAYS = %w[ Sun Mon Tue Wed Thu Fri Sat ]
  RFC822_MONTHS = %w[ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ]

  # make rfc1123 date string
  def CGI::rfc1123_date(time)
    t = time.clone.gmtime
    return format(&quot;%s, %.2d %s %d %.2d:%.2d:%.2d GMT&quot;,
                RFC822_DAYS[t.wday], t.day, RFC822_MONTHS[t.month-1], t.year,
                t.hour, t.min, t.sec)
  end

  # escape url encode
  def CGI::escape(str)
    str.gsub(/[^a-zA-Z0-9_\-.]/n){ sprintf(&quot;%%%02X&quot;, $&amp;.unpack(&quot;C&quot;)[0]) }
  end

  # unescape url encoded
  def CGI::unescape(str)
    str.gsub(/\+/, ' ').gsub(/%([0-9a-fA-F]{2})/){ [$1.hex].pack(&quot;c&quot;) }
  end

  # escape HTML
  def CGI::escapeHTML(str)
    str.gsub(/&amp;/, &quot;&amp;amp;&quot;).gsub(/\&quot;/, &quot;&amp;quot;&quot;).gsub(/&gt;/, &quot;&amp;gt;&quot;).gsub(/&lt;/, &quot;&amp;lt;&quot;)
  end

  # offline mode. read name=value pairs on standard input.
  def read_from_cmdline
    require &quot;shellwords.rb&quot;
    words = Shellwords.shellwords(
              if not ARGV.empty?
                ARGV.join(' ')
              else
                STDERR.print &quot;(offline mode: enter name=value pairs on standard input)\n&quot; if STDIN.tty?
                readlines.join(' ').gsub(/\n/, '')
              end.gsub(/\\=/, '%3D').gsub(/\\&amp;/, '%26'))

    if words.find{|x| x =~ /=/} then words.join('&amp;') else words.join('+') end
  end

  def initialize(input = $stdin)

    @inputs = {}
    @cookie = {}

    case ENV['REQUEST_METHOD']
    when &quot;GET&quot;
      ENV['QUERY_STRING'] or &quot;&quot;
    when &quot;POST&quot;
      input.read(Integer(ENV['CONTENT_LENGTH'])) or &quot;&quot;
    else
      read_from_cmdline
    end.split(/[&amp;;]/).each do |x|
      key, val = x.split(/=/,2).collect{|x|CGI::unescape(x)}
      if @inputs.include?(key)
        @inputs[key] += &quot;\0&quot; + (val or &quot;&quot;)
      else
        @inputs[key] = (val or &quot;&quot;)
      end
    end

    super(@inputs)

    if ENV.has_key?('HTTP_COOKIE') or ENV.has_key?('COOKIE')
      (ENV['HTTP_COOKIE'] or ENV['COOKIE']).split(/; /).each do |x|
        key, val = x.split(/=/,2)
        key = CGI::unescape(key)
        val = val.split(/&amp;/).collect{|x|CGI::unescape(x)}.join(&quot;\0&quot;)
        if @cookie.include?(key)
          @cookie[key] += &quot;\0&quot; + val
        else
          @cookie[key] = val
        end
      end
    end
  end

  attr(&quot;inputs&quot;)
  attr(&quot;cookie&quot;)

  # make HTML tag string
  def CGI::tag(element, attributes = {})
    &quot;&lt;&quot; + escapeHTML(element) + attributes.collect{|name, value|
      &quot; &quot; + escapeHTML(name) + '=&quot;' + escapeHTML(value) + '&quot;'
    }.to_s + &quot;&gt;&quot; +
    (iterator? ? yield.to_s + &quot;&lt;/&quot; + escapeHTML(element) + &quot;&gt;&quot; : &quot;&quot;)
  end

  # make raw cookie string
  def CGI::cookie(options)
    &quot;Set-Cookie: &quot; + options['name'] + '=' + escape(options['value']) +
    (options['domain']  ? '; domain='  + options['domain'] : '') +
    (options['path']    ? '; path='    + options['path']   : '') +
    (options['expires'] ? '; expires=' + rfc1123_date(options['expires']) : '') +
    (options['secure']  ? '; secure' : '')
  end

  # make HTTP header string
  def CGI::header(*options)
    if defined?(MOD_RUBY)
      options.each{|option|
        option.sub(/(.*?): (.*)/){
          Apache::request.headers_out[$1] = $2
        }
      }
      Apache::request.send_http_header
      ''
    else
      if options.delete(&quot;nph&quot;) or (ENV['SERVER_SOFTWARE'] =~ /IIS/)
        [(ENV['SERVER_PROTOCOL'] or &quot;HTTP/1.0&quot;) + &quot; 200 OK&quot;,
         &quot;Date: &quot; + rfc1123_date(Time.now),
         &quot;Server: &quot; + (ENV['SERVER_SOFTWARE'] or &quot;&quot;),
         &quot;Connection: close&quot;] +
        (options.empty? ? [&quot;Content-Type: text/html&quot;] : options)
      else
        options.empty? ? [&quot;Content-Type: text/html&quot;] : options
      end.join(EOL) + EOL + EOL
    end
  end

  # print HTTP header and string to $&gt;
  def CGI::print(*options)
    $&gt;.print CGI::header(*options) + yield.to_s
  end

  # print message to $&gt;
  def CGI::message(message, title = &quot;&quot;, header = [&quot;Content-Type: text/html&quot;])
    if message.kind_of?(Hash)
      title   = message['title']
      header  = message['header']
      message = message['body']
    end
    CGI::print(*header){
      CGI::tag(&quot;HTML&quot;){
        CGI::tag(&quot;HEAD&quot;){ CGI.tag(&quot;TITLE&quot;){ title } } +
        CGI::tag(&quot;BODY&quot;){ message }
      }
    }
    true
  end

  # print error message to $&gt; and exit
  def CGI::error
    CGI::message({'title'=&gt;'ERROR', 'body'=&gt;
      CGI::tag(&quot;PRE&quot;){
        &quot;ERROR: &quot; + CGI::tag(&quot;STRONG&quot;){ escapeHTML($!.to_s) } + &quot;\n&quot; + escapeHTML($@.join(&quot;\n&quot;))
      }
    })
    exit
  end
end
</pre>
    </div>