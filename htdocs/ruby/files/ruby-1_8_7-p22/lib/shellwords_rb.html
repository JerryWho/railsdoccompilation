  <div id="fileHeader">
    <h1>shellwords.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/shellwords.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Mar 21 07:16:15 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# shellwords.rb: Manipulates strings a la UNIX Bourne shell
#

#
# This module manipulates strings according to the word parsing rules
# of the UNIX Bourne shell.
#
# The shellwords() function was originally a port of shellwords.pl,
# but modified to conform to POSIX / SUSv3 (IEEE Std 1003.1-2001).
#
# Authors:
#   - Wakou Aoyama
#   - Akinori MUSHA &lt;knu@iDaemons.org&gt;
#
# Contact:
#   - Akinori MUSHA &lt;knu@iDaemons.org&gt; (current maintainer)
#
module Shellwords
  #
  # Splits a string into an array of tokens in the same way the UNIX
  # Bourne shell does.
  #
  #   argv = Shellwords.split('here are &quot;two words&quot;')
  #   argv #=&gt; [&quot;here&quot;, &quot;are&quot;, &quot;two words&quot;]
  #
  # +String#shellsplit+ is a shorthand for this function.
  #
  #   argv = 'here are &quot;two words&quot;'.shellsplit
  #   argv #=&gt; [&quot;here&quot;, &quot;are&quot;, &quot;two words&quot;]
  #
  def shellsplit(line)
    line = String.new(line) rescue
      raise(ArgumentError, &quot;Argument must be a string&quot;)
    line.lstrip!
    words = []
    until line.empty?
      field = ''
      loop do
	if line.sub!(/\A&quot;(([^&quot;\\]|\\.)*)&quot;/, '') then
	  snippet = $1.gsub(/\\(.)/, '\1')
	elsif line =~ /\A&quot;/ then
	  raise ArgumentError, &quot;Unmatched double quote: #{line}&quot;
	elsif line.sub!(/\A'([^']*)'/, '') then
	  snippet = $1
	elsif line =~ /\A'/ then
	  raise ArgumentError, &quot;Unmatched single quote: #{line}&quot;
	elsif line.sub!(/\A\\(.)?/, '') then
	  snippet = $1 || '\\'
	elsif line.sub!(/\A([^\s\\'&quot;]+)/, '') then
	  snippet = $1
	else
	  line.lstrip!
	  break
	end
	field.concat(snippet)
      end
      words.push(field)
    end
    words
  end

  alias shellwords shellsplit

  module_function :shellsplit, :shellwords

  class &lt;&lt; self
    alias split shellsplit
  end

  #
  # Escapes a string so that it can be safely used in a Bourne shell
  # command line.
  #
  # Note that a resulted string should be used unquoted and is not
  # intended for use in double quotes nor in single quotes.
  #
  #   open(&quot;| grep #{Shellwords.escape(pattern)} file&quot;) { |pipe|
  #     # ...
  #   }
  #
  # +String#shellescape+ is a shorthand for this function.
  #
  #   open(&quot;| grep #{pattern.shellescape} file&quot;) { |pipe|
  #     # ...
  #   }
  #
  def shellescape(str)
    # An empty argument will be skipped, so return empty quotes.
    return &quot;''&quot; if str.empty?

    str = str.dup

    # Process as a single byte sequence because not all shell
    # implementations are multibyte aware.
    str.gsub!(/([^A-Za-z0-9_\-.,:\/@\n])/n, &quot;\\\\\\1&quot;)

    # A LF cannot be escaped with a backslash because a backslash + LF
    # combo is regarded as line continuation and simply ignored.
    str.gsub!(/\n/, &quot;'\n'&quot;)

    return str
  end

  module_function :shellescape

  class &lt;&lt; self
    alias escape shellescape
  end

  #
  # Builds a command line string from an argument list +array+ joining
  # all elements escaped for Bourne shell and separated by a space.
  #
  #   open('|' + Shellwords.join(['grep', pattern, *files])) { |pipe|
  #     # ...
  #   }
  #
  # +Array#shelljoin+ is a shorthand for this function.
  #
  #   open('|' + ['grep', pattern, *files].shelljoin) { |pipe|
  #     # ...
  #   }
  #
  def shelljoin(array)
    array.map { |arg| shellescape(arg) }.join(' ')
  end

  module_function :shelljoin

  class &lt;&lt; self
    alias join shelljoin
  end
end

class String
  #
  # call-seq:
  #   str.shellsplit =&gt; array
  #
  # Splits +str+ into an array of tokens in the same way the UNIX
  # Bourne shell does.  See +Shellwords::shellsplit+ for details.
  #
  def shellsplit
    Shellwords.split(self)
  end

  #
  # call-seq:
  #   str.shellescape =&gt; string
  #
  # Escapes +str+ so that it can be safely used in a Bourne shell
  # command line.  See +Shellwords::shellescape+ for details.
  #
  def shellescape
    Shellwords.escape(self)
  end
end

class Array
  #
  # call-seq:
  #   array.shelljoin =&gt; string
  #
  # Builds a command line string from an argument list +array+ joining
  # all elements escaped for Bourne shell and separated by a space.
  # See +Shellwords::shelljoin+ for details.
  #
  def shelljoin
    Shellwords.join(self)
  end
end
</pre>
    </div>