  <div id="fileHeader">
    <h1>ftp.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/net/ftp.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue May 29 23:27:12 -0500 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># 
# = net/ftp.rb - FTP Client Library
# 
# Written by Shugo Maeda &lt;shugo@ruby-lang.org&gt;.
#
# Documentation by Gavin Sinclair, sourced from &quot;Programming Ruby&quot; (Hunt/Thomas)
# and &quot;Ruby In a Nutshell&quot; (Matsumoto), used with permission.
# 
# This library is distributed under the terms of the Ruby license.
# You can freely distribute/modify this library.
#
# It is included in the Ruby standard library.
#
# See the Net::FTP class for an overview.
#

require &quot;socket&quot;
require &quot;monitor&quot;

module Net

  # :stopdoc:
  class FTPError &lt; StandardError; end
  class FTPReplyError &lt; FTPError; end
  class FTPTempError &lt; FTPError; end 
  class FTPPermError &lt; FTPError; end 
  class FTPProtoError &lt; FTPError; end
  # :startdoc:

  #
  # This class implements the File Transfer Protocol.  If you have used a
  # command-line FTP program, and are familiar with the commands, you will be
  # able to use this class easily.  Some extra features are included to take
  # advantage of Ruby's style and strengths.
  #
  # == Example
  # 
  #   require 'net/ftp'
  #
  # === Example 1
  #  
  #   ftp = Net::FTP.new('ftp.netlab.co.jp')
  #   ftp.login
  #   files = ftp.chdir('pub/lang/ruby/contrib')
  #   files = ftp.list('n*')
  #   ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
  #   ftp.close
  #
  # === Example 2
  #
  #   Net::FTP.open('ftp.netlab.co.jp') do |ftp|
  #     ftp.login
  #     files = ftp.chdir('pub/lang/ruby/contrib')
  #     files = ftp.list('n*')
  #     ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
  #   end
  #
  # == Major Methods
  #
  # The following are the methods most likely to be useful to users:
  # - FTP.open
  # - #getbinaryfile
  # - #gettextfile
  # - #putbinaryfile
  # - #puttextfile
  # - #chdir
  # - #nlst
  # - #size
  # - #rename
  # - #delete
  #
  class FTP
    include MonitorMixin
    
    # :stopdoc:
    FTP_PORT = 21
    CRLF = &quot;\r\n&quot;
    DEFAULT_BLOCKSIZE = 4096
    # :startdoc:
    
    # When +true+, transfers are performed in binary mode.  Default: +true+.
    attr_accessor :binary

    # When +true+, the connection is in passive mode.  Default: +false+.
    attr_accessor :passive

    # When +true+, all traffic to and from the server is written
    # to +$stdout+.  Default: +false+.
    attr_accessor :debug_mode

    # Sets or retrieves the +resume+ status, which decides whether incomplete
    # transfers are resumed or restarted.  Default: +false+.
    attr_accessor :resume

    # The server's welcome message.
    attr_reader :welcome

    # The server's last response code.
    attr_reader :last_response_code
    alias lastresp last_response_code

    # The server's last response.
    attr_reader :last_response
    
    #
    # A synonym for &lt;tt&gt;FTP.new&lt;/tt&gt;, but with a mandatory host parameter.
    #
    # If a block is given, it is passed the +FTP+ object, which will be closed
    # when the block finishes, or when an exception is raised.
    #
    def FTP.open(host, user = nil, passwd = nil, acct = nil)
      if block_given?
        ftp = new(host, user, passwd, acct)
        begin
          yield ftp
        ensure
          ftp.close
        end
      else
        new(host, user, passwd, acct)
      end
    end
    
    #
    # Creates and returns a new +FTP+ object. If a +host+ is given, a connection
    # is made. Additionally, if the +user+ is given, the given user name,
    # password, and (optionally) account are used to log in.  See #login.
    #
    def initialize(host = nil, user = nil, passwd = nil, acct = nil)
      super()
      @binary = true
      @passive = false
      @debug_mode = false
      @resume = false
      if host
	connect(host)
	if user
	  login(user, passwd, acct)
	end
      end
    end

    # Obsolete
    def return_code
      $stderr.puts(&quot;warning: Net::FTP#return_code is obsolete and do nothing&quot;)
      return &quot;\n&quot;
    end

    # Obsolete
    def return_code=(s)
      $stderr.puts(&quot;warning: Net::FTP#return_code= is obsolete and do nothing&quot;)
    end

    def open_socket(host, port)
      if defined? SOCKSsocket and ENV[&quot;SOCKS_SERVER&quot;]
	@passive = true
	return SOCKSsocket.open(host, port)
      else
	return TCPSocket.open(host, port)
      end
    end
    private :open_socket
    
    #
    # Establishes an FTP connection to host, optionally overriding the default
    # port. If the environment variable +SOCKS_SERVER+ is set, sets up the
    # connection through a SOCKS proxy. Raises an exception (typically
    # &lt;tt&gt;Errno::ECONNREFUSED&lt;/tt&gt;) if the connection cannot be established.
    #
    def connect(host, port = FTP_PORT)
      if @debug_mode
	print &quot;connect: &quot;, host, &quot;, &quot;, port, &quot;\n&quot;
      end
      synchronize do
	@sock = open_socket(host, port)
	voidresp
      end
    end

    #
    # WRITEME or make private
    #
    def set_socket(sock, get_greeting = true)
      synchronize do
	@sock = sock
	if get_greeting
	  voidresp
	end
      end
    end

    def sanitize(s)
      if s =~ /^PASS /i
	return s[0, 5] + &quot;*&quot; * (s.length - 5)
      else
	return s
      end
    end
    private :sanitize
    
    def putline(line)
      if @debug_mode
	print &quot;put: &quot;, sanitize(line), &quot;\n&quot;
      end
      line = line + CRLF
      @sock.write(line)
    end
    private :putline
    
    def getline
      line = @sock.readline # if get EOF, raise EOFError
      line.sub!(/(\r\n|\n|\r)\z/n, &quot;&quot;)
      if @debug_mode
	print &quot;get: &quot;, sanitize(line), &quot;\n&quot;
      end
      return line
    end
    private :getline
    
    def getmultiline
      line = getline
      buff = line
      if line[3] == ?-
	  code = line[0, 3]
	begin
	  line = getline
	  buff &lt;&lt; &quot;\n&quot; &lt;&lt; line
	end until line[0, 3] == code and line[3] != ?-
      end
      return buff &lt;&lt; &quot;\n&quot;
    end
    private :getmultiline
    
    def getresp
      @last_response = getmultiline
      @last_response_code = @last_response[0, 3]
      case @last_response_code
      when /\A[123]/
	return @last_response
      when /\A4/
	raise FTPTempError, @last_response
      when /\A5/
	raise FTPPermError, @last_response
      else
	raise FTPProtoError, @last_response
      end
    end
    private :getresp
    
    def voidresp
      resp = getresp
      if resp[0] != ?2
	raise FTPReplyError, resp
      end
    end
    private :voidresp
    
    #
    # Sends a command and returns the response.
    #
    def sendcmd(cmd)
      synchronize do
	putline(cmd)
	return getresp
      end
    end
    
    #
    # Sends a command and expect a response beginning with '2'.
    #
    def voidcmd(cmd)
      synchronize do
	putline(cmd)
	voidresp
      end
    end
    
    def sendport(host, port)
      af = (@sock.peeraddr)[0]
      if af == &quot;AF_INET&quot;
	hbytes = host.split(&quot;.&quot;)
	pbytes = [port / 256, port % 256]
	bytes = hbytes + pbytes
	cmd = &quot;PORT &quot; + bytes.join(&quot;,&quot;)
      elsif af == &quot;AF_INET6&quot;
	cmd = &quot;EPRT |2|&quot; + host + &quot;|&quot; + sprintf(&quot;%d&quot;, port) + &quot;|&quot;
      else
	raise FTPProtoError, host
      end
      voidcmd(cmd)
    end
    private :sendport
    
    def makeport
      sock = TCPServer.open(@sock.addr[3], 0)
      port = sock.addr[1]
      host = sock.addr[3]
      resp = sendport(host, port)
      return sock
    end
    private :makeport
    
    def makepasv
      if @sock.peeraddr[0] == &quot;AF_INET&quot;
	host, port = parse227(sendcmd(&quot;PASV&quot;))
      else
	host, port = parse229(sendcmd(&quot;EPSV&quot;))
	#     host, port = parse228(sendcmd(&quot;LPSV&quot;))
      end
      return host, port
    end
    private :makepasv
    
    def transfercmd(cmd, rest_offset = nil)
      if @passive
	host, port = makepasv
	conn = open_socket(host, port)
	if @resume and rest_offset
	  resp = sendcmd(&quot;REST &quot; + rest_offset.to_s) 
	  if resp[0] != ?3
	    raise FTPReplyError, resp
	  end
	end
	resp = sendcmd(cmd)
        # skip 2XX for some ftp servers
        resp = getresp if resp[0] == ?2
	if resp[0] != ?1
	  raise FTPReplyError, resp
	end
      else
	sock = makeport
	if @resume and rest_offset
	  resp = sendcmd(&quot;REST &quot; + rest_offset.to_s) 
	  if resp[0] != ?3
	    raise FTPReplyError, resp
	  end
	end
	resp = sendcmd(cmd)
        # skip 2XX for some ftp servers
        resp = getresp if resp[0] == ?2
	if resp[0] != ?1
	  raise FTPReplyError, resp
	end
	conn = sock.accept
	sock.close
      end
      return conn
    end
    private :transfercmd
    
    def getaddress
      thishost = Socket.gethostname
      if not thishost.index(&quot;.&quot;)
	thishost = Socket.gethostbyname(thishost)[0]
      end
      if ENV.has_key?(&quot;LOGNAME&quot;)
	realuser = ENV[&quot;LOGNAME&quot;]
      elsif ENV.has_key?(&quot;USER&quot;)
	realuser = ENV[&quot;USER&quot;]
      else
	realuser = &quot;anonymous&quot;
      end
      return realuser + &quot;@&quot; + thishost
    end
    private :getaddress
    
    #
    # Logs in to the remote host. The session must have been previously
    # connected.  If +user+ is the string &quot;anonymous&quot; and the +password+ is
    # +nil+, a password of &lt;tt&gt;user@host&lt;/tt&gt; is synthesized. If the +acct+
    # parameter is not +nil+, an FTP ACCT command is sent following the
    # successful login.  Raises an exception on error (typically
    # &lt;tt&gt;Net::FTPPermError&lt;/tt&gt;).
    #
    def login(user = &quot;anonymous&quot;, passwd = nil, acct = nil)
      if user == &quot;anonymous&quot; and passwd == nil
	passwd = getaddress
      end
      
      resp = &quot;&quot;
      synchronize do
	resp = sendcmd('USER ' + user)
	if resp[0] == ?3
	  resp = sendcmd('PASS ' + passwd)
	end
	if resp[0] == ?3
	  resp = sendcmd('ACCT ' + acct)
	end
      end
      if resp[0] != ?2
	raise FTPReplyError, resp
      end
      @welcome = resp
    end
    
    #
    # Puts the connection into binary (image) mode, issues the given command,
    # and fetches the data returned, passing it to the associated block in
    # chunks of +blocksize+ characters. Note that +cmd+ is a server command
    # (such as &quot;RETR myfile&quot;).
    #
    def retrbinary(cmd, blocksize, rest_offset = nil) # :yield: data
      synchronize do
	voidcmd(&quot;TYPE I&quot;)
	conn = transfercmd(cmd, rest_offset)
	loop do
	  data = conn.read(blocksize)
	  break if data == nil
	  yield(data)
	end
	conn.close
	voidresp
      end
    end
    
    #
    # Puts the connection into ASCII (text) mode, issues the given command, and
    # passes the resulting data, one line at a time, to the associated block. If
    # no block is given, prints the lines. Note that +cmd+ is a server command
    # (such as &quot;RETR myfile&quot;).
    #
    def retrlines(cmd) # :yield: line
      synchronize do
	voidcmd(&quot;TYPE A&quot;)
	conn = transfercmd(cmd)
	loop do
	  line = conn.gets
	  break if line == nil
	  if line[-2, 2] == CRLF
	    line = line[0 .. -3]
	  elsif line[-1] == ?\n
	    line = line[0 .. -2]
	  end
	  yield(line)
	end
	conn.close
	voidresp
      end
    end
    
    #
    # Puts the connection into binary (image) mode, issues the given server-side
    # command (such as &quot;STOR myfile&quot;), and sends the contents of the file named
    # +file+ to the server. If the optional block is given, it also passes it
    # the data, in chunks of +blocksize+ characters.
    #
    def storbinary(cmd, file, blocksize, rest_offset = nil, &amp;block) # :yield: data
      if rest_offset
        file.seek(rest_offset, IO::SEEK_SET)
      end
      synchronize do
	voidcmd(&quot;TYPE I&quot;)
	conn = transfercmd(cmd, rest_offset)
	loop do
	  buf = file.read(blocksize)
	  break if buf == nil
	  conn.write(buf)
	  yield(buf) if block
	end
	conn.close
	voidresp
      end
    end
    
    #
    # Puts the connection into ASCII (text) mode, issues the given server-side
    # command (such as &quot;STOR myfile&quot;), and sends the contents of the file
    # named +file+ to the server, one line at a time. If the optional block is
    # given, it also passes it the lines.
    #
    def storlines(cmd, file, &amp;block) # :yield: line
      synchronize do
	voidcmd(&quot;TYPE A&quot;)
	conn = transfercmd(cmd)
	loop do
	  buf = file.gets
	  break if buf == nil
	  if buf[-2, 2] != CRLF
	    buf = buf.chomp + CRLF
	  end
	  conn.write(buf)
	  yield(buf) if block
	end
	conn.close
	voidresp
      end
    end

    #
    # Retrieves +remotefile+ in binary mode, storing the result in +localfile+.
    # If a block is supplied, it is passed the retrieved data in +blocksize+
    # chunks.
    #
    def getbinaryfile(remotefile, localfile = File.basename(remotefile),
		      blocksize = DEFAULT_BLOCKSIZE, &amp;block) # :yield: data
      if @resume
	rest_offset = File.size?(localfile)
	f = open(localfile, &quot;a&quot;)
      else
	rest_offset = nil
	f = open(localfile, &quot;w&quot;)
      end
      begin
	f.binmode
	retrbinary(&quot;RETR &quot; + remotefile, blocksize, rest_offset) do |data|
	  f.write(data)
	  yield(data) if block
	end
      ensure
	f.close
      end
    end
    
    #
    # Retrieves +remotefile+ in ASCII (text) mode, storing the result in
    # +localfile+. If a block is supplied, it is passed the retrieved data one
    # line at a time.
    #
    def gettextfile(remotefile, localfile = File.basename(remotefile), &amp;block) # :yield: line
      f = open(localfile, &quot;w&quot;)
      begin
	retrlines(&quot;RETR &quot; + remotefile) do |line|
	  f.puts(line)
	  yield(line) if block
	end
      ensure
	f.close
      end
    end

    #
    # Retrieves +remotefile+ in whatever mode the session is set (text or
    # binary).  See #gettextfile and #getbinaryfile.
    #
    def get(remotefile, localfile = File.basename(remotefile),
	    blocksize = DEFAULT_BLOCKSIZE, &amp;block) # :yield: data
      unless @binary
	gettextfile(remotefile, localfile, &amp;block)
      else
	getbinaryfile(remotefile, localfile, blocksize, &amp;block)
      end
    end
    
    #
    # Transfers +localfile+ to the server in binary mode, storing the result in
    # +remotefile+. If a block is supplied, calls it, passing in the transmitted
    # data in +blocksize+ chunks.
    #
    def putbinaryfile(localfile, remotefile = File.basename(localfile),
		      blocksize = DEFAULT_BLOCKSIZE, &amp;block) # :yield: data
      if @resume
        begin
          rest_offset = size(remotefile)
        rescue Net::FTPPermError
          rest_offset = nil
        end
      else
	rest_offset = nil
      end
      f = open(localfile)
      begin
	f.binmode
	storbinary(&quot;STOR &quot; + remotefile, f, blocksize, rest_offset, &amp;block)
      ensure
	f.close
      end
    end
    
    #
    # Transfers +localfile+ to the server in ASCII (text) mode, storing the result
    # in +remotefile+. If callback or an associated block is supplied, calls it,
    # passing in the transmitted data one line at a time.
    #
    def puttextfile(localfile, remotefile = File.basename(localfile), &amp;block) # :yield: line
      f = open(localfile)
      begin
	storlines(&quot;STOR &quot; + remotefile, f, &amp;block)
      ensure
	f.close
      end
    end

    #
    # Transfers +localfile+ to the server in whatever mode the session is set
    # (text or binary).  See #puttextfile and #putbinaryfile.
    #
    def put(localfile, remotefile = File.basename(localfile),
	    blocksize = DEFAULT_BLOCKSIZE, &amp;block)
      unless @binary
	puttextfile(localfile, remotefile, &amp;block)
      else
	putbinaryfile(localfile, remotefile, blocksize, &amp;block)
      end
    end

    #
    # Sends the ACCT command.  TODO: more info.
    #
    def acct(account)
      cmd = &quot;ACCT &quot; + account
      voidcmd(cmd)
    end
    
    #
    # Returns an array of filenames in the remote directory.
    #
    def nlst(dir = nil)
      cmd = &quot;NLST&quot;
      if dir
	cmd = cmd + &quot; &quot; + dir
      end
      files = []
      retrlines(cmd) do |line|
	files.push(line)
      end
      return files
    end
    
    #
    # Returns an array of file information in the directory (the output is like
    # `ls -l`).  If a block is given, it iterates through the listing.
    #
    def list(*args, &amp;block) # :yield: line
      cmd = &quot;LIST&quot;
      args.each do |arg|
	cmd = cmd + &quot; &quot; + arg
      end
      if block
	retrlines(cmd, &amp;block)
      else
	lines = []
	retrlines(cmd) do |line|
	  lines &lt;&lt; line
	end
	return lines
      end
    end
    alias ls list
    alias dir list
    
    #
    # Renames a file on the server.
    #
    def rename(fromname, toname)
      resp = sendcmd(&quot;RNFR &quot; + fromname)
      if resp[0] != ?3
	raise FTPReplyError, resp
      end
      voidcmd(&quot;RNTO &quot; + toname)
    end
    
    #
    # Deletes a file on the server.
    #
    def delete(filename)
      resp = sendcmd(&quot;DELE &quot; + filename)
      if resp[0, 3] == &quot;250&quot;
	return
      elsif resp[0] == ?5
	raise FTPPermError, resp
      else
	raise FTPReplyError, resp
      end
    end
    
    #
    # Changes the (remote) directory.
    #
    def chdir(dirname)
      if dirname == &quot;..&quot;
	begin
	  voidcmd(&quot;CDUP&quot;)
	  return
	rescue FTPPermError
	  if $![0, 3] != &quot;500&quot;
	    raise FTPPermError, $!
	  end
	end
      end
      cmd = &quot;CWD &quot; + dirname
      voidcmd(cmd)
    end
    
    #
    # Returns the size of the given (remote) filename.
    #
    def size(filename)
      voidcmd(&quot;TYPE I&quot;)
      resp = sendcmd(&quot;SIZE &quot; + filename)
      if resp[0, 3] != &quot;213&quot; 
	raise FTPReplyError, resp
      end
      return resp[3..-1].strip.to_i
    end
    
    MDTM_REGEXP = /^(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)/  # :nodoc:
    
    #
    # Returns the last modification time of the (remote) file.  If +local+ is
    # +true+, it is returned as a local time, otherwise it's a UTC time.
    #
    def mtime(filename, local = false)
      str = mdtm(filename)
      ary = str.scan(MDTM_REGEXP)[0].collect {|i| i.to_i}
      return local ? Time.local(*ary) : Time.gm(*ary)
    end
    
    #
    # Creates a remote directory.
    #
    def mkdir(dirname)
      resp = sendcmd(&quot;MKD &quot; + dirname)
      return parse257(resp)
    end
    
    #
    # Removes a remote directory.
    #
    def rmdir(dirname)
      voidcmd(&quot;RMD &quot; + dirname)
    end
    
    #
    # Returns the current remote directory.
    #
    def pwd
      resp = sendcmd(&quot;PWD&quot;)
      return parse257(resp)
    end
    alias getdir pwd
    
    #
    # Returns system information.
    #
    def system
      resp = sendcmd(&quot;SYST&quot;)
      if resp[0, 3] != &quot;215&quot;
	raise FTPReplyError, resp
      end
      return resp[4 .. -1]
    end
    
    #
    # Aborts the previous command (ABOR command).
    #
    def abort
      line = &quot;ABOR&quot; + CRLF
      print &quot;put: ABOR\n&quot; if @debug_mode
      @sock.send(line, Socket::MSG_OOB)
      resp = getmultiline
      unless [&quot;426&quot;, &quot;226&quot;, &quot;225&quot;].include?(resp[0, 3])
	raise FTPProtoError, resp
      end
      return resp
    end
    
    #
    # Returns the status (STAT command).
    #
    def status
      line = &quot;STAT&quot; + CRLF
      print &quot;put: STAT\n&quot; if @debug_mode
      @sock.send(line, Socket::MSG_OOB)
      return getresp
    end
    
    #
    # Issues the MDTM command.  TODO: more info.
    #
    def mdtm(filename)
      resp = sendcmd(&quot;MDTM &quot; + filename)
      if resp[0, 3] == &quot;213&quot;
	return resp[3 .. -1].strip
      end
    end
    
    #
    # Issues the HELP command.
    #
    def help(arg = nil)
      cmd = &quot;HELP&quot;
      if arg
	cmd = cmd + &quot; &quot; + arg
      end
      sendcmd(cmd)
    end
    
    #
    # Exits the FTP session.
    #
    def quit
      voidcmd(&quot;QUIT&quot;)
    end

    #
    # Issues a NOOP command.
    #
    def noop
      voidcmd(&quot;NOOP&quot;)
    end

    #
    # Issues a SITE command.
    #
    def site(arg)
      cmd = &quot;SITE &quot; + arg
      voidcmd(cmd)
    end
    
    #
    # Closes the connection.  Further operations are impossible until you open
    # a new connection with #connect.
    #
    def close
      @sock.close if @sock and not @sock.closed?
    end
    
    #
    # Returns +true+ iff the connection is closed.
    #
    def closed?
      @sock == nil or @sock.closed?
    end
    
    def parse227(resp)
      if resp[0, 3] != &quot;227&quot;
	raise FTPReplyError, resp
      end
      left = resp.index(&quot;(&quot;)
      right = resp.index(&quot;)&quot;)
      if left == nil or right == nil
	raise FTPProtoError, resp
      end
      numbers = resp[left + 1 .. right - 1].split(&quot;,&quot;)
      if numbers.length != 6
	raise FTPProtoError, resp
      end
      host = numbers[0, 4].join(&quot;.&quot;)
      port = (numbers[4].to_i &lt;&lt; 8) + numbers[5].to_i
      return host, port
    end
    private :parse227
    
    def parse228(resp)
      if resp[0, 3] != &quot;228&quot;
	raise FTPReplyError, resp
      end
      left = resp.index(&quot;(&quot;)
      right = resp.index(&quot;)&quot;)
      if left == nil or right == nil
	raise FTPProtoError, resp
      end
      numbers = resp[left + 1 .. right - 1].split(&quot;,&quot;)
      if numbers[0] == &quot;4&quot;
	if numbers.length != 9 || numbers[1] != &quot;4&quot; || numbers[2 + 4] != &quot;2&quot;
	  raise FTPProtoError, resp
	end
	host = numbers[2, 4].join(&quot;.&quot;)
	port = (numbers[7].to_i &lt;&lt; 8) + numbers[8].to_i
      elsif numbers[0] == &quot;6&quot;
	if numbers.length != 21 || numbers[1] != &quot;16&quot; || numbers[2 + 16] != &quot;2&quot;
	  raise FTPProtoError, resp
	end
	v6 = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]
	for i in 0 .. 7
	  v6[i] = sprintf(&quot;%02x%02x&quot;, numbers[(i * 2) + 2].to_i,
			  numbers[(i * 2) + 3].to_i)
	end
	host = v6[0, 8].join(&quot;:&quot;)
	port = (numbers[19].to_i &lt;&lt; 8) + numbers[20].to_i
      end 
      return host, port
    end
    private :parse228
    
    def parse229(resp)
      if resp[0, 3] != &quot;229&quot;
	raise FTPReplyError, resp
      end
      left = resp.index(&quot;(&quot;)
      right = resp.index(&quot;)&quot;)
      if left == nil or right == nil
	raise FTPProtoError, resp
      end
      numbers = resp[left + 1 .. right - 1].split(resp[left + 1, 1])
      if numbers.length != 4
	raise FTPProtoError, resp
      end
      port = numbers[3].to_i
      host = (@sock.peeraddr())[3]
      return host, port
    end
    private :parse229
    
    def parse257(resp)
      if resp[0, 3] != &quot;257&quot;
	raise FTPReplyError, resp
      end
      if resp[3, 2] != ' &quot;'
	return &quot;&quot;
      end
      dirname = &quot;&quot;
      i = 5
      n = resp.length
      while i &lt; n
	c = resp[i, 1]
	i = i + 1
	if c == '&quot;'
	  if i &gt; n or resp[i, 1] != '&quot;'
	    break
	  end
	  i = i + 1
	end
	dirname = dirname + c
      end
      return dirname
    end
    private :parse257
  end

end


# Documentation comments:
#  - sourced from pickaxe and nutshell, with improvements (hopefully)
#  - three methods should be private (search WRITEME)
#  - two methods need more information (search TODO)
</pre>
    </div>