  <div id="fileHeader">
    <h1>telnet.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/net/telnet.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun May 18 10:02:36 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># = net/telnet.rb - Simple Telnet Client Library
# 
# Author:: Wakou Aoyama &lt;wakou@ruby-lang.org&gt;
# Documentation:: William Webber and Wakou Aoyama 
#
# This file holds the class Net::Telnet, which provides client-side
# telnet functionality.
#
# For documentation, see Net::Telnet.
#

require &quot;socket&quot;
require &quot;delegate&quot;
require &quot;timeout&quot;
require &quot;English&quot;
 
module Net

  #
  # == Net::Telnet
  #
  # Provides telnet client functionality.
  #
  # This class also has, through delegation, all the methods of a
  # socket object (by default, a +TCPSocket+, but can be set by the
  # +Proxy+ option to &lt;tt&gt;new()&lt;/tt&gt;).  This provides methods such as
  # &lt;tt&gt;close()&lt;/tt&gt; to end the session and &lt;tt&gt;sysread()&lt;/tt&gt; to read
  # data directly from the host, instead of via the &lt;tt&gt;waitfor()&lt;/tt&gt;
  # mechanism.  Note that if you do use &lt;tt&gt;sysread()&lt;/tt&gt; directly
  # when in telnet mode, you should probably pass the output through
  # &lt;tt&gt;preprocess()&lt;/tt&gt; to extract telnet command sequences.
  #
  # == Overview
  #
  # The telnet protocol allows a client to login remotely to a user
  # account on a server and execute commands via a shell.  The equivalent
  # is done by creating a Net::Telnet class with the +Host+ option
  # set to your host, calling #login() with your user and password,
  # issuing one or more #cmd() calls, and then calling #close()
  # to end the session.  The #waitfor(), #print(), #puts(), and
  # #write() methods, which #cmd() is implemented on top of, are
  # only needed if you are doing something more complicated.
  #
  # A Net::Telnet object can also be used to connect to non-telnet
  # services, such as SMTP or HTTP.  In this case, you normally
  # want to provide the +Port+ option to specify the port to
  # connect to, and set the +Telnetmode+ option to false to prevent
  # the client from attempting to interpret telnet command sequences.
  # Generally, #login() will not work with other protocols, and you
  # have to handle authentication yourself.
  #
  # For some protocols, it will be possible to specify the +Prompt+
  # option once when you create the Telnet object and use #cmd() calls; 
  # for others, you will have to specify the response sequence to
  # look for as the Match option to every #cmd() call, or call
  # #puts() and #waitfor() directly; for yet others, you will have 
  # to use #sysread() instead of #waitfor() and parse server 
  # responses yourself.
  #
  # It is worth noting that when you create a new Net::Telnet object,
  # you can supply a proxy IO channel via the Proxy option.  This
  # can be used to attach the Telnet object to other Telnet objects,
  # to already open sockets, or to any read-write IO object.  This
  # can be useful, for instance, for setting up a test fixture for
  # unit testing.
  # 
  # == Examples
  # 
  # === Log in and send a command, echoing all output to stdout
  # 
  #   localhost = Net::Telnet::new(&quot;Host&quot; =&gt; &quot;localhost&quot;,
  #                                &quot;Timeout&quot; =&gt; 10,
  #                                &quot;Prompt&quot; =&gt; /[$%#&gt;] \z/n)
  #   localhost.login(&quot;username&quot;, &quot;password&quot;) { |c| print c }
  #   localhost.cmd(&quot;command&quot;) { |c| print c }
  #   localhost.close
  # 
  # 
  # === Check a POP server to see if you have mail
  # 
  #   pop = Net::Telnet::new(&quot;Host&quot; =&gt; &quot;your_destination_host_here&quot;,
  #                          &quot;Port&quot; =&gt; 110,
  #                          &quot;Telnetmode&quot; =&gt; false,
  #                          &quot;Prompt&quot; =&gt; /^\+OK/n)
  #   pop.cmd(&quot;user &quot; + &quot;your_username_here&quot;) { |c| print c }
  #   pop.cmd(&quot;pass &quot; + &quot;your_password_here&quot;) { |c| print c }
  #   pop.cmd(&quot;list&quot;) { |c| print c }
  #
  # == References
  #
  # There are a large number of RFCs relevant to the Telnet protocol.
  # RFCs 854-861 define the base protocol.  For a complete listing
  # of relevant RFCs, see
  # http://www.omnifarious.org/~hopper/technical/telnet-rfc.html
  #
  class Telnet &lt; SimpleDelegator

    # :stopdoc:
    IAC   = 255.chr # &quot;\377&quot; # &quot;\xff&quot; # interpret as command
    DONT  = 254.chr # &quot;\376&quot; # &quot;\xfe&quot; # you are not to use option 
    DO    = 253.chr # &quot;\375&quot; # &quot;\xfd&quot; # please, you use option 
    WONT  = 252.chr # &quot;\374&quot; # &quot;\xfc&quot; # I won't use option 
    WILL  = 251.chr # &quot;\373&quot; # &quot;\xfb&quot; # I will use option 
    SB    = 250.chr # &quot;\372&quot; # &quot;\xfa&quot; # interpret as subnegotiation 
    GA    = 249.chr # &quot;\371&quot; # &quot;\xf9&quot; # you may reverse the line 
    EL    = 248.chr # &quot;\370&quot; # &quot;\xf8&quot; # erase the current line 
    EC    = 247.chr # &quot;\367&quot; # &quot;\xf7&quot; # erase the current character 
    AYT   = 246.chr # &quot;\366&quot; # &quot;\xf6&quot; # are you there 
    AO    = 245.chr # &quot;\365&quot; # &quot;\xf5&quot; # abort output--but let prog finish 
    IP    = 244.chr # &quot;\364&quot; # &quot;\xf4&quot; # interrupt process--permanently 
    BREAK = 243.chr # &quot;\363&quot; # &quot;\xf3&quot; # break 
    DM    = 242.chr # &quot;\362&quot; # &quot;\xf2&quot; # data mark--for connect. cleaning 
    NOP   = 241.chr # &quot;\361&quot; # &quot;\xf1&quot; # nop 
    SE    = 240.chr # &quot;\360&quot; # &quot;\xf0&quot; # end sub negotiation 
    EOR   = 239.chr # &quot;\357&quot; # &quot;\xef&quot; # end of record (transparent mode) 
    ABORT = 238.chr # &quot;\356&quot; # &quot;\xee&quot; # Abort process 
    SUSP  = 237.chr # &quot;\355&quot; # &quot;\xed&quot; # Suspend process 
    EOF   = 236.chr # &quot;\354&quot; # &quot;\xec&quot; # End of file 
    SYNCH = 242.chr # &quot;\362&quot; # &quot;\xf2&quot; # for telfunc calls 

    OPT_BINARY         =   0.chr # &quot;\000&quot; # &quot;\x00&quot; # Binary Transmission 
    OPT_ECHO           =   1.chr # &quot;\001&quot; # &quot;\x01&quot; # Echo 
    OPT_RCP            =   2.chr # &quot;\002&quot; # &quot;\x02&quot; # Reconnection 
    OPT_SGA            =   3.chr # &quot;\003&quot; # &quot;\x03&quot; # Suppress Go Ahead 
    OPT_NAMS           =   4.chr # &quot;\004&quot; # &quot;\x04&quot; # Approx Message Size Negotiation 
    OPT_STATUS         =   5.chr # &quot;\005&quot; # &quot;\x05&quot; # Status 
    OPT_TM             =   6.chr # &quot;\006&quot; # &quot;\x06&quot; # Timing Mark 
    OPT_RCTE           =   7.chr # &quot;\a&quot;   # &quot;\x07&quot; # Remote Controlled Trans and Echo 
    OPT_NAOL           =   8.chr # &quot;\010&quot; # &quot;\x08&quot; # Output Line Width 
    OPT_NAOP           =   9.chr # &quot;\t&quot;   # &quot;\x09&quot; # Output Page Size 
    OPT_NAOCRD         =  10.chr # &quot;\n&quot;   # &quot;\x0a&quot; # Output Carriage-Return Disposition 
    OPT_NAOHTS         =  11.chr # &quot;\v&quot;   # &quot;\x0b&quot; # Output Horizontal Tab Stops 
    OPT_NAOHTD         =  12.chr # &quot;\f&quot;   # &quot;\x0c&quot; # Output Horizontal Tab Disposition 
    OPT_NAOFFD         =  13.chr # &quot;\r&quot;   # &quot;\x0d&quot; # Output Formfeed Disposition 
    OPT_NAOVTS         =  14.chr # &quot;\016&quot; # &quot;\x0e&quot; # Output Vertical Tabstops 
    OPT_NAOVTD         =  15.chr # &quot;\017&quot; # &quot;\x0f&quot; # Output Vertical Tab Disposition 
    OPT_NAOLFD         =  16.chr # &quot;\020&quot; # &quot;\x10&quot; # Output Linefeed Disposition 
    OPT_XASCII         =  17.chr # &quot;\021&quot; # &quot;\x11&quot; # Extended ASCII 
    OPT_LOGOUT         =  18.chr # &quot;\022&quot; # &quot;\x12&quot; # Logout 
    OPT_BM             =  19.chr # &quot;\023&quot; # &quot;\x13&quot; # Byte Macro 
    OPT_DET            =  20.chr # &quot;\024&quot; # &quot;\x14&quot; # Data Entry Terminal 
    OPT_SUPDUP         =  21.chr # &quot;\025&quot; # &quot;\x15&quot; # SUPDUP 
    OPT_SUPDUPOUTPUT   =  22.chr # &quot;\026&quot; # &quot;\x16&quot; # SUPDUP Output 
    OPT_SNDLOC         =  23.chr # &quot;\027&quot; # &quot;\x17&quot; # Send Location 
    OPT_TTYPE          =  24.chr # &quot;\030&quot; # &quot;\x18&quot; # Terminal Type 
    OPT_EOR            =  25.chr # &quot;\031&quot; # &quot;\x19&quot; # End of Record 
    OPT_TUID           =  26.chr # &quot;\032&quot; # &quot;\x1a&quot; # TACACS User Identification 
    OPT_OUTMRK         =  27.chr # &quot;\e&quot;   # &quot;\x1b&quot; # Output Marking 
    OPT_TTYLOC         =  28.chr # &quot;\034&quot; # &quot;\x1c&quot; # Terminal Location Number 
    OPT_3270REGIME     =  29.chr # &quot;\035&quot; # &quot;\x1d&quot; # Telnet 3270 Regime 
    OPT_X3PAD          =  30.chr # &quot;\036&quot; # &quot;\x1e&quot; # X.3 PAD 
    OPT_NAWS           =  31.chr # &quot;\037&quot; # &quot;\x1f&quot; # Negotiate About Window Size 
    OPT_TSPEED         =  32.chr # &quot; &quot;    # &quot;\x20&quot; # Terminal Speed 
    OPT_LFLOW          =  33.chr # &quot;!&quot;    # &quot;\x21&quot; # Remote Flow Control 
    OPT_LINEMODE       =  34.chr # &quot;\&quot;&quot;   # &quot;\x22&quot; # Linemode 
    OPT_XDISPLOC       =  35.chr # &quot;#&quot;    # &quot;\x23&quot; # X Display Location 
    OPT_OLD_ENVIRON    =  36.chr # &quot;$&quot;    # &quot;\x24&quot; # Environment Option 
    OPT_AUTHENTICATION =  37.chr # &quot;%&quot;    # &quot;\x25&quot; # Authentication Option 
    OPT_ENCRYPT        =  38.chr # &quot;&amp;&quot;    # &quot;\x26&quot; # Encryption Option 
    OPT_NEW_ENVIRON    =  39.chr # &quot;'&quot;    # &quot;\x27&quot; # New Environment Option 
    OPT_EXOPL          = 255.chr # &quot;\377&quot; # &quot;\xff&quot; # Extended-Options-List 

    NULL = &quot;\000&quot; 
    CR   = &quot;\015&quot;   
    LF   = &quot;\012&quot; 
    EOL  = CR + LF 
    REVISION = '$Id: telnet.rb 16458 2008-05-18 15:02:36Z knu $'
    # :startdoc:

    #
    # Creates a new Net::Telnet object.
    #
    # Attempts to connect to the host (unless the Proxy option is
    # provided: see below).  If a block is provided, it is yielded
    # status messages on the attempt to connect to the server, of
    # the form:
    # 
    #   Trying localhost...
    #   Connected to localhost.
    #
    # +options+ is a hash of options.  The following example lists
    # all options and their default values.
    # 
    #   host = Net::Telnet::new(
    #            &quot;Host&quot;       =&gt; &quot;localhost&quot;,  # default: &quot;localhost&quot;
    #            &quot;Port&quot;       =&gt; 23,           # default: 23
    #            &quot;Binmode&quot;    =&gt; false,        # default: false
    #            &quot;Output_log&quot; =&gt; &quot;output_log&quot;, # default: nil (no output)
    #            &quot;Dump_log&quot;   =&gt; &quot;dump_log&quot;,   # default: nil (no output)
    #            &quot;Prompt&quot;     =&gt; /[$%#&gt;] \z/n, # default: /[$%#&gt;] \z/n
    #            &quot;Telnetmode&quot; =&gt; true,         # default: true
    #            &quot;Timeout&quot;    =&gt; 10,           # default: 10
    #              # if ignore timeout then set &quot;Timeout&quot; to false.
    #            &quot;Waittime&quot;   =&gt; 0,            # default: 0
    #            &quot;Proxy&quot;      =&gt; proxy         # default: nil
    #                            # proxy is Net::Telnet or IO object
    #          )
    #
    # The options have the following meanings:
    #
    # Host:: the hostname or IP address of the host to connect to, as a String. 
    #        Defaults to &quot;localhost&quot;.
    #
    # Port:: the port to connect to.  Defaults to 23.
    #
    # Binmode:: if false (the default), newline substitution is performed.  
    #           Outgoing LF is
    #           converted to CRLF, and incoming CRLF is converted to LF.  If
    #           true, this substitution is not performed.  This value can
    #           also be set with the #binmode() method.  The 
    #           outgoing conversion only applies to the #puts() and #print()
    #           methods, not the #write() method.  The precise nature of
    #           the newline conversion is also affected by the telnet options
    #           SGA and BIN.
    #
    # Output_log:: the name of the file to write connection status messages
    #              and all received traffic to.  In the case of a proper
    #              Telnet session, this will include the client input as
    #              echoed by the host; otherwise, it only includes server
    #              responses.  Output is appended verbatim to this file.  
    #              By default, no output log is kept.
    #
    # Dump_log:: as for Output_log, except that output is written in hexdump
    #            format (16 bytes per line as hex pairs, followed by their
    #            printable equivalent), with connection status messages
    #            preceded by '#', sent traffic preceded by '&gt;', and 
    #            received traffic preceded by '&lt;'.  By default, not dump log
    #            is kept.
    #
    # Prompt:: a regular expression matching the host's command-line prompt
    #          sequence.  This is needed by the Telnet class to determine
    #          when the output from a command has finished and the host is
    #          ready to receive a new command.  By default, this regular
    #          expression is /[$%#&gt;] \z/n.
    #
    # Telnetmode:: a boolean value, true by default.  In telnet mode, 
    #              traffic received from the host is parsed for special
    #              command sequences, and these sequences are escaped
    #              in outgoing traffic sent using #puts() or #print()
    #              (but not #write()).  If you are using the Net::Telnet
    #              object to connect to a non-telnet service (such as
    #              SMTP or POP), this should be set to &quot;false&quot; to prevent
    #              undesired data corruption.  This value can also be set
    #              by the #telnetmode() method.
    #
    # Timeout:: the number of seconds to wait before timing out both the
    #           initial attempt to connect to host (in this constructor),
    #           and all attempts to read data from the host (in #waitfor(),
    #           #cmd(), and #login()).  Exceeding this timeout causes a
    #           TimeoutError to be raised.  The default value is 10 seconds.
    #           You can disable the timeout by setting this value to false.
    #           In this case, the connect attempt will eventually timeout
    #           on the underlying connect(2) socket call with an
    #           Errno::ETIMEDOUT error (but generally only after a few
    #           minutes), but other attempts to read data from the host
    #           will hand indefinitely if no data is forthcoming.
    #
    # Waittime:: the amount of time to wait after seeing what looks like a 
    #            prompt (that is, received data that matches the Prompt
    #            option regular expression) to see if more data arrives.
    #            If more data does arrive in this time, Net::Telnet assumes
    #            that what it saw was not really a prompt.  This is to try to 
    #            avoid false matches, but it can also lead to missing real
    #            prompts (if, for instance, a background process writes to
    #            the terminal soon after the prompt is displayed).  By
    #            default, set to 0, meaning not to wait for more data.
    #
    # Proxy:: a proxy object to used instead of opening a direct connection
    #         to the host.  Must be either another Net::Telnet object or
    #         an IO object.  If it is another Net::Telnet object, this 
    #         instance will use that one's socket for communication.  If an
    #         IO object, it is used directly for communication.  Any other
    #         kind of object will cause an error to be raised.
    #
    def initialize(options) # :yield: mesg 
      @options = options
      @options[&quot;Host&quot;]       = &quot;localhost&quot;   unless @options.has_key?(&quot;Host&quot;)
      @options[&quot;Port&quot;]       = 23            unless @options.has_key?(&quot;Port&quot;)
      @options[&quot;Prompt&quot;]     = /[$%#&gt;] \z/n  unless @options.has_key?(&quot;Prompt&quot;)
      @options[&quot;Timeout&quot;]    = 10            unless @options.has_key?(&quot;Timeout&quot;)
      @options[&quot;Waittime&quot;]   = 0             unless @options.has_key?(&quot;Waittime&quot;)
      unless @options.has_key?(&quot;Binmode&quot;)
        @options[&quot;Binmode&quot;]    = false         
      else
        unless (true == @options[&quot;Binmode&quot;] or false == @options[&quot;Binmode&quot;])
          raise ArgumentError, &quot;Binmode option must be true or false&quot;
        end
      end

      unless @options.has_key?(&quot;Telnetmode&quot;)
        @options[&quot;Telnetmode&quot;] = true          
      else
        unless (true == @options[&quot;Telnetmode&quot;] or false == @options[&quot;Telnetmode&quot;])
          raise ArgumentError, &quot;Telnetmode option must be true or false&quot;
        end
      end

      @telnet_option = { &quot;SGA&quot; =&gt; false, &quot;BINARY&quot; =&gt; false }

      if @options.has_key?(&quot;Output_log&quot;)
        @log = File.open(@options[&quot;Output_log&quot;], 'a+')
        @log.sync = true
        @log.binmode
      end

      if @options.has_key?(&quot;Dump_log&quot;)
        @dumplog = File.open(@options[&quot;Dump_log&quot;], 'a+')
        @dumplog.sync = true
        @dumplog.binmode
        def @dumplog.log_dump(dir, x)  # :nodoc:
          len = x.length
          addr = 0
          offset = 0
          while 0 &lt; len
            if len &lt; 16
              line = x[offset, len]
            else
              line = x[offset, 16]
            end
            hexvals = line.unpack('H*')[0]
            hexvals += ' ' * (32 - hexvals.length)
            hexvals = format(&quot;%s %s %s %s  &quot; * 4, *hexvals.unpack('a2' * 16))
            line = line.gsub(/[\000-\037\177-\377]/n, '.')
            printf &quot;%s 0x%5.5x: %s%s\n&quot;, dir, addr, hexvals, line
            addr += 16
            offset += 16
            len -= 16
          end
          print &quot;\n&quot;
        end
      end

      if @options.has_key?(&quot;Proxy&quot;)
        if @options[&quot;Proxy&quot;].kind_of?(Net::Telnet)
          @sock = @options[&quot;Proxy&quot;].sock
        elsif @options[&quot;Proxy&quot;].kind_of?(IO)
          @sock = @options[&quot;Proxy&quot;]
        else
          raise &quot;Error: Proxy must be an instance of Net::Telnet or IO.&quot;
        end
      else
        message = &quot;Trying &quot; + @options[&quot;Host&quot;] + &quot;...\n&quot;
        yield(message) if block_given?
        @log.write(message) if @options.has_key?(&quot;Output_log&quot;)
        @dumplog.log_dump('#', message) if @options.has_key?(&quot;Dump_log&quot;)

        begin
          if @options[&quot;Timeout&quot;] == false
            @sock = TCPSocket.open(@options[&quot;Host&quot;], @options[&quot;Port&quot;])
          else
            timeout(@options[&quot;Timeout&quot;]) do
              @sock = TCPSocket.open(@options[&quot;Host&quot;], @options[&quot;Port&quot;])
            end
          end
        rescue TimeoutError
          raise TimeoutError, &quot;timed out while opening a connection to the host&quot;
        rescue
          @log.write($ERROR_INFO.to_s + &quot;\n&quot;) if @options.has_key?(&quot;Output_log&quot;)
          @dumplog.log_dump('#', $ERROR_INFO.to_s + &quot;\n&quot;) if @options.has_key?(&quot;Dump_log&quot;)
          raise
        end
        @sock.sync = true
        @sock.binmode

        message = &quot;Connected to &quot; + @options[&quot;Host&quot;] + &quot;.\n&quot;
        yield(message) if block_given?
        @log.write(message) if @options.has_key?(&quot;Output_log&quot;)
        @dumplog.log_dump('#', message) if @options.has_key?(&quot;Dump_log&quot;)
      end

      super(@sock)
    end # initialize

    # The socket the Telnet object is using.  Note that this object becomes
    # a delegate of the Telnet object, so normally you invoke its methods
    # directly on the Telnet object.
    attr :sock 

    # Set telnet command interpretation on (+mode+ == true) or off
    # (+mode+ == false), or return the current value (+mode+ not
    # provided).  It should be on for true telnet sessions, off if
    # using Net::Telnet to connect to a non-telnet service such
    # as SMTP.
    def telnetmode(mode = nil)
      case mode
      when nil
        @options[&quot;Telnetmode&quot;]
      when true, false
        @options[&quot;Telnetmode&quot;] = mode
      else
        raise ArgumentError, &quot;argument must be true or false, or missing&quot;
      end
    end

    # Turn telnet command interpretation on (true) or off (false).  It
    # should be on for true telnet sessions, off if using Net::Telnet
    # to connect to a non-telnet service such as SMTP.
    def telnetmode=(mode)
      if (true == mode or false == mode)
        @options[&quot;Telnetmode&quot;] = mode
      else
        raise ArgumentError, &quot;argument must be true or false&quot;
      end
    end

    # Turn newline conversion on (+mode+ == false) or off (+mode+ == true),
    # or return the current value (+mode+ is not specified).
    def binmode(mode = nil)
      case mode
      when nil
        @options[&quot;Binmode&quot;] 
      when true, false
        @options[&quot;Binmode&quot;] = mode
      else
        raise ArgumentError, &quot;argument must be true or false&quot;
      end
    end

    # Turn newline conversion on (false) or off (true).
    def binmode=(mode)
      if (true == mode or false == mode)
        @options[&quot;Binmode&quot;] = mode
      else
        raise ArgumentError, &quot;argument must be true or false&quot;
      end
    end

    # Preprocess received data from the host.
    #
    # Performs newline conversion and detects telnet command sequences.
    # Called automatically by #waitfor().  You should only use this 
    # method yourself if you have read input directly using sysread()
    # or similar, and even then only if in telnet mode.
    def preprocess(string)
      # combine CR+NULL into CR
      string = string.gsub(/#{CR}#{NULL}/no, CR) if @options[&quot;Telnetmode&quot;]

      # combine EOL into &quot;\n&quot;
      string = string.gsub(/#{EOL}/no, &quot;\n&quot;) unless @options[&quot;Binmode&quot;]

      string.gsub(/#{IAC}(
                   [#{IAC}#{AO}#{AYT}#{DM}#{IP}#{NOP}]|
                   [#{DO}#{DONT}#{WILL}#{WONT}]
                     [#{OPT_BINARY}-#{OPT_NEW_ENVIRON}#{OPT_EXOPL}]|
                   #{SB}[^#{IAC}]*#{IAC}#{SE}
                 )/xno) do
        if    IAC == $1  # handle escaped IAC characters
          IAC
        elsif AYT == $1  # respond to &quot;IAC AYT&quot; (are you there)
          self.write(&quot;nobody here but us pigeons&quot; + EOL)
          ''
        elsif DO[0] == $1[0]  # respond to &quot;IAC DO x&quot;
          if OPT_BINARY[0] == $1[1]
            @telnet_option[&quot;BINARY&quot;] = true
            self.write(IAC + WILL + OPT_BINARY)
          else
            self.write(IAC + WONT + $1[1..1])
          end
          ''
        elsif DONT[0] == $1[0]  # respond to &quot;IAC DON'T x&quot; with &quot;IAC WON'T x&quot;
          self.write(IAC + WONT + $1[1..1])
          ''
        elsif WILL[0] == $1[0]  # respond to &quot;IAC WILL x&quot;
          if    OPT_BINARY[0] == $1[1]
            self.write(IAC + DO + OPT_BINARY)
          elsif OPT_ECHO[0] == $1[1]
            self.write(IAC + DO + OPT_ECHO)
          elsif OPT_SGA[0]  == $1[1]
            @telnet_option[&quot;SGA&quot;] = true
            self.write(IAC + DO + OPT_SGA)
          else
            self.write(IAC + DONT + $1[1..1])
          end
          ''
        elsif WONT[0] == $1[0]  # respond to &quot;IAC WON'T x&quot;
          if    OPT_ECHO[0] == $1[1]
            self.write(IAC + DONT + OPT_ECHO)
          elsif OPT_SGA[0]  == $1[1]
            @telnet_option[&quot;SGA&quot;] = false
            self.write(IAC + DONT + OPT_SGA)
          else
            self.write(IAC + DONT + $1[1..1])
          end
          ''
        else
          ''
        end
      end
    end # preprocess

    # Read data from the host until a certain sequence is matched.
    #
    # If a block is given, the received data will be yielded as it
    # is read in (not necessarily all in one go), or nil if EOF 
    # occurs before any data is received.  Whether a block is given
    # or not, all data read will be returned in a single string, or again 
    # nil if EOF occurs before any data is received.  Note that
    # received data includes the matched sequence we were looking for.
    #
    # +options+ can be either a regular expression or a hash of options.
    # If a regular expression, this specifies the data to wait for.
    # If a hash, this can specify the following options:
    #
    # Match:: a regular expression, specifying the data to wait for.
    # Prompt:: as for Match; used only if Match is not specified.
    # String:: as for Match, except a string that will be converted
    #          into a regular expression.  Used only if Match and
    #          Prompt are not specified.
    # Timeout:: the number of seconds to wait for data from the host
    #           before raising a TimeoutError.  If set to false, 
    #           no timeout will occur.  If not specified, the
    #           Timeout option value specified when this instance
    #           was created will be used, or, failing that, the
    #           default value of 10 seconds.
    # Waittime:: the number of seconds to wait after matching against
    #            the input data to see if more data arrives.  If more
    #            data arrives within this time, we will judge ourselves
    #            not to have matched successfully, and will continue
    #            trying to match.  If not specified, the Waittime option
    #            value specified when this instance was created will be
    #            used, or, failing that, the default value of 0 seconds,
    #            which means not to wait for more input.
    # FailEOF:: if true, when the remote end closes the connection then an
    #           EOFError will be raised. Otherwise, defaults to the old
    #           behaviour that the function will return whatever data
    #           has been received already, or nil if nothing was received.
    #           
    def waitfor(options) # :yield: recvdata
      time_out = @options[&quot;Timeout&quot;]
      waittime = @options[&quot;Waittime&quot;]
      fail_eof = @options[&quot;FailEOF&quot;]

      if options.kind_of?(Hash)
        prompt   = if options.has_key?(&quot;Match&quot;)
                     options[&quot;Match&quot;]
                   elsif options.has_key?(&quot;Prompt&quot;)
                     options[&quot;Prompt&quot;]
                   elsif options.has_key?(&quot;String&quot;)
                     Regexp.new( Regexp.quote(options[&quot;String&quot;]) )
                   end
        time_out = options[&quot;Timeout&quot;]  if options.has_key?(&quot;Timeout&quot;)
        waittime = options[&quot;Waittime&quot;] if options.has_key?(&quot;Waittime&quot;)
        fail_eof = options[&quot;FailEOF&quot;]  if options.has_key?(&quot;FailEOF&quot;)
      else
        prompt = options
      end

      if time_out == false
        time_out = nil
      end

      line = ''
      buf = ''
      rest = ''
      until(prompt === line and not IO::select([@sock], nil, nil, waittime))
        unless IO::select([@sock], nil, nil, time_out)
          raise TimeoutError, &quot;timed out while waiting for more data&quot;
        end
        begin
          c = @sock.readpartial(1024 * 1024)
          @dumplog.log_dump('&lt;', c) if @options.has_key?(&quot;Dump_log&quot;)
          if @options[&quot;Telnetmode&quot;]
            c = rest + c
            if Integer(c.rindex(/#{IAC}#{SE}/no)) &lt;
               Integer(c.rindex(/#{IAC}#{SB}/no))
              buf = preprocess(c[0 ... c.rindex(/#{IAC}#{SB}/no)])
              rest = c[c.rindex(/#{IAC}#{SB}/no) .. -1]
            elsif pt = c.rindex(/#{IAC}[^#{IAC}#{AO}#{AYT}#{DM}#{IP}#{NOP}]?\z/no) ||
                       c.rindex(/\r\z/no)
              buf = preprocess(c[0 ... pt])
              rest = c[pt .. -1]
            else
              buf = preprocess(c)
              rest = ''
            end
         else
           # Not Telnetmode.
           #
           # We cannot use preprocess() on this data, because that
           # method makes some Telnetmode-specific assumptions.
           buf = rest + c
           rest = ''
           unless @options[&quot;Binmode&quot;]
             if pt = buf.rindex(/\r\z/no)
               buf = buf[0 ... pt]
               rest = buf[pt .. -1]
             end
             buf.gsub!(/#{EOL}/no, &quot;\n&quot;)
           end
          end
          @log.print(buf) if @options.has_key?(&quot;Output_log&quot;)
          line += buf
          yield buf if block_given?
        rescue EOFError # End of file reached
          raise if fail_eof
          if line == ''
            line = nil
            yield nil if block_given?
          end
          break
        end
      end
      line
    end

    # Write +string+ to the host.
    #
    # Does not perform any conversions on +string+.  Will log +string+ to the
    # dumplog, if the Dump_log option is set.
    def write(string)
      length = string.length
      while 0 &lt; length
        IO::select(nil, [@sock])
        @dumplog.log_dump('&gt;', string[-length..-1]) if @options.has_key?(&quot;Dump_log&quot;)
        length -= @sock.syswrite(string[-length..-1])
      end
    end

    # Sends a string to the host.
    #
    # This does _not_ automatically append a newline to the string.  Embedded
    # newlines may be converted and telnet command sequences escaped 
    # depending upon the values of telnetmode, binmode, and telnet options
    # set by the host.
    def print(string)
      string = string.gsub(/#{IAC}/no, IAC + IAC) if @options[&quot;Telnetmode&quot;]

      if @options[&quot;Binmode&quot;]
        self.write(string)
      else
        if @telnet_option[&quot;BINARY&quot;] and @telnet_option[&quot;SGA&quot;]
          # IAC WILL SGA IAC DO BIN send EOL --&gt; CR
          self.write(string.gsub(/\n/n, CR))
        elsif @telnet_option[&quot;SGA&quot;]
          # IAC WILL SGA send EOL --&gt; CR+NULL
          self.write(string.gsub(/\n/n, CR + NULL))
        else
          # NONE send EOL --&gt; CR+LF
          self.write(string.gsub(/\n/n, EOL))
        end
      end
    end

    # Sends a string to the host.
    #
    # Same as #print(), but appends a newline to the string.
    def puts(string)
      self.print(string + &quot;\n&quot;)
    end

    # Send a command to the host.
    #
    # More exactly, sends a string to the host, and reads in all received
    # data until is sees the prompt or other matched sequence.
    #
    # If a block is given, the received data will be yielded to it as
    # it is read in.  Whether a block is given or not, the received data 
    # will be return as a string.  Note that the received data includes
    # the prompt and in most cases the host's echo of our command.
    #
    # +options+ is either a String, specified the string or command to
    # send to the host; or it is a hash of options.  If a hash, the
    # following options can be specified:
    #
    # String:: the command or other string to send to the host.
    # Match:: a regular expression, the sequence to look for in
    #         the received data before returning.  If not specified,
    #         the Prompt option value specified when this instance
    #         was created will be used, or, failing that, the default
    #         prompt of /[$%#&gt;] \z/n.
    # Timeout:: the seconds to wait for data from the host before raising
    #           a Timeout error.  If not specified, the Timeout option
    #           value specified when this instance was created will be
    #           used, or, failing that, the default value of 10 seconds.
    #
    # The command or other string will have the newline sequence appended
    # to it.
    def cmd(options) # :yield: recvdata
      match    = @options[&quot;Prompt&quot;]
      time_out = @options[&quot;Timeout&quot;]

      if options.kind_of?(Hash)
        string   = options[&quot;String&quot;]
        match    = options[&quot;Match&quot;]   if options.has_key?(&quot;Match&quot;)
        time_out = options[&quot;Timeout&quot;] if options.has_key?(&quot;Timeout&quot;)
      else
        string = options
      end

      self.puts(string)
      if block_given?
        waitfor({&quot;Prompt&quot; =&gt; match, &quot;Timeout&quot; =&gt; time_out}){|c| yield c }
      else
        waitfor({&quot;Prompt&quot; =&gt; match, &quot;Timeout&quot; =&gt; time_out})
      end
    end

    # Login to the host with a given username and password.
    #
    # The username and password can either be provided as two string
    # arguments in that order, or as a hash with keys &quot;Name&quot; and
    # &quot;Password&quot;.    
    #
    # This method looks for the strings &quot;login&quot; and &quot;Password&quot; from the
    # host to determine when to send the username and password.  If the
    # login sequence does not follow this pattern (for instance, you
    # are connecting to a service other than telnet), you will need
    # to handle login yourself.
    #
    # The password can be omitted, either by only
    # provided one String argument, which will be used as the username,
    # or by providing a has that has no &quot;Password&quot; key.  In this case,
    # the method will not look for the &quot;Password:&quot; prompt; if it is
    # sent, it will have to be dealt with by later calls.
    #
    # The method returns all data received during the login process from
    # the host, including the echoed username but not the password (which
    # the host should not echo).  If a block is passed in, this received
    # data is also yielded to the block as it is received.
    def login(options, password = nil) # :yield: recvdata
      login_prompt = /[Ll]ogin[: ]*\z/n
      password_prompt = /[Pp]ass(?:word|phrase)[: ]*\z/n
      if options.kind_of?(Hash)
        username = options[&quot;Name&quot;]
        password = options[&quot;Password&quot;]
	login_prompt = options[&quot;LoginPrompt&quot;] if options[&quot;LoginPrompt&quot;]
	password_prompt = options[&quot;PasswordPrompt&quot;] if options[&quot;PasswordPrompt&quot;]
      else
        username = options
      end

      if block_given?
        line = waitfor(login_prompt){|c| yield c }
        if password
          line += cmd({&quot;String&quot; =&gt; username,
                       &quot;Match&quot; =&gt; password_prompt}){|c| yield c }
          line += cmd(password){|c| yield c }
        else
          line += cmd(username){|c| yield c }
        end
      else
        line = waitfor(login_prompt)
        if password
          line += cmd({&quot;String&quot; =&gt; username,
                       &quot;Match&quot; =&gt; password_prompt})
          line += cmd(password)
        else
          line += cmd(username)
        end
      end
      line
    end

  end  # class Telnet
end  # module Net

</pre>
    </div>