  <div id="fileHeader">
    <h1>html_generator.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rdoc/generators/html_generator.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># We're responsible for generating all the HTML files
# from the object tree defined in code_objects.rb. We
# generate:
#
# [files]   an html file for each input file given. These
#           input files appear as objects of class
#           TopLevel
#
# [classes] an html file for each class or module encountered.
#           These classes are not grouped by file: if a file
#           contains four classes, we'll generate an html
#           file for the file itself, and four html files 
#           for the individual classes. 
#
# [indices] we generate three indices for files, classes,
#           and methods. These are displayed in a browser
#           like window with three index panes across the
#           top and the selected description below
#
# Method descriptions appear in whatever entity (file, class,
# or module) that contains them.
#
# We generate files in a structure below a specified subdirectory,
# normally +doc+.
#
#  opdir
#     |
#     |___ files
#     |       |__  per file summaries
#     |
#     |___ classes
#             |__ per class/module descriptions
#
# HTML is generated using the Template class.
#

require 'ftools'

require 'rdoc/options'
require 'rdoc/template'
require 'rdoc/markup/simple_markup'
require 'rdoc/markup/simple_markup/to_html'
require 'cgi'

module Generators

  # Name of sub-direcories that hold file and class/module descriptions

  FILE_DIR  = &quot;files&quot;
  CLASS_DIR = &quot;classes&quot;
  CSS_NAME  = &quot;rdoc-style.css&quot;
  

  ##
  # Build a hash of all items that can be cross-referenced.
  # This is used when we output required and included names: 
  # if the names appear in this hash, we can generate
  # an html cross reference to the appropriate description.
  # We also use this when parsing comment blocks: any decorated 
  # words matching an entry in this list are hyperlinked.

  class AllReferences
    @@refs = {}
    
    def AllReferences::reset
      @@refs = {}
    end

    def AllReferences.add(name, html_class)
      @@refs[name] = html_class
    end

    def AllReferences.[](name)
      @@refs[name]
    end

    def AllReferences.keys
      @@refs.keys
    end
  end


  ##
  # Subclass of the SM::ToHtml class that supports looking
  # up words in the AllReferences list. Those that are
  # found (like AllReferences in this comment) will
  # be hyperlinked

  class HyperlinkHtml &lt; SM::ToHtml
    # We need to record the html path of our caller so we can generate
    # correct relative paths for any hyperlinks that we find
    def initialize(from_path, context)
      super()
      @from_path = from_path

      @parent_name = context.parent_name
      @parent_name += &quot;::&quot; if @parent_name
      @context = context
    end

    # We're invoked when any text matches the CROSSREF pattern
    # (defined in MarkUp). If we fine the corresponding reference,
    # generate a hyperlink. If the name we're looking for contains
    # no punctuation, we look for it up the module/class chain. For
    # example, HyperlinkHtml is found, even without the Generators::
    # prefix, because we look for it in module Generators first.

    def handle_special_CROSSREF(special)
      name = special.text
      if name[0,1] == '#'
        lookup = name[1..-1]
        name = lookup unless Options.instance.show_hash
      else
        lookup = name
      end

      # Find class, module, or method in class or module.
      if /([A-Z]\w*)[.\#](\w+[!?=]?)/ =~ lookup
        container = $1
        method = $2
        ref = @context.find_symbol(container, method)
      elsif /([A-Za-z]\w*)[.\#](\w+(\([\.\w+\*\/\+\-\=\&lt;\&gt;]+\))?)/ =~ lookup
        container = $1
        method = $2
        ref = @context.find_symbol(container, method)
      else
        ref = @context.find_symbol(lookup)
      end

      if ref and ref.document_self
        &quot;&lt;a href=\&quot;#{ref.as_href(@from_path)}\&quot;&gt;#{name}&lt;/a&gt;&quot;
      else
        name
      end
    end


    # Generate a hyperlink for url, labeled with text. Handle the
    # special cases for img: and link: described under handle_special_HYPEDLINK
    def gen_url(url, text)
      if url =~ /([A-Za-z]+):(.*)/
        type = $1
        path = $2
      else
        type = &quot;http&quot;
        path = url
        url  = &quot;http://#{url}&quot;
      end

      if type == &quot;link&quot;
        if path[0,1] == '#'     # is this meaningful?
          url = path
        else
          url = HTMLGenerator.gen_url(@from_path, path)
        end
      end

      if (type == &quot;http&quot; || type == &quot;link&quot;) &amp;&amp; 
          url =~ /\.(gif|png|jpg|jpeg|bmp)$/

        &quot;&lt;img src=\&quot;#{url}\&quot; /&gt;&quot;
      else
        &quot;&lt;a href=\&quot;#{url}\&quot;&gt;#{text.sub(%r{^#{type}:/*}, '')}&lt;/a&gt;&quot;
      end
    end

    # And we're invoked with a potential external hyperlink mailto:
    # just gets inserted. http: links are checked to see if they
    # reference an image. If so, that image gets inserted using an
    # &lt;img&gt; tag. Otherwise a conventional &lt;a href&gt; is used.  We also
    # support a special type of hyperlink, link:, which is a reference
    # to a local file whose path is relative to the --op directory.

    def handle_special_HYPERLINK(special)
      url = special.text
      gen_url(url, url)
    end

    # HEre's a hypedlink where the label is different to the URL
    #  &lt;label&gt;[url]
    #
    
    def handle_special_TIDYLINK(special)
      text = special.text
#      unless text =~ /(\S+)\[(.*?)\]/
      unless text =~ /\{(.*?)\}\[(.*?)\]/ or text =~ /(\S+)\[(.*?)\]/ 
        return text
      end
      label = $1
      url   = $2
      gen_url(url, label)
    end

  end


  
  #####################################################################
  #
  # Handle common markup tasks for the various Html classes
  #

  module MarkUp

    # Convert a string in markup format into HTML. We keep a cached
    # SimpleMarkup object lying around after the first time we're
    # called per object.

    def markup(str, remove_para=false)
      return '' unless str
      unless defined? @markup
        @markup = SM::SimpleMarkup.new

        # class names, variable names, or instance variables
        @markup.add_special(/(
                               \w+(::\w+)*[.\#]\w+(\([\.\w+\*\/\+\-\=\&lt;\&gt;]+\))?  # A::B.meth(**) (for operator in Fortran95)
                             | \#\w+(\([.\w\*\/\+\-\=\&lt;\&gt;]+\))?  #  meth(**) (for operator in Fortran95)
                             | \b([A-Z]\w*(::\w+)*[.\#]\w+)  #    A::B.meth
                             | \b([A-Z]\w+(::\w+)*)       #    A::B..
                             | \#\w+[!?=]?                #    #meth_name 
                             | \b\w+([_\/\.]+\w+)*[!?=]?  #    meth_name
                             )/x, 
                            :CROSSREF)

        # external hyperlinks
        @markup.add_special(/((link:|https?:|mailto:|ftp:|www\.)\S+\w)/, :HYPERLINK)

        # and links of the form  &lt;text&gt;[&lt;url&gt;]
        @markup.add_special(/(((\{.*?\})|\b\S+?)\[\S+?\.\S+?\])/, :TIDYLINK)
#        @markup.add_special(/\b(\S+?\[\S+?\.\S+?\])/, :TIDYLINK)

      end
      unless defined? @html_formatter
        @html_formatter = HyperlinkHtml.new(self.path, self)
      end

      # Convert leading comment markers to spaces, but only
      # if all non-blank lines have them

      if str =~ /^(?&gt;\s*)[^\#]/
        content = str
      else
        content = str.gsub(/^\s*(#+)/)  { $1.tr('#',' ') }
      end

      res = @markup.convert(content, @html_formatter)
      if remove_para
        res.sub!(/^&lt;p&gt;/, '')
        res.sub!(/&lt;\/p&gt;$/, '')
      end
      res
    end

    # Qualify a stylesheet URL; if if +css_name+ does not begin with '/' or
    # 'http[s]://', prepend a prefix relative to +path+. Otherwise, return it
    # unmodified.

    def style_url(path, css_name=nil)
#      $stderr.puts &quot;style_url( #{path.inspect}, #{css_name.inspect} )&quot;
      css_name ||= CSS_NAME
      if %r{^(https?:/)?/} =~ css_name
        return css_name
      else
        return HTMLGenerator.gen_url(path, css_name)
      end
    end

    # Build a webcvs URL with the given 'url' argument. URLs with a '%s' in them
    # get the file's path sprintfed into them; otherwise they're just catenated
    # together.

    def cvs_url(url, full_path)
      if /%s/ =~ url
        return sprintf( url, full_path )
      else
        return url + full_path
      end
    end
  end


  #####################################################################
  #
  # A Context is built by the parser to represent a container: contexts
  # hold classes, modules, methods, require lists and include lists.
  # ClassModule and TopLevel are the context objects we process here
  # 
  class ContextUser

    include MarkUp

    attr_reader :context
    
    def initialize(context, options)
      @context = context
      @options = options
    end
      
    # convenience method to build a hyperlink
    def href(link, cls, name)
      %{&lt;a href=&quot;#{link}&quot; class=&quot;#{cls}&quot;&gt;#{name}&lt;/a&gt;} #&quot;
    end

    # return a reference to outselves to be used as an href=
    # the form depends on whether we're all in one file
    # or in multiple files

    def as_href(from_path)
      if @options.all_one_file
        &quot;#&quot; + path
      else
        HTMLGenerator.gen_url(from_path, path)
      end
    end

    # Create a list of HtmlMethod objects for each method
    # in the corresponding context object. If the @options.show_all
    # variable is set (corresponding to the &lt;tt&gt;--all&lt;/tt&gt; option,
    # we include all methods, otherwise just the public ones.

    def collect_methods
      list = @context.method_list
      unless @options.show_all
        list = list.find_all {|m| m.visibility == :public || m.visibility == :protected || m.force_documentation }
      end
      @methods = list.collect {|m| HtmlMethod.new(m, self, @options) }
    end

    # Build a summary list of all the methods in this context
    def build_method_summary_list(path_prefix=&quot;&quot;)
      collect_methods unless @methods
      meths = @methods.sort
      res = []
      meths.each do |meth|
	res &lt;&lt; {
          &quot;name&quot; =&gt; CGI.escapeHTML(meth.name),
          &quot;aref&quot; =&gt; &quot;#{path_prefix}\##{meth.aref}&quot; 
        }
      end
      res
    end


    # Build a list of aliases for which we couldn't find a
    # corresponding method
    def build_alias_summary_list(section)
      values = []
      @context.aliases.each do |al|
        next unless al.section == section
        res = {
          'old_name' =&gt; al.old_name,
          'new_name' =&gt; al.new_name,
        }
        if al.comment &amp;&amp; !al.comment.empty?
          res['desc'] = markup(al.comment, true)
        end
        values &lt;&lt; res
      end
      values
    end
    
    # Build a list of constants
    def build_constants_summary_list(section)
      values = []
      @context.constants.each do |co|
        next unless co.section == section
        res = {
          'name'  =&gt; co.name,
          'value' =&gt; CGI.escapeHTML(co.value)
        }
        res['desc'] = markup(co.comment, true) if co.comment &amp;&amp; !co.comment.empty?
        values &lt;&lt; res
      end
      values
    end
    
    def build_requires_list(context)
      potentially_referenced_list(context.requires) {|fn| [fn + &quot;.rb&quot;] }
    end

    def build_include_list(context)
      potentially_referenced_list(context.includes)
    end

    # Build a list from an array of &lt;i&gt;Htmlxxx&lt;/i&gt; items. Look up each
    # in the AllReferences hash: if we find a corresponding entry,
    # we generate a hyperlink to it, otherwise just output the name.
    # However, some names potentially need massaging. For example,
    # you may require a Ruby file without the .rb extension,
    # but the file names we know about may have it. To deal with
    # this, we pass in a block which performs the massaging,
    # returning an array of alternative names to match

    def potentially_referenced_list(array)
      res = []
      array.each do |i|
        ref = AllReferences[i.name] 
#         if !ref
#           container = @context.parent
#           while !ref &amp;&amp; container
#             name = container.name + &quot;::&quot; + i.name
#             ref = AllReferences[name] 
#             container = container.parent
#           end
#         end

        ref = @context.find_symbol(i.name)
        ref = ref.viewer if ref

        if !ref &amp;&amp; block_given?
          possibles = yield(i.name)
          while !ref and !possibles.empty?
            ref = AllReferences[possibles.shift]
          end
        end
        h_name = CGI.escapeHTML(i.name)
        if ref and ref.document_self
          path = url(ref.path)
          res &lt;&lt; { &quot;name&quot; =&gt; h_name, &quot;aref&quot; =&gt; path }
        else
          res &lt;&lt; { &quot;name&quot; =&gt; h_name }
        end
      end
      res
    end

    # Build an array of arrays of method details. The outer array has up
    # to six entries, public, private, and protected for both class
    # methods, the other for instance methods. The inner arrays contain
    # a hash for each method

    def build_method_detail_list(section)
      outer = []

      methods = @methods.sort
      for singleton in [true, false]
        for vis in [ :public, :protected, :private ] 
          res = []
          methods.each do |m|
            if m.section == section and
                m.document_self and 
                m.visibility == vis and 
                m.singleton == singleton
              row = {}
              if m.call_seq
                row[&quot;callseq&quot;] = m.call_seq.gsub(/-&gt;/, '&amp;rarr;')
              else
                row[&quot;name&quot;]        = CGI.escapeHTML(m.name)
                row[&quot;params&quot;]      = m.params
              end
              desc = m.description.strip
              row[&quot;m_desc&quot;]      = desc unless desc.empty?
              row[&quot;aref&quot;]        = m.aref
              row[&quot;visibility&quot;]  = m.visibility.to_s

              alias_names = []
              m.aliases.each do |other|
                if other.viewer   # won't be if the alias is private
                  alias_names &lt;&lt; {
                    'name' =&gt; other.name,
                    'aref'  =&gt; other.viewer.as_href(path)
                  } 
                end
              end
              unless alias_names.empty?
                row[&quot;aka&quot;] = alias_names
              end

              if @options.inline_source
                code = m.source_code
                row[&quot;sourcecode&quot;] = code if code
              else
                code = m.src_url
                if code
                  row[&quot;codeurl&quot;] = code
                  row[&quot;imgurl&quot;]  = m.img_url
                end
              end
              res &lt;&lt; row
            end
          end
          if res.size &gt; 0 
            outer &lt;&lt; {
              &quot;type&quot;    =&gt; vis.to_s.capitalize,
              &quot;category&quot;    =&gt; singleton ? &quot;Class&quot; : &quot;Instance&quot;,
              &quot;methods&quot; =&gt; res
            }
          end
        end
      end
      outer
    end

    # Build the structured list of classes and modules contained
    # in this context. 

    def build_class_list(level, from, section, infile=nil)
      res = &quot;&quot;
      prefix = &quot;&amp;nbsp;&amp;nbsp;::&quot; * level;

      from.modules.sort.each do |mod|
        next unless mod.section == section
        next if infile &amp;&amp; !mod.defined_in?(infile)
        if mod.document_self
          res &lt;&lt; 
            prefix &lt;&lt;
            &quot;Module &quot; &lt;&lt;
            href(url(mod.viewer.path), &quot;link&quot;, mod.full_name) &lt;&lt;
            &quot;&lt;br /&gt;\n&quot; &lt;&lt;
            build_class_list(level + 1, mod, section, infile)
        end
      end

      from.classes.sort.each do |cls|
        next unless cls.section == section
        next if infile &amp;&amp; !cls.defined_in?(infile)
        if cls.document_self
          res      &lt;&lt;
            prefix &lt;&lt; 
            &quot;Class &quot; &lt;&lt;
            href(url(cls.viewer.path), &quot;link&quot;, cls.full_name) &lt;&lt;
            &quot;&lt;br /&gt;\n&quot; &lt;&lt;
            build_class_list(level + 1, cls, section, infile)
        end
      end

      res
    end
    
    def url(target)
      HTMLGenerator.gen_url(path, target)
    end

    def aref_to(target)
      if @options.all_one_file
        &quot;#&quot; + target
      else
        url(target)
      end
    end

    def document_self
      @context.document_self
    end

    def diagram_reference(diagram)
      res = diagram.gsub(/((?:src|href)=&quot;)(.*?)&quot;/) {
        $1 + url($2) + '&quot;'
      }
      res
    end


    # Find a symbol in ourselves or our parent
    def find_symbol(symbol, method=nil)
      res = @context.find_symbol(symbol, method)
      if res
        res = res.viewer
      end
      res
    end

    # create table of contents if we contain sections
      
    def add_table_of_sections
      toc = []
      @context.sections.each do |section|
        if section.title
          toc &lt;&lt; {
            'secname' =&gt; section.title,
            'href'    =&gt; section.sequence
          }
        end
      end
      
      @values['toc'] = toc unless toc.empty?
    end


  end

  #####################################################################
  #
  # Wrap a ClassModule context

  class HtmlClass &lt; ContextUser

    attr_reader :path

    def initialize(context, html_file, prefix, options)
      super(context, options)

      @html_file = html_file
      @is_module = context.is_module?
      @values    = {}

      context.viewer = self

      if options.all_one_file
        @path = context.full_name
      else
        @path = http_url(context.full_name, prefix)
      end

      collect_methods

      AllReferences.add(name, self)
    end

    # return the relative file name to store this class in,
    # which is also its url
    def http_url(full_name, prefix)
      path = full_name.dup
      if path['&lt;&lt;']
        path.gsub!(/&lt;&lt;\s*(\w*)/) { &quot;from-#$1&quot; }
      end
      File.join(prefix, path.split(&quot;::&quot;)) + &quot;.html&quot;
    end


    def name
      @context.full_name
    end

    def parent_name
      @context.parent.full_name
    end

    def index_name
      name
    end

    def write_on(f)
      value_hash
      template = TemplatePage.new(RDoc::Page::BODY,
                                      RDoc::Page::CLASS_PAGE,
                                      RDoc::Page::METHOD_LIST)
      template.write_html_on(f, @values)
    end

    def value_hash
      class_attribute_values
      add_table_of_sections

      @values[&quot;charset&quot;] = @options.charset
      @values[&quot;style_url&quot;] = style_url(path, @options.css)

      d = markup(@context.comment)
      @values[&quot;description&quot;] = d unless d.empty?

      ml = build_method_summary_list
      @values[&quot;methods&quot;] = ml unless ml.empty?

      il = build_include_list(@context)
      @values[&quot;includes&quot;] = il unless il.empty?

      @values[&quot;sections&quot;] = @context.sections.map do |section|

        secdata = {
          &quot;sectitle&quot; =&gt; section.title,
          &quot;secsequence&quot; =&gt; section.sequence,
          &quot;seccomment&quot; =&gt; markup(section.comment)
        }

        al = build_alias_summary_list(section)
        secdata[&quot;aliases&quot;] = al unless al.empty?
        
        co = build_constants_summary_list(section)
        secdata[&quot;constants&quot;] = co unless co.empty?
        
        al = build_attribute_list(section)
        secdata[&quot;attributes&quot;] = al unless al.empty?
        
        cl = build_class_list(0, @context, section)
        secdata[&quot;classlist&quot;] = cl unless cl.empty?
        
        mdl = build_method_detail_list(section)
        secdata[&quot;method_list&quot;] = mdl unless mdl.empty?

        secdata
      end

      @values
    end

    def build_attribute_list(section)
      atts = @context.attributes.sort
      res = []
      atts.each do |att|
        next unless att.section == section
        if att.visibility == :public || att.visibility == :protected || @options.show_all
          entry = {
            &quot;name&quot;   =&gt; CGI.escapeHTML(att.name), 
            &quot;rw&quot;     =&gt; att.rw, 
            &quot;a_desc&quot; =&gt; markup(att.comment, true)
          }
          unless att.visibility == :public || att.visibility == :protected
            entry[&quot;rw&quot;] &lt;&lt; &quot;-&quot;
          end
          res &lt;&lt; entry
        end
      end
      res
    end

    def class_attribute_values
      h_name = CGI.escapeHTML(name)

      @values[&quot;classmod&quot;]  = @is_module ? &quot;Module&quot; : &quot;Class&quot;
      @values[&quot;title&quot;]     = &quot;#{@values['classmod']}: #{h_name}&quot;

      c = @context
      c = c.parent while c and !c.diagram
      if c &amp;&amp; c.diagram
        @values[&quot;diagram&quot;] = diagram_reference(c.diagram)
      end

      @values[&quot;full_name&quot;] = h_name

      parent_class = @context.superclass

      if parent_class
	@values[&quot;parent&quot;] = CGI.escapeHTML(parent_class)

	if parent_name
	  lookup = parent_name + &quot;::&quot; + parent_class
	else
	  lookup = parent_class
	end

	parent_url = AllReferences[lookup] || AllReferences[parent_class]

	if parent_url and parent_url.document_self
	  @values[&quot;par_url&quot;] = aref_to(parent_url.path)
	end
      end

      files = []
      @context.in_files.each do |f|
        res = {}
        full_path = CGI.escapeHTML(f.file_absolute_name)

        res[&quot;full_path&quot;]     = full_path
        res[&quot;full_path_url&quot;] = aref_to(f.viewer.path) if f.document_self

        if @options.webcvs
          res[&quot;cvsurl&quot;] = cvs_url( @options.webcvs, full_path )
        end

        files &lt;&lt; res
      end

      @values['infiles'] = files
    end

    def &lt;=&gt;(other)
      self.name &lt;=&gt; other.name
    end

  end

  #####################################################################
  #
  # Handles the mapping of a file's information to HTML. In reality,
  # a file corresponds to a +TopLevel+ object, containing modules,
  # classes, and top-level methods. In theory it _could_ contain
  # attributes and aliases, but we ignore these for now.

  class HtmlFile &lt; ContextUser

    attr_reader :path
    attr_reader :name

    def initialize(context, options, file_dir)
      super(context, options)

      @values = {}

      if options.all_one_file
        @path = filename_to_label
      else
        @path = http_url(file_dir)
      end

      @name = @context.file_relative_name

      collect_methods
      AllReferences.add(name, self)
      context.viewer = self
    end

    def http_url(file_dir)
      File.join(file_dir, @context.file_relative_name.tr('.', '_')) +
        &quot;.html&quot;
    end

    def filename_to_label
      @context.file_relative_name.gsub(/%|\/|\?|\#/) {|s| '%' + (&quot;%x&quot; % s[0]) }
    end

    def index_name
      name
    end

    def parent_name
      nil
    end

    def value_hash
      file_attribute_values
      add_table_of_sections

      @values[&quot;charset&quot;]   = @options.charset
      @values[&quot;href&quot;]      = path
      @values[&quot;style_url&quot;] = style_url(path, @options.css)

      if @context.comment
        d = markup(@context.comment)
        @values[&quot;description&quot;] = d if d.size &gt; 0
      end

      ml = build_method_summary_list
      @values[&quot;methods&quot;] = ml unless ml.empty?

      il = build_include_list(@context)
      @values[&quot;includes&quot;] = il unless il.empty?

      rl = build_requires_list(@context)
      @values[&quot;requires&quot;] = rl unless rl.empty?

      if @options.promiscuous
        file_context = nil
      else
        file_context = @context
      end


      @values[&quot;sections&quot;] = @context.sections.map do |section|

        secdata = {
          &quot;sectitle&quot; =&gt; section.title,
          &quot;secsequence&quot; =&gt; section.sequence,
          &quot;seccomment&quot; =&gt; markup(section.comment)
        }

        cl = build_class_list(0, @context, section, file_context)
        @values[&quot;classlist&quot;] = cl unless cl.empty?

        mdl = build_method_detail_list(section)
        secdata[&quot;method_list&quot;] = mdl unless mdl.empty?

        al = build_alias_summary_list(section)
        secdata[&quot;aliases&quot;] = al unless al.empty?
        
        co = build_constants_summary_list(section)
        @values[&quot;constants&quot;] = co unless co.empty?

        secdata
      end
      
      @values
    end
    
    def write_on(f)
      value_hash
      template = TemplatePage.new(RDoc::Page::BODY,
                                  RDoc::Page::FILE_PAGE,
                                  RDoc::Page::METHOD_LIST)
      template.write_html_on(f, @values)
    end

    def file_attribute_values
      full_path = @context.file_absolute_name
      short_name = File.basename(full_path)
      
      @values[&quot;title&quot;] = CGI.escapeHTML(&quot;File: #{short_name}&quot;)

      if @context.diagram
        @values[&quot;diagram&quot;] = diagram_reference(@context.diagram)
      end

      @values[&quot;short_name&quot;]   = CGI.escapeHTML(short_name)
      @values[&quot;full_path&quot;]    = CGI.escapeHTML(full_path)
      @values[&quot;dtm_modified&quot;] = @context.file_stat.mtime.to_s

      if @options.webcvs
        @values[&quot;cvsurl&quot;] = cvs_url( @options.webcvs, @values[&quot;full_path&quot;] )
      end
    end

    def &lt;=&gt;(other)
      self.name &lt;=&gt; other.name
    end
  end

  #####################################################################

  class HtmlMethod
    include MarkUp

    attr_reader :context
    attr_reader :src_url
    attr_reader :img_url
    attr_reader :source_code

    @@seq = &quot;M000000&quot;

    @@all_methods = []

    def HtmlMethod::reset
      @@all_methods = []
    end

    def initialize(context, html_class, options)
      @context    = context
      @html_class = html_class
      @options    = options
      @@seq       = @@seq.succ
      @seq        = @@seq
      @@all_methods &lt;&lt; self

      context.viewer = self

      if (ts = @context.token_stream)
        @source_code = markup_code(ts)
        unless @options.inline_source
          @src_url = create_source_code_file(@source_code)
          @img_url = HTMLGenerator.gen_url(path, 'source.png')
        end
      end

      AllReferences.add(name, self)
    end
    
    # return a reference to outselves to be used as an href=
    # the form depends on whether we're all in one file
    # or in multiple files

    def as_href(from_path)
      if @options.all_one_file
        &quot;#&quot; + path
      else
        HTMLGenerator.gen_url(from_path, path)
      end
    end

    def name
      @context.name
    end

    def section
      @context.section
    end

    def index_name
      &quot;#{@context.name} (#{@html_class.name})&quot;
    end

    def parent_name
      if @context.parent.parent
        @context.parent.parent.full_name
      else
        nil
      end
    end

    def aref
      @seq
    end

    def path
      if @options.all_one_file
	aref
      else
	@html_class.path + &quot;#&quot; + aref
      end
    end

    def description
      markup(@context.comment)
    end

    def visibility
      @context.visibility
    end

    def singleton
      @context.singleton
    end

    def call_seq
      cs = @context.call_seq
      if cs
        cs.gsub(/\n/, &quot;&lt;br /&gt;\n&quot;)
      else
        nil
      end
    end

    def params
      # params coming from a call-seq in 'C' will start with the
      # method name
      p = @context.params
      if p !~ /^\w/
        p = @context.params.gsub(/\s*\#.*/, '')
        p = p.tr(&quot;\n&quot;, &quot; &quot;).squeeze(&quot; &quot;)
        p = &quot;(&quot; + p + &quot;)&quot; unless p[0] == ?(
        
        if (block = @context.block_params)
         # If this method has explicit block parameters, remove any
         # explicit &amp;block

         p.sub!(/,?\s*&amp;\w+/, '')

          block.gsub!(/\s*\#.*/, '')
          block = block.tr(&quot;\n&quot;, &quot; &quot;).squeeze(&quot; &quot;)
          if block[0] == ?(
            block.sub!(/^\(/, '').sub!(/\)/, '')
          end
          p &lt;&lt; &quot; {|#{block.strip}| ...}&quot;
        end
      end
      CGI.escapeHTML(p)
    end
    
    def create_source_code_file(code_body)
      meth_path = @html_class.path.sub(/\.html$/, '.src')
      File.makedirs(meth_path)
      file_path = File.join(meth_path, @seq) + &quot;.html&quot;

      template = TemplatePage.new(RDoc::Page::SRC_PAGE)
      File.open(file_path, &quot;w&quot;) do |f|
        values = {
          'title'     =&gt; CGI.escapeHTML(index_name),
          'code'      =&gt; code_body,
          'style_url' =&gt; style_url(file_path, @options.css),
          'charset'   =&gt; @options.charset
        }
        template.write_html_on(f, values)
      end
      HTMLGenerator.gen_url(path, file_path)
    end

    def HtmlMethod.all_methods
      @@all_methods
    end

    def &lt;=&gt;(other)
      @context &lt;=&gt; other.context
    end

    ##
    # Given a sequence of source tokens, mark up the source code
    # to make it look purty.


    def markup_code(tokens)
      src = &quot;&quot;
      tokens.each do |t|
        next unless t
        #    p t.class
#        style = STYLE_MAP[t.class]
        style = case t
                when RubyToken::TkCONSTANT then &quot;ruby-constant&quot;
                when RubyToken::TkKW       then &quot;ruby-keyword kw&quot;
                when RubyToken::TkIVAR     then &quot;ruby-ivar&quot;
                when RubyToken::TkOp       then &quot;ruby-operator&quot;
                when RubyToken::TkId       then &quot;ruby-identifier&quot;
                when RubyToken::TkNode     then &quot;ruby-node&quot;
                when RubyToken::TkCOMMENT  then &quot;ruby-comment cmt&quot;
                when RubyToken::TkREGEXP   then &quot;ruby-regexp re&quot;
                when RubyToken::TkSTRING   then &quot;ruby-value str&quot;
                when RubyToken::TkVal      then &quot;ruby-value&quot;
                else
                    nil
                end

        text = CGI.escapeHTML(t.text)

        if style
          src &lt;&lt; &quot;&lt;span class=\&quot;#{style}\&quot;&gt;#{text}&lt;/span&gt;&quot;
        else
          src &lt;&lt; text
        end
      end

      add_line_numbers(src) if Options.instance.include_line_numbers
      src
    end

    # we rely on the fact that the first line of a source code
    # listing has 
    #    # File xxxxx, line dddd

    def add_line_numbers(src)
      if src =~ /\A.*, line (\d+)/
        first = $1.to_i - 1
        last  = first + src.count(&quot;\n&quot;)
        size = last.to_s.length
        real_fmt = &quot;%#{size}d: &quot;
        fmt = &quot; &quot; * (size+2)
        src.gsub!(/^/) do
          res = sprintf(fmt, first) 
          first += 1
          fmt = real_fmt
          res
        end
      end
    end

    def document_self
      @context.document_self
    end

    def aliases
      @context.aliases
    end

    def find_symbol(symbol, method=nil)
      res = @context.parent.find_symbol(symbol, method)
      if res
        res = res.viewer
      end
      res
    end
  end

  #####################################################################

  class HTMLGenerator

    include MarkUp

    ##
    # convert a target url to one that is relative to a given
    # path
    
    def HTMLGenerator.gen_url(path, target)
      from          = File.dirname(path)
      to, to_file   = File.split(target)
      
      from = from.split(&quot;/&quot;)
      to   = to.split(&quot;/&quot;)
      
      while from.size &gt; 0 and to.size &gt; 0 and from[0] == to[0]
        from.shift
        to.shift
      end
      
      from.fill(&quot;..&quot;)
      from.concat(to)
      from &lt;&lt; to_file
      File.join(*from)
    end

    # Generators may need to return specific subclasses depending
    # on the options they are passed. Because of this
    # we create them using a factory

    def HTMLGenerator.for(options)
      AllReferences::reset
      HtmlMethod::reset

      if options.all_one_file
        HTMLGeneratorInOne.new(options)
      else
        HTMLGenerator.new(options)
      end
    end

    class &lt;&lt;self
      protected :new
    end

    # Set up a new HTML generator. Basically all we do here is load
    # up the correct output temlate

    def initialize(options) #:not-new:
      @options    = options
      load_html_template
    end


    ##
    # Build the initial indices and output objects
    # based on an array of TopLevel objects containing
    # the extracted information. 

    def generate(toplevels)
      @toplevels  = toplevels
      @files      = []
      @classes    = []

      write_style_sheet
      gen_sub_directories()
      build_indices
      generate_html
    end

    private

    ##
    # Load up the HTML template specified in the options.
    # If the template name contains a slash, use it literally
    #
    def load_html_template
      template = @options.template
      unless template =~ %r{/|\\}
        template = File.join(&quot;rdoc/generators/template&quot;,
                             @options.generator.key, template)
      end
      require template
      extend RDoc::Page
    rescue LoadError
      $stderr.puts &quot;Could not find HTML template '#{template}'&quot;
      exit 99
    end

    ##
    # Write out the style sheet used by the main frames
    #
    
    def write_style_sheet
      template = TemplatePage.new(RDoc::Page::STYLE)
      unless @options.css
        File.open(CSS_NAME, &quot;w&quot;) do |f|
          values = { &quot;fonts&quot; =&gt; RDoc::Page::FONTS }
          template.write_html_on(f, values)
        end
      end
    end

    ##
    # See the comments at the top for a description of the
    # directory structure

    def gen_sub_directories
      File.makedirs(FILE_DIR, CLASS_DIR)
    rescue 
      $stderr.puts $!.message
      exit 1
    end

    ##
    # Generate:
    #
    # * a list of HtmlFile objects for each TopLevel object.
    # * a list of HtmlClass objects for each first level
    #   class or module in the TopLevel objects
    # * a complete list of all hyperlinkable terms (file,
    #   class, module, and method names)

    def build_indices

      @toplevels.each do |toplevel|
        @files &lt;&lt; HtmlFile.new(toplevel, @options, FILE_DIR)
      end

      RDoc::TopLevel.all_classes_and_modules.each do |cls|
        build_class_list(cls, @files[0], CLASS_DIR)
      end
    end

    def build_class_list(from, html_file, class_dir)
      @classes &lt;&lt; HtmlClass.new(from, html_file, class_dir, @options)
      from.each_classmodule do |mod|
        build_class_list(mod, html_file, class_dir)
      end
    end

    ##
    # Generate all the HTML
    #
    def generate_html
      # the individual descriptions for files and classes
      gen_into(@files)
      gen_into(@classes)
      # and the index files
      gen_file_index
      gen_class_index
      gen_method_index
      gen_main_index
      
      # this method is defined in the template file
      write_extra_pages if defined? write_extra_pages
    end

    def gen_into(list)
      list.each do |item|
        if item.document_self
          op_file = item.path
          File.makedirs(File.dirname(op_file))
          File.open(op_file, &quot;w&quot;) { |file| item.write_on(file) }
        end
      end

    end

    def gen_file_index
      gen_an_index(@files, 'Files', 
                   RDoc::Page::FILE_INDEX, 
                   &quot;fr_file_index.html&quot;)
    end

    def gen_class_index
      gen_an_index(@classes, 'Classes',
                   RDoc::Page::CLASS_INDEX,
                   &quot;fr_class_index.html&quot;)
    end

    def gen_method_index
      gen_an_index(HtmlMethod.all_methods, 'Methods', 
                   RDoc::Page::METHOD_INDEX,
                   &quot;fr_method_index.html&quot;)
    end

    
    def gen_an_index(collection, title, template, filename)
      template = TemplatePage.new(RDoc::Page::FR_INDEX_BODY, template)
      res = []
      collection.sort.each do |f|
        if f.document_self
          res &lt;&lt; { &quot;href&quot; =&gt; f.path, &quot;name&quot; =&gt; f.index_name }
        end
      end

      values = {
        &quot;entries&quot;    =&gt; res,
        'list_title' =&gt; CGI.escapeHTML(title),
        'index_url'  =&gt; main_url,
        'charset'    =&gt; @options.charset,
        'style_url'  =&gt; style_url('', @options.css),
      }

      File.open(filename, &quot;w&quot;) do |f|
        template.write_html_on(f, values)
      end
    end

    # The main index page is mostly a template frameset, but includes
    # the initial page. If the &lt;tt&gt;--main&lt;/tt&gt; option was given,
    # we use this as our main page, otherwise we use the
    # first file specified on the command line.

    def gen_main_index
      template = TemplatePage.new(RDoc::Page::INDEX)
      File.open(&quot;index.html&quot;, &quot;w&quot;) do |f|
        values = {
          &quot;initial_page&quot; =&gt; main_url,
          'title'        =&gt; CGI.escapeHTML(@options.title),
          'charset'      =&gt; @options.charset
        }
        if @options.inline_source
          values['inline_source'] = true
        end
        template.write_html_on(f, values)
      end
    end

    # return the url of the main page
    def main_url
      main_page = @options.main_page
      ref = nil
      if main_page
        ref = AllReferences[main_page]
        if ref
          ref = ref.path
        else
          $stderr.puts &quot;Could not find main page #{main_page}&quot;
        end
      end

      unless ref
        for file in @files
          if file.document_self
            ref = file.path 
            break
          end
        end
      end

      unless ref
        $stderr.puts &quot;Couldn't find anything to document&quot;
        $stderr.puts &quot;Perhaps you've used :stopdoc: in all classes&quot;
        exit(1)
      end

      ref
    end


  end


  ######################################################################


  class HTMLGeneratorInOne &lt; HTMLGenerator

    def initialize(*args)
      super
    end

    ##
    # Build the initial indices and output objects
    # based on an array of TopLevel objects containing
    # the extracted information. 

    def generate(info)
      @toplevels  = info
      @files      = []
      @classes    = []
      @hyperlinks = {}

      build_indices
      generate_xml
    end


    ##
    # Generate:
    #
    # * a list of HtmlFile objects for each TopLevel object.
    # * a list of HtmlClass objects for each first level
    #   class or module in the TopLevel objects
    # * a complete list of all hyperlinkable terms (file,
    #   class, module, and method names)

    def build_indices

      @toplevels.each do |toplevel|
        @files &lt;&lt; HtmlFile.new(toplevel, @options, FILE_DIR)
      end

      RDoc::TopLevel.all_classes_and_modules.each do |cls|
        build_class_list(cls, @files[0], CLASS_DIR)
      end
    end

    def build_class_list(from, html_file, class_dir)
      @classes &lt;&lt; HtmlClass.new(from, html_file, class_dir, @options)
      from.each_classmodule do |mod|
        build_class_list(mod, html_file, class_dir)
      end
    end

    ##
    # Generate all the HTML. For the one-file case, we generate
    # all the information in to one big hash
    #
    def generate_xml
      values = { 
        'charset' =&gt; @options.charset,
        'files'   =&gt; gen_into(@files),
        'classes' =&gt; gen_into(@classes),
        'title'        =&gt; CGI.escapeHTML(@options.title),
      }
      
      # this method is defined in the template file
      write_extra_pages if defined? write_extra_pages

      template = TemplatePage.new(RDoc::Page::ONE_PAGE)

      if @options.op_name
        opfile = File.open(@options.op_name, &quot;w&quot;)
      else
        opfile = $stdout
      end
      template.write_html_on(opfile, values)
    end

    def gen_into(list)
      res = []
      list.each do |item|
        res &lt;&lt; item.value_hash
      end
      res
    end

    def gen_file_index
      gen_an_index(@files, 'Files')
    end

    def gen_class_index
      gen_an_index(@classes, 'Classes')
    end

    def gen_method_index
      gen_an_index(HtmlMethod.all_methods, 'Methods')
    end

    
    def gen_an_index(collection, title)
      res = []
      collection.sort.each do |f|
        if f.document_self
          res &lt;&lt; { &quot;href&quot; =&gt; f.path, &quot;name&quot; =&gt; f.index_name }
        end
      end

      return {
        &quot;entries&quot; =&gt; res,
        'list_title' =&gt; title,
        'index_url'  =&gt; main_url,
      }
    end

  end
end
</pre>
    </div>