  <div id="fileHeader">
    <h1>parse_f95.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rdoc/parsers/parse_f95.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#= parse_f95.rb - Fortran95 Parser
#
#== Overview
#
#&quot;parse_f95.rb&quot; parses Fortran95 files with suffixes &quot;f90&quot;, &quot;F90&quot;, &quot;f95&quot;
#and &quot;F95&quot;. Fortran95 files are expected to be conformed to Fortran95
#standards.
#
#== Rules
#
#Fundamental rules are same as that of the Ruby parser.
#But comment markers are '!' not '#'.
#
#=== Correspondence between RDoc documentation and Fortran95 programs
#
#&quot;parse_f95.rb&quot; parses main programs, modules, subroutines, functions,
#derived-types, public variables, public constants,
#defined operators and defined assignments.
#These components are described in items of RDoc documentation, as follows.
#
#Files :: Files (same as Ruby)
#Classes :: Modules
#Methods :: Subroutines, functions, variables, constants, derived-types, defined operators, defined assignments
#Required files :: Files in which imported modules, external subroutines and external functions are defined.
#Included Modules :: List of imported modules
#Attributes :: List of derived-types, List of imported modules all of whose components are published again
#
#Components listed in 'Methods' (subroutines, functions, ...)
#defined in modules are described in the item of 'Classes'.
#On the other hand, components defined in main programs or
#as external procedures are described in the item of 'Files'.
#
#=== Components parsed by default
#
#By default, documentation on public components (subroutines, functions, 
#variables, constants, derived-types, defined operators, 
#defined assignments) are generated. 
#With &quot;--all&quot; option, documentation on all components
#are generated (almost same as the Ruby parser).
#
#=== Information parsed automatically
#
#The following information is automatically parsed.
#
#* Types of arguments
#* Types of variables and constants
#* Types of variables in the derived types, and initial values
#* NAMELISTs and types of variables in them, and initial values
#
#Aliases by interface statement are described in the item of 'Methods'.
#
#Components which are imported from other modules and published again 
#are described in the item of 'Methods'.
#
#=== Format of comment blocks
#
#Comment blocks should be written as follows.
#Comment blocks are considered to be ended when the line without '!'
#appears.
#The indentation is not necessary.
#
#     ! (Top of file)
#     !
#     ! Comment blocks for the files.
#     !
#     !--
#     ! The comment described in the part enclosed by
#     ! &quot;!--&quot; and &quot;!++&quot; is ignored.
#     !++
#     !
#     module hogehoge
#       !
#       ! Comment blocks for the modules (or the programs).
#       !
#
#       private
#
#       logical            :: a     ! a private variable
#       real, public       :: b     ! a public variable
#       integer, parameter :: c = 0 ! a public constant
#
#       public :: c
#       public :: MULTI_ARRAY
#       public :: hoge, foo
#
#       type MULTI_ARRAY
#         !
#         ! Comment blocks for the derived-types.
#         !
#         real, pointer :: var(:) =&gt;null() ! Comments block for the variables.
#         integer       :: num = 0
#       end type MULTI_ARRAY
#
#     contains
#
#       subroutine hoge( in,   &amp;   ! Comment blocks between continuation lines are ignored.
#           &amp;            out )
#         !
#         ! Comment blocks for the subroutines or functions
#         !
#         character(*),intent(in):: in ! Comment blocks for the arguments.
#         character(*),intent(out),allocatable,target  :: in
#                                      ! Comment blocks can be
#                                      ! written under Fortran statements.
#
#         character(32) :: file ! This comment parsed as a variable in below NAMELIST.
#         integer       :: id
#
#         namelist /varinfo_nml/ file, id
#                 !
#                 ! Comment blocks for the NAMELISTs.
#                 ! Information about variables are described above.
#                 !
#
#       ....
#
#       end subroutine hoge
#
#       integer function foo( in )
#         !
#         ! This part is considered as comment block.
#
#         ! Comment blocks under blank lines are ignored.
#         !
#         integer, intent(in):: inA ! This part is considered as comment block.
#
#                                   ! This part is ignored.
#
#       end function foo
#
#       subroutine hide( in,   &amp;
#         &amp;              out )      !:nodoc:
#         !
#         ! If &quot;!:nodoc:&quot; is described at end-of-line in subroutine
#         ! statement as above, the subroutine is ignored.
#         ! This assignment can be used to modules, subroutines,
#         ! functions, variables, constants, derived-types,
#         ! defined operators, defined assignments,
#         ! list of imported modules (&quot;use&quot; statement).
#         !
#
#       ....
#
#       end subroutine hide
#
#     end module hogehoge
#


require &quot;rdoc/code_objects&quot;

module RDoc

  class Token

    NO_TEXT = &quot;??&quot;.freeze

    def initialize(line_no, char_no)
      @line_no = line_no
      @char_no = char_no
      @text    = NO_TEXT
    end
    # Because we're used in contexts that expect to return a token,
    # we set the text string and then return ourselves
    def set_text(text)
      @text = text
      self
    end

    attr_reader :line_no, :char_no, :text

  end

  # See rdoc/parsers/parse_f95.rb

  class Fortran95parser

    extend ParserFactory
    parse_files_matching(/\.((f|F)9(0|5)|F)$/)

    @@external_aliases = []
    @@public_methods   = []

    # &quot;false&quot;:: Comments are below source code
    # &quot;true&quot; :: Comments are upper source code
    COMMENTS_ARE_UPPER  = false

    # Internal alias message
    INTERNAL_ALIAS_MES = &quot;Alias for&quot;

    # External alias message
    EXTERNAL_ALIAS_MES = &quot;The entity is&quot;

    # prepare to parse a Fortran 95 file
    def initialize(top_level, file_name, body, options, stats)
      @body = body
      @stats = stats
      @file_name  = file_name
      @options = options
      @top_level = top_level
      @progress = $stderr unless options.quiet
    end

    # define code constructs
    def scan

      # remove private comment
      remaining_code = remove_private_comments(@body)

      # continuation lines are united to one line
      remaining_code = united_to_one_line(remaining_code)

      # semicolons are replaced to line feed
      remaining_code = semicolon_to_linefeed(remaining_code)

      # collect comment for file entity
      whole_comment, remaining_code = collect_first_comment(remaining_code)
      @top_level.comment = whole_comment

      # String &quot;remaining_code&quot; is converted to Array &quot;remaining_lines&quot;
      remaining_lines = remaining_code.split(&quot;\n&quot;)

      # &quot;module&quot; or &quot;program&quot; parts are parsed (new)
      #
      level_depth = 0
      block_searching_flag = nil
      block_searching_lines = []
      pre_comment = []
      module_program_trailing = &quot;&quot;
      module_program_name = &quot;&quot;
      other_block_level_depth = 0
      other_block_searching_flag = nil
      remaining_lines.collect!{|line|
        if !block_searching_flag &amp;&amp; !other_block_searching_flag
          if line =~ /^\s*?module\s+(\w+)\s*?(!.*?)?$/i
            block_searching_flag = :module
            block_searching_lines &lt;&lt; line
            module_program_name = $1
            module_program_trailing = find_comments($2)
            next false
          elsif line =~ /^\s*?program\s+(\w+)\s*?(!.*?)?$/i ||
                 line =~ /^\s*?\w/ &amp;&amp; !block_start?(line)
            block_searching_flag = :program
            block_searching_lines &lt;&lt; line
            module_program_name = $1 || &quot;&quot;
            module_program_trailing = find_comments($2)
            next false

          elsif block_start?(line)
            other_block_searching_flag = true
            next line

          elsif line =~ /^\s*?!\s?(.*)/
            pre_comment &lt;&lt; line
            next line
          else
            pre_comment = []
            next line
          end
        elsif other_block_searching_flag
          other_block_level_depth += 1 if block_start?(line)
          other_block_level_depth -= 1 if block_end?(line)
          if other_block_level_depth &lt; 0
            other_block_level_depth = 0
            other_block_searching_flag = nil
          end
          next line
        end

        block_searching_lines &lt;&lt; line
        level_depth += 1 if block_start?(line)
        level_depth -= 1 if block_end?(line)
        if level_depth &gt;= 0
          next false
        end

        # &quot;module_program_code&quot; is formatted.
        # &quot;:nodoc:&quot; flag is checked.
        #
        module_program_code = block_searching_lines.join(&quot;\n&quot;)
        module_program_code = remove_empty_head_lines(module_program_code)
        if module_program_trailing =~ /^:nodoc:/
          # next loop to search next block
          level_depth = 0
          block_searching_flag = false
          block_searching_lines = []
          pre_comment = []
          next false
        end

        # NormalClass is created, and added to @top_level
        #
        if block_searching_flag == :module
          module_name = module_program_name
          module_code = module_program_code
          module_trailing = module_program_trailing
          progress &quot;m&quot;
          @stats.num_modules += 1
          f9x_module = @top_level.add_module NormalClass, module_name
          f9x_module.record_location @top_level

          f9x_comment = COMMENTS_ARE_UPPER ? 
            find_comments(pre_comment.join(&quot;\n&quot;))  + &quot;\n&quot; + module_trailing :
              module_trailing + &quot;\n&quot; + find_comments(module_code.sub(/^.*$\n/i, ''))
          f9x_module.comment = f9x_comment
          parse_program_or_module(f9x_module, module_code)

          TopLevel.all_files.each do |name, toplevel|
            if toplevel.include_includes?(module_name, @options.ignore_case)
              if !toplevel.include_requires?(@file_name, @options.ignore_case)
                toplevel.add_require(Require.new(@file_name, &quot;&quot;))
              end
            end
            toplevel.each_classmodule{|m|
              if m.include_includes?(module_name, @options.ignore_case)
                if !m.include_requires?(@file_name, @options.ignore_case)
                  m.add_require(Require.new(@file_name, &quot;&quot;))
                end
              end
            }
          end
        elsif block_searching_flag == :program
          program_name = module_program_name
          program_code = module_program_code
          program_trailing = module_program_trailing
          progress &quot;p&quot;
          program_comment = COMMENTS_ARE_UPPER ? 
            find_comments(pre_comment.join(&quot;\n&quot;)) + &quot;\n&quot; + program_trailing : 
              program_trailing + &quot;\n&quot; + find_comments(program_code.sub(/^.*$\n/i, ''))
          program_comment = &quot;\n\n= &lt;i&gt;Program&lt;/i&gt; &lt;tt&gt;#{program_name}&lt;/tt&gt;\n\n&quot; \
                            + program_comment
          @top_level.comment &lt;&lt; program_comment
          parse_program_or_module(@top_level, program_code, :private)
        end

        # next loop to search next block
        level_depth = 0
        block_searching_flag = false
        block_searching_lines = []
        pre_comment = []
        next false
      }

      remaining_lines.delete_if{ |line|
        line == false
      }

      # External subprograms and functions are parsed
      #
      parse_program_or_module(@top_level, remaining_lines.join(&quot;\n&quot;),
                              :public, true)

      @top_level
    end  # End of scan

    private

    def parse_program_or_module(container, code,
                                visibility=:public, external=nil)
      return unless container
      return unless code
      remaining_lines = code.split(&quot;\n&quot;)
      remaining_code = &quot;#{code}&quot;

      #
      # Parse variables before &quot;contains&quot; in module
      #
      level_depth = 0
      before_contains_lines = []
      before_contains_code = nil
      before_contains_flag = nil
      remaining_lines.each{ |line|
        if !before_contains_flag
          if line =~ /^\s*?module\s+\w+\s*?(!.*?)?$/i
            before_contains_flag = true
          end
        else
          break if line =~ /^\s*?contains\s*?(!.*?)?$/i
          level_depth += 1 if block_start?(line)
          level_depth -= 1 if block_end?(line)
          break if level_depth &lt; 0
          before_contains_lines &lt;&lt; line
        end
      }
      before_contains_code = before_contains_lines.join(&quot;\n&quot;)
      if before_contains_code
        before_contains_code.gsub!(/^\s*?interface\s+.*?\s+end\s+interface.*?$/im, &quot;&quot;)
        before_contains_code.gsub!(/^\s*?type[\s\,]+.*?\s+end\s+type.*?$/im, &quot;&quot;)
      end

      #
      # Parse global &quot;use&quot;
      #
      use_check_code = &quot;#{before_contains_code}&quot;
      cascaded_modules_list = []
      while use_check_code =~ /^\s*?use\s+(\w+)(.*?)(!.*?)?$/i
        use_check_code = $~.pre_match
        use_check_code &lt;&lt; $~.post_match
        used_mod_name = $1.strip.chomp
        used_list = $2 || &quot;&quot;
        used_trailing = $3 || &quot;&quot;
        next if used_trailing =~ /!:nodoc:/
        if !container.include_includes?(used_mod_name, @options.ignore_case)
          progress &quot;.&quot;
          container.add_include Include.new(used_mod_name, &quot;&quot;)
        end
        if ! (used_list =~ /\,\s*?only\s*?:/i )
          cascaded_modules_list &lt;&lt; &quot;\#&quot; + used_mod_name
        end
      end

      #
      # Parse public and private, and store information.
      # This information is used when &quot;add_method&quot; and
      # &quot;set_visibility_for&quot; are called.
      #
      visibility_default, visibility_info = 
                parse_visibility(remaining_lines.join(&quot;\n&quot;), visibility, container)
      @@public_methods.concat visibility_info
      if visibility_default == :public
        if !cascaded_modules_list.empty?
          cascaded_modules = 
            Attr.new(&quot;Cascaded Modules&quot;,
                     &quot;Imported modules all of whose components are published again&quot;,
                     &quot;&quot;,
                     cascaded_modules_list.join(&quot;, &quot;))
          container.add_attribute(cascaded_modules)
        end
      end

      #
      # Check rename elements
      #
      use_check_code = &quot;#{before_contains_code}&quot;
      while use_check_code =~ /^\s*?use\s+(\w+)\s*?\,(.+)$/i
        use_check_code = $~.pre_match
        use_check_code &lt;&lt; $~.post_match
        used_mod_name = $1.strip.chomp
        used_elements = $2.sub(/\s*?only\s*?:\s*?/i, '')
        used_elements.split(&quot;,&quot;).each{ |used|
          if /\s*?(\w+)\s*?=&gt;\s*?(\w+)\s*?/ =~ used
            local = $1
            org = $2
            @@public_methods.collect!{ |pub_meth|
              if local == pub_meth[&quot;name&quot;] ||
                  local.upcase == pub_meth[&quot;name&quot;].upcase &amp;&amp;
                  @options.ignore_case
                pub_meth[&quot;name&quot;] = org
                pub_meth[&quot;local_name&quot;] = local
              end
              pub_meth
            }
          end
        }
      end

      #
      # Parse private &quot;use&quot;
      #
      use_check_code = remaining_lines.join(&quot;\n&quot;)
      while use_check_code =~ /^\s*?use\s+(\w+)(.*?)(!.*?)?$/i
        use_check_code = $~.pre_match
        use_check_code &lt;&lt; $~.post_match
        used_mod_name = $1.strip.chomp
        used_trailing = $3 || &quot;&quot;
        next if used_trailing =~ /!:nodoc:/
        if !container.include_includes?(used_mod_name, @options.ignore_case)
          progress &quot;.&quot;
          container.add_include Include.new(used_mod_name, &quot;&quot;)
        end
      end

      container.each_includes{ |inc|
        TopLevel.all_files.each do |name, toplevel|
          indicated_mod = toplevel.find_symbol(inc.name,
                                               nil, @options.ignore_case)
          if indicated_mod
            indicated_name = indicated_mod.parent.file_relative_name
            if !container.include_requires?(indicated_name, @options.ignore_case)
              container.add_require(Require.new(indicated_name, &quot;&quot;))
            end
            break
          end
        end
      }

      #
      # Parse derived-types definitions
      #
      derived_types_comment = &quot;&quot;
      remaining_code = remaining_lines.join(&quot;\n&quot;)
      while remaining_code =~ /^\s*?
                                    type[\s\,]+(public|private)?\s*?(::)?\s*?
                                    (\w+)\s*?(!.*?)?$
                                    (.*?)
                                    ^\s*?end\s+type.*?$
                              /imx
        remaining_code = $~.pre_match
        remaining_code &lt;&lt; $~.post_match
        typename = $3.chomp.strip
        type_elements = $5 || &quot;&quot;
        type_code = remove_empty_head_lines($&amp;)
        type_trailing = find_comments($4)
        next if type_trailing =~ /^:nodoc:/
        type_visibility = $1
        type_comment = COMMENTS_ARE_UPPER ? 
          find_comments($~.pre_match) + &quot;\n&quot; + type_trailing :
            type_trailing + &quot;\n&quot; + find_comments(type_code.sub(/^.*$\n/i, ''))
        type_element_visibility_public = true
        type_code.split(&quot;\n&quot;).each{ |line|
          if /^\s*?private\s*?$/ =~ line
            type_element_visibility_public = nil
            break
          end
        } if type_code

        args_comment = &quot;&quot;
        type_args_info = nil

        if @options.show_all
          args_comment = find_arguments(nil, type_code, true)
        else
          type_public_args_list = []
          type_args_info = definition_info(type_code)
          type_args_info.each{ |arg|
            arg_is_public = type_element_visibility_public
            arg_is_public = true if arg.include_attr?(&quot;public&quot;)
            arg_is_public = nil if arg.include_attr?(&quot;private&quot;)
            type_public_args_list &lt;&lt; arg.varname if arg_is_public
          }
          args_comment = find_arguments(type_public_args_list, type_code)
        end

        type = AnyMethod.new(&quot;type #{typename}&quot;, typename)
        type.singleton = false
        type.params = &quot;&quot;
        type.comment = &quot;&lt;b&gt;&lt;em&gt; Derived Type &lt;/em&gt;&lt;/b&gt; :: &lt;tt&gt;&lt;/tt&gt;\n&quot;
        type.comment &lt;&lt; args_comment if args_comment
        type.comment &lt;&lt; type_comment if type_comment
        progress &quot;t&quot;
        @stats.num_methods += 1
        container.add_method type

        set_visibility(container, typename, visibility_default, @@public_methods)

        if type_visibility
          type_visibility.gsub!(/\s/,'')
          type_visibility.gsub!(/\,/,'')
          type_visibility.gsub!(/:/,'')
          type_visibility.downcase!
          if type_visibility == &quot;public&quot;
            container.set_visibility_for([typename], :public)
          elsif type_visibility == &quot;private&quot;
            container.set_visibility_for([typename], :private)
          end
        end

        check_public_methods(type, container.name)

        if @options.show_all
          derived_types_comment &lt;&lt; &quot;, &quot; unless derived_types_comment.empty?
          derived_types_comment &lt;&lt; typename
        else
          if type.visibility == :public
          derived_types_comment &lt;&lt; &quot;, &quot; unless derived_types_comment.empty?
          derived_types_comment &lt;&lt; typename
          end
        end

      end

      if !derived_types_comment.empty?
        derived_types_table = 
          Attr.new(&quot;Derived Types&quot;, &quot;Derived_Types&quot;, &quot;&quot;, 
                   derived_types_comment)
        container.add_attribute(derived_types_table)
      end

      #
      # move interface scope
      #
      interface_code = &quot;&quot;
      while remaining_code =~ /^\s*?
                                   interface(
                                              \s+\w+                      |
                                              \s+operator\s*?\(.*?\)       |
                                              \s+assignment\s*?\(\s*?=\s*?\)
                                            )?\s*?$
                                   (.*?)
                                   ^\s*?end\s+interface.*?$
                              /imx
        interface_code &lt;&lt; remove_empty_head_lines($&amp;) + &quot;\n&quot;
        remaining_code = $~.pre_match
        remaining_code &lt;&lt; $~.post_match
      end

      #
      # Parse global constants or variables in modules
      #
      const_var_defs = definition_info(before_contains_code)
      const_var_defs.each{|defitem|
        next if defitem.nodoc
        const_or_var_type = &quot;Variable&quot;
        const_or_var_progress = &quot;v&quot;
        if defitem.include_attr?(&quot;parameter&quot;)
          const_or_var_type = &quot;Constant&quot;
          const_or_var_progress = &quot;c&quot;
        end
        const_or_var = AnyMethod.new(const_or_var_type, defitem.varname)
        const_or_var.singleton = false
        const_or_var.params = &quot;&quot;
        self_comment = find_arguments([defitem.varname], before_contains_code)
        const_or_var.comment = &quot;&lt;b&gt;&lt;em&gt;&quot; + const_or_var_type + &quot;&lt;/em&gt;&lt;/b&gt; :: &lt;tt&gt;&lt;/tt&gt;\n&quot;
        const_or_var.comment &lt;&lt; self_comment if self_comment
        progress const_or_var_progress
        @stats.num_methods += 1
        container.add_method const_or_var

        set_visibility(container, defitem.varname, visibility_default, @@public_methods)

        if defitem.include_attr?(&quot;public&quot;)
          container.set_visibility_for([defitem.varname], :public)
        elsif defitem.include_attr?(&quot;private&quot;)
          container.set_visibility_for([defitem.varname], :private)
        end

        check_public_methods(const_or_var, container.name)

      } if const_var_defs

      remaining_lines = remaining_code.split(&quot;\n&quot;)

      # &quot;subroutine&quot; or &quot;function&quot; parts are parsed (new)
      #
      level_depth = 0
      block_searching_flag = nil
      block_searching_lines = []
      pre_comment = []
      procedure_trailing = &quot;&quot;
      procedure_name = &quot;&quot;
      procedure_params = &quot;&quot;
      procedure_prefix = &quot;&quot;
      procedure_result_arg = &quot;&quot;
      procedure_type = &quot;&quot;
      contains_lines = []
      contains_flag = nil
      remaining_lines.collect!{|line|
        if !block_searching_flag
          # subroutine
          if line =~ /^\s*?
                           (recursive|pure|elemental)?\s*?
                           subroutine\s+(\w+)\s*?(\(.*?\))?\s*?(!.*?)?$
                     /ix
            block_searching_flag = :subroutine
            block_searching_lines &lt;&lt; line

            procedure_name = $2.chomp.strip
            procedure_params = $3 || &quot;&quot;
            procedure_prefix = $1 || &quot;&quot;
            procedure_trailing = $4 || &quot;!&quot;
            next false

          # function
          elsif line =~ /^\s*?
                         (recursive|pure|elemental)?\s*?
                         (
                             character\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | type\s*?\([\w\s]+?\)\s+
                           | integer\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | real\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | double\s+precision\s+
                           | logical\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | complex\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                         )?
                         function\s+(\w+)\s*?
                         (\(.*?\))?(\s+result\((.*?)\))?\s*?(!.*?)?$
                        /ix
            block_searching_flag = :function
            block_searching_lines &lt;&lt; line

            procedure_prefix = $1 || &quot;&quot;
            procedure_type = $2 ? $2.chomp.strip : nil
            procedure_name = $8.chomp.strip
            procedure_params = $9 || &quot;&quot;
            procedure_result_arg = $11 ? $11.chomp.strip : procedure_name
            procedure_trailing = $12 || &quot;!&quot;
            next false
          elsif line =~ /^\s*?!\s?(.*)/
            pre_comment &lt;&lt; line
            next line
          else
            pre_comment = []
            next line
          end
        end
        contains_flag = true if line =~ /^\s*?contains\s*?(!.*?)?$/
        block_searching_lines &lt;&lt; line
        contains_lines &lt;&lt; line if contains_flag

        level_depth += 1 if block_start?(line)
        level_depth -= 1 if block_end?(line)
        if level_depth &gt;= 0
          next false
        end

        # &quot;procedure_code&quot; is formatted.
        # &quot;:nodoc:&quot; flag is checked.
        #
        procedure_code = block_searching_lines.join(&quot;\n&quot;)
        procedure_code = remove_empty_head_lines(procedure_code)
        if procedure_trailing =~ /^!:nodoc:/
          # next loop to search next block
          level_depth = 0
          block_searching_flag = nil
          block_searching_lines = []
          pre_comment = []
          procedure_trailing = &quot;&quot;
          procedure_name = &quot;&quot;
          procedure_params = &quot;&quot;
          procedure_prefix = &quot;&quot;
          procedure_result_arg = &quot;&quot;
          procedure_type = &quot;&quot;
          contains_lines = []
          contains_flag = nil
          next false
        end

        # AnyMethod is created, and added to container
        #
        subroutine_function = nil
        if block_searching_flag == :subroutine
          subroutine_prefix   = procedure_prefix
          subroutine_name     = procedure_name
          subroutine_params   = procedure_params
          subroutine_trailing = procedure_trailing
          subroutine_code     = procedure_code

          subroutine_comment = COMMENTS_ARE_UPPER ? 
            pre_comment.join(&quot;\n&quot;) + &quot;\n&quot; + subroutine_trailing : 
              subroutine_trailing + &quot;\n&quot; + subroutine_code.sub(/^.*$\n/i, '')
          subroutine = AnyMethod.new(&quot;subroutine&quot;, subroutine_name)
          parse_subprogram(subroutine, subroutine_params,
                           subroutine_comment, subroutine_code,
                           before_contains_code, nil, subroutine_prefix)
          progress &quot;s&quot;
          @stats.num_methods += 1
          container.add_method subroutine
          subroutine_function = subroutine

        elsif block_searching_flag == :function
          function_prefix     = procedure_prefix
          function_type       = procedure_type
          function_name       = procedure_name
          function_params_org = procedure_params
          function_result_arg = procedure_result_arg
          function_trailing   = procedure_trailing
          function_code_org   = procedure_code

          function_comment = COMMENTS_ARE_UPPER ?
            pre_comment.join(&quot;\n&quot;) + &quot;\n&quot; + function_trailing :
              function_trailing + &quot;\n &quot; + function_code_org.sub(/^.*$\n/i, '')

          function_code = &quot;#{function_code_org}&quot;
          if function_type
            function_code &lt;&lt; &quot;\n&quot; + function_type + &quot; :: &quot; + function_result_arg
          end

          function_params =
            function_params_org.sub(/^\(/, &quot;\(#{function_result_arg}, &quot;)

          function = AnyMethod.new(&quot;function&quot;, function_name)
          parse_subprogram(function, function_params,
                           function_comment, function_code,
                           before_contains_code, true, function_prefix)

          # Specific modification due to function
          function.params.sub!(/\(\s*?#{function_result_arg}\s*?,\s*?/, &quot;\( &quot;)
          function.params &lt;&lt; &quot; result(&quot; + function_result_arg + &quot;)&quot;
          function.start_collecting_tokens
          function.add_token Token.new(1,1).set_text(function_code_org)

          progress &quot;f&quot;
          @stats.num_methods += 1
          container.add_method function
          subroutine_function = function

        end

        # The visibility of procedure is specified
        #
        set_visibility(container, procedure_name, 
                       visibility_default, @@public_methods)

        # The alias for this procedure from external modules
        #
        check_external_aliases(procedure_name,
                               subroutine_function.params,
                               subroutine_function.comment, subroutine_function) if external
        check_public_methods(subroutine_function, container.name)


        # contains_lines are parsed as private procedures
        if contains_flag
          parse_program_or_module(container,
                                  contains_lines.join(&quot;\n&quot;), :private)
        end

        # next loop to search next block
        level_depth = 0
        block_searching_flag = nil
        block_searching_lines = []
        pre_comment = []
        procedure_trailing = &quot;&quot;
        procedure_name = &quot;&quot;
        procedure_params = &quot;&quot;
        procedure_prefix = &quot;&quot;
        procedure_result_arg = &quot;&quot;
        contains_lines = []
        contains_flag = nil
        next false
      } # End of remaining_lines.collect!{|line|

      # Array remains_lines is converted to String remains_code again
      #
      remaining_code = remaining_lines.join(&quot;\n&quot;)

      #
      # Parse interface
      #
      interface_scope = false
      generic_name = &quot;&quot;
      interface_code.split(&quot;\n&quot;).each{ |line|
        if /^\s*?
                 interface(
                            \s+\w+|
                            \s+operator\s*?\(.*?\)|
                            \s+assignment\s*?\(\s*?=\s*?\)
                          )?
                 \s*?(!.*?)?$
           /ix =~ line
          generic_name = $1 ? $1.strip.chomp : nil
          interface_trailing = $2 || &quot;!&quot;
          interface_scope = true
          interface_scope = false if interface_trailing =~ /!:nodoc:/
#          if generic_name =~ /operator\s*?\((.*?)\)/i
#            operator_name = $1
#            if operator_name &amp;&amp; !operator_name.empty?
#              generic_name = &quot;#{operator_name}&quot;
#            end
#          end
#          if generic_name =~ /assignment\s*?\((.*?)\)/i
#            assignment_name = $1
#            if assignment_name &amp;&amp; !assignment_name.empty?
#              generic_name = &quot;#{assignment_name}&quot;
#            end
#          end
        end
        if /^\s*?end\s+interface/i =~ line
          interface_scope = false
          generic_name = nil
        end
        # internal alias
        if interface_scope &amp;&amp; /^\s*?module\s+procedure\s+(.*?)(!.*?)?$/i =~ line
          procedures = $1.strip.chomp
          procedures_trailing = $2 || &quot;!&quot;
          next if procedures_trailing =~ /!:nodoc:/
          procedures.split(&quot;,&quot;).each{ |proc|
            proc.strip!
            proc.chomp!
            next if generic_name == proc || !generic_name
            old_meth = container.find_symbol(proc, nil, @options.ignore_case)
            next if !old_meth
            nolink = old_meth.visibility == :private ? true : nil
            nolink = nil if @options.show_all
            new_meth = 
               initialize_external_method(generic_name, proc, 
                                          old_meth.params, nil, 
                                          old_meth.comment, 
                                          old_meth.clone.token_stream[0].text, 
                                          true, nolink)
            new_meth.singleton = old_meth.singleton

            progress &quot;i&quot;
            @stats.num_methods += 1
            container.add_method new_meth

            set_visibility(container, generic_name, visibility_default, @@public_methods)

            check_public_methods(new_meth, container.name)

          }
        end

        # external aliases
        if interface_scope
          # subroutine
          proc = nil
          params = nil
          procedures_trailing = nil
          if line =~ /^\s*?
                           (recursive|pure|elemental)?\s*?
                           subroutine\s+(\w+)\s*?(\(.*?\))?\s*?(!.*?)?$
                     /ix
            proc = $2.chomp.strip
            generic_name = proc unless generic_name
            params = $3 || &quot;&quot;
            procedures_trailing = $4 || &quot;!&quot;

          # function
          elsif line =~ /^\s*?
                         (recursive|pure|elemental)?\s*?
                         (
                             character\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | type\s*?\([\w\s]+?\)\s+
                           | integer\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | real\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | double\s+precision\s+
                           | logical\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                           | complex\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                         )?
                         function\s+(\w+)\s*?
                         (\(.*?\))?(\s+result\((.*?)\))?\s*?(!.*?)?$
                        /ix
            proc = $8.chomp.strip
            generic_name = proc unless generic_name
            params = $9 || &quot;&quot;
            procedures_trailing = $12 || &quot;!&quot;
          else
            next
          end
          next if procedures_trailing =~ /!:nodoc:/
          indicated_method = nil
          indicated_file   = nil
          TopLevel.all_files.each do |name, toplevel|
            indicated_method = toplevel.find_local_symbol(proc, @options.ignore_case)
            indicated_file = name
            break if indicated_method
          end

          if indicated_method
            external_method = 
              initialize_external_method(generic_name, proc, 
                                         indicated_method.params, 
                                         indicated_file, 
                                         indicated_method.comment)

            progress &quot;e&quot;
            @stats.num_methods += 1
            container.add_method external_method
            set_visibility(container, generic_name, visibility_default, @@public_methods)
            if !container.include_requires?(indicated_file, @options.ignore_case)
              container.add_require(Require.new(indicated_file, &quot;&quot;))
            end
            check_public_methods(external_method, container.name)

          else
            @@external_aliases &lt;&lt; {
              &quot;new_name&quot;  =&gt; generic_name,
              &quot;old_name&quot;  =&gt; proc,
              &quot;file_or_module&quot; =&gt; container,
              &quot;visibility&quot; =&gt; find_visibility(container, generic_name, @@public_methods) || visibility_default
            }
          end
        end

      } if interface_code # End of interface_code.split(&quot;\n&quot;).each ...

      #
      # Already imported methods are removed from @@public_methods.
      # Remainders are assumed to be imported from other modules.
      #
      @@public_methods.delete_if{ |method| method[&quot;entity_is_discovered&quot;]}

      @@public_methods.each{ |pub_meth|
        next unless pub_meth[&quot;file_or_module&quot;].name == container.name
        pub_meth[&quot;used_modules&quot;].each{ |used_mod|
          TopLevel.all_classes_and_modules.each{ |modules|
            if modules.name == used_mod ||
                modules.name.upcase == used_mod.upcase &amp;&amp;
                @options.ignore_case
              modules.method_list.each{ |meth|
                if meth.name == pub_meth[&quot;name&quot;] ||
                    meth.name.upcase == pub_meth[&quot;name&quot;].upcase &amp;&amp;
                    @options.ignore_case
                  new_meth = initialize_public_method(meth,
                                                      modules.name)
                  if pub_meth[&quot;local_name&quot;]
                    new_meth.name = pub_meth[&quot;local_name&quot;]
                  end
                  progress &quot;e&quot;
                  @stats.num_methods += 1
                  container.add_method new_meth
                end
              }
            end
          }
        }
      }

      container
    end  # End of parse_program_or_module

    #
    # Parse arguments, comment, code of subroutine and function.
    # Return AnyMethod object.
    #
    def parse_subprogram(subprogram, params, comment, code, 
                         before_contains=nil, function=nil, prefix=nil)
      subprogram.singleton = false
      prefix = &quot;&quot; if !prefix
      arguments = params.sub(/\(/, &quot;&quot;).sub(/\)/, &quot;&quot;).split(&quot;,&quot;) if params
      args_comment, params_opt = 
        find_arguments(arguments, code.sub(/^s*?contains\s*?(!.*?)?$.*/im, &quot;&quot;),
                       nil, nil, true)
      params_opt = &quot;( &quot; + params_opt + &quot; ) &quot; if params_opt
      subprogram.params = params_opt || &quot;&quot;
      namelist_comment = find_namelists(code, before_contains)

      block_comment = find_comments comment
      if function
        subprogram.comment = &quot;&lt;b&gt;&lt;em&gt; Function &lt;/em&gt;&lt;/b&gt; :: &lt;em&gt;#{prefix}&lt;/em&gt;\n&quot;
      else
        subprogram.comment = &quot;&lt;b&gt;&lt;em&gt; Subroutine &lt;/em&gt;&lt;/b&gt; :: &lt;em&gt;#{prefix}&lt;/em&gt;\n&quot;
      end
      subprogram.comment &lt;&lt; args_comment if args_comment
      subprogram.comment &lt;&lt; block_comment if block_comment
      subprogram.comment &lt;&lt; namelist_comment if namelist_comment

      # For output source code
      subprogram.start_collecting_tokens
      subprogram.add_token Token.new(1,1).set_text(code)

      subprogram
    end

    #
    # Collect comment for file entity
    #
    def collect_first_comment(body)
      comment = &quot;&quot;
      not_comment = &quot;&quot;
      comment_start = false
      comment_end   = false
      body.split(&quot;\n&quot;).each{ |line|
        if comment_end
          not_comment &lt;&lt; line
          not_comment &lt;&lt; &quot;\n&quot;
        elsif /^\s*?!\s?(.*)$/i =~ line
          comment_start = true
          comment &lt;&lt; $1
          comment &lt;&lt; &quot;\n&quot;
        elsif /^\s*?$/i =~ line
          comment_end = true if comment_start &amp;&amp; COMMENTS_ARE_UPPER
        else
          comment_end = true
          not_comment &lt;&lt; line
          not_comment &lt;&lt; &quot;\n&quot;
        end
      }
      return comment, not_comment
    end


    # Return comments of definitions of arguments
    #
    # If &quot;all&quot; argument is true, information of all arguments are returned.
    # If &quot;modified_params&quot; is true, list of arguments are decorated,
    # for example, optional arguments are parenthetic as &quot;[arg]&quot;.
    #
    def find_arguments(args, text, all=nil, indent=nil, modified_params=nil)
      return unless args || all
      indent = &quot;&quot; unless indent
      args = [&quot;all&quot;] if all
      params = &quot;&quot; if modified_params
      comma = &quot;&quot;
      return unless text
      args_rdocforms = &quot;\n&quot;
      remaining_lines = &quot;#{text}&quot;
      definitions = definition_info(remaining_lines)
      args.each{ |arg|
        arg.strip!
        arg.chomp!
        definitions.each { |defitem|
          if arg == defitem.varname.strip.chomp || all
            args_rdocforms &lt;&lt; &lt;&lt;-&quot;EOF&quot;

#{indent}&lt;tt&gt;&lt;b&gt;#{defitem.varname.chomp.strip}#{defitem.arraysuffix}&lt;/b&gt; #{defitem.inivalue}&lt;/tt&gt; :: 
#{indent}   &lt;tt&gt;#{defitem.types.chomp.strip}&lt;/tt&gt;
EOF
            if !defitem.comment.chomp.strip.empty?
              comment = &quot;&quot;
              defitem.comment.split(&quot;\n&quot;).each{ |line|
                comment &lt;&lt; &quot;       &quot; + line + &quot;\n&quot;
              }
              args_rdocforms &lt;&lt; &lt;&lt;-&quot;EOF&quot;

#{indent}   &lt;tt&gt;&lt;/tt&gt; :: 
#{indent}       &lt;tt&gt;&lt;/tt&gt;
#{indent}       #{comment.chomp.strip}
EOF
            end

            if modified_params
              if defitem.include_attr?(&quot;optional&quot;)
                params &lt;&lt; &quot;#{comma}[#{arg}]&quot;
              else
                params &lt;&lt; &quot;#{comma}#{arg}&quot;
              end
              comma = &quot;, &quot;
            end
          end
        }
      }
      if modified_params
        return args_rdocforms, params
      else
        return args_rdocforms
      end
    end

    # Return comments of definitions of namelists
    #
    def find_namelists(text, before_contains=nil)
      return nil if !text
      result = &quot;&quot;
      lines = &quot;#{text}&quot;
      before_contains = &quot;&quot; if !before_contains
      while lines =~ /^\s*?namelist\s+\/\s*?(\w+)\s*?\/([\s\w\,]+)$/i
        lines = $~.post_match
        nml_comment = COMMENTS_ARE_UPPER ? 
            find_comments($~.pre_match) : find_comments($~.post_match)
        nml_name = $1
        nml_args = $2.split(&quot;,&quot;)
        result &lt;&lt; &quot;\n\n=== NAMELIST &lt;tt&gt;&lt;b&gt;&quot; + nml_name + &quot;&lt;/tt&gt;&lt;/b&gt;\n\n&quot;
        result &lt;&lt; nml_comment + &quot;\n&quot; if nml_comment
        if lines.split(&quot;\n&quot;)[0] =~ /^\//i
          lines = &quot;namelist &quot; + lines
        end
        result &lt;&lt; find_arguments(nml_args, &quot;#{text}&quot; + &quot;\n&quot; + before_contains)
      end
      return result
    end

    #
    # Comments just after module or subprogram, or arguments are
    # returned. If &quot;COMMENTS_ARE_UPPER&quot; is true, comments just before
    # modules or subprograms are returned
    #
    def find_comments text
      return &quot;&quot; unless text
      lines = text.split(&quot;\n&quot;)
      lines.reverse! if COMMENTS_ARE_UPPER
      comment_block = Array.new
      lines.each do |line|
        break if line =~ /^\s*?\w/ || line =~ /^\s*?$/
        if COMMENTS_ARE_UPPER
          comment_block.unshift line.sub(/^\s*?!\s?/,&quot;&quot;)
        else
          comment_block.push line.sub(/^\s*?!\s?/,&quot;&quot;)
        end
      end
      nice_lines = comment_block.join(&quot;\n&quot;).split &quot;\n\s*?\n&quot;
      nice_lines[0] ||= &quot;&quot;
      nice_lines.shift
    end

    def progress(char)
      unless @options.quiet
        @progress.print(char)
        @progress.flush
      end
    end

    #
    # Create method for internal alias
    #
    def initialize_public_method(method, parent)
      return if !method || !parent

      new_meth = AnyMethod.new(&quot;External Alias for module&quot;, method.name)
      new_meth.singleton    = method.singleton
      new_meth.params       = method.params.clone
      new_meth.comment      = remove_trailing_alias(method.comment.clone)
      new_meth.comment      &lt;&lt; &quot;\n\n#{EXTERNAL_ALIAS_MES} #{parent.strip.chomp}\##{method.name}&quot;

      return new_meth
    end

    #
    # Create method for external alias
    #
    # If argument &quot;internal&quot; is true, file is ignored.
    #
    def initialize_external_method(new, old, params, file, comment, token=nil,
                                   internal=nil, nolink=nil)
      return nil unless new || old

      if internal
        external_alias_header = &quot;#{INTERNAL_ALIAS_MES} &quot;
        external_alias_text   = external_alias_header + old 
      elsif file
        external_alias_header = &quot;#{EXTERNAL_ALIAS_MES} &quot;
        external_alias_text   = external_alias_header + file + &quot;#&quot; + old
      else
        return nil
      end
      external_meth = AnyMethod.new(external_alias_text, new)
      external_meth.singleton    = false
      external_meth.params       = params
      external_comment = remove_trailing_alias(comment) + &quot;\n\n&quot; if comment
      external_meth.comment = external_comment || &quot;&quot;
      if nolink &amp;&amp; token
        external_meth.start_collecting_tokens
        external_meth.add_token Token.new(1,1).set_text(token)
      else
        external_meth.comment &lt;&lt; external_alias_text
      end

      return external_meth
    end



    #
    # Parse visibility
    #
    def parse_visibility(code, default, container)
      result = []
      visibility_default = default || :public

      used_modules = []
      container.includes.each{|i| used_modules &lt;&lt; i.name} if container

      remaining_code = code.gsub(/^\s*?type[\s\,]+.*?\s+end\s+type.*?$/im, &quot;&quot;)
      remaining_code.split(&quot;\n&quot;).each{ |line|
        if /^\s*?private\s*?$/ =~ line
          visibility_default = :private
          break
        end
      } if remaining_code

      remaining_code.split(&quot;\n&quot;).each{ |line|
        if /^\s*?private\s*?(::)?\s+(.*)\s*?(!.*?)?/i =~ line
          methods = $2.sub(/!.*$/, '')
          methods.split(&quot;,&quot;).each{ |meth|
            meth.sub!(/!.*$/, '')
            meth.gsub!(/:/, '')
            result &lt;&lt; {
              &quot;name&quot; =&gt; meth.chomp.strip,
              &quot;visibility&quot; =&gt; :private,
              &quot;used_modules&quot; =&gt; used_modules.clone,
              &quot;file_or_module&quot; =&gt; container,
              &quot;entity_is_discovered&quot; =&gt; nil,
              &quot;local_name&quot; =&gt; nil
            }
          }
        elsif /^\s*?public\s*?(::)?\s+(.*)\s*?(!.*?)?/i =~ line
          methods = $2.sub(/!.*$/, '')
          methods.split(&quot;,&quot;).each{ |meth|
            meth.sub!(/!.*$/, '')
            meth.gsub!(/:/, '')
            result &lt;&lt; {
              &quot;name&quot; =&gt; meth.chomp.strip,
              &quot;visibility&quot; =&gt; :public,
              &quot;used_modules&quot; =&gt; used_modules.clone,
              &quot;file_or_module&quot; =&gt; container,
              &quot;entity_is_discovered&quot; =&gt; nil,
              &quot;local_name&quot; =&gt; nil
            }
          }
        end
      } if remaining_code

      if container
        result.each{ |vis_info|
          vis_info[&quot;parent&quot;] = container.name
        }
      end

      return visibility_default, result
    end

    #
    # Set visibility
    #
    # &quot;subname&quot; element of &quot;visibility_info&quot; is deleted.
    #
    def set_visibility(container, subname, visibility_default, visibility_info)
      return unless container || subname || visibility_default || visibility_info
      not_found = true
      visibility_info.collect!{ |info|
        if info[&quot;name&quot;] == subname ||
            @options.ignore_case &amp;&amp; info[&quot;name&quot;].upcase == subname.upcase
          if info[&quot;file_or_module&quot;].name == container.name
            container.set_visibility_for([subname], info[&quot;visibility&quot;])
            info[&quot;entity_is_discovered&quot;] = true
            not_found = false
          end
        end
        info
      }
      if not_found
        return container.set_visibility_for([subname], visibility_default)
      else
        return container
      end
    end

    #
    # Find visibility
    #
    def find_visibility(container, subname, visibility_info)
      return nil if !subname || !visibility_info
      visibility_info.each{ |info|
        if info[&quot;name&quot;] == subname ||
            @options.ignore_case &amp;&amp; info[&quot;name&quot;].upcase == subname.upcase
          if info[&quot;parent&quot;] == container.name
            return info[&quot;visibility&quot;]
          end
        end
      }
      return nil
    end

    #
    # Check external aliases
    #
    def check_external_aliases(subname, params, comment, test=nil)
      @@external_aliases.each{ |alias_item|
        if subname == alias_item[&quot;old_name&quot;] ||
                    subname.upcase == alias_item[&quot;old_name&quot;].upcase &amp;&amp;
                            @options.ignore_case

          new_meth = initialize_external_method(alias_item[&quot;new_name&quot;], 
                                                subname, params, @file_name, 
                                                comment)
          new_meth.visibility = alias_item[&quot;visibility&quot;]

          progress &quot;e&quot;
          @stats.num_methods += 1
          alias_item[&quot;file_or_module&quot;].add_method(new_meth)

          if !alias_item[&quot;file_or_module&quot;].include_requires?(@file_name, @options.ignore_case)
            alias_item[&quot;file_or_module&quot;].add_require(Require.new(@file_name, &quot;&quot;))
          end
        end
      }
    end

    #
    # Check public_methods
    #
    def check_public_methods(method, parent)
      return if !method || !parent
      @@public_methods.each{ |alias_item|
        parent_is_used_module = nil
        alias_item[&quot;used_modules&quot;].each{ |used_module|
          if used_module == parent ||
              used_module.upcase == parent.upcase &amp;&amp;
              @options.ignore_case
            parent_is_used_module = true
          end
        }
        next if !parent_is_used_module

        if method.name == alias_item[&quot;name&quot;] ||
            method.name.upcase == alias_item[&quot;name&quot;].upcase &amp;&amp;
            @options.ignore_case

          new_meth = initialize_public_method(method, parent)
          if alias_item[&quot;local_name&quot;]
            new_meth.name = alias_item[&quot;local_name&quot;]
          end

          progress &quot;e&quot;
          @stats.num_methods += 1
          alias_item[&quot;file_or_module&quot;].add_method new_meth
        end
      }
    end

    #
    # Continuous lines are united.
    #
    # Comments in continuous lines are removed.
    #
    def united_to_one_line(f90src)
      return &quot;&quot; unless f90src
      lines = f90src.split(&quot;\n&quot;)
      previous_continuing = false
      now_continuing = false
      body = &quot;&quot;
      lines.each{ |line|
        words = line.split(&quot;&quot;)
        next if words.empty? &amp;&amp; previous_continuing
        commentout = false
        brank_flag = true ; brank_char = &quot;&quot;
        squote = false    ; dquote = false
        ignore = false
        words.collect! { |char|
          if previous_continuing &amp;&amp; brank_flag
            now_continuing = true
            ignore         = true
            case char
            when &quot;!&quot;                       ; break
            when &quot; &quot; ; brank_char &lt;&lt; char  ; next &quot;&quot;
            when &quot;&amp;&quot;
              brank_flag = false
              now_continuing = false
              next &quot;&quot;
            else 
              brank_flag     = false
              now_continuing = false
              ignore         = false
              next brank_char + char
            end
          end
          ignore = false

          if now_continuing
            next &quot;&quot;
          elsif !(squote) &amp;&amp; !(dquote) &amp;&amp; !(commentout)
            case char
            when &quot;!&quot; ; commentout = true     ; next char
            when &quot;\&quot;&quot;; dquote = true         ; next char
            when &quot;\'&quot;; squote = true         ; next char
            when &quot;&amp;&quot; ; now_continuing = true ; next &quot;&quot;
            else next char
            end
          elsif commentout
            next char
          elsif squote
            case char
            when &quot;\'&quot;; squote = false ; next char
            else next char
            end
          elsif dquote
            case char
            when &quot;\&quot;&quot;; dquote = false ; next char
            else next char
            end
          end
        }
        if !ignore &amp;&amp; !previous_continuing || !brank_flag
          if previous_continuing
            body &lt;&lt; words.join(&quot;&quot;)
          else
            body &lt;&lt; &quot;\n&quot; + words.join(&quot;&quot;)
          end
        end
        previous_continuing = now_continuing ? true : nil
        now_continuing = nil
      }
      return body
    end


    #
    # Continuous line checker
    #
    def continuous_line?(line)
      continuous = false
      if /&amp;\s*?(!.*)?$/ =~ line
        continuous = true
        if comment_out?($~.pre_match)
          continuous = false
        end
      end
      return continuous
    end

    #
    # Comment out checker
    #
    def comment_out?(line)
      return nil unless line
      commentout = false
      squote = false ; dquote = false
      line.split(&quot;&quot;).each { |char|
        if !(squote) &amp;&amp; !(dquote)
          case char
          when &quot;!&quot; ; commentout = true ; break
          when &quot;\&quot;&quot;; dquote = true
          when &quot;\'&quot;; squote = true
          else next
          end
        elsif squote
          case char
          when &quot;\'&quot;; squote = false
          else next
          end
        elsif dquote
          case char
          when &quot;\&quot;&quot;; dquote = false
          else next
          end
        end
      }
      return commentout
    end

    #
    # Semicolons are replaced to line feed.
    #
    def semicolon_to_linefeed(text)
      return &quot;&quot; unless text
      lines = text.split(&quot;\n&quot;)
      lines.collect!{ |line|
        words = line.split(&quot;&quot;)
        commentout = false
        squote = false ; dquote = false
        words.collect! { |char|
          if !(squote) &amp;&amp; !(dquote) &amp;&amp; !(commentout)
            case char
            when &quot;!&quot; ; commentout = true ; next char
            when &quot;\&quot;&quot;; dquote = true     ; next char
            when &quot;\'&quot;; squote = true     ; next char
            when &quot;;&quot; ;                     &quot;\n&quot;
            else next char
            end
          elsif commentout
            next char
          elsif squote
            case char
            when &quot;\'&quot;; squote = false ; next char
            else next char
            end
          elsif dquote
            case char
            when &quot;\&quot;&quot;; dquote = false ; next char
            else next char
            end
          end
        }
        words.join(&quot;&quot;)
      }
      return lines.join(&quot;\n&quot;)
    end

    #
    # Which &quot;line&quot; is start of block (module, program, block data,
    # subroutine, function) statement ?
    #
    def block_start?(line)
      return nil if !line

      if line =~ /^\s*?module\s+(\w+)\s*?(!.*?)?$/i    ||
          line =~ /^\s*?program\s+(\w+)\s*?(!.*?)?$/i  ||
          line =~ /^\s*?block\s+data(\s+\w+)?\s*?(!.*?)?$/i     ||
          line =~ \
                  /^\s*?
                   (recursive|pure|elemental)?\s*?
                   subroutine\s+(\w+)\s*?(\(.*?\))?\s*?(!.*?)?$
                  /ix ||
          line =~ \
                  /^\s*?
                   (recursive|pure|elemental)?\s*?
                   (
                       character\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                     | type\s*?\([\w\s]+?\)\s+
                     | integer\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                     | real\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                     | double\s+precision\s+
                     | logical\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                     | complex\s*?(\([\w\s\=\(\)\*]+?\))?\s+
                   )?
                   function\s+(\w+)\s*?
                   (\(.*?\))?(\s+result\((.*?)\))?\s*?(!.*?)?$
                  /ix
        return true
      end

      return nil
    end

    #
    # Which &quot;line&quot; is end of block (module, program, block data,
    # subroutine, function) statement ?
    #
    def block_end?(line)
      return nil if !line

      if line =~ /^\s*?end\s*?(!.*?)?$/i                 ||
          line =~ /^\s*?end\s+module(\s+\w+)?\s*?(!.*?)?$/i       ||
          line =~ /^\s*?end\s+program(\s+\w+)?\s*?(!.*?)?$/i      ||
          line =~ /^\s*?end\s+block\s+data(\s+\w+)?\s*?(!.*?)?$/i  ||
          line =~ /^\s*?end\s+subroutine(\s+\w+)?\s*?(!.*?)?$/i   ||
          line =~ /^\s*?end\s+function(\s+\w+)?\s*?(!.*?)?$/i
        return true
      end

      return nil
    end

    #
    # Remove &quot;Alias for&quot; in end of comments
    #
    def remove_trailing_alias(text)
      return &quot;&quot; if !text
      lines = text.split(&quot;\n&quot;).reverse
      comment_block = Array.new
      checked = false
      lines.each do |line|
        if !checked 
          if /^\s?#{INTERNAL_ALIAS_MES}/ =~ line ||
              /^\s?#{EXTERNAL_ALIAS_MES}/ =~ line
            checked = true
            next
          end
        end
        comment_block.unshift line
      end
      nice_lines = comment_block.join(&quot;\n&quot;)
      nice_lines ||= &quot;&quot;
      return nice_lines
    end

    # Empty lines in header are removed
    def remove_empty_head_lines(text)
      return &quot;&quot; unless text
      lines = text.split(&quot;\n&quot;)
      header = true
      lines.delete_if{ |line|
        header = false if /\S/ =~ line
        header &amp;&amp; /^\s*?$/ =~ line
      }
      lines.join(&quot;\n&quot;)
    end


    # header marker &quot;=&quot;, &quot;==&quot;, ... are removed
    def remove_header_marker(text)
      return text.gsub(/^\s?(=+)/, '&lt;tt&gt;&lt;/tt&gt;\1')
    end

    def remove_private_comments(body)
      body.gsub!(/^\s*!--\s*?$.*?^\s*!\+\+\s*?$/m, '')
      return body
    end


    #
    # Information of arguments of subroutines and functions in Fortran95
    #
    class Fortran95Definition

      # Name of variable
      #
      attr_reader   :varname

      # Types of variable
      #
      attr_reader   :types

      # Initial Value
      #
      attr_reader   :inivalue

      # Suffix of array
      #
      attr_reader   :arraysuffix

      # Comments
      #
      attr_accessor   :comment

      # Flag of non documentation
      #
      attr_accessor   :nodoc

      def initialize(varname, types, inivalue, arraysuffix, comment,
                     nodoc=false)
        @varname = varname
        @types = types
        @inivalue = inivalue
        @arraysuffix = arraysuffix
        @comment = comment
        @nodoc = nodoc
      end

      def to_s
        return &lt;&lt;-EOF
&lt;Fortran95Definition: 
  varname=#{@varname}, types=#{types},
  inivalue=#{@inivalue}, arraysuffix=#{@arraysuffix}, nodoc=#{@nodoc}, 
  comment=
#{@comment}
&gt;
EOF
      end

      #
      # If attr is included, true is returned
      #
      def include_attr?(attr)
        return if !attr
        @types.split(&quot;,&quot;).each{ |type|
          return true if type.strip.chomp.upcase == attr.strip.chomp.upcase
        }
        return nil
      end

    end # End of Fortran95Definition

    #
    # Parse string argument &quot;text&quot;, and Return Array of
    # Fortran95Definition object
    #
    def definition_info(text)
      return nil unless text
      lines = &quot;#{text}&quot;
      defs = Array.new
      comment = &quot;&quot;
      trailing_comment = &quot;&quot;
      under_comment_valid = false
      lines.split(&quot;\n&quot;).each{ |line|
        if /^\s*?!\s?(.*)/ =~ line
          if COMMENTS_ARE_UPPER
            comment &lt;&lt; remove_header_marker($1)
            comment &lt;&lt; &quot;\n&quot;
          elsif defs[-1] &amp;&amp; under_comment_valid
            defs[-1].comment &lt;&lt; &quot;\n&quot;
            defs[-1].comment &lt;&lt; remove_header_marker($1)
          end
          next
        elsif /^\s*?$/ =~ line
          comment = &quot;&quot;
          under_comment_valid = false
          next
        end
        type = &quot;&quot;
        characters = &quot;&quot;
        if line =~ /^\s*?
                    (
                        character\s*?(\([\w\s\=\(\)\*]+?\))?[\s\,]*
                      | type\s*?\([\w\s]+?\)[\s\,]*
                      | integer\s*?(\([\w\s\=\(\)\*]+?\))?[\s\,]*
                      | real\s*?(\([\w\s\=\(\)\*]+?\))?[\s\,]*
                      | double\s+precision[\s\,]*
                      | logical\s*?(\([\w\s\=\(\)\*]+?\))?[\s\,]*
                      | complex\s*?(\([\w\s\=\(\)\*]+?\))?[\s\,]*
                    )
                    (.*?::)?
                    (.+)$
                   /ix
          characters = $8
          type = $1
          type &lt;&lt; $7.gsub(/::/, '').gsub(/^\s*?\,/, '') if $7
        else
          under_comment_valid = false
          next
        end
        squote = false ; dquote = false ; bracket = 0
        iniflag = false; commentflag = false
        varname = &quot;&quot; ; arraysuffix = &quot;&quot; ; inivalue = &quot;&quot;
        start_pos = defs.size
        characters.split(&quot;&quot;).each { |char|
          if !(squote) &amp;&amp; !(dquote) &amp;&amp; bracket &lt;= 0 &amp;&amp; !(iniflag) &amp;&amp; !(commentflag)
            case char
            when &quot;!&quot; ; commentflag = true
            when &quot;(&quot; ; bracket += 1       ; arraysuffix = char
            when &quot;\&quot;&quot;; dquote = true
            when &quot;\'&quot;; squote = true
            when &quot;=&quot; ; iniflag = true     ; inivalue &lt;&lt; char
            when &quot;,&quot;
              defs &lt;&lt; Fortran95Definition.new(varname, type, inivalue, arraysuffix, comment)
              varname = &quot;&quot; ; arraysuffix = &quot;&quot; ; inivalue = &quot;&quot;
              under_comment_valid = true
            when &quot; &quot; ; next
            else     ; varname &lt;&lt; char
            end
          elsif commentflag
            comment &lt;&lt; remove_header_marker(char)
            trailing_comment &lt;&lt; remove_header_marker(char)
          elsif iniflag
            if dquote
              case char
              when &quot;\&quot;&quot; ; dquote = false ; inivalue &lt;&lt; char
              else      ; inivalue &lt;&lt; char
              end
            elsif squote
              case char
              when &quot;\'&quot; ; squote = false ; inivalue &lt;&lt; char
              else      ; inivalue &lt;&lt; char
              end
            elsif bracket &gt; 0
              case char
              when &quot;(&quot; ; bracket += 1 ; inivalue &lt;&lt; char
              when &quot;)&quot; ; bracket -= 1 ; inivalue &lt;&lt; char
              else     ; inivalue &lt;&lt; char
              end
            else
              case char
              when &quot;,&quot;
                defs &lt;&lt; Fortran95Definition.new(varname, type, inivalue, arraysuffix, comment)
                varname = &quot;&quot; ; arraysuffix = &quot;&quot; ; inivalue = &quot;&quot;
                iniflag = false
                under_comment_valid = true
              when &quot;(&quot; ; bracket += 1 ; inivalue &lt;&lt; char
              when &quot;\&quot;&quot;; dquote = true  ; inivalue &lt;&lt; char
              when &quot;\'&quot;; squote = true  ; inivalue &lt;&lt; char
              when &quot;!&quot; ; commentflag = true
              else     ; inivalue &lt;&lt; char
              end
            end
          elsif !(squote) &amp;&amp; !(dquote) &amp;&amp; bracket &gt; 0
            case char
            when &quot;(&quot; ; bracket += 1 ; arraysuffix &lt;&lt; char
            when &quot;)&quot; ; bracket -= 1 ; arraysuffix &lt;&lt; char
            else     ; arraysuffix &lt;&lt; char
            end
          elsif squote
            case char
            when &quot;\'&quot;; squote = false ; inivalue &lt;&lt; char
            else     ; inivalue &lt;&lt; char
            end
          elsif dquote
            case char
            when &quot;\&quot;&quot;; dquote = false ; inivalue &lt;&lt; char
            else     ; inivalue &lt;&lt; char
            end
          end
        }
        defs &lt;&lt; Fortran95Definition.new(varname, type, inivalue, arraysuffix, comment)
        if trailing_comment =~ /^:nodoc:/
          defs[start_pos..-1].collect!{ |defitem|
            defitem.nodoc = true
          }
        end
        varname = &quot;&quot; ; arraysuffix = &quot;&quot; ; inivalue = &quot;&quot;
        comment = &quot;&quot;
        under_comment_valid = true
        trailing_comment = &quot;&quot;
      }
      return defs
    end


  end # class Fortran95parser

end # module RDoc
</pre>
    </div>