  <div id="fileHeader">
    <h1>diagram.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rdoc/diagram.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># A wonderful hack by to draw package diagrams using the dot package.
# Originally written by  Jah, team Enticla.
#
# You must have the V1.7 or later in your path
# http://www.research.att.com/sw/tools/graphviz/

require &quot;rdoc/dot/dot&quot;
require 'rdoc/options'

module RDoc

  # Draw a set of diagrams representing the modules and classes in the
  # system. We draw one diagram for each file, and one for each toplevel
  # class or module. This means there will be overlap. However, it also
  # means that you'll get better context for objects.
  #
  # To use, simply
  #
  #   d = Diagram.new(info)   # pass in collection of top level infos
  #   d.draw
  #
  # The results will be written to the +dot+ subdirectory. The process
  # also sets the +diagram+ attribute in each object it graphs to
  # the name of the file containing the image. This can be used
  # by output generators to insert images.

  class Diagram

    FONT = &quot;Arial&quot;

    DOT_PATH = &quot;dot&quot;

    # Pass in the set of top level objects. The method also creates
    # the subdirectory to hold the images

    def initialize(info, options)
      @info = info
      @options = options
      @counter = 0
      File.makedirs(DOT_PATH)
      @diagram_cache = {}
    end

    # Draw the diagrams. We traverse the files, drawing a diagram for
    # each. We also traverse each top-level class and module in that
    # file drawing a diagram for these too. 

    def draw
      unless @options.quiet
        $stderr.print &quot;Diagrams: &quot;
        $stderr.flush
      end

      @info.each_with_index do |i, file_count|
        @done_modules = {}
        @local_names = find_names(i)
        @global_names = []
        @global_graph = graph = DOT::DOTDigraph.new('name' =&gt; 'TopLevel',
                                    'fontname' =&gt; FONT,
                                    'fontsize' =&gt; '8',
                                    'bgcolor'  =&gt; 'lightcyan1',
                                    'compound' =&gt; 'true')
        
        # it's a little hack %) i'm too lazy to create a separate class
        # for default node
        graph &lt;&lt; DOT::DOTNode.new('name' =&gt; 'node',
                                  'fontname' =&gt; FONT,
                                  'color' =&gt; 'black',
                                  'fontsize' =&gt; 8)
        
        i.modules.each do |mod|
          draw_module(mod, graph, true, i.file_relative_name)
        end
        add_classes(i, graph, i.file_relative_name)

        i.diagram = convert_to_png(&quot;f_#{file_count}&quot;, graph)
        
        # now go through and document each top level class and
        # module independently
        i.modules.each_with_index do |mod, count|
          @done_modules = {}
          @local_names = find_names(mod)
          @global_names = []

          @global_graph = graph = DOT::DOTDigraph.new('name' =&gt; 'TopLevel',
                                      'fontname' =&gt; FONT,
                                      'fontsize' =&gt; '8',
                                      'bgcolor'  =&gt; 'lightcyan1',
                                      'compound' =&gt; 'true')

          graph &lt;&lt; DOT::DOTNode.new('name' =&gt; 'node',
                                    'fontname' =&gt; FONT,
                                    'color' =&gt; 'black',
                                    'fontsize' =&gt; 8)
          draw_module(mod, graph, true)
          mod.diagram = convert_to_png(&quot;m_#{file_count}_#{count}&quot;, 
                                       graph) 
        end
      end
      $stderr.puts unless @options.quiet
    end

    #######
    private
    #######

    def find_names(mod)
      return [mod.full_name] + mod.classes.collect{|cl| cl.full_name} +
        mod.modules.collect{|m| find_names(m)}.flatten
    end

    def find_full_name(name, mod)
      full_name = name.dup
      return full_name if @local_names.include?(full_name)
      mod_path = mod.full_name.split('::')[0..-2]
      unless mod_path.nil?
        until mod_path.empty?
          full_name = mod_path.pop + '::' + full_name
          return full_name if @local_names.include?(full_name)
        end
      end
      return name
    end

    def draw_module(mod, graph, toplevel = false, file = nil)
      return if  @done_modules[mod.full_name] and not toplevel

      @counter += 1
      url = mod.http_url(&quot;classes&quot;)
      m = DOT::DOTSubgraph.new('name' =&gt; &quot;cluster_#{mod.full_name.gsub( /:/,'_' )}&quot;,
                               'label' =&gt; mod.name,
                               'fontname' =&gt; FONT,
                               'color' =&gt; 'blue', 
                               'style' =&gt; 'filled', 
                               'URL'   =&gt; %{&quot;#{url}&quot;},
                               'fillcolor' =&gt; toplevel ? 'palegreen1' : 'palegreen3')
      
      @done_modules[mod.full_name] = m
      add_classes(mod, m, file)
      graph &lt;&lt; m

      unless mod.includes.empty?
        mod.includes.each do |m|
          m_full_name = find_full_name(m.name, mod)
          if @local_names.include?(m_full_name)
            @global_graph &lt;&lt; DOT::DOTEdge.new('from' =&gt; &quot;#{m_full_name.gsub( /:/,'_' )}&quot;,
                                      'to' =&gt; &quot;#{mod.full_name.gsub( /:/,'_' )}&quot;,
                                      'ltail' =&gt; &quot;cluster_#{m_full_name.gsub( /:/,'_' )}&quot;,
                                      'lhead' =&gt; &quot;cluster_#{mod.full_name.gsub( /:/,'_' )}&quot;)
          else
            unless @global_names.include?(m_full_name)
              path = m_full_name.split(&quot;::&quot;)
              url = File.join('classes', *path) + &quot;.html&quot;
              @global_graph &lt;&lt; DOT::DOTNode.new('name' =&gt; &quot;#{m_full_name.gsub( /:/,'_' )}&quot;,
                                        'shape' =&gt; 'box',
                                        'label' =&gt; &quot;#{m_full_name}&quot;,
                                        'URL'   =&gt; %{&quot;#{url}&quot;})
              @global_names &lt;&lt; m_full_name
            end
            @global_graph &lt;&lt; DOT::DOTEdge.new('from' =&gt; &quot;#{m_full_name.gsub( /:/,'_' )}&quot;,
                                      'to' =&gt; &quot;#{mod.full_name.gsub( /:/,'_' )}&quot;,
                                      'lhead' =&gt; &quot;cluster_#{mod.full_name.gsub( /:/,'_' )}&quot;)
          end
        end
      end
    end

    def add_classes(container, graph, file = nil )

      use_fileboxes = Options.instance.fileboxes

      files = {}

      # create dummy node (needed if empty and for module includes)
      if container.full_name
        graph &lt;&lt; DOT::DOTNode.new('name'     =&gt; &quot;#{container.full_name.gsub( /:/,'_' )}&quot;,
                                  'label'    =&gt; &quot;&quot;,
                                  'width'  =&gt; (container.classes.empty? and 
                                               container.modules.empty?) ? 
                                  '0.75' : '0.01',
                                  'height' =&gt; '0.01',
                                  'shape' =&gt; 'plaintext')
      end
      container.classes.each_with_index do |cl, cl_index|
        last_file = cl.in_files[-1].file_relative_name

        if use_fileboxes &amp;&amp; !files.include?(last_file)
          @counter += 1
          files[last_file] =
            DOT::DOTSubgraph.new('name'     =&gt; &quot;cluster_#{@counter}&quot;,
                                 'label'    =&gt; &quot;#{last_file}&quot;,
                                 'fontname' =&gt; FONT,
                                 'color'=&gt;
                                 last_file == file ? 'red' : 'black')
        end

        next if cl.name == 'Object' || cl.name[0,2] == &quot;&lt;&lt;&quot;

        url = cl.http_url(&quot;classes&quot;)
        
        label = cl.name.dup
        if use_fileboxes &amp;&amp; cl.in_files.length &gt; 1
          label &lt;&lt;  '\n[' + 
                        cl.in_files.collect {|i|
                             i.file_relative_name 
                        }.sort.join( '\n' ) +
                    ']'
        end 
                
        attrs = {
          'name' =&gt; &quot;#{cl.full_name.gsub( /:/, '_' )}&quot;,
          'fontcolor' =&gt; 'black',
          'style'=&gt;'filled',
          'color'=&gt;'palegoldenrod',
          'label' =&gt; label,
          'shape' =&gt; 'ellipse',
          'URL'   =&gt; %{&quot;#{url}&quot;}
        }

        c = DOT::DOTNode.new(attrs)
        
        if use_fileboxes
          files[last_file].push c 
        else
          graph &lt;&lt; c
        end
      end
      
      if use_fileboxes
        files.each_value do |val|
          graph &lt;&lt; val
        end
      end
      
      unless container.classes.empty?
        container.classes.each_with_index do |cl, cl_index|
          cl.includes.each do |m|
            m_full_name = find_full_name(m.name, cl)
            if @local_names.include?(m_full_name)
              @global_graph &lt;&lt; DOT::DOTEdge.new('from' =&gt; &quot;#{m_full_name.gsub( /:/,'_' )}&quot;,
                                      'to' =&gt; &quot;#{cl.full_name.gsub( /:/,'_' )}&quot;,
                                      'ltail' =&gt; &quot;cluster_#{m_full_name.gsub( /:/,'_' )}&quot;)
            else
              unless @global_names.include?(m_full_name)
                path = m_full_name.split(&quot;::&quot;)
                url = File.join('classes', *path) + &quot;.html&quot;
                @global_graph &lt;&lt; DOT::DOTNode.new('name' =&gt; &quot;#{m_full_name.gsub( /:/,'_' )}&quot;,
                                          'shape' =&gt; 'box',
                                          'label' =&gt; &quot;#{m_full_name}&quot;,
                                          'URL'   =&gt; %{&quot;#{url}&quot;})
                @global_names &lt;&lt; m_full_name
              end
              @global_graph &lt;&lt; DOT::DOTEdge.new('from' =&gt; &quot;#{m_full_name.gsub( /:/,'_' )}&quot;,
                                      'to' =&gt; &quot;#{cl.full_name.gsub( /:/, '_')}&quot;)
            end
          end

          sclass = cl.superclass
          next if sclass.nil? || sclass == 'Object'
          sclass_full_name = find_full_name(sclass,cl)
          unless @local_names.include?(sclass_full_name) or @global_names.include?(sclass_full_name)
            path = sclass_full_name.split(&quot;::&quot;)
            url = File.join('classes', *path) + &quot;.html&quot;
            @global_graph &lt;&lt; DOT::DOTNode.new(
                       'name' =&gt; &quot;#{sclass_full_name.gsub( /:/, '_' )}&quot;,
                       'label' =&gt; sclass_full_name,
                       'URL'   =&gt; %{&quot;#{url}&quot;})
            @global_names &lt;&lt; sclass_full_name
          end
          @global_graph &lt;&lt; DOT::DOTEdge.new('from' =&gt; &quot;#{sclass_full_name.gsub( /:/,'_' )}&quot;,
                                    'to' =&gt; &quot;#{cl.full_name.gsub( /:/, '_')}&quot;)
        end
      end

      container.modules.each do |submod|
        draw_module(submod, graph)
      end
      
    end

    def convert_to_png(file_base, graph)
      str = graph.to_s
      return @diagram_cache[str] if @diagram_cache[str]
      op_type = Options.instance.image_format
      dotfile = File.join(DOT_PATH, file_base)
      src = dotfile + &quot;.dot&quot;
      dot = dotfile + &quot;.&quot; + op_type

      unless @options.quiet
        $stderr.print &quot;.&quot;
        $stderr.flush
      end

      File.open(src, 'w+' ) do |f|
        f &lt;&lt; str &lt;&lt; &quot;\n&quot;
      end
      
      system &quot;dot&quot;, &quot;-T#{op_type}&quot;, src, &quot;-o&quot;, dot

      # Now construct the imagemap wrapper around
      # that png

      ret = wrap_in_image_map(src, dot)
      @diagram_cache[str] = ret
      return ret
    end

    # Extract the client-side image map from dot, and use it
    # to generate the imagemap proper. Return the whole
    # &lt;map&gt;..&lt;img&gt; combination, suitable for inclusion on
    # the page

    def wrap_in_image_map(src, dot)
      res = %{&lt;map id=&quot;map&quot; name=&quot;map&quot;&gt;\n}
      dot_map = `dot -Tismap #{src}`
      dot_map.each do |area|
        unless area =~ /^rectangle \((\d+),(\d+)\) \((\d+),(\d+)\) ([\/\w.]+)\s*(.*)/
          $stderr.puts &quot;Unexpected output from dot:\n#{area}&quot;
          return nil
        end
        
        xs, ys = [$1.to_i, $3.to_i], [$2.to_i, $4.to_i]
        url, area_name = $5, $6

        res &lt;&lt;  %{  &lt;area shape=&quot;rect&quot; coords=&quot;#{xs.min},#{ys.min},#{xs.max},#{ys.max}&quot; }
        res &lt;&lt;  %{     href=&quot;#{url}&quot; alt=&quot;#{area_name}&quot; /&gt;\n}
      end
      res &lt;&lt; &quot;&lt;/map&gt;\n&quot;
#      map_file = src.sub(/.dot/, '.map')
#      system(&quot;dot -Timap #{src} -o #{map_file}&quot;)
      res &lt;&lt; %{&lt;img src=&quot;#{dot}&quot; usemap=&quot;#map&quot; border=&quot;0&quot; alt=&quot;#{dot}&quot;&gt;}
      return res
    end
  end
end
</pre>
    </div>