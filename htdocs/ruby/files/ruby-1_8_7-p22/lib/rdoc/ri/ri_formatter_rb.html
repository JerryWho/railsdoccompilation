  <div id="fileHeader">
    <h1>ri_formatter.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rdoc/ri/ri_formatter.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module RI
  class TextFormatter

    attr_reader :indent
    
    def initialize(options, indent)
      @options = options
      @width   = options.width
      @indent  = indent
    end
    
    
    ######################################################################
    
    def draw_line(label=nil)
      len = @width
      len -= (label.size+1) if label
      print &quot;-&quot;*len
      if label
        print(&quot; &quot;)
        bold_print(label) 
      end
      puts
    end
    
    ######################################################################
    
    def wrap(txt,  prefix=@indent, linelen=@width)
      return unless txt &amp;&amp; !txt.empty?
      work = conv_markup(txt)
      textLen = linelen - prefix.length
      patt = Regexp.new(&quot;^(.{0,#{textLen}})[ \n]&quot;)
      next_prefix = prefix.tr(&quot;^ &quot;, &quot; &quot;)

      res = []

      while work.length &gt; textLen
        if work =~ patt
          res &lt;&lt; $1
          work.slice!(0, $&amp;.length)
        else
          res &lt;&lt; work.slice!(0, textLen)
        end
      end
      res &lt;&lt; work if work.length.nonzero?
      puts(prefix + res.join(&quot;\n&quot; + next_prefix))
    end

    ######################################################################

    def blankline
      puts
    end
    
    ######################################################################

    # called when we want to ensure a nbew 'wrap' starts on a newline
    # Only needed for HtmlFormatter, because the rest do their
    # own line breaking

    def break_to_newline
    end
    
    ######################################################################

    def bold_print(txt)
      print txt
    end

    ######################################################################

    def raw_print_line(txt)
      puts txt
    end

    ######################################################################

    # convert HTML entities back to ASCII
    def conv_html(txt)
      txt.
          gsub(/&amp;gt;/, '&gt;').
          gsub(/&amp;lt;/, '&lt;').
          gsub(/&amp;quot;/, '&quot;').
          gsub(/&amp;amp;/, '&amp;')
          
    end

    # convert markup into display form
    def conv_markup(txt)
      txt.
          gsub(%r{&lt;tt&gt;(.*?)&lt;/tt&gt;}) { &quot;+#$1+&quot; } .
          gsub(%r{&lt;code&gt;(.*?)&lt;/code&gt;}) { &quot;+#$1+&quot; } .
          gsub(%r{&lt;b&gt;(.*?)&lt;/b&gt;}) { &quot;*#$1*&quot; } .
          gsub(%r{&lt;em&gt;(.*?)&lt;/em&gt;}) { &quot;_#$1_&quot; }
    end

    ######################################################################

    def display_list(list)
      case list.type

      when SM::ListBase::BULLET 
        prefixer = proc { |ignored| @indent + &quot;*   &quot; }

      when SM::ListBase::NUMBER,
      SM::ListBase::UPPERALPHA,
      SM::ListBase::LOWERALPHA

        start = case list.type
                when SM::ListBase::NUMBER      then 1
                when  SM::ListBase::UPPERALPHA then 'A'
                when SM::ListBase::LOWERALPHA  then 'a'
                end
        prefixer = proc do |ignored|
          res = @indent + &quot;#{start}.&quot;.ljust(4)
          start = start.succ
          res
        end
        
      when SM::ListBase::LABELED
        prefixer = proc do |li|
          li.label
        end

      when SM::ListBase::NOTE
        longest = 0
        list.contents.each do |item|
          if item.kind_of?(SM::Flow::LI) &amp;&amp; item.label.length &gt; longest
            longest = item.label.length
          end
        end

        prefixer = proc do |li|
          @indent + li.label.ljust(longest+1)
        end

      else
        fail &quot;unknown list type&quot;

      end

      list.contents.each do |item|
        if item.kind_of? SM::Flow::LI
          prefix = prefixer.call(item)
          display_flow_item(item, prefix)
        else
          display_flow_item(item)
        end
       end
    end

    ######################################################################

    def display_flow_item(item, prefix=@indent)
      case item
      when SM::Flow::P, SM::Flow::LI
        wrap(conv_html(item.body), prefix)
        blankline
        
      when SM::Flow::LIST
        display_list(item)

      when SM::Flow::VERB
        display_verbatim_flow_item(item, @indent)

      when SM::Flow::H
        display_heading(conv_html(item.text), item.level, @indent)

      when SM::Flow::RULE
        draw_line

      else
        fail &quot;Unknown flow element: #{item.class}&quot;
      end
    end

    ######################################################################

    def display_verbatim_flow_item(item, prefix=@indent)
        item.body.split(/\n/).each do |line|
          print @indent, conv_html(line), &quot;\n&quot;
        end
        blankline
    end

    ######################################################################

    def display_heading(text, level, indent)
      text = strip_attributes(text)
      case level
      when 1
        ul = &quot;=&quot; * text.length
        puts
        puts text.upcase
        puts ul
#        puts
        
      when 2
        ul = &quot;-&quot; * text.length
        puts
        puts text
        puts ul
#        puts
      else
        print indent, text, &quot;\n&quot;
      end
    end


    def display_flow(flow)
      flow.each do |f|
        display_flow_item(f)
      end
    end

    def strip_attributes(txt)
      tokens = txt.split(%r{(&lt;/?(?:b|code|em|i|tt)&gt;)})
      text = [] 
      attributes = 0
      tokens.each do |tok|
        case tok
        when %r{^&lt;/(\w+)&gt;$}, %r{^&lt;(\w+)&gt;$}
          ;
        else
          text &lt;&lt; tok
        end
      end
      text.join
    end


  end
  
  
  ######################################################################
  # Handle text with attributes. We're a base class: there are
  # different presentation classes (one, for example, uses overstrikes
  # to handle bold and underlining, while another using ANSI escape
  # sequences
  
  class AttributeFormatter &lt; TextFormatter
    
    BOLD      = 1
    ITALIC    = 2
    CODE      = 4

    ATTR_MAP = {
      &quot;b&quot;    =&gt; BOLD,
      &quot;code&quot; =&gt; CODE,
      &quot;em&quot;   =&gt; ITALIC,
      &quot;i&quot;    =&gt; ITALIC,
      &quot;tt&quot;   =&gt; CODE
    }

    # TODO: struct?
    class AttrChar
      attr_reader :char
      attr_reader :attr

      def initialize(char, attr)
        @char = char
        @attr = attr
      end
    end

    
    class AttributeString
      attr_reader :txt

      def initialize
        @txt = []
        @optr = 0
      end

      def &lt;&lt;(char)
        @txt &lt;&lt; char
      end

      def empty?
        @optr &gt;= @txt.length
      end

      # accept non space, then all following spaces
      def next_word
        start = @optr
        len = @txt.length

        while @optr &lt; len &amp;&amp; @txt[@optr].char != &quot; &quot;
          @optr += 1
        end

        while @optr &lt; len &amp;&amp; @txt[@optr].char == &quot; &quot;
          @optr += 1
        end

        @txt[start...@optr]
      end
    end

    ######################################################################
    # overrides base class. Looks for &lt;tt&gt;...&lt;/tt&gt; etc sequences
    # and generates an array of AttrChars. This array is then used
    # as the basis for the split

    def wrap(txt,  prefix=@indent, linelen=@width)
      return unless txt &amp;&amp; !txt.empty?

      txt = add_attributes_to(txt)
      next_prefix = prefix.tr(&quot;^ &quot;, &quot; &quot;)
      linelen -= prefix.size

      line = []

      until txt.empty?
        word = txt.next_word
        if word.size + line.size &gt; linelen
          write_attribute_text(prefix, line)
          prefix = next_prefix
          line = []
        end
        line.concat(word)
      end

      write_attribute_text(prefix, line) if line.length &gt; 0
    end

    protected

    # overridden in specific formatters

    def write_attribute_text(prefix, line)
      print prefix
      line.each do |achar|
        print achar.char
      end
      puts
    end

    # again, overridden

    def bold_print(txt)
      print txt
    end

    private

    def add_attributes_to(txt)
      tokens = txt.split(%r{(&lt;/?(?:b|code|em|i|tt)&gt;)})
      text = AttributeString.new
      attributes = 0
      tokens.each do |tok|
        case tok
        when %r{^&lt;/(\w+)&gt;$} then attributes &amp;= ~(ATTR_MAP[$1]||0)
        when %r{^&lt;(\w+)&gt;$}  then attributes  |= (ATTR_MAP[$1]||0)
        else
          tok.split(//).each {|ch| text &lt;&lt; AttrChar.new(ch, attributes)}
        end
      end
      text
    end

  end


  ##################################################
  
  # This formatter generates overstrike-style formatting, which
  # works with pagers such as man and less.

  class OverstrikeFormatter &lt; AttributeFormatter

    BS = &quot;\C-h&quot;

    def write_attribute_text(prefix, line)
      print prefix
      line.each do |achar|
        attr = achar.attr
        if (attr &amp; (ITALIC+CODE)) != 0
          print &quot;_&quot;, BS
        end
        if (attr &amp; BOLD) != 0
          print achar.char, BS
        end
        print achar.char
      end
      puts
    end

    # draw a string in bold
    def bold_print(text)
      text.split(//).each do |ch|
        print ch, BS, ch
      end
    end
  end

  ##################################################
  
  # This formatter uses ANSI escape sequences
  # to colorize stuff
  # works with pages such as man and less.

  class AnsiFormatter &lt; AttributeFormatter

    def initialize(*args)
      print &quot;\033[0m&quot;
      super
    end

    def write_attribute_text(prefix, line)
      print prefix
      curr_attr = 0
      line.each do |achar|
        attr = achar.attr
        if achar.attr != curr_attr
          update_attributes(achar.attr)
          curr_attr = achar.attr
        end
        print achar.char
      end
      update_attributes(0) unless curr_attr.zero?
      puts
    end


    def bold_print(txt)
      print &quot;\033[1m#{txt}\033[m&quot;
    end

    HEADINGS = {
      1 =&gt; [ &quot;\033[1;32m&quot;, &quot;\033[m&quot; ] ,
      2 =&gt; [&quot;\033[4;32m&quot;, &quot;\033[m&quot; ],
      3 =&gt; [&quot;\033[32m&quot;, &quot;\033[m&quot; ]
    }

    def display_heading(text, level, indent)
      level = 3 if level &gt; 3
      heading = HEADINGS[level]
      print indent
      print heading[0]
      print strip_attributes(text)
      puts heading[1]
    end
    
    private

    ATTR_MAP = {
      BOLD   =&gt; &quot;1&quot;,
      ITALIC =&gt; &quot;33&quot;,
      CODE   =&gt; &quot;36&quot;
    }

    def update_attributes(attr)
      str = &quot;\033[&quot;
      for quality in [ BOLD, ITALIC, CODE]
        unless (attr &amp; quality).zero?
          str &lt;&lt; ATTR_MAP[quality]
        end
      end
      print str, &quot;m&quot;
    end
  end

  ##################################################
  
  # This formatter uses HTML.

  class HtmlFormatter &lt; AttributeFormatter

    def initialize(*args)
      super
    end

    def write_attribute_text(prefix, line)
      curr_attr = 0
      line.each do |achar|
        attr = achar.attr
        if achar.attr != curr_attr
          update_attributes(curr_attr, achar.attr)
          curr_attr = achar.attr
        end
        print(escape(achar.char))
      end
      update_attributes(curr_attr, 0) unless curr_attr.zero?
    end

    def draw_line(label=nil)
      if label != nil
        bold_print(label)
      end
      puts(&quot;&lt;hr&gt;&quot;)
    end

    def bold_print(txt)
      tag(&quot;b&quot;) { txt }
    end

    def blankline()
      puts(&quot;&lt;p&gt;&quot;)
    end

    def break_to_newline
      puts(&quot;&lt;br&gt;&quot;)
    end

    def display_heading(text, level, indent)
      level = 4 if level &gt; 4
      tag(&quot;h#{level}&quot;) { text }
      puts
    end
    
    ######################################################################

    def display_list(list)

      case list.type
      when SM::ListBase::BULLET 
        list_type = &quot;ul&quot;
        prefixer = proc { |ignored| &quot;&lt;li&gt;&quot; }

      when SM::ListBase::NUMBER,
      SM::ListBase::UPPERALPHA,
      SM::ListBase::LOWERALPHA
        list_type = &quot;ol&quot;
        prefixer = proc { |ignored| &quot;&lt;li&gt;&quot; }
        
      when SM::ListBase::LABELED
        list_type = &quot;dl&quot;
        prefixer = proc do |li|
          &quot;&lt;dt&gt;&lt;b&gt;&quot; + escape(li.label) + &quot;&lt;/b&gt;&lt;dd&gt;&quot;
        end

      when SM::ListBase::NOTE
        list_type = &quot;table&quot;
        prefixer = proc do |li|
          %{&lt;tr valign=&quot;top&quot;&gt;&lt;td&gt;#{li.label.gsub(/ /, '&amp;nbsp;')}&lt;/td&gt;&lt;td&gt;}
        end
      else
        fail &quot;unknown list type&quot;
      end

      print &quot;&lt;#{list_type}&gt;&quot;
      list.contents.each do |item|
        if item.kind_of? SM::Flow::LI
          prefix = prefixer.call(item)
          print prefix
          display_flow_item(item, prefix)
        else
          display_flow_item(item)
        end
      end
      print &quot;&lt;/#{list_type}&gt;&quot;
    end

    def display_verbatim_flow_item(item, prefix=@indent)
        print(&quot;&lt;pre&gt;&quot;)
        puts item.body
        puts(&quot;&lt;/pre&gt;&quot;)
    end

    private

    ATTR_MAP = {
      BOLD   =&gt; &quot;b&gt;&quot;,
      ITALIC =&gt; &quot;i&gt;&quot;,
      CODE   =&gt; &quot;tt&gt;&quot;
    }

    def update_attributes(current, wanted)
      str = &quot;&quot;
      # first turn off unwanted ones
      off = current &amp; ~wanted
      for quality in [ BOLD, ITALIC, CODE]
        if (off &amp; quality) &gt; 0
          str &lt;&lt; &quot;&lt;/&quot; + ATTR_MAP[quality]
        end
      end

      # now turn on wanted
      for quality in [ BOLD, ITALIC, CODE]
        unless (wanted &amp; quality).zero?
          str &lt;&lt; &quot;&lt;&quot; &lt;&lt; ATTR_MAP[quality]
        end
      end
      print str
    end

    def tag(code)
        print(&quot;&lt;#{code}&gt;&quot;)
        print(yield)
        print(&quot;&lt;/#{code}&gt;&quot;)
    end

    def escape(str)
      str.
          gsub(/&amp;/n, '&amp;amp;').
          gsub(/\&quot;/n, '&amp;quot;').
          gsub(/&gt;/n, '&amp;gt;').
          gsub(/&lt;/n, '&amp;lt;')
    end

  end

  ##################################################
  
  # This formatter reduces extra lines for a simpler output.
  # It improves way output looks for tools like IRC bots.

  class SimpleFormatter &lt; TextFormatter

    ######################################################################

    # No extra blank lines

    def blankline
    end

    ######################################################################

    # Display labels only, no lines

    def draw_line(label=nil)
      unless label.nil? then
        bold_print(label) 
        puts
      end
    end

    ######################################################################

    # Place heading level indicators inline with heading.

    def display_heading(text, level, indent)
      text = strip_attributes(text)
      case level
      when 1
        puts &quot;= &quot; + text.upcase
      when 2
        puts &quot;-- &quot; + text
      else
        print indent, text, &quot;\n&quot;
      end
    end

  end


  # Finally, fill in the list of known formatters

  class TextFormatter

    FORMATTERS = {
      &quot;ansi&quot;   =&gt; AnsiFormatter,
      &quot;bs&quot;     =&gt; OverstrikeFormatter,
      &quot;html&quot;   =&gt; HtmlFormatter,
      &quot;plain&quot;  =&gt; TextFormatter,
      &quot;simple&quot; =&gt; SimpleFormatter,
    }
      
    def TextFormatter.list
      FORMATTERS.keys.sort.join(&quot;, &quot;)
    end

    def TextFormatter.for(name)
      FORMATTERS[name.downcase]
    end

  end

end


</pre>
    </div>