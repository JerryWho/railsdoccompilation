  <div id="fileHeader">
    <h1>to_flow.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rdoc/markup/simple_markup/to_flow.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rdoc/markup/simple_markup/fragments'
require 'rdoc/markup/simple_markup/inline'
require 'cgi'

module SM

  module Flow
    P = Struct.new(:body)
    VERB = Struct.new(:body)
    RULE = Struct.new(:width)
    class LIST
      attr_reader :type, :contents
      def initialize(type)
        @type = type
        @contents = []
      end
      def &lt;&lt;(stuff)
        @contents &lt;&lt; stuff
      end
    end
    LI = Struct.new(:label, :body)
    H = Struct.new(:level, :text)
  end

  class ToFlow
    LIST_TYPE_TO_HTML = {
      SM::ListBase::BULLET     =&gt;  [ &quot;&lt;ul&gt;&quot;, &quot;&lt;/ul&gt;&quot; ],
      SM::ListBase::NUMBER     =&gt;  [ &quot;&lt;ol&gt;&quot;, &quot;&lt;/ol&gt;&quot; ],
      SM::ListBase::UPPERALPHA =&gt;  [ &quot;&lt;ol&gt;&quot;, &quot;&lt;/ol&gt;&quot; ],
      SM::ListBase::LOWERALPHA =&gt;  [ &quot;&lt;ol&gt;&quot;, &quot;&lt;/ol&gt;&quot; ],
      SM::ListBase::LABELED    =&gt;  [ &quot;&lt;dl&gt;&quot;, &quot;&lt;/dl&gt;&quot; ],
      SM::ListBase::NOTE       =&gt;  [ &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
    }

    InlineTag = Struct.new(:bit, :on, :off)

    def initialize
      init_tags
    end

    ##
    # Set up the standard mapping of attributes to HTML tags
    #
    def init_tags
      @attr_tags = [
        InlineTag.new(SM::Attribute.bitmap_for(:BOLD), &quot;&lt;b&gt;&quot;, &quot;&lt;/b&gt;&quot;),
        InlineTag.new(SM::Attribute.bitmap_for(:TT),   &quot;&lt;tt&gt;&quot;, &quot;&lt;/tt&gt;&quot;),
        InlineTag.new(SM::Attribute.bitmap_for(:EM),   &quot;&lt;em&gt;&quot;, &quot;&lt;/em&gt;&quot;),
      ]
    end

    ##
    # Add a new set of HTML tags for an attribute. We allow
    # separate start and end tags for flexibility
    #
    def add_tag(name, start, stop)
      @attr_tags &lt;&lt; InlineTag.new(SM::Attribute.bitmap_for(name), start, stop)
    end

    ##
    # Given an HTML tag, decorate it with class information
    # and the like if required. This is a no-op in the base
    # class, but is overridden in HTML output classes that
    # implement style sheets

    def annotate(tag)
      tag
    end

    ## 
    # Here's the client side of the visitor pattern

    def start_accepting
      @res = []
      @list_stack = []
    end

    def end_accepting
      @res
    end

    def accept_paragraph(am, fragment)
      @res &lt;&lt; Flow::P.new((convert_flow(am.flow(fragment.txt))))
    end

    def accept_verbatim(am, fragment)
      @res &lt;&lt; Flow::VERB.new((convert_flow(am.flow(fragment.txt))))
    end

    def accept_rule(am, fragment)
      size = fragment.param
      size = 10 if size &gt; 10
      @res &lt;&lt; Flow::RULE.new(size)
    end

    def accept_list_start(am, fragment)
      @list_stack.push(@res)
      list = Flow::LIST.new(fragment.type)
      @res &lt;&lt; list
      @res = list
    end

    def accept_list_end(am, fragment)
      @res = @list_stack.pop
    end

    def accept_list_item(am, fragment)
      @res &lt;&lt; Flow::LI.new(fragment.param, convert_flow(am.flow(fragment.txt)))
    end

    def accept_blank_line(am, fragment)
      # @res &lt;&lt; annotate(&quot;&lt;p /&gt;&quot;) &lt;&lt; &quot;\n&quot;
    end

    def accept_heading(am, fragment)
      @res &lt;&lt; Flow::H.new(fragment.head_level, convert_flow(am.flow(fragment.txt)))
    end


    #######################################################################

    private

    #######################################################################

    def on_tags(res, item)
      attr_mask = item.turn_on
      return if attr_mask.zero?

      @attr_tags.each do |tag|
        if attr_mask &amp; tag.bit != 0
          res &lt;&lt; annotate(tag.on)
        end
      end
    end

    def off_tags(res, item)
      attr_mask = item.turn_off
      return if attr_mask.zero?

      @attr_tags.reverse_each do |tag|
        if attr_mask &amp; tag.bit != 0
          res &lt;&lt; annotate(tag.off)
        end
      end
    end

    def convert_flow(flow)
      res = &quot;&quot;
      flow.each do |item|
        case item
        when String
          res &lt;&lt; convert_string(item)
        when AttrChanger
          off_tags(res, item)
          on_tags(res,  item)
        when Special
          res &lt;&lt; convert_special(item)
        else
          raise &quot;Unknown flow element: #{item.inspect}&quot;
        end
      end
      res
    end

    # some of these patterns are taken from SmartyPants...

    def convert_string(item)
      CGI.escapeHTML(item)
    end

    def convert_special(special)
      handled = false
      Attribute.each_name_of(special.type) do |name|
        method_name = &quot;handle_special_#{name}&quot;
        if self.respond_to? method_name
          special.text = send(method_name, special)
          handled = true
        end
      end
      raise &quot;Unhandled special: #{special}&quot; unless handled
      special.text
    end


  end

end
</pre>
    </div>