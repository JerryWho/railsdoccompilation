  <div id="fileHeader">
    <h1>to_html.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/rdoc/markup/simple_markup/to_html.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rdoc/markup/simple_markup/fragments'
require 'rdoc/markup/simple_markup/inline'

require 'cgi'

module SM

  class ToHtml

    LIST_TYPE_TO_HTML = {
      ListBase::BULLET =&gt;  [ &quot;&lt;ul&gt;&quot;, &quot;&lt;/ul&gt;&quot; ],
      ListBase::NUMBER =&gt;  [ &quot;&lt;ol&gt;&quot;, &quot;&lt;/ol&gt;&quot; ],
      ListBase::UPPERALPHA =&gt;  [ &quot;&lt;ol&gt;&quot;, &quot;&lt;/ol&gt;&quot; ],
      ListBase::LOWERALPHA =&gt;  [ &quot;&lt;ol&gt;&quot;, &quot;&lt;/ol&gt;&quot; ],
      ListBase::LABELED =&gt; [ &quot;&lt;dl&gt;&quot;, &quot;&lt;/dl&gt;&quot; ],
      ListBase::NOTE    =&gt; [ &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
    }

    InlineTag = Struct.new(:bit, :on, :off)

    def initialize
      init_tags
    end

    ##
    # Set up the standard mapping of attributes to HTML tags
    #
    def init_tags
      @attr_tags = [
        InlineTag.new(SM::Attribute.bitmap_for(:BOLD), &quot;&lt;b&gt;&quot;, &quot;&lt;/b&gt;&quot;),
        InlineTag.new(SM::Attribute.bitmap_for(:TT),   &quot;&lt;tt&gt;&quot;, &quot;&lt;/tt&gt;&quot;),
        InlineTag.new(SM::Attribute.bitmap_for(:EM),   &quot;&lt;em&gt;&quot;, &quot;&lt;/em&gt;&quot;),
      ]
    end

    ##
    # Add a new set of HTML tags for an attribute. We allow
    # separate start and end tags for flexibility
    #
    def add_tag(name, start, stop)
      @attr_tags &lt;&lt; InlineTag.new(SM::Attribute.bitmap_for(name), start, stop)
    end

    ##
    # Given an HTML tag, decorate it with class information
    # and the like if required. This is a no-op in the base
    # class, but is overridden in HTML output classes that
    # implement style sheets

    def annotate(tag)
      tag
    end

    ## 
    # Here's the client side of the visitor pattern

    def start_accepting
      @res = &quot;&quot;
      @in_list_entry = []
    end

    def end_accepting
      @res
    end

    def accept_paragraph(am, fragment)
      @res &lt;&lt; annotate(&quot;&lt;p&gt;&quot;) + &quot;\n&quot;
      @res &lt;&lt; wrap(convert_flow(am.flow(fragment.txt)))
      @res &lt;&lt; annotate(&quot;&lt;/p&gt;&quot;) + &quot;\n&quot;
    end

    def accept_verbatim(am, fragment)
      @res &lt;&lt; annotate(&quot;&lt;pre&gt;&quot;) + &quot;\n&quot;
      @res &lt;&lt; CGI.escapeHTML(fragment.txt)
      @res &lt;&lt; annotate(&quot;&lt;/pre&gt;&quot;) &lt;&lt; &quot;\n&quot;
    end

    def accept_rule(am, fragment)
      size = fragment.param
      size = 10 if size &gt; 10
      @res &lt;&lt; &quot;&lt;hr size=\&quot;#{size}\&quot;&gt;&lt;/hr&gt;&quot;
    end

    def accept_list_start(am, fragment)
      @res &lt;&lt; html_list_name(fragment.type, true) &lt;&lt;&quot;\n&quot;
      @in_list_entry.push false
    end

    def accept_list_end(am, fragment)
      if tag = @in_list_entry.pop
        @res &lt;&lt; annotate(tag) &lt;&lt; &quot;\n&quot;
      end
      @res &lt;&lt; html_list_name(fragment.type, false) &lt;&lt;&quot;\n&quot;
    end

    def accept_list_item(am, fragment)
      if tag = @in_list_entry.last
        @res &lt;&lt; annotate(tag) &lt;&lt; &quot;\n&quot;
      end
      @res &lt;&lt; list_item_start(am, fragment)
      @res &lt;&lt; wrap(convert_flow(am.flow(fragment.txt))) &lt;&lt; &quot;\n&quot;
      @in_list_entry[-1] = list_end_for(fragment.type)
    end

    def accept_blank_line(am, fragment)
      # @res &lt;&lt; annotate(&quot;&lt;p /&gt;&quot;) &lt;&lt; &quot;\n&quot;
    end

    def accept_heading(am, fragment)
      @res &lt;&lt; convert_heading(fragment.head_level, am.flow(fragment.txt))
    end

    # This is a higher speed (if messier) version of wrap

    def wrap(txt, line_len = 76)
      res = &quot;&quot;
      sp = 0
      ep = txt.length
      while sp &lt; ep
        # scan back for a space
        p = sp + line_len - 1
        if p &gt;= ep
          p = ep
        else
          while p &gt; sp and txt[p] != ?\s
            p -= 1
          end
          if p &lt;= sp
            p = sp + line_len
            while p &lt; ep and txt[p] != ?\s
              p += 1
            end
          end
        end
        res &lt;&lt; txt[sp...p] &lt;&lt; &quot;\n&quot;
        sp = p
        sp += 1 while sp &lt; ep and txt[sp] == ?\s
      end
      res
    end

    #######################################################################

    private

    #######################################################################

    def on_tags(res, item)
      attr_mask = item.turn_on
      return if attr_mask.zero?

      @attr_tags.each do |tag|
        if attr_mask &amp; tag.bit != 0
          res &lt;&lt; annotate(tag.on)
        end
      end
    end

    def off_tags(res, item)
      attr_mask = item.turn_off
      return if attr_mask.zero?

      @attr_tags.reverse_each do |tag|
        if attr_mask &amp; tag.bit != 0
          res &lt;&lt; annotate(tag.off)
        end
      end
    end

    def convert_flow(flow)
      res = &quot;&quot;
      flow.each do |item|
        case item
        when String
          res &lt;&lt; convert_string(item)
        when AttrChanger
          off_tags(res, item)
          on_tags(res,  item)
        when Special
          res &lt;&lt; convert_special(item)
        else
          raise &quot;Unknown flow element: #{item.inspect}&quot;
        end
      end
      res
    end

    # some of these patterns are taken from SmartyPants...

    def convert_string(item)
      CGI.escapeHTML(item).
      
      
      # convert -- to em-dash, (-- to en-dash)
        gsub(/---?/, '&amp;#8212;'). #gsub(/--/, '&amp;#8211;').

      # convert ... to elipsis (and make sure .... becomes .&lt;elipsis&gt;)
        gsub(/\.\.\.\./, '.&amp;#8230;').gsub(/\.\.\./, '&amp;#8230;').

      # convert single closing quote
        gsub(%r{([^ \t\r\n\[\{\(])\'}) { &quot;#$1&amp;#8217;&quot; }.
        gsub(%r{\'(?=\W|s\b)}) { &quot;&amp;#8217;&quot; }.

      # convert single opening quote
        gsub(/'/, '&amp;#8216;').

      # convert double closing quote
        gsub(%r{([^ \t\r\n\[\{\(])\'(?=\W)}) { &quot;#$1&amp;#8221;&quot; }.

      # convert double opening quote
        gsub(/'/, '&amp;#8220;').

      # convert copyright
        gsub(/\(c\)/, '&amp;#169;').

      # convert and registered trademark
        gsub(/\(r\)/, '&amp;#174;')

    end

    def convert_special(special)
      handled = false
      Attribute.each_name_of(special.type) do |name|
        method_name = &quot;handle_special_#{name}&quot;
        if self.respond_to? method_name
          special.text = send(method_name, special)
          handled = true
        end
      end
      raise &quot;Unhandled special: #{special}&quot; unless handled
      special.text
    end

    def convert_heading(level, flow)
      res =
        annotate(&quot;&lt;h#{level}&gt;&quot;) + 
        convert_flow(flow) + 
        annotate(&quot;&lt;/h#{level}&gt;\n&quot;)
    end

    def html_list_name(list_type, is_open_tag)
      tags = LIST_TYPE_TO_HTML[list_type] || raise(&quot;Invalid list type: #{list_type.inspect}&quot;)
      annotate(tags[ is_open_tag ? 0 : 1])
    end

    def list_item_start(am, fragment)
      case fragment.type
      when ListBase::BULLET, ListBase::NUMBER
        annotate(&quot;&lt;li&gt;&quot;)

      when ListBase::UPPERALPHA
	annotate(&quot;&lt;li type=\&quot;A\&quot;&gt;&quot;)

      when ListBase::LOWERALPHA
	annotate(&quot;&lt;li type=\&quot;a\&quot;&gt;&quot;)

      when ListBase::LABELED
        annotate(&quot;&lt;dt&gt;&quot;) +
          convert_flow(am.flow(fragment.param)) + 
          annotate(&quot;&lt;/dt&gt;&quot;) +
          annotate(&quot;&lt;dd&gt;&quot;)

      when ListBase::NOTE
        annotate(&quot;&lt;tr&gt;&quot;) +
          annotate(&quot;&lt;td valign=\&quot;top\&quot;&gt;&quot;) +
          convert_flow(am.flow(fragment.param)) + 
          annotate(&quot;&lt;/td&gt;&quot;) +
          annotate(&quot;&lt;td&gt;&quot;)
      else
        raise &quot;Invalid list type&quot;
      end
    end

    def list_end_for(fragment_type)
      case fragment_type
      when ListBase::BULLET, ListBase::NUMBER, ListBase::UPPERALPHA, ListBase::LOWERALPHA
        &quot;&lt;/li&gt;&quot;
      when ListBase::LABELED
        &quot;&lt;/dd&gt;&quot;
      when ListBase::NOTE
        &quot;&lt;/td&gt;&lt;/tr&gt;&quot;
      else
        raise &quot;Invalid list type&quot;
      end
    end

  end

end
</pre>
    </div>