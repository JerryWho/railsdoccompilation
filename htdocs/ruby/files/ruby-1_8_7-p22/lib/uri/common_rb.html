  <div id="fileHeader">
    <h1>common.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/uri/common.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 10 03:31:55 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># = uri/common.rb
#
# Author:: Akira Yamada &lt;akira@ruby-lang.org&gt;
# Revision:: $Id: common.rb 14178 2007-12-10 09:31:55Z matz $
# License:: 
#   You can redistribute it and/or modify it under the same term as Ruby.
#

module URI
  module REGEXP
    #
    # Patterns used to parse URI's
    #
    module PATTERN
      # :stopdoc:

      # RFC 2396 (URI Generic Syntax)
      # RFC 2732 (IPv6 Literal Addresses in URL's)
      # RFC 2373 (IPv6 Addressing Architecture)

      # alpha         = lowalpha | upalpha
      ALPHA = &quot;a-zA-Z&quot;
      # alphanum      = alpha | digit
      ALNUM = &quot;#{ALPHA}\\d&quot;

      # hex           = digit | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; |
      #                         &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
      HEX     = &quot;a-fA-F\\d&quot;
      # escaped       = &quot;%&quot; hex hex
      ESCAPED = &quot;%[#{HEX}]{2}&quot;
      # mark          = &quot;-&quot; | &quot;_&quot; | &quot;.&quot; | &quot;!&quot; | &quot;~&quot; | &quot;*&quot; | &quot;'&quot; |
      #                 &quot;(&quot; | &quot;)&quot;
      # unreserved    = alphanum | mark
      UNRESERVED = &quot;-_.!~*'()#{ALNUM}&quot;
      # reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; |
      #                 &quot;$&quot; | &quot;,&quot;
      # reserved      = &quot;;&quot; | &quot;/&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | 
      #                 &quot;$&quot; | &quot;,&quot; | &quot;[&quot; | &quot;]&quot; (RFC 2732)
      RESERVED = &quot;;/?:@&amp;=+$,\\[\\]&quot;

      # uric          = reserved | unreserved | escaped
      URIC = &quot;(?:[#{UNRESERVED}#{RESERVED}]|#{ESCAPED})&quot;
      # uric_no_slash = unreserved | escaped | &quot;;&quot; | &quot;?&quot; | &quot;:&quot; | &quot;@&quot; |
      #                 &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
      URIC_NO_SLASH = &quot;(?:[#{UNRESERVED};?:@&amp;=+$,]|#{ESCAPED})&quot;
      # query         = *uric
      QUERY = &quot;#{URIC}*&quot;
      # fragment      = *uric
      FRAGMENT = &quot;#{URIC}*&quot;

      # domainlabel   = alphanum | alphanum *( alphanum | &quot;-&quot; ) alphanum
      DOMLABEL = &quot;(?:[#{ALNUM}](?:[-#{ALNUM}]*[#{ALNUM}])?)&quot;
      # toplabel      = alpha | alpha *( alphanum | &quot;-&quot; ) alphanum
      TOPLABEL = &quot;(?:[#{ALPHA}](?:[-#{ALNUM}]*[#{ALNUM}])?)&quot;
      # hostname      = *( domainlabel &quot;.&quot; ) toplabel [ &quot;.&quot; ]
      HOSTNAME = &quot;(?:#{DOMLABEL}\\.)*#{TOPLABEL}\\.?&quot;

      # RFC 2373, APPENDIX B:
      # IPv6address = hexpart [ &quot;:&quot; IPv4address ]
      # IPv4address   = 1*3DIGIT &quot;.&quot; 1*3DIGIT &quot;.&quot; 1*3DIGIT &quot;.&quot; 1*3DIGIT
      # hexpart = hexseq | hexseq &quot;::&quot; [ hexseq ] | &quot;::&quot; [ hexseq ]
      # hexseq  = hex4 *( &quot;:&quot; hex4)
      # hex4    = 1*4HEXDIG
      #
      # XXX: This definition has a flaw. &quot;::&quot; + IPv4address must be
      # allowed too.  Here is a replacement.
      #
      # IPv4address = 1*3DIGIT &quot;.&quot; 1*3DIGIT &quot;.&quot; 1*3DIGIT &quot;.&quot; 1*3DIGIT
      IPV4ADDR = &quot;\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}&quot;
      # hex4     = 1*4HEXDIG
      HEX4 = &quot;[#{HEX}]{1,4}&quot;
      # lastpart = hex4 | IPv4address
      LASTPART = &quot;(?:#{HEX4}|#{IPV4ADDR})&quot;
      # hexseq1  = *( hex4 &quot;:&quot; ) hex4
      HEXSEQ1 = &quot;(?:#{HEX4}:)*#{HEX4}&quot;
      # hexseq2  = *( hex4 &quot;:&quot; ) lastpart
      HEXSEQ2 = &quot;(?:#{HEX4}:)*#{LASTPART}&quot;
      # IPv6address = hexseq2 | [ hexseq1 ] &quot;::&quot; [ hexseq2 ]
      IPV6ADDR = &quot;(?:#{HEXSEQ2}|(?:#{HEXSEQ1})?::(?:#{HEXSEQ2})?)&quot;

      # IPv6prefix  = ( hexseq1 | [ hexseq1 ] &quot;::&quot; [ hexseq1 ] ) &quot;/&quot; 1*2DIGIT
      # unused

      # ipv6reference = &quot;[&quot; IPv6address &quot;]&quot; (RFC 2732)
      IPV6REF = &quot;\\[#{IPV6ADDR}\\]&quot;

      # host          = hostname | IPv4address
      # host          = hostname | IPv4address | IPv6reference (RFC 2732)
      HOST = &quot;(?:#{HOSTNAME}|#{IPV4ADDR}|#{IPV6REF})&quot;
      # port          = *digit
      PORT = '\d*'
      # hostport      = host [ &quot;:&quot; port ]
      HOSTPORT = &quot;#{HOST}(?::#{PORT})?&quot;

      # userinfo      = *( unreserved | escaped |
      #                    &quot;;&quot; | &quot;:&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )
      USERINFO = &quot;(?:[#{UNRESERVED};:&amp;=+$,]|#{ESCAPED})*&quot;

      # pchar         = unreserved | escaped |
      #                 &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot;
      PCHAR = &quot;(?:[#{UNRESERVED}:@&amp;=+$,]|#{ESCAPED})&quot;
      # param         = *pchar
      PARAM = &quot;#{PCHAR}*&quot;
      # segment       = *pchar *( &quot;;&quot; param )
      SEGMENT = &quot;#{PCHAR}*(?:;#{PARAM})*&quot;
      # path_segments = segment *( &quot;/&quot; segment )
      PATH_SEGMENTS = &quot;#{SEGMENT}(?:/#{SEGMENT})*&quot;

      # server        = [ [ userinfo &quot;@&quot; ] hostport ]
      SERVER = &quot;(?:#{USERINFO}@)?#{HOSTPORT}&quot;
      # reg_name      = 1*( unreserved | escaped | &quot;$&quot; | &quot;,&quot; |
      #                     &quot;;&quot; | &quot;:&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; )
      REG_NAME = &quot;(?:[#{UNRESERVED}$,;:@&amp;=+]|#{ESCAPED})+&quot;
      # authority     = server | reg_name
      AUTHORITY = &quot;(?:#{SERVER}|#{REG_NAME})&quot;

      # rel_segment   = 1*( unreserved | escaped |
      #                     &quot;;&quot; | &quot;@&quot; | &quot;&amp;&quot; | &quot;=&quot; | &quot;+&quot; | &quot;$&quot; | &quot;,&quot; )
      REL_SEGMENT = &quot;(?:[#{UNRESERVED};@&amp;=+$,]|#{ESCAPED})+&quot;

      # scheme        = alpha *( alpha | digit | &quot;+&quot; | &quot;-&quot; | &quot;.&quot; )
      SCHEME = &quot;[#{ALPHA}][-+.#{ALPHA}\\d]*&quot;

      # abs_path      = &quot;/&quot;  path_segments
      ABS_PATH = &quot;/#{PATH_SEGMENTS}&quot;
      # rel_path      = rel_segment [ abs_path ]
      REL_PATH = &quot;#{REL_SEGMENT}(?:#{ABS_PATH})?&quot;
      # net_path      = &quot;//&quot; authority [ abs_path ]
      NET_PATH   = &quot;//#{AUTHORITY}(?:#{ABS_PATH})?&quot;

      # hier_part     = ( net_path | abs_path ) [ &quot;?&quot; query ]
      HIER_PART   = &quot;(?:#{NET_PATH}|#{ABS_PATH})(?:\\?(?:#{QUERY}))?&quot;
      # opaque_part   = uric_no_slash *uric
      OPAQUE_PART = &quot;#{URIC_NO_SLASH}#{URIC}*&quot;

      # absoluteURI   = scheme &quot;:&quot; ( hier_part | opaque_part )
      ABS_URI   = &quot;#{SCHEME}:(?:#{HIER_PART}|#{OPAQUE_PART})&quot;
      # relativeURI   = ( net_path | abs_path | rel_path ) [ &quot;?&quot; query ]
      REL_URI = &quot;(?:#{NET_PATH}|#{ABS_PATH}|#{REL_PATH})(?:\\?#{QUERY})?&quot;

      # URI-reference = [ absoluteURI | relativeURI ] [ &quot;#&quot; fragment ]
      URI_REF = &quot;(?:#{ABS_URI}|#{REL_URI})?(?:##{FRAGMENT})?&quot;

      # XXX:
      X_ABS_URI = &quot;
        (#{PATTERN::SCHEME}):                     (?# 1: scheme)
        (?:
           (#{PATTERN::OPAQUE_PART})              (?# 2: opaque)
        |
           (?:(?:
             //(?:
                 (?:(?:(#{PATTERN::USERINFO})@)?  (?# 3: userinfo)
                   (?:(#{PATTERN::HOST})(?::(\\d*))?))?(?# 4: host, 5: port)
               |
                 (#{PATTERN::REG_NAME})           (?# 6: registry)
               )
             |
             (?!//))                              (?# XXX: '//' is the mark for hostport)
             (#{PATTERN::ABS_PATH})?              (?# 7: path)
           )(?:\\?(#{PATTERN::QUERY}))?           (?# 8: query)
        )
        (?:\\#(#{PATTERN::FRAGMENT}))?            (?# 9: fragment)
      &quot;
      X_REL_URI = &quot;
        (?:
          (?:
            //
            (?:
              (?:(#{PATTERN::USERINFO})@)?       (?# 1: userinfo)
                (#{PATTERN::HOST})?(?::(\\d*))?  (?# 2: host, 3: port)
            |
              (#{PATTERN::REG_NAME})             (?# 4: registry)
            )
          )
        |
          (#{PATTERN::REL_SEGMENT})              (?# 5: rel_segment)
        )?
        (#{PATTERN::ABS_PATH})?                  (?# 6: abs_path)
        (?:\\?(#{PATTERN::QUERY}))?              (?# 7: query)
        (?:\\#(#{PATTERN::FRAGMENT}))?           (?# 8: fragment)
      &quot;
      # :startdoc:
    end # PATTERN

    # :stopdoc:

    # for URI::split
    ABS_URI = Regexp.new('^' + PATTERN::X_ABS_URI + '$', #'
                         Regexp::EXTENDED, 'N').freeze
    REL_URI = Regexp.new('^' + PATTERN::X_REL_URI + '$', #'
                         Regexp::EXTENDED, 'N').freeze

    # for URI::extract
    URI_REF     = Regexp.new(PATTERN::URI_REF, false, 'N').freeze
    ABS_URI_REF = Regexp.new(PATTERN::X_ABS_URI, Regexp::EXTENDED, 'N').freeze
    REL_URI_REF = Regexp.new(PATTERN::X_REL_URI, Regexp::EXTENDED, 'N').freeze

    # for URI::escape/unescape
    ESCAPED = Regexp.new(PATTERN::ESCAPED, false, 'N').freeze
    UNSAFE  = Regexp.new(&quot;[^#{PATTERN::UNRESERVED}#{PATTERN::RESERVED}]&quot;,
                         false, 'N').freeze

    # for Generic#initialize
    SCHEME   = Regexp.new(&quot;^#{PATTERN::SCHEME}$&quot;, false, 'N').freeze #&quot;
    USERINFO = Regexp.new(&quot;^#{PATTERN::USERINFO}$&quot;, false, 'N').freeze #&quot;
    HOST     = Regexp.new(&quot;^#{PATTERN::HOST}$&quot;, false, 'N').freeze #&quot;
    PORT     = Regexp.new(&quot;^#{PATTERN::PORT}$&quot;, false, 'N').freeze #&quot;
    OPAQUE   = Regexp.new(&quot;^#{PATTERN::OPAQUE_PART}$&quot;, false, 'N').freeze #&quot;
    REGISTRY = Regexp.new(&quot;^#{PATTERN::REG_NAME}$&quot;, false, 'N').freeze #&quot;
    ABS_PATH = Regexp.new(&quot;^#{PATTERN::ABS_PATH}$&quot;, false, 'N').freeze #&quot;
    REL_PATH = Regexp.new(&quot;^#{PATTERN::REL_PATH}$&quot;, false, 'N').freeze #&quot;
    QUERY    = Regexp.new(&quot;^#{PATTERN::QUERY}$&quot;, false, 'N').freeze #&quot;
    FRAGMENT = Regexp.new(&quot;^#{PATTERN::FRAGMENT}$&quot;, false, 'N').freeze #&quot;
    # :startdoc:
  end # REGEXP

  module Util # :nodoc:
    def make_components_hash(klass, array_hash)
      tmp = {}
      if array_hash.kind_of?(Array) &amp;&amp;
          array_hash.size == klass.component.size - 1
        klass.component[1..-1].each_index do |i|
          begin
            tmp[klass.component[i + 1]] = array_hash[i].clone
          rescue TypeError
            tmp[klass.component[i + 1]] = array_hash[i]
          end
        end

      elsif array_hash.kind_of?(Hash)
        array_hash.each do |key, value|
          begin
            tmp[key] = value.clone
          rescue TypeError
            tmp[key] = value
          end
        end
      else
        raise ArgumentError, 
          &quot;expected Array of or Hash of components of #{klass.to_s} (#{klass.component[1..-1].join(', ')})&quot;
      end
      tmp[:scheme] = klass.to_s.sub(/\A.*::/, '').downcase

      return tmp
    end
    module_function :make_components_hash
  end

  module Escape
    include REGEXP

    #
    # == Synopsis
    #
    #   URI.escape(str [, unsafe])
    #
    # == Args
    #
    # +str+::
    #   String to replaces in.
    # +unsafe+::
    #   Regexp that matches all symbols that must be replaced with codes.
    #   By default uses &lt;tt&gt;REGEXP::UNSAFE&lt;/tt&gt;.
    #   When this argument is a String, it represents a character set.
    #
    # == Description
    #
    # Escapes the string, replacing all unsafe characters with codes.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   enc_uri = URI.escape(&quot;http://example.com/?a=\11\15&quot;)
    #   p enc_uri
    #   # =&gt; &quot;http://example.com/?a=%09%0D&quot;
    #
    #   p URI.unescape(enc_uri)
    #   # =&gt; &quot;http://example.com/?a=\t\r&quot;
    #
    #   p URI.escape(&quot;@?@!&quot;, &quot;!?&quot;)
    #   # =&gt; &quot;@%3F@%21&quot;
    #
    def escape(str, unsafe = UNSAFE)
      unless unsafe.kind_of?(Regexp)
        # perhaps unsafe is String object
        unsafe = Regexp.new(&quot;[#{Regexp.quote(unsafe)}]&quot;, false, 'N')
      end
      str.gsub(unsafe) do |us|
        tmp = ''
        us.each_byte do |uc|
          tmp &lt;&lt; sprintf('%%%02X', uc)
        end
        tmp
      end
    end
    alias encode escape
    #
    # == Synopsis
    #
    #   URI.unescape(str)
    #
    # == Args
    #
    # +str+::
    #   Unescapes the string.
    #
    # == Usage
    #
    #   require 'uri'
    #
    #   enc_uri = URI.escape(&quot;http://example.com/?a=\11\15&quot;)
    #   p enc_uri
    #   # =&gt; &quot;http://example.com/?a=%09%0D&quot;
    #
    #   p URI.unescape(enc_uri)
    #   # =&gt; &quot;http://example.com/?a=\t\r&quot;
    #
    def unescape(str)
      str.gsub(ESCAPED) do
        $&amp;[1,2].hex.chr
      end
    end
    alias decode unescape
  end

  include REGEXP
  extend Escape

  @@schemes = {}
  
  #
  # Base class for all URI exceptions.
  #
  class Error &lt; StandardError; end
  #
  # Not a URI.
  #
  class InvalidURIError &lt; Error; end
  #
  # Not a URI component.
  #
  class InvalidComponentError &lt; Error; end
  #
  # URI is valid, bad usage is not.
  #
  class BadURIError &lt; Error; end

  #
  # == Synopsis
  #
  #   URI::split(uri)
  #
  # == Args
  #
  # +uri+::
  #   String with URI.
  #
  # == Description
  #
  # Splits the string on following parts and returns array with result:
  #
  #   * Scheme
  #   * Userinfo
  #   * Host
  #   * Port
  #   * Registry
  #   * Path
  #   * Opaque
  #   * Query
  #   * Fragment
  # 
  # == Usage
  #
  #   require 'uri'
  #
  #   p URI.split(&quot;http://www.ruby-lang.org/&quot;)
  #   # =&gt; [&quot;http&quot;, nil, &quot;www.ruby-lang.org&quot;, nil, nil, &quot;/&quot;, nil, nil, nil]
  #
  def self.split(uri)
    case uri
    when ''
      # null uri

    when ABS_URI
      scheme, opaque, userinfo, host, port, 
        registry, path, query, fragment = $~[1..-1]

      # URI-reference = [ absoluteURI | relativeURI ] [ &quot;#&quot; fragment ]

      # absoluteURI   = scheme &quot;:&quot; ( hier_part | opaque_part )
      # hier_part     = ( net_path | abs_path ) [ &quot;?&quot; query ]
      # opaque_part   = uric_no_slash *uric

      # abs_path      = &quot;/&quot;  path_segments
      # net_path      = &quot;//&quot; authority [ abs_path ]

      # authority     = server | reg_name
      # server        = [ [ userinfo &quot;@&quot; ] hostport ]

      if !scheme
        raise InvalidURIError, 
          &quot;bad URI(absolute but no scheme): #{uri}&quot;
      end
      if !opaque &amp;&amp; (!path &amp;&amp; (!host &amp;&amp; !registry))
        raise InvalidURIError,
          &quot;bad URI(absolute but no path): #{uri}&quot; 
      end

    when REL_URI
      scheme = nil
      opaque = nil

      userinfo, host, port, registry, 
        rel_segment, abs_path, query, fragment = $~[1..-1]
      if rel_segment &amp;&amp; abs_path
        path = rel_segment + abs_path
      elsif rel_segment
        path = rel_segment
      elsif abs_path
        path = abs_path
      end

      # URI-reference = [ absoluteURI | relativeURI ] [ &quot;#&quot; fragment ]

      # relativeURI   = ( net_path | abs_path | rel_path ) [ &quot;?&quot; query ]

      # net_path      = &quot;//&quot; authority [ abs_path ]
      # abs_path      = &quot;/&quot;  path_segments
      # rel_path      = rel_segment [ abs_path ]

      # authority     = server | reg_name
      # server        = [ [ userinfo &quot;@&quot; ] hostport ]

    else
      raise InvalidURIError, &quot;bad URI(is not URI?): #{uri}&quot;
    end

    path = '' if !path &amp;&amp; !opaque # (see RFC2396 Section 5.2)
    ret = [
      scheme, 
      userinfo, host, port,         # X
      registry,                        # X
      path,                         # Y
      opaque,                        # Y
      query,
      fragment
    ]
    return ret
  end

  #
  # == Synopsis
  #
  #   URI::parse(uri_str)
  #
  # == Args
  #
  # +uri_str+::
  #   String with URI.
  #
  # == Description
  #
  # Creates one of the URI's subclasses instance from the string.
  #  
  # == Raises
  #
  # URI::InvalidURIError
  #   Raised if URI given is not a correct one.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   uri = URI.parse(&quot;http://www.ruby-lang.org/&quot;)
  #   p uri
  #   # =&gt; #&lt;URI::HTTP:0x202281be URL:http://www.ruby-lang.org/&gt;
  #   p uri.scheme 
  #   # =&gt; &quot;http&quot; 
  #   p uri.host 
  #   # =&gt; &quot;www.ruby-lang.org&quot; 
  # 
  def self.parse(uri)
    scheme, userinfo, host, port, 
      registry, path, opaque, query, fragment = self.split(uri)

    if scheme &amp;&amp; @@schemes.include?(scheme.upcase)
      @@schemes[scheme.upcase].new(scheme, userinfo, host, port, 
                                   registry, path, opaque, query, 
                                   fragment)
    else
      Generic.new(scheme, userinfo, host, port, 
                  registry, path, opaque, query, 
                  fragment)
    end
  end

  #
  # == Synopsis
  #
  #   URI::join(str[, str, ...])
  #
  # == Args
  #
  # +str+::
  #   String(s) to work with
  #
  # == Description
  #
  # Joins URIs.
  #
  # == Usage
  #
  #   require 'uri'
  #
  #   p URI.join(&quot;http://localhost/&quot;,&quot;main.rbx&quot;)
  #   # =&gt; #&lt;URI::HTTP:0x2022ac02 URL:http://localhost/main.rbx&gt;
  #
  def self.join(*str)
    u = self.parse(str[0])
    str[1 .. -1].each do |x|
      u = u.merge(x)
    end
    u
  end

  #
  # == Synopsis
  #
  #   URI::extract(str[, schemes][,&amp;blk])
  #
  # == Args
  #
  # +str+:: 
  #   String to extract URIs from.
  # +schemes+::
  #   Limit URI matching to a specific schemes.
  #
  # == Description
  #
  # Extracts URIs from a string. If block given, iterates through all matched URIs.
  # Returns nil if block given or array with matches.
  #
  # == Usage
  #
  #   require &quot;uri&quot;
  #
  #   URI.extract(&quot;text here http://foo.example.org/bla and here mailto:test@example.com and here also.&quot;)
  #   # =&gt; [&quot;http://foo.example.com/bla&quot;, &quot;mailto:test@example.com&quot;]
  #
  def self.extract(str, schemes = nil, &amp;block)
    if block_given?
      str.scan(regexp(schemes)) { yield $&amp; }
      nil
    else
      result = []
      str.scan(regexp(schemes)) { result.push $&amp; }
      result
    end
  end

  #
  # == Synopsis
  #
  #   URI::regexp([match_schemes])
  #
  # == Args
  #
  # +match_schemes+:: 
  #   Array of schemes. If given, resulting regexp matches to URIs
  #   whose scheme is one of the match_schemes.
  # 
  # == Description
  # Returns a Regexp object which matches to URI-like strings.
  # The Regexp object returned by this method includes arbitrary
  # number of capture group (parentheses).  Never rely on it's number.
  # 
  # == Usage
  #
  #   require 'uri'
  #
  #   # extract first URI from html_string
  #   html_string.slice(URI.regexp)
  # 
  #   # remove ftp URIs
  #   html_string.sub(URI.regexp(['ftp'])
  # 
  #   # You should not rely on the number of parentheses
  #   html_string.scan(URI.regexp) do |*matches|
  #     p $&amp;
  #   end
  #
  def self.regexp(schemes = nil)
    unless schemes
      ABS_URI_REF
    else
      /(?=#{Regexp.union(*schemes)}:)#{PATTERN::X_ABS_URI}/xn
    end
  end

end

module Kernel
  # alias for URI.parse.
  #
  # This method is introduced at 1.8.2.
  def URI(uri_str) # :doc:
    URI.parse(uri_str)
  end
  module_function :URI
end
</pre>
    </div>