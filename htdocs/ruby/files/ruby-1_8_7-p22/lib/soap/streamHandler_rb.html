  <div id="fileHeader">
    <h1>streamHandler.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/soap/streamHandler.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># SOAP4R - Stream handler.
# Copyright (C) 2000, 2001, 2003  NAKAMURA, Hiroshi &lt;nahi@ruby-lang.org&gt;.

# This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
# redistribute it and/or modify it under the same terms of Ruby's license;
# either the dual license version in 2003, or any later version.


require 'soap/soap'
require 'soap/httpconfigloader'
begin
  require 'stringio'
  require 'zlib'
rescue LoadError
  warn(&quot;Loading stringio or zlib failed.  No gzipped response support.&quot;) if $DEBUG
end


module SOAP


class StreamHandler
  RUBY_VERSION_STRING = &quot;ruby #{ RUBY_VERSION } (#{ RUBY_RELEASE_DATE }) [#{ RUBY_PLATFORM }]&quot;

  class ConnectionData
    attr_accessor :send_string
    attr_accessor :send_contenttype
    attr_accessor :receive_string
    attr_accessor :receive_contenttype
    attr_accessor :is_fault
    attr_accessor :soapaction

    def initialize(send_string = nil)
      @send_string = send_string
      @send_contenttype = nil
      @receive_string = nil
      @receive_contenttype = nil
      @is_fault = false
      @soapaction = nil
    end
  end

  def self.parse_media_type(str)
    if /^#{ MediaType }(?:\s*;\s*charset=([^&quot;]+|&quot;[^&quot;]+&quot;))?$/i !~ str
      return nil
    end
    charset = $1
    charset.gsub!(/&quot;/, '') if charset
    charset || 'us-ascii'
  end

  def self.create_media_type(charset)
    &quot;#{ MediaType }; charset=#{ charset }&quot;
  end
end


class HTTPStreamHandler &lt; StreamHandler
  include SOAP

  begin
    require 'http-access2'
    if HTTPAccess2::VERSION &lt; &quot;2.0&quot;
      raise LoadError.new(&quot;http-access/2.0 or later is required.&quot;)
    end
    Client = HTTPAccess2::Client
    RETRYABLE = true
  rescue LoadError
    warn(&quot;Loading http-access2 failed.  Net/http is used.&quot;) if $DEBUG
    require 'soap/netHttpClient'
    Client = SOAP::NetHttpClient
    RETRYABLE = false
  end


public
  
  attr_reader :client
  attr_accessor :wiredump_file_base
  
  MAX_RETRY_COUNT = 10       	# [times]

  def initialize(options)
    super()
    @client = Client.new(nil, &quot;SOAP4R/#{ Version }&quot;)
    @wiredump_file_base = nil
    @charset = @wiredump_dev = nil
    @options = options
    set_options
    @client.debug_dev = @wiredump_dev
    @cookie_store = nil
    @accept_encoding_gzip = false
  end

  def test_loopback_response
    @client.test_loopback_response
  end

  def accept_encoding_gzip=(allow)
    @accept_encoding_gzip = allow
  end

  def inspect
    &quot;#&lt;#{self.class}&gt;&quot;
  end

  def send(endpoint_url, conn_data, soapaction = nil, charset = @charset)
    conn_data.soapaction ||= soapaction # for backward conpatibility
    send_post(endpoint_url, conn_data, charset)
  end

  def reset(endpoint_url = nil)
    if endpoint_url.nil?
      @client.reset_all
    else
      @client.reset(endpoint_url)
    end
    @client.save_cookie_store if @cookie_store
  end

private

  def set_options
    HTTPConfigLoader.set_options(@client, @options)
    @charset = @options[&quot;charset&quot;] || XSD::Charset.xml_encoding_label
    @options.add_hook(&quot;charset&quot;) do |key, value|
      @charset = value
    end
    @wiredump_dev = @options[&quot;wiredump_dev&quot;]
    @options.add_hook(&quot;wiredump_dev&quot;) do |key, value|
      @wiredump_dev = value
      @client.debug_dev = @wiredump_dev
    end
    set_cookie_store_file(@options[&quot;cookie_store_file&quot;])
    @options.add_hook(&quot;cookie_store_file&quot;) do |key, value|
      set_cookie_store_file(value)
    end
    ssl_config = @options[&quot;ssl_config&quot;]
    basic_auth = @options[&quot;basic_auth&quot;]
    @options.lock(true)
    ssl_config.unlock
    basic_auth.unlock
  end

  def set_cookie_store_file(value)
    value = nil if value and value.empty?
    @cookie_store = value
    @client.set_cookie_store(@cookie_store) if @cookie_store
  end

  def send_post(endpoint_url, conn_data, charset)
    conn_data.send_contenttype ||= StreamHandler.create_media_type(charset)

    if @wiredump_file_base
      filename = @wiredump_file_base + '_request.xml'
      f = File.open(filename, &quot;w&quot;)
      f &lt;&lt; conn_data.send_string
      f.close
    end

    extra = {}
    extra['Content-Type'] = conn_data.send_contenttype
    extra['SOAPAction'] = &quot;\&quot;#{ conn_data.soapaction }\&quot;&quot;
    extra['Accept-Encoding'] = 'gzip' if send_accept_encoding_gzip?
    send_string = conn_data.send_string
    @wiredump_dev &lt;&lt; &quot;Wire dump:\n\n&quot; if @wiredump_dev
    begin
      retry_count = 0
      while true
        res = @client.post(endpoint_url, send_string, extra)
        if RETRYABLE and HTTP::Status.redirect?(res.status)
          retry_count += 1
          if retry_count &gt;= MAX_RETRY_COUNT
            raise HTTPStreamError.new(&quot;redirect count exceeded&quot;)
          end
          endpoint_url = res.header[&quot;location&quot;][0]
          puts &quot;redirected to #{endpoint_url}&quot; if $DEBUG
        else
          break
        end
      end
    rescue
      @client.reset(endpoint_url)
      raise
    end
    @wiredump_dev &lt;&lt; &quot;\n\n&quot; if @wiredump_dev
    receive_string = res.content
    if @wiredump_file_base
      filename = @wiredump_file_base + '_response.xml'
      f = File.open(filename, &quot;w&quot;)
      f &lt;&lt; receive_string
      f.close
    end
    case res.status
    when 405
      raise PostUnavailableError.new(&quot;#{ res.status }: #{ res.reason }&quot;)
    when 200, 500
      # Nothing to do.
    else
      raise HTTPStreamError.new(&quot;#{ res.status }: #{ res.reason }&quot;)
    end
    if res.respond_to?(:header) and !res.header['content-encoding'].empty? and
        res.header['content-encoding'][0].downcase == 'gzip'
      receive_string = decode_gzip(receive_string)
    end
    conn_data.receive_string = receive_string
    conn_data.receive_contenttype = res.contenttype
    conn_data
  end

  def send_accept_encoding_gzip?
    @accept_encoding_gzip and defined?(::Zlib)
  end

  def decode_gzip(instring)
    unless send_accept_encoding_gzip?
      raise HTTPStreamError.new(&quot;Gzipped response content.&quot;)
    end
    begin
      gz = Zlib::GzipReader.new(StringIO.new(instring))
      gz.read
    ensure
      gz.close
    end
  end
end


end
</pre>
    </div>