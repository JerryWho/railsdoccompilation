  <div id="fileHeader">
    <h1>generator.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/soap/generator.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># SOAP4R - SOAP XML Instance Generator library.
# Copyright (C) 2001, 2003, 2005  NAKAMURA, Hiroshi &lt;nahi@ruby-lang.org&gt;.

# This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
# redistribute it and/or modify it under the same terms of Ruby's license;
# either the dual license version in 2003, or any later version.


require 'xsd/ns'
require 'soap/soap'
require 'soap/baseData'
require 'soap/encodingstyle/handler'


module SOAP


###
## CAUTION: MT-unsafe
#
class SOAPGenerator
  include SOAP

  class FormatEncodeError &lt; Error; end

public

  attr_accessor :charset
  attr_accessor :default_encodingstyle
  attr_accessor :generate_explicit_type
  attr_accessor :use_numeric_character_reference

  def initialize(opt = {})
    @reftarget = nil
    @handlers = {}
    @charset = opt[:charset] || XSD::Charset.xml_encoding_label
    @default_encodingstyle = opt[:default_encodingstyle] || EncodingNamespace
    @generate_explicit_type =
      opt.key?(:generate_explicit_type) ? opt[:generate_explicit_type] : true
    @elementformdefault = opt[:elementformdefault]
    @attributeformdefault = opt[:attributeformdefault]
    @use_numeric_character_reference = opt[:use_numeric_character_reference]
    @indentstr = opt[:no_indent] ? '' : '  '
    @buf = @indent = @curr = nil
  end

  def generate(obj, io = nil)
    @buf = io || ''
    @indent = ''

    prologue
    @handlers.each do |uri, handler|
      handler.encode_prologue
    end

    ns = XSD::NS.new
    @buf &lt;&lt; xmldecl
    encode_data(ns, obj, nil)

    @handlers.each do |uri, handler|
      handler.encode_epilogue
    end
    epilogue

    @buf
  end

  def encode_data(ns, obj, parent)
    if obj.is_a?(SOAPEnvelopeElement)
      encode_element(ns, obj, parent)
      return
    end
    if @reftarget &amp;&amp; !obj.precedents.empty?
      add_reftarget(obj.elename.name, obj)
      ref = SOAPReference.new(obj)
      ref.elename = ref.elename.dup_name(obj.elename.name)
      obj.precedents.clear	# Avoid cyclic delay.
      obj.encodingstyle = parent.encodingstyle
      # SOAPReference is encoded here.
      obj = ref
    end
    encodingstyle = obj.encodingstyle
    # Children's encodingstyle is derived from its parent.
    encodingstyle ||= parent.encodingstyle if parent
    obj.encodingstyle = encodingstyle
    handler = find_handler(encodingstyle || @default_encodingstyle)
    unless handler
      raise FormatEncodeError.new(&quot;Unknown encodingStyle: #{ encodingstyle }.&quot;)
    end
    if !obj.elename.name
      raise FormatEncodeError.new(&quot;Element name not defined: #{ obj }.&quot;)
    end
    handler.encode_data(self, ns, obj, parent)
    handler.encode_data_end(self, ns, obj, parent)
  end

  def add_reftarget(name, node)
    unless @reftarget
      raise FormatEncodeError.new(&quot;Reftarget is not defined.&quot;)
    end
    @reftarget.add(name, node)
  end

  def encode_child(ns, child, parent)
    indent_backup, @indent = @indent, @indent + @indentstr
    encode_data(ns.clone_ns, child, parent)
    @indent = indent_backup
  end

  def encode_element(ns, obj, parent)
    attrs = {}
    if obj.is_a?(SOAPBody)
      @reftarget = obj
      obj.encode(self, ns, attrs) do |child|
	indent_backup, @indent = @indent, @indent + @indentstr
        encode_data(ns.clone_ns, child, obj)
	@indent = indent_backup
      end
      @reftarget = nil
    else
      if obj.is_a?(SOAPEnvelope)
        # xsi:nil=&quot;true&quot; can appear even if dumping without explicit type.
        SOAPGenerator.assign_ns(attrs, ns,
	  XSD::InstanceNamespace, XSINamespaceTag)
        if @generate_explicit_type
          SOAPGenerator.assign_ns(attrs, ns, XSD::Namespace, XSDNamespaceTag)
        end
      end
      obj.encode(self, ns, attrs) do |child|
	indent_backup, @indent = @indent, @indent + @indentstr
        encode_data(ns.clone_ns, child, obj)
	@indent = indent_backup
      end
    end
  end

  def encode_name(ns, data, attrs)
    if element_local?(data)
      data.elename.name
    else
      if element_qualified?(data)
        SOAPGenerator.assign_ns(attrs, ns, data.elename.namespace, '')
      else
        SOAPGenerator.assign_ns(attrs, ns, data.elename.namespace)
      end
      ns.name(data.elename)
    end
  end

  def encode_name_end(ns, data)
    if element_local?(data)
      data.elename.name
    else
      ns.name(data.elename)
    end
  end

  def encode_tag(elename, attrs = nil)
    if !attrs or attrs.empty?
      @buf &lt;&lt; &quot;\n#{ @indent }&lt;#{ elename }&gt;&quot;
    elsif attrs.size == 1
      key, value = attrs.shift
      @buf &lt;&lt; %Q[\n#{ @indent }&lt;#{ elename } #{ key }=&quot;#{ value }&quot;&gt;]
    else
      @buf &lt;&lt; &quot;\n#{ @indent }&lt;#{ elename } &quot; &lt;&lt;
        attrs.collect { |key, value|
          %Q[#{ key }=&quot;#{ value }&quot;]
        }.join(&quot;\n#{ @indent }#{ @indentstr * 2 }&quot;) &lt;&lt;
	'&gt;'
    end
  end

  def encode_tag_end(elename, cr = nil)
    if cr
      @buf &lt;&lt; &quot;\n#{ @indent }&lt;/#{ elename }&gt;&quot;
    else
      @buf &lt;&lt; &quot;&lt;/#{ elename }&gt;&quot;
    end
  end

  def encode_rawstring(str)
    @buf &lt;&lt; str
  end

  EncodeMap = {
    '&amp;' =&gt; '&amp;amp;',
    '&lt;' =&gt; '&amp;lt;',
    '&gt;' =&gt; '&amp;gt;',
    '&quot;' =&gt; '&amp;quot;',
    '\'' =&gt; '&amp;apos;',
    &quot;\r&quot; =&gt; '&amp;#xd;'
  }
  EncodeCharRegexp = Regexp.new(&quot;[#{EncodeMap.keys.join}]&quot;)
  def encode_string(str)
    if @use_numeric_character_reference and !XSD::Charset.is_us_ascii(str)
      str.gsub!(EncodeCharRegexp) { |c| EncodeMap[c] }
      @buf &lt;&lt; str.unpack(&quot;U*&quot;).collect { |c|
        if c == 0x9 or c == 0xa or c == 0xd or (c &gt;= 0x20 and c &lt;= 0x7f)
          c.chr
        else
          sprintf(&quot;&amp;#x%x;&quot;, c)
        end
      }.join
    else
      @buf &lt;&lt; str.gsub(EncodeCharRegexp) { |c| EncodeMap[c] }
    end
  end

  def element_local?(element)
    element.elename.namespace.nil?
  end

  def element_qualified?(element)
    if element.respond_to?(:qualified)
      if element.qualified.nil?
        @elementformdefault
      else
        element.qualified
      end
    else
      @elementformdefault
    end
  end

  def self.assign_ns(attrs, ns, namespace, tag = nil)
    if namespace.nil?
      raise FormatEncodeError.new(&quot;empty namespace&quot;)
    end
    unless ns.assigned?(namespace)
      tag = ns.assign(namespace, tag)
      if tag == ''
        attr = 'xmlns'
      else
        attr = &quot;xmlns:#{tag}&quot;
      end
      attrs[attr] = namespace
    end
  end

private

  def prologue
  end

  def epilogue
  end

  def find_handler(encodingstyle)
    unless @handlers.key?(encodingstyle)
      handler = SOAP::EncodingStyle::Handler.handler(encodingstyle).new(@charset)
      handler.generate_explicit_type = @generate_explicit_type
      handler.encode_prologue
      @handlers[encodingstyle] = handler
    end
    @handlers[encodingstyle]
  end

  def xmldecl
    if @charset
      %Q[&lt;?xml version=&quot;1.0&quot; encoding=&quot;#{ @charset }&quot; ?&gt;]
    else
      %Q[&lt;?xml version=&quot;1.0&quot; ?&gt;]
    end
  end
end


end
</pre>
    </div>