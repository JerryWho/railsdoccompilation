  <div id="fileHeader">
    <h1>format.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/date/format.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Jan 17 06:07:07 -0600 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># format.rb: Written by Tadayoshi Funaba 1999-2008
# $Id: format.rb,v 2.43 2008-01-17 20:16:31+09 tadf Exp $

require 'rational'

class Date

  module Format # :nodoc:

    MONTHS = {
      'january'  =&gt; 1, 'february' =&gt; 2, 'march'    =&gt; 3, 'april'    =&gt; 4,
      'may'      =&gt; 5, 'june'     =&gt; 6, 'july'     =&gt; 7, 'august'   =&gt; 8,
      'september'=&gt; 9, 'october'  =&gt;10, 'november' =&gt;11, 'december' =&gt;12
    }

    DAYS = {
      'sunday'   =&gt; 0, 'monday'   =&gt; 1, 'tuesday'  =&gt; 2, 'wednesday'=&gt; 3,
      'thursday' =&gt; 4, 'friday'   =&gt; 5, 'saturday' =&gt; 6
    }

    ABBR_MONTHS = {
      'jan'      =&gt; 1, 'feb'      =&gt; 2, 'mar'      =&gt; 3, 'apr'      =&gt; 4,
      'may'      =&gt; 5, 'jun'      =&gt; 6, 'jul'      =&gt; 7, 'aug'      =&gt; 8,
      'sep'      =&gt; 9, 'oct'      =&gt;10, 'nov'      =&gt;11, 'dec'      =&gt;12
    }

    ABBR_DAYS = {
      'sun'      =&gt; 0, 'mon'      =&gt; 1, 'tue'      =&gt; 2, 'wed'      =&gt; 3,
      'thu'      =&gt; 4, 'fri'      =&gt; 5, 'sat'      =&gt; 6
    }

    ZONES = {
      'ut'  =&gt;  0*3600, 'gmt' =&gt;  0*3600, 'est' =&gt; -5*3600, 'edt' =&gt; -4*3600,
      'cst' =&gt; -6*3600, 'cdt' =&gt; -5*3600, 'mst' =&gt; -7*3600, 'mdt' =&gt; -6*3600,
      'pst' =&gt; -8*3600, 'pdt' =&gt; -7*3600,
      'a'   =&gt;  1*3600, 'b'   =&gt;  2*3600, 'c'   =&gt;  3*3600, 'd'   =&gt;  4*3600,
      'e'   =&gt;  5*3600, 'f'   =&gt;  6*3600, 'g'   =&gt;  7*3600, 'h'   =&gt;  8*3600,
      'i'   =&gt;  9*3600, 'k'   =&gt; 10*3600, 'l'   =&gt; 11*3600, 'm'   =&gt; 12*3600,
      'n'   =&gt; -1*3600, 'o'   =&gt; -2*3600, 'p'   =&gt; -3*3600, 'q'   =&gt; -4*3600,
      'r'   =&gt; -5*3600, 's'   =&gt; -6*3600, 't'   =&gt; -7*3600, 'u'   =&gt; -8*3600,
      'v'   =&gt; -9*3600, 'w'   =&gt;-10*3600, 'x'   =&gt;-11*3600, 'y'   =&gt;-12*3600,
      'z'   =&gt;  0*3600,

      'utc' =&gt;  0*3600, 'wet' =&gt;  0*3600,
      'at'  =&gt; -2*3600, 'brst'=&gt; -2*3600, 'ndt' =&gt; -(2*3600+1800),
      'art' =&gt; -3*3600, 'adt' =&gt; -3*3600, 'brt' =&gt; -3*3600, 'clst'=&gt; -3*3600,
      'nst' =&gt; -(3*3600+1800),
      'ast' =&gt; -4*3600, 'clt' =&gt; -4*3600,
      'akdt'=&gt; -8*3600, 'ydt' =&gt; -8*3600,
      'akst'=&gt; -9*3600, 'hadt'=&gt; -9*3600, 'hdt' =&gt; -9*3600, 'yst' =&gt; -9*3600,
      'ahst'=&gt;-10*3600, 'cat' =&gt;-10*3600, 'hast'=&gt;-10*3600, 'hst' =&gt;-10*3600,
      'nt'  =&gt;-11*3600,
      'idlw'=&gt;-12*3600,
      'bst' =&gt;  1*3600, 'cet' =&gt;  1*3600, 'fwt' =&gt;  1*3600, 'met' =&gt;  1*3600,
      'mewt'=&gt;  1*3600, 'mez' =&gt;  1*3600, 'swt' =&gt;  1*3600, 'wat' =&gt;  1*3600,
      'west'=&gt;  1*3600,
      'cest'=&gt;  2*3600, 'eet' =&gt;  2*3600, 'fst' =&gt;  2*3600, 'mest'=&gt;  2*3600,
      'mesz'=&gt;  2*3600, 'sast'=&gt;  2*3600, 'sst' =&gt;  2*3600,
      'bt'  =&gt;  3*3600, 'eat' =&gt;  3*3600, 'eest'=&gt;  3*3600, 'msk' =&gt;  3*3600,
      'msd' =&gt;  4*3600, 'zp4' =&gt;  4*3600,
      'zp5' =&gt;  5*3600, 'ist' =&gt;  (5*3600+1800),
      'zp6' =&gt;  6*3600,
      'wast'=&gt;  7*3600,
      'cct' =&gt;  8*3600, 'sgt' =&gt;  8*3600, 'wadt'=&gt;  8*3600,
      'jst' =&gt;  9*3600, 'kst' =&gt;  9*3600,
      'east'=&gt; 10*3600, 'gst' =&gt; 10*3600,
      'eadt'=&gt; 11*3600,
      'idle'=&gt; 12*3600, 'nzst'=&gt; 12*3600, 'nzt' =&gt; 12*3600,
      'nzdt'=&gt; 13*3600,

      'afghanistan'           =&gt;   16200, 'alaskan'               =&gt;  -32400,
      'arab'                  =&gt;   10800, 'arabian'               =&gt;   14400,
      'arabic'                =&gt;   10800, 'atlantic'              =&gt;  -14400,
      'aus central'           =&gt;   34200, 'aus eastern'           =&gt;   36000,
      'azores'                =&gt;   -3600, 'canada central'        =&gt;  -21600,
      'cape verde'            =&gt;   -3600, 'caucasus'              =&gt;   14400,
      'cen. australia'        =&gt;   34200, 'central america'       =&gt;  -21600,
      'central asia'          =&gt;   21600, 'central europe'        =&gt;    3600,
      'central european'      =&gt;    3600, 'central pacific'       =&gt;   39600,
      'central'               =&gt;  -21600, 'china'                 =&gt;   28800,
      'dateline'              =&gt;  -43200, 'e. africa'             =&gt;   10800,
      'e. australia'          =&gt;   36000, 'e. europe'             =&gt;    7200,
      'e. south america'      =&gt;  -10800, 'eastern'               =&gt;  -18000,
      'egypt'                 =&gt;    7200, 'ekaterinburg'          =&gt;   18000,
      'fiji'                  =&gt;   43200, 'fle'                   =&gt;    7200,
      'greenland'             =&gt;  -10800, 'greenwich'             =&gt;       0,
      'gtb'                   =&gt;    7200, 'hawaiian'              =&gt;  -36000,
      'india'                 =&gt;   19800, 'iran'                  =&gt;   12600,
      'jerusalem'             =&gt;    7200, 'korea'                 =&gt;   32400,
      'mexico'                =&gt;  -21600, 'mid-atlantic'          =&gt;   -7200,
      'mountain'              =&gt;  -25200, 'myanmar'               =&gt;   23400,
      'n. central asia'       =&gt;   21600, 'nepal'                 =&gt;   20700,
      'new zealand'           =&gt;   43200, 'newfoundland'          =&gt;  -12600,
      'north asia east'       =&gt;   28800, 'north asia'            =&gt;   25200,
      'pacific sa'            =&gt;  -14400, 'pacific'               =&gt;  -28800,
      'romance'               =&gt;    3600, 'russian'               =&gt;   10800,
      'sa eastern'            =&gt;  -10800, 'sa pacific'            =&gt;  -18000,
      'sa western'            =&gt;  -14400, 'samoa'                 =&gt;  -39600,
      'se asia'               =&gt;   25200, 'malay peninsula'       =&gt;   28800,
      'south africa'          =&gt;    7200, 'sri lanka'             =&gt;   21600,
      'taipei'                =&gt;   28800, 'tasmania'              =&gt;   36000,
      'tokyo'                 =&gt;   32400, 'tonga'                 =&gt;   46800,
      'us eastern'            =&gt;  -18000, 'us mountain'           =&gt;  -25200,
      'vladivostok'           =&gt;   36000, 'w. australia'          =&gt;   28800,
      'w. central africa'     =&gt;    3600, 'w. europe'             =&gt;    3600,
      'west asia'             =&gt;   18000, 'west pacific'          =&gt;   36000,
      'yakutsk'               =&gt;   32400
    }

    [MONTHS, DAYS, ABBR_MONTHS, ABBR_DAYS, ZONES].each do |x|
      x.freeze
    end

    class Bag # :nodoc:

      def initialize
	@elem = {}
      end

      def method_missing(t, *args, &amp;block)
	t = t.to_s
	set = t.chomp!('=')
	t = t.intern
	if set
	  @elem[t] = args[0]
	else
	  @elem[t]
	end
      end

      def to_hash
	@elem.reject{|k, v| /\A_/ =~ k.to_s || v.nil?}
      end

    end

  end

  def emit(e, f) # :nodoc:
    case e
    when Numeric
      sign = %w(+ + -)[e &lt;=&gt; 0]
      e = e.abs
    end

    s = e.to_s

    if f[:s] &amp;&amp; f[:p] == '0'
      f[:w] -= 1
    end

    if f[:s] &amp;&amp; f[:p] == &quot;\s&quot;
      s[0,0] = sign
    end

    if f[:p] != '-'
      s = s.rjust(f[:w], f[:p])
    end

    if f[:s] &amp;&amp; f[:p] != &quot;\s&quot;
      s[0,0] = sign
    end

    s = s.upcase if f[:u]
    s = s.downcase if f[:d]
    s
  end

  def emit_w(e, w, f) # :nodoc:
    f[:w] = [f[:w], w].compact.max
    emit(e, f)
  end

  def emit_n(e, w, f) # :nodoc:
    f[:p] ||= '0'
    emit_w(e, w, f)
  end

  def emit_sn(e, w, f) # :nodoc:
    if e &lt; 0
      w += 1
      f[:s] = true
    end
    emit_n(e, w, f)
  end

  def emit_z(e, w, f) # :nodoc:
    w += 1
    f[:s] = true
    emit_n(e, w, f)
  end

  def emit_a(e, w, f) # :nodoc:
    f[:p] ||= &quot;\s&quot;
    emit_w(e, w, f)
  end

  def emit_ad(e, w, f) # :nodoc:
    if f[:x]
      f[:u] = true
      f[:d] = false
    end
    emit_a(e, w, f)
  end

  def emit_au(e, w, f) # :nodoc:
    if f[:x]
      f[:u] = false
      f[:d] = true
    end
    emit_a(e, w, f)
  end

  private :emit, :emit_w, :emit_n, :emit_sn, :emit_z,
	  :emit_a, :emit_ad, :emit_au

  def strftime(fmt='%F')
    fmt.gsub(/%([-_0^#]+)?(\d+)?([EO]?(?::{1,3}z|.))/m) do |m|
      f = {}
      a = $&amp;
      s, w, c = $1, $2, $3
      if s
	s.scan(/./) do |k|
	  case k
	  when '-'; f[:p] = '-'
	  when '_'; f[:p] = &quot;\s&quot;
	  when '0'; f[:p] = '0'
	  when '^'; f[:u] = true
	  when '#'; f[:x] = true
	  end
	end
      end
      if w
	f[:w] = w.to_i
      end
      case c
      when 'A'; emit_ad(DAYNAMES[wday], 0, f)
      when 'a'; emit_ad(ABBR_DAYNAMES[wday], 0, f)
      when 'B'; emit_ad(MONTHNAMES[mon], 0, f)
      when 'b'; emit_ad(ABBR_MONTHNAMES[mon], 0, f)
      when 'C', 'EC'; emit_sn((year / 100).floor, 2, f)
      when 'c', 'Ec'; emit_a(strftime('%a %b %e %H:%M:%S %Y'), 0, f)
      when 'D'; emit_a(strftime('%m/%d/%y'), 0, f)
      when 'd', 'Od'; emit_n(mday, 2, f)
      when 'e', 'Oe'; emit_a(mday, 2, f)
      when 'F'
	if m == '%F'
	  format('%.4d-%02d-%02d', year, mon, mday) # 4p
	else
	  emit_a(strftime('%Y-%m-%d'), 0, f)
	end
      when 'G'; emit_sn(cwyear, 4, f)
      when 'g'; emit_n(cwyear % 100, 2, f)
      when 'H', 'OH'; emit_n(hour, 2, f)
      when 'h'; emit_ad(strftime('%b'), 0, f)
      when 'I', 'OI'; emit_n((hour % 12).nonzero? || 12, 2, f)
      when 'j'; emit_n(yday, 3, f)
      when 'k'; emit_a(hour, 2, f)
      when 'L'
	emit_n((sec_fraction / MILLISECONDS_IN_DAY).floor, 3, f)
      when 'l'; emit_a((hour % 12).nonzero? || 12, 2, f)
      when 'M', 'OM'; emit_n(min, 2, f)
      when 'm', 'Om'; emit_n(mon, 2, f)
      when 'N'
	emit_n((sec_fraction / NANOSECONDS_IN_DAY).floor, 9, f)
      when 'n'; &quot;\n&quot;
      when 'P'; emit_ad(strftime('%p').downcase, 0, f)
      when 'p'; emit_au(if hour &lt; 12 then 'AM' else 'PM' end, 0, f)
      when 'Q'
	s = ((ajd - UNIX_EPOCH_IN_AJD) / MILLISECONDS_IN_DAY).round
	emit_sn(s, 1, f)
      when 'R'; emit_a(strftime('%H:%M'), 0, f)
      when 'r'; emit_a(strftime('%I:%M:%S %p'), 0, f)
      when 'S', 'OS'; emit_n(sec, 2, f)
      when 's'
	s = ((ajd - UNIX_EPOCH_IN_AJD) / SECONDS_IN_DAY).round
	emit_sn(s, 1, f)
      when 'T'
	if m == '%T'
	  format('%02d:%02d:%02d', hour, min, sec) # 4p
	else
	  emit_a(strftime('%H:%M:%S'), 0, f)
	end
      when 't'; &quot;\t&quot;
      when 'U', 'W', 'OU', 'OW'
	emit_n(if c[-1,1] == 'U' then wnum0 else wnum1 end, 2, f)
      when 'u', 'Ou'; emit_n(cwday, 1, f)
      when 'V', 'OV'; emit_n(cweek, 2, f)
      when 'v'; emit_a(strftime('%e-%b-%Y'), 0, f)
      when 'w', 'Ow'; emit_n(wday, 1, f)
      when 'X', 'EX'; emit_a(strftime('%H:%M:%S'), 0, f)
      when 'x', 'Ex'; emit_a(strftime('%m/%d/%y'), 0, f)
      when 'Y', 'EY'; emit_sn(year, 4, f)
      when 'y', 'Ey', 'Oy'; emit_n(year % 100, 2, f)
      when 'Z'; emit_au(strftime('%:z'), 0, f)
      when /\A(:{0,3})z/
	t = $1.size
	sign = if offset &lt; 0 then -1 else +1 end
	fr = offset.abs
	ss = fr.div(SECONDS_IN_DAY) # 4p
	hh, ss = ss.divmod(3600)
	mm, ss = ss.divmod(60)
	if t == 3
	  if    ss.nonzero? then t =  2
	  elsif mm.nonzero? then t =  1
	  else                   t = -1
	  end
	end
	case t
	when -1
	  tail = []
	  sep = ''
	when 0
	  f[:w] -= 2 if f[:w]
	  tail = ['%02d' % mm]
	  sep = ''
	when 1
	  f[:w] -= 3 if f[:w]
	  tail = ['%02d' % mm]
	  sep = ':'
	when 2
	  f[:w] -= 6 if f[:w]
	  tail = ['%02d' % mm, '%02d' % ss]
	  sep = ':'
	end
	([emit_z(sign * hh, 2, f)] + tail).join(sep)
      when '%'; emit_a('%', 0, f)
      when '+'; emit_a(strftime('%a %b %e %H:%M:%S %Z %Y'), 0, f)
      when '1'
	if $VERBOSE
	  warn(&quot;warning: strftime: %1 is deprecated; forget this&quot;)
	end
	emit_n(jd, 1, f)
      when '2'
	if $VERBOSE
	  warn(&quot;warning: strftime: %2 is deprecated; use '%Y-%j'&quot;)
	end
	emit_a(strftime('%Y-%j'), 0, f)
      when '3'
	if $VERBOSE
	  warn(&quot;warning: strftime: %3 is deprecated; use '%F'&quot;)
	end
	emit_a(strftime('%F'), 0, f)
      else
	a
      end
    end
  end

# alias_method :format, :strftime

  def asctime() strftime('%c') end

  alias_method :ctime, :asctime

=begin
  def iso8601() strftime('%F') end

  def rfc3339() iso8601 end

  def rfc2822() strftime('%a, %-d %b %Y %T %z') end

  alias_method :rfc822, :rfc2822

  def jisx0301
    if jd &lt; 2405160
      iso8601
    else
      case jd
      when 2405160...2419614
	g = 'M%02d' % (year - 1867)
      when 2419614...2424875
	g = 'T%02d' % (year - 1911)
      when 2424875...2447535
	g = 'S%02d' % (year - 1925)
      else
	g = 'H%02d' % (year - 1988)
      end
      g + strftime('.%m.%d')
    end
  end

  def beat(n=0)
    i, f = (new_offset(HOURS_IN_DAY).day_fraction * 1000).divmod(1)
    ('@%03d' % i) +
      if n &lt; 1
	''
      else
	'.%0*d' % [n, (f / Rational(1, 10**n)).round]
      end
  end
=end

  def self.num_pattern? (s) # :nodoc:
    /\A%[EO]?[CDdeFGgHIjkLlMmNQRrSsTUuVvWwXxYy\d]/ =~ s || /\A\d/ =~ s
  end

  private_class_method :num_pattern?

  def self._strptime_i(str, fmt, e) # :nodoc:
    fmt.scan(/%([EO]?(?::{1,3}z|.))|(.)/m) do |s, c|
      a = $&amp;
      if s
	case s
	when 'A', 'a'
	  return unless str.sub!(/\A(#{Format::DAYS.keys.join('|')})/io, '') ||
			str.sub!(/\A(#{Format::ABBR_DAYS.keys.join('|')})/io, '')
	  val = Format::DAYS[$1.downcase] || Format::ABBR_DAYS[$1.downcase]
	  return unless val
	  e.wday = val
	when 'B', 'b', 'h'
	  return unless str.sub!(/\A(#{Format::MONTHS.keys.join('|')})/io, '') ||
			str.sub!(/\A(#{Format::ABBR_MONTHS.keys.join('|')})/io, '')
	  val = Format::MONTHS[$1.downcase] || Format::ABBR_MONTHS[$1.downcase]
	  return unless val
	  e.mon = val
	when 'C', 'EC'
	  return unless str.sub!(if num_pattern?($')
				 then /\A([-+]?\d{1,2})/
				 else /\A([-+]?\d{1,})/
				 end, '')
	  val = $1.to_i
	  e._cent = val
	when 'c', 'Ec'
	  return unless _strptime_i(str, '%a %b %e %H:%M:%S %Y', e)
	when 'D'
	  return unless _strptime_i(str, '%m/%d/%y', e)
	when 'd', 'e', 'Od', 'Oe'
	  return unless str.sub!(/\A( \d|\d{1,2})/, '')
	  val = $1.to_i
	  return unless (1..31) === val
	  e.mday = val
	when 'F'
	  return unless _strptime_i(str, '%Y-%m-%d', e)
	when 'G'
	  return unless str.sub!(if num_pattern?($')
				 then /\A([-+]?\d{1,4})/
				 else /\A([-+]?\d{1,})/
				 end, '')
	  val = $1.to_i
	  e.cwyear = val
	when 'g'
	  return unless str.sub!(/\A(\d{1,2})/, '')
	  val = $1.to_i
	  return unless (0..99) === val
	  e.cwyear = val
	  e._cent ||= if val &gt;= 69 then 19 else 20 end
	when 'H', 'k', 'OH'
	  return unless str.sub!(/\A( \d|\d{1,2})/, '')
	  val = $1.to_i
	  return unless (0..24) === val
	  e.hour = val
	when 'I', 'l', 'OI'
	  return unless str.sub!(/\A( \d|\d{1,2})/, '')
	  val = $1.to_i
	  return unless (1..12) === val
	  e.hour = val
	when 'j'
	  return unless str.sub!(/\A(\d{1,3})/, '')
	  val = $1.to_i
	  return unless (1..366) === val
	  e.yday = val
	when 'L'
	  return unless str.sub!(if num_pattern?($')
				 then /\A([-+]?\d{1,3})/
				 else /\A([-+]?\d{1,})/
				 end, '')
#	  val = Rational($1.to_i, 10**3)
	  val = Rational($1.to_i, 10**$1.size)
	  e.sec_fraction = val
	when 'M', 'OM'
	  return unless str.sub!(/\A(\d{1,2})/, '')
	  val = $1.to_i
	  return unless (0..59) === val
	  e.min = val
	when 'm', 'Om'
	  return unless str.sub!(/\A(\d{1,2})/, '')
	  val = $1.to_i
	  return unless (1..12) === val
	  e.mon = val
	when 'N'
	  return unless str.sub!(if num_pattern?($')
				 then /\A([-+]?\d{1,9})/
				 else /\A([-+]?\d{1,})/
				 end, '')
#	  val = Rational($1.to_i, 10**9)
	  val = Rational($1.to_i, 10**$1.size)
	  e.sec_fraction = val
	when 'n', 't'
	  return unless _strptime_i(str, &quot;\s&quot;, e)
	when 'P', 'p'
	  return unless str.sub!(/\A([ap])(?:m\b|\.m\.)/i, '')
	  e._merid = if $1.downcase == 'a' then 0 else 12 end
	when 'Q'
	  return unless str.sub!(/\A(-?\d{1,})/, '')
	  val = Rational($1.to_i, 10**3)
	  e.seconds = val
	when 'R'
	  return unless _strptime_i(str, '%H:%M', e)
	when 'r'
	  return unless _strptime_i(str, '%I:%M:%S %p', e)
	when 'S', 'OS'
	  return unless str.sub!(/\A(\d{1,2})/, '')
	  val = $1.to_i
	  return unless (0..60) === val
	  e.sec = val
	when 's'
	  return unless str.sub!(/\A(-?\d{1,})/, '')
	  val = $1.to_i
	  e.seconds = val
	when 'T'
	  return unless _strptime_i(str, '%H:%M:%S', e)
	when 'U', 'W', 'OU', 'OW'
	  return unless str.sub!(/\A(\d{1,2})/, '')
	  val = $1.to_i
	  return unless (0..53) === val
	  e.__send__(if s[-1,1] == 'U' then :wnum0= else :wnum1= end, val)
	when 'u', 'Ou'
	  return unless str.sub!(/\A(\d{1})/, '')
	  val = $1.to_i
	  return unless (1..7) === val
	  e.cwday = val
	when 'V', 'OV'
	  return unless str.sub!(/\A(\d{1,2})/, '')
	  val = $1.to_i
	  return unless (1..53) === val
	  e.cweek = val
	when 'v'
	  return unless _strptime_i(str, '%e-%b-%Y', e)
	when 'w'
	  return unless str.sub!(/\A(\d{1})/, '')
	  val = $1.to_i
	  return unless (0..6) === val
	  e.wday = val
	when 'X', 'EX'
	  return unless _strptime_i(str, '%H:%M:%S', e)
	when 'x', 'Ex'
	  return unless _strptime_i(str, '%m/%d/%y', e)
	when 'Y', 'EY'
	  return unless str.sub!(if num_pattern?($')
				 then /\A([-+]?\d{1,4})/
				 else /\A([-+]?\d{1,})/
				 end, '')
	  val = $1.to_i
	  e.year = val
	when 'y', 'Ey', 'Oy'
	  return unless str.sub!(/\A(\d{1,2})/, '')
	  val = $1.to_i
	  return unless (0..99) === val
	  e.year = val
	  e._cent ||= if val &gt;= 69 then 19 else 20 end
	when 'Z', /\A:{0,3}z/
	  return unless str.sub!(/\A((?:gmt|utc?)?[-+]\d+(?:[,.:]\d+(?::\d+)?)?
				    |[[:alpha:].\s]+(?:standard|daylight)\s+time\b
				    |[[:alpha:]]+(?:\s+dst)?\b
				    )/ix, '')
	  val = $1
	  e.zone = val
	  offset = zone_to_diff(val)
	  e.offset = offset
	when '%'
	  return unless str.sub!(/\A%/, '')
	when '+'
	  return unless _strptime_i(str, '%a %b %e %H:%M:%S %Z %Y', e)
	when '1'
	  if $VERBOSE
	    warn(&quot;warning: strptime: %1 is deprecated; forget this&quot;)
	  end
	  return unless str.sub!(/\A(\d+)/, '')
	  val = $1.to_i
	  e.jd = val
	when '2'
	  if $VERBOSE
	    warn(&quot;warning: strptime: %2 is deprecated; use '%Y-%j'&quot;)
	  end
	  return unless _strptime_i(str, '%Y-%j', e)
	when '3'
	  if $VERBOSE
	    warn(&quot;warning: strptime: %3 is deprecated; use '%F'&quot;)
	  end
	  return unless _strptime_i(str, '%F', e)
	else
	  return unless str.sub!(Regexp.new('\\A' + Regexp.quote(a)), '')
	end
      else
	case c
	when /\A[\s\v]/
	  str.sub!(/\A[\s\v]+/, '')
	else
	  return unless str.sub!(Regexp.new('\\A' + Regexp.quote(a)), '')
	end
      end
    end
  end

  private_class_method :_strptime_i

  def self._strptime(str, fmt='%F')
    str = str.dup
    e = Format::Bag.new
    return unless _strptime_i(str, fmt, e)

    if e._cent
      if e.cwyear
	e.cwyear += e._cent * 100
      end
      if e.year
	e.  year += e._cent * 100
      end
    end

    if e._merid
      if e.hour
	e.hour %= 12
	e.hour += e._merid
      end
    end

    unless str.empty?
      e.leftover = str
    end

    e.to_hash
  end

  def self.s3e(e, y, m, d, bc=false)
    unless String === m
      m = m.to_s
    end

    if y &amp;&amp; m &amp;&amp; !d
      y, m, d = d, y, m
    end

    if y == nil
      if d &amp;&amp; d.size &gt; 2
	y = d
	d = nil
      end
      if d &amp;&amp; d[0,1] == &quot;'&quot;
	y = d
	d = nil
      end
    end

    if y
      y.scan(/(\d+)(.+)?/)
      if $2
	y, d = d, $1
      end
    end

    if m
      if m[0,1] == &quot;'&quot; || m.size &gt; 2
	y, m, d = m, d, y # us -&gt; be
      end
    end

    if d
      if d[0,1] == &quot;'&quot; || d.size &gt; 2
	y, d = d, y
      end
    end

    if y
      y =~ /([-+])?(\d+)/
      if $1 || $2.size &gt; 2
	c = false
      end
      iy = $&amp;.to_i
      if bc
	iy = -iy + 1
      end
      e.year = iy
    end

    if m
      m =~ /\d+/
      e.mon = $&amp;.to_i
    end

    if d
      d =~ /\d+/
      e.mday = $&amp;.to_i
    end

    if c != nil
      e._comp = c
    end

  end

  private_class_method :s3e

  def self._parse_day(str, e) # :nodoc:
    if str.sub!(/\b(#{Format::ABBR_DAYS.keys.join('|')})[^-\d\s]*/ino, ' ')
      e.wday = Format::ABBR_DAYS[$1.downcase]
      true
=begin
    elsif str.sub!(/\b(?!\dth)(su|mo|tu|we|th|fr|sa)\b/in, ' ')
      e.wday = %w(su mo tu we th fr sa).index($1.downcase)
      true
=end
    end
  end

  def self._parse_time(str, e) # :nodoc:
    if str.sub!(
		/(
		   (?:
		     \d+\s*:\s*\d+
		     (?:
		       \s*:\s*\d+(?:[,.]\d*)?
		     )?
		   |
		     \d+\s*h(?:\s*\d+m?(?:\s*\d+s?)?)?
		   )
		   (?:
		     \s*
		     [ap](?:m\b|\.m\.)
		   )?
		 |
		   \d+\s*[ap](?:m\b|\.m\.)
		 )
		 (?:
		   \s*
		   (
		     (?:gmt|utc?)?[-+]\d+(?:[,.:]\d+(?::\d+)?)?
		   |
		     [[:alpha:].\s]+(?:standard|daylight)\stime\b
		   |
		     [[:alpha:]]+(?:\sdst)?\b
		   )
		 )?
		/inx,
		' ')

      t = $1
      e.zone = $2 if $2

      t =~ /\A(\d+)h?
	      (?:\s*:?\s*(\d+)m?
		(?:
		  \s*:?\s*(\d+)(?:[,.](\d+))?s?
		)?
	      )?
	    (?:\s*([ap])(?:m\b|\.m\.))?/inx

      e.hour = $1.to_i
      e.min = $2.to_i if $2
      e.sec = $3.to_i if $3
      e.sec_fraction = Rational($4.to_i, 10**$4.size) if $4

      if $5
	e.hour %= 12
	if $5.downcase == 'p'
	  e.hour += 12
	end
      end
      true
    end
  end

=begin
  def self._parse_beat(str, e) # :nodoc:
    if str.sub!(/@\s*(\d+)(?:[,.](\d*))?/, ' ')
      beat = Rational($1.to_i)
      beat += Rational($2.to_i, 10**$2.size) if $2
      secs = Rational(beat, 1000)
      h, min, s, fr = self.day_fraction_to_time(secs)
      e.hour = h
      e.min = min
      e.sec = s
      e.sec_fraction = fr * 86400
      e.zone = '+01:00'
      true
    end
  end
=end

  def self._parse_eu(str, e) # :nodoc:
    if str.sub!(
		/'?(\d+)[^-\d\s]*
		 \s*
		 (#{Format::ABBR_MONTHS.keys.join('|')})[^-\d\s']*
		 (?:
		   \s*
		   (c(?:e|\.e\.)|b(?:ce|\.c\.e\.)|a(?:d|\.d\.)|b(?:c|\.c\.))?
		   \s*
		   ('?-?\d+(?:(?:st|nd|rd|th)\b)?)
		 )?
		/inox,
		' ') # '
      s3e(e, $4, Format::ABBR_MONTHS[$2.downcase], $1,
	  $3 &amp;&amp; $3[0,1].downcase == 'b')
      true
    end
  end

  def self._parse_us(str, e) # :nodoc:
    if str.sub!(
		/\b(#{Format::ABBR_MONTHS.keys.join('|')})[^-\d\s']*
		 \s*
		 ('?\d+)[^-\d\s']*
		 (?:
		   \s*
		   (c(?:e|\.e\.)|b(?:ce|\.c\.e\.)|a(?:d|\.d\.)|b(?:c|\.c\.))?
		   \s*
		   ('?-?\d+)
		 )?
		/inox,
		' ') # '
      s3e(e, $4, Format::ABBR_MONTHS[$1.downcase], $2,
	  $3 &amp;&amp; $3[0,1].downcase == 'b')
      true
    end
  end

  def self._parse_iso(str, e) # :nodoc:
    if str.sub!(/('?[-+]?\d+)-(\d+)-('?-?\d+)/n, ' ')
      s3e(e, $1, $2, $3)
      true
    end
  end

  def self._parse_iso2(str, e) # :nodoc:
    if str.sub!(/\b(\d{2}|\d{4})?-?w(\d{2})(?:-?(\d))?\b/in, ' ')
      e.cwyear = $1.to_i if $1
      e.cweek = $2.to_i
      e.cwday = $3.to_i if $3
      true
    elsif str.sub!(/-w-(\d)\b/in, ' ')
      e.cwday = $1.to_i
      true
    elsif str.sub!(/--(\d{2})?-(\d{2})\b/n, ' ')
      e.mon = $1.to_i if $1
      e.mday = $2.to_i
      true
    elsif str.sub!(/--(\d{2})(\d{2})?\b/n, ' ')
      e.mon = $1.to_i
      e.mday = $2.to_i if $2
      true
    elsif /[,.](\d{2}|\d{4})-\d{3}\b/n !~ str &amp;&amp;
	str.sub!(/\b(\d{2}|\d{4})-(\d{3})\b/n, ' ')
      e.year = $1.to_i
      e.yday = $2.to_i
      true
    elsif /\d-\d{3}\b/n !~ str &amp;&amp;
	str.sub!(/\b-(\d{3})\b/n, ' ')
      e.yday = $1.to_i
      true
    end
  end

  def self._parse_jis(str, e) # :nodoc:
    if str.sub!(/\b([mtsh])(\d+)\.(\d+)\.(\d+)/in, ' ')
      era = { 'm'=&gt;1867,
	      't'=&gt;1911,
	      's'=&gt;1925,
	      'h'=&gt;1988
	  }[$1.downcase]
      e.year = $2.to_i + era
      e.mon = $3.to_i
      e.mday = $4.to_i
      true
    end
  end

  def self._parse_vms(str, e) # :nodoc:
    if str.sub!(/('?-?\d+)-(#{Format::ABBR_MONTHS.keys.join('|')})[^-]*
		-('?-?\d+)/inox, ' ')
      s3e(e, $3, Format::ABBR_MONTHS[$2.downcase], $1)
      true
    elsif str.sub!(/\b(#{Format::ABBR_MONTHS.keys.join('|')})[^-]*
		-('?-?\d+)(?:-('?-?\d+))?/inox, ' ')
      s3e(e, $3, Format::ABBR_MONTHS[$1.downcase], $2)
      true
    end
  end

  def self._parse_sla(str, e) # :nodoc:
    if str.sub!(%r|('?-?\d+)/\s*('?\d+)(?:\D\s*('?-?\d+))?|n, ' ') # '
      s3e(e, $3, $1, $2)
      true
    end
  end

  def self._parse_dot(str, e) # :nodoc:
    if str.sub!(%r|('?-?\d+)\.\s*('?\d+)\.\s*('?-?\d+)|n, ' ') # '
      s3e(e, $1, $2, $3)
      true
    end
  end

  def self._parse_year(str, e) # :nodoc:
    if str.sub!(/'(\d+)\b/n, ' ')
      e.year = $1.to_i
      true
    end
  end

  def self._parse_mon(str, e) # :nodoc:
    if str.sub!(/\b(#{Format::ABBR_MONTHS.keys.join('|')})\S*/ino, ' ')
      e.mon = Format::ABBR_MONTHS[$1.downcase]
      true
    end
  end

  def self._parse_mday(str, e) # :nodoc:
    if str.sub!(/(\d+)(st|nd|rd|th)\b/in, ' ')
      e.mday = $1.to_i
      true
    end
  end

  def self._parse_ddd(str, e) # :nodoc:
    if str.sub!(
		/([-+]?)(\d{2,14})
		  (?:
		    \s*
		    t?
		    \s*
		    (\d{2,6})?(?:[,.](\d*))?
		  )?
		  (?:
		    \s*
		    (
		      z\b
		    |
		      [-+]\d{1,4}\b
		    |
		      \[[-+]?\d[^\]]*\]
		    )
		  )?
		/inx,
		' ')
      case $2.size
      when 2
	if $3.nil? &amp;&amp; $4
	  e.sec  = $2[-2, 2].to_i
	else
	  e.mday = $2[ 0, 2].to_i
	end
      when 4
	if $3.nil? &amp;&amp; $4
	  e.sec  = $2[-2, 2].to_i
	  e.min  = $2[-4, 2].to_i
	else
	  e.mon  = $2[ 0, 2].to_i
	  e.mday = $2[ 2, 2].to_i
	end
      when 6
	if $3.nil? &amp;&amp; $4
	  e.sec  = $2[-2, 2].to_i
	  e.min  = $2[-4, 2].to_i
	  e.hour = $2[-6, 2].to_i
	else
	  e.year = ($1 + $2[ 0, 2]).to_i
	  e.mon  = $2[ 2, 2].to_i
	  e.mday = $2[ 4, 2].to_i
	end
      when 8, 10, 12, 14
	if $3.nil? &amp;&amp; $4
	  e.sec  = $2[-2, 2].to_i
	  e.min  = $2[-4, 2].to_i
	  e.hour = $2[-6, 2].to_i
	  e.mday = $2[-8, 2].to_i
	  if $2.size &gt;= 10
	    e.mon  = $2[-10, 2].to_i
	  end
	  if $2.size == 12
	    e.year = ($1 + $2[-12, 2]).to_i
	  end
	  if $2.size == 14
	    e.year = ($1 + $2[-14, 4]).to_i
	    e._comp = false
	  end
	else
	  e.year = ($1 + $2[ 0, 4]).to_i
	  e.mon  = $2[ 4, 2].to_i
	  e.mday = $2[ 6, 2].to_i
	  e.hour = $2[ 8, 2].to_i if $2.size &gt;= 10
	  e.min  = $2[10, 2].to_i if $2.size &gt;= 12
	  e.sec  = $2[12, 2].to_i if $2.size &gt;= 14
	  e._comp = false
	end
      when 3
	if $3.nil? &amp;&amp; $4
	  e.sec  = $2[-2, 2].to_i
	  e.min  = $2[-3, 1].to_i
	else
	  e.yday = $2[ 0, 3].to_i
	end
      when 5
	if $3.nil? &amp;&amp; $4
	  e.sec  = $2[-2, 2].to_i
	  e.min  = $2[-4, 2].to_i
	  e.hour = $2[-5, 1].to_i
	else
	  e.year = ($1 + $2[ 0, 2]).to_i
	  e.yday = $2[ 2, 3].to_i
	end
      when 7
	if $3.nil? &amp;&amp; $4
	  e.sec  = $2[-2, 2].to_i
	  e.min  = $2[-4, 2].to_i
	  e.hour = $2[-6, 2].to_i
	  e.mday = $2[-7, 1].to_i
	else
	  e.year = ($1 + $2[ 0, 4]).to_i
	  e.yday = $2[ 4, 3].to_i
	end
      end
      if $3
	if $4
	  case $3.size
	  when 2, 4, 6
	    e.sec  = $3[-2, 2].to_i
	    e.min  = $3[-4, 2].to_i if $3.size &gt;= 4
	    e.hour = $3[-6, 2].to_i if $3.size &gt;= 6
	  end
	else
	  case $3.size
	  when 2, 4, 6
	    e.hour = $3[ 0, 2].to_i
	    e.min  = $3[ 2, 2].to_i if $3.size &gt;= 4
	    e.sec  = $3[ 4, 2].to_i if $3.size &gt;= 6
	  end
	end
      end
      if $4
	e.sec_fraction = Rational($4.to_i, 10**$4.size)
      end
      if $5
	e.zone = $5
	if e.zone[0,1] == '['
	  o, n, = e.zone[1..-2].split(':')
	  e.zone = n || o
	  if /\A\d/ =~ o
	    o = format('+%s', o)
	  end
	  e.offset = zone_to_diff(o)
	end
      end
      true
    end
  end

  private_class_method :_parse_day, :_parse_time, # :_parse_beat,
	:_parse_eu, :_parse_us, :_parse_iso, :_parse_iso2,
	:_parse_jis, :_parse_vms, :_parse_sla, :_parse_dot,
	:_parse_year, :_parse_mon, :_parse_mday, :_parse_ddd

  def self._parse(str, comp=false)
    str = str.dup

    e = Format::Bag.new

    e._comp = comp

    str.gsub!(/[^-+',.\/:@[:alnum:]\[\]\x80-\xff]+/n, ' ')

    _parse_time(str, e) # || _parse_beat(str, e)
    _parse_day(str, e)

    _parse_eu(str, e)     ||
    _parse_us(str, e)     ||
    _parse_iso(str, e)    ||
    _parse_jis(str, e)    ||
    _parse_vms(str, e)    ||
    _parse_sla(str, e)    ||
    _parse_dot(str, e)    ||
    _parse_iso2(str, e)   ||
    _parse_year(str, e)   ||
    _parse_mon(str, e)    ||
    _parse_mday(str, e)   ||
    _parse_ddd(str, e)

    if str.sub!(/\b(bc\b|bce\b|b\.c\.|b\.c\.e\.)/in, ' ')
      if e.year
	e.year = -e.year + 1
      end
    end

    if str.sub!(/\A\s*(\d{1,2})\s*\z/n, ' ')
      if e.hour &amp;&amp; !e.mday
	v = $1.to_i
	if (1..31) === v
	  e.mday = v
	end
      end
      if e.mday &amp;&amp; !e.hour
	v = $1.to_i
	if (0..24) === v
	  e.hour = v
	end
      end
    end

    if e._comp
      if e.cwyear
	if e.cwyear &gt;= 0 &amp;&amp; e.cwyear &lt;= 99
	  e.cwyear += if e.cwyear &gt;= 69
		      then 1900 else 2000 end
	end
      end
      if e.year
	if e.year &gt;= 0 &amp;&amp; e.year &lt;= 99
	  e.year += if e.year &gt;= 69
		    then 1900 else 2000 end
	end
      end
    end

    e.offset ||= zone_to_diff(e.zone) if e.zone

    e.to_hash
  end

  def self.zone_to_diff(zone) # :nodoc:
    zone = zone.downcase
    if zone.sub!(/\s+(standard|daylight)\s+time\z/, '')
      dst = $1 == 'daylight'
    else
      dst = zone.sub!(/\s+dst\z/, '')
    end
    if Format::ZONES.include?(zone)
      offset = Format::ZONES[zone]
      offset += 3600 if dst
    elsif zone.sub!(/\A(?:gmt|utc?)?([-+])/, '')
      sign = $1
      if zone.include?(':')
	hour, min, sec, = zone.split(':')
      elsif zone.include?(',') || zone.include?('.')
	hour, fr, = zone.split(/[,.]/)
	min = Rational(fr.to_i, 10**fr.size) * 60
      else
	case zone.size
	when 3
	  hour = zone[0,1]
	  min = zone[1,2]
	else
	  hour = zone[0,2]
	  min = zone[2,2]
	  sec = zone[4,2]
	end
      end
      offset = hour.to_i * 3600 + min.to_i * 60 + sec.to_i
      offset *= -1 if sign == '-'
    end
    offset
  end

end

class DateTime &lt; Date

  def strftime(fmt='%FT%T%:z')
    super(fmt)
  end

  def self._strptime(str, fmt='%FT%T%z')
    super(str, fmt)
  end

=begin
  def iso8601_timediv(n) # :nodoc:
    strftime('T%T' +
	     if n &lt; 1
	       ''
	     else
	       '.%0*d' % [n, (sec_fraction / SECONDS_IN_DAY / (10**n)).round]
	     end +
	     '%:z')
  end

  private :iso8601_timediv

  def iso8601(n=0)
    super() + iso8601_timediv(n)
  end

  def rfc3339(n=0) iso8601(n) end

  def jisx0301(n=0)
    super() + iso8601_timediv(n)
  end
=end

end
</pre>
    </div>