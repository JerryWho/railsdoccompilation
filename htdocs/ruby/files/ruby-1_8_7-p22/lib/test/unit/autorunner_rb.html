  <div id="fileHeader">
    <h1>autorunner.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/test/unit/autorunner.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Feb 25 08:08:40 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'test/unit'
require 'test/unit/ui/testrunnerutilities'
require 'optparse'

module Test
  module Unit
    class AutoRunner
      def self.run(force_standalone=false, default_dir=nil, argv=ARGV, &amp;block)
        r = new(force_standalone || standalone?, &amp;block)
        r.base = default_dir
        r.process_args(argv)
        r.run
      end
      
      def self.standalone?
        return false unless(&quot;-e&quot; == $0)
        ObjectSpace.each_object(Class) do |klass|
          return false if(klass &lt; TestCase)
        end
        true
      end

      RUNNERS = {
        :console =&gt; proc do |r|
          require 'test/unit/ui/console/testrunner'
          Test::Unit::UI::Console::TestRunner
        end,
        :gtk =&gt; proc do |r|
          require 'test/unit/ui/gtk/testrunner'
          Test::Unit::UI::GTK::TestRunner
        end,
        :gtk2 =&gt; proc do |r|
          require 'test/unit/ui/gtk2/testrunner'
          Test::Unit::UI::GTK2::TestRunner
        end,
        :fox =&gt; proc do |r|
          require 'test/unit/ui/fox/testrunner'
          Test::Unit::UI::Fox::TestRunner
        end,
        :tk =&gt; proc do |r|
          require 'test/unit/ui/tk/testrunner'
          Test::Unit::UI::Tk::TestRunner
        end,
      }

      OUTPUT_LEVELS = [
        [:silent, UI::SILENT],
        [:progress, UI::PROGRESS_ONLY],
        [:normal, UI::NORMAL],
        [:verbose, UI::VERBOSE],
      ]

      COLLECTORS = {
        :objectspace =&gt; proc do |r|
          require 'test/unit/collector/objectspace'
          c = Collector::ObjectSpace.new
          c.filter = r.filters
          c.collect($0.sub(/\.rb\Z/, ''))
        end,
        :dir =&gt; proc do |r|
          require 'test/unit/collector/dir'
          c = Collector::Dir.new
          c.filter = r.filters
          c.pattern.concat(r.pattern) if(r.pattern)
          c.exclude.concat(r.exclude) if(r.exclude)
          c.base = r.base
          $:.push(r.base) if r.base
          c.collect(*(r.to_run.empty? ? ['.'] : r.to_run))
        end,
      }

      attr_reader :suite
      attr_accessor :output_level, :filters, :to_run, :pattern, :exclude, :base, :workdir
      attr_writer :runner, :collector

      def initialize(standalone)
        Unit.run = true
        @standalone = standalone
        @runner = RUNNERS[:console]
        @collector = COLLECTORS[(standalone ? :dir : :objectspace)]
        @filters = []
        @to_run = []
        @output_level = UI::NORMAL
        @workdir = nil
        yield(self) if(block_given?)
      end

      def process_args(args = ARGV)
        begin
          options.order!(args) {|arg| @to_run &lt;&lt; arg}
        rescue OptionParser::ParseError =&gt; e
          puts e
          puts options
          $! = nil
          abort
        else
          @filters &lt;&lt; proc{false} unless(@filters.empty?)
        end
        not @to_run.empty?
      end

      def options
        @options ||= OptionParser.new do |o|
          o.banner = &quot;Test::Unit automatic runner.&quot;
          o.banner &lt;&lt; &quot;\nUsage: #{$0} [options] [-- untouched arguments]&quot;

          o.on
          o.on('-r', '--runner=RUNNER', RUNNERS,
               &quot;Use the given RUNNER.&quot;,
               &quot;(&quot; + keyword_display(RUNNERS) + &quot;)&quot;) do |r|
            @runner = r
          end

          if(@standalone)
            o.on('-b', '--basedir=DIR', &quot;Base directory of test suites.&quot;) do |b|
              @base = b
            end

            o.on('-w', '--workdir=DIR', &quot;Working directory to run tests.&quot;) do |w|
              @workdir = w
            end

            o.on('-a', '--add=TORUN', Array,
                 &quot;Add TORUN to the list of things to run;&quot;,
                 &quot;can be a file or a directory.&quot;) do |a|
              @to_run.concat(a)
            end

            @pattern = []
            o.on('-p', '--pattern=PATTERN', Regexp,
                 &quot;Match files to collect against PATTERN.&quot;) do |e|
              @pattern &lt;&lt; e
            end

            @exclude = []
            o.on('-x', '--exclude=PATTERN', Regexp,
                 &quot;Ignore files to collect against PATTERN.&quot;) do |e|
              @exclude &lt;&lt; e
            end
          end

          o.on('-n', '--name=NAME', String,
               &quot;Runs tests matching NAME.&quot;,
               &quot;(patterns may be used).&quot;) do |n|
            n = (%r{\A/(.*)/\Z} =~ n ? Regexp.new($1) : n)
            case n
            when Regexp
              @filters &lt;&lt; proc{|t| n =~ t.method_name ? true : nil}
            else
              @filters &lt;&lt; proc{|t| n == t.method_name ? true : nil}
            end
          end

          o.on('-t', '--testcase=TESTCASE', String,
               &quot;Runs tests in TestCases matching TESTCASE.&quot;,
               &quot;(patterns may be used).&quot;) do |n|
            n = (%r{\A/(.*)/\Z} =~ n ? Regexp.new($1) : n)
            case n
            when Regexp
              @filters &lt;&lt; proc{|t| n =~ t.class.name ? true : nil}
            else
              @filters &lt;&lt; proc{|t| n == t.class.name ? true : nil}
            end
          end

          o.on('-I', &quot;--load-path=DIR[#{File::PATH_SEPARATOR}DIR...]&quot;,
               &quot;Appends directory list to $LOAD_PATH.&quot;) do |dirs|
            $LOAD_PATH.concat(dirs.split(File::PATH_SEPARATOR))
          end

          o.on('-v', '--verbose=[LEVEL]', OUTPUT_LEVELS,
               &quot;Set the output level (default is verbose).&quot;,
               &quot;(&quot; + keyword_display(OUTPUT_LEVELS) + &quot;)&quot;) do |l|
            @output_level = l || UI::VERBOSE
          end

          o.on('--',
               &quot;Stop processing options so that the&quot;,
               &quot;remaining options will be passed to the&quot;,
               &quot;test.&quot;){o.terminate}

          o.on('-h', '--help', 'Display this help.'){puts o; exit}

          o.on_tail
          o.on_tail('Deprecated options:')

          o.on_tail('--console', 'Console runner (use --runner).') do
            warn(&quot;Deprecated option (--console).&quot;)
            @runner = RUNNERS[:console]
          end

          o.on_tail('--gtk', 'GTK runner (use --runner).') do
            warn(&quot;Deprecated option (--gtk).&quot;)
            @runner = RUNNERS[:gtk]
          end

          o.on_tail('--fox', 'Fox runner (use --runner).') do
            warn(&quot;Deprecated option (--fox).&quot;)
            @runner = RUNNERS[:fox]
          end

          o.on_tail
        end
      end

      def keyword_display(array)
        list = array.collect {|e, *| e.to_s}
        Array === array or list.sort!
        list.collect {|e| e.sub(/^(.)([A-Za-z]+)(?=\w*$)/, '\\1[\\2]')}.join(&quot;, &quot;)
      end

      def run
        @suite = @collector[self]
        result = @runner[self] or return false
        Dir.chdir(@workdir) if @workdir
        result.run(@suite, @output_level).passed?
      end
    end
  end
end
</pre>
    </div>