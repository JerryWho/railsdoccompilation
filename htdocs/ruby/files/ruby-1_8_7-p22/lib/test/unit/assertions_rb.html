  <div id="fileHeader">
    <h1>assertions.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/test/unit/assertions.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># Author:: Nathaniel Talbott.
# Copyright:: Copyright (c) 2000-2003 Nathaniel Talbott. All rights reserved.
# License:: Ruby license.

require 'test/unit/assertionfailederror'
require 'test/unit/util/backtracefilter'

module Test
  module Unit

    ##
    # Test::Unit::Assertions contains the standard Test::Unit assertions.
    # Assertions is included in Test::Unit::TestCase.
    #
    # To include it in your own code and use its functionality, you simply
    # need to rescue Test::Unit::AssertionFailedError. Additionally you may
    # override add_assertion to get notified whenever an assertion is made.
    #
    # Notes:
    # * The message to each assertion, if given, will be propagated with the
    #   failure.
    # * It is easy to add your own assertions based on assert_block().
    #
    # = Example Custom Assertion
    #
    #   def deny(boolean, message = nil)
    #     message = build_message message, '&lt;?&gt; is not false or nil.', boolean
    #     assert_block message do
    #       not boolean
    #     end
    #   end

    module Assertions

      ##
      # The assertion upon which all other assertions are based. Passes if the
      # block yields true.
      #
      # Example:
      #   assert_block &quot;Couldn't do the thing&quot; do
      #     do_the_thing
      #   end

      public
      def assert_block(message=&quot;assert_block failed.&quot;) # :yields: 
        _wrap_assertion do
          if (! yield)
            raise AssertionFailedError.new(message.to_s)
          end
        end
      end

      ##
      # Asserts that +boolean+ is not false or nil.
      #
      # Example:
      #   assert [1, 2].include?(5)

      public
      def assert(boolean, message=nil)
        _wrap_assertion do
          assert_block(&quot;assert should not be called with a block.&quot;) { !block_given? }
          assert_block(build_message(message, &quot;&lt;?&gt; is not true.&quot;, boolean)) { boolean }
        end
      end

      ##
      # Passes if +expected+ == +actual.
      #
      # Note that the ordering of arguments is important, since a helpful
      # error message is generated when this one fails that tells you the
      # values of expected and actual.
      #
      # Example:
      #   assert_equal 'MY STRING', 'my string'.upcase

      public
      def assert_equal(expected, actual, message=nil)
        full_message = build_message(message, &lt;&lt;EOT, expected, actual)
&lt;?&gt; expected but was
&lt;?&gt;.
EOT
        assert_block(full_message) { expected == actual }
      end

      private
      def _check_exception_class(args) # :nodoc:
        args.partition do |klass|
          next if klass.instance_of?(Module)
          assert(Exception &gt;= klass, &quot;Should expect a class of exception, #{klass}&quot;)
          true
        end
      end

      private
      def _expected_exception?(actual_exception, exceptions, modules) # :nodoc:
        exceptions.include?(actual_exception.class) or
          modules.any? {|mod| actual_exception.is_a?(mod)}
      end

      ##
      # Passes if the block raises one of the given exceptions.
      #
      # Example:
      #   assert_raise RuntimeError, LoadError do
      #     raise 'Boom!!!'
      #   end

      public
      def assert_raise(*args)
        _wrap_assertion do
          if Module === args.last
            message = &quot;&quot;
          else
            message = args.pop
          end
          exceptions, modules = _check_exception_class(args)
          expected = args.size == 1 ? args.first : args
          actual_exception = nil
          full_message = build_message(message, &quot;&lt;?&gt; exception expected but none was thrown.&quot;, expected)
          assert_block(full_message) do
            begin
              yield
            rescue Exception =&gt; actual_exception
              break
            end
            false
          end
          full_message = build_message(message, &quot;&lt;?&gt; exception expected but was\n?&quot;, expected, actual_exception)
          assert_block(full_message) {_expected_exception?(actual_exception, exceptions, modules)}
          actual_exception
        end
      end

      ##
      # Alias of assert_raise.
      #
      # Will be deprecated in 1.9, and removed in 2.0.

      public
      def assert_raises(*args, &amp;block)
        assert_raise(*args, &amp;block)
      end

      ##
      # Passes if +object+ .instance_of? +klass+
      #
      # Example:
      #   assert_instance_of String, 'foo'

      public
      def assert_instance_of(klass, object, message=&quot;&quot;)
        _wrap_assertion do
          assert_equal(Class, klass.class, &quot;assert_instance_of takes a Class as its first argument&quot;)
          full_message = build_message(message, &lt;&lt;EOT, object, klass, object.class)
&lt;?&gt; expected to be an instance of
&lt;?&gt; but was
&lt;?&gt;.
EOT
          assert_block(full_message){object.instance_of?(klass)}
        end
      end

      ##
      # Passes if +object+ is nil.
      #
      # Example:
      #   assert_nil [1, 2].uniq!

      public
      def assert_nil(object, message=&quot;&quot;)
        assert_equal(nil, object, message)
      end

      ##
      # Passes if +object+ .kind_of? +klass+
      #
      # Example:
      #   assert_kind_of Object, 'foo'

      public
      def assert_kind_of(klass, object, message=&quot;&quot;)
        _wrap_assertion do
          assert(klass.kind_of?(Module), &quot;The first parameter to assert_kind_of should be a kind_of Module.&quot;)
          full_message = build_message(message, &quot;&lt;?&gt;\nexpected to be kind_of\\?\n&lt;?&gt; but was\n&lt;?&gt;.&quot;, object, klass, object.class)
          assert_block(full_message){object.kind_of?(klass)}
        end
      end

      ##
      # Passes if +object+ .respond_to? +method+
      #
      # Example:
      #   assert_respond_to 'bugbear', :slice

      public
      def assert_respond_to(object, method, message=&quot;&quot;)
        _wrap_assertion do
          full_message = build_message(nil, &quot;&lt;?&gt;\ngiven as the method name argument to #assert_respond_to must be a Symbol or #respond_to\\?(:to_str).&quot;, method)

          assert_block(full_message) do
            method.kind_of?(Symbol) || method.respond_to?(:to_str)
          end
          full_message = build_message(message, &lt;&lt;EOT, object, object.class, method)
&lt;?&gt;
of type &lt;?&gt;
expected to respond_to\\?&lt;?&gt;.
EOT
          assert_block(full_message) { object.respond_to?(method) }
        end
      end

      ##
      # Passes if +string+ =~ +pattern+.
      #
      # Example:
      #   assert_match(/\d+/, 'five, 6, seven')

      public
      def assert_match(pattern, string, message=&quot;&quot;)
        _wrap_assertion do
          pattern = case(pattern)
            when String
              Regexp.new(Regexp.escape(pattern))
            else
              pattern
          end
          full_message = build_message(message, &quot;&lt;?&gt; expected to be =~\n&lt;?&gt;.&quot;, string, pattern)
          assert_block(full_message) { string =~ pattern }
        end
      end

      ##
      # Passes if +actual+ .equal? +expected+ (i.e. they are the same
      # instance).
      #
      # Example:
      #   o = Object.new
      #   assert_same o, o

      public
      def assert_same(expected, actual, message=&quot;&quot;)
        full_message = build_message(message, &lt;&lt;EOT, expected, expected.__id__, actual, actual.__id__)
&lt;?&gt;
with id &lt;?&gt; expected to be equal\\? to
&lt;?&gt;
with id &lt;?&gt;.
EOT
        assert_block(full_message) { actual.equal?(expected) }
      end

      ##
      # Compares the +object1+ with +object2+ using +operator+.
      #
      # Passes if object1.__send__(operator, object2) is true.
      #
      # Example:
      #   assert_operator 5, :&gt;=, 4

      public
      def assert_operator(object1, operator, object2, message=&quot;&quot;)
        _wrap_assertion do
          full_message = build_message(nil, &quot;&lt;?&gt;\ngiven as the operator for #assert_operator must be a Symbol or #respond_to\\?(:to_str).&quot;, operator)
          assert_block(full_message){operator.kind_of?(Symbol) || operator.respond_to?(:to_str)}
          full_message = build_message(message, &lt;&lt;EOT, object1, AssertionMessage.literal(operator), object2)
&lt;?&gt; expected to be
?
&lt;?&gt;.
EOT
          assert_block(full_message) { object1.__send__(operator, object2) }
        end
      end

      ##
      # Passes if block does not raise an exception.
      #
      # Example:
      #   assert_nothing_raised do
      #     [1, 2].uniq
      #   end

      public
      def assert_nothing_raised(*args)
        _wrap_assertion do
          if Module === args.last
            message = &quot;&quot;
          else
            message = args.pop
          end
          exceptions, modules = _check_exception_class(args)
          begin
            yield
          rescue Exception =&gt; e
            if ((args.empty? &amp;&amp; !e.instance_of?(AssertionFailedError)) ||
                _expected_exception?(e, exceptions, modules))
              assert_block(build_message(message, &quot;Exception raised:\n?&quot;, e)){false}
            else
              raise
            end
          end
          nil
        end
      end

      ##
      # Flunk always fails.
      #
      # Example:
      #   flunk 'Not done testing yet.'

      public
      def flunk(message=&quot;Flunked&quot;)
        assert_block(build_message(message)){false}
      end

      ##
      # Passes if ! +actual+ .equal? +expected+
      #
      # Example:
      #   assert_not_same Object.new, Object.new

      public
      def assert_not_same(expected, actual, message=&quot;&quot;)
        full_message = build_message(message, &lt;&lt;EOT, expected, expected.__id__, actual, actual.__id__)
&lt;?&gt;
with id &lt;?&gt; expected to not be equal\\? to
&lt;?&gt;
with id &lt;?&gt;.
EOT
        assert_block(full_message) { !actual.equal?(expected) }
      end

      ##
      # Passes if +expected+ != +actual+
      #
      # Example:
      #   assert_not_equal 'some string', 5

      public
      def assert_not_equal(expected, actual, message=&quot;&quot;)
        full_message = build_message(message, &quot;&lt;?&gt; expected to be != to\n&lt;?&gt;.&quot;, expected, actual)
        assert_block(full_message) { expected != actual }
      end

      ##
      # Passes if ! +object+ .nil?
      #
      # Example:
      #   assert_not_nil '1 two 3'.sub!(/two/, '2')

      public
      def assert_not_nil(object, message=&quot;&quot;)
        full_message = build_message(message, &quot;&lt;?&gt; expected to not be nil.&quot;, object)
        assert_block(full_message){!object.nil?}
      end

      ##
      # Passes if +regexp+ !~ +string+ 
      #
      # Example:
      #   assert_no_match(/two/, 'one 2 three')

      public
      def assert_no_match(regexp, string, message=&quot;&quot;)
        _wrap_assertion do
          assert_instance_of(Regexp, regexp, &quot;The first argument to assert_no_match should be a Regexp.&quot;)
          full_message = build_message(message, &quot;&lt;?&gt; expected to not match\n&lt;?&gt;.&quot;, regexp, string)
          assert_block(full_message) { regexp !~ string }
        end
      end

      UncaughtThrow = {NameError =&gt; /^uncaught throw \`(.+)\'$/,
                       ThreadError =&gt; /^uncaught throw \`(.+)\' in thread /} #`

      ##
      # Passes if the block throws +expected_symbol+
      #
      # Example:
      #   assert_throws :done do
      #     throw :done
      #   end

      public
      def assert_throws(expected_symbol, message=&quot;&quot;, &amp;proc)
        _wrap_assertion do
          assert_instance_of(Symbol, expected_symbol, &quot;assert_throws expects the symbol that should be thrown for its first argument&quot;)
          assert_block(&quot;Should have passed a block to assert_throws.&quot;){block_given?}
          caught = true
          begin
            catch(expected_symbol) do
              proc.call
              caught = false
            end
            full_message = build_message(message, &quot;&lt;?&gt; should have been thrown.&quot;, expected_symbol)
            assert_block(full_message){caught}
          rescue NameError, ThreadError =&gt; error
            if UncaughtThrow[error.class] !~ error.message
              raise error
            end
            full_message = build_message(message, &quot;&lt;?&gt; expected to be thrown but\n&lt;?&gt; was thrown.&quot;, expected_symbol, $1.intern)
            flunk(full_message)
          end
        end
      end

      ##
      # Passes if block does not throw anything.
      #
      # Example:
      #  assert_nothing_thrown do
      #    [1, 2].uniq
      #  end

      public
      def assert_nothing_thrown(message=&quot;&quot;, &amp;proc)
        _wrap_assertion do
          assert(block_given?, &quot;Should have passed a block to assert_nothing_thrown&quot;)
          begin
            proc.call
          rescue NameError, ThreadError =&gt; error
            if UncaughtThrow[error.class] !~ error.message
              raise error
            end
            full_message = build_message(message, &quot;&lt;?&gt; was thrown when nothing was expected&quot;, $1.intern)
            flunk(full_message)
          end
          assert(true, &quot;Expected nothing to be thrown&quot;)
        end
      end

      ##
      # Passes if +expected_float+ and +actual_float+ are equal
      # within +delta+ tolerance.
      #
      # Example:
      #   assert_in_delta 0.05, (50000.0 / 10**6), 0.00001

      public
      def assert_in_delta(expected_float, actual_float, delta, message=&quot;&quot;)
        _wrap_assertion do
          {expected_float =&gt; &quot;first float&quot;, actual_float =&gt; &quot;second float&quot;, delta =&gt; &quot;delta&quot;}.each do |float, name|
            assert_respond_to(float, :to_f, &quot;The arguments must respond to to_f; the #{name} did not&quot;)
          end
          assert_operator(delta, :&gt;=, 0.0, &quot;The delta should not be negative&quot;)
          full_message = build_message(message, &lt;&lt;EOT, expected_float, actual_float, delta)
&lt;?&gt; and
&lt;?&gt; expected to be within
&lt;?&gt; of each other.
EOT
          assert_block(full_message) { (expected_float.to_f - actual_float.to_f).abs &lt;= delta.to_f }
        end
      end

      ##
      # Passes if the method send returns a true value.
      #
      # +send_array+ is composed of:
      # * A receiver
      # * A method
      # * Arguments to the method
      #
      # Example:
      #   assert_send [[1, 2], :include?, 4]

      public
      def assert_send(send_array, message=&quot;&quot;)
        _wrap_assertion do
          assert_instance_of(Array, send_array, &quot;assert_send requires an array of send information&quot;)
          assert(send_array.size &gt;= 2, &quot;assert_send requires at least a receiver and a message name&quot;)
          full_message = build_message(message, &lt;&lt;EOT, send_array[0], AssertionMessage.literal(send_array[1].to_s), send_array[2..-1])
&lt;?&gt; expected to respond to
&lt;?(?)&gt; with a true value.
EOT
          assert_block(full_message) { send_array[0].__send__(send_array[1], *send_array[2..-1]) }
        end
      end

      ##
      # Builds a failure message.  +head+ is added before the +template+ and
      # +arguments+ replaces the '?'s positionally in the template.

      public
      def build_message(head, template=nil, *arguments)
        template &amp;&amp;= template.chomp
        return AssertionMessage.new(head, template, arguments)
      end

      private
      def _wrap_assertion
        @_assertion_wrapped ||= false
        unless (@_assertion_wrapped)
          @_assertion_wrapped = true
          begin
            add_assertion
            return yield
          ensure
            @_assertion_wrapped = false
          end
        else
          return yield
        end
      end
      
      ##
      # Called whenever an assertion is made.  Define this in classes that
      # include Test::Unit::Assertions to record assertion counts.

      private
      def add_assertion
      end

      ##
      # Select whether or not to use the pretty-printer. If this option is set
      # to false before any assertions are made, pp.rb will not be required.

      public
      def self.use_pp=(value)
        AssertionMessage.use_pp = value
      end
      
      # :stopdoc:

      class AssertionMessage
        @use_pp = true
        class &lt;&lt; self
          attr_accessor :use_pp
        end

        class Literal
          def initialize(value)
            @value = value
          end
          
          def inspect
            @value.to_s
          end
        end

        class Template
          def self.create(string)
            parts = (string ? string.scan(/(?=[^\\])\?|(?:\\\?|[^\?])+/m) : [])
            self.new(parts)
          end

          attr_reader :count

          def initialize(parts)
            @parts = parts
            @count = parts.find_all{|e| e == '?'}.size
          end

          def result(parameters)
            raise &quot;The number of parameters does not match the number of substitutions.&quot; if(parameters.size != count)
            params = parameters.dup
            @parts.collect{|e| e == '?' ? params.shift : e.gsub(/\\\?/m, '?')}.join('')
          end
        end

        def self.literal(value)
          Literal.new(value)
        end

        include Util::BacktraceFilter

        def initialize(head, template_string, parameters)
          @head = head
          @template_string = template_string
          @parameters = parameters
        end

        def convert(object)
          case object
            when Exception
              &lt;&lt;EOM.chop
Class: &lt;#{convert(object.class)}&gt;
Message: &lt;#{convert(object.message)}&gt;
---Backtrace---
#{filter_backtrace(object.backtrace).join(&quot;\n&quot;)}
---------------
EOM
            else
              if(self.class.use_pp)
                begin
                  require 'pp'
                rescue LoadError
                  self.class.use_pp = false
                  return object.inspect
                end unless(defined?(PP))
                PP.pp(object, '').chomp
              else
                object.inspect
              end
          end
        end

        def template
          @template ||= Template.create(@template_string)
        end

        def add_period(string)
          (string =~ /\.\Z/ ? string : string + '.')
        end

        def to_s
          message_parts = []
          if (@head)
            head = @head.to_s 
            unless(head.empty?)
              message_parts &lt;&lt; add_period(head)
            end
          end
          tail = template.result(@parameters.collect{|e| convert(e)})
          message_parts &lt;&lt; tail unless(tail.empty?)
          message_parts.join(&quot;\n&quot;)
        end
      end

      # :startdoc:

    end
  end
end
</pre>
    </div>