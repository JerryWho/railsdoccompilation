  <div id="fileHeader">
    <h1>abbrev.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/abbrev.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#!/usr/bin/env ruby
=begin
#
# Copyright (c) 2001,2003 Akinori MUSHA &lt;knu@iDaemons.org&gt;
#
# All rights reserved.  You can redistribute and/or modify it under
# the same terms as Ruby.
#
# $Idaemons: /home/cvs/rb/abbrev.rb,v 1.2 2001/05/30 09:37:45 knu Exp $
# $RoughId: abbrev.rb,v 1.4 2003/10/14 19:45:42 knu Exp $
# $Id: abbrev.rb 11708 2007-02-12 23:01:19Z shyouhei $
=end

# Calculate the set of unique abbreviations for a given set of strings.
#
#   require 'abbrev'
#   require 'pp'
#
#   pp Abbrev::abbrev(['ruby', 'rules']).sort
#
# &lt;i&gt;Generates:&lt;/i&gt;
#
#   [[&quot;rub&quot;, &quot;ruby&quot;],
#    [&quot;ruby&quot;, &quot;ruby&quot;],
#    [&quot;rul&quot;, &quot;rules&quot;],
#    [&quot;rule&quot;, &quot;rules&quot;],
#    [&quot;rules&quot;, &quot;rules&quot;]]
#
# Also adds an +abbrev+ method to class +Array+.

module Abbrev

  # Given a set of strings, calculate the set of unambiguous
  # abbreviations for those strings, and return a hash where the keys
  # are all the possible abbreviations and the values are the full
  # strings. Thus, given input of &quot;car&quot; and &quot;cone&quot;, the keys pointing
  # to &quot;car&quot; would be &quot;ca&quot; and &quot;car&quot;, while those pointing to &quot;cone&quot;
  # would be &quot;co&quot;, &quot;con&quot;, and &quot;cone&quot;.
  #
  # The optional +pattern+ parameter is a pattern or a string. Only
  # those input strings matching the pattern, or begging the string,
  # are considered for inclusion in the output hash

  def abbrev(words, pattern = nil)
    table = {}
    seen = Hash.new(0)

    if pattern.is_a?(String)
      pattern = /^#{Regexp.quote(pattern)}/	# regard as a prefix
    end

    words.each do |word|
      next if (abbrev = word).empty?
      while (len = abbrev.rindex(/[\w\W]\z/)) &gt; 0
	abbrev = word[0,len]

	next if pattern &amp;&amp; pattern !~ abbrev

	case seen[abbrev] += 1
	when 1
	  table[abbrev] = word
	when 2
	  table.delete(abbrev)
	else
	  break
	end
      end
    end

    words.each do |word|
      next if pattern &amp;&amp; pattern !~ word

      table[word] = word
    end

    table
  end

  module_function :abbrev
end

class Array
  # Calculates the set of unambiguous abbreviations for the strings in
  # +self+. If passed a pattern or a string, only the strings matching
  # the pattern or starting with the string are considered.
  #
  #   %w{ car cone }.abbrev   #=&gt; { &quot;ca&quot; =&gt; &quot;car&quot;, &quot;car&quot; =&gt; &quot;car&quot;,
  #                                 &quot;co&quot; =&gt; &quot;cone&quot;, &quot;con&quot; =&gt; cone&quot;,
  #                                 &quot;cone&quot; =&gt; &quot;cone&quot; }
  def abbrev(pattern = nil)
    Abbrev::abbrev(self, pattern)
  end
end

if $0 == __FILE__
  while line = gets
    hash = line.split.abbrev

    hash.sort.each do |k, v|
      puts &quot;#{k} =&gt; #{v}&quot;
    end
  end
end
</pre>
    </div>