  <div id="fileHeader">
    <h1>completion.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/irb/completion.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
#   irb/completor.rb - 
#   	$Release Version: 0.9$
#   	$Revision: 11708 $
#   	$Date: 2007-02-13 08:01:19 +0900 (Tue, 13 Feb 2007) $
#   	by Keiju ISHITSUKA(keiju@ishitsuka.com)
#       From Original Idea of shugo@ruby-lang.org
#

require &quot;readline&quot;

module IRB
  module InputCompletor

    @RCS_ID='-$Id: completion.rb 11708 2007-02-12 23:01:19Z shyouhei $-'

    ReservedWords = [
      &quot;BEGIN&quot;, &quot;END&quot;,
      &quot;alias&quot;, &quot;and&quot;, 
      &quot;begin&quot;, &quot;break&quot;, 
      &quot;case&quot;, &quot;class&quot;,
      &quot;def&quot;, &quot;defined&quot;, &quot;do&quot;,
      &quot;else&quot;, &quot;elsif&quot;, &quot;end&quot;, &quot;ensure&quot;,
      &quot;false&quot;, &quot;for&quot;, 
      &quot;if&quot;, &quot;in&quot;, 
      &quot;module&quot;, 
      &quot;next&quot;, &quot;nil&quot;, &quot;not&quot;,
      &quot;or&quot;, 
      &quot;redo&quot;, &quot;rescue&quot;, &quot;retry&quot;, &quot;return&quot;,
      &quot;self&quot;, &quot;super&quot;,
      &quot;then&quot;, &quot;true&quot;,
      &quot;undef&quot;, &quot;unless&quot;, &quot;until&quot;,
      &quot;when&quot;, &quot;while&quot;,
      &quot;yield&quot;,
    ]
      
    CompletionProc = proc { |input|
      bind = IRB.conf[:MAIN_CONTEXT].workspace.binding
      
#      puts &quot;input: #{input}&quot;

      case input
      when /^(\/[^\/]*\/)\.([^.]*)$/
	# Regexp
	receiver = $1
	message = Regexp.quote($2)

	candidates = Regexp.instance_methods(true)
	select_message(receiver, message, candidates)

      when /^([^\]]*\])\.([^.]*)$/
	# Array
	receiver = $1
	message = Regexp.quote($2)

	candidates = Array.instance_methods(true)
	select_message(receiver, message, candidates)

      when /^([^\}]*\})\.([^.]*)$/
	# Proc or Hash
	receiver = $1
	message = Regexp.quote($2)

	candidates = Proc.instance_methods(true) | Hash.instance_methods(true)
	select_message(receiver, message, candidates)
	
      when /^(:[^:.]*)$/
 	# Symbol
	if Symbol.respond_to?(:all_symbols)
	  sym = $1
	  candidates = Symbol.all_symbols.collect{|s| &quot;:&quot; + s.id2name}
	  candidates.grep(/^#{sym}/)
	else
	  []
	end

      when /^::([A-Z][^:\.\(]*)$/
	# Absolute Constant or class methods
	receiver = $1
	candidates = Object.constants
	candidates.grep(/^#{receiver}/).collect{|e| &quot;::&quot; + e}

      when /^(((::)?[A-Z][^:.\(]*)+)::?([^:.]*)$/
	# Constant or class methods
	receiver = $1
	message = Regexp.quote($4)
	begin
	  candidates = eval(&quot;#{receiver}.constants | #{receiver}.methods&quot;, bind)
	rescue Exception
	  candidates = []
	end
	candidates.grep(/^#{message}/).collect{|e| receiver + &quot;::&quot; + e}

      when /^(:[^:.]+)\.([^.]*)$/
	# Symbol
	receiver = $1
	message = Regexp.quote($2)

	candidates = Symbol.instance_methods(true)
	select_message(receiver, message, candidates)

      when /^(-?(0[dbo])?[0-9_]+(\.[0-9_]+)?([eE]-?[0-9]+)?)\.([^.]*)$/
	# Numeric
	receiver = $1
	message = Regexp.quote($5)

	begin
	  candidates = eval(receiver, bind).methods
	rescue Exception
	  candidates = []
	end
	select_message(receiver, message, candidates)

      when /^(-?0x[0-9a-fA-F_]+)\.([^.]*)$/
	# Numeric(0xFFFF)
	receiver = $1
	message = Regexp.quote($2)

	begin
	  candidates = eval(receiver, bind).methods
	rescue Exception
	  candidates = []
	end
	select_message(receiver, message, candidates)

      when /^(\$[^.]*)$/
	candidates = global_variables.grep(Regexp.new(Regexp.quote($1)))

#      when /^(\$?(\.?[^.]+)+)\.([^.]*)$/
      when /^((\.?[^.]+)+)\.([^.]*)$/
	# variable
	receiver = $1
	message = Regexp.quote($3)

	gv = eval(&quot;global_variables&quot;, bind)
	lv = eval(&quot;local_variables&quot;, bind)
	cv = eval(&quot;self.class.constants&quot;, bind)
	
	if (gv | lv | cv).include?(receiver)
	  # foo.func and foo is local var.
	  candidates = eval(&quot;#{receiver}.methods&quot;, bind)
	elsif /^[A-Z]/ =~ receiver and /\./ !~ receiver
	  # Foo::Bar.func
	  begin
	    candidates = eval(&quot;#{receiver}.methods&quot;, bind)
	  rescue Exception
	    candidates = []
	  end
	else
	  # func1.func2
	  candidates = []
	  ObjectSpace.each_object(Module){|m|
	    begin
	      name = m.name
	    rescue Exception
	      name = &quot;&quot;
	    end
	    next if name != &quot;IRB::Context&quot; and 
	      /^(IRB|SLex|RubyLex|RubyToken)/ =~ name
	    candidates.concat m.instance_methods(false)
	  }
	  candidates.sort!
	  candidates.uniq!
	end
	select_message(receiver, message, candidates)

      when /^\.([^.]*)$/
	# unknown(maybe String)

	receiver = &quot;&quot;
	message = Regexp.quote($1)

	candidates = String.instance_methods(true)
	select_message(receiver, message, candidates)

      else
	candidates = eval(&quot;methods | private_methods | local_variables | self.class.constants&quot;, bind)
			  
	(candidates|ReservedWords).grep(/^#{Regexp.quote(input)}/)
      end
    }

    Operators = [&quot;%&quot;, &quot;&amp;&quot;, &quot;*&quot;, &quot;**&quot;, &quot;+&quot;,  &quot;-&quot;,  &quot;/&quot;,
      &quot;&lt;&quot;, &quot;&lt;&lt;&quot;, &quot;&lt;=&quot;, &quot;&lt;=&gt;&quot;, &quot;==&quot;, &quot;===&quot;, &quot;=~&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;&gt;&gt;&quot;,
      &quot;[]&quot;, &quot;[]=&quot;, &quot;^&quot;,]

    def self.select_message(receiver, message, candidates)
      candidates.grep(/^#{message}/).collect do |e|
	case e
	when /^[a-zA-Z_]/
	  receiver + &quot;.&quot; + e
	when /^[0-9]/
	when *Operators
	  #receiver + &quot; &quot; + e
	end
      end
    end
  end
end

if Readline.respond_to?(&quot;basic_word_break_characters=&quot;)
  Readline.basic_word_break_characters= &quot; \t\n\&quot;\\'`&gt;&lt;=;|&amp;{(&quot;
end
Readline.completion_append_character = nil
Readline.completion_proc = IRB::InputCompletor::CompletionProc
</pre>
    </div>