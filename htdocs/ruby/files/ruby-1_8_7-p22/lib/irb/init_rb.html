  <div id="fileHeader">
    <h1>init.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/irb/init.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
#   irb/init.rb - irb initialize module
#   	$Release Version: 0.9.5$
#   	$Revision: 11708 $
#   	$Date: 2007-02-13 08:01:19 +0900 (Tue, 13 Feb 2007) $
#   	by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#   
#

module IRB

  # initialize config
  def IRB.setup(ap_path)
    IRB.init_config(ap_path)
    IRB.init_error
    IRB.parse_opts
    IRB.run_config
    IRB.load_modules

    unless @CONF[:PROMPT][@CONF[:PROMPT_MODE]]
      IRB.fail(UndefinedPromptMode, @CONF[:PROMPT_MODE]) 
    end
  end

  # @CONF default setting
  def IRB.init_config(ap_path)
    # class instance variables
    @TRACER_INITIALIZED = false

    # default configurations
    unless ap_path and @CONF[:AP_NAME]
      ap_path = File.join(File.dirname(File.dirname(__FILE__)), &quot;irb.rb&quot;)
    end
    @CONF[:AP_NAME] = File::basename(ap_path, &quot;.rb&quot;)

    @CONF[:IRB_NAME] = &quot;irb&quot;
    @CONF[:IRB_LIB_PATH] = File.dirname(__FILE__)

    @CONF[:RC] = true
    @CONF[:LOAD_MODULES] = []
    @CONF[:IRB_RC] = nil

    @CONF[:MATH_MODE] = false
    @CONF[:USE_READLINE] = false unless defined?(ReadlineInputMethod)
    @CONF[:INSPECT_MODE] = nil
    @CONF[:USE_TRACER] = false
    @CONF[:USE_LOADER] = false
    @CONF[:IGNORE_SIGINT] = true
    @CONF[:IGNORE_EOF] = false
    @CONF[:ECHO] = nil
    @CONF[:VERBOSE] = nil

    @CONF[:EVAL_HISTORY] = nil
    @CONF[:SAVE_HISTORY] = nil

    @CONF[:BACK_TRACE_LIMIT] = 16

    @CONF[:PROMPT] = {
      :NULL =&gt; {
	:PROMPT_I =&gt; nil,
	:PROMPT_N =&gt; nil,
	:PROMPT_S =&gt; nil,
	:PROMPT_C =&gt; nil,
	:RETURN =&gt; &quot;%s\n&quot;
      },
      :DEFAULT =&gt; {
	:PROMPT_I =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,
	:PROMPT_N =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,
	:PROMPT_S =&gt; &quot;%N(%m):%03n:%i%l &quot;,
	:PROMPT_C =&gt; &quot;%N(%m):%03n:%i* &quot;,
	:RETURN =&gt; &quot;=&gt; %s\n&quot;
      },
      :CLASSIC =&gt; {
	:PROMPT_I =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,
	:PROMPT_N =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,
	:PROMPT_S =&gt; &quot;%N(%m):%03n:%i%l &quot;,
	:PROMPT_C =&gt; &quot;%N(%m):%03n:%i* &quot;,
	:RETURN =&gt; &quot;%s\n&quot;
      },
      :SIMPLE =&gt; {
	:PROMPT_I =&gt; &quot;&gt;&gt; &quot;,
	:PROMPT_N =&gt; &quot;&gt;&gt; &quot;,
	:PROMPT_S =&gt; nil,
	:PROMPT_C =&gt; &quot;?&gt; &quot;,
	:RETURN =&gt; &quot;=&gt; %s\n&quot;
      },
      :INF_RUBY =&gt; {
	:PROMPT_I =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,
#	:PROMPT_N =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,
	:PROMPT_N =&gt; nil,
	:PROMPT_S =&gt; nil,
	:PROMPT_C =&gt; nil,
	:RETURN =&gt; &quot;%s\n&quot;,
	:AUTO_INDENT =&gt; true
      },
      :XMP =&gt; {
	:PROMPT_I =&gt; nil,
	:PROMPT_N =&gt; nil,
	:PROMPT_S =&gt; nil,
	:PROMPT_C =&gt; nil,
	:RETURN =&gt; &quot;    ==&gt;%s\n&quot;
      }
    }

    @CONF[:PROMPT_MODE] = (STDIN.tty? ? :DEFAULT : :NULL)
    @CONF[:AUTO_INDENT] = false

    @CONF[:CONTEXT_MODE] = 3 # use binding in function on TOPLEVEL_BINDING
    @CONF[:SINGLE_IRB] = false

#    @CONF[:LC_MESSAGES] = &quot;en&quot;
    @CONF[:LC_MESSAGES] = Locale.new
    
    @CONF[:DEBUG_LEVEL] = 1
  end

  def IRB.init_error
    @CONF[:LC_MESSAGES].load(&quot;irb/error.rb&quot;)
  end

  FEATURE_IOPT_CHANGE_VERSION = &quot;1.9.0&quot;

  # option analyzing
  def IRB.parse_opts
    load_path = []
    while opt = ARGV.shift
      case opt
      when &quot;-f&quot;
	@CONF[:RC] = false
      when &quot;-m&quot;
	@CONF[:MATH_MODE] = true
      when &quot;-d&quot;
	$DEBUG = true
      when /^-r(.+)?/
	opt = $1 || ARGV.shift
	@CONF[:LOAD_MODULES].push opt if opt
      when /^-I(.+)?/
        opt = $1 || ARGV.shift
	load_path.concat(opt.split(File::PATH_SEPARATOR)) if opt
      when /^-K(.)/
	$KCODE = $1
      when &quot;--inspect&quot;
	@CONF[:INSPECT_MODE] = true
      when &quot;--noinspect&quot;
	@CONF[:INSPECT_MODE] = false
      when &quot;--readline&quot;
	@CONF[:USE_READLINE] = true
      when &quot;--noreadline&quot;
	@CONF[:USE_READLINE] = false
      when &quot;--echo&quot;
	@CONF[:ECHO] = true
      when &quot;--noecho&quot;
	@CONF[:ECHO] = false
      when &quot;--verbose&quot;
	@CONF[:VERBOSE] = true
      when &quot;--noverbose&quot;
	@CONF[:VERBOSE] = false
      when &quot;--prompt-mode&quot;, &quot;--prompt&quot;
	prompt_mode = ARGV.shift.upcase.tr(&quot;-&quot;, &quot;_&quot;).intern
	@CONF[:PROMPT_MODE] = prompt_mode
      when &quot;--noprompt&quot;
	@CONF[:PROMPT_MODE] = :NULL
      when &quot;--inf-ruby-mode&quot;
	@CONF[:PROMPT_MODE] = :INF_RUBY
      when &quot;--sample-book-mode&quot;, &quot;--simple-prompt&quot;
	@CONF[:PROMPT_MODE] = :SIMPLE
      when &quot;--tracer&quot;
	@CONF[:USE_TRACER] = true
      when &quot;--back-trace-limit&quot;
	@CONF[:BACK_TRACE_LIMIT] = ARGV.shift.to_i
      when &quot;--context-mode&quot;
	@CONF[:CONTEXT_MODE] = ARGV.shift.to_i
      when &quot;--single-irb&quot;
	@CONF[:SINGLE_IRB] = true
      when &quot;--irb_debug&quot;
	@CONF[:DEBUG_LEVEL] = ARGV.shift.to_i
      when &quot;-v&quot;, &quot;--version&quot;
	print IRB.version, &quot;\n&quot;
	exit 0
      when &quot;-h&quot;, &quot;--help&quot;
	require &quot;irb/help&quot;
	IRB.print_usage
	exit 0
      when /^-/
	IRB.fail UnrecognizedSwitch, opt
      else
	@CONF[:SCRIPT] = opt
	$0 = opt
	break
      end
    end
    if RUBY_VERSION &gt;= FEATURE_IOPT_CHANGE_VERSION
      load_path.collect! do |path|
	/\A\.\// =~ path ? path : File.expand_path(path)
      end
    end
    $LOAD_PATH.unshift(*load_path)
  end

  # running config
  def IRB.run_config
    if @CONF[:RC]
      begin
	load rc_file
      rescue LoadError, Errno::ENOENT
      rescue
	print &quot;load error: #{rc_file}\n&quot;
	print $!.class, &quot;: &quot;, $!, &quot;\n&quot;
	for err in $@[0, $@.size - 2]
	  print &quot;\t&quot;, err, &quot;\n&quot;
	end
      end
    end
  end

  IRBRC_EXT = &quot;rc&quot;
  def IRB.rc_file(ext = IRBRC_EXT)
    if !@CONF[:RC_NAME_GENERATOR]
      rc_file_generators do |rcgen|
	@CONF[:RC_NAME_GENERATOR] ||= rcgen
	if File.exist?(rcgen.call(IRBRC_EXT))
	  @CONF[:RC_NAME_GENERATOR] = rcgen
	  break
	end
      end
    end
    @CONF[:RC_NAME_GENERATOR].call ext
  end

  # enumerate possible rc-file base name generators
  def IRB.rc_file_generators
    if irbrc = ENV[&quot;IRBRC&quot;]
      yield proc{|rc|  rc == &quot;rc&quot; ? irbrc : irbrc+rc}
    end
    if home = ENV[&quot;HOME&quot;]
      yield proc{|rc| home+&quot;/.irb#{rc}&quot;} 
    end
    home = Dir.pwd
    yield proc{|rc| home+&quot;/.irb#{rc}&quot;}
    yield proc{|rc| home+&quot;/irb#{rc.sub(/\A_?/, '.')}&quot;}
    yield proc{|rc| home+&quot;/_irb#{rc}&quot;}
    yield proc{|rc| home+&quot;/$irb#{rc}&quot;}
  end

  # loading modules
  def IRB.load_modules
    for m in @CONF[:LOAD_MODULES]
      begin
	require m
      rescue
	print $@[0], &quot;:&quot;, $!.class, &quot;: &quot;, $!, &quot;\n&quot;
      end
    end
  end

end
</pre>
    </div>