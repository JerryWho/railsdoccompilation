  <div id="fileHeader">
    <h1>slex.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/irb/slex.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
#   irb/slex.rb - simple lex analyzer
#   	$Release Version: 0.9.5$
#   	$Revision: 16857 $
#   	$Date: 2008-06-06 17:05:24 +0900 (Fri, 06 Jun 2008) $
#   	by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#   
#

require &quot;e2mmap&quot;
require &quot;irb/notifier&quot;

module IRB
  class SLex
    @RCS_ID='-$Id: slex.rb 16857 2008-06-06 08:05:24Z knu $-'

    extend Exception2MessageMapper
    def_exception :ErrNodeNothing, &quot;node nothing&quot;
    def_exception :ErrNodeAlreadyExists, &quot;node already exists&quot;

    DOUT = Notifier::def_notifier(&quot;SLex::&quot;)
    D_WARN = DOUT::def_notifier(1, &quot;Warn: &quot;)
    D_DEBUG = DOUT::def_notifier(2, &quot;Debug: &quot;)
    D_DETAIL = DOUT::def_notifier(4, &quot;Detail: &quot;)
    
    DOUT.level = Notifier::D_NOMSG

    def initialize
      @head = Node.new(&quot;&quot;)
    end
    
    def def_rule(token, preproc = nil, postproc = nil, &amp;block)
      D_DETAIL.pp token

      postproc = block if block_given?
      node = create(token, preproc, postproc)
    end
    
    def def_rules(*tokens, &amp;block)
      if block_given?
	p = block
      end
      for token in tokens
	def_rule(token, nil, p)
      end
    end
    
    def preproc(token, proc)
      node = search(token)
      node.preproc=proc
    end
    
    #要チェック? 
    def postproc(token)
      node = search(token, proc)
      node.postproc=proc
    end
    
    def search(token)
      @head.search(token.split(//))
    end

    def create(token, preproc = nil, postproc = nil)
      @head.create_subnode(token.split(//), preproc, postproc)
    end
    
    def match(token)
      case token
      when Array
      when String
	return match(token.split(//))
      else
	return @head.match_io(token)
      end
      ret = @head.match(token)
      D_DETAIL.exec_if{D_DEATIL.printf &quot;match end: %s:%s\n&quot;, ret, token.inspect}
      ret
    end
    
    def inspect
      format(&quot;&lt;SLex: @head = %s&gt;&quot;, @head.inspect)
    end

    #----------------------------------------------------------------------
    #
    #   class Node - 
    #
    #----------------------------------------------------------------------
    class Node
      # if postproc is nil, this node is an abstract node.
      # if postproc is non-nil, this node is a real node.
      def initialize(preproc = nil, postproc = nil)
	@Tree = {}
	@preproc = preproc
	@postproc = postproc
      end

      attr_accessor :preproc
      attr_accessor :postproc
      
      def search(chrs, opt = nil)
	return self if chrs.empty?
	ch = chrs.shift
	if node = @Tree[ch]
	  node.search(chrs, opt)
	else
	  if opt
	    chrs.unshift ch
	    self.create_subnode(chrs)
	  else
	    SLex.fail ErrNodeNothing
	  end
	end
      end
      
      def create_subnode(chrs, preproc = nil, postproc = nil)
	if chrs.empty?
	  if @postproc
	    D_DETAIL.pp node
	    SLex.fail ErrNodeAlreadyExists
	  else
	    D_DEBUG.puts &quot;change abstract node to real node.&quot;
	    @preproc = preproc
	    @postproc = postproc
	  end
	  return self
	end
	
	ch = chrs.shift
	if node = @Tree[ch]
	  if chrs.empty?
	    if node.postproc
	      DebugLogger.pp node
	      DebugLogger.pp self
	      DebugLogger.pp ch
	      DebugLogger.pp chrs
	      SLex.fail ErrNodeAlreadyExists
	    else
	      D_WARN.puts &quot;change abstract node to real node&quot;
	      node.preproc = preproc
	      node.postproc = postproc
	    end
	  else
	    node.create_subnode(chrs, preproc, postproc)
	  end
	else
	  if chrs.empty?
	    node = Node.new(preproc, postproc)
	  else
	    node = Node.new
	    node.create_subnode(chrs, preproc, postproc)
	  end
	  @Tree[ch] = node
	end
	node
      end

      #
      # chrs: String
      #       character array
      #       io must have getc()/ungetc(); and ungetc() must be
      #       able to be called arbitrary number of times. 
      #
      def match(chrs, op = &quot;&quot;)
	D_DETAIL.print &quot;match&gt;: &quot;, chrs, &quot;op:&quot;, op, &quot;\n&quot;
	if chrs.empty?
	  if @preproc.nil? || @preproc.call(op, chrs)
	    DOUT.printf(D_DETAIL, &quot;op1: %s\n&quot;, op)
	    @postproc.call(op, chrs)
	  else
	    nil
	  end
	else
	  ch = chrs.shift
	  if node = @Tree[ch]
	    if ret = node.match(chrs, op+ch)
	      return ret
	    else
	      chrs.unshift ch
	      if @postproc and @preproc.nil? || @preproc.call(op, chrs)
		DOUT.printf(D_DETAIL, &quot;op2: %s\n&quot;, op.inspect)
		ret = @postproc.call(op, chrs)
		return ret
	      else
		return nil
	      end
	    end
	  else
	    chrs.unshift ch
	    if @postproc and @preproc.nil? || @preproc.call(op, chrs)
	      DOUT.printf(D_DETAIL, &quot;op3: %s\n&quot;, op)
	      @postproc.call(op, chrs)
	      return &quot;&quot;
	    else
	      return nil
	    end
	  end
	end
      end

      def match_io(io, op = &quot;&quot;)
	if op == &quot;&quot;
	  ch = io.getc
	  if ch == nil
	    return nil
	  end
	else
	  ch = io.getc_of_rests
	end
	if ch.nil?
	  if @preproc.nil? || @preproc.call(op, io)
	    D_DETAIL.printf(&quot;op1: %s\n&quot;, op)
	    @postproc.call(op, io)
	  else
	    nil
	  end
	else
	  if node = @Tree[ch]
	    if ret = node.match_io(io, op+ch)
	      ret
	    else
	      io.ungetc ch
	      if @postproc and @preproc.nil? || @preproc.call(op, io)
		DOUT.exec_if{D_DETAIL.printf &quot;op2: %s\n&quot;, op.inspect}
		@postproc.call(op, io)
	      else
		nil
	      end
	    end
	  else
	    io.ungetc ch
	    if @postproc and @preproc.nil? || @preproc.call(op, io)
	      D_DETAIL.printf(&quot;op3: %s\n&quot;, op)
	      @postproc.call(op, io)
	    else
	      nil
	    end
	  end
	end
      end
    end
  end
end

SLex=IRB::SLex

if $0 == __FILE__
  #    Tracer.on
  case $1
  when &quot;1&quot;
    tr = SLex.new
    print &quot;0: &quot;, tr.inspect, &quot;\n&quot;
    tr.def_rule(&quot;=&quot;) {print &quot;=\n&quot;}
    print &quot;1: &quot;, tr.inspect, &quot;\n&quot;
    tr.def_rule(&quot;==&quot;) {print &quot;==\n&quot;}
    print &quot;2: &quot;, tr.inspect, &quot;\n&quot;
    
    print &quot;case 1:\n&quot;
    print tr.match(&quot;=&quot;), &quot;\n&quot;
    print &quot;case 2:\n&quot;
    print tr.match(&quot;==&quot;), &quot;\n&quot;
    print &quot;case 3:\n&quot;
    print tr.match(&quot;=&gt;&quot;), &quot;\n&quot;
    
  when &quot;2&quot;
    tr = SLex.new
    print &quot;0: &quot;, tr.inspect, &quot;\n&quot;
    tr.def_rule(&quot;=&quot;) {print &quot;=\n&quot;}
    print &quot;1: &quot;, tr.inspect, &quot;\n&quot;
    tr.def_rule(&quot;==&quot;, proc{false}) {print &quot;==\n&quot;}
    print &quot;2: &quot;, tr.inspect, &quot;\n&quot;
    
    print &quot;case 1:\n&quot;
    print tr.match(&quot;=&quot;), &quot;\n&quot;
    print &quot;case 2:\n&quot;
    print tr.match(&quot;==&quot;), &quot;\n&quot;
    print &quot;case 3:\n&quot;
    print tr.match(&quot;=&gt;&quot;), &quot;\n&quot;
  end
  exit
end

</pre>
    </div>