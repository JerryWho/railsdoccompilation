  <div id="fileHeader">
    <h1>ruby-lex.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/irb/ruby-lex.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
#   irb/ruby-lex.rb - ruby lexcal analyzer
#   	$Release Version: 0.9.5$
#   	$Revision: 16857 $
#   	$Date: 2008-06-06 17:05:24 +0900 (Fri, 06 Jun 2008) $
#   	by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#   
#

require &quot;e2mmap&quot;
require &quot;irb/slex&quot;
require &quot;irb/ruby-token&quot;

class RubyLex
  @RCS_ID='-$Id: ruby-lex.rb 16857 2008-06-06 08:05:24Z knu $-'

  extend Exception2MessageMapper
  def_exception(:AlreadyDefinedToken, &quot;Already defined token(%s)&quot;)
  def_exception(:TkReading2TokenNoKey, &quot;key nothing(key='%s')&quot;)
  def_exception(:TkSymbol2TokenNoKey, &quot;key nothing(key='%s')&quot;)
  def_exception(:TkReading2TokenDuplicateError, 
		&quot;key duplicate(token_n='%s', key='%s')&quot;)
  def_exception(:SyntaxError, &quot;%s&quot;)

  def_exception(:TerminateLineInput, &quot;Terminate Line Input&quot;)
  
  include RubyToken

  class &lt;&lt; self
    attr_accessor :debug_level
    def debug?
      @debug_level &gt; 0
    end
  end
  @debug_level = 0

  def initialize
    lex_init
    set_input(STDIN)

    @seek = 0
    @exp_line_no = @line_no = 1
    @base_char_no = 0
    @char_no = 0
    @rests = []
    @readed = []
    @here_readed = []

    @indent = 0
    @indent_stack = []
    @lex_state = EXPR_BEG
    @space_seen = false
    @here_header = false
    
    @continue = false
    @line = &quot;&quot;

    @skip_space = false
    @readed_auto_clean_up = false
    @exception_on_syntax_error = true

    @prompt = nil
  end

  attr_accessor :skip_space
  attr_accessor :readed_auto_clean_up
  attr_accessor :exception_on_syntax_error

  attr_reader :seek
  attr_reader :char_no
  attr_reader :line_no
  attr_reader :indent

  # io functions
  def set_input(io, p = nil, &amp;block)
    @io = io
    if p.respond_to?(:call)
      @input = p
    elsif block_given?
      @input = block
    else
      @input = Proc.new{@io.gets}
    end
  end

  def get_readed
    if idx = @readed.reverse.index(&quot;\n&quot;)
      @base_char_no = idx
    else
      @base_char_no += @readed.size
    end
    
    readed = @readed.join(&quot;&quot;)
    @readed = []
    readed
  end

  def getc
    while @rests.empty?
#      return nil unless buf_input
      @rests.push nil unless buf_input
    end
    c = @rests.shift
    if @here_header
      @here_readed.push c
    else
      @readed.push c
    end
    @seek += 1
    if c == &quot;\n&quot;
      @line_no += 1 
      @char_no = 0
    else
      @char_no += 1
    end
    c
  end

  def gets
    l = &quot;&quot;
    while c = getc
      l.concat(c)
      break if c == &quot;\n&quot;
    end
    return nil if l == &quot;&quot; and c.nil?
    l
  end

  def eof?
    @io.eof?
  end

  def getc_of_rests
    if @rests.empty?
      nil
    else
      getc
    end
  end

  def ungetc(c = nil)
    if @here_readed.empty?
      c2 = @readed.pop
    else
      c2 = @here_readed.pop
    end
    c = c2 unless c
    @rests.unshift c #c = 
      @seek -= 1
    if c == &quot;\n&quot;
      @line_no -= 1 
      if idx = @readed.reverse.index(&quot;\n&quot;)
	@char_no = @readed.size - idx
      else
	@char_no = @base_char_no + @readed.size
      end
    else
      @char_no -= 1
    end
  end

  def peek_equal?(str)
    chrs = str.split(//)
    until @rests.size &gt;= chrs.size
      return false unless buf_input
    end
    @rests[0, chrs.size] == chrs
  end

  def peek_match?(regexp)
    while @rests.empty?
      return false unless buf_input
    end
    regexp =~ @rests.join(&quot;&quot;)
  end

  def peek(i = 0)
    while @rests.size &lt;= i
      return nil unless buf_input
    end
    @rests[i]
  end

  def buf_input
    prompt
    line = @input.call
    return nil unless line
    @rests.concat line.split(//)
    true
  end
  private :buf_input

  def set_prompt(p = nil, &amp;block)
    p = block if block_given?
    if p.respond_to?(:call)
      @prompt = p
    else
      @prompt = Proc.new{print p}
    end
  end

  def prompt
    if @prompt
      @prompt.call(@ltype, @indent, @continue, @line_no)
    end
  end

  def initialize_input
    @ltype = nil
    @quoted = nil
    @indent = 0
    @indent_stack = []
    @lex_state = EXPR_BEG
    @space_seen = false
    @here_header = false
    
    @continue = false
    prompt

    @line = &quot;&quot;
    @exp_line_no = @line_no
  end
  
  def each_top_level_statement
    initialize_input
    catch(:TERM_INPUT) do
      loop do
	begin
	  @continue = false
	  prompt
	  unless l = lex
	    throw :TERM_INPUT if @line == ''
	  else
	    #p l
	    @line.concat l
	    if @ltype or @continue or @indent &gt; 0
	      next
	    end
	  end
	  if @line != &quot;\n&quot;
	    yield @line, @exp_line_no
	  end
	  break unless l
	  @line = ''
	  @exp_line_no = @line_no

	  @indent = 0
	  @indent_stack = []
	  prompt
	rescue TerminateLineInput
	  initialize_input
	  prompt
	  get_readed
	end
      end
    end
  end

  def lex
    until (((tk = token).kind_of?(TkNL) || tk.kind_of?(TkEND_OF_SCRIPT)) &amp;&amp;
	     !@continue or
	     tk.nil?)
      #p tk
      #p @lex_state
      #p self
    end
    line = get_readed
    #      print self.inspect
    if line == &quot;&quot; and tk.kind_of?(TkEND_OF_SCRIPT) || tk.nil?
      nil
    else
      line
    end
  end

  def token
    #      require &quot;tracer&quot;
    #      Tracer.on
    @prev_seek = @seek
    @prev_line_no = @line_no
    @prev_char_no = @char_no
    begin
      begin
	tk = @OP.match(self)
	@space_seen = tk.kind_of?(TkSPACE)
      rescue SyntaxError
	raise if @exception_on_syntax_error
	tk = TkError.new(@seek, @line_no, @char_no)
      end
    end while @skip_space and tk.kind_of?(TkSPACE)
    if @readed_auto_clean_up
      get_readed
    end
    #      Tracer.off
    tk
  end
  
  ENINDENT_CLAUSE = [
    &quot;case&quot;, &quot;class&quot;, &quot;def&quot;, &quot;do&quot;, &quot;for&quot;, &quot;if&quot;,
    &quot;module&quot;, &quot;unless&quot;, &quot;until&quot;, &quot;while&quot;, &quot;begin&quot; #, &quot;when&quot;
  ]
  DEINDENT_CLAUSE = [&quot;end&quot; #, &quot;when&quot;
  ]

  PERCENT_LTYPE = {
    &quot;q&quot; =&gt; &quot;\'&quot;,
    &quot;Q&quot; =&gt; &quot;\&quot;&quot;,
    &quot;x&quot; =&gt; &quot;\`&quot;,
    &quot;r&quot; =&gt; &quot;/&quot;,
    &quot;w&quot; =&gt; &quot;]&quot;,
    &quot;W&quot; =&gt; &quot;]&quot;,
    &quot;s&quot; =&gt; &quot;:&quot;
  }
  
  PERCENT_PAREN = {
    &quot;{&quot; =&gt; &quot;}&quot;,
    &quot;[&quot; =&gt; &quot;]&quot;,
    &quot;&lt;&quot; =&gt; &quot;&gt;&quot;,
    &quot;(&quot; =&gt; &quot;)&quot;
  }

  Ltype2Token = {
    &quot;\'&quot; =&gt; TkSTRING,
    &quot;\&quot;&quot; =&gt; TkSTRING,
    &quot;\`&quot; =&gt; TkXSTRING,
    &quot;/&quot; =&gt; TkREGEXP,
    &quot;]&quot; =&gt; TkDSTRING,
    &quot;:&quot; =&gt; TkSYMBOL
  }
  DLtype2Token = {
    &quot;\&quot;&quot; =&gt; TkDSTRING,
    &quot;\`&quot; =&gt; TkDXSTRING,
    &quot;/&quot; =&gt; TkDREGEXP,
  }

  def lex_init()
    @OP = IRB::SLex.new
    @OP.def_rules(&quot;\0&quot;, &quot;\004&quot;, &quot;\032&quot;) do |op, io|
      Token(TkEND_OF_SCRIPT)
    end

    @OP.def_rules(&quot; &quot;, &quot;\t&quot;, &quot;\f&quot;, &quot;\r&quot;, &quot;\13&quot;) do |op, io|
      @space_seen = true
      while getc =~ /[ \t\f\r\13]/; end
      ungetc
      Token(TkSPACE)
    end

    @OP.def_rule(&quot;#&quot;) do |op, io|
      identify_comment
    end

    @OP.def_rule(&quot;=begin&quot;,
		 proc{|op, io| @prev_char_no == 0 &amp;&amp; peek(0) =~ /\s/}) do 
      |op, io|
      @ltype = &quot;=&quot;
      until getc == &quot;\n&quot;; end
      until peek_equal?(&quot;=end&quot;) &amp;&amp; peek(4) =~ /\s/
	until getc == &quot;\n&quot;; end
      end
      gets
      @ltype = nil
      Token(TkRD_COMMENT)
    end

    @OP.def_rule(&quot;\n&quot;) do |op, io|
      print &quot;\\n\n&quot; if RubyLex.debug?
      case @lex_state
      when EXPR_BEG, EXPR_FNAME, EXPR_DOT
	@continue = true
      else
	@continue = false
	@lex_state = EXPR_BEG
	until (@indent_stack.empty? || 
	       [TkLPAREN, TkLBRACK, TkLBRACE, 
		 TkfLPAREN, TkfLBRACK, TkfLBRACE].include?(@indent_stack.last))
	  @indent_stack.pop
	end
      end
      @here_header = false
      @here_readed = []
      Token(TkNL)
    end

    @OP.def_rules(&quot;*&quot;, &quot;**&quot;,	
		  &quot;=&quot;, &quot;==&quot;, &quot;===&quot;, 
		  &quot;=~&quot;, &quot;&lt;=&gt;&quot;,	
		  &quot;&lt;&quot;, &quot;&lt;=&quot;,
		  &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;&gt;&gt;&quot;) do
      |op, io|
      case @lex_state
      when EXPR_FNAME, EXPR_DOT
	@lex_state = EXPR_ARG
      else
	@lex_state = EXPR_BEG
      end
      Token(op)
    end

    @OP.def_rules(&quot;!&quot;, &quot;!=&quot;, &quot;!~&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      Token(op)
    end

    @OP.def_rules(&quot;&lt;&lt;&quot;) do
      |op, io|
      tk = nil
      if @lex_state != EXPR_END &amp;&amp; @lex_state != EXPR_CLASS &amp;&amp;
	  (@lex_state != EXPR_ARG || @space_seen)
	c = peek(0)
	if /\S/ =~ c &amp;&amp; (/[&quot;'`]/ =~ c || /[\w_]/ =~ c || c == &quot;-&quot;)
	  tk = identify_here_document
	end
      end
      unless tk
	tk = Token(op)
	case @lex_state
	when EXPR_FNAME, EXPR_DOT
	  @lex_state = EXPR_ARG
	else
	  @lex_state = EXPR_BEG
	end
      end
      tk
    end

    @OP.def_rules(&quot;'&quot;, '&quot;') do
      |op, io|
      identify_string(op)
    end

    @OP.def_rules(&quot;`&quot;) do
      |op, io|
      if @lex_state == EXPR_FNAME
	@lex_state = EXPR_END
	Token(op)
      else
	identify_string(op)
      end
    end

    @OP.def_rules('?') do
      |op, io|
      if @lex_state == EXPR_END
	@lex_state = EXPR_BEG
	Token(TkQUESTION)
      else
	ch = getc
	if @lex_state == EXPR_ARG &amp;&amp; ch =~ /\s/
	  ungetc
	  @lex_state = EXPR_BEG;
	  Token(TkQUESTION)
	else
	  if (ch == '\\') 
	    read_escape
	  end
	  @lex_state = EXPR_END
	  Token(TkINTEGER)
	end
      end
    end

    @OP.def_rules(&quot;&amp;&quot;, &quot;&amp;&amp;&quot;, &quot;|&quot;, &quot;||&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      Token(op)
    end
    
    @OP.def_rules(&quot;+=&quot;, &quot;-=&quot;, &quot;*=&quot;, &quot;**=&quot;, 
		  &quot;&amp;=&quot;, &quot;|=&quot;, &quot;^=&quot;, &quot;&lt;&lt;=&quot;, &quot;&gt;&gt;=&quot;, &quot;||=&quot;, &quot;&amp;&amp;=&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      op =~ /^(.*)=$/
      Token(TkOPASGN, $1)
    end

    @OP.def_rule(&quot;+@&quot;, proc{|op, io| @lex_state == EXPR_FNAME}) do
      |op, io|
      @lex_state = EXPR_ARG
      Token(op)
    end

    @OP.def_rule(&quot;-@&quot;, proc{|op, io| @lex_state == EXPR_FNAME}) do
      |op, io|
      @lex_state = EXPR_ARG
      Token(op)
    end

    @OP.def_rules(&quot;+&quot;, &quot;-&quot;) do
      |op, io|
      catch(:RET) do
	if @lex_state == EXPR_ARG
	  if @space_seen and peek(0) =~ /[0-9]/
	    throw :RET, identify_number
	  else
	    @lex_state = EXPR_BEG
	  end
	elsif @lex_state != EXPR_END and peek(0) =~ /[0-9]/
	  throw :RET, identify_number
	else
	  @lex_state = EXPR_BEG
	end
	Token(op)
      end
    end

    @OP.def_rule(&quot;.&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      if peek(0) =~ /[0-9]/
	ungetc
	identify_number
      else
	# for &quot;obj.if&quot; etc.
	@lex_state = EXPR_DOT
	Token(TkDOT)
      end
    end

    @OP.def_rules(&quot;..&quot;, &quot;...&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      Token(op)
    end

    lex_int2
  end
  
  def lex_int2
    @OP.def_rules(&quot;]&quot;, &quot;}&quot;, &quot;)&quot;) do
      |op, io|
      @lex_state = EXPR_END
      @indent -= 1
      @indent_stack.pop
      Token(op)
    end

    @OP.def_rule(&quot;:&quot;) do
      |op, io|
      if @lex_state == EXPR_END || peek(0) =~ /\s/
	@lex_state = EXPR_BEG
	Token(TkCOLON)
      else
	@lex_state = EXPR_FNAME;
	Token(TkSYMBEG)
      end
    end

    @OP.def_rule(&quot;::&quot;) do
       |op, io|
#      p @lex_state.id2name, @space_seen
      if @lex_state == EXPR_BEG or @lex_state == EXPR_ARG &amp;&amp; @space_seen
	@lex_state = EXPR_BEG
	Token(TkCOLON3)
      else
	@lex_state = EXPR_DOT
	Token(TkCOLON2)
      end
    end

    @OP.def_rule(&quot;/&quot;) do
      |op, io|
      if @lex_state == EXPR_BEG || @lex_state == EXPR_MID
	identify_string(op)
      elsif peek(0) == '='
	getc
	@lex_state = EXPR_BEG
	Token(TkOPASGN, &quot;/&quot;) #/)
      elsif @lex_state == EXPR_ARG and @space_seen and peek(0) !~ /\s/
	identify_string(op)
      else 
	@lex_state = EXPR_BEG
	Token(&quot;/&quot;) #/)
      end
    end

    @OP.def_rules(&quot;^&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      Token(&quot;^&quot;)
    end

    #       @OP.def_rules(&quot;^=&quot;) do
    # 	@lex_state = EXPR_BEG
    # 	Token(OP_ASGN, :^)
    #       end
    
    @OP.def_rules(&quot;,&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      Token(op)
    end

    @OP.def_rules(&quot;;&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      until (@indent_stack.empty? || 
	     [TkLPAREN, TkLBRACK, TkLBRACE, 
	       TkfLPAREN, TkfLBRACK, TkfLBRACE].include?(@indent_stack.last))
	@indent_stack.pop
      end
      Token(op)
    end

    @OP.def_rule(&quot;~&quot;) do
      |op, io|
      @lex_state = EXPR_BEG
      Token(&quot;~&quot;)
    end

    @OP.def_rule(&quot;~@&quot;, proc{|op, io| @lex_state == EXPR_FNAME}) do
      |op, io|
      @lex_state = EXPR_BEG
      Token(&quot;~&quot;)
    end
    
    @OP.def_rule(&quot;(&quot;) do
      |op, io|
      @indent += 1
      if @lex_state == EXPR_BEG || @lex_state == EXPR_MID
	@lex_state = EXPR_BEG
	tk_c = TkfLPAREN
      else
	@lex_state = EXPR_BEG
	tk_c = TkLPAREN
      end
      @indent_stack.push tk_c
      tk = Token(tk_c)
    end

    @OP.def_rule(&quot;[]&quot;, proc{|op, io| @lex_state == EXPR_FNAME}) do
      |op, io|
      @lex_state = EXPR_ARG
      Token(&quot;[]&quot;)
    end

    @OP.def_rule(&quot;[]=&quot;, proc{|op, io| @lex_state == EXPR_FNAME}) do
      |op, io|
      @lex_state = EXPR_ARG
      Token(&quot;[]=&quot;)
    end

    @OP.def_rule(&quot;[&quot;) do
      |op, io|
      @indent += 1
      if @lex_state == EXPR_FNAME
	tk_c = TkfLBRACK
      else
	if @lex_state == EXPR_BEG || @lex_state == EXPR_MID
	  tk_c = TkLBRACK
	elsif @lex_state == EXPR_ARG &amp;&amp; @space_seen
	  tk_c = TkLBRACK
	else
	  tk_c = TkfLBRACK
	end
	@lex_state = EXPR_BEG
      end
      @indent_stack.push tk_c
      Token(tk_c)
    end

    @OP.def_rule(&quot;{&quot;) do
      |op, io|
      @indent += 1
      if @lex_state != EXPR_END &amp;&amp; @lex_state != EXPR_ARG
	tk_c = TkLBRACE
      else
	tk_c = TkfLBRACE
      end
      @lex_state = EXPR_BEG
      @indent_stack.push tk_c
      Token(tk_c)
    end

    @OP.def_rule('\\') do
      |op, io|
      if getc == &quot;\n&quot;
	@space_seen = true
	@continue = true
	Token(TkSPACE)
      else
	ungetc
	Token(&quot;\\&quot;)
      end
    end

    @OP.def_rule('%') do
      |op, io|
      if @lex_state == EXPR_BEG || @lex_state == EXPR_MID
	identify_quotation
      elsif peek(0) == '='
	getc
	Token(TkOPASGN, :%)
      elsif @lex_state == EXPR_ARG and @space_seen and peek(0) !~ /\s/
	identify_quotation
      else
	@lex_state = EXPR_BEG
	Token(&quot;%&quot;) #))
      end
    end

    @OP.def_rule('$') do
      |op, io|
      identify_gvar
    end

    @OP.def_rule('@') do
      |op, io|
      if peek(0) =~ /[\w_@]/
	ungetc
	identify_identifier
      else
	Token(&quot;@&quot;)
      end
    end

    #       @OP.def_rule(&quot;def&quot;, proc{|op, io| /\s/ =~ io.peek(0)}) do 
    # 	|op, io|
    # 	@indent += 1
    # 	@lex_state = EXPR_FNAME
    # #	@lex_state = EXPR_END
    # #	until @rests[0] == &quot;\n&quot; or @rests[0] == &quot;;&quot;
    # #	  rests.shift
    # #	end
    #       end

    @OP.def_rule(&quot;&quot;) do
      |op, io|
      printf &quot;MATCH: start %s: %s\n&quot;, op, io.inspect if RubyLex.debug?
      if peek(0) =~ /[0-9]/
	t = identify_number
      elsif peek(0) =~ /[\w_]/
	t = identify_identifier
      end
      printf &quot;MATCH: end %s: %s\n&quot;, op, io.inspect if RubyLex.debug?
      t
    end
    
    p @OP if RubyLex.debug?
  end
  
  def identify_gvar
    @lex_state = EXPR_END
    
    case ch = getc
    when /[~_*$?!@\/\\;,=:&lt;&gt;&quot;.]/   #&quot;
      Token(TkGVAR, &quot;$&quot; + ch)
    when &quot;-&quot;
      Token(TkGVAR, &quot;$-&quot; + getc)
    when &quot;&amp;&quot;, &quot;`&quot;, &quot;'&quot;, &quot;+&quot;
      Token(TkBACK_REF, &quot;$&quot;+ch)
    when /[1-9]/
      while getc =~ /[0-9]/; end
      ungetc
      Token(TkNTH_REF)
    when /\w/
      ungetc
      ungetc
      identify_identifier
    else 
      ungetc
      Token(&quot;$&quot;)
    end
  end
  
  def identify_identifier
    token = &quot;&quot;
    if peek(0) =~ /[$@]/
      token.concat(c = getc)
      if c == &quot;@&quot; and peek(0) == &quot;@&quot;
	token.concat getc
      end
    end

    while (ch = getc) =~ /\w|_/
      print &quot;:&quot;, ch, &quot;:&quot; if RubyLex.debug?
      token.concat ch
    end
    ungetc
    
    if (ch == &quot;!&quot; || ch == &quot;?&quot;) &amp;&amp; token[0,1] =~ /\w/ &amp;&amp; peek(0) != &quot;=&quot;
      token.concat getc
    end

    # almost fix token

    case token
    when /^\$/
      return Token(TkGVAR, token)
    when /^\@\@/
      @lex_state = EXPR_END
      # p Token(TkCVAR, token)
      return Token(TkCVAR, token)
    when /^\@/
      @lex_state = EXPR_END
      return Token(TkIVAR, token)
    end
    
    if @lex_state != EXPR_DOT
      print token, &quot;\n&quot; if RubyLex.debug?

      token_c, *trans = TkReading2Token[token]
      if token_c
	# reserved word?

	if (@lex_state != EXPR_BEG &amp;&amp;
	    @lex_state != EXPR_FNAME &amp;&amp;
	    trans[1])
	  # modifiers
	  token_c = TkSymbol2Token[trans[1]]
	  @lex_state = trans[0]
	else
	  if @lex_state != EXPR_FNAME
	    if ENINDENT_CLAUSE.include?(token)
	      # check for ``class = val'' etc.
	      valid = true
	      case token
	      when &quot;class&quot;
		valid = false unless peek_match?(/^\s*(&lt;&lt;|\w|::)/)
	      when &quot;def&quot;
		valid = false if peek_match?(/^\s*(([+-\/*&amp;\|^]|&lt;&lt;|&gt;&gt;|\|\||\&amp;\&amp;)=|\&amp;\&amp;|\|\|)/)
	      when &quot;do&quot;
		valid = false if peek_match?(/^\s*([+-\/*]?=|\*|&lt;|&gt;|\&amp;)/)
	      when *ENINDENT_CLAUSE
		valid = false if peek_match?(/^\s*([+-\/*]?=|\*|&lt;|&gt;|\&amp;|\|)/)
	      else
		# no nothing
	      end
	      if valid
		if token == &quot;do&quot;
		  if ![TkFOR, TkWHILE, TkUNTIL].include?(@indent_stack.last)
		    @indent += 1
		    @indent_stack.push token_c
		  end
		else
		  @indent += 1
		  @indent_stack.push token_c
		end
#		p @indent_stack
	      end

	    elsif DEINDENT_CLAUSE.include?(token)
	      @indent -= 1
	      @indent_stack.pop
	    end
	    @lex_state = trans[0]
	  else
	    @lex_state = EXPR_END
	  end
	end
	return Token(token_c, token)
      end
    end

    if @lex_state == EXPR_FNAME
      @lex_state = EXPR_END
      if peek(0) == '='
	token.concat getc
      end
    elsif @lex_state == EXPR_BEG || @lex_state == EXPR_DOT
      @lex_state = EXPR_ARG
    else
      @lex_state = EXPR_END
    end

    if token[0, 1] =~ /[A-Z]/
      return Token(TkCONSTANT, token)
    elsif token[token.size - 1, 1] =~ /[!?]/
      return Token(TkFID, token)
    else
      return Token(TkIDENTIFIER, token)
    end
  end

  def identify_here_document
    ch = getc
#    if lt = PERCENT_LTYPE[ch]
    if ch == &quot;-&quot;
      ch = getc
      indent = true
    end
    if /['&quot;`]/ =~ ch
      lt = ch
      quoted = &quot;&quot;
      while (c = getc) &amp;&amp; c != lt
	quoted.concat c
      end
    else
      lt = '&quot;'
      quoted = ch.dup
      while (c = getc) &amp;&amp; c =~ /\w/
	quoted.concat c
      end
      ungetc
    end

    ltback, @ltype = @ltype, lt
    reserve = []
    while ch = getc
      reserve.push ch
      if ch == &quot;\\&quot;
	reserve.push ch = getc
      elsif ch == &quot;\n&quot;
	break
      end
    end

    @here_header = false
    while l = gets
      l = l.sub(/(:?\r)?\n\z/, '')
      if (indent ? l.strip : l) == quoted
 	break
      end
    end

    @here_header = true
    @here_readed.concat reserve
    while ch = reserve.pop
      ungetc ch
    end

    @ltype = ltback
    @lex_state = EXPR_END
    Token(Ltype2Token[lt])
  end
  
  def identify_quotation
    ch = getc
    if lt = PERCENT_LTYPE[ch]
      ch = getc
    elsif ch =~ /\W/
      lt = &quot;\&quot;&quot;
    else
      RubyLex.fail SyntaxError, &quot;unknown type of %string&quot;
    end
#     if ch !~ /\W/
#       ungetc
#       next
#     end
    #@ltype = lt
    @quoted = ch unless @quoted = PERCENT_PAREN[ch]
    identify_string(lt, @quoted)
  end

  def identify_number
    @lex_state = EXPR_END

    if peek(0) == &quot;0&quot; &amp;&amp; peek(1) !~ /[.eE]/
      getc
      case peek(0)
      when /[xX]/
	ch = getc
	match = /[0-9a-fA-F_]/
      when /[bB]/
	ch = getc
	match = /[01_]/
      when /[oO]/
	ch = getc
	match = /[0-7_]/
      when /[dD]/
	ch = getc
	match = /[0-9_]/
      when /[0-7]/
	match = /[0-7_]/
      when /[89]/
	RubyLex.fail SyntaxError, &quot;Illegal octal digit&quot;
      else 
	return Token(TkINTEGER)
      end
      
      len0 = true
      non_digit = false
      while ch = getc
	if match =~ ch
	  if ch == &quot;_&quot;
	    if non_digit
	      RubyLex.fail SyntaxError, &quot;trailing `#{ch}' in number&quot;
	    else
	      non_digit = ch
	    end
	  else
	    non_digit = false
	    len0 = false
	  end
	else
	  ungetc
	  if len0
	    RubyLex.fail SyntaxError, &quot;numeric literal without digits&quot;
	  end
	  if non_digit
	    RubyLex.fail SyntaxError, &quot;trailing `#{non_digit}' in number&quot;
	  end
	  break
	end
      end
      return Token(TkINTEGER)
    end
    
    type = TkINTEGER
    allow_point = true
    allow_e = true
    non_digit = false
    while ch = getc
      case ch
      when /[0-9]/
	non_digit = false
      when &quot;_&quot;
	non_digit = ch
      when allow_point &amp;&amp; &quot;.&quot;
	if non_digit
	  RubyLex.fail SyntaxError, &quot;trailing `#{non_digit}' in number&quot;
	end
	type = TkFLOAT
	if peek(0) !~ /[0-9]/
	  type = TkINTEGER
	  ungetc
	  break
	end
	allow_point = false
      when allow_e &amp;&amp; &quot;e&quot;, allow_e &amp;&amp; &quot;E&quot;
	if non_digit
	  RubyLex.fail SyntaxError, &quot;trailing `#{non_digit}' in number&quot;
	end
	type = TkFLOAT
	if peek(0) =~ /[+-]/
	  getc
	end
	allow_e = false
	allow_point = false
	non_digit = ch
      else
	if non_digit
	  RubyLex.fail SyntaxError, &quot;trailing `#{non_digit}' in number&quot;
	end
	ungetc
	break
      end
    end
    Token(type)
  end
  
  def identify_string(ltype, quoted = ltype)
    @ltype = ltype
    @quoted = quoted
    subtype = nil
    begin
      nest = 0
      while ch = getc
	if @quoted == ch and nest == 0
	  break
	elsif @ltype != &quot;'&quot; &amp;&amp; @ltype != &quot;]&quot; &amp;&amp; @ltype != &quot;:&quot; and ch == &quot;#&quot;
	  subtype = true
	elsif ch == '\\' #'
	  read_escape
	end
	if PERCENT_PAREN.values.include?(@quoted) 
	  if PERCENT_PAREN[ch] == @quoted
	    nest += 1
	  elsif ch == @quoted
	    nest -= 1
	  end
	end
      end
      if @ltype == &quot;/&quot;
	if peek(0) =~ /i|m|x|o|e|s|u|n/
	  getc
	end
      end
      if subtype
	Token(DLtype2Token[ltype])
      else
	Token(Ltype2Token[ltype])
      end
    ensure
      @ltype = nil
      @quoted = nil
      @lex_state = EXPR_END
    end
  end
  
  def identify_comment
    @ltype = &quot;#&quot;

    while ch = getc
#      if ch == &quot;\\&quot; #&quot;
#	read_escape
#      end
      if ch == &quot;\n&quot;
	@ltype = nil
	ungetc
	break
      end
    end
    return Token(TkCOMMENT)
  end
  
  def read_escape
    case ch = getc
    when &quot;\n&quot;, &quot;\r&quot;, &quot;\f&quot;
    when &quot;\\&quot;, &quot;n&quot;, &quot;t&quot;, &quot;r&quot;, &quot;f&quot;, &quot;v&quot;, &quot;a&quot;, &quot;e&quot;, &quot;b&quot;, &quot;s&quot; #&quot;
    when /[0-7]/
      ungetc ch
      3.times do
	case ch = getc
	when /[0-7]/
	when nil
	  break
	else
	  ungetc
	  break
	end
      end
      
    when &quot;x&quot;
      2.times do
	case ch = getc
	when /[0-9a-fA-F]/
	when nil
	  break
	else
	  ungetc
	  break
	end
      end

    when &quot;M&quot;
      if (ch = getc) != '-'
	ungetc
      else
	if (ch = getc) == &quot;\\&quot; #&quot;
	  read_escape
	end
      end

    when &quot;C&quot;, &quot;c&quot; #, &quot;^&quot;
      if ch == &quot;C&quot; and (ch = getc) != &quot;-&quot;
	ungetc
      elsif (ch = getc) == &quot;\\&quot; #&quot;
	read_escape
      end
    else
      # other characters 
    end
  end
end
</pre>
    </div>