  <div id="fileHeader">
    <h1>ipaddr.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/ipaddr.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Mar 21 07:16:15 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# ipaddr.rb - A class to manipulate an IP address
#
# Copyright (c) 2002 Hajimu UMEMOTO &lt;ume@mahoroba.org&gt;.
# Copyright (c) 2007 Akinori MUSHA &lt;knu@iDaemons.org&gt;.
# All rights reserved.
#
# You can redistribute and/or modify it under the same terms as Ruby.
#
# $Id: ipaddr.rb 15822 2008-03-21 12:16:15Z knu $
#
# Contact:
#   - Akinori MUSHA &lt;knu@iDaemons.org&gt; (current maintainer)
#
# TODO:
#   - scope_id support
#
require 'socket'

unless Socket.const_defined? &quot;AF_INET6&quot;
  class Socket
    AF_INET6 = Object.new
  end

  class &lt;&lt; IPSocket
    def valid_v4?(addr)
      if /\A(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})\Z/ =~ addr
        return $~.captures.all? {|i| i.to_i &lt; 256}
      end
      return false
    end

    def valid_v6?(addr)
      # IPv6 (normal)
      return true if /\A[\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*\Z/ =~ addr
      return true if /\A[\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*::([\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*)?\Z/ =~ addr
      return true if /\A::([\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*)?\Z/ =~ addr
      # IPv6 (IPv4 compat)
      return true if /\A[\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*:/ =~ addr &amp;&amp; valid_v4?($')
      return true if /\A[\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*::([\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*:)?/ =~ addr &amp;&amp; valid_v4?($')
      return true if /\A::([\dA-Fa-f]{1,4}(:[\dA-Fa-f]{1,4})*:)?/ =~ addr &amp;&amp; valid_v4?($')

      false
    end

    def valid?(addr)
      valid_v4?(addr) || valid_v6?(addr)
    end

    alias getaddress_orig getaddress
    def getaddress(s)
      if valid?(s)
        s
      elsif /\A[-A-Za-z\d.]+\Z/ =~ s
        getaddress_orig(s)
      else
        raise ArgumentError, &quot;invalid address&quot;
      end
    end
  end
end

# IPAddr provides a set of methods to manipulate an IP address.  Both IPv4 and
# IPv6 are supported.
#
# == Example
#
#   require 'ipaddr'
#   
#   ipaddr1 = IPAddr.new &quot;3ffe:505:2::1&quot;
#   
#   p ipaddr1			#=&gt; #&lt;IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&gt;
#   
#   p ipaddr1.to_s		#=&gt; &quot;3ffe:505:2::1&quot;
#   
#   ipaddr2 = ipaddr1.mask(48)	#=&gt; #&lt;IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000&gt;
#   
#   p ipaddr2.to_s		#=&gt; &quot;3ffe:505:2::&quot;
#   
#   ipaddr3 = IPAddr.new &quot;192.168.2.0/24&quot;
#   
#   p ipaddr3			#=&gt; #&lt;IPAddr: IPv4:192.168.2.0/255.255.255.0&gt;

class IPAddr

  IN4MASK = 0xffffffff
  IN6MASK = 0xffffffffffffffffffffffffffffffff
  IN6FORMAT = ([&quot;%.4x&quot;] * 8).join(':')

  # Returns the address family of this IP address.
  attr :family

  # Creates a new ipaddr containing the given network byte ordered
  # string form of an IP address.
  def IPAddr::new_ntoh(addr)
    return IPAddr.new(IPAddr::ntop(addr))
  end

  # Convert a network byte ordered string form of an IP address into
  # human readable form.
  def IPAddr::ntop(addr)
    case addr.size
    when 4
      s = addr.unpack('C4').join('.')
    when 16
      s = IN6FORMAT % addr.unpack('n8')
    else
      raise ArgumentError, &quot;unsupported address family&quot;
    end
    return s
  end

  # Returns a new ipaddr built by bitwise AND.
  def &amp;(other)
    return self.clone.set(@addr &amp; coerce_other(other).to_i)
  end

  # Returns a new ipaddr built by bitwise OR.
  def |(other)
    return self.clone.set(@addr | coerce_other(other).to_i)
  end

  # Returns a new ipaddr built by bitwise right-shift.
  def &gt;&gt;(num)
    return self.clone.set(@addr &gt;&gt; num)
  end

  # Returns a new ipaddr built by bitwise left shift.
  def &lt;&lt;(num)
    return self.clone.set(addr_mask(@addr &lt;&lt; num))
  end

  # Returns a new ipaddr built by bitwise negation.
  def ~
    return self.clone.set(addr_mask(~@addr))
  end

  # Returns true if two ipaddrs are equal.
  def ==(other)
    other = coerce_other(other)
    return @family == other.family &amp;&amp; @addr == other.to_i
  end

  # Returns a new ipaddr built by masking IP address with the given
  # prefixlen/netmask. (e.g. 8, 64, &quot;255.255.255.0&quot;, etc.)
  def mask(prefixlen)
    return self.clone.mask!(prefixlen)
  end

  # Returns true if the given ipaddr is in the range.
  #
  # e.g.:
  #   require 'ipaddr'
  #   net1 = IPAddr.new(&quot;192.168.2.0/24&quot;)
  #   net2 = IPAddr.new(&quot;192.168.2.100&quot;)
  #   net3 = IPAddr.new(&quot;192.168.3.0&quot;)
  #   p net1.include?(net2)	#=&gt; true
  #   p net1.include?(net3)	#=&gt; false
  def include?(other)
    other = coerce_other(other)
    if ipv4_mapped?
      if (@mask_addr &gt;&gt; 32) != 0xffffffffffffffffffffffff
	return false
      end
      mask_addr = (@mask_addr &amp; IN4MASK)
      addr = (@addr &amp; IN4MASK)
      family = Socket::AF_INET
    else
      mask_addr = @mask_addr
      addr = @addr
      family = @family
    end
    if other.ipv4_mapped?
      other_addr = (other.to_i &amp; IN4MASK)
      other_family = Socket::AF_INET
    else
      other_addr = other.to_i
      other_family = other.family
    end

    if family != other_family
      return false
    end
    return ((addr &amp; mask_addr) == (other_addr &amp; mask_addr))
  end
  alias === include?

  # Returns the integer representation of the ipaddr.
  def to_i
    return @addr
  end

  # Returns a string containing the IP address representation.
  def to_s
    str = to_string
    return str if ipv4?

    str.gsub!(/\b0{1,3}([\da-f]+)\b/i, '\1')
    loop do
      break if str.sub!(/\A0:0:0:0:0:0:0:0\Z/, '::')
      break if str.sub!(/\b0:0:0:0:0:0:0\b/, ':')
      break if str.sub!(/\b0:0:0:0:0:0\b/, ':')
      break if str.sub!(/\b0:0:0:0:0\b/, ':')
      break if str.sub!(/\b0:0:0:0\b/, ':')
      break if str.sub!(/\b0:0:0\b/, ':')
      break if str.sub!(/\b0:0\b/, ':')
      break
    end
    str.sub!(/:{3,}/, '::')

    if /\A::(ffff:)?([\da-f]{1,4}):([\da-f]{1,4})\Z/i =~ str
      str = sprintf('::%s%d.%d.%d.%d', $1, $2.hex / 256, $2.hex % 256, $3.hex / 256, $3.hex % 256)
    end

    str
  end

  # Returns a string containing the IP address representation in
  # canonical form.
  def to_string
    return _to_string(@addr)
  end

  # Returns a network byte ordered string form of the IP address.
  def hton
    case @family
    when Socket::AF_INET
      return [@addr].pack('N')
    when Socket::AF_INET6
      return (0..7).map { |i|
	(@addr &gt;&gt; (112 - 16 * i)) &amp; 0xffff
      }.pack('n8')
    else
      raise &quot;unsupported address family&quot;
    end
  end

  # Returns true if the ipaddr is an IPv4 address.
  def ipv4?
    return @family == Socket::AF_INET
  end

  # Returns true if the ipaddr is an IPv6 address.
  def ipv6?
    return @family == Socket::AF_INET6
  end

  # Returns true if the ipaddr is an IPv4-mapped IPv6 address.
  def ipv4_mapped?
    return ipv6? &amp;&amp; (@addr &gt;&gt; 32) == 0xffff
  end

  # Returns true if the ipaddr is an IPv4-compatible IPv6 address.
  def ipv4_compat?
    if !ipv6? || (@addr &gt;&gt; 32) != 0
      return false
    end
    a = (@addr &amp; IN4MASK)
    return a != 0 &amp;&amp; a != 1
  end

  # Returns a new ipaddr built by converting the native IPv4 address
  # into an IPv4-mapped IPv6 address.
  def ipv4_mapped
    if !ipv4?
      raise ArgumentError, &quot;not an IPv4 address&quot;
    end
    return self.clone.set(@addr | 0xffff00000000, Socket::AF_INET6)
  end

  # Returns a new ipaddr built by converting the native IPv4 address
  # into an IPv4-compatible IPv6 address.
  def ipv4_compat
    if !ipv4?
      raise ArgumentError, &quot;not an IPv4 address&quot;
    end
    return self.clone.set(@addr, Socket::AF_INET6)
  end

  # Returns a new ipaddr built by converting the IPv6 address into a
  # native IPv4 address.  If the IP address is not an IPv4-mapped or
  # IPv4-compatible IPv6 address, returns self.
  def native
    if !ipv4_mapped? &amp;&amp; !ipv4_compat?
      return self
    end
    return self.clone.set(@addr &amp; IN4MASK, Socket::AF_INET)
  end

  # Returns a string for DNS reverse lookup.  It returns a string in
  # RFC3172 form for an IPv6 address.
  def reverse
    case @family
    when Socket::AF_INET
      return _reverse + &quot;.in-addr.arpa&quot;
    when Socket::AF_INET6
      return ip6_arpa
    else
      raise &quot;unsupported address family&quot;
    end
  end

  # Returns a string for DNS reverse lookup compatible with RFC3172.
  def ip6_arpa
    if !ipv6?
      raise ArgumentError, &quot;not an IPv6 address&quot;
    end
    return _reverse + &quot;.ip6.arpa&quot;
  end

  # Returns a string for DNS reverse lookup compatible with RFC1886.
  def ip6_int
    if !ipv6?
      raise ArgumentError, &quot;not an IPv6 address&quot;
    end
    return _reverse + &quot;.ip6.int&quot;
  end

  # Returns the successor to the ipaddr.
  def succ
    return self.clone.set(@addr + 1, @family)
  end

  # Compares the ipaddr with another.
  def &lt;=&gt;(other)
    other = coerce_other(other)

    return nil if other.family != @family

    return @addr &lt;=&gt; other.to_i
  end
  include Comparable

  # Creates a Range object for the network address.
  def to_range
    begin_addr = (@addr &amp; @mask_addr)

    case @family
    when Socket::AF_INET
      end_addr = (@addr | (IN4MASK ^ @mask_addr))
    when Socket::AF_INET6
      end_addr = (@addr | (IN6MASK ^ @mask_addr))
    else
      raise &quot;unsupported address family&quot;
    end

    return clone.set(begin_addr, @family)..clone.set(end_addr, @family)
  end

  # Returns a string containing a human-readable representation of the
  # ipaddr. (&quot;#&lt;IPAddr: family:address/mask&gt;&quot;)
  def inspect
    case @family
    when Socket::AF_INET
      af = &quot;IPv4&quot;
    when Socket::AF_INET6
      af = &quot;IPv6&quot;
    else
      raise &quot;unsupported address family&quot;
    end
    return sprintf(&quot;#&lt;%s: %s:%s/%s&gt;&quot;, self.class.name,
		   af, _to_string(@addr), _to_string(@mask_addr))
  end

  protected

  def set(addr, *family)
    case family[0] ? family[0] : @family
    when Socket::AF_INET
      if addr &lt; 0 || addr &gt; IN4MASK
	raise ArgumentError, &quot;invalid address&quot;
      end
    when Socket::AF_INET6
      if addr &lt; 0 || addr &gt; IN6MASK
	raise ArgumentError, &quot;invalid address&quot;
      end
    else
      raise ArgumentError, &quot;unsupported address family&quot;
    end
    @addr = addr
    if family[0]
      @family = family[0]
    end
    return self
  end

  def mask!(mask)
    if mask.kind_of?(String)
      if mask =~ /^\d+$/
	prefixlen = mask.to_i
      else
	m = IPAddr.new(mask)
	if m.family != @family
	  raise ArgumentError, &quot;address family is not same&quot;
	end
	@mask_addr = m.to_i
	@addr &amp;= @mask_addr
	return self
      end
    else
      prefixlen = mask
    end
    case @family
    when Socket::AF_INET
      if prefixlen &lt; 0 || prefixlen &gt; 32
	raise ArgumentError, &quot;invalid length&quot;
      end
      masklen = 32 - prefixlen
      @mask_addr = ((IN4MASK &gt;&gt; masklen) &lt;&lt; masklen)
    when Socket::AF_INET6
      if prefixlen &lt; 0 || prefixlen &gt; 128
	raise ArgumentError, &quot;invalid length&quot;
      end
      masklen = 128 - prefixlen
      @mask_addr = ((IN6MASK &gt;&gt; masklen) &lt;&lt; masklen)
    else
      raise &quot;unsupported address family&quot;
    end
    @addr = ((@addr &gt;&gt; masklen) &lt;&lt; masklen)
    return self
  end

  private

  # Creates a new ipaddr object either from a human readable IP
  # address representation in string, or from a packed in_addr value
  # followed by an address family.
  # 
  # In the former case, the following are the valid formats that will
  # be recognized: &quot;address&quot;, &quot;address/prefixlen&quot; and &quot;address/mask&quot;,
  # where IPv6 address may be enclosed in square brackets (`[' and
  # `]').  If a prefixlen or a mask is specified, it returns a masked
  # IP address.  Although the address family is determined
  # automatically from a specified string, you can specify one
  # explicitly by the optional second argument.
  # 
  # Otherwise an IP addess is generated from a packed in_addr value
  # and an address family.
  #
  # The IPAddr class defines many methods and operators, and some of
  # those, such as &amp;, |, include? and ==, accept a string, or a packed
  # in_addr value instead of an IPAddr object.
  def initialize(addr = '::', family = Socket::AF_UNSPEC)
    if !addr.kind_of?(String)
      case family
      when Socket::AF_INET, Socket::AF_INET6
        set(addr.to_i, family)
        @mask_addr = (family == Socket::AF_INET) ? IN4MASK : IN6MASK
        return
      when Socket::AF_UNSPEC
	raise ArgumentError, &quot;address family must be specified&quot;
      else
	raise ArgumentError, &quot;unsupported address family: #{family}&quot;
      end
    end
    prefix, prefixlen = addr.split('/')
    if prefix =~ /^\[(.*)\]$/i
      prefix = $1
      family = Socket::AF_INET6
    end
    # It seems AI_NUMERICHOST doesn't do the job.
    #Socket.getaddrinfo(left, nil, Socket::AF_INET6, Socket::SOCK_STREAM, nil,
    #		       Socket::AI_NUMERICHOST)
    begin
      IPSocket.getaddress(prefix)		# test if address is vaild
    rescue
      raise ArgumentError, &quot;invalid address&quot;
    end
    @addr = @family = nil
    if family == Socket::AF_UNSPEC || family == Socket::AF_INET
      @addr = in_addr(prefix)
      if @addr
	@family = Socket::AF_INET
      end
    end
    if !@addr &amp;&amp; (family == Socket::AF_UNSPEC || family == Socket::AF_INET6)
      @addr = in6_addr(prefix)
      @family = Socket::AF_INET6
    end
    if family != Socket::AF_UNSPEC &amp;&amp; @family != family
      raise ArgumentError, &quot;address family mismatch&quot;
    end
    if prefixlen
      mask!(prefixlen)
    else
      @mask_addr = (family == Socket::AF_INET) ? IN4MASK : IN6MASK
    end
  end

  def coerce_other(other)
    case other
    when IPAddr
      other
    when String
      self.class.new(other)
    else
      self.class.new(other, @family)
    end
  end

  def in_addr(addr)
    if addr =~ /^\d+\.\d+\.\d+\.\d+$/
      return addr.split('.').inject(0) { |i, s|
        i &lt;&lt; 8 | s.to_i
      }
    end
    return nil
  end

  def in6_addr(left)
    case left
    when /^::ffff:(\d+\.\d+\.\d+\.\d+)$/i
      return in_addr($1) + 0xffff00000000
    when /^::(\d+\.\d+\.\d+\.\d+)$/i
      return in_addr($1)
    when /[^0-9a-f:]/i
      raise ArgumentError, &quot;invalid address&quot;
    when /^(.*)::(.*)$/
      left, right = $1, $2
    else
      right = ''
    end
    l = left.split(':')
    r = right.split(':')
    rest = 8 - l.size - r.size
    if rest &lt; 0
      return nil
    end
    return (l + Array.new(rest, '0') + r).inject(0) { |i, s|
      i &lt;&lt; 16 | s.hex
    }
  end

  def addr_mask(addr)
    case @family
    when Socket::AF_INET
      return addr &amp; IN4MASK
    when Socket::AF_INET6
      return addr &amp; IN6MASK
    else
      raise &quot;unsupported address family&quot;
    end
  end

  def _reverse
    case @family
    when Socket::AF_INET
      return (0..3).map { |i|
	(@addr &gt;&gt; (8 * i)) &amp; 0xff
      }.join('.')
    when Socket::AF_INET6
      return (&quot;%.32x&quot; % @addr).reverse!.gsub!(/.(?!$)/, '\&amp;.')
    else
      raise &quot;unsupported address family&quot;
    end
  end

  def _to_string(addr)
    case @family
    when Socket::AF_INET
      return (0..3).map { |i|
	(addr &gt;&gt; (24 - 8 * i)) &amp; 0xff
      }.join('.')
    when Socket::AF_INET6
      return ((&quot;%.32x&quot; % addr).gsub!(/.{4}(?!$)/, '\&amp;:'))
    else
      raise &quot;unsupported address family&quot;
    end
  end

end

if $0 == __FILE__
  eval DATA.read, nil, $0, __LINE__+4
end

__END__

require 'test/unit'
require 'test/unit/ui/console/testrunner'

class TC_IPAddr &lt; Test::Unit::TestCase
  def test_s_new
    assert_nothing_raised {
      IPAddr.new(&quot;3FFE:505:ffff::/48&quot;)
      IPAddr.new(&quot;0:0:0:1::&quot;)
      IPAddr.new(&quot;2001:200:300::/48&quot;)
    }

    a = IPAddr.new
    assert_equal(&quot;::&quot;, a.to_s)
    assert_equal(&quot;0000:0000:0000:0000:0000:0000:0000:0000&quot;, a.to_string)
    assert_equal(Socket::AF_INET6, a.family)

    a = IPAddr.new(&quot;0123:4567:89ab:cdef:0ABC:DEF0:1234:5678&quot;)
    assert_equal(&quot;123:4567:89ab:cdef:abc:def0:1234:5678&quot;, a.to_s)
    assert_equal(&quot;0123:4567:89ab:cdef:0abc:def0:1234:5678&quot;, a.to_string)
    assert_equal(Socket::AF_INET6, a.family)

    a = IPAddr.new(&quot;3ffe:505:2::/48&quot;)
    assert_equal(&quot;3ffe:505:2::&quot;, a.to_s)
    assert_equal(&quot;3ffe:0505:0002:0000:0000:0000:0000:0000&quot;, a.to_string)
    assert_equal(Socket::AF_INET6, a.family)
    assert_equal(false, a.ipv4?)
    assert_equal(true, a.ipv6?)
    assert_equal(&quot;#&lt;IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000&gt;&quot;, a.inspect)

    a = IPAddr.new(&quot;3ffe:505:2::/ffff:ffff:ffff::&quot;)
    assert_equal(&quot;3ffe:505:2::&quot;, a.to_s)
    assert_equal(&quot;3ffe:0505:0002:0000:0000:0000:0000:0000&quot;, a.to_string)
    assert_equal(Socket::AF_INET6, a.family)

    a = IPAddr.new(&quot;0.0.0.0&quot;)
    assert_equal(&quot;0.0.0.0&quot;, a.to_s)
    assert_equal(&quot;0.0.0.0&quot;, a.to_string)
    assert_equal(Socket::AF_INET, a.family)

    a = IPAddr.new(&quot;192.168.1.2&quot;)
    assert_equal(&quot;192.168.1.2&quot;, a.to_s)
    assert_equal(&quot;192.168.1.2&quot;, a.to_string)
    assert_equal(Socket::AF_INET, a.family)
    assert_equal(true, a.ipv4?)
    assert_equal(false, a.ipv6?)

    a = IPAddr.new(&quot;192.168.1.2/24&quot;)
    assert_equal(&quot;192.168.1.0&quot;, a.to_s)
    assert_equal(&quot;192.168.1.0&quot;, a.to_string)
    assert_equal(Socket::AF_INET, a.family)
    assert_equal(&quot;#&lt;IPAddr: IPv4:192.168.1.0/255.255.255.0&gt;&quot;, a.inspect)

    a = IPAddr.new(&quot;192.168.1.2/255.255.255.0&quot;)
    assert_equal(&quot;192.168.1.0&quot;, a.to_s)
    assert_equal(&quot;192.168.1.0&quot;, a.to_string)
    assert_equal(Socket::AF_INET, a.family)

    assert_equal(&quot;0:0:0:1::&quot;, IPAddr.new(&quot;0:0:0:1::&quot;).to_s)
    assert_equal(&quot;2001:200:300::&quot;, IPAddr.new(&quot;2001:200:300::/48&quot;).to_s)

    assert_equal(&quot;2001:200:300::&quot;, IPAddr.new(&quot;[2001:200:300::]/48&quot;).to_s)

    [
      [&quot;fe80::1%fxp0&quot;],
      [&quot;::1/255.255.255.0&quot;],
      [&quot;::1:192.168.1.2/120&quot;],
      [IPAddr.new(&quot;::1&quot;).to_i],
      [&quot;::ffff:192.168.1.2/120&quot;, Socket::AF_INET],
      [&quot;[192.168.1.2]/120&quot;],
    ].each { |args|
      assert_raises(ArgumentError) {
	IPAddr.new(*args)
      }
    }
  end

  def test_s_new_ntoh
    addr = ''
    IPAddr.new(&quot;1234:5678:9abc:def0:1234:5678:9abc:def0&quot;).hton.each_byte { |c|
      addr += sprintf(&quot;%02x&quot;, c)
    }
    assert_equal(&quot;123456789abcdef0123456789abcdef0&quot;, addr)
    addr = ''
    IPAddr.new(&quot;123.45.67.89&quot;).hton.each_byte { |c|
      addr += sprintf(&quot;%02x&quot;, c)
    }
    assert_equal(sprintf(&quot;%02x%02x%02x%02x&quot;, 123, 45, 67, 89), addr)
    a = IPAddr.new(&quot;3ffe:505:2::&quot;)
    assert_equal(&quot;3ffe:505:2::&quot;, IPAddr.new_ntoh(a.hton).to_s)
    a = IPAddr.new(&quot;192.168.2.1&quot;)
    assert_equal(&quot;192.168.2.1&quot;, IPAddr.new_ntoh(a.hton).to_s)
  end

  def test_ipv4_compat
    a = IPAddr.new(&quot;::192.168.1.2&quot;)
    assert_equal(&quot;::192.168.1.2&quot;, a.to_s)
    assert_equal(&quot;0000:0000:0000:0000:0000:0000:c0a8:0102&quot;, a.to_string)
    assert_equal(Socket::AF_INET6, a.family)
    assert_equal(true, a.ipv4_compat?)
    b = a.native
    assert_equal(&quot;192.168.1.2&quot;, b.to_s)
    assert_equal(Socket::AF_INET, b.family)
    assert_equal(false, b.ipv4_compat?)

    a = IPAddr.new(&quot;192.168.1.2&quot;)
    b = a.ipv4_compat
    assert_equal(&quot;::192.168.1.2&quot;, b.to_s)
    assert_equal(Socket::AF_INET6, b.family)
  end

  def test_ipv4_mapped
    a = IPAddr.new(&quot;::ffff:192.168.1.2&quot;)
    assert_equal(&quot;::ffff:192.168.1.2&quot;, a.to_s)
    assert_equal(&quot;0000:0000:0000:0000:0000:ffff:c0a8:0102&quot;, a.to_string)
    assert_equal(Socket::AF_INET6, a.family)
    assert_equal(true, a.ipv4_mapped?)
    b = a.native
    assert_equal(&quot;192.168.1.2&quot;, b.to_s)
    assert_equal(Socket::AF_INET, b.family)
    assert_equal(false, b.ipv4_mapped?)

    a = IPAddr.new(&quot;192.168.1.2&quot;)
    b = a.ipv4_mapped
    assert_equal(&quot;::ffff:192.168.1.2&quot;, b.to_s)
    assert_equal(Socket::AF_INET6, b.family)
  end

  def test_reverse
    assert_equal(&quot;f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa&quot;, IPAddr.new(&quot;3ffe:505:2::f&quot;).reverse)
    assert_equal(&quot;1.2.168.192.in-addr.arpa&quot;, IPAddr.new(&quot;192.168.2.1&quot;).reverse)
  end

  def test_ip6_arpa
    assert_equal(&quot;f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa&quot;, IPAddr.new(&quot;3ffe:505:2::f&quot;).ip6_arpa)
    assert_raises(ArgumentError) {
      IPAddr.new(&quot;192.168.2.1&quot;).ip6_arpa
    }
  end

  def test_ip6_int
    assert_equal(&quot;f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.int&quot;, IPAddr.new(&quot;3ffe:505:2::f&quot;).ip6_int)
    assert_raises(ArgumentError) {
      IPAddr.new(&quot;192.168.2.1&quot;).ip6_int
    }
  end

  def test_to_s
    assert_equal(&quot;3ffe:0505:0002:0000:0000:0000:0000:0001&quot;, IPAddr.new(&quot;3ffe:505:2::1&quot;).to_string)
    assert_equal(&quot;3ffe:505:2::1&quot;, IPAddr.new(&quot;3ffe:505:2::1&quot;).to_s)
  end
end

class TC_Operator &lt; Test::Unit::TestCase

  IN6MASK32  = &quot;ffff:ffff::&quot;
  IN6MASK128 = &quot;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&quot;

  def setup
    @in6_addr_any = IPAddr.new()
    @a = IPAddr.new(&quot;3ffe:505:2::/48&quot;)
    @b = IPAddr.new(&quot;0:0:0:1::&quot;)
    @c = IPAddr.new(IN6MASK32)
  end
  alias set_up setup

  def test_or
    assert_equal(&quot;3ffe:505:2:1::&quot;, (@a | @b).to_s)
    a = @a
    a |= @b
    assert_equal(&quot;3ffe:505:2:1::&quot;, a.to_s)
    assert_equal(&quot;3ffe:505:2::&quot;, @a.to_s)
    assert_equal(&quot;3ffe:505:2:1::&quot;,
		 (@a | 0x00000000000000010000000000000000).to_s)
  end

  def test_and
    assert_equal(&quot;3ffe:505::&quot;, (@a &amp; @c).to_s)
    a = @a
    a &amp;= @c
    assert_equal(&quot;3ffe:505::&quot;, a.to_s)
    assert_equal(&quot;3ffe:505:2::&quot;, @a.to_s)
    assert_equal(&quot;3ffe:505::&quot;, (@a &amp; 0xffffffff000000000000000000000000).to_s)
  end

  def test_shift_right
    assert_equal(&quot;0:3ffe:505:2::&quot;, (@a &gt;&gt; 16).to_s)
    a = @a
    a &gt;&gt;= 16
    assert_equal(&quot;0:3ffe:505:2::&quot;, a.to_s)
    assert_equal(&quot;3ffe:505:2::&quot;, @a.to_s)
  end

  def test_shift_left
    assert_equal(&quot;505:2::&quot;, (@a &lt;&lt; 16).to_s)
    a = @a
    a &lt;&lt;= 16
    assert_equal(&quot;505:2::&quot;, a.to_s)
    assert_equal(&quot;3ffe:505:2::&quot;, @a.to_s)
  end

  def test_carrot
    a = ~@in6_addr_any
    assert_equal(IN6MASK128, a.to_s)
    assert_equal(&quot;::&quot;, @in6_addr_any.to_s)
  end

  def test_equal
    assert_equal(true, @a == IPAddr.new(&quot;3ffe:505:2::&quot;))
    assert_equal(false, @a == IPAddr.new(&quot;3ffe:505:3::&quot;))
    assert_equal(true, @a != IPAddr.new(&quot;3ffe:505:3::&quot;))
    assert_equal(false, @a != IPAddr.new(&quot;3ffe:505:2::&quot;))
  end

  def test_mask
    a = @a.mask(32)
    assert_equal(&quot;3ffe:505::&quot;, a.to_s)
    assert_equal(&quot;3ffe:505:2::&quot;, @a.to_s)
  end

  def test_include?
    assert_equal(true, @a.include?(IPAddr.new(&quot;3ffe:505:2::&quot;)))
    assert_equal(true, @a.include?(IPAddr.new(&quot;3ffe:505:2::1&quot;)))
    assert_equal(false, @a.include?(IPAddr.new(&quot;3ffe:505:3::&quot;)))
    net1 = IPAddr.new(&quot;192.168.2.0/24&quot;)
    assert_equal(true, net1.include?(IPAddr.new(&quot;192.168.2.0&quot;)))
    assert_equal(true, net1.include?(IPAddr.new(&quot;192.168.2.255&quot;)))
    assert_equal(false, net1.include?(IPAddr.new(&quot;192.168.3.0&quot;)))
    # test with integer parameter
    int = (192 &lt;&lt; 24) + (168 &lt;&lt; 16) + (2 &lt;&lt; 8) + 13

    assert_equal(true, net1.include?(int))
    assert_equal(false, net1.include?(int+255))

  end

end
</pre>
    </div>