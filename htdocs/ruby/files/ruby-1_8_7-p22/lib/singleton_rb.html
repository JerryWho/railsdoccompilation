  <div id="fileHeader">
    <h1>singleton.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/singleton.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed May 28 02:16:25 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># The Singleton module implements the Singleton pattern.
#
# Usage:
#    class Klass
#       include Singleton
#       # ...
#    end
#
# *  this ensures that only one instance of Klass lets call it
#    ``the instance'' can be created.
#
#    a,b  = Klass.instance, Klass.instance
#    a == b   # =&gt; true
#    a.new    #  NoMethodError - new is private ...
#
# *  ``The instance'' is created at instantiation time, in other
#    words the first call of Klass.instance(), thus
#
#      class OtherKlass
#        include Singleton
#        # ...
#      end
#      ObjectSpace.each_object(OtherKlass){} # =&gt; 0.
#
# *  This behavior is preserved under inheritance and cloning.
#
#
#
# This is achieved by marking
# *  Klass.new and Klass.allocate - as private
#
# Providing (or modifying) the class methods
# *  Klass.inherited(sub_klass) and Klass.clone()  -
#    to ensure that the Singleton pattern is properly
#    inherited and cloned.
#
# *  Klass.instance()  -  returning ``the instance''. After a
#    successful self modifying (normally the first) call the
#    method body is a simple:
#
#       def Klass.instance()
#         return @__instance__
#       end
#
# *  Klass._load(str)  -  calling Klass.instance()
#
# *  Klass._instantiate?()  -  returning ``the instance'' or
#    nil. This hook method puts a second (or nth) thread calling
#    Klass.instance() on a waiting loop. The return value
#    signifies the successful completion or premature termination
#    of the first, or more generally, current &quot;instantiation thread&quot;.
#
#
# The instance method of Singleton are
# * clone and dup - raising TypeErrors to prevent cloning or duping
#
# *  _dump(depth) - returning the empty string.  Marshalling strips
#    by default all state information, e.g. instance variables and
#    taint state, from ``the instance''.  Providing custom _load(str)
#    and _dump(depth) hooks allows the (partially) resurrections of
#    a previous state of ``the instance''.



module Singleton
  #  disable build-in copying methods
  def clone
    raise TypeError, &quot;can't clone instance of singleton #{self.class}&quot;
  end
  def dup
    raise TypeError, &quot;can't dup instance of singleton #{self.class}&quot;
  end

  private
  #  default marshalling strategy
  def _dump(depth=-1)
    ''
  end
end


class &lt;&lt; Singleton
  #  Method body of first instance call.
  FirstInstanceCall = proc do
    #  @__instance__ takes on one of the following values
    #  * nil     -  before and after a failed creation
    #  * false  -  during creation
    #  * sub_class instance  -  after a successful creation
    #  the form makes up for the lack of returns in progs
    Thread.critical = true
    if  @__instance__.nil?
      @__instance__  = false
      Thread.critical = false
      begin
        @__instance__ = new
      ensure
        if @__instance__
          class &lt;&lt;self
            remove_method :instance
            def instance; @__instance__ end
          end
        else
          @__instance__ = nil #  failed instance creation
        end
      end
    elsif  _instantiate?()
      Thread.critical = false
    else
      @__instance__  = false
      Thread.critical = false
      begin
        @__instance__ = new
      ensure
        if @__instance__
          class &lt;&lt;self
            remove_method :instance
            def instance; @__instance__ end
          end
        else
          @__instance__ = nil
        end
      end
    end
    @__instance__
  end

  module SingletonClassMethods
    # properly clone the Singleton pattern - did you know
    # that duping doesn't copy class methods?
    def clone
      Singleton.__init__(super)
    end

    def _load(str)
      instance
    end

    private

    #  ensure that the Singleton pattern is properly inherited
    def inherited(sub_klass)
      super
      Singleton.__init__(sub_klass)
    end

    # waiting-loop hook
    def _instantiate?()
      while false.equal?(@__instance__)
        Thread.critical = false
        sleep(0.08)   # timeout
        Thread.critical = true
      end
      @__instance__
    end
  end

  def __init__(klass)
    klass.instance_eval { @__instance__ = nil }
    class &lt;&lt; klass
      define_method(:instance,FirstInstanceCall)
    end
    klass
  end

  private
  #  extending an object with Singleton is a bad idea
  undef_method :extend_object

  def append_features(mod)
    #  help out people counting on transitive mixins
    unless mod.instance_of?(Class)
      raise TypeError, &quot;Inclusion of the OO-Singleton module in module #{mod}&quot;
    end
    super
  end

  def included(klass)
    super
    klass.private_class_method  :new, :allocate
    klass.extend SingletonClassMethods
    Singleton.__init__(klass)
  end
end



if __FILE__ == $0

def num_of_instances(klass)
    &quot;#{ObjectSpace.each_object(klass){}} #{klass} instance(s)&quot;
end

# The basic and most important example.

class SomeSingletonClass
  include Singleton
end
puts &quot;There are #{num_of_instances(SomeSingletonClass)}&quot;

a = SomeSingletonClass.instance
b = SomeSingletonClass.instance # a and b are same object
puts &quot;basic test is #{a == b}&quot;

begin
  SomeSingletonClass.new
rescue  NoMethodError =&gt; mes
  puts mes
end



puts &quot;\nThreaded example with exception and customized #_instantiate?() hook&quot;; p
Thread.abort_on_exception = false

class Ups &lt; SomeSingletonClass
  def initialize
    self.class.__sleep
    puts &quot;initialize called by thread ##{Thread.current[:i]}&quot;
  end
end

class &lt;&lt; Ups
  def _instantiate?
    @enter.push Thread.current[:i]
    while false.equal?(@__instance__)
      Thread.critical = false
      sleep 0.08
      Thread.critical = true
    end
    @leave.push Thread.current[:i]
    @__instance__
  end

  def __sleep
    sleep(rand(0.08))
  end

  def new
    begin
      __sleep
      raise  &quot;boom - thread ##{Thread.current[:i]} failed to create instance&quot;
    ensure
      # simple flip-flop
      class &lt;&lt; self
        remove_method :new
      end
    end
  end

  def instantiate_all
    @enter = []
    @leave = []
    1.upto(9) {|i|
      Thread.new {
        begin
          Thread.current[:i] = i
          __sleep
          instance
        rescue RuntimeError =&gt; mes
          puts mes
        end
      }
    }
    puts &quot;Before there were #{num_of_instances(self)}&quot;
    sleep 3
    puts &quot;Now there is #{num_of_instances(self)}&quot;
    puts &quot;#{@enter.join '; '} was the order of threads entering the waiting loop&quot;
    puts &quot;#{@leave.join '; '} was the order of threads leaving the waiting loop&quot;
  end
end


Ups.instantiate_all
# results in message like
# Before there were 0 Ups instance(s)
# boom - thread #6 failed to create instance
# initialize called by thread #3
# Now there is 1 Ups instance(s)
# 3; 2; 1; 8; 4; 7; 5 was the order of threads entering the waiting loop
# 3; 2; 1; 7; 4; 8; 5 was the order of threads leaving the waiting loop


puts &quot;\nLets see if class level cloning really works&quot;
Yup = Ups.clone
def Yup.new
  begin
    __sleep
    raise  &quot;boom - thread ##{Thread.current[:i]} failed to create instance&quot;
  ensure
    # simple flip-flop
    class &lt;&lt; self
      remove_method :new
    end
  end
end
Yup.instantiate_all


puts &quot;\n\n&quot;,&quot;Customized marshalling&quot;
class A
  include Singleton
  attr_accessor :persist, :die
  def _dump(depth)
    # this strips the @die information from the instance
    Marshal.dump(@persist,depth)
  end
end

def A._load(str)
  instance.persist = Marshal.load(str)
  instance
end

a = A.instance
a.persist = [&quot;persist&quot;]
a.die = &quot;die&quot;
a.taint

stored_state = Marshal.dump(a)
# change state
a.persist = nil
a.die = nil
b = Marshal.load(stored_state)
p a == b  #  =&gt; true
p a.persist  #  =&gt; [&quot;persist&quot;]
p a.die      #  =&gt; nil


puts &quot;\n\nSingleton with overridden default #inherited() hook&quot;
class Up
end
def Up.inherited(sub_klass)
  puts &quot;#{sub_klass} subclasses #{self}&quot;
end


class Middle &lt; Up
  include Singleton
end

class Down &lt; Middle; end

puts  &quot;and basic \&quot;Down test\&quot; is #{Down.instance == Down.instance}\n
Various exceptions&quot;

begin
  module AModule
    include Singleton
  end
rescue TypeError =&gt; mes
  puts mes  #=&gt; Inclusion of the OO-Singleton module in module AModule
end

begin
  'aString'.extend Singleton
rescue NoMethodError =&gt; mes
  puts mes  #=&gt; undefined method `extend_object' for Singleton:Module
end

end
</pre>
    </div>