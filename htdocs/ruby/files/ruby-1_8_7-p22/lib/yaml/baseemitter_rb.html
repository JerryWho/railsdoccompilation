  <div id="fileHeader">
    <h1>baseemitter.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/yaml/baseemitter.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Apr 19 06:45:39 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# BaseEmitter
#

require 'yaml/constants'
require 'yaml/encoding'
require 'yaml/error'

module YAML

    module BaseEmitter

        def options( opt = nil )
            if opt
                @options[opt] || YAML::DEFAULTS[opt]
            else
                @options
            end
        end

        def options=( opt )
            @options = opt
        end

        #
        # Emit binary data
        #
        def binary_base64( value )
            self &lt;&lt; &quot;!binary &quot;
            self.node_text( [value].pack(&quot;m&quot;), '|' )
        end

		#
		# Emit plain, normal flowing text
		#
		def node_text( value, block = nil )
            @seq_map = false
			valx = value.dup
            unless block
            block =
                if options(:UseBlock)
                    '|'
                elsif not options(:UseFold) and valx =~ /\n[ \t]/ and not valx =~ /#{YAML::ESCAPE_CHAR}/
                    '|'
                else
                    '&gt;'
                end 

                indt = $&amp;.to_i if block =~ /\d+/
                if valx =~ /(\A\n*[ \t#]|^---\s+)/
                    indt = options(:Indent) unless indt.to_i &gt; 0
                    block += indt.to_s
                end

            block +=
                if valx =~ /\n\Z\n/
                    &quot;+&quot;
                elsif valx =~ /\Z\n/
                    &quot;&quot;
                else
                    &quot;-&quot;
                end
            end
            block += &quot;\n&quot;
            if block[0] == ?&quot;
                esc_skip = ( &quot;\t\n&quot; unless valx =~ /^[ \t]/ ) || &quot;&quot;
                valx = fold( YAML::escape( valx, esc_skip ) + &quot;\&quot;&quot; ).chomp
                self &lt;&lt; '&quot;' + indent_text( valx, indt, false )
            else
                if block[0] == ?&gt; 
                    valx = fold( valx ) 
                end
                #p [block, indt]
                self &lt;&lt; block + indent_text( valx, indt )
            end
		end

		#
		# Emit a simple, unqouted string
		#
		def simple( value )
            @seq_map = false
            self &lt;&lt; value.to_s
		end

		#
		# Emit double-quoted string
		#
		def double( value )
			&quot;\&quot;#{YAML.escape( value )}\&quot;&quot; 
		end

		#
		# Emit single-quoted string
		#
		def single( value )
			&quot;'#{value}'&quot;
		end

		#
		# Write a text block with the current indent
		#
		def indent_text( text, mod, first_line = true )
			return &quot;&quot; if text.to_s.empty?
            spacing = indent( mod )
            text = text.gsub( /\A([^\n])/, &quot;#{ spacing }\\1&quot; ) if first_line
			return text.gsub( /\n^([^\n])/, &quot;\n#{spacing}\\1&quot; )
		end

		#
		# Write a current indent
		#
        def indent( mod = nil )
            #p [ self.id, level, mod, :INDENT ]
            if level &lt;= 0
                mod ||= 0
            else
                mod ||= options(:Indent)
                mod += ( level - 1 ) * options(:Indent)
            end
            return &quot; &quot; * mod
		end

		#
		# Add indent to the buffer
		#
		def indent!
			self &lt;&lt; indent
		end

		#
		# Folding paragraphs within a column
		#
		def fold( value )
            value.gsub( /(^[ \t]+.*$)|(\S.{0,#{options(:BestWidth) - 1}})(?:[ \t]+|(\n+(?=[ \t]|\Z))|$)/ ) do
                $1 || $2 + ( $3 || &quot;\n&quot; )
            end
		end

        #
        # Quick mapping
        #
        def map( type, &amp;e )
            val = Mapping.new
            e.call( val )
			self &lt;&lt; &quot;#{type} &quot; if type.length.nonzero?

			#
			# Empty hashes
			#
			if val.length.zero?
				self &lt;&lt; &quot;{}&quot;
                @seq_map = false
			else
                # FIXME
                # if @buffer.length == 1 and options(:UseHeader) == false and type.length.zero? 
			    #     @headless = 1 
                # end

                defkey = @options.delete( :DefaultKey )
                if defkey
                    seq_map_shortcut
                    self &lt;&lt; &quot;= : &quot;
                    defkey.to_yaml( :Emitter =&gt; self )
                end

				#
				# Emit the key and value
				#
                val.each { |v|
                    seq_map_shortcut
                    if v[0].is_complex_yaml?
                        self &lt;&lt; &quot;? &quot;
                    end
                    v[0].to_yaml( :Emitter =&gt; self )
                    if v[0].is_complex_yaml?
                        self &lt;&lt; &quot;\n&quot;
                        indent!
                    end
                    self &lt;&lt; &quot;: &quot; 
                    v[1].to_yaml( :Emitter =&gt; self )
                }
			end
        end

        def seq_map_shortcut
            # FIXME: seq_map needs to work with the new anchoring system
            # if @seq_map
            #     @anchor_extras[@buffer.length - 1] = &quot;\n&quot; + indent
            #     @seq_map = false
            # else
                self &lt;&lt; &quot;\n&quot;
                indent! 
            # end
        end

        #
        # Quick sequence
        #
        def seq( type, &amp;e )
            @seq_map = false
            val = Sequence.new
            e.call( val )
			self &lt;&lt; &quot;#{type} &quot; if type.length.nonzero?

			#
			# Empty arrays
			#
			if val.length.zero?
				self &lt;&lt; &quot;[]&quot;
			else
                # FIXME
                # if @buffer.length == 1 and options(:UseHeader) == false and type.length.zero? 
			    #     @headless = 1 
                # end

				#
				# Emit the key and value
				#
                val.each { |v|
                    self &lt;&lt; &quot;\n&quot;
                    indent!
                    self &lt;&lt; &quot;- &quot;
                    @seq_map = true if v.class == Hash
                    v.to_yaml( :Emitter =&gt; self )
                }
			end
        end

    end

    #
    # Emitter helper classes
    #
    class Mapping &lt; Array
        def add( k, v )
            push [k, v]
        end
    end

    class Sequence &lt; Array
        def add( v )
            push v
        end
    end

end
</pre>
    </div>