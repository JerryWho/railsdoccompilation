  <div id="fileHeader">
    <h1>mkmf.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/mkmf.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu May 29 06:23:36 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># module to create Makefile for extension modules
# invoke like: ruby -r mkmf extconf.rb

require 'rbconfig'
require 'fileutils'
require 'shellwords'

CONFIG = Config::MAKEFILE_CONFIG
ORIG_LIBPATH = ENV['LIB']

CXX_EXT = %w[cc cxx cpp]
if /mswin|bccwin|mingw|msdosdjgpp|human|os2/ !~ CONFIG['build_os']
  CXX_EXT.concat(%w[C])
end
SRC_EXT = %w[c m] &lt;&lt; CXX_EXT
$static = $config_h = nil
$default_static = $static

unless defined? $configure_args
  $configure_args = {}
  args = CONFIG[&quot;configure_args&quot;]
  if ENV[&quot;CONFIGURE_ARGS&quot;]
    args &lt;&lt; &quot; &quot; &lt;&lt; ENV[&quot;CONFIGURE_ARGS&quot;]
  end
  for arg in Shellwords::shellwords(args)
    arg, val = arg.split('=', 2)
    next unless arg
    arg.tr!('_', '-')
    if arg.sub!(/^(?!--)/, '--')
      val or next
      arg.downcase!
    end
    next if /^--(?:top|topsrc|src|cur)dir$/ =~ arg
    $configure_args[arg] = val || true
  end
  for arg in ARGV
    arg, val = arg.split('=', 2)
    next unless arg
    arg.tr!('_', '-')
    if arg.sub!(/^(?!--)/, '--')
      val or next
      arg.downcase!
    end
    $configure_args[arg] = val || true
  end
end

$libdir = CONFIG[&quot;libdir&quot;]
$rubylibdir = CONFIG[&quot;rubylibdir&quot;]
$archdir = CONFIG[&quot;archdir&quot;]
$sitedir = CONFIG[&quot;sitedir&quot;]
$sitelibdir = CONFIG[&quot;sitelibdir&quot;]
$sitearchdir = CONFIG[&quot;sitearchdir&quot;]
$vendordir = CONFIG[&quot;vendordir&quot;]
$vendorlibdir = CONFIG[&quot;vendorlibdir&quot;]
$vendorarchdir = CONFIG[&quot;vendorarchdir&quot;]

$mswin = /mswin/ =~ RUBY_PLATFORM
$bccwin = /bccwin/ =~ RUBY_PLATFORM
$mingw = /mingw/ =~ RUBY_PLATFORM
$cygwin = /cygwin/ =~ RUBY_PLATFORM
$human = /human/ =~ RUBY_PLATFORM
$netbsd = /netbsd/ =~ RUBY_PLATFORM
$os2 = /os2/ =~ RUBY_PLATFORM
$beos = /beos/ =~ RUBY_PLATFORM
$solaris = /solaris/ =~ RUBY_PLATFORM
$dest_prefix_pattern = (File::PATH_SEPARATOR == ';' ? /\A([[:alpha:]]:)?/ : /\A/)

# :stopdoc:

def config_string(key, config = CONFIG)
  s = config[key] and !s.empty? and block_given? ? yield(s) : s
end

def dir_re(dir)
  Regexp.new('\$(?:\('+dir+'\)|\{'+dir+'\})(?:\$(?:\(target_prefix\)|\{target_prefix\}))?')
end

INSTALL_DIRS = [
  [dir_re('commondir'), &quot;$(RUBYCOMMONDIR)&quot;],
  [dir_re('sitedir'), &quot;$(RUBYCOMMONDIR)&quot;],
  [dir_re('vendordir'), &quot;$(RUBYCOMMONDIR)&quot;],
  [dir_re('rubylibdir'), &quot;$(RUBYLIBDIR)&quot;],
  [dir_re('archdir'), &quot;$(RUBYARCHDIR)&quot;],
  [dir_re('sitelibdir'), &quot;$(RUBYLIBDIR)&quot;],
  [dir_re('vendorlibdir'), &quot;$(RUBYLIBDIR)&quot;],
  [dir_re('sitearchdir'), &quot;$(RUBYARCHDIR)&quot;],
  [dir_re('bindir'), &quot;$(BINDIR)&quot;],
  [dir_re('vendorarchdir'), &quot;$(RUBYARCHDIR)&quot;],
]

def install_dirs(target_prefix = nil)
  if $extout
    dirs = [
      ['BINDIR',        '$(extout)/bin'],
      ['RUBYCOMMONDIR', '$(extout)/common'],
      ['RUBYLIBDIR',    '$(RUBYCOMMONDIR)$(target_prefix)'],
      ['RUBYARCHDIR',   '$(extout)/$(arch)$(target_prefix)'],
      ['extout',        &quot;#$extout&quot;],
      ['extout_prefix', &quot;#$extout_prefix&quot;],
    ]
  elsif $extmk
    dirs = [
      ['BINDIR',        '$(bindir)'],
      ['RUBYCOMMONDIR', '$(rubylibdir)'],
      ['RUBYLIBDIR',    '$(rubylibdir)$(target_prefix)'],
      ['RUBYARCHDIR',   '$(archdir)$(target_prefix)'],
    ]
  elsif $configure_args.has_key?('--vendor')
    dirs = [
      ['BINDIR',        '$(bindir)'],
      ['RUBYCOMMONDIR', '$(vendordir)$(target_prefix)'],
      ['RUBYLIBDIR',    '$(vendorlibdir)$(target_prefix)'],
      ['RUBYARCHDIR',   '$(vendorarchdir)$(target_prefix)'],
    ]
  else
    dirs = [
      ['BINDIR',        '$(bindir)'],
      ['RUBYCOMMONDIR', '$(sitedir)$(target_prefix)'],
      ['RUBYLIBDIR',    '$(sitelibdir)$(target_prefix)'],
      ['RUBYARCHDIR',   '$(sitearchdir)$(target_prefix)'],
    ]
  end
  dirs &lt;&lt; ['target_prefix', (target_prefix ? &quot;/#{target_prefix}&quot; : &quot;&quot;)]
  dirs
end

def map_dir(dir, map = nil)
  map ||= INSTALL_DIRS
  map.inject(dir) {|dir, (orig, new)| dir.gsub(orig, new)}
end

topdir = File.dirname(libdir = File.dirname(__FILE__))
extdir = File.expand_path(&quot;ext&quot;, topdir)
$extmk = File.expand_path($0)[0, extdir.size+1] == extdir+&quot;/&quot;
if not $extmk and File.exist?(($hdrdir = Config::CONFIG[&quot;archdir&quot;]) + &quot;/ruby.h&quot;)
  $topdir = $hdrdir
elsif File.exist?(($hdrdir = ($top_srcdir ||= topdir))  + &quot;/ruby.h&quot;) and
    File.exist?(($topdir ||= Config::CONFIG[&quot;topdir&quot;]) + &quot;/config.h&quot;)
else
  abort &quot;mkmf.rb can't find header files for ruby at #{$hdrdir}/ruby.h&quot;
end

OUTFLAG = CONFIG['OUTFLAG']
CPPOUTFILE = CONFIG['CPPOUTFILE']

CONFTEST_C = &quot;conftest.c&quot;

class String
  # Wraps a string in escaped quotes if it contains whitespace.
  def quote
    /\s/ =~ self ? &quot;\&quot;#{self}\&quot;&quot; : &quot;#{self}&quot;
  end

  # Generates a string used as cpp macro name.
  def tr_cpp
    strip.upcase.tr_s(&quot;^A-Z0-9_&quot;, &quot;_&quot;)
  end
end
class Array
  # Wraps all strings in escaped quotes if they contain whitespace.
  def quote
    map {|s| s.quote}
  end
end

def rm_f(*files)
  FileUtils.rm_f(Dir[files.join(&quot;\0&quot;)])
end

# Returns time stamp of the +target+ file if it exists and is newer
# than or equal to all of +times+.
def modified?(target, times)
  (t = File.mtime(target)) rescue return nil
  Array === times or times = [times]
  t if times.all? {|n| n &lt;= t}
end

def merge_libs(*libs)
  libs.inject([]) do |x, y|
    xy = x &amp; y
    xn = yn = 0
    y = y.inject([]) {|ary, e| ary.last == e ? ary : ary &lt;&lt; e}
    y.each_with_index do |v, yi|
      if xy.include?(v)
        xi = [x.index(v), xn].max()
        x[xi, 1] = y[yn..yi]
        xn, yn = xi + (yi - yn + 1), yi + 1
      end
    end
    x.concat(y[yn..-1] || [])
  end
end

# This is a custom logging module. It generates an mkmf.log file when you
# run your extconf.rb script. This can be useful for debugging unexpected
# failures.
#
# This module and its associated methods are meant for internal use only.
#
module Logging
  @log = nil
  @logfile = 'mkmf.log'
  @orgerr = $stderr.dup
  @orgout = $stdout.dup
  @postpone = 0
  @quiet = $extmk

  def self::open
    @log ||= File::open(@logfile, 'w')
    @log.sync = true
    $stderr.reopen(@log)
    $stdout.reopen(@log)
    yield
  ensure
    $stderr.reopen(@orgerr)
    $stdout.reopen(@orgout)
  end

  def self::message(*s)
    @log ||= File::open(@logfile, 'w')
    @log.sync = true
    @log.printf(*s)
  end

  def self::logfile file
    @logfile = file
    if @log and not @log.closed?
      @log.flush
      @log.close
      @log = nil
    end
  end
  
  def self::postpone
    tmplog = &quot;mkmftmp#{@postpone += 1}.log&quot;
    open do
      log, *save = @log, @logfile, @orgout, @orgerr
      @log, @logfile, @orgout, @orgerr = nil, tmplog, log, log
      begin
        log.print(open {yield})
        @log.close
        File::open(tmplog) {|t| FileUtils.copy_stream(t, log)}
      ensure
        @log, @logfile, @orgout, @orgerr = log, *save
        @postpone -= 1
        rm_f tmplog
      end
    end
  end

  class &lt;&lt; self
    attr_accessor :quiet
  end
end

def xsystem command
  varpat = /\$\((\w+)\)|\$\{(\w+)\}/
  if varpat =~ command
    vars = Hash.new {|h, k| h[k] = ''; ENV[k]}
    command = command.dup
    nil while command.gsub!(varpat) {vars[$1||$2]}
  end
  Logging::open do
    puts command.quote
    system(command)
  end
end

def xpopen command, *mode, &amp;block
  Logging::open do
    case mode[0]
    when nil, /^r/
      puts &quot;#{command} |&quot;
    else
      puts &quot;| #{command}&quot;
    end
    IO.popen(command, *mode, &amp;block)
  end
end

def log_src(src)
  src = src.split(/^/)
  fmt = &quot;%#{src.size.to_s.size}d: %s&quot;
  Logging::message &lt;&lt;&quot;EOM&quot;
checked program was:
/* begin */
EOM
  src.each_with_index {|line, no| Logging::message fmt, no+1, line}
  Logging::message &lt;&lt;&quot;EOM&quot;
/* end */

EOM
end

def create_tmpsrc(src)
  src = yield(src) if block_given?
  src = src.gsub(/[ \t]+$/, '').gsub(/\A\n+|^\n+$/, '').sub(/[^\n]\z/, &quot;\\&amp;\n&quot;)
  open(CONFTEST_C, &quot;wb&quot;) do |cfile|
    cfile.print src
  end
  src
end

def try_do(src, command, &amp;b)
  src = create_tmpsrc(src, &amp;b)
  xsystem(command)
ensure
  log_src(src)
end

def link_command(ldflags, opt=&quot;&quot;, libpath=$DEFLIBPATH|$LIBPATH)
  conf = Config::CONFIG.merge('hdrdir' =&gt; $hdrdir.quote,
                              'src' =&gt; CONFTEST_C,
                              'INCFLAGS' =&gt; $INCFLAGS,
                              'CPPFLAGS' =&gt; $CPPFLAGS,
                              'CFLAGS' =&gt; &quot;#$CFLAGS&quot;,
                              'ARCH_FLAG' =&gt; &quot;#$ARCH_FLAG&quot;,
                              'LDFLAGS' =&gt; &quot;#$LDFLAGS #{ldflags}&quot;,
                              'LIBPATH' =&gt; libpathflag(libpath),
                              'LOCAL_LIBS' =&gt; &quot;#$LOCAL_LIBS #$libs&quot;,
                              'LIBS' =&gt; &quot;#$LIBRUBYARG_STATIC #{opt} #$LIBS&quot;)
  Config::expand(TRY_LINK.dup, conf)
end

def cc_command(opt=&quot;&quot;)
  conf = Config::CONFIG.merge('hdrdir' =&gt; $hdrdir.quote, 'srcdir' =&gt; $srcdir.quote)
  Config::expand(&quot;$(CC) #$INCFLAGS #$CPPFLAGS #$CFLAGS #$ARCH_FLAG #{opt} -c #{CONFTEST_C}&quot;,
		 conf)
end

def cpp_command(outfile, opt=&quot;&quot;)
  conf = Config::CONFIG.merge('hdrdir' =&gt; $hdrdir.quote, 'srcdir' =&gt; $srcdir.quote)
  Config::expand(&quot;$(CPP) #$INCFLAGS #$CPPFLAGS #$CFLAGS #{opt} #{CONFTEST_C} #{outfile}&quot;,
		 conf)
end

def libpathflag(libpath=$DEFLIBPATH|$LIBPATH)
  libpath.map{|x|
    case x
    when &quot;$(topdir)&quot;, /\A\./
      LIBPATHFLAG
    else
      LIBPATHFLAG+RPATHFLAG
    end % x.quote
  }.join
end

def try_link0(src, opt=&quot;&quot;, &amp;b)
  try_do(src, link_command(&quot;&quot;, opt), &amp;b)
end

def try_link(src, opt=&quot;&quot;, &amp;b)
  try_link0(src, opt, &amp;b)
ensure
  rm_f &quot;conftest*&quot;, &quot;c0x32*&quot;
end

def try_compile(src, opt=&quot;&quot;, &amp;b)
  try_do(src, cc_command(opt), &amp;b)
ensure
  rm_f &quot;conftest*&quot;
end

def try_cpp(src, opt=&quot;&quot;, &amp;b)
  try_do(src, cpp_command(CPPOUTFILE, opt), &amp;b)
ensure
  rm_f &quot;conftest*&quot;
end

def cpp_include(header)
  if header
    header = [header] unless header.kind_of? Array
    header.map {|h| &quot;#include &lt;#{h}&gt;\n&quot;}.join
  else
    &quot;&quot;
  end
end

def with_cppflags(flags)
  cppflags = $CPPFLAGS
  $CPPFLAGS = flags
  ret = yield
ensure
  $CPPFLAGS = cppflags unless ret
end

def with_cflags(flags)
  cflags = $CFLAGS
  $CFLAGS = flags
  ret = yield
ensure
  $CFLAGS = cflags unless ret
end

def with_ldflags(flags)
  ldflags = $LDFLAGS
  $LDFLAGS = flags
  ret = yield
ensure
  $LDFLAGS = ldflags unless ret
end

def try_static_assert(expr, headers = nil, opt = &quot;&quot;, &amp;b)
  headers = cpp_include(headers)
  try_compile(&lt;&lt;SRC, opt, &amp;b)
#{COMMON_HEADERS}
#{headers}
/*top*/
int conftest_const[(#{expr}) ? 1 : -1];
SRC
end

def try_constant(const, headers = nil, opt = &quot;&quot;, &amp;b)
  includes = cpp_include(headers)
  if CROSS_COMPILING
    if try_static_assert(&quot;#{const} &gt; 0&quot;, headers, opt)
      # positive constant
    elsif try_static_assert(&quot;#{const} &lt; 0&quot;, headers, opt)
      neg = true
      const = &quot;-(#{const})&quot;
    elsif try_static_assert(&quot;#{const} == 0&quot;, headers, opt)
      return 0
    else
      # not a constant
      return nil
    end
    upper = 1
    lower = 0
    until try_static_assert(&quot;#{const} &lt;= #{upper}&quot;, headers, opt)
      lower = upper
      upper &lt;&lt;= 1
    end
    return nil unless lower
    while upper &gt; lower + 1
      mid = (upper + lower) / 2
      if try_static_assert(&quot;#{const} &gt; #{mid}&quot;, headers, opt)
        lower = mid
      else
        upper = mid
      end
    end
    upper = -upper if neg
    return upper
  else
    src = %{#{COMMON_HEADERS}
#{includes}
#include &lt;stdio.h&gt;
/*top*/
int conftest_const = (int)(#{const});
int main() {printf(&quot;%d\\n&quot;, conftest_const); return 0;}
}
    if try_link0(src, opt, &amp;b)
      xpopen(&quot;./conftest&quot;) do |f|
        return Integer(f.gets)
      end
    end
  end
  nil
end

def try_func(func, libs, headers = nil, &amp;b)
  headers = cpp_include(headers)
  try_link(&lt;&lt;&quot;SRC&quot;, libs, &amp;b) or try_link(&lt;&lt;&quot;SRC&quot;, libs, &amp;b)
#{COMMON_HEADERS}
#{headers}
/*top*/
int main() { return 0; }
int t() { void ((*volatile p)()); p = (void ((*)()))#{func}; return 0; }
SRC
#{headers}
/*top*/
int main() { return 0; }
int t() { #{func}(); return 0; }
SRC
end

def try_var(var, headers = nil, &amp;b)
  headers = cpp_include(headers)
  try_compile(&lt;&lt;&quot;SRC&quot;, &amp;b)
#{COMMON_HEADERS}
#{headers}
/*top*/
int main() { return 0; }
int t() { const volatile void *volatile p; p = &amp;(&amp;#{var})[0]; return 0; }
SRC
end

def egrep_cpp(pat, src, opt = &quot;&quot;, &amp;b)
  src = create_tmpsrc(src, &amp;b)
  xpopen(cpp_command('', opt)) do |f|
    if Regexp === pat
      puts(&quot;    ruby -ne 'print if #{pat.inspect}'&quot;)
      f.grep(pat) {|l|
	puts &quot;#{f.lineno}: #{l}&quot;
	return true
      }
      false
    else
      puts(&quot;    egrep '#{pat}'&quot;)
      begin
	stdin = $stdin.dup
	$stdin.reopen(f)
	system(&quot;egrep&quot;, pat)
      ensure
	$stdin.reopen(stdin)
      end
    end
  end
ensure
  rm_f &quot;conftest*&quot;
  log_src(src)
end

# This is used internally by the have_macro? method.
def macro_defined?(macro, src, opt = &quot;&quot;, &amp;b)
  src = src.sub(/[^\n]\z/, &quot;\\&amp;\n&quot;)
  try_compile(src + &lt;&lt;&quot;SRC&quot;, opt, &amp;b)
/*top*/
#ifndef #{macro}
# error
&gt;&gt;&gt;&gt;&gt;&gt; #{macro} undefined &lt;&lt;&lt;&lt;&lt;&lt;
#endif
SRC
end

def try_run(src, opt = &quot;&quot;, &amp;b)
  if try_link0(src, opt, &amp;b)
    xsystem(&quot;./conftest&quot;)
  else
    nil
  end
ensure
  rm_f &quot;conftest*&quot;
end

def install_files(mfile, ifiles, map = nil, srcprefix = nil)
  ifiles or return
  ifiles.empty? and return
  srcprefix ||= '$(srcdir)'
  Config::expand(srcdir = srcprefix.dup)
  dirs = []
  path = Hash.new {|h, i| h[i] = dirs.push([i])[-1]}
  ifiles.each do |files, dir, prefix|
    dir = map_dir(dir, map)
    prefix &amp;&amp;= %r|\A#{Regexp.quote(prefix)}/?|
    if /\A\.\// =~ files
      # install files which are in current working directory.
      files = files[2..-1]
      len = nil
    else
      # install files which are under the $(srcdir).
      files = File.join(srcdir, files)
      len = srcdir.size
    end
    f = nil
    Dir.glob(files) do |f|
      f[0..len] = &quot;&quot; if len
      case File.basename(f)
      when *$NONINSTALLFILES
        next
      end
      d = File.dirname(f)
      d.sub!(prefix, &quot;&quot;) if prefix
      d = (d.empty? || d == &quot;.&quot;) ? dir : File.join(dir, d)
      f = File.join(srcprefix, f) if len
      path[d] &lt;&lt; f
    end
    unless len or f
      d = File.dirname(files)
      d.sub!(prefix, &quot;&quot;) if prefix
      d = (d.empty? || d == &quot;.&quot;) ? dir : File.join(dir, d)
      path[d] &lt;&lt; files
    end
  end
  dirs
end

def install_rb(mfile, dest, srcdir = nil)
  install_files(mfile, [[&quot;lib/**/*.rb&quot;, dest, &quot;lib&quot;]], nil, srcdir)
end

def append_library(libs, lib) # :no-doc:
  format(LIBARG, lib) + &quot; &quot; + libs
end

def message(*s)
  unless Logging.quiet and not $VERBOSE
    printf(*s)
    $stdout.flush
  end
end

# This emits a string to stdout that allows users to see the results of the
# various have* and find* methods as they are tested.
#
# Internal use only.
#
def checking_for(m, fmt = nil)
  f = caller[0][/in `(.*)'$/, 1] and f &lt;&lt; &quot;: &quot; #` for vim
  m = &quot;checking #{/\Acheck/ =~ f ? '' : 'for '}#{m}... &quot;
  message &quot;%s&quot;, m
  a = r = nil
  Logging::postpone do
    r = yield
    a = (fmt ? fmt % r : r ? &quot;yes&quot; : &quot;no&quot;) &lt;&lt; &quot;\n&quot;
    &quot;#{f}#{m}-------------------- #{a}\n&quot;
  end
  message(a)
  Logging::message &quot;--------------------\n\n&quot;
  r
end

def checking_message(target, place = nil, opt = nil)
  [[&quot;in&quot;, place], [&quot;with&quot;, opt]].inject(&quot;#{target}&quot;) do |msg, (pre, noun)|
    if noun
      [[:to_str], [:join, &quot;,&quot;], [:to_s]].each do |meth, *args|
        if noun.respond_to?(meth)
          break noun = noun.send(meth, *args)
        end
      end
      msg &lt;&lt; &quot; #{pre} #{noun}&quot; unless noun.empty?
    end
    msg
  end
end

# :startdoc:

# Returns whether or not +macro+ is defined either in the common header
# files or within any +headers+ you provide.
#
# Any options you pass to +opt+ are passed along to the compiler.
#
def have_macro(macro, headers = nil, opt = &quot;&quot;, &amp;b)
  checking_for checking_message(macro, headers, opt) do
    macro_defined?(macro, cpp_include(headers), opt, &amp;b)
  end
end

# Returns whether or not the given entry point +func+ can be found within
# +lib+.  If +func+ is nil, the 'main()' entry point is used by default.
# If found, it adds the library to list of libraries to be used when linking
# your extension.
#
# If +headers+ are provided, it will include those header files as the
# header files it looks in when searching for +func+.
#
# The real name of the library to be linked can be altered by
# '--with-FOOlib' configuration option.
#
def have_library(lib, func = nil, headers = nil, &amp;b)
  func = &quot;main&quot; if !func or func.empty?
  lib = with_config(lib+'lib', lib)
  checking_for checking_message(&quot;#{func}()&quot;, LIBARG%lib) do
    if COMMON_LIBS.include?(lib)
      true
    else
      libs = append_library($libs, lib)
      if try_func(func, libs, headers, &amp;b)
        $libs = libs
        true
      else
        false
      end
    end
  end
end

# Returns whether or not the entry point +func+ can be found within the library
# +lib+ in one of the +paths+ specified, where +paths+ is an array of strings.
# If +func+ is nil , then the main() function is used as the entry point.
#
# If +lib+ is found, then the path it was found on is added to the list of
# library paths searched and linked against.
#
def find_library(lib, func, *paths, &amp;b)
  func = &quot;main&quot; if !func or func.empty?
  lib = with_config(lib+'lib', lib)
  paths = paths.collect {|path| path.split(File::PATH_SEPARATOR)}.flatten
  checking_for &quot;#{func}() in #{LIBARG%lib}&quot; do
    libpath = $LIBPATH
    libs = append_library($libs, lib)
    begin
      until r = try_func(func, libs, &amp;b) or paths.empty?
	$LIBPATH = libpath | [paths.shift]
      end
      if r
	$libs = libs
	libpath = nil
      end
    ensure
      $LIBPATH = libpath if libpath
    end
    r
  end
end

# Returns whether or not the function +func+ can be found in the common
# header files, or within any +headers+ that you provide.  If found, a
# macro is passed as a preprocessor constant to the compiler using the
# function name, in uppercase, prepended with 'HAVE_'.
#
# For example, if have_func('foo') returned true, then the HAVE_FOO
# preprocessor macro would be passed to the compiler.
#
def have_func(func, headers = nil, &amp;b)
  checking_for checking_message(&quot;#{func}()&quot;, headers) do
    if try_func(func, $libs, headers, &amp;b)
      $defs.push(format(&quot;-DHAVE_%s&quot;, func.tr_cpp))
      true
    else
      false
    end
  end
end

# Returns whether or not the variable +var+ can be found in the common
# header files, or within any +headers+ that you provide.  If found, a
# macro is passed as a preprocessor constant to the compiler using the
# variable name, in uppercase, prepended with 'HAVE_'.
#
# For example, if have_var('foo') returned true, then the HAVE_FOO
# preprocessor macro would be passed to the compiler.
#
def have_var(var, headers = nil, &amp;b)
  checking_for checking_message(var, headers) do
    if try_var(var, headers, &amp;b)
      $defs.push(format(&quot;-DHAVE_%s&quot;, var.tr_cpp))
      true
    else
      false
    end
  end
end

# Returns whether or not the given +header+ file can be found on your system.
# If found, a macro is passed as a preprocessor constant to the compiler using
# the header file name, in uppercase, prepended with 'HAVE_'.
#
# For example, if have_header('foo.h') returned true, then the HAVE_FOO_H
# preprocessor macro would be passed to the compiler.
#
def have_header(header, &amp;b)
  checking_for header do
    if try_cpp(cpp_include(header), &amp;b)
      $defs.push(format(&quot;-DHAVE_%s&quot;, header.tr(&quot;a-z./\055&quot;, &quot;A-Z___&quot;)))
      true
    else
      false
    end
  end
end

# Instructs mkmf to search for the given +header+ in any of the +paths+
# provided, and returns whether or not it was found in those paths.
#
# If the header is found then the path it was found on is added to the list
# of included directories that are sent to the compiler (via the -I switch).
#
def find_header(header, *paths)
  message = checking_message(header, paths)
  header = cpp_include(header)
  checking_for message do
    if try_cpp(header)
      true
    else
      found = false
      paths.each do |dir|
        opt = &quot;-I#{dir}&quot;.quote
        if try_cpp(header, opt)
          $INCFLAGS &lt;&lt; &quot; &quot; &lt;&lt; opt
          found = true
          break
        end
      end
      found
    end
  end
end

# Returns whether or not the struct of type +type+ contains +member+.  If
# it does not, or the struct type can't be found, then false is returned.  You
# may optionally specify additional +headers+ in which to look for the struct
# (in addition to the common header files).
#
# If found, a macro is passed as a preprocessor constant to the compiler using
# the member name, in uppercase, prepended with 'HAVE_ST_'.
#
# For example, if have_struct_member('struct foo', 'bar') returned true, then the
# HAVE_ST_BAR preprocessor macro would be passed to the compiler.
# 
def have_struct_member(type, member, headers = nil, &amp;b)
  checking_for checking_message(&quot;#{type}.#{member}&quot;, headers) do
    if try_compile(&lt;&lt;&quot;SRC&quot;, &amp;b)
#{COMMON_HEADERS}
#{cpp_include(headers)}
/*top*/
int main() { return 0; }
int s = (char *)&amp;((#{type}*)0)-&gt;#{member} - (char *)0;
SRC
      $defs.push(format(&quot;-DHAVE_ST_%s&quot;, member.tr_cpp))
      true
    else
      false
    end
  end
end

def try_type(type, headers = nil, opt = &quot;&quot;, &amp;b)
  if try_compile(&lt;&lt;&quot;SRC&quot;, opt, &amp;b)
#{COMMON_HEADERS}
#{cpp_include(headers)}
/*top*/
typedef #{type} conftest_type;
int conftestval[sizeof(conftest_type)?1:-1];
SRC
    $defs.push(format(&quot;-DHAVE_TYPE_%s&quot;, type.tr_cpp))
    true
  else
    false
  end
end

# Returns whether or not the static type +type+ is defined.  You may
# optionally pass additional +headers+ to check against in addition to the
# common header files.
#
# You may also pass additional flags to +opt+ which are then passed along to
# the compiler.
#
# If found, a macro is passed as a preprocessor constant to the compiler using
# the type name, in uppercase, prepended with 'HAVE_TYPE_'.
#
# For example, if have_type('foo') returned true, then the HAVE_TYPE_FOO
# preprocessor macro would be passed to the compiler.
#
def have_type(type, headers = nil, opt = &quot;&quot;, &amp;b)
  checking_for checking_message(type, headers, opt) do
    try_type(type, headers, opt, &amp;b)
  end
end

# Returns where the static type +type+ is defined.
#
# You may also pass additional flags to +opt+ which are then passed along to
# the compiler.
#
# See also +have_type+.
#
def find_type(type, opt, *headers, &amp;b)
  opt ||= &quot;&quot;
  fmt = &quot;not found&quot;
  def fmt.%(x)
    x ? x.respond_to?(:join) ? x.join(&quot;,&quot;) : x : self
  end
  checking_for checking_message(type, nil, opt), fmt do
    headers.find do |h|
      try_type(type, h, opt, &amp;b)
    end
  end
end

def try_const(const, headers = nil, opt = &quot;&quot;, &amp;b)
  const, type = *const
  if try_compile(&lt;&lt;&quot;SRC&quot;, opt, &amp;b)
#{COMMON_HEADERS}
#{cpp_include(headers)}
/*top*/
typedef #{type || 'int'} conftest_type;
conftest_type conftestval = #{type ? '' : '(int)'}#{const};
SRC
    $defs.push(format(&quot;-DHAVE_CONST_%s&quot;, const.tr_cpp))
    true
  else
    false
  end
end

# Returns whether or not the constant +const+ is defined.  You may
# optionally pass the +type+ of +const+ as &lt;code&gt;[const, type]&lt;/code&gt;,
# like as:
#
#   have_const(%w[PTHREAD_MUTEX_INITIALIZER pthread_mutex_t], &quot;pthread.h&quot;)
#
# You may also pass additional +headers+ to check against in addition
# to the common header files, and additional flags to +opt+ which are
# then passed along to the compiler.
#
# If found, a macro is passed as a preprocessor constant to the compiler using
# the type name, in uppercase, prepended with 'HAVE_CONST_'.
#
# For example, if have_const('foo') returned true, then the HAVE_CONST_FOO
# preprocessor macro would be passed to the compiler.
#
def have_const(const, headers = nil, opt = &quot;&quot;, &amp;b)
  checking_for checking_message([*const].compact.join(' '), headers, opt) do
    try_const(const, headers, opt, &amp;b)
  end
end

# Returns the size of the given +type+.  You may optionally specify additional
# +headers+ to search in for the +type+.
#
# If found, a macro is passed as a preprocessor constant to the compiler using
# the type name, in uppercase, prepended with 'SIZEOF_', followed by the type
# name, followed by '=X' where 'X' is the actual size.
#
# For example, if check_sizeof('mystruct') returned 12, then the
# SIZEOF_MYSTRUCT=12 preprocessor macro would be passed to the compiler.
#
def check_sizeof(type, headers = nil, &amp;b)
  expr = &quot;sizeof(#{type})&quot;
  fmt = &quot;%d&quot;
  def fmt.%(x)
    x ? super : &quot;failed&quot;
  end
  checking_for checking_message(&quot;size of #{type}&quot;, headers), fmt do
    if size = try_constant(expr, headers, &amp;b)
      $defs.push(format(&quot;-DSIZEOF_%s=%d&quot;, type.tr_cpp, size))
      size
    end
  end
end

# :stopdoc:

# Used internally by the what_type? method to determine if +type+ is a scalar
# pointer.
def scalar_ptr_type?(type, member = nil, headers = nil, &amp;b)
  try_compile(&lt;&lt;&quot;SRC&quot;, &amp;b)   # pointer
#{COMMON_HEADERS}
#{cpp_include(headers)}
/*top*/
volatile #{type} conftestval;
int main() { return 0; }
int t() {return (int)(1-*(conftestval#{member ? &quot;.#{member}&quot; : &quot;&quot;}));}
SRC
end

# Used internally by the what_type? method to determine if +type+ is a scalar
# pointer.
def scalar_type?(type, member = nil, headers = nil, &amp;b)
  try_compile(&lt;&lt;&quot;SRC&quot;, &amp;b)   # pointer
#{COMMON_HEADERS}
#{cpp_include(headers)}
/*top*/
volatile #{type} conftestval;
int main() { return 0; }
int t() {return (int)(1-(conftestval#{member ? &quot;.#{member}&quot; : &quot;&quot;}));}
SRC
end

def what_type?(type, member = nil, headers = nil, &amp;b)
  m = &quot;#{type}&quot;
  name = type
  if member
    m &lt;&lt; &quot;.&quot; &lt;&lt; member
    name = &quot;(((#{type} *)0)-&gt;#{member})&quot;
  end
  fmt = &quot;seems %s&quot;
  def fmt.%(x)
    x ? super : &quot;unknown&quot;
  end
  checking_for checking_message(m, headers), fmt do
    if scalar_ptr_type?(type, member, headers, &amp;b)
      if try_static_assert(&quot;sizeof(*#{name}) == 1&quot;, headers)
        &quot;string&quot;
      end
    elsif scalar_type?(type, member, headers, &amp;b)
      if try_static_assert(&quot;sizeof(#{name}) &gt; sizeof(long)&quot;, headers)
        &quot;long long&quot;
      elsif try_static_assert(&quot;sizeof(#{name}) &gt; sizeof(int)&quot;, headers)
        &quot;long&quot;
      elsif try_static_assert(&quot;sizeof(#{name}) &gt; sizeof(short)&quot;, headers)
        &quot;int&quot;
      elsif try_static_assert(&quot;sizeof(#{name}) &gt; 1&quot;, headers)
        &quot;short&quot;
      else
        &quot;char&quot;
      end
    end
  end
end

# This method is used internally by the find_executable method.
#
# Internal use only.
#
def find_executable0(bin, path = nil)
  ext = config_string('EXEEXT')
  if File.expand_path(bin) == bin
    return bin if File.executable?(bin)
    ext and File.executable?(file = bin + ext) and return file
    return nil
  end
  if path ||= ENV['PATH']
    path = path.split(File::PATH_SEPARATOR)
  else
    path = %w[/usr/local/bin /usr/ucb /usr/bin /bin]
  end
  file = nil
  path.each do |dir|
    return file if File.executable?(file = File.join(dir, bin))
    return file if ext and File.executable?(file &lt;&lt; ext)
  end
  nil
end

# :startdoc:

# Searches for the executable +bin+ on +path+. The default path is your
# PATH environment variable. If that isn't defined, it will resort to
# searching /usr/local/bin, /usr/ucb, /usr/bin and /bin.
#
# If found, it will return the full path, including the executable name,
# of where it was found.
#
# Note that this method does not actually affect the generated Makefile.
#
def find_executable(bin, path = nil)
  checking_for checking_message(bin, path) do
    find_executable0(bin, path)
  end
end

# :stopdoc:

def arg_config(config, *defaults, &amp;block)
  $arg_config &lt;&lt; [config, *defaults]
  defaults &lt;&lt; nil if !block and defaults.empty?
  $configure_args.fetch(config.tr('_', '-'), *defaults, &amp;block)
end

# :startdoc:

# Tests for the presence of a --with-&lt;tt&gt;config&lt;/tt&gt; or --without-&lt;tt&gt;config&lt;/tt&gt;
# option. Returns true if the with option is given, false if the without
# option is given, and the default value otherwise.
#
# This can be useful for adding custom definitions, such as debug information.
#
# Example:
#
#    if with_config(&quot;debug&quot;)
#       $defs.push(&quot;-DOSSL_DEBUG&quot;) unless $defs.include? &quot;-DOSSL_DEBUG&quot;
#    end
#
def with_config(config, *defaults)
  config = config.sub(/^--with[-_]/, '')
  val = arg_config(&quot;--with-&quot;+config) do
    if arg_config(&quot;--without-&quot;+config)
      false
    elsif block_given?
      yield(config, *defaults)
    else
      break *defaults
    end
  end
  case val
  when &quot;yes&quot;
    true
  when &quot;no&quot;
    false
  else
    val
  end
end

# Tests for the presence of an --enable-&lt;tt&gt;config&lt;/tt&gt; or
# --disable-&lt;tt&gt;config&lt;/tt&gt; option. Returns true if the enable option is given,
# false if the disable option is given, and the default value otherwise.
#
# This can be useful for adding custom definitions, such as debug information.
#
# Example:
#
#    if enable_config(&quot;debug&quot;)
#       $defs.push(&quot;-DOSSL_DEBUG&quot;) unless $defs.include? &quot;-DOSSL_DEBUG&quot;
#    end
#
def enable_config(config, *defaults)
  if arg_config(&quot;--enable-&quot;+config)
    true
  elsif arg_config(&quot;--disable-&quot;+config)
    false
  elsif block_given?
    yield(config, *defaults)
  else
    return *defaults
  end
end

# Generates a header file consisting of the various macro definitions generated
# by other methods such as have_func and have_header. These are then wrapped in
# a custom #ifndef based on the +header+ file name, which defaults to
# 'extconf.h'.
#
# For example:
# 
#    # extconf.rb
#    require 'mkmf'
#    have_func('realpath')
#    have_header('sys/utime.h')
#    create_header
#    create_makefile('foo')
#
# The above script would generate the following extconf.h file:
#
#    #ifndef EXTCONF_H
#    #define EXTCONF_H
#    #define HAVE_REALPATH 1
#    #define HAVE_SYS_UTIME_H 1
#    #endif
#
# Given that the create_header method generates a file based on definitions
# set earlier in your extconf.rb file, you will probably want to make this
# one of the last methods you call in your script.
#
def create_header(header = &quot;extconf.h&quot;)
  message &quot;creating %s\n&quot;, header
  sym = header.tr(&quot;a-z./\055&quot;, &quot;A-Z___&quot;)
  hdr = [&quot;#ifndef #{sym}\n#define #{sym}\n&quot;]
  for line in $defs
    case line
    when /^-D([^=]+)(?:=(.*))?/
      hdr &lt;&lt; &quot;#define #$1 #{$2 ? Shellwords.shellwords($2)[0] : 1}\n&quot;
    when /^-U(.*)/
      hdr &lt;&lt; &quot;#undef #$1\n&quot;
    end
  end
  hdr &lt;&lt; &quot;#endif\n&quot;
  hdr = hdr.join
  unless (IO.read(header) == hdr rescue false)
    open(header, &quot;w&quot;) do |hfile|
      hfile.write(hdr)
    end
  end
  $extconf_h = header
end

# Sets a +target+ name that the user can then use to configure various 'with'
# options with on the command line by using that name.  For example, if the
# target is set to &quot;foo&quot;, then the user could use the --with-foo-dir command
# line option.
#
# You may pass along additional 'include' or 'lib' defaults via the +idefault+
# and +ldefault+ parameters, respectively.
#
# Note that dir_config only adds to the list of places to search for libraries
# and include files.  It does not link the libraries into your application.
#
def dir_config(target, idefault=nil, ldefault=nil)
  if dir = with_config(target + &quot;-dir&quot;, (idefault unless ldefault))
    defaults = Array === dir ? dir : dir.split(File::PATH_SEPARATOR)
    idefault = ldefault = nil
  end

  idir = with_config(target + &quot;-include&quot;, idefault)
  $arg_config.last[1] ||= &quot;${#{target}-dir}/include&quot;
  ldir = with_config(target + &quot;-lib&quot;, ldefault)
  $arg_config.last[1] ||= &quot;${#{target}-dir}/lib&quot;

  idirs = idir ? Array === idir ? idir : idir.split(File::PATH_SEPARATOR) : []
  if defaults
    idirs.concat(defaults.collect {|dir| dir + &quot;/include&quot;})
    idir = ([idir] + idirs).compact.join(File::PATH_SEPARATOR)
  end
  unless idirs.empty?
    idirs.collect! {|dir| &quot;-I&quot; + dir}
    idirs -= Shellwords.shellwords($CPPFLAGS)
    unless idirs.empty?
      $CPPFLAGS = (idirs.quote &lt;&lt; $CPPFLAGS).join(&quot; &quot;)
    end
  end

  ldirs = ldir ? Array === ldir ? ldir : ldir.split(File::PATH_SEPARATOR) : []
  if defaults
    ldirs.concat(defaults.collect {|dir| dir + &quot;/lib&quot;})
    ldir = ([ldir] + ldirs).compact.join(File::PATH_SEPARATOR)
  end
  $LIBPATH = ldirs | $LIBPATH

  [idir, ldir]
end

# :stopdoc:

# Handles meta information about installed libraries. Uses your platform's
# pkg-config program if it has one.
def pkg_config(pkg)
  if pkgconfig = with_config(&quot;#{pkg}-config&quot;) and find_executable0(pkgconfig)
    # iff package specific config command is given
    get = proc {|opt| `#{pkgconfig} --#{opt}`.chomp}
  elsif ($PKGCONFIG ||= 
         (pkgconfig = with_config(&quot;pkg-config&quot;, (&quot;pkg-config&quot; unless CROSS_COMPILING))) &amp;&amp;
         find_executable0(pkgconfig) &amp;&amp; pkgconfig) and
      system(&quot;#{$PKGCONFIG} --exists #{pkg}&quot;)
    # default to pkg-config command
    get = proc {|opt| `#{$PKGCONFIG} --#{opt} #{pkg}`.chomp}
  elsif find_executable0(pkgconfig = &quot;#{pkg}-config&quot;)
    # default to package specific config command, as a last resort.
    get = proc {|opt| `#{pkgconfig} --#{opt}`.chomp}
  end
  if get
    cflags = get['cflags']
    ldflags = get['libs']
    libs = get['libs-only-l']
    ldflags = (Shellwords.shellwords(ldflags) - Shellwords.shellwords(libs)).quote.join(&quot; &quot;)
    $CFLAGS += &quot; &quot; &lt;&lt; cflags
    $LDFLAGS += &quot; &quot; &lt;&lt; ldflags
    $libs += &quot; &quot; &lt;&lt; libs
    Logging::message &quot;package configuration for %s\n&quot;, pkg
    Logging::message &quot;cflags: %s\nldflags: %s\nlibs: %s\n\n&quot;,
                     cflags, ldflags, libs
    [cflags, ldflags, libs]
  else
    Logging::message &quot;package configuration for %s is not found\n&quot;, pkg
    nil
  end
end

def with_destdir(dir)
  dir = dir.sub($dest_prefix_pattern, '')
  /\A\$[\(\{]/ =~ dir ? dir : &quot;$(DESTDIR)&quot;+dir
end

# Converts forward slashes to backslashes. Aimed at MS Windows.
#
# Internal use only.
#
def winsep(s)
  s.tr('/', '\\')
end

def configuration(srcdir)
  mk = []
  vpath = %w[$(srcdir) $(topdir) $(hdrdir)]
  if !CROSS_COMPILING
    case CONFIG['build_os']
    when 'cygwin'
      if CONFIG['target_os'] != 'cygwin'
        vpath.each {|p| p.sub!(/.*/, '$(shell cygpath -u \&amp;)')}
      end
    when 'msdosdjgpp', 'mingw32'
      CONFIG['PATH_SEPARATOR'] = ';'
    end
  end
  mk &lt;&lt; %{
SHELL = /bin/sh

#### Start of system configuration section. ####
#{
if $extmk
  &quot;top_srcdir = &quot; + $top_srcdir.sub(%r&quot;\A#{Regexp.quote($topdir)}/&quot;, &quot;$(topdir)/&quot;)
end
}
srcdir = #{srcdir.gsub(/\$\((srcdir)\)|\$\{(srcdir)\}/) {CONFIG[$1||$2]}.quote}
topdir = #{($extmk ? CONFIG[&quot;topdir&quot;] : $topdir).quote}
hdrdir = #{$extmk ? CONFIG[&quot;hdrdir&quot;].quote : '$(topdir)'}
VPATH = #{vpath.join(CONFIG['PATH_SEPARATOR'])}
}
  if $extmk
    mk &lt;&lt; &quot;RUBYLIB = -\nRUBYOPT = -rpurelib.rb\n&quot;
  end
  if destdir = CONFIG[&quot;prefix&quot;][$dest_prefix_pattern, 1]
    mk &lt;&lt; &quot;\nDESTDIR = #{destdir}\n&quot;
  end
  CONFIG.each do |key, var|
    next unless /prefix$/ =~ key
    mk &lt;&lt; &quot;#{key} = #{with_destdir(var)}\n&quot;
  end
  CONFIG.each do |key, var|
    next if /^abs_/ =~ key
    next unless /^(?:src|top|hdr|(.*))dir$/ =~ key and $1
    mk &lt;&lt; &quot;#{key} = #{with_destdir(var)}\n&quot;
  end
  if !$extmk and !$configure_args.has_key?('--ruby') and
      sep = config_string('BUILD_FILE_SEPARATOR')
    sep = &quot;:/=#{sep}&quot;
  else
    sep = &quot;&quot;
  end
  extconf_h = $extconf_h ? &quot;-DRUBY_EXTCONF_H=\\\&quot;$(RUBY_EXTCONF_H)\\\&quot; &quot; : $defs.join(&quot; &quot;)&lt;&lt;&quot; &quot;
  mk &lt;&lt; %{
CC = #{CONFIG['CC']}
LIBRUBY = #{CONFIG['LIBRUBY']}
LIBRUBY_A = #{CONFIG['LIBRUBY_A']}
LIBRUBYARG_SHARED = #$LIBRUBYARG_SHARED
LIBRUBYARG_STATIC = #$LIBRUBYARG_STATIC

RUBY_EXTCONF_H = #{$extconf_h}
CFLAGS   = #{$static ? '' : CONFIG['CCDLFLAGS']} #$CFLAGS #$ARCH_FLAG
INCFLAGS = -I. #$INCFLAGS
DEFS     = #{CONFIG['DEFS']}
CPPFLAGS = #{extconf_h}#{$CPPFLAGS}
CXXFLAGS = $(CFLAGS) #{CONFIG['CXXFLAGS']}
ldflags  = #{$LDFLAGS}
dldflags = #{$DLDFLAGS}
archflag = #{$ARCH_FLAG}
DLDFLAGS = $(ldflags) $(dldflags) $(archflag)
LDSHARED = #{CONFIG['LDSHARED']}
AR = #{CONFIG['AR']}
EXEEXT = #{CONFIG['EXEEXT']}

RUBY_INSTALL_NAME = #{CONFIG['RUBY_INSTALL_NAME']}
RUBY_SO_NAME = #{CONFIG['RUBY_SO_NAME']}
arch = #{CONFIG['arch']}
sitearch = #{CONFIG['sitearch']}
ruby_version = #{Config::CONFIG['ruby_version']}
ruby = #{$ruby}
RUBY = $(ruby#{sep})
RM = #{config_string('RM') || '$(RUBY) -run -e rm -- -f'}
MAKEDIRS = #{config_string('MAKEDIRS') || '@$(RUBY) -run -e mkdir -- -p'}
INSTALL = #{config_string('INSTALL') || '@$(RUBY) -run -e install -- -vp'}
INSTALL_PROG = #{config_string('INSTALL_PROG') || '$(INSTALL) -m 0755'}
INSTALL_DATA = #{config_string('INSTALL_DATA') || '$(INSTALL) -m 0644'}
COPY = #{config_string('CP') || '@$(RUBY) -run -e cp -- -v'}

#### End of system configuration section. ####

preload = #{$preload ? $preload.join(' ') : ''}
}
  if $nmake == ?b
    mk.each do |x|
      x.gsub!(/^(MAKEDIRS|INSTALL_(?:PROG|DATA))+\s*=.*\n/) do
        &quot;!ifndef &quot; + $1 + &quot;\n&quot; +
        $&amp; +
	&quot;!endif\n&quot;
      end
    end
  end
  mk
end

def dummy_makefile(srcdir)
  configuration(srcdir) &lt;&lt; &lt;&lt;RULES &lt;&lt; CLEANINGS
CLEANFILES = #{$cleanfiles.join(' ')}
DISTCLEANFILES = #{$distcleanfiles.join(' ')}

all install static install-so install-rb: Makefile

RULES
end
# :startdoc:

# Generates the Makefile for your extension, passing along any options and
# preprocessor constants that you may have generated through other methods.
#
# The +target+ name should correspond the name of the global function name
# defined within your C extension, minus the 'Init_'.  For example, if your
# C extension is defined as 'Init_foo', then your target would simply be 'foo'.
#
# If any '/' characters are present in the target name, only the last name
# is interpreted as the target name, and the rest are considered toplevel
# directory names, and the generated Makefile will be altered accordingly to
# follow that directory structure.
#
# For example, if you pass 'test/foo' as a target name, your extension will
# be installed under the 'test' directory.  This means that in order to
# load the file within a Ruby program later, that directory structure will
# have to be followed, e.g. &quot;require 'test/foo'&quot;.
#
# The +srcprefix+ should be used when your source files are not in the same
# directory as your build script. This will not only eliminate the need for
# you to manually copy the source files into the same directory as your build
# script, but it also sets the proper +target_prefix+ in the generated
# Makefile.
#
# Setting the +target_prefix+ will, in turn, install the generated binary in
# a directory under your Config::CONFIG['sitearchdir'] that mimics your local
# filesystem when you run 'make install'.
#
# For example, given the following file tree:
#
#    ext/
#       extconf.rb
#       test/
#          foo.c
#
# And given the following code:
#
#    create_makefile('test/foo', 'test')
#
# That will set the +target_prefix+ in the generated Makefile to 'test'. That,
# in turn, will create the following file tree when installed via the
# 'make install' command:
#
#    /path/to/ruby/sitearchdir/test/foo.so
#
# It is recommended that you use this approach to generate your makefiles,
# instead of copying files around manually, because some third party
# libraries may depend on the +target_prefix+ being set properly.
#
# The +srcprefix+ argument can be used to override the default source
# directory, i.e. the current directory . It is included as part of the VPATH
# and added to the list of INCFLAGS.
#
def create_makefile(target, srcprefix = nil)
  $target = target
  libpath = $DEFLIBPATH|$LIBPATH
  message &quot;creating Makefile\n&quot;
  rm_f &quot;conftest*&quot;
  if CONFIG[&quot;DLEXT&quot;] == $OBJEXT
    for lib in libs = $libs.split
      lib.sub!(/-l(.*)/, %%&quot;lib\\1.#{$LIBEXT}&quot;%)
    end
    $defs.push(format(&quot;-DEXTLIB='%s'&quot;, libs.join(&quot;,&quot;)))
  end

  if target.include?('/')
    target_prefix, target = File.split(target)
    target_prefix[0,0] = '/'
  else
    target_prefix = &quot;&quot;
  end

  srcprefix ||= '$(srcdir)'
  Config::expand(srcdir = srcprefix.dup)

  if not $objs
    $objs = []
    srcs = Dir[File.join(srcdir, &quot;*.{#{SRC_EXT.join(%q{,})}}&quot;)]
    for f in srcs
      obj = File.basename(f, &quot;.*&quot;) &lt;&lt; &quot;.o&quot;
      $objs.push(obj) unless $objs.index(obj)
    end
  elsif !(srcs = $srcs)
    srcs = $objs.collect {|obj| obj.sub(/\.o\z/, '.c')}
  end
  $srcs = srcs
  for i in $objs
    i.sub!(/\.o\z/, &quot;.#{$OBJEXT}&quot;)
  end
  $objs = $objs.join(&quot; &quot;)

  target = nil if $objs == &quot;&quot;

  if target and EXPORT_PREFIX
    if File.exist?(File.join(srcdir, target + '.def'))
      deffile = &quot;$(srcdir)/$(TARGET).def&quot;
      unless EXPORT_PREFIX.empty?
        makedef = %{-pe &quot;sub!(/^(?=\\w)/,'#{EXPORT_PREFIX}') unless 1../^EXPORTS$/i&quot;}
      end
    else
      makedef = %{-e &quot;puts 'EXPORTS', '#{EXPORT_PREFIX}Init_$(TARGET)'&quot;}
    end
    if makedef
      $distcleanfiles &lt;&lt; '$(DEFFILE)'
      origdef = deffile
      deffile = &quot;$(TARGET)-$(arch).def&quot;
    end
  end
  origdef ||= ''

  libpath = libpathflag(libpath)

  dllib = target ? &quot;$(TARGET).#{CONFIG['DLEXT']}&quot; : &quot;&quot;
  staticlib = target ? &quot;$(TARGET).#$LIBEXT&quot; : &quot;&quot;
  mfile = open(&quot;Makefile&quot;, &quot;wb&quot;)
  mfile.print configuration(srcprefix)
  mfile.print &quot;
libpath = #{($DEFLIBPATH|$LIBPATH).join(&quot; &quot;)}
LIBPATH = #{libpath}
DEFFILE = #{deffile}

CLEANFILES = #{$cleanfiles.join(' ')}
DISTCLEANFILES = #{$distcleanfiles.join(' ')}

extout = #{$extout}
extout_prefix = #{$extout_prefix}
target_prefix = #{target_prefix}
LOCAL_LIBS = #{$LOCAL_LIBS}
LIBS = #{$LIBRUBYARG} #{$libs} #{$LIBS}
SRCS = #{srcs.collect(&amp;File.method(:basename)).join(' ')}
OBJS = #{$objs}
TARGET = #{target}
DLLIB = #{dllib}
EXTSTATIC = #{$static || &quot;&quot;}
STATIC_LIB = #{staticlib unless $static.nil?}
#{!$extout &amp;&amp; defined?($installed_list) ? &quot;INSTALLED_LIST = #{$installed_list}\n&quot; : &quot;&quot;}
&quot;
  install_dirs.each {|d| mfile.print(&quot;%-14s= %s\n&quot; % d) if /^[[:upper:]]/ =~ d[0]}
  n = ($extout ? '$(RUBYARCHDIR)/' : '') + '$(TARGET).'
  mfile.print &quot;
TARGET_SO     = #{($extout ? '$(RUBYARCHDIR)/' : '')}$(DLLIB)
CLEANLIBS     = #{n}#{CONFIG['DLEXT']} #{n}il? #{n}tds #{n}map
CLEANOBJS     = *.#{$OBJEXT} *.#{$LIBEXT} *.s[ol] *.pdb *.exp *.bak

all:		#{$extout ? &quot;install&quot; : target ? &quot;$(DLLIB)&quot; : &quot;Makefile&quot;}
static:		$(STATIC_LIB)#{$extout ? &quot; install-rb&quot; : &quot;&quot;}
&quot;
  mfile.print CLEANINGS
  dirs = []
  mfile.print &quot;install: install-so install-rb\n\n&quot;
  sodir = (dir = &quot;$(RUBYARCHDIR)&quot;).dup
  mfile.print(&quot;install-so: &quot;)
  if target
    f = &quot;$(DLLIB)&quot;
    dest = &quot;#{dir}/#{f}&quot;
    mfile.puts dir, &quot;install-so: #{dest}&quot;
    unless $extout
      mfile.print &quot;#{dest}: #{f}\n&quot;
      if (sep = config_string('BUILD_FILE_SEPARATOR'))
        f.gsub!(&quot;/&quot;, sep)
        dir.gsub!(&quot;/&quot;, sep)
        sep = &quot;:/=&quot;+sep
        f.gsub!(/(\$\(\w+)(\))/) {$1+sep+$2}
        f.gsub!(/(\$\{\w+)(\})/) {$1+sep+$2}
        dir.gsub!(/(\$\(\w+)(\))/) {$1+sep+$2}
        dir.gsub!(/(\$\{\w+)(\})/) {$1+sep+$2}
      end
      mfile.print &quot;\t$(INSTALL_PROG) #{f} #{dir}\n&quot;
      if defined?($installed_list)
	mfile.print &quot;\t@echo #{dir}/#{File.basename(f)}&gt;&gt;$(INSTALLED_LIST)\n&quot;
      end
    end
  else
    mfile.puts &quot;Makefile&quot;
  end
  mfile.print(&quot;install-rb: pre-install-rb install-rb-default\n&quot;)
  mfile.print(&quot;install-rb-default: pre-install-rb-default\n&quot;)
  mfile.print(&quot;pre-install-rb: Makefile\n&quot;)
  mfile.print(&quot;pre-install-rb-default: Makefile\n&quot;)
  for sfx, i in [[&quot;-default&quot;, [[&quot;lib/**/*.rb&quot;, &quot;$(RUBYLIBDIR)&quot;, &quot;lib&quot;]]], [&quot;&quot;, $INSTALLFILES]]
    files = install_files(mfile, i, nil, srcprefix) or next
    for dir, *files in files
      unless dirs.include?(dir)
	dirs &lt;&lt; dir
	mfile.print &quot;pre-install-rb#{sfx}: #{dir}\n&quot;
      end
      files.each do |f|
	dest = &quot;#{dir}/#{File.basename(f)}&quot;
	mfile.print(&quot;install-rb#{sfx}: #{dest}\n&quot;)
	mfile.print(&quot;#{dest}: #{f} #{dir}\n\t$(#{$extout ? 'COPY' : 'INSTALL_DATA'}) &quot;)
	sep = config_string('BUILD_FILE_SEPARATOR')
	if sep
	  f = f.gsub(&quot;/&quot;, sep)
	  sep = &quot;:/=&quot;+sep
	  f = f.gsub(/(\$\(\w+)(\))/) {$1+sep+$2}
	  f = f.gsub(/(\$\{\w+)(\})/) {$1+sep+$2}
	else
	  sep = &quot;&quot;
	end
	mfile.print(&quot;#{f} $(@D#{sep})\n&quot;)
	if defined?($installed_list) and !$extout
	  mfile.print(&quot;\t@echo #{dest}&gt;&gt;$(INSTALLED_LIST)\n&quot;)
	end
      end
    end
  end
  dirs.unshift(sodir) if target and !dirs.include?(sodir)
  dirs.each {|dir| mfile.print &quot;#{dir}:\n\t$(MAKEDIRS) $@\n&quot;}

  mfile.print &lt;&lt;-SITEINSTALL

site-install: site-install-so site-install-rb
site-install-so: install-so
site-install-rb: install-rb

  SITEINSTALL

  return unless target

  mfile.puts SRC_EXT.collect {|ext| &quot;.path.#{ext} = $(VPATH)&quot;} if $nmake == ?b
  mfile.print &quot;.SUFFIXES: .#{SRC_EXT.join(' .')} .#{$OBJEXT}\n&quot;
  mfile.print &quot;\n&quot;

  CXX_EXT.each do |ext|
    COMPILE_RULES.each do |rule|
      mfile.printf(rule, ext, $OBJEXT)
      mfile.printf(&quot;\n\t%s\n\n&quot;, COMPILE_CXX)
    end
  end
  %w[c].each do |ext|
    COMPILE_RULES.each do |rule|
      mfile.printf(rule, ext, $OBJEXT)
      mfile.printf(&quot;\n\t%s\n\n&quot;, COMPILE_C)
    end
  end

  mfile.print &quot;$(RUBYARCHDIR)/&quot; if $extout
  mfile.print &quot;$(DLLIB): &quot;, (makedef ? &quot;$(DEFFILE) &quot; : &quot;&quot;), &quot;$(OBJS)\n&quot;
  mfile.print &quot;\t@-$(RM) $@\n&quot;
  mfile.print &quot;\t@-$(MAKEDIRS) $(@D)\n&quot; if $extout
  link_so = LINK_SO.gsub(/^/, &quot;\t&quot;)
  mfile.print link_so, &quot;\n\n&quot;
  unless $static.nil?
    mfile.print &quot;$(STATIC_LIB): $(OBJS)\n\t&quot;
    mfile.print &quot;$(AR) #{config_string('ARFLAGS') || 'cru '}$@ $(OBJS)&quot;
    config_string('RANLIB') do |ranlib|
      mfile.print &quot;\n\t@-#{ranlib} $(DLLIB) 2&gt; /dev/null || true&quot;
    end
  end
  mfile.print &quot;\n\n&quot;
  if makedef
    mfile.print &quot;$(DEFFILE): #{origdef}\n&quot;
    mfile.print &quot;\t$(RUBY) #{makedef} #{origdef} &gt; $@\n\n&quot;
  end

  depend = File.join(srcdir, &quot;depend&quot;)
  if File.exist?(depend)
    suffixes = []
    depout = []
    open(depend, &quot;r&quot;) do |dfile|
      mfile.printf &quot;###\n&quot;
      cont = implicit = nil
      impconv = proc do
	COMPILE_RULES.each {|rule| depout &lt;&lt; (rule % implicit[0]) &lt;&lt; implicit[1]}
	implicit = nil
      end
      ruleconv = proc do |line|
	if implicit
	  if /\A\t/ =~ line
	    implicit[1] &lt;&lt; line
	    next
	  else
	    impconv[]
	  end
	end
	if m = /\A\.(\w+)\.(\w+)(?:\s*:)/.match(line)
	  suffixes &lt;&lt; m[1] &lt;&lt; m[2]
	  implicit = [[m[1], m[2]], [m.post_match]]
	  next
	elsif RULE_SUBST and /\A(?!\s*\w+\s*=)[$\w][^#]*:/ =~ line
	  line.gsub!(%r&quot;(\s)(?!\.)([^$(){}+=:\s\/\\,]+)(?=\s|\z)&quot;) {$1 + RULE_SUBST % $2}
	end
	depout &lt;&lt; line
      end
      while line = dfile.gets()
	line.gsub!(/\.o\b/, &quot;.#{$OBJEXT}&quot;)
	line.gsub!(/\$\((?:hdr|top)dir\)\/config.h/, $config_h) if $config_h
	if /(?:^|[^\\])(?:\\\\)*\\$/ =~ line
	  (cont ||= []) &lt;&lt; line
	  next
	elsif cont
	  line = (cont &lt;&lt; line).join
	  cont = nil
	end
	ruleconv.call(line)
      end
      if cont
	ruleconv.call(cont.join)
      elsif implicit
	impconv.call
      end
    end
    unless suffixes.empty?
      mfile.print &quot;.SUFFIXES: .&quot;, suffixes.uniq.join(&quot; .&quot;), &quot;\n\n&quot;
    end
    mfile.print &quot;$(OBJS): $(RUBY_EXTCONF_H)\n\n&quot; if $extconf_h
    mfile.print depout
  else
    headers = %w[ruby.h defines.h]
    if RULE_SUBST
      headers.each {|h| h.sub!(/.*/) {|*m| RULE_SUBST % m}}
    end
    headers &lt;&lt; $config_h if $config_h
    headers &lt;&lt; &quot;$(RUBY_EXTCONF_H)&quot; if $extconf_h
    mfile.print &quot;$(OBJS): &quot;, headers.join(' '), &quot;\n&quot;
  end

  $makefile_created = true
ensure
  mfile.close if mfile
end

# :stopdoc:

def init_mkmf(config = CONFIG)
  $makefile_created = false
  $arg_config = []
  $enable_shared = config['ENABLE_SHARED'] == 'yes'
  $defs = []
  $extconf_h = nil
  $CFLAGS = with_config(&quot;cflags&quot;, arg_config(&quot;CFLAGS&quot;, config[&quot;CFLAGS&quot;])).dup
  $ARCH_FLAG = with_config(&quot;arch_flag&quot;, arg_config(&quot;ARCH_FLAG&quot;, config[&quot;ARCH_FLAG&quot;])).dup
  $CPPFLAGS = with_config(&quot;cppflags&quot;, arg_config(&quot;CPPFLAGS&quot;, config[&quot;CPPFLAGS&quot;])).dup
  $LDFLAGS = with_config(&quot;ldflags&quot;, arg_config(&quot;LDFLAGS&quot;, config[&quot;LDFLAGS&quot;])).dup
  $INCFLAGS = &quot;-I$(topdir) -I$(hdrdir) -I$(srcdir)&quot;
  $DLDFLAGS = with_config(&quot;dldflags&quot;, arg_config(&quot;DLDFLAGS&quot;, config[&quot;DLDFLAGS&quot;])).dup
  $LIBEXT = config['LIBEXT'].dup
  $OBJEXT = config[&quot;OBJEXT&quot;].dup
  $LIBS = &quot;#{config['LIBS']} #{config['DLDLIBS']}&quot;
  $LIBRUBYARG = &quot;&quot;
  $LIBRUBYARG_STATIC = config['LIBRUBYARG_STATIC']
  $LIBRUBYARG_SHARED = config['LIBRUBYARG_SHARED']
  $DEFLIBPATH = $extmk ? [&quot;$(topdir)&quot;] : CROSS_COMPILING ? [] : [&quot;$(libdir)&quot;]
  $DEFLIBPATH.unshift(&quot;.&quot;)
  $LIBPATH = []
  $INSTALLFILES = []
  $NONINSTALLFILES = [/~\z/, /\A#.*#\z/, /\A\.#/, /\.bak\z/i, /\.orig\z/, /\.rej\z/, /\.l[ao]\z/, /\.o\z/]

  $objs = nil
  $srcs = nil
  $libs = &quot;&quot;
  if $enable_shared or Config.expand(config[&quot;LIBRUBY&quot;].dup) != Config.expand(config[&quot;LIBRUBY_A&quot;].dup)
    $LIBRUBYARG = config['LIBRUBYARG']
  end

  $LOCAL_LIBS = &quot;&quot;

  $cleanfiles = config_string('CLEANFILES') {|s| Shellwords.shellwords(s)} || []
  $cleanfiles &lt;&lt; &quot;mkmf.log&quot;
  $distcleanfiles = config_string('DISTCLEANFILES') {|s| Shellwords.shellwords(s)} || []

  $extout ||= nil
  $extout_prefix ||= nil

  $arg_config.clear
  dir_config(&quot;opt&quot;)
end

FailedMessage = &lt;&lt;MESSAGE
Could not create Makefile due to some reason, probably lack of
necessary libraries and/or headers.  Check the mkmf.log file for more
details.  You may need configuration options.

Provided configuration options:
MESSAGE

# Returns whether or not the Makefile was successfully generated. If not,
# the script will abort with an error message.
#
# Internal use only.
#
def mkmf_failed(path)
  unless $makefile_created or File.exist?(&quot;Makefile&quot;)
    opts = $arg_config.collect {|t, n| &quot;\t#{t}#{n ? &quot;=#{n}&quot; : &quot;&quot;}\n&quot;}
    abort &quot;*** #{path} failed ***\n&quot; + FailedMessage + opts.join
  end
end

# :startdoc:

init_mkmf

$make = with_config(&quot;make-prog&quot;, ENV[&quot;MAKE&quot;] || &quot;make&quot;)
make, = Shellwords.shellwords($make)
$nmake = nil
case
when $mswin
  $nmake = ?m if /nmake/i =~ make
when $bccwin
  $nmake = ?b if /Borland/i =~ `#{make} -h`
end

Config::CONFIG[&quot;srcdir&quot;] = CONFIG[&quot;srcdir&quot;] =
  $srcdir = arg_config(&quot;--srcdir&quot;, File.dirname($0))
$configure_args[&quot;--topsrcdir&quot;] ||= $srcdir
if $curdir = arg_config(&quot;--curdir&quot;)
  Config.expand(curdir = $curdir.dup)
else
  curdir = $curdir = &quot;.&quot;
end
unless File.expand_path(Config::CONFIG[&quot;topdir&quot;]) == File.expand_path(curdir)
  CONFIG[&quot;topdir&quot;] = $curdir
  Config::CONFIG[&quot;topdir&quot;] = curdir
end
$configure_args[&quot;--topdir&quot;] ||= $curdir
$ruby = arg_config(&quot;--ruby&quot;, File.join(Config::CONFIG[&quot;bindir&quot;], CONFIG[&quot;ruby_install_name&quot;]))

split = Shellwords.method(:shellwords).to_proc

EXPORT_PREFIX = config_string('EXPORT_PREFIX') {|s| s.strip}

hdr = []
config_string('COMMON_MACROS') do |s|
  Shellwords.shellwords(s).each do |w|
    hdr &lt;&lt; &quot;#define &quot; + w.split(/=/, 2).join(&quot; &quot;)
  end
end
config_string('COMMON_HEADERS') do |s|
  Shellwords.shellwords(s).each {|s| hdr &lt;&lt; &quot;#include &lt;#{s}&gt;&quot;}
end
COMMON_HEADERS = hdr.join(&quot;\n&quot;)
COMMON_LIBS = config_string('COMMON_LIBS', &amp;split) || []

COMPILE_RULES = config_string('COMPILE_RULES', &amp;split) || %w[.%s.%s:]
RULE_SUBST = config_string('RULE_SUBST')
COMPILE_C = config_string('COMPILE_C') || '$(CC) $(INCFLAGS) $(CPPFLAGS) $(CFLAGS) -c $&lt;'
COMPILE_CXX = config_string('COMPILE_CXX') || '$(CXX) $(INCFLAGS) $(CPPFLAGS) $(CXXFLAGS) -c $&lt;'
TRY_LINK = config_string('TRY_LINK') ||
  &quot;$(CC) #{OUTFLAG}conftest $(INCFLAGS) $(CPPFLAGS) &quot; \
  &quot;$(CFLAGS) $(src) $(LIBPATH) $(LDFLAGS) $(ARCH_FLAG) $(LOCAL_LIBS) $(LIBS)&quot;
LINK_SO = config_string('LINK_SO') ||
  if CONFIG[&quot;DLEXT&quot;] == $OBJEXT
    &quot;ld $(DLDFLAGS) -r -o $@ $(OBJS)\n&quot;
  else
    &quot;$(LDSHARED) #{OUTFLAG}$@ $(OBJS) &quot; \
    &quot;$(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)&quot;
  end
LIBPATHFLAG = config_string('LIBPATHFLAG') || ' -L&quot;%s&quot;'
RPATHFLAG = config_string('RPATHFLAG') || ''
LIBARG = config_string('LIBARG') || '-l%s'

sep = config_string('BUILD_FILE_SEPARATOR') {|sep| &quot;:/=#{sep}&quot; if sep != &quot;/&quot;} || &quot;&quot;
CLEANINGS = &quot;
clean:
		@-$(RM) $(CLEANLIBS#{sep}) $(CLEANOBJS#{sep}) $(CLEANFILES#{sep})

distclean:	clean
		@-$(RM) Makefile $(RUBY_EXTCONF_H) conftest.* mkmf.log
		@-$(RM) core ruby$(EXEEXT) *~ $(DISTCLEANFILES#{sep})

realclean:	distclean
&quot;

if not $extmk and /\A(extconf|makefile).rb\z/ =~ File.basename($0)
  END {mkmf_failed($0)}
end
</pre>
    </div>