  <div id="fileHeader">
    <h1>time.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/time.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 03:05:24 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>
#
# == Introduction
# 
# This library extends the Time class:
# * conversion between date string and time object.
#   * date-time defined by RFC 2822
#   * HTTP-date defined by RFC 2616
#   * dateTime defined by XML Schema Part 2: Datatypes (ISO 8601)
#   * various formats handled by Date._parse (string to time only)
# 
# == Design Issues
# 
# === Specialized interface
# 
# This library provides methods dedicated to special purposes:
# * RFC 2822, RFC 2616 and XML Schema.
# * They makes usual life easier.
# 
# === Doesn't depend on strftime
# 
# This library doesn't use +strftime+.  Especially #rfc2822 doesn't depend
# on +strftime+ because:
# 
# * %a and %b are locale sensitive
# 
#   Since they are locale sensitive, they may be replaced to
#   invalid weekday/month name in some locales.
#   Since ruby-1.6 doesn't invoke setlocale by default,
#   the problem doesn't arise until some external library invokes setlocale.
#   Ruby/GTK is the example of such library.
# 
# * %z is not portable
# 
#   %z is required to generate zone in date-time of RFC 2822
#   but it is not portable.
#
# == Revision Information
#
# $Id$
#

require 'parsedate'

#
# Implements the extensions to the Time class that are described in the
# documentation for the time.rb library.
#
class Time
  class &lt;&lt; Time

    ZoneOffset = {
      'UTC' =&gt; 0,
      # ISO 8601
      'Z' =&gt; 0,
      # RFC 822
      'UT' =&gt; 0, 'GMT' =&gt; 0,
      'EST' =&gt; -5, 'EDT' =&gt; -4,
      'CST' =&gt; -6, 'CDT' =&gt; -5,
      'MST' =&gt; -7, 'MDT' =&gt; -6,
      'PST' =&gt; -8, 'PDT' =&gt; -7,
      # Following definition of military zones is original one.
      # See RFC 1123 and RFC 2822 for the error in RFC 822.
      'A' =&gt; +1, 'B' =&gt; +2, 'C' =&gt; +3, 'D' =&gt; +4,  'E' =&gt; +5,  'F' =&gt; +6, 
      'G' =&gt; +7, 'H' =&gt; +8, 'I' =&gt; +9, 'K' =&gt; +10, 'L' =&gt; +11, 'M' =&gt; +12,
      'N' =&gt; -1, 'O' =&gt; -2, 'P' =&gt; -3, 'Q' =&gt; -4,  'R' =&gt; -5,  'S' =&gt; -6, 
      'T' =&gt; -7, 'U' =&gt; -8, 'V' =&gt; -9, 'W' =&gt; -10, 'X' =&gt; -11, 'Y' =&gt; -12,
    }
    def zone_offset(zone, year=self.now.year)
      off = nil
      zone = zone.upcase
      if /\A([+-])(\d\d):?(\d\d)\z/ =~ zone
        off = ($1 == '-' ? -1 : 1) * ($2.to_i * 60 + $3.to_i) * 60
      elsif /\A[+-]\d\d\z/ =~ zone
        off = zone.to_i * 3600
      elsif ZoneOffset.include?(zone)
        off = ZoneOffset[zone] * 3600
      elsif ((t = self.local(year, 1, 1)).zone.upcase == zone rescue false)
        off = t.utc_offset
      elsif ((t = self.local(year, 7, 1)).zone.upcase == zone rescue false)
        off = t.utc_offset
      end
      off
    end

    def zone_utc?(zone)
      # * +0000 means localtime. [RFC 2822]
      # * GMT is a localtime abbreviation in Europe/London, etc.
      if /\A(?:-00:00|-0000|-00|UTC|Z|UT)\z/i =~ zone
        true
      else
        false
      end
    end
    private :zone_utc?

    LeapYearMonthDays = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    CommonYearMonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    def month_days(y, m)
      if ((y % 4 == 0) &amp;&amp; (y % 100 != 0)) || (y % 400 == 0)
        LeapYearMonthDays[m-1]
      else
        CommonYearMonthDays[m-1]
      end
    end
    private :month_days

    def apply_offset(year, mon, day, hour, min, sec, off)
      if off &lt; 0
        off = -off
        off, o = off.divmod(60)
        if o != 0 then sec += o; o, sec = sec.divmod(60); off += o end
        off, o = off.divmod(60)
        if o != 0 then min += o; o, min = min.divmod(60); off += o end
        off, o = off.divmod(24)
        if o != 0 then hour += o; o, hour = hour.divmod(24); off += o end
        if off != 0
          day += off
          if month_days(year, mon) &lt; day
            mon += 1
            if 12 &lt; mon
              mon = 1
              year += 1
            end
            day = 1
          end
        end
      elsif 0 &lt; off
        off, o = off.divmod(60)
        if o != 0 then sec -= o; o, sec = sec.divmod(60); off -= o end
        off, o = off.divmod(60)
        if o != 0 then min -= o; o, min = min.divmod(60); off -= o end
        off, o = off.divmod(24)
        if o != 0 then hour -= o; o, hour = hour.divmod(24); off -= o end
        if off != 0 then
          day -= off
          if day &lt; 1
            mon -= 1
            if mon &lt; 1
              year -= 1
              mon = 12
            end
            day = month_days(year, mon)
          end
        end
      end
      return year, mon, day, hour, min, sec
    end
    private :apply_offset

    def make_time(year, mon, day, hour, min, sec, sec_fraction, zone, now)
      usec = nil
      usec = (sec_fraction * 1000000).to_i if sec_fraction
      if now
        begin
          break if year; year = now.year
          break if mon; mon = now.mon
          break if day; day = now.day
          break if hour; hour = now.hour
          break if min; min = now.min
          break if sec; sec = now.sec
          break if sec_fraction; usec = now.tv_usec
        end until true
      end

      year ||= 1970
      mon ||= 1
      day ||= 1
      hour ||= 0
      min ||= 0
      sec ||= 0
      usec ||= 0

      off = nil
      off = zone_offset(zone, year) if zone

      if off
        year, mon, day, hour, min, sec =
          apply_offset(year, mon, day, hour, min, sec, off)
        t = self.utc(year, mon, day, hour, min, sec, usec)
        t.localtime if !zone_utc?(zone)
        t
      else
        self.local(year, mon, day, hour, min, sec, usec)
      end
    end
    private :make_time

    #
    # Parses +date+ using Date._parse and converts it to a Time object.
    #
    # If a block is given, the year described in +date+ is converted by the
    # block.  For example:
    #
    #     Time.parse(...) {|y| y &lt; 100 ? (y &gt;= 69 ? y + 1900 : y + 2000) : y}
    #
    # If the upper components of the given time are broken or missing, they are
    # supplied with those of +now+.  For the lower components, the minimum
    # values (1 or 0) are assumed if broken or missing.  For example:
    #
    #     # Suppose it is &quot;Thu Nov 29 14:33:20 GMT 2001&quot; now and
    #     # your timezone is GMT:
    #     Time.parse(&quot;16:30&quot;)     #=&gt; Thu Nov 29 16:30:00 GMT 2001
    #     Time.parse(&quot;7/23&quot;)      #=&gt; Mon Jul 23 00:00:00 GMT 2001
    #     Time.parse(&quot;Aug 31&quot;)    #=&gt; Fri Aug 31 00:00:00 GMT 2001
    #
    # Since there are numerous conflicts among locally defined timezone
    # abbreviations all over the world, this method is not made to
    # understand all of them.  For example, the abbreviation &quot;CST&quot; is
    # used variously as:
    #
    #     -06:00 in America/Chicago,
    #     -05:00 in America/Havana,
    #     +08:00 in Asia/Harbin,
    #     +09:30 in Australia/Darwin,
    #     +10:30 in Australia/Adelaide,
    #     etc.
    #
    # Based on the fact, this method only understands the timezone
    # abbreviations described in RFC 822 and the system timezone, in the
    # order named. (i.e. a definition in RFC 822 overrides the system
    # timezone definition.)  The system timezone is taken from
    # &lt;tt&gt;Time.local(year, 1, 1).zone&lt;/tt&gt; and
    # &lt;tt&gt;Time.local(year, 7, 1).zone&lt;/tt&gt;.
    # If the extracted timezone abbreviation does not match any of them,
    # it is ignored and the given time is regarded as a local time.
    #
    # ArgumentError is raised if Date._parse cannot extract information from
    # +date+ or Time class cannot represent specified date.
    #
    # This method can be used as fail-safe for other parsing methods as:
    #
    #   Time.rfc2822(date) rescue Time.parse(date)
    #   Time.httpdate(date) rescue Time.parse(date)
    #   Time.xmlschema(date) rescue Time.parse(date)
    #
    # A failure for Time.parse should be checked, though.
    #
    def parse(date, now=self.now)
      d = Date._parse(date, false)
      year = d[:year]
      year = yield(year) if year &amp;&amp; block_given?
      make_time(year, d[:mon], d[:mday], d[:hour], d[:min], d[:sec], d[:sec_fraction], d[:zone], now)
    end

    MonthValue = {
      'JAN' =&gt; 1, 'FEB' =&gt; 2, 'MAR' =&gt; 3, 'APR' =&gt; 4, 'MAY' =&gt; 5, 'JUN' =&gt; 6,
      'JUL' =&gt; 7, 'AUG' =&gt; 8, 'SEP' =&gt; 9, 'OCT' =&gt;10, 'NOV' =&gt;11, 'DEC' =&gt;12
    }

    #
    # Parses +date+ as date-time defined by RFC 2822 and converts it to a Time
    # object.  The format is identical to the date format defined by RFC 822 and
    # updated by RFC 1123.
    #
    # ArgumentError is raised if +date+ is not compliant with RFC 2822
    # or Time class cannot represent specified date.
    #
    # See #rfc2822 for more information on this format.
    #
    def rfc2822(date)
      if /\A\s*
          (?:(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s*,\s*)?
          (\d{1,2})\s+
          (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+
          (\d{2,})\s+
          (\d{2})\s*
          :\s*(\d{2})\s*
          (?::\s*(\d{2}))?\s+
          ([+-]\d{4}|
           UT|GMT|EST|EDT|CST|CDT|MST|MDT|PST|PDT|[A-IK-Z])/ix =~ date
        # Since RFC 2822 permit comments, the regexp has no right anchor.
        day = $1.to_i
        mon = MonthValue[$2.upcase]
        year = $3.to_i
        hour = $4.to_i
        min = $5.to_i
        sec = $6 ? $6.to_i : 0
        zone = $7

        # following year completion is compliant with RFC 2822.
        year = if year &lt; 50
                 2000 + year
               elsif year &lt; 1000
                 1900 + year
               else
                 year
               end

        year, mon, day, hour, min, sec =
          apply_offset(year, mon, day, hour, min, sec, zone_offset(zone))
        t = self.utc(year, mon, day, hour, min, sec)
        t.localtime if !zone_utc?(zone)
        t
      else
        raise ArgumentError.new(&quot;not RFC 2822 compliant date: #{date.inspect}&quot;)
      end
    end
    alias rfc822 rfc2822

    #
    # Parses +date+ as HTTP-date defined by RFC 2616 and converts it to a Time
    # object.
    #
    # ArgumentError is raised if +date+ is not compliant with RFC 2616 or Time
    # class cannot represent specified date.
    #
    # See #httpdate for more information on this format.
    #
    def httpdate(date)
      if /\A\s*
          (?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),\x20
          (\d{2})\x20
          (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\x20
          (\d{4})\x20
          (\d{2}):(\d{2}):(\d{2})\x20
          GMT
          \s*\z/ix =~ date
        self.rfc2822(date)
      elsif /\A\s*
             (?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday),\x20
             (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d)\x20
             (\d\d):(\d\d):(\d\d)\x20
             GMT
             \s*\z/ix =~ date
        self.parse(date)
      elsif /\A\s*
             (?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\x20
             (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\x20
             (\d\d|\x20\d)\x20
             (\d\d):(\d\d):(\d\d)\x20
             (\d{4})
             \s*\z/ix =~ date
        self.utc($6.to_i, MonthValue[$1.upcase], $2.to_i,
                 $3.to_i, $4.to_i, $5.to_i)
      else
        raise ArgumentError.new(&quot;not RFC 2616 compliant date: #{date.inspect}&quot;)
      end
    end

    #
    # Parses +date+ as dateTime defined by XML Schema and converts it to a Time
    # object.  The format is restricted version of the format defined by ISO
    # 8601.
    #
    # ArgumentError is raised if +date+ is not compliant with the format or Time
    # class cannot represent specified date.
    #
    # See #xmlschema for more information on this format.
    #
    def xmlschema(date)
      if /\A\s*
          (-?\d+)-(\d\d)-(\d\d)
          T
          (\d\d):(\d\d):(\d\d)
          (\.\d*)?
          (Z|[+-]\d\d:\d\d)?
          \s*\z/ix =~ date
        year = $1.to_i
        mon = $2.to_i
        day = $3.to_i
        hour = $4.to_i
        min = $5.to_i
        sec = $6.to_i
        usec = 0
        usec = ($7[1..-1] + '000000')[0,6].to_i if $7
        if $8
          zone = $8
          year, mon, day, hour, min, sec =
            apply_offset(year, mon, day, hour, min, sec, zone_offset(zone))
          self.utc(year, mon, day, hour, min, sec, usec)
        else
          self.local(year, mon, day, hour, min, sec, usec)
        end
      else
        raise ArgumentError.new(&quot;invalid date: #{date.inspect}&quot;)
      end
    end
    alias iso8601 xmlschema
  end # class &lt;&lt; self

  #
  # Returns a string which represents the time as date-time defined by RFC 2822:
  #
  #   day-of-week, DD month-name CCYY hh:mm:ss zone
  #
  # where zone is [+-]hhmm.
  #
  # If +self+ is a UTC time, -0000 is used as zone.
  #
  def rfc2822
    sprintf('%s, %02d %s %d %02d:%02d:%02d ',
      RFC2822_DAY_NAME[wday],
      day, RFC2822_MONTH_NAME[mon-1], year,
      hour, min, sec) +
    if utc?
      '-0000'
    else
      off = utc_offset
      sign = off &lt; 0 ? '-' : '+'
      sprintf('%s%02d%02d', sign, *(off.abs / 60).divmod(60))
    end
  end
  alias rfc822 rfc2822

  RFC2822_DAY_NAME = [
    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
  ]
  RFC2822_MONTH_NAME = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
  ]

  #
  # Returns a string which represents the time as rfc1123-date of HTTP-date
  # defined by RFC 2616: 
  # 
  #   day-of-week, DD month-name CCYY hh:mm:ss GMT
  #
  # Note that the result is always UTC (GMT).
  #
  def httpdate
    t = dup.utc
    sprintf('%s, %02d %s %d %02d:%02d:%02d GMT',
      RFC2822_DAY_NAME[t.wday],
      t.day, RFC2822_MONTH_NAME[t.mon-1], t.year,
      t.hour, t.min, t.sec)
  end

  #
  # Returns a string which represents the time as dateTime defined by XML
  # Schema:
  #
  #   CCYY-MM-DDThh:mm:ssTZD
  #   CCYY-MM-DDThh:mm:ss.sssTZD
  #
  # where TZD is Z or [+-]hh:mm.
  #
  # If self is a UTC time, Z is used as TZD.  [+-]hh:mm is used otherwise.
  #
  # +fractional_seconds+ specifies a number of digits of fractional seconds.
  # Its default value is 0.
  #
  def xmlschema(fraction_digits=0)
    sprintf('%d-%02d-%02dT%02d:%02d:%02d',
      year, mon, day, hour, min, sec) +
    if fraction_digits == 0
      ''
    elsif fraction_digits &lt;= 6
      '.' + sprintf('%06d', usec)[0, fraction_digits]
    else
      '.' + sprintf('%06d', usec) + '0' * (fraction_digits - 6)
    end +
    if utc?
      'Z'
    else
      off = utc_offset
      sign = off &lt; 0 ? '-' : '+'
      sprintf('%s%02d:%02d', sign, *(off.abs / 60).divmod(60))
    end
  end
  alias iso8601 xmlschema
end

if __FILE__ == $0
  require 'test/unit'

  class TimeExtentionTest &lt; Test::Unit::TestCase # :nodoc:
    def test_rfc822
      assert_equal(Time.utc(1976, 8, 26, 14, 30) + 4 * 3600,
                   Time.rfc2822(&quot;26 Aug 76 14:30 EDT&quot;))
      assert_equal(Time.utc(1976, 8, 27, 9, 32) + 7 * 3600,
                   Time.rfc2822(&quot;27 Aug 76 09:32 PDT&quot;))
    end

    def test_rfc2822
      assert_equal(Time.utc(1997, 11, 21, 9, 55, 6) + 6 * 3600,
                   Time.rfc2822(&quot;Fri, 21 Nov 1997 09:55:06 -0600&quot;))
      assert_equal(Time.utc(2003, 7, 1, 10, 52, 37) - 2 * 3600,
                   Time.rfc2822(&quot;Tue, 1 Jul 2003 10:52:37 +0200&quot;))
      assert_equal(Time.utc(1997, 11, 21, 10, 1, 10) + 6 * 3600,
                   Time.rfc2822(&quot;Fri, 21 Nov 1997 10:01:10 -0600&quot;))
      assert_equal(Time.utc(1997, 11, 21, 11, 0, 0) + 6 * 3600,
                   Time.rfc2822(&quot;Fri, 21 Nov 1997 11:00:00 -0600&quot;))
      assert_equal(Time.utc(1997, 11, 24, 14, 22, 1) + 8 * 3600,
                   Time.rfc2822(&quot;Mon, 24 Nov 1997 14:22:01 -0800&quot;))
      begin
        Time.at(-1)
      rescue ArgumentError
        # ignore
      else
        assert_equal(Time.utc(1969, 2, 13, 23, 32, 54) + 3 * 3600 + 30 * 60,
                     Time.rfc2822(&quot;Thu, 13 Feb 1969 23:32:54 -0330&quot;))
        assert_equal(Time.utc(1969, 2, 13, 23, 32, 0) + 3 * 3600 + 30 * 60,
                     Time.rfc2822(&quot; Thu,
        13
          Feb
            1969
        23:32
                 -0330 (Newfoundland Time)&quot;))
      end
      assert_equal(Time.utc(1997, 11, 21, 9, 55, 6),
                   Time.rfc2822(&quot;21 Nov 97 09:55:06 GMT&quot;))
      assert_equal(Time.utc(1997, 11, 21, 9, 55, 6) + 6 * 3600,
                   Time.rfc2822(&quot;Fri, 21 Nov 1997 09 :   55  :  06 -0600&quot;))
      assert_raise(ArgumentError) {
        # inner comment is not supported.
        Time.rfc2822(&quot;Fri, 21 Nov 1997 09(comment):   55  :  06 -0600&quot;)
      }
    end

    def test_rfc2616
      t = Time.utc(1994, 11, 6, 8, 49, 37)
      assert_equal(t, Time.httpdate(&quot;Sun, 06 Nov 1994 08:49:37 GMT&quot;))
      assert_equal(t, Time.httpdate(&quot;Sunday, 06-Nov-94 08:49:37 GMT&quot;))
      assert_equal(t, Time.httpdate(&quot;Sun Nov  6 08:49:37 1994&quot;))
      assert_equal(Time.utc(1995, 11, 15, 6, 25, 24),
                   Time.httpdate(&quot;Wed, 15 Nov 1995 06:25:24 GMT&quot;))
      assert_equal(Time.utc(1995, 11, 15, 4, 58, 8),
                   Time.httpdate(&quot;Wed, 15 Nov 1995 04:58:08 GMT&quot;))
      assert_equal(Time.utc(1994, 11, 15, 8, 12, 31),
                   Time.httpdate(&quot;Tue, 15 Nov 1994 08:12:31 GMT&quot;))
      assert_equal(Time.utc(1994, 12, 1, 16, 0, 0),
                   Time.httpdate(&quot;Thu, 01 Dec 1994 16:00:00 GMT&quot;))
      assert_equal(Time.utc(1994, 10, 29, 19, 43, 31),
                   Time.httpdate(&quot;Sat, 29 Oct 1994 19:43:31 GMT&quot;))
      assert_equal(Time.utc(1994, 11, 15, 12, 45, 26),
                   Time.httpdate(&quot;Tue, 15 Nov 1994 12:45:26 GMT&quot;))
      assert_equal(Time.utc(1999, 12, 31, 23, 59, 59),
                   Time.httpdate(&quot;Fri, 31 Dec 1999 23:59:59 GMT&quot;))
    end

    def test_rfc3339
      t = Time.utc(1985, 4, 12, 23, 20, 50, 520000)
      s = &quot;1985-04-12T23:20:50.52Z&quot;
      assert_equal(t, Time.iso8601(s))
      assert_equal(s, t.iso8601(2))

      t = Time.utc(1996, 12, 20, 0, 39, 57)
      s = &quot;1996-12-19T16:39:57-08:00&quot;
      assert_equal(t, Time.iso8601(s))
      # There is no way to generate time string with arbitrary timezone.
      s = &quot;1996-12-20T00:39:57Z&quot;
      assert_equal(t, Time.iso8601(s))
      assert_equal(s, t.iso8601)

      t = Time.utc(1990, 12, 31, 23, 59, 60)
      s = &quot;1990-12-31T23:59:60Z&quot;
      assert_equal(t, Time.iso8601(s))
      # leap second is representable only if timezone file has it.
      s = &quot;1990-12-31T15:59:60-08:00&quot;
      assert_equal(t, Time.iso8601(s))

      begin
        Time.at(-1)
      rescue ArgumentError
        # ignore
      else
        t = Time.utc(1937, 1, 1, 11, 40, 27, 870000)
        s = &quot;1937-01-01T12:00:27.87+00:20&quot;
        assert_equal(t, Time.iso8601(s))
      end
    end

    # http://www.w3.org/TR/xmlschema-2/
    def test_xmlschema
      assert_equal(Time.utc(1999, 5, 31, 13, 20, 0) + 5 * 3600,
                   Time.xmlschema(&quot;1999-05-31T13:20:00-05:00&quot;))
      assert_equal(Time.local(2000, 1, 20, 12, 0, 0),
                   Time.xmlschema(&quot;2000-01-20T12:00:00&quot;))
      assert_equal(Time.utc(2000, 1, 20, 12, 0, 0),
                   Time.xmlschema(&quot;2000-01-20T12:00:00Z&quot;))
      assert_equal(Time.utc(2000, 1, 20, 12, 0, 0) - 12 * 3600,
                   Time.xmlschema(&quot;2000-01-20T12:00:00+12:00&quot;))
      assert_equal(Time.utc(2000, 1, 20, 12, 0, 0) + 13 * 3600,
                   Time.xmlschema(&quot;2000-01-20T12:00:00-13:00&quot;))
      assert_equal(Time.utc(2000, 3, 4, 23, 0, 0) - 3 * 3600,
                   Time.xmlschema(&quot;2000-03-04T23:00:00+03:00&quot;))
      assert_equal(Time.utc(2000, 3, 4, 20, 0, 0),
                   Time.xmlschema(&quot;2000-03-04T20:00:00Z&quot;))
      assert_equal(Time.local(2000, 1, 15, 0, 0, 0),
                   Time.xmlschema(&quot;2000-01-15T00:00:00&quot;))
      assert_equal(Time.local(2000, 2, 15, 0, 0, 0),
                   Time.xmlschema(&quot;2000-02-15T00:00:00&quot;))
      assert_equal(Time.local(2000, 1, 15, 12, 0, 0),
                   Time.xmlschema(&quot;2000-01-15T12:00:00&quot;))
      assert_equal(Time.utc(2000, 1, 16, 12, 0, 0),
                   Time.xmlschema(&quot;2000-01-16T12:00:00Z&quot;))
      assert_equal(Time.local(2000, 1, 1, 12, 0, 0),
                   Time.xmlschema(&quot;2000-01-01T12:00:00&quot;))
      assert_equal(Time.utc(1999, 12, 31, 23, 0, 0),
                   Time.xmlschema(&quot;1999-12-31T23:00:00Z&quot;))
      assert_equal(Time.local(2000, 1, 16, 12, 0, 0),
                   Time.xmlschema(&quot;2000-01-16T12:00:00&quot;))
      assert_equal(Time.local(2000, 1, 16, 0, 0, 0),
                   Time.xmlschema(&quot;2000-01-16T00:00:00&quot;))
      assert_equal(Time.utc(2000, 1, 12, 12, 13, 14),
                   Time.xmlschema(&quot;2000-01-12T12:13:14Z&quot;))
      assert_equal(Time.utc(2001, 4, 17, 19, 23, 17, 300000),
                   Time.xmlschema(&quot;2001-04-17T19:23:17.3Z&quot;))
    end

    def test_encode_xmlschema
      t = Time.utc(2001, 4, 17, 19, 23, 17, 300000)
      assert_equal(&quot;2001-04-17T19:23:17Z&quot;, t.xmlschema)
      assert_equal(&quot;2001-04-17T19:23:17.3Z&quot;, t.xmlschema(1))
      assert_equal(&quot;2001-04-17T19:23:17.300000Z&quot;, t.xmlschema(6))
      assert_equal(&quot;2001-04-17T19:23:17.3000000Z&quot;, t.xmlschema(7))

      t = Time.utc(2001, 4, 17, 19, 23, 17, 123456)
      assert_equal(&quot;2001-04-17T19:23:17.1234560Z&quot;, t.xmlschema(7))
      assert_equal(&quot;2001-04-17T19:23:17.123456Z&quot;, t.xmlschema(6))
      assert_equal(&quot;2001-04-17T19:23:17.12345Z&quot;, t.xmlschema(5))
      assert_equal(&quot;2001-04-17T19:23:17.1Z&quot;, t.xmlschema(1))

      begin
        Time.at(-1)
      rescue ArgumentError
        # ignore
      else
        t = Time.utc(1960, 12, 31, 23, 0, 0, 123456)
        assert_equal(&quot;1960-12-31T23:00:00.123456Z&quot;, t.xmlschema(6))
      end

      assert_equal(249, Time.xmlschema(&quot;2008-06-05T23:49:23.000249+09:00&quot;).usec)
    end

    def test_completion
      now = Time.local(2001,11,29,21,26,35)
      assert_equal(Time.local( 2001,11,29,21,12),
                   Time.parse(&quot;2001/11/29 21:12&quot;, now))
      assert_equal(Time.local( 2001,11,29),
                   Time.parse(&quot;2001/11/29&quot;, now))
      assert_equal(Time.local( 2001,11,29),
                   Time.parse(     &quot;11/29&quot;, now))
      #assert_equal(Time.local(2001,11,1), Time.parse(&quot;Nov&quot;, now))
      assert_equal(Time.local( 2001,11,29,10,22),
                   Time.parse(           &quot;10:22&quot;, now))
    end

    def test_invalid
      # They were actually used in some web sites.
      assert_raise(ArgumentError) { Time.httpdate(&quot;1 Dec 2001 10:23:57 GMT&quot;) }
      assert_raise(ArgumentError) { Time.httpdate(&quot;Sat, 1 Dec 2001 10:25:42 GMT&quot;) }
      assert_raise(ArgumentError) { Time.httpdate(&quot;Sat,  1-Dec-2001 10:53:55 GMT&quot;) }
      assert_raise(ArgumentError) { Time.httpdate(&quot;Saturday, 01-Dec-2001 10:15:34 GMT&quot;) }
      assert_raise(ArgumentError) { Time.httpdate(&quot;Saturday, 01-Dec-101 11:10:07 GMT&quot;) }
      assert_raise(ArgumentError) { Time.httpdate(&quot;Fri, 30 Nov 2001 21:30:00 JST&quot;) }

      # They were actually used in some mails.
      assert_raise(ArgumentError) { Time.rfc2822(&quot;01-5-20&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;7/21/00&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;2001-8-28&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;00-5-6 1:13:06&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;2001-9-27 9:36:49&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;2000-12-13 11:01:11&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;2001/10/17 04:29:55&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;9/4/2001 9:23:19 PM&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;01 Nov 2001 09:04:31&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;13 Feb 2001 16:4 GMT&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;01 Oct 00 5:41:19 PM&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;2 Jul 00 00:51:37 JST&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;01 11 2001 06:55:57 -0500&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;18 \343\366\356\341\370 2000&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, Oct 2001  18:53:32&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, 2 Nov 2001 03:47:54&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, 27 Jul 2001 11.14.14 +0200&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Thu, 2 Nov 2000 04:13:53 -600&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Wed, 5 Apr 2000 22:57:09 JST&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Mon, 11 Sep 2000 19:47:33 00000&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, 28 Apr 2000 20:40:47 +-900&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, 19 Jan 2001 8:15:36 AM -0500&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Thursday, Sep 27 2001 7:42:35 AM EST&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;3/11/2001 1:31:57 PM Pacific Daylight Time&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Mi, 28 Mrz 2001 11:51:36&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;P, 30 sept 2001 23:03:14&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;fr, 11 aug 2000 18:39:22&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fr, 21 Sep 2001 17:44:03 -1000&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Mo, 18 Jun 2001 19:21:40 -1000&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;l\366, 12 aug 2000 18:53:20&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;l\366, 26 maj 2001 00:15:58&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Dom, 30 Sep 2001 17:36:30&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;%&amp;, 31 %2/ 2000 15:44:47 -0500&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;dom, 26 ago 2001 03:57:07 -0300&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;ter, 04 set 2001 16:27:58 -0300&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Wen, 3 oct 2001 23:17:49 -0400&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Wen, 3 oct 2001 23:17:49 -0400&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;ele, 11 h: 2000 12:42:15 -0500&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Tue, 14 Aug 2001 3:55:3 +0200&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, 25 Aug 2000 9:3:48 +0800&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, 1 Dec 2000 0:57:50 EST&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Mon, 7 May 2001 9:39:51 +0200&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Wed, 1 Aug 2001 16:9:15 +0200&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Wed, 23 Aug 2000 9:17:36 +0800&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Fri, 11 Aug 2000 10:4:42 +0800&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Sat, 15 Sep 2001 13:22:2 +0300&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Wed,16 \276\305\324\302 2001 20:06:25 +0800&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;Wed,7 \312\256\322\273\324\302 2001 23:47:22 +0800&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;=?iso-8859-1?Q?(=C5=DA),?= 10   2 2001 23:32:26 +0900 (JST)&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;\307\341\314\343\332\311, 30 \344\346\335\343\310\321 2001 10:01:06&quot;) }
      assert_raise(ArgumentError) { Time.rfc2822(&quot;=?iso-8859-1?Q?(=BF=E5),?= 12  =?iso-8859-1?Q?9=B7=EE?= 2001 14:52:41\n+0900 (JST)&quot;) }
    end

    def test_zone_0000
      assert_equal(true, Time.parse(&quot;2000-01-01T00:00:00Z&quot;).utc?)
      assert_equal(true, Time.parse(&quot;2000-01-01T00:00:00-00:00&quot;).utc?)
      assert_equal(false, Time.parse(&quot;2000-01-01T00:00:00+00:00&quot;).utc?)
      assert_equal(false, Time.parse(&quot;Sat, 01 Jan 2000 00:00:00 GMT&quot;).utc?)
      assert_equal(true, Time.parse(&quot;Sat, 01 Jan 2000 00:00:00 -0000&quot;).utc?)
      assert_equal(false, Time.parse(&quot;Sat, 01 Jan 2000 00:00:00 +0000&quot;).utc?)
      assert_equal(false, Time.rfc2822(&quot;Sat, 01 Jan 2000 00:00:00 GMT&quot;).utc?)
      assert_equal(true, Time.rfc2822(&quot;Sat, 01 Jan 2000 00:00:00 -0000&quot;).utc?)
      assert_equal(false, Time.rfc2822(&quot;Sat, 01 Jan 2000 00:00:00 +0000&quot;).utc?)
      assert_equal(true, Time.rfc2822(&quot;Sat, 01 Jan 2000 00:00:00 UTC&quot;).utc?)
    end

    def test_parse_leap_second
      t = Time.utc(1998,12,31,23,59,59)
      assert_equal(t, Time.parse(&quot;Thu Dec 31 23:59:59 UTC 1998&quot;))
      assert_equal(t, Time.parse(&quot;Fri Dec 31 23:59:59 -0000 1998&quot;));t.localtime
      assert_equal(t, Time.parse(&quot;Fri Jan  1 08:59:59 +0900 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Jan  1 00:59:59 +0100 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Dec 31 23:59:59 +0000 1998&quot;))
      assert_equal(t, Time.parse(&quot;Fri Dec 31 22:59:59 -0100 1998&quot;));t.utc
      t += 1
      assert_equal(t, Time.parse(&quot;Thu Dec 31 23:59:60 UTC 1998&quot;))
      assert_equal(t, Time.parse(&quot;Fri Dec 31 23:59:60 -0000 1998&quot;));t.localtime
      assert_equal(t, Time.parse(&quot;Fri Jan  1 08:59:60 +0900 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Jan  1 00:59:60 +0100 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Dec 31 23:59:60 +0000 1998&quot;))
      assert_equal(t, Time.parse(&quot;Fri Dec 31 22:59:60 -0100 1998&quot;));t.utc
      t += 1 if t.sec == 60
      assert_equal(t, Time.parse(&quot;Thu Jan  1 00:00:00 UTC 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Jan  1 00:00:00 -0000 1999&quot;));t.localtime
      assert_equal(t, Time.parse(&quot;Fri Jan  1 09:00:00 +0900 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Jan  1 01:00:00 +0100 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Jan  1 00:00:00 +0000 1999&quot;))
      assert_equal(t, Time.parse(&quot;Fri Dec 31 23:00:00 -0100 1998&quot;))
    end

    def test_rfc2822_leap_second
      t = Time.utc(1998,12,31,23,59,59)
      assert_equal(t, Time.rfc2822(&quot;Thu, 31 Dec 1998 23:59:59 UTC&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri, 31 Dec 1998 23:59:59 -0000&quot;));t.localtime                                  
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 08:59:59 +0900&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 00:59:59 +0100&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri, 31 Dec 1998 23:59:59 +0000&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri, 31 Dec 1998 22:59:59 -0100&quot;));t.utc                                  
      t += 1
      assert_equal(t, Time.rfc2822(&quot;Thu, 31 Dec 1998 23:59:60 UTC&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri, 31 Dec 1998 23:59:60 -0000&quot;));t.localtime                                  
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 08:59:60 +0900&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 00:59:60 +0100&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri, 31 Dec 1998 23:59:60 +0000&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri, 31 Dec 1998 22:59:60 -0100&quot;));t.utc                                  
      t += 1 if t.sec == 60
      assert_equal(t, Time.rfc2822(&quot;Thu,  1 Jan 1999 00:00:00 UTC&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 00:00:00 -0000&quot;));t.localtime                                  
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 09:00:00 +0900&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 01:00:00 +0100&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri,  1 Jan 1999 00:00:00 +0000&quot;))
      assert_equal(t, Time.rfc2822(&quot;Fri, 31 Dec 1998 23:00:00 -0100&quot;))
    end

    def test_xmlschema_leap_second
      t = Time.utc(1998,12,31,23,59,59)
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T23:59:59Z&quot;))
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T23:59:59-00:00&quot;));t.localtime
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T08:59:59+09:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T00:59:59+01:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T23:59:59+00:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T22:59:59-01:00&quot;));t.utc
      t += 1
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T23:59:60Z&quot;))
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T23:59:60-00:00&quot;));t.localtime
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T08:59:60+09:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T00:59:60+01:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T23:59:60+00:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T22:59:60-01:00&quot;));t.utc
      t += 1 if t.sec == 60
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T00:00:00Z&quot;))
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T00:00:00-00:00&quot;));t.localtime
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T09:00:00+09:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T01:00:00+01:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1999-01-01T00:00:00+00:00&quot;))
      assert_equal(t, Time.xmlschema(&quot;1998-12-31T23:00:00-01:00&quot;))
    end

    def test_ruby_talk_152866
      t = Time::xmlschema('2005-08-30T22:48:00-07:00')
      assert_equal(31, t.day)
      assert_equal(8, t.mon)
    end

    def test_parse_fraction
      assert_equal(500000, Time.parse(&quot;2000-01-01T00:00:00.5+00:00&quot;).tv_usec)
    end
  end
end
</pre>
    </div>