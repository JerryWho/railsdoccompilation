  <div id="fileHeader">
    <h1>irb.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/irb.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Feb 08 09:44:54 -0600 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
#   irb.rb - irb main module
#   	$Release Version: 0.9.5 $
#   	$Revision: 15408 $
#   	$Date: 2008-02-09 00:44:54 +0900 (Sat, 09 Feb 2008) $
#   	by Keiju ISHITSUKA(keiju@ruby-lang.org)
#
# --
#
#
#
require &quot;e2mmap&quot;

require &quot;irb/init&quot;
require &quot;irb/context&quot;
require &quot;irb/extend-command&quot;
#require &quot;irb/workspace&quot;

require &quot;irb/ruby-lex&quot;
require &quot;irb/input-method&quot;
require &quot;irb/locale&quot;

STDOUT.sync = true

module IRB
  @RCS_ID='-$Id: irb.rb 15408 2008-02-08 15:44:54Z nobu $-'

  class Abort &lt; Exception;end

  #
  @CONF = {}

  def IRB.conf
    @CONF
  end

  # IRB version method
  def IRB.version
    if v = @CONF[:VERSION] then return v end

    require &quot;irb/version&quot;
    rv = @RELEASE_VERSION.sub(/\.0/, &quot;&quot;)
    @CONF[:VERSION] = format(&quot;irb %s(%s)&quot;, rv, @LAST_UPDATE_DATE)
  end

  def IRB.CurrentContext
    IRB.conf[:MAIN_CONTEXT]
  end

  # initialize IRB and start TOP_LEVEL irb
  def IRB.start(ap_path = nil)
    $0 = File::basename(ap_path, &quot;.rb&quot;) if ap_path

    IRB.setup(ap_path)

    if @CONF[:SCRIPT]
      irb = Irb.new(nil, @CONF[:SCRIPT])
    else
      irb = Irb.new
    end

    @CONF[:IRB_RC].call(irb.context) if @CONF[:IRB_RC]
    @CONF[:MAIN_CONTEXT] = irb.context

    trap(&quot;SIGINT&quot;) do
      irb.signal_handle
    end
    
    catch(:IRB_EXIT) do
      irb.eval_input
    end
#    print &quot;\n&quot;
  end

  def IRB.irb_exit(irb, ret)
    throw :IRB_EXIT, ret
  end

  def IRB.irb_abort(irb, exception = Abort)
    if defined? Thread
      irb.context.thread.raise exception, &quot;abort then interrupt!!&quot;
    else
      raise exception, &quot;abort then interrupt!!&quot;
    end
  end

  #
  # irb interpriter main routine 
  #
  class Irb
    def initialize(workspace = nil, input_method = nil, output_method = nil)
      @context = Context.new(self, workspace, input_method, output_method)
      @context.main.extend ExtendCommandBundle
      @signal_status = :IN_IRB

      @scanner = RubyLex.new
      @scanner.exception_on_syntax_error = false
    end
    attr_reader :context
    attr_accessor :scanner

    def eval_input
      @scanner.set_prompt do
	|ltype, indent, continue, line_no|
	if ltype
	  f = @context.prompt_s
	elsif continue
	  f = @context.prompt_c
	elsif indent &gt; 0
	  f = @context.prompt_n
	else @context.prompt_i
	  f = @context.prompt_i
	end
	f = &quot;&quot; unless f
	if @context.prompting?
	  @context.io.prompt = p = prompt(f, ltype, indent, line_no)
	else
	  @context.io.prompt = p = &quot;&quot;
	end
	if @context.auto_indent_mode
	  unless ltype
            ind = prompt(@context.prompt_i, ltype, indent, line_no)[/.*\z/].size +
	      indent * 2 - p.size
	    ind += 2 if continue
	    @context.io.prompt = p + &quot; &quot; * ind if ind &gt; 0
	  end
	end
      end
       
      @scanner.set_input(@context.io) do
	signal_status(:IN_INPUT) do
	  if l = @context.io.gets
	    print l if @context.verbose?
	  else
	    if @context.ignore_eof? and @context.io.readable_atfer_eof?
	      l = &quot;\n&quot;
	      if @context.verbose?
		printf &quot;Use \&quot;exit\&quot; to leave %s\n&quot;, @context.ap_name
	      end
	    end
	  end
	  l
	end
      end

      @scanner.each_top_level_statement do |line, line_no|
	signal_status(:IN_EVAL) do
	  begin
            line.untaint
	    @context.evaluate(line, line_no)
	    output_value if @context.echo?
	    exc = nil
	  rescue Interrupt =&gt; exc
	  rescue SystemExit, SignalException
	    raise
	  rescue Exception =&gt; exc
	  end
	  if exc
	    print exc.class, &quot;: &quot;, exc, &quot;\n&quot;
	    if exc.backtrace[0] =~ /irb(2)?(\/.*|-.*|\.rb)?:/ &amp;&amp; exc.class.to_s !~ /^IRB/
	      irb_bug = true 
	    else
	      irb_bug = false
	    end
	    
	    messages = []
	    lasts = []
	    levels = 0
	    for m in exc.backtrace
	      m = @context.workspace.filter_backtrace(m) unless irb_bug
	      if m
		if messages.size &lt; @context.back_trace_limit
		  messages.push &quot;\tfrom &quot;+m
		else
		  lasts.push &quot;\tfrom &quot;+m
		  if lasts.size &gt; @context.back_trace_limit
		    lasts.shift 
		    levels += 1
		  end
		end
	      end
	    end
	    print messages.join(&quot;\n&quot;), &quot;\n&quot;
	    unless lasts.empty?
	      printf &quot;... %d levels...\n&quot;, levels if levels &gt; 0
	      print lasts.join(&quot;\n&quot;)
	    end
	    print &quot;Maybe IRB bug!!\n&quot; if irb_bug
	  end
          if $SAFE &gt; 2
            abort &quot;Error: irb does not work for $SAFE level higher than 2&quot;
          end
	end
      end
    end

    def suspend_name(path = nil, name = nil)
      @context.irb_path, back_path = path, @context.irb_path if path
      @context.irb_name, back_name = name, @context.irb_name if name
      begin
	yield back_path, back_name
      ensure
	@context.irb_path = back_path if path
	@context.irb_name = back_name if name
      end
    end

    def suspend_workspace(workspace)
      @context.workspace, back_workspace = workspace, @context.workspace
      begin
	yield back_workspace
      ensure
	@context.workspace = back_workspace
      end
    end

    def suspend_input_method(input_method)
      back_io = @context.io
      @context.instance_eval{@io = input_method}
      begin
	yield back_io
      ensure
	@context.instance_eval{@io = back_io}
      end
    end

    def suspend_context(context)
      @context, back_context = context, @context
      begin
	yield back_context
      ensure
	@context = back_context
      end
    end

    def signal_handle
      unless @context.ignore_sigint?
	print &quot;\nabort!!\n&quot; if @context.verbose?
	exit
      end

      case @signal_status
      when :IN_INPUT
	print &quot;^C\n&quot;
	raise RubyLex::TerminateLineInput
      when :IN_EVAL
	IRB.irb_abort(self)
      when :IN_LOAD
	IRB.irb_abort(self, LoadAbort)
      when :IN_IRB
	# ignore
      else
	# ignore other cases as well
      end
    end

    def signal_status(status)
      return yield if @signal_status == :IN_LOAD

      signal_status_back = @signal_status
      @signal_status = status
      begin
	yield
      ensure
	@signal_status = signal_status_back
      end
    end

    def prompt(prompt, ltype, indent, line_no)
      p = prompt.dup
      p.gsub!(/%([0-9]+)?([a-zA-Z])/) do
	case $2
	when &quot;N&quot;
	  @context.irb_name
	when &quot;m&quot;
	  @context.main.to_s
	when &quot;M&quot;
	  @context.main.inspect
	when &quot;l&quot;
	  ltype
	when &quot;i&quot;
	  if $1 
	    format(&quot;%&quot; + $1 + &quot;d&quot;, indent)
	  else
	    indent.to_s
	  end
	when &quot;n&quot;
	  if $1 
	    format(&quot;%&quot; + $1 + &quot;d&quot;, line_no)
	  else
	    line_no.to_s
	  end
	when &quot;%&quot;
	  &quot;%&quot;
	end
      end
      p
    end

    def output_value
      if @context.inspect?
        printf @context.return_format, @context.last_value.inspect
      else
        printf @context.return_format, @context.last_value
      end
    end

    def inspect
      ary = []
      for iv in instance_variables
	case iv
	when &quot;@signal_status&quot;
	  ary.push format(&quot;%s=:%s&quot;, iv, @signal_status.id2name)
	when &quot;@context&quot;
	  ary.push format(&quot;%s=%s&quot;, iv, eval(iv).__to_s__)
	else
	  ary.push format(&quot;%s=%s&quot;, iv, eval(iv))
	end
      end
      format(&quot;#&lt;%s: %s&gt;&quot;, self.class, ary.join(&quot;, &quot;))
    end
  end

  # Singleton method
  def @CONF.inspect
    IRB.version unless self[:VERSION]

    array = []
    for k, v in sort{|a1, a2| a1[0].id2name &lt;=&gt; a2[0].id2name}
      case k
      when :MAIN_CONTEXT, :__TMP__EHV__
	array.push format(&quot;CONF[:%s]=...myself...&quot;, k.id2name)
      when :PROMPT
	s = v.collect{
	  |kk, vv|
	  ss = vv.collect{|kkk, vvv| &quot;:#{kkk.id2name}=&gt;#{vvv.inspect}&quot;}
	  format(&quot;:%s=&gt;{%s}&quot;, kk.id2name, ss.join(&quot;, &quot;))
	}
	array.push format(&quot;CONF[:%s]={%s}&quot;, k.id2name, s.join(&quot;, &quot;))
      else
	array.push format(&quot;CONF[:%s]=%s&quot;, k.id2name, v.inspect)
      end
    end
    array.join(&quot;\n&quot;)
  end
end
</pre>
    </div>