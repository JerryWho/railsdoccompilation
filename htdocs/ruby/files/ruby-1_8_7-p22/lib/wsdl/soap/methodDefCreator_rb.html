  <div id="fileHeader">
    <h1>methodDefCreator.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/lib/wsdl/soap/methodDefCreator.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># WSDL4R - Creating driver code from WSDL.
# Copyright (C) 2002, 2003, 2005  NAKAMURA, Hiroshi &lt;nahi@ruby-lang.org&gt;.

# This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
# redistribute it and/or modify it under the same terms of Ruby's license;
# either the dual license version in 2003, or any later version.


require 'wsdl/info'
require 'wsdl/soap/classDefCreatorSupport'
require 'soap/rpc/element'


module WSDL
module SOAP


class MethodDefCreator
  include ClassDefCreatorSupport

  attr_reader :definitions

  def initialize(definitions)
    @definitions = definitions
    @simpletypes = @definitions.collect_simpletypes
    @complextypes = @definitions.collect_complextypes
    @elements = @definitions.collect_elements
    @types = []
  end

  def dump(porttype)
    @types.clear
    result = &quot;&quot;
    operations = @definitions.porttype(porttype).operations
    binding = @definitions.porttype_binding(porttype)
    operations.each do |operation|
      op_bind = binding.operations[operation.name]
      next unless op_bind # no binding is defined
      next unless op_bind.soapoperation # not a SOAP operation binding
      result &lt;&lt; &quot;,\n&quot; unless result.empty?
      result &lt;&lt; dump_method(operation, op_bind).chomp
    end
    return result, @types
  end

  def collect_rpcparameter(operation)
    result = operation.inputparts.collect { |part|
      collect_type(part.type)
      param_set(::SOAP::RPC::SOAPMethod::IN, part.name, rpcdefinedtype(part))
    }
    outparts = operation.outputparts
    if outparts.size &gt; 0
      retval = outparts[0]
      collect_type(retval.type)
      result &lt;&lt; param_set(::SOAP::RPC::SOAPMethod::RETVAL, retval.name,
        rpcdefinedtype(retval))
      cdr(outparts).each { |part|
	collect_type(part.type)
	result &lt;&lt; param_set(::SOAP::RPC::SOAPMethod::OUT, part.name,
          rpcdefinedtype(part))
      }
    end
    result
  end

  def collect_documentparameter(operation)
    param = []
    operation.inputparts.each do |input|
      param &lt;&lt; param_set(::SOAP::RPC::SOAPMethod::IN, input.name,
        documentdefinedtype(input), elementqualified(input))
    end
    operation.outputparts.each do |output|
      param &lt;&lt; param_set(::SOAP::RPC::SOAPMethod::OUT, output.name,
        documentdefinedtype(output), elementqualified(output))
    end
    param
  end

private

  def dump_method(operation, binding)
    name = safemethodname(operation.name.name)
    name_as = operation.name.name
    style = binding.soapoperation_style
    inputuse = binding.input.soapbody_use
    outputuse = binding.output.soapbody_use
    namespace = binding.input.soapbody.namespace
    if style == :rpc
      qname = XSD::QName.new(namespace, name_as)
      paramstr = param2str(collect_rpcparameter(operation))
    else
      qname = nil
      paramstr = param2str(collect_documentparameter(operation))
    end
    if paramstr.empty?
      paramstr = '[]'
    else
      paramstr = &quot;[ &quot; &lt;&lt; paramstr.split(/\r?\n/).join(&quot;\n    &quot;) &lt;&lt; &quot; ]&quot;
    end
    definitions = &lt;&lt;__EOD__
#{ndq(binding.soapaction)},
  #{dq(name)},
  #{paramstr},
  { :request_style =&gt;  #{sym(style.id2name)}, :request_use =&gt;  #{sym(inputuse.id2name)},
    :response_style =&gt; #{sym(style.id2name)}, :response_use =&gt; #{sym(outputuse.id2name)} }
__EOD__
    if style == :rpc
      return &lt;&lt;__EOD__
[ #{qname.dump},
  #{definitions}]
__EOD__
    else
      return &lt;&lt;__EOD__
[ #{definitions}]
__EOD__
    end
  end

  def rpcdefinedtype(part)
    if mapped = basetype_mapped_class(part.type)
      ['::' + mapped.name]
    elsif definedtype = @simpletypes[part.type]
      ['::' + basetype_mapped_class(definedtype.base).name]
    elsif definedtype = @elements[part.element]
      #['::SOAP::SOAPStruct', part.element.namespace, part.element.name]
      ['nil', part.element.namespace, part.element.name]
    elsif definedtype = @complextypes[part.type]
      case definedtype.compoundtype
      when :TYPE_STRUCT, :TYPE_EMPTY    # ToDo: empty should be treated as void.
        type = create_class_name(part.type)
	[type, part.type.namespace, part.type.name]
      when :TYPE_MAP
	[Hash.name, part.type.namespace, part.type.name]
      when :TYPE_ARRAY
	arytype = definedtype.find_arytype || XSD::AnyTypeName
	ns = arytype.namespace
	name = arytype.name.sub(/\[(?:,)*\]$/, '')
        type = create_class_name(XSD::QName.new(ns, name))
	[type + '[]', ns, name]
      else
	raise NotImplementedError.new(&quot;must not reach here&quot;)
      end
    else
      raise RuntimeError.new(&quot;part: #{part.name} cannot be resolved&quot;)
    end
  end

  def documentdefinedtype(part)
    if mapped = basetype_mapped_class(part.type)
      ['::' + mapped.name, nil, part.name]
    elsif definedtype = @simpletypes[part.type]
      ['::' + basetype_mapped_class(definedtype.base).name, nil, part.name]
    elsif definedtype = @elements[part.element]
      ['::SOAP::SOAPElement', part.element.namespace, part.element.name]
    elsif definedtype = @complextypes[part.type]
      ['::SOAP::SOAPElement', part.type.namespace, part.type.name]
    else
      raise RuntimeError.new(&quot;part: #{part.name} cannot be resolved&quot;)
    end
  end

  def elementqualified(part)
    if mapped = basetype_mapped_class(part.type)
      false
    elsif definedtype = @simpletypes[part.type]
      false
    elsif definedtype = @elements[part.element]
      definedtype.elementform == 'qualified'
    elsif definedtype = @complextypes[part.type]
      false
    else
      raise RuntimeError.new(&quot;part: #{part.name} cannot be resolved&quot;)
    end
  end

  def param_set(io_type, name, type, ele = nil)
    [io_type, name, type, ele]
  end

  def collect_type(type)
    # ignore inline type definition.
    return if type.nil?
    return if @types.include?(type)
    @types &lt;&lt; type
    return unless @complextypes[type]
    @complextypes[type].each_element do |element|
      collect_type(element.type)
    end
  end

  def param2str(params)
    params.collect { |param|
      io, name, type, ele = param
      unless ele.nil?
        &quot;[#{dq(io)}, #{dq(name)}, #{type2str(type)}, #{ele2str(ele)}]&quot;
      else
        &quot;[#{dq(io)}, #{dq(name)}, #{type2str(type)}]&quot;
      end
    }.join(&quot;,\n&quot;)
  end

  def type2str(type)
    if type.size == 1
      &quot;[#{dq(type[0])}]&quot; 
    else
      &quot;[#{dq(type[0])}, #{ndq(type[1])}, #{dq(type[2])}]&quot; 
    end
  end

  def ele2str(ele)
    qualified = ele
    if qualified
      &quot;true&quot;
    else
      &quot;false&quot;
    end
  end

  def cdr(ary)
    result = ary.dup
    result.shift
    result
  end
end


end
end
</pre>
    </div>