  <div id="fileHeader">
    <h1>file.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/file.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Jun 17 01:10:23 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  file.c -

  $Author: knu $
  $Date: 2008-06-17 15:10:23 +0900 (Tue, 17 Jun 2008) $
  created at: Mon Nov 15 12:24:34 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#ifdef _WIN32
#include &quot;missing/file.h&quot;
#endif
#ifdef __CYGWIN__
#include &lt;windows.h&gt;
#include &lt;sys/cygwin.h&gt;
#endif

#include &quot;ruby.h&quot;
#include &quot;rubyio.h&quot;
#include &quot;rubysig.h&quot;
#include &quot;util.h&quot;
#include &quot;dln.h&quot;

#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif

#ifdef HAVE_SYS_FILE_H
# include &lt;sys/file.h&gt;
#else
int flock _((int, int));
#endif

#ifdef HAVE_SYS_PARAM_H
# include &lt;sys/param.h&gt;
#endif
#ifndef MAXPATHLEN
# define MAXPATHLEN 1024
#endif

#include &lt;time.h&gt;

VALUE rb_time_new _((time_t, time_t));

#ifdef HAVE_UTIME_H
#include &lt;utime.h&gt;
#elif defined HAVE_SYS_UTIME_H
#include &lt;sys/utime.h&gt;
#endif

#ifdef HAVE_PWD_H
#include &lt;pwd.h&gt;
#endif

#ifndef HAVE_STRING_H
char *strrchr _((const char*,const char));
#endif

#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#ifdef HAVE_SYS_MKDEV_H
#include &lt;sys/mkdev.h&gt;
#endif

#if !defined HAVE_LSTAT &amp;&amp; !defined lstat
#define lstat stat
#endif
#if !HAVE_FSEEKO &amp;&amp; !defined(fseeko)
# define fseeko  fseek
#endif

#ifdef __BEOS__ /* should not change ID if -1 */
static int
be_chown(const char *path, uid_t owner, gid_t group)
{
    if (owner == -1 || group == -1) {
	struct stat st;
	if (stat(path, &amp;st) &lt; 0) return -1;
	if (owner == -1) owner = st.st_uid;
	if (group == -1) group = st.st_gid;
    }
    return chown(path, owner, group);
}
#define chown be_chown
static int
be_fchown(int fd, uid_t owner, gid_t group)
{
    if (owner == -1 || group == -1) {
	struct stat st;
	if (fstat(fd, &amp;st) &lt; 0) return -1;
	if (owner == -1) owner = st.st_uid;
	if (group == -1) group = st.st_gid;
    }
    return fchown(fd, owner, group);
}
#define fchown be_fchown
#endif /* __BEOS__ */

VALUE rb_cFile;
VALUE rb_mFileTest;
VALUE rb_cStat;

static long apply2files _((void (*)(const char *, void *), VALUE, void *));
static long
apply2files(func, vargs, arg)
    void (*func)_((const char *, void *));
    VALUE vargs;
    void *arg;
{
    long i;
    VALUE path;
    struct RArray *args = RARRAY(vargs);

    for (i=0; i&lt;args-&gt;len; i++) {
	path = args-&gt;ptr[i];
	SafeStringValue(path);
	(*func)(StringValueCStr(path), arg);
    }

    return args-&gt;len;
}

/*
 *  call-seq:
 *     file.path -&gt; filename
 *  
 *  Returns the pathname used to create &lt;i&gt;file&lt;/i&gt; as a string. Does
 *  not normalize the name.
 *     
 *     File.new(&quot;testfile&quot;).path               #=&gt; &quot;testfile&quot;
 *     File.new(&quot;/tmp/../tmp/xxx&quot;, &quot;w&quot;).path   #=&gt; &quot;/tmp/../tmp/xxx&quot;
 *     
 */

static VALUE
rb_file_path(obj)
    VALUE obj;
{
    rb_io_t *fptr;

    fptr = RFILE(rb_io_taint_check(obj))-&gt;fptr;
    rb_io_check_initialized(fptr);
    if (!fptr-&gt;path) return Qnil;
    return rb_tainted_str_new2(fptr-&gt;path);
}

static VALUE
stat_new_0(klass, st)
    VALUE klass;
    struct stat *st;
{
    struct stat *nst = 0;

    if (st) {
	nst = ALLOC(struct stat);
	*nst = *st;
    }
    return Data_Wrap_Struct(klass, NULL, free, nst);
}

static VALUE
stat_new(st)
    struct stat *st;
{
    return stat_new_0(rb_cStat, st);
}

static struct stat*
get_stat(self)
    VALUE self;
{
    struct stat* st;
    Data_Get_Struct(self, struct stat, st);
    if (!st) rb_raise(rb_eTypeError, &quot;uninitialized File::Stat&quot;);
    return st;
}

/*
 *  call-seq:
 *     stat &lt;=&gt; other_stat    =&gt; -1, 0, 1
 *  
 *  Compares &lt;code&gt;File::Stat&lt;/code&gt; objects by comparing their
 *  respective modification times.
 *     
 *     f1 = File.new(&quot;f1&quot;, &quot;w&quot;)
 *     sleep 1
 *     f2 = File.new(&quot;f2&quot;, &quot;w&quot;)
 *     f1.stat &lt;=&gt; f2.stat   #=&gt; -1
 */

static VALUE
rb_stat_cmp(self, other)
    VALUE self, other;
{
    if (rb_obj_is_kind_of(other, rb_obj_class(self))) {
	time_t t1 = get_stat(self)-&gt;st_mtime;
	time_t t2 = get_stat(other)-&gt;st_mtime;
	if (t1 == t2)
	    return INT2FIX(0);
	else if (t1 &lt; t2)
	    return INT2FIX(-1);
	else
	    return INT2FIX(1);
    }
    return Qnil;
}

static VALUE rb_stat_dev _((VALUE));
static VALUE rb_stat_ino _((VALUE));
static VALUE rb_stat_mode _((VALUE));
static VALUE rb_stat_nlink _((VALUE));
static VALUE rb_stat_uid _((VALUE));
static VALUE rb_stat_gid _((VALUE));
static VALUE rb_stat_rdev _((VALUE));
static VALUE rb_stat_size _((VALUE));
static VALUE rb_stat_blksize _((VALUE));
static VALUE rb_stat_blocks _((VALUE));
static VALUE rb_stat_atime _((VALUE));
static VALUE rb_stat_mtime _((VALUE));
static VALUE rb_stat_ctime _((VALUE));

/*
 *  call-seq:
 *     stat.dev    =&gt; fixnum
 *  
 *  Returns an integer representing the device on which &lt;i&gt;stat&lt;/i&gt;
 *  resides.
 *     
 *     File.stat(&quot;testfile&quot;).dev   #=&gt; 774
 */

static VALUE
rb_stat_dev(self)
    VALUE self;
{
    return INT2NUM(get_stat(self)-&gt;st_dev);
}

/*
 *  call-seq:
 *     stat.dev_major   =&gt; fixnum
 *  
 *  Returns the major part of &lt;code&gt;File_Stat#dev&lt;/code&gt; or
 *  &lt;code&gt;nil&lt;/code&gt;.
 *     
 *     File.stat(&quot;/dev/fd1&quot;).dev_major   #=&gt; 2
 *     File.stat(&quot;/dev/tty&quot;).dev_major   #=&gt; 5
 */

static VALUE
rb_stat_dev_major(self)
    VALUE self;
{
#if defined(major)
    long dev = get_stat(self)-&gt;st_dev;
    return ULONG2NUM(major(dev));
#else
    return Qnil;
#endif
}

/*
 *  call-seq:
 *     stat.dev_minor   =&gt; fixnum
 *  
 *  Returns the minor part of &lt;code&gt;File_Stat#dev&lt;/code&gt; or
 *  &lt;code&gt;nil&lt;/code&gt;.
 *     
 *     File.stat(&quot;/dev/fd1&quot;).dev_minor   #=&gt; 1
 *     File.stat(&quot;/dev/tty&quot;).dev_minor   #=&gt; 0
 */

static VALUE
rb_stat_dev_minor(self)
    VALUE self;
{
#if defined(minor)
    long dev = get_stat(self)-&gt;st_dev;
    return ULONG2NUM(minor(dev));
#else
    return Qnil;
#endif
}


/*
 *  call-seq:
 *     stat.ino   =&gt; fixnum
 *  
 *  Returns the inode number for &lt;i&gt;stat&lt;/i&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).ino   #=&gt; 1083669
 *     
 */

static VALUE
rb_stat_ino(self)
    VALUE self;
{
#ifdef HUGE_ST_INO
    return ULL2NUM(get_stat(self)-&gt;st_ino);
#else
    return ULONG2NUM(get_stat(self)-&gt;st_ino);
#endif
}

/*
 *  call-seq:
 *     stat.mode   =&gt; fixnum
 *  
 *  Returns an integer representing the permission bits of
 *  &lt;i&gt;stat&lt;/i&gt;. The meaning of the bits is platform dependent; on
 *  Unix systems, see &lt;code&gt;stat(2)&lt;/code&gt;.
 *     
 *     File.chmod(0644, &quot;testfile&quot;)   #=&gt; 1
 *     s = File.stat(&quot;testfile&quot;)
 *     sprintf(&quot;%o&quot;, s.mode)          #=&gt; &quot;100644&quot;
 */

static VALUE
rb_stat_mode(self)
    VALUE self;
{
#ifdef __BORLANDC__
    return UINT2NUM((unsigned short)(get_stat(self)-&gt;st_mode));
#else
    return UINT2NUM(get_stat(self)-&gt;st_mode);
#endif
}

/*
 *  call-seq:
 *     stat.nlink   =&gt; fixnum
 *  
 *  Returns the number of hard links to &lt;i&gt;stat&lt;/i&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).nlink             #=&gt; 1
 *     File.link(&quot;testfile&quot;, &quot;testfile.bak&quot;)   #=&gt; 0
 *     File.stat(&quot;testfile&quot;).nlink             #=&gt; 2
 *     
 */

static VALUE
rb_stat_nlink(self)
    VALUE self;
{
    return UINT2NUM(get_stat(self)-&gt;st_nlink);
}


/*
 *  call-seq:
 *     stat.uid    =&gt; fixnum
 *  
 *  Returns the numeric user id of the owner of &lt;i&gt;stat&lt;/i&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).uid   #=&gt; 501
 *     
 */

static VALUE
rb_stat_uid(self)
    VALUE self;
{
    return UINT2NUM(get_stat(self)-&gt;st_uid);
}

/*
 *  call-seq:
 *     stat.gid   =&gt; fixnum
 *  
 *  Returns the numeric group id of the owner of &lt;i&gt;stat&lt;/i&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).gid   #=&gt; 500
 *     
 */

static VALUE
rb_stat_gid(self)
    VALUE self;
{
    return UINT2NUM(get_stat(self)-&gt;st_gid);
}


/*
 *  call-seq:
 *     stat.rdev   =&gt;  fixnum or nil
 *  
 *  Returns an integer representing the device type on which
 *  &lt;i&gt;stat&lt;/i&gt; resides. Returns &lt;code&gt;nil&lt;/code&gt; if the operating
 *  system doesn't support this feature.
 *     
 *     File.stat(&quot;/dev/fd1&quot;).rdev   #=&gt; 513
 *     File.stat(&quot;/dev/tty&quot;).rdev   #=&gt; 1280
 */

static VALUE
rb_stat_rdev(self)
    VALUE self;
{
#ifdef HAVE_ST_RDEV
    return ULONG2NUM(get_stat(self)-&gt;st_rdev);
#else
    return Qnil;
#endif
}

/*
 *  call-seq:
 *     stat.rdev_major   =&gt; fixnum
 *  
 *  Returns the major part of &lt;code&gt;File_Stat#rdev&lt;/code&gt; or
 *  &lt;code&gt;nil&lt;/code&gt;.
 *     
 *     File.stat(&quot;/dev/fd1&quot;).rdev_major   #=&gt; 2
 *     File.stat(&quot;/dev/tty&quot;).rdev_major   #=&gt; 5
 */

static VALUE
rb_stat_rdev_major(self)
    VALUE self;
{
#if defined(HAVE_ST_RDEV) &amp;&amp; defined(major)
    long rdev = get_stat(self)-&gt;st_rdev;
    return ULONG2NUM(major(rdev));
#else
    return Qnil;
#endif
}

/*
 *  call-seq:
 *     stat.rdev_minor   =&gt; fixnum
 *  
 *  Returns the minor part of &lt;code&gt;File_Stat#rdev&lt;/code&gt; or
 *  &lt;code&gt;nil&lt;/code&gt;.
 *     
 *     File.stat(&quot;/dev/fd1&quot;).rdev_minor   #=&gt; 1
 *     File.stat(&quot;/dev/tty&quot;).rdev_minor   #=&gt; 0
 */

static VALUE
rb_stat_rdev_minor(self)
    VALUE self;
{
#if defined(HAVE_ST_RDEV) &amp;&amp; defined(minor)
    long rdev = get_stat(self)-&gt;st_rdev;
    return ULONG2NUM(minor(rdev));
#else
    return Qnil;
#endif
}

/*
 *  call-seq:
 *     stat.size    =&gt; fixnum
 *  
 *  Returns the size of &lt;i&gt;stat&lt;/i&gt; in bytes.
 *     
 *     File.stat(&quot;testfile&quot;).size   #=&gt; 66
 */

static VALUE
rb_stat_size(self)
    VALUE self;
{
    return OFFT2NUM(get_stat(self)-&gt;st_size);
}

/*
 *  call-seq:
 *     stat.blksize   =&gt; integer or nil
 *  
 *  Returns the native file system's block size. Will return &lt;code&gt;nil&lt;/code&gt;
 *  on platforms that don't support this information.
 *     
 *     File.stat(&quot;testfile&quot;).blksize   #=&gt; 4096
 *     
 */

static VALUE
rb_stat_blksize(self)
    VALUE self;
{
#ifdef HAVE_ST_BLKSIZE
    return ULONG2NUM(get_stat(self)-&gt;st_blksize);
#else
    return Qnil;
#endif
}

/*
 *  call-seq:
 *     stat.blocks    =&gt; integer or nil
 *  
 *  Returns the number of native file system blocks allocated for this
 *  file, or &lt;code&gt;nil&lt;/code&gt; if the operating system doesn't 
 *  support this feature.
 *     
 *     File.stat(&quot;testfile&quot;).blocks   #=&gt; 2
 */

static VALUE
rb_stat_blocks(self)
    VALUE self;
{
#ifdef HAVE_ST_BLOCKS
    return ULONG2NUM(get_stat(self)-&gt;st_blocks);
#else
    return Qnil;
#endif
}


/*
 *  call-seq:
 *     stat.atime   =&gt; time
 *  
 *  Returns the last access time for this file as an object of class
 *  &lt;code&gt;Time&lt;/code&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).atime   #=&gt; Wed Dec 31 18:00:00 CST 1969
 *     
 */

static VALUE
rb_stat_atime(self)
    VALUE self;
{
    return rb_time_new(get_stat(self)-&gt;st_atime, 0);
}

/*
 *  call-seq:
 *     stat.mtime -&gt; aTime
 *  
 *  Returns the modification time of &lt;i&gt;stat&lt;/i&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).mtime   #=&gt; Wed Apr 09 08:53:14 CDT 2003
 *     
 */

static VALUE
rb_stat_mtime(self)
    VALUE self;
{
    return rb_time_new(get_stat(self)-&gt;st_mtime, 0);
}

/*
 *  call-seq:
 *     stat.ctime -&gt; aTime
 *  
 *  Returns the change time for &lt;i&gt;stat&lt;/i&gt; (that is, the time
 *  directory information about the file was changed, not the file
 *  itself).
 *     
 *     File.stat(&quot;testfile&quot;).ctime   #=&gt; Wed Apr 09 08:53:14 CDT 2003
 *     
 */

static VALUE
rb_stat_ctime(self)
    VALUE self;
{
    return rb_time_new(get_stat(self)-&gt;st_ctime, 0);
}

/*
 * call-seq:
 *   stat.inspect  =&gt;  string
 *
 * Produce a nicely formatted description of &lt;i&gt;stat&lt;/i&gt;.
 *
 *   File.stat(&quot;/etc/passwd&quot;).inspect
 *      #=&gt; &quot;#&lt;File::Stat dev=0xe000005, ino=1078078, mode=0100644, 
 *           nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096, 
 *           blocks=8, atime=Wed Dec 10 10:16:12 CST 2003, 
 *           mtime=Fri Sep 12 15:41:41 CDT 2003, 
 *           ctime=Mon Oct 27 11:20:27 CST 2003&gt;&quot;
 */

static VALUE
rb_stat_inspect(self)
    VALUE self;
{
    VALUE str;
    int i;
    static const struct {
	const char *name;
	VALUE (*func)_((VALUE));
    } member[] = {
	{&quot;dev&quot;,	    rb_stat_dev},
	{&quot;ino&quot;,	    rb_stat_ino},
	{&quot;mode&quot;,    rb_stat_mode},
	{&quot;nlink&quot;,   rb_stat_nlink},
	{&quot;uid&quot;,	    rb_stat_uid},
	{&quot;gid&quot;,	    rb_stat_gid},
	{&quot;rdev&quot;,    rb_stat_rdev},
	{&quot;size&quot;,    rb_stat_size},
	{&quot;blksize&quot;, rb_stat_blksize},
	{&quot;blocks&quot;,  rb_stat_blocks},
	{&quot;atime&quot;,   rb_stat_atime},
	{&quot;mtime&quot;,   rb_stat_mtime},
	{&quot;ctime&quot;,   rb_stat_ctime},
    };

    str = rb_str_buf_new2(&quot;#&lt;&quot;);
    rb_str_buf_cat2(str, rb_obj_classname(self));
    rb_str_buf_cat2(str, &quot; &quot;);

    for (i = 0; i &lt; sizeof(member)/sizeof(member[0]); i++) {
	VALUE v;

	if (i &gt; 0) {
	    rb_str_buf_cat2(str, &quot;, &quot;);
	}
	rb_str_buf_cat2(str, member[i].name);
	rb_str_buf_cat2(str, &quot;=&quot;);
	v = (*member[i].func)(self);
	if (i == 2) {		/* mode */
	    char buf[32];

	    sprintf(buf, &quot;0%lo&quot;, NUM2ULONG(v));
	    rb_str_buf_cat2(str, buf);
	}
	else if (i == 0 || i == 6) { /* dev/rdev */
	    char buf[32];

	    sprintf(buf, &quot;0x%lx&quot;, NUM2ULONG(v));
	    rb_str_buf_cat2(str, buf);
	}
	else {
	    rb_str_append(str, rb_inspect(v));
	}
    }
    rb_str_buf_cat2(str, &quot;&gt;&quot;);
    OBJ_INFECT(str, self);

    return str;
}

static int
rb_stat(file, st)
    VALUE file;
    struct stat *st;
{
    VALUE tmp;

    tmp = rb_check_convert_type(file, T_FILE, &quot;IO&quot;, &quot;to_io&quot;);
    if (!NIL_P(tmp)) {
	rb_io_t *fptr;

	rb_secure(2);
	GetOpenFile(tmp, fptr);
	return fstat(fileno(fptr-&gt;f), st);
    }
    SafeStringValue(file);
    return stat(StringValueCStr(file), st);
}

#ifdef _WIN32
static HANDLE
w32_io_info(file, st)
    VALUE *file;
    BY_HANDLE_FILE_INFORMATION *st;
{
    VALUE tmp;
    HANDLE f, ret = 0;

    tmp = rb_check_convert_type(*file, T_FILE, &quot;IO&quot;, &quot;to_io&quot;);
    if (!NIL_P(tmp)) {
	rb_io_t *fptr;

	GetOpenFile(tmp, fptr);
	f = (HANDLE)rb_w32_get_osfhandle(fileno(fptr-&gt;f));
	if (f == (HANDLE)-1) return INVALID_HANDLE_VALUE;
    }
    else {
	SafeStringValue(*file);
	f = CreateFile(StringValueCStr(*file), 0,
	               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
	               rb_w32_iswin95() ? 0 : FILE_FLAG_BACKUP_SEMANTICS, NULL);
	if (f == INVALID_HANDLE_VALUE) return f;
	ret = f;
    }
    if (GetFileType(f) == FILE_TYPE_DISK) {
	ZeroMemory(st, sizeof(*st));
	if (GetFileInformationByHandle(f, st)) return ret;
    }
    if (ret) CloseHandle(ret);
    return INVALID_HANDLE_VALUE;
}
#endif

/*
 *  call-seq:
 *     File.stat(file_name)   =&gt;  stat
 *  
 *  Returns a &lt;code&gt;File::Stat&lt;/code&gt; object for the named file (see
 *  &lt;code&gt;File::Stat&lt;/code&gt;).
 *     
 *     File.stat(&quot;testfile&quot;).mtime   #=&gt; Tue Apr 08 12:58:04 CDT 2003
 *     
 */

static VALUE
rb_file_s_stat(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    SafeStringValue(fname);
    if (rb_stat(fname, &amp;st) &lt; 0) {
	rb_sys_fail(StringValueCStr(fname));
    }
    return stat_new(&amp;st);
}

/*
 *  call-seq:
 *     ios.stat    =&gt; stat
 *  
 *  Returns status information for &lt;em&gt;ios&lt;/em&gt; as an object of type
 *  &lt;code&gt;File::Stat&lt;/code&gt;.
 *     
 *     f = File.new(&quot;testfile&quot;)
 *     s = f.stat
 *     &quot;%o&quot; % s.mode   #=&gt; &quot;100644&quot;
 *     s.blksize       #=&gt; 4096
 *     s.atime         #=&gt; Wed Apr 09 08:53:54 CDT 2003
 *     
 */

static VALUE
rb_io_stat(obj)
    VALUE obj;
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr-&gt;f), &amp;st) == -1) {
	rb_sys_fail(fptr-&gt;path);
    }
    return stat_new(&amp;st);
}

/*
 *  call-seq:
 *     File.lstat(file_name)   =&gt; stat
 *  
 *  Same as &lt;code&gt;File::stat&lt;/code&gt;, but does not follow the last symbolic
 *  link. Instead, reports on the link itself.
 *     
 *     File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   #=&gt; 0
 *     File.stat(&quot;testfile&quot;).size              #=&gt; 66
 *     File.lstat(&quot;link2test&quot;).size            #=&gt; 8
 *     File.stat(&quot;link2test&quot;).size             #=&gt; 66
 *     
 */

static VALUE
rb_file_s_lstat(klass, fname)
    VALUE klass, fname;
{
#ifdef HAVE_LSTAT
    struct stat st;

    SafeStringValue(fname);
    if (lstat(StringValueCStr(fname), &amp;st) == -1) {
	rb_sys_fail(RSTRING(fname)-&gt;ptr);
    }
    return stat_new(&amp;st);
#else
    return rb_file_s_stat(klass, fname);
#endif
}


/*
 *  call-seq:
 *     file.lstat   =&gt;  stat
 *  
 *  Same as &lt;code&gt;IO#stat&lt;/code&gt;, but does not follow the last symbolic
 *  link. Instead, reports on the link itself.
 *     
 *     File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   #=&gt; 0
 *     File.stat(&quot;testfile&quot;).size              #=&gt; 66
 *     f = File.new(&quot;link2test&quot;)
 *     f.lstat.size                            #=&gt; 8
 *     f.stat.size                             #=&gt; 66
 */

static VALUE
rb_file_lstat(obj)
    VALUE obj;
{
#ifdef HAVE_LSTAT
    rb_io_t *fptr;
    struct stat st;

    rb_secure(2);
    GetOpenFile(obj, fptr);
    if (!fptr-&gt;path) return Qnil;
    if (lstat(fptr-&gt;path, &amp;st) == -1) {
	rb_sys_fail(fptr-&gt;path);
    }
    return stat_new(&amp;st);
#else
    return rb_io_stat(obj);
#endif
}

#ifndef HAVE_GROUP_MEMBER
static int
group_member(gid)
    GETGROUPS_T gid;
{
#ifndef _WIN32
    if (getgid() == gid || getegid() == gid)
	return Qtrue;

# ifdef HAVE_GETGROUPS
#  ifndef NGROUPS
#   ifdef NGROUPS_MAX
#    define NGROUPS NGROUPS_MAX
#   else
#    define NGROUPS 32
#   endif
#  endif
    {
	GETGROUPS_T gary[NGROUPS];
	int anum;

	anum = getgroups(NGROUPS, gary);
	while (--anum &gt;= 0)
	    if (gary[anum] == gid)
		return Qtrue;
    }
# endif
#endif
    return Qfalse;
}
#endif

#ifndef S_IXUGO
#  define S_IXUGO		(S_IXUSR | S_IXGRP | S_IXOTH)
#endif

#if defined(S_IXGRP) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)
#define USE_GETEUID 1
#endif

#ifndef HAVE_EACCESS
int
eaccess(path, mode)
     const char *path;
     int mode;
{
#ifdef USE_GETEUID
    struct stat st;
    int euid;

    if (stat(path, &amp;st) &lt; 0) return -1;

    euid = geteuid();

    if (euid == 0) {
	/* Root can read or write any file. */
	if (!(mode &amp; X_OK))
	    return 0;

	/* Root can execute any file that has any one of the execute
	   bits set. */
	if (st.st_mode &amp; S_IXUGO)
	    return 0;

	return -1;
    }

    if (st.st_uid == euid)        /* owner */
	mode &lt;&lt;= 6;
    else if (group_member(st.st_gid))
	mode &lt;&lt;= 3;

    if ((st.st_mode &amp; mode) == mode) return 0;

    return -1;
#else
# if defined(_MSC_VER) || defined(__MINGW32__)
    mode &amp;= ~1;
# endif
    return access(path, mode);
#endif
}
#endif


/*
 * Document-class: FileTest
 *
 *  &lt;code&gt;FileTest&lt;/code&gt; implements file test operations similar to
 *  those used in &lt;code&gt;File::Stat&lt;/code&gt;. It exists as a standalone
 *  module, and its methods are also insinuated into the &lt;code&gt;File&lt;/code&gt;
 *  class. (Note that this is not done by inclusion: the interpreter cheats).
 *     
 */


/*
 * call-seq:
 *   File.directory?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is a directory,
 * &lt;code&gt;false&lt;/code&gt; otherwise.
 *
 *    File.directory?(&quot;.&quot;)
 */

static VALUE
test_d(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISDIR
#   define S_ISDIR(m) ((m &amp; S_IFMT) == S_IFDIR)
#endif

    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISDIR(st.st_mode)) return Qtrue;
    return Qfalse;
}

/*
 * call-seq:
 *   File.pipe?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is a pipe.
 */

static VALUE
test_p(obj, fname)
    VALUE obj, fname;
{
#ifdef S_IFIFO
#  ifndef S_ISFIFO
#    define S_ISFIFO(m) ((m &amp; S_IFMT) == S_IFIFO)
#  endif

    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISFIFO(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}

/*
 * call-seq:
 *   File.symlink?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is a symbolic link.
 */

static VALUE
test_l(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISLNK
#  ifdef _S_ISLNK
#    define S_ISLNK(m) _S_ISLNK(m)
#  elif defined __BORLANDC__
#    ifdef _S_IFLNK
#      define S_ISLNK(m) (((unsigned short)(m) &amp; S_IFMT) == _S_IFLNK)
#    else
#      ifdef S_IFLNK
#        define S_ISLNK(m) (((unsigned short)(m) &amp; S_IFMT) == S_IFLNK)
#      endif
#    endif
#  else
#    ifdef _S_IFLNK
#      define S_ISLNK(m) ((m &amp; S_IFMT) == _S_IFLNK)
#    else
#      ifdef S_IFLNK
#	 define S_ISLNK(m) ((m &amp; S_IFMT) == S_IFLNK)
#      endif
#    endif
#  endif
#endif

#ifdef S_ISLNK
    struct stat st;

    SafeStringValue(fname);
    if (lstat(StringValueCStr(fname), &amp;st) &lt; 0) return Qfalse;
    if (S_ISLNK(st.st_mode)) return Qtrue;
#endif

    return Qfalse;
}

/*
 * call-seq:
 *   File.socket?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is a socket.
 */

static VALUE
test_S(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISSOCK
#  ifdef _S_ISSOCK
#    define S_ISSOCK(m) _S_ISSOCK(m)
#  elif defined __BORLANDC__
#    ifdef _S_IFSOCK
#      define S_ISSOCK(m) (((unsigned short)(m) &amp; S_IFMT) == _S_IFSOCK)
#    else
#      ifdef S_IFSOCK
#        define S_ISSOCK(m) (((unsigned short)(m) &amp; S_IFMT) == S_IFSOCK)
#      endif
#    endif
#  else
#    ifdef _S_IFSOCK
#      define S_ISSOCK(m) ((m &amp; S_IFMT) == _S_IFSOCK)
#    else
#      ifdef S_IFSOCK
#	 define S_ISSOCK(m) ((m &amp; S_IFMT) == S_IFSOCK)
#      endif
#    endif
#  endif
#endif

#ifdef S_ISSOCK
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISSOCK(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}

/*
 * call-seq:
 *   File.blockdev?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is a block device.
 */

static VALUE
test_b(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISBLK
#   ifdef S_IFBLK
#	define S_ISBLK(m) ((m &amp; S_IFMT) == S_IFBLK)
#   else
#	define S_ISBLK(m) (0)  /* anytime false */
#   endif
#endif

#ifdef S_ISBLK
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISBLK(st.st_mode)) return Qtrue;

#endif
    return Qfalse;
}

/*
 * call-seq:
 *   File.chardev?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is a character device.
 */
static VALUE
test_c(obj, fname)
    VALUE obj, fname;
{
#ifndef S_ISCHR
#   define S_ISCHR(m) ((m &amp; S_IFMT) == S_IFCHR)
#endif

    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISCHR(st.st_mode)) return Qtrue;

    return Qfalse;
}


/*
 * call-seq:
 *    File.exist?(file_name)    =&gt;  true or false
 *    File.exists?(file_name)   =&gt;  true or false    (obsolete)
 *
 * Return &lt;code&gt;true&lt;/code&gt; if the named file exists.
 */

static VALUE
test_e(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    return Qtrue;
}

/*
 * call-seq:
 *    File.readable?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is readable by the effective
 * user id of this process.
 */

static VALUE
test_r(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (eaccess(StringValueCStr(fname), R_OK) &lt; 0) return Qfalse;
    return Qtrue;
}

/*
 * call-seq:
 *    File.readable_real?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is readable by the real
 * user id of this process.
 */

static VALUE
test_R(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (access(StringValueCStr(fname), R_OK) &lt; 0) return Qfalse;
    return Qtrue;
}


/*
 * call-seq:
 *    File.writable?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is writable by the effective
 * user id of this process.
 */

static VALUE
test_w(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (eaccess(StringValueCStr(fname), W_OK) &lt; 0) return Qfalse;
    return Qtrue;
}

/*
 * call-seq:
 *    File.writable_real?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is writable by the real
 * user id of this process.
 */

static VALUE
test_W(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (access(StringValueCStr(fname), W_OK) &lt; 0) return Qfalse;
    return Qtrue;
}

/*
 * call-seq:
 *    File.executable?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is executable by the effective
 * user id of this process.
 */

static VALUE
test_x(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (eaccess(StringValueCStr(fname), X_OK) &lt; 0) return Qfalse;
    return Qtrue;
}

/*
 * call-seq:
 *    File.executable_real?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file is executable by the real
 * user id of this process.
 */

static VALUE
test_X(obj, fname)
    VALUE obj, fname;
{
    SafeStringValue(fname);
    if (access(StringValueCStr(fname), X_OK) &lt; 0) return Qfalse;
    return Qtrue;
}

#ifndef S_ISREG
#   define S_ISREG(m) ((m &amp; S_IFMT) == S_IFREG)
#endif

/*
 * call-seq:
 *    File.file?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file exists and is a
 * regular file.
 */

static VALUE
test_f(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (S_ISREG(st.st_mode)) return Qtrue;
    return Qfalse;
}

/*
 * call-seq:
 *    File.zero?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file exists and has
 * a zero size.
 */

static VALUE
test_z(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (st.st_size == 0) return Qtrue;
    return Qfalse;
}

/*
 * call-seq:
 *    File.size?(file_name)   =&gt; Integer or nil
 *
 * Returns +nil+ if +file_name+ doesn't exist or has zero size, the size of the
 * file otherwise.
 */

static VALUE
test_s(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qnil;
    if (st.st_size == 0) return Qnil;
    return OFFT2NUM(st.st_size);
}

/*
 * call-seq:
 *    File.owned?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file exists and the
 * effective used id of the calling process is the owner of
 * the file.
 */

static VALUE
test_owned(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (st.st_uid == geteuid()) return Qtrue;
    return Qfalse;
}

static VALUE
test_rowned(obj, fname)
    VALUE obj, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (st.st_uid == getuid()) return Qtrue;
    return Qfalse;
}

/*
 * call-seq:
 *    File.grpowned?(file_name)   =&gt; true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file exists and the
 * effective group id of the calling process is the owner of
 * the file. Returns &lt;code&gt;false&lt;/code&gt; on Windows.
 */

static VALUE
test_grpowned(obj, fname)
    VALUE obj, fname;
{
#ifndef _WIN32
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0) return Qfalse;
    if (group_member(st.st_gid)) return Qtrue;
#endif
    return Qfalse;
}

#if defined(S_ISUID) || defined(S_ISGID) || defined(S_ISVTX)
static VALUE
check3rdbyte(fname, mode)
    VALUE fname;
    int mode;
{
    struct stat st;

    SafeStringValue(fname);
    if (stat(StringValueCStr(fname), &amp;st) &lt; 0) return Qfalse;
    if (st.st_mode &amp; mode) return Qtrue;
    return Qfalse;
}
#endif

/*
 * call-seq:
 *   File.setuid?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file has the setuid bit set.
 */

static VALUE
test_suid(obj, fname)
    VALUE obj, fname;
{
#ifdef S_ISUID
    return check3rdbyte(fname, S_ISUID);
#else
    return Qfalse;
#endif
}

/*
 * call-seq:
 *   File.setgid?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file has the setgid bit set.
 */

static VALUE
test_sgid(obj, fname)
    VALUE obj, fname;
{
#ifdef S_ISGID
    return check3rdbyte(fname, S_ISGID);
#else
    return Qfalse;
#endif
}

/*
 * call-seq:
 *   File.sticky?(file_name)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named file has the sticky bit set.
 */

static VALUE
test_sticky(obj, fname)
    VALUE obj, fname;
{
#ifdef S_ISVTX
    return check3rdbyte(fname, S_ISVTX);
#else
    return Qnil;
#endif
}

/*
 * call-seq:
 *   File.identical?(file_1, file_2)   =&gt;  true or false
 *
 * Returns &lt;code&gt;true&lt;/code&gt; if the named files are identical.
 *
 *     open(&quot;a&quot;, &quot;w&quot;) {}
 *     p File.identical?(&quot;a&quot;, &quot;a&quot;)      #=&gt; true
 *     p File.identical?(&quot;a&quot;, &quot;./a&quot;)    #=&gt; true
 *     File.link(&quot;a&quot;, &quot;b&quot;)
 *     p File.identical?(&quot;a&quot;, &quot;b&quot;)      #=&gt; true
 *     File.symlink(&quot;a&quot;, &quot;c&quot;)
 *     p File.identical?(&quot;a&quot;, &quot;c&quot;)      #=&gt; true
 *     open(&quot;d&quot;, &quot;w&quot;) {}
 *     p File.identical?(&quot;a&quot;, &quot;d&quot;)      #=&gt; false
 */

static VALUE
test_identical(obj, fname1, fname2)
    VALUE obj, fname1, fname2;
{
#ifndef DOSISH
    struct stat st1, st2;

    if (rb_stat(fname1, &amp;st1) &lt; 0) return Qfalse;
    if (rb_stat(fname2, &amp;st2) &lt; 0) return Qfalse;
    if (st1.st_dev != st2.st_dev) return Qfalse;
    if (st1.st_ino != st2.st_ino) return Qfalse;
#else
#ifdef _WIN32
    BY_HANDLE_FILE_INFORMATION st1, st2;
    HANDLE f1 = 0, f2 = 0;
#endif

    rb_secure(2);
#ifdef _WIN32
    f1 = w32_io_info(&amp;fname1, &amp;st1);
    if (f1 == INVALID_HANDLE_VALUE) return Qfalse;
    f2 = w32_io_info(&amp;fname2, &amp;st2);
    if (f1) CloseHandle(f1);
    if (f2 == INVALID_HANDLE_VALUE) return Qfalse;
    if (f2) CloseHandle(f2);

    if (st1.dwVolumeSerialNumber == st2.dwVolumeSerialNumber &amp;&amp;
	st1.nFileIndexHigh == st2.nFileIndexHigh &amp;&amp;
	st1.nFileIndexLow == st2.nFileIndexLow)
	return Qtrue;
    if (!f1 || !f2) return Qfalse;
    if (rb_w32_iswin95()) return Qfalse;
#else
    SafeStringValue(fname1);
    fname1 = rb_str_new4(fname1);
    SafeStringValue(fname2);
    if (access(RSTRING(fname1)-&gt;ptr, 0)) return Qfalse;
    if (access(RSTRING(fname2)-&gt;ptr, 0)) return Qfalse;
#endif
    fname1 = rb_file_expand_path(fname1, Qnil);
    fname2 = rb_file_expand_path(fname2, Qnil);
    if (RSTRING(fname1)-&gt;len != RSTRING(fname2)-&gt;len) return Qfalse;
    if (rb_memcicmp(RSTRING(fname1)-&gt;ptr, RSTRING(fname2)-&gt;ptr, RSTRING(fname1)-&gt;len))
	return Qfalse;
#endif
    return Qtrue;
}

/*
 * call-seq:
 *    File.size(file_name)   =&gt; integer
 *
 * Returns the size of &lt;code&gt;file_name&lt;/code&gt;.
 */

static VALUE
rb_file_s_size(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0)
	rb_sys_fail(StringValueCStr(fname));
    return OFFT2NUM(st.st_size);
}

static VALUE
rb_file_ftype(st)
    struct stat *st;
{
    const char *t;

    if (S_ISREG(st-&gt;st_mode)) {
	t = &quot;file&quot;;
    }
    else if (S_ISDIR(st-&gt;st_mode)) {
	t = &quot;directory&quot;;
    }
    else if (S_ISCHR(st-&gt;st_mode)) {
	t = &quot;characterSpecial&quot;;
    }
#ifdef S_ISBLK
    else if (S_ISBLK(st-&gt;st_mode)) {
	t = &quot;blockSpecial&quot;;
    }
#endif
#ifdef S_ISFIFO
    else if (S_ISFIFO(st-&gt;st_mode)) {
	t = &quot;fifo&quot;;
    }
#endif
#ifdef S_ISLNK
    else if (S_ISLNK(st-&gt;st_mode)) {
	t = &quot;link&quot;;
    }
#endif
#ifdef S_ISSOCK
    else if (S_ISSOCK(st-&gt;st_mode)) {
	t = &quot;socket&quot;;
    }
#endif
    else {
	t = &quot;unknown&quot;;
    }

    return rb_str_new2(t);
}

/*
 *  call-seq:
 *     File.ftype(file_name)   =&gt; string
 *  
 *  Identifies the type of the named file; the return string is one of
 *  ``&lt;code&gt;file&lt;/code&gt;'', ``&lt;code&gt;directory&lt;/code&gt;'',
 *  ``&lt;code&gt;characterSpecial&lt;/code&gt;'', ``&lt;code&gt;blockSpecial&lt;/code&gt;'',
 *  ``&lt;code&gt;fifo&lt;/code&gt;'', ``&lt;code&gt;link&lt;/code&gt;'',
 *  ``&lt;code&gt;socket&lt;/code&gt;'', or ``&lt;code&gt;unknown&lt;/code&gt;''.
 *     
 *     File.ftype(&quot;testfile&quot;)            #=&gt; &quot;file&quot;
 *     File.ftype(&quot;/dev/tty&quot;)            #=&gt; &quot;characterSpecial&quot;
 *     File.ftype(&quot;/tmp/.X11-unix/X0&quot;)   #=&gt; &quot;socket&quot;
 */

static VALUE
rb_file_s_ftype(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    SafeStringValue(fname);
    if (lstat(StringValueCStr(fname), &amp;st) == -1) {
	rb_sys_fail(RSTRING(fname)-&gt;ptr);
    }

    return rb_file_ftype(&amp;st);
}

/*
 *  call-seq:
 *     File.atime(file_name)  =&gt;  time
 *  
 *  Returns the last access time for the named file as a Time object).
 *     
 *     File.atime(&quot;testfile&quot;)   #=&gt; Wed Apr 09 08:51:48 CDT 2003
 *     
 */

static VALUE
rb_file_s_atime(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0)
	rb_sys_fail(StringValueCStr(fname));
    return rb_time_new(st.st_atime, 0);
}

/*
 *  call-seq:
 *     file.atime    =&gt; time
 *  
 *  Returns the last access time (a &lt;code&gt;Time&lt;/code&gt; object)
 *   for &lt;i&gt;file&lt;/i&gt;, or epoch if &lt;i&gt;file&lt;/i&gt; has not been accessed.
 *     
 *     File.new(&quot;testfile&quot;).atime   #=&gt; Wed Dec 31 18:00:00 CST 1969
 *     
 */

static VALUE
rb_file_atime(obj)
    VALUE obj;
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr-&gt;f), &amp;st) == -1) {
	rb_sys_fail(fptr-&gt;path);
    }
    return rb_time_new(st.st_atime, 0);
}

/*
 *  call-seq:
 *     File.mtime(file_name)  =&gt;  time
 *  
 *  Returns the modification time for the named file as a Time object.
 *     
 *     File.mtime(&quot;testfile&quot;)   #=&gt; Tue Apr 08 12:58:04 CDT 2003
 *     
 */

static VALUE
rb_file_s_mtime(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0)
	rb_sys_fail(RSTRING(fname)-&gt;ptr);
    return rb_time_new(st.st_mtime, 0);
}

/*
 *  call-seq:
 *     file.mtime -&gt; time
 *  
 *  Returns the modification time for &lt;i&gt;file&lt;/i&gt;.
 *     
 *     File.new(&quot;testfile&quot;).mtime   #=&gt; Wed Apr 09 08:53:14 CDT 2003
 *     
 */

static VALUE
rb_file_mtime(obj)
    VALUE obj;
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr-&gt;f), &amp;st) == -1) {
	rb_sys_fail(fptr-&gt;path);
    }
    return rb_time_new(st.st_mtime, 0);
}

/*
 *  call-seq:
 *     File.ctime(file_name)  =&gt; time
 *  
 *  Returns the change time for the named file (the time at which
 *  directory information about the file was changed, not the file
 *  itself).
 *     
 *     File.ctime(&quot;testfile&quot;)   #=&gt; Wed Apr 09 08:53:13 CDT 2003
 *     
 */

static VALUE
rb_file_s_ctime(klass, fname)
    VALUE klass, fname;
{
    struct stat st;

    if (rb_stat(fname, &amp;st) &lt; 0)
	rb_sys_fail(RSTRING(fname)-&gt;ptr);
    return rb_time_new(st.st_ctime, 0);
}

/*
 *  call-seq:
 *     file.ctime -&gt; time
 *  
 *  Returns the change time for &lt;i&gt;file&lt;/i&gt; (that is, the time directory
 *  information about the file was changed, not the file itself).
 *     
 *     File.new(&quot;testfile&quot;).ctime   #=&gt; Wed Apr 09 08:53:14 CDT 2003
 *     
 */

static VALUE
rb_file_ctime(obj)
    VALUE obj;
{
    rb_io_t *fptr;
    struct stat st;

    GetOpenFile(obj, fptr);
    if (fstat(fileno(fptr-&gt;f), &amp;st) == -1) {
	rb_sys_fail(fptr-&gt;path);
    }
    return rb_time_new(st.st_ctime, 0);
}

static void chmod_internal _((const char *, void *));
static void
chmod_internal(path, mode)
    const char *path;
    void *mode;
{
    if (chmod(path, *(int *)mode) &lt; 0)
	rb_sys_fail(path);
}

/*
 *  call-seq:
 *     File.chmod(mode_int, file_name, ... ) -&gt; integer
 *  
 *  Changes permission bits on the named file(s) to the bit pattern
 *  represented by &lt;i&gt;mode_int&lt;/i&gt;. Actual effects are operating system
 *  dependent (see the beginning of this section). On Unix systems, see
 *  &lt;code&gt;chmod(2)&lt;/code&gt; for details. Returns the number of files
 *  processed.
 *     
 *     File.chmod(0644, &quot;testfile&quot;, &quot;out&quot;)   #=&gt; 2
 */

static VALUE
rb_file_s_chmod(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE vmode;
    VALUE rest;
    int mode;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, &quot;1*&quot;, &amp;vmode, &amp;rest);
    mode = NUM2INT(vmode);

    n = apply2files(chmod_internal, rest, &amp;mode);
    return LONG2FIX(n);
}

/*
 *  call-seq:
 *     file.chmod(mode_int)   =&gt; 0
 *  
 *  Changes permission bits on &lt;i&gt;file&lt;/i&gt; to the bit pattern
 *  represented by &lt;i&gt;mode_int&lt;/i&gt;. Actual effects are platform
 *  dependent; on Unix systems, see &lt;code&gt;chmod(2)&lt;/code&gt; for details.
 *  Follows symbolic links. Also see &lt;code&gt;File#lchmod&lt;/code&gt;.
 *     
 *     f = File.new(&quot;out&quot;, &quot;w&quot;);
 *     f.chmod(0644)   #=&gt; 0
 */

static VALUE
rb_file_chmod(obj, vmode)
    VALUE obj, vmode;
{
    rb_io_t *fptr;
    int mode;

    rb_secure(2);
    mode = NUM2INT(vmode);

    GetOpenFile(obj, fptr);
#ifdef HAVE_FCHMOD
    if (fchmod(fileno(fptr-&gt;f), mode) == -1)
	rb_sys_fail(fptr-&gt;path);
#else
    if (!fptr-&gt;path) return Qnil;
    if (chmod(fptr-&gt;path, mode) == -1)
	rb_sys_fail(fptr-&gt;path);
#endif

    return INT2FIX(0);
}

#if defined(HAVE_LCHMOD)
static void lchmod_internal _((const char *, void *));
static void
lchmod_internal(path, mode)
    const char *path;
    void *mode;
{
    if (lchmod(path, (int)(VALUE)mode) &lt; 0)
	rb_sys_fail(path);
}

/*
 *  call-seq:
 *     File.lchmod(mode_int, file_name, ...)  =&gt; integer
 *  
 *  Equivalent to &lt;code&gt;File::chmod&lt;/code&gt;, but does not follow symbolic
 *  links (so it will change the permissions associated with the link,
 *  not the file referenced by the link). Often not available.
 *     
 */

static VALUE
rb_file_s_lchmod(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE vmode;
    VALUE rest;
    long mode, n;

    rb_secure(2);
    rb_scan_args(argc, argv, &quot;1*&quot;, &amp;vmode, &amp;rest);
    mode = NUM2INT(vmode);

    n = apply2files(lchmod_internal, rest, (void *)(long)mode);
    return LONG2FIX(n);
}
#else
static VALUE
rb_file_s_lchmod(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_notimplement();
    return Qnil;		/* not reached */
}
#endif

struct chown_args {
    int owner, group;
};

static void chown_internal _((const char *, void *));
static void
chown_internal(path, argp)
    const char *path;
    void *argp;
{
    struct chown_args *args = (struct chown_args *)argp;
    if (chown(path, args-&gt;owner, args-&gt;group) &lt; 0)
	rb_sys_fail(path);
}

/*
 *  call-seq:
 *     File.chown(owner_int, group_int, file_name,... ) -&gt; integer
 *  
 *  Changes the owner and group of the named file(s) to the given
 *  numeric owner and group id's. Only a process with superuser
 *  privileges may change the owner of a file. The current owner of a
 *  file may change the file's group to any group to which the owner
 *  belongs. A &lt;code&gt;nil&lt;/code&gt; or -1 owner or group id is ignored.
 *  Returns the number of files processed.
 *     
 *     File.chown(nil, 100, &quot;testfile&quot;)
 *     
 */

static VALUE
rb_file_s_chown(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE o, g, rest;
    struct chown_args arg;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, &quot;2*&quot;, &amp;o, &amp;g, &amp;rest);
    if (NIL_P(o)) {
	arg.owner = -1;
    }
    else {
	arg.owner = NUM2INT(o);
    }
    if (NIL_P(g)) {
	arg.group = -1;
    }
    else {
	arg.group = NUM2INT(g);
    }

    n = apply2files(chown_internal, rest, &amp;arg);
    return LONG2FIX(n);
}

/*
 *  call-seq:
 *     file.chown(owner_int, group_int )   =&gt; 0
 *  
 *  Changes the owner and group of &lt;i&gt;file&lt;/i&gt; to the given numeric
 *  owner and group id's. Only a process with superuser privileges may
 *  change the owner of a file. The current owner of a file may change
 *  the file's group to any group to which the owner belongs. A
 *  &lt;code&gt;nil&lt;/code&gt; or -1 owner or group id is ignored. Follows
 *  symbolic links. See also &lt;code&gt;File#lchown&lt;/code&gt;.
 *     
 *     File.new(&quot;testfile&quot;).chown(502, 1000)
 *     
 */

static VALUE
rb_file_chown(obj, owner, group)
    VALUE obj, owner, group;
{
    rb_io_t *fptr;
    int o, g;

    rb_secure(2);
    o = NIL_P(owner) ? -1 : NUM2INT(owner);
    g = NIL_P(group) ? -1 : NUM2INT(group);
    GetOpenFile(obj, fptr);
#if defined(DJGPP) || defined(__CYGWIN32__) || defined(_WIN32) || defined(__EMX__)
    if (!fptr-&gt;path) return Qnil;
    if (chown(fptr-&gt;path, o, g) == -1)
	rb_sys_fail(fptr-&gt;path);
#else
    if (fchown(fileno(fptr-&gt;f), o, g) == -1)
	rb_sys_fail(fptr-&gt;path);
#endif

    return INT2FIX(0);
}

#if defined(HAVE_LCHOWN) &amp;&amp; !defined(__CHECKER__)
static void lchown_internal _((const char *, void *));
static void
lchown_internal(path, argp)
    const char *path;
    void *argp;
{
    struct chown_args *args = (struct chown_args *)argp;
    if (lchown(path, args-&gt;owner, args-&gt;group) &lt; 0)
	rb_sys_fail(path);
}


/*
 *  call-seq:
 *     file.lchown(owner_int, group_int, file_name,..) =&gt; integer
 *  
 *  Equivalent to &lt;code&gt;File::chown&lt;/code&gt;, but does not follow symbolic
 *  links (so it will change the owner associated with the link, not the
 *  file referenced by the link). Often not available. Returns number
 *  of files in the argument list.
 *     
 */

static VALUE
rb_file_s_lchown(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE o, g, rest;
    struct chown_args arg;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, &quot;2*&quot;, &amp;o, &amp;g, &amp;rest);
    if (NIL_P(o)) {
	arg.owner = -1;
    }
    else {
	arg.owner = NUM2INT(o);
    }
    if (NIL_P(g)) {
	arg.group = -1;
    }
    else {
	arg.group = NUM2INT(g);
    }

    n = apply2files(lchown_internal, rest, &amp;arg);
    return LONG2FIX(n);
}
#else
static VALUE
rb_file_s_lchown(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_notimplement();
}
#endif

struct timeval rb_time_timeval();

static void utime_internal _((const char *, void *));

#if defined(HAVE_UTIMES) &amp;&amp; !defined(__CHECKER__)

static void
utime_internal(path, arg)
    const char *path;
    void *arg;
{
    struct timeval *tvp = arg;
    if (utimes(path, tvp) &lt; 0)
	rb_sys_fail(path);
}

/*
 * call-seq:
 *  File.utime(atime, mtime, file_name,...)   =&gt;  integer
 *
 * Sets the access and modification times of each
 * named file to the first two arguments. Returns
 * the number of file names in the argument list.
 */

static VALUE
rb_file_s_utime(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE atime, mtime, rest;
    struct timeval tvs[2], *tvp = NULL;
    long n;

    rb_secure(2);
    rb_scan_args(argc, argv, &quot;2*&quot;, &amp;atime, &amp;mtime, &amp;rest);

    if (!NIL_P(atime) || !NIL_P(mtime)) {
	tvp = tvs;
	tvp[0] = rb_time_timeval(atime);
	tvp[1] = rb_time_timeval(mtime);
    }

    n = apply2files(utime_internal, rest, tvp);
    return LONG2FIX(n);
}

#else

#if !defined HAVE_UTIME_H &amp;&amp; !defined HAVE_SYS_UTIME_H
struct utimbuf {
    long actime;
    long modtime;
};
#endif

static void
utime_internal(path, arg)
    const char *path;
    void *arg;
{
    struct utimbuf *utp = arg;
    if (utime(path, utp) &lt; 0)
	rb_sys_fail(path);
}

static VALUE
rb_file_s_utime(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE atime, mtime, rest;
    long n;
    struct timeval tv;
    struct utimbuf utbuf, *utp = NULL;

    rb_scan_args(argc, argv, &quot;2*&quot;, &amp;atime, &amp;mtime, &amp;rest);

    if (!NIL_P(atime) || !NIL_P(mtime)) {
	utp = &amp;utbuf;
	tv = rb_time_timeval(atime);
	utp-&gt;actime = tv.tv_sec;
	tv = rb_time_timeval(mtime);
	utp-&gt;modtime = tv.tv_sec;
    }

    n = apply2files(utime_internal, rest, utp);
    return LONG2FIX(n);
}

#endif

NORETURN(static void sys_fail2 _((VALUE,VALUE)));
static void
sys_fail2(s1, s2)
    VALUE s1, s2;
{
    char *buf;
    int len;

    len = RSTRING(s1)-&gt;len + RSTRING(s2)-&gt;len + 5;
    buf = ALLOCA_N(char, len);
    snprintf(buf, len, &quot;%s or %s&quot;, RSTRING(s1)-&gt;ptr, RSTRING(s2)-&gt;ptr);
    rb_sys_fail(buf);
}

/*
 *  call-seq:
 *     File.link(old_name, new_name)    =&gt; 0
 *  
 *  Creates a new name for an existing file using a hard link. Will not
 *  overwrite &lt;i&gt;new_name&lt;/i&gt; if it already exists (raising a subclass
 *  of &lt;code&gt;SystemCallError&lt;/code&gt;). Not available on all platforms.
 *     
 *     File.link(&quot;testfile&quot;, &quot;.testfile&quot;)   #=&gt; 0
 *     IO.readlines(&quot;.testfile&quot;)[0]         #=&gt; &quot;This is line one\n&quot;
 */

static VALUE
rb_file_s_link(klass, from, to)
    VALUE klass, from, to;
{
#ifdef HAVE_LINK
    SafeStringValue(from);
    SafeStringValue(to);

    if (link(StringValueCStr(from), StringValueCStr(to)) &lt; 0) {
	sys_fail2(from, to);
    }
    return INT2FIX(0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

/*
 *  call-seq:
 *     File.symlink(old_name, new_name)   =&gt; 0
 *  
 *  Creates a symbolic link called &lt;i&gt;new_name&lt;/i&gt; for the existing file
 *  &lt;i&gt;old_name&lt;/i&gt;. Raises a &lt;code&gt;NotImplemented&lt;/code&gt; exception on
 *  platforms that do not support symbolic links.
 *     
 *     File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   #=&gt; 0
 *     
 */

static VALUE
rb_file_s_symlink(klass, from, to)
    VALUE klass, from, to;
{
#ifdef HAVE_SYMLINK
    SafeStringValue(from);
    SafeStringValue(to);

    if (symlink(StringValueCStr(from), StringValueCStr(to)) &lt; 0) {
	sys_fail2(from, to);
    }
    return INT2FIX(0);
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

/*
 *  call-seq:
 *     File.readlink(link_name) -&gt; file_name
 *  
 *  Returns the name of the file referenced by the given link.
 *  Not available on all platforms.
 *     
 *     File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   #=&gt; 0
 *     File.readlink(&quot;link2test&quot;)              #=&gt; &quot;testfile&quot;
 */

static VALUE
rb_file_s_readlink(klass, path)
    VALUE klass, path;
{
#ifdef HAVE_READLINK
    char *buf;
    int size = 100;
    int rv;
    VALUE v;

    SafeStringValue(path);
    buf = xmalloc(size);
    while ((rv = readlink(RSTRING(path)-&gt;ptr, buf, size)) == size
#ifdef _AIX
	    || (rv &lt; 0 &amp;&amp; errno == ERANGE) /* quirky behavior of GPFS */
#endif
	) {
	size *= 2;
	buf = xrealloc(buf, size);
    }
    if (rv &lt; 0) {
	free(buf);
	rb_sys_fail(RSTRING(path)-&gt;ptr);
    }
    v = rb_tainted_str_new(buf, rv);
    free(buf);

    return v;
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}

static void unlink_internal _((const char *, void *));
static void
unlink_internal(path, arg)
    const char *path;
    void *arg;
{
    if (unlink(path) &lt; 0)
	rb_sys_fail(path);
}

/*
 *  call-seq:
 *     File.delete(file_name, ...)  =&gt; integer
 *     File.unlink(file_name, ...)  =&gt; integer
 *  
 *  Deletes the named files, returning the number of names
 *  passed as arguments. Raises an exception on any error.
 *  See also &lt;code&gt;Dir::rmdir&lt;/code&gt;.
 */

static VALUE
rb_file_s_unlink(klass, args)
    VALUE klass, args;
{
    long n;

    rb_secure(2);
    n = apply2files(unlink_internal, args, 0);
    return LONG2FIX(n);
}

/*
 *  call-seq:
 *     File.rename(old_name, new_name)   =&gt; 0
 *  
 *  Renames the given file to the new name. Raises a
 *  &lt;code&gt;SystemCallError&lt;/code&gt; if the file cannot be renamed.
 *     
 *     File.rename(&quot;afile&quot;, &quot;afile.bak&quot;)   #=&gt; 0
 */

static VALUE
rb_file_s_rename(klass, from, to)
    VALUE klass, from, to;
{
    const char *src, *dst;
    SafeStringValue(from);
    SafeStringValue(to);

    src = StringValueCStr(from);
    dst = StringValueCStr(to);
#if defined __CYGWIN__
    errno = 0;
#endif
    if (rename(src, dst) &lt; 0) {
#if defined DOSISH &amp;&amp; !defined _WIN32
	switch (errno) {
	  case EEXIST:
#if defined (__EMX__)
	  case EACCES:
#endif
	    if (chmod(dst, 0666) == 0 &amp;&amp;
		unlink(dst) == 0 &amp;&amp;
		rename(src, dst) == 0)
		return INT2FIX(0);
	}
#endif
	sys_fail2(from, to);
    }

    return INT2FIX(0);
}

/*
 *  call-seq:
 *     File.umask()          =&gt; integer
 *     File.umask(integer)   =&gt; integer
 *  
 *  Returns the current umask value for this process. If the optional
 *  argument is given, set the umask to that value and return the
 *  previous value. Umask values are &lt;em&gt;subtracted&lt;/em&gt; from the
 *  default permissions, so a umask of &lt;code&gt;0222&lt;/code&gt; would make a
 *  file read-only for everyone.
 *     
 *     File.umask(0006)   #=&gt; 18
 *     File.umask         #=&gt; 6
 */

static VALUE
rb_file_s_umask(argc, argv)
    int argc;
    VALUE *argv;
{
    int omask = 0;

    rb_secure(2);
    if (argc == 0) {
	omask = umask(0);
	umask(omask);
    }
    else if (argc == 1) {
	omask = umask(NUM2INT(argv[0]));
    }
    else {
	rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }
    return INT2FIX(omask);
}

#ifdef __CYGWIN__
#undef DOSISH
#endif
#if defined __CYGWIN__ || defined DOSISH
#define DOSISH_UNC
#define DOSISH_DRIVE_LETTER
#define isdirsep(x) ((x) == '/' || (x) == '\\')
#else
#define isdirsep(x) ((x) == '/')
#endif

#if defined _WIN32 || defined __CYGWIN__
#define USE_NTFS 1
#else
#define USE_NTFS 0
#endif

#ifdef DOSISH_DRIVE_LETTER
#include &lt;ctype.h&gt;
#endif

#if USE_NTFS
#define istrailinggabage(x) ((x) == '.' || (x) == ' ')
#else
#define istrailinggabage(x) 0
#endif

#ifndef CharNext		/* defined as CharNext[AW] on Windows. */
# if defined(DJGPP)
#   define CharNext(p) ((p) + mblen(p, MB_CUR_MAX))
# else
#   define CharNext(p) ((p) + 1)
# endif
#endif

#ifdef DOSISH_DRIVE_LETTER
static inline int
has_drive_letter(buf)
    const char *buf;
{
    if (ISALPHA(buf[0]) &amp;&amp; buf[1] == ':') {
	return 1;
    }
    else {
	return 0;
    }
}

static char*
getcwdofdrv(drv)
    int drv;
{
    char drive[4];
    char *drvcwd, *oldcwd;

    drive[0] = drv;
    drive[1] = ':';
    drive[2] = '\0';

    /* the only way that I know to get the current directory
       of a particular drive is to change chdir() to that drive,
       so save the old cwd before chdir()
    */
    oldcwd = my_getcwd();
    if (chdir(drive) == 0) {
	drvcwd = my_getcwd();
	chdir(oldcwd);
	free(oldcwd);
    }
    else {
	/* perhaps the drive is not exist. we return only drive letter */
	drvcwd = strdup(drive);
    }
    return drvcwd;
}
#endif

static inline char *
skiproot(path)
    const char *path;
{
#ifdef DOSISH_DRIVE_LETTER
    if (has_drive_letter(path)) path += 2;
#endif
    while (isdirsep(*path)) path++;
    return (char *)path;
}

#define nextdirsep rb_path_next
char *
rb_path_next(s)
    const char *s;
{
    while (*s &amp;&amp; !isdirsep(*s)) {
	s = CharNext(s);
    }
    return (char *)s;
}

#if defined(DOSISH_UNC) || defined(DOSISH_DRIVE_LETTER) 
#define skipprefix rb_path_skip_prefix
#else
#define skipprefix(path) (path)
#endif
char *
rb_path_skip_prefix(path)
    const char *path;
{
#if defined(DOSISH_UNC) || defined(DOSISH_DRIVE_LETTER) 
#ifdef DOSISH_UNC
    if (isdirsep(path[0]) &amp;&amp; isdirsep(path[1])) {
	path += 2;
	while (isdirsep(*path)) path++;
	if (*(path = nextdirsep(path)) &amp;&amp; path[1] &amp;&amp; !isdirsep(path[1]))
	    path = nextdirsep(path + 1);
	return (char *)path;
    }
#endif
#ifdef DOSISH_DRIVE_LETTER
    if (has_drive_letter(path))
	return (char *)(path + 2);
#endif
#endif
    return (char *)path;
}

#define strrdirsep rb_path_last_separator
char *
rb_path_last_separator(path)
    const char *path;
{
    char *last = NULL;
    while (*path) {
	if (isdirsep(*path)) {
	    const char *tmp = path++;
	    while (isdirsep(*path)) path++;
	    if (!*path) break;
	    last = (char *)tmp;
	}
	else {
	    path = CharNext(path);
	}
    }
    return last;
}

static char *
chompdirsep(path)
    const char *path;
{
    while (*path) {
	if (isdirsep(*path)) {
	    const char *last = path++;
	    while (isdirsep(*path)) path++;
	    if (!*path) return (char *)last;
	}
	else {
	    path = CharNext(path);
	}
    }
    return (char *)path;
}

char *
rb_path_end(path)
    const char *path;
{
    if (isdirsep(*path)) path++;
    return chompdirsep(path);
}

#if USE_NTFS
static char *
ntfs_tail(const char *path)
{
    while (*path == '.') path++;
    while (*path &amp;&amp; *path != ':') {
	if (istrailinggabage(*path)) {
	    const char *last = path++;
	    while (istrailinggabage(*path)) path++;
	    if (!*path || *path == ':') return (char *)last;
	}
	else if (isdirsep(*path)) {
	    const char *last = path++;
	    while (isdirsep(*path)) path++;
	    if (!*path) return (char *)last;
	    if (*path == ':') path++;
	}
	else {
	    path = CharNext(path);
	}
    }
    return (char *)path;
}
#endif

#define BUFCHECK(cond) do {\
    long bdiff = p - buf;\
    if (cond) {\
	do {buflen *= 2;} while (cond);\
	rb_str_resize(result, buflen);\
	buf = RSTRING_PTR(result);\
	p = buf + bdiff;\
	pend = buf + buflen;\
    }\
} while (0)

#define BUFINIT() (\
    p = buf = RSTRING(result)-&gt;ptr,\
    buflen = RSTRING(result)-&gt;len,\
    pend = p + buflen)

#if !defined(TOLOWER)
#define TOLOWER(c) (ISUPPER(c) ? tolower(c) : (c))
#endif

static int is_absolute_path _((const char*));

static VALUE
file_expand_path(fname, dname, result)
    VALUE fname, dname, result;
{
    const char *s, *b;
    char *buf, *p, *pend, *root;
    long buflen, dirlen;
    int tainted;

    s = StringValuePtr(fname);
    BUFINIT();
    tainted = OBJ_TAINTED(fname);

    if (s[0] == '~') {
	if (isdirsep(s[1]) || s[1] == '\0') {
	    const char *dir = getenv(&quot;HOME&quot;);

	    if (!dir) {
		rb_raise(rb_eArgError, &quot;couldn't find HOME environment -- expanding `%s'&quot;, s);
	    }
	    dirlen = strlen(dir);
	    BUFCHECK(dirlen &gt; buflen);
	    strcpy(buf, dir);
#if defined DOSISH || defined __CYGWIN__
	    for (p = buf; *p; p = CharNext(p)) {
		if (*p == '\\') {
		    *p = '/';
		}
	    }
#else
	    p = buf + strlen(dir);
#endif
	    s++;
	    tainted = 1;
	}
	else {
#ifdef HAVE_PWD_H
	    struct passwd *pwPtr;
	    s++;
#endif
	    s = nextdirsep(b = s);
	    BUFCHECK(bdiff + (s-b) &gt;= buflen);
	    memcpy(p, b, s-b);
	    p += s-b;
	    *p = '\0';
#ifdef HAVE_PWD_H
	    pwPtr = getpwnam(buf);
	    if (!pwPtr) {
		endpwent();
		rb_raise(rb_eArgError, &quot;user %s doesn't exist&quot;, buf);
	    }
	    dirlen = strlen(pwPtr-&gt;pw_dir);
	    BUFCHECK(dirlen &gt; buflen);
	    strcpy(buf, pwPtr-&gt;pw_dir);
	    p = buf + strlen(pwPtr-&gt;pw_dir);
	    endpwent();
#endif
	}
    }
#ifdef DOSISH_DRIVE_LETTER
    /* skip drive letter */
    else if (has_drive_letter(s)) {
	if (isdirsep(s[2])) {
	    /* specified drive letter, and full path */
	    /* skip drive letter */
	    BUFCHECK(bdiff + 2 &gt;= buflen);
	    memcpy(p, s, 2);
	    p += 2;
	    s += 2;
	}
	else {
	    /* specified drive, but not full path */
	    int same = 0;
	    if (!NIL_P(dname)) {
		file_expand_path(dname, Qnil, result);
		BUFINIT();
		if (has_drive_letter(p) &amp;&amp; TOLOWER(p[0]) == TOLOWER(s[0])) {
		    /* ok, same drive */
		    same = 1;
		}
	    }
	    if (!same) {
		char *dir = getcwdofdrv(*s);

		tainted = 1;
		dirlen = strlen(dir);
		BUFCHECK(dirlen &gt; buflen);
		strcpy(buf, dir);
		free(dir);
	    }
	    p = chompdirsep(skiproot(buf));
	    s += 2;
	}
    }
#endif
    else if (!is_absolute_path(s)) {
	if (!NIL_P(dname)) {
	    file_expand_path(dname, Qnil, result);
	    BUFINIT();
	}
	else {
	    char *dir = my_getcwd();

	    tainted = 1;
	    dirlen = strlen(dir);
	    BUFCHECK(dirlen &gt; buflen);
	    strcpy(buf, dir);
	    free(dir);
	}
#if defined DOSISH || defined __CYGWIN__
	if (isdirsep(*s)) {
	    /* specified full path, but not drive letter nor UNC */
	    /* we need to get the drive letter or UNC share name */
	    p = skipprefix(buf);
	}
	else
#endif
	    p = chompdirsep(skiproot(buf));
    }
    else {
	b = s;
	do s++; while (isdirsep(*s));
	p = buf + (s - b);
	BUFCHECK(bdiff &gt;= buflen);
	memset(buf, '/', p - buf);
    }
    if (p &gt; buf &amp;&amp; p[-1] == '/')
	--p;
    else
	*p = '/';

    p[1] = 0;
    root = skipprefix(buf);

    b = s;
    while (*s) {
	switch (*s) {
	  case '.':
	    if (b == s++) {	/* beginning of path element */
		switch (*s) {
		  case '\0':
		    b = s;
		    break;
		  case '.':
		    if (*(s+1) == '\0' || isdirsep(*(s+1))) {
			/* We must go back to the parent */
			char *n;
			*p = '\0';
			if (!(n = strrdirsep(root))) {
			    *p = '/';
			}
			else {
			    p = n;
			}
			b = ++s;
		    }
#if USE_NTFS
		    else {
			do *++s; while (istrailinggabage(*s));
		    }
#endif
		    break;
		  case '/':
#if defined DOSISH || defined __CYGWIN__
		  case '\\':
#endif
		    b = ++s;
		    break;
		  default:
		    /* ordinary path element, beginning don't move */
		    break;
		}
	    }
#if USE_NTFS
	    else {
		--s;
	      case ' ': {
		const char *e = s;
		while (istrailinggabage(*s)) s++;
		if (!*s) {
		    s = e;
		    goto endpath;
		}
	      }
	    }
#endif
	    break;
	  case '/':
#if defined DOSISH || defined __CYGWIN__
	  case '\\':
#endif
	    if (s &gt; b) {
		long rootdiff = root - buf;
		BUFCHECK(bdiff + (s-b+1) &gt;= buflen);
		root = buf + rootdiff;
		memcpy(++p, b, s-b);
		p += s-b;
		*p = '/';
	    }
	    b = ++s;
	    break;
	  default:
	    s = CharNext(s);
	    break;
	}
    }

    if (s &gt; b) {
#if USE_NTFS
      endpath:
	if (s &gt; b + 6 &amp;&amp; strncasecmp(s - 6, &quot;:$DATA&quot;, 6) == 0) {
	    /* alias of stream */
	    /* get rid of a bug of x64 VC++ */
	    if (*(s-7) == ':') s -= 7;			/* prime */
	    else if (memchr(b, ':', s - 6 - b)) s -= 6; /* alternative */
	}
#endif
	BUFCHECK(bdiff + (s-b) &gt;= buflen);
	memcpy(++p, b, s-b);
	p += s-b;
    }
    if (p == skiproot(buf) - 1) p++;

#if USE_NTFS
    *p = '\0';
    if ((s = strrdirsep(b = buf)) != 0 &amp;&amp; !strpbrk(s, &quot;*?&quot;)) {
	size_t len;
	WIN32_FIND_DATA wfd;
#ifdef __CYGWIN__
	int lnk_added = 0, is_symlink = 0;
	struct stat st;
	char w32buf[MAXPATHLEN];
	p = (char *)s;
	if (lstat(buf, &amp;st) == 0 &amp;&amp; S_ISLNK(st.st_mode)) {
	    is_symlink = 1;
	    *p = '\0';
	}
	if (cygwin_conv_to_win32_path((*buf ? buf : &quot;/&quot;), w32buf) == 0) {
	    b = w32buf;
	}
	if (is_symlink &amp;&amp; b == w32buf) {
	    *p = '\\';
	    strlcat(w32buf, p, sizeof(w32buf));
	    len = strlen(p);
	    if (len &gt; 4 &amp;&amp; strcasecmp(p + len - 4, &quot;.lnk&quot;) != 0) {
		lnk_added = 1;
		strlcat(w32buf, &quot;.lnk&quot;, sizeof(w32buf));
	    }
	}
	*p = '/';
#endif
	HANDLE h = FindFirstFile(b, &amp;wfd);
	if (h != INVALID_HANDLE_VALUE) {
	    FindClose(h);
	    len = strlen(wfd.cFileName);
#ifdef __CYGWIN__
	    if (lnk_added &amp;&amp; len &gt; 4 &amp;&amp;
		strcasecmp(wfd.cFileName + len - 4, &quot;.lnk&quot;) == 0) {
		wfd.cFileName[len -= 4] = '\0';
	    }
#else
	    p = (char *)s;
#endif
	    ++p;
	    BUFCHECK(bdiff + len &gt;= buflen);
	    memcpy(p, wfd.cFileName, len + 1);
	    p += len;
	}
#ifdef __CYGWIN__
	else {
	    p += strlen(p);
	}
#endif
    }
#endif

    if (tainted) OBJ_TAINT(result);
    rb_str_set_len(result, p - buf);
    return result;
}

VALUE
rb_file_expand_path(fname, dname)
    VALUE fname, dname;
{
    return file_expand_path(fname, dname, rb_str_new(0, MAXPATHLEN + 2));
}

/*
 *  call-seq:
 *     File.expand_path(file_name [, dir_string] ) -&gt; abs_file_name
 *  
 *  Converts a pathname to an absolute pathname. Relative paths are
 *  referenced from the current working directory of the process unless
 *  &lt;i&gt;dir_string&lt;/i&gt; is given, in which case it will be used as the
 *  starting point. The given pathname may start with a
 *  ``&lt;code&gt;~&lt;/code&gt;'', which expands to the process owner's home
 *  directory (the environment variable &lt;code&gt;HOME&lt;/code&gt; must be set
 *  correctly). ``&lt;code&gt;~&lt;/code&gt;&lt;i&gt;user&lt;/i&gt;'' expands to the named
 *  user's home directory.
 *     
 *     File.expand_path(&quot;~oracle/bin&quot;)           #=&gt; &quot;/home/oracle/bin&quot;
 *     File.expand_path(&quot;../../bin&quot;, &quot;/tmp/x&quot;)   #=&gt; &quot;/bin&quot;
 */

VALUE
rb_file_s_expand_path(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, dname;

    if (argc == 1) {
	return rb_file_expand_path(argv[0], Qnil);
    }
    rb_scan_args(argc, argv, &quot;11&quot;, &amp;fname, &amp;dname);

    return rb_file_expand_path(fname, dname);
}

static int
rmext(p, l1, e)
    const char *p, *e;
    int l1;
{
    int l2;

    if (!e) return 0;

    l2 = strlen(e);
    if (l2 == 2 &amp;&amp; e[1] == '*') {
	unsigned char c = *e;
	e = p + l1;
	do {
	    if (e &lt;= p) return 0;
	} while (*--e != c);
	return e - p;
    }
    if (l1 &lt; l2) return l1;

#if CASEFOLD_FILESYSTEM
#define fncomp strncasecmp
#else
#define fncomp strncmp
#endif
    if (fncomp(p+l1-l2, e, l2) == 0) {
	return l1-l2;
    }
    return 0;
}

/*
 *  call-seq:
 *     File.basename(file_name [, suffix] ) -&gt; base_name
 *  
 *  Returns the last component of the filename given in &lt;i&gt;file_name&lt;/i&gt;,
 *  which must be formed using forward slashes (``&lt;code&gt;/&lt;/code&gt;'')
 *  regardless of the separator used on the local file system. If
 *  &lt;i&gt;suffix&lt;/i&gt; is given and present at the end of &lt;i&gt;file_name&lt;/i&gt;,
 *  it is removed.
 *     
 *     File.basename(&quot;/home/gumby/work/ruby.rb&quot;)          #=&gt; &quot;ruby.rb&quot;
 *     File.basename(&quot;/home/gumby/work/ruby.rb&quot;, &quot;.rb&quot;)   #=&gt; &quot;ruby&quot;
 */

static VALUE
rb_file_s_basename(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE fname, fext, basename;
    const char *name, *p;
#if defined DOSISH_DRIVE_LETTER || defined DOSISH_UNC
    const char *root;
#endif
    int f, n;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;fname, &amp;fext) == 2) {
	StringValue(fext);
    }
    StringValue(fname);
    if (RSTRING(fname)-&gt;len == 0 || !*(name = RSTRING(fname)-&gt;ptr))
	return fname;
    name = skipprefix(name);
#if defined DOSISH_DRIVE_LETTER || defined DOSISH_UNC
    root = name;
#endif
    while (isdirsep(*name))
	name++;
    if (!*name) {
	p = name - 1;
	f = 1;
#if defined DOSISH_DRIVE_LETTER || defined DOSISH_UNC
	if (name != root) {
	    /* has slashes */
	}
#ifdef DOSISH_DRIVE_LETTER
	else if (*p == ':') {
	    p++;
	    f = 0;
	}
#endif
#ifdef DOSISH_UNC
	else {
	    p = &quot;/&quot;;
	}
#endif
#endif
    }
    else {
	if (!(p = strrdirsep(name))) {
	    p = name;
	}
	else {
	    while (isdirsep(*p)) p++; /* skip last / */
	}
#if USE_NTFS
	n = ntfs_tail(p) - p;
#else
	n = chompdirsep(p) - p;
#endif
	if (NIL_P(fext) || !(f = rmext(p, n, StringValueCStr(fext)))) {
	    f = n;
	}
	if (f == RSTRING_LEN(fname)) return fname;
    }
    basename = rb_str_new(p, f);
    OBJ_INFECT(basename, fname);
    return basename;
}

/*
 *  call-seq:
 *     File.dirname(file_name ) -&gt; dir_name
 *  
 *  Returns all components of the filename given in &lt;i&gt;file_name&lt;/i&gt;
 *  except the last one. The filename must be formed using forward
 *  slashes (``&lt;code&gt;/&lt;/code&gt;'') regardless of the separator used on the
 *  local file system.
 *     
 *     File.dirname(&quot;/home/gumby/work/ruby.rb&quot;)   #=&gt; &quot;/home/gumby/work&quot;
 */

static VALUE
rb_file_s_dirname(klass, fname)
    VALUE klass, fname;
{
    const char *name, *root, *p;
    VALUE dirname;

    name = StringValueCStr(fname);
    root = skiproot(name);
#ifdef DOSISH_UNC
    if (root &gt; name + 1 &amp;&amp; isdirsep(*name))
	root = skipprefix(name = root - 2);
#else
    if (root &gt; name + 1)
	name = root - 1;
#endif
    p = strrdirsep(root);
    if (!p) {
	p = root;
    }
    if (p == name)
	return rb_str_new2(&quot;.&quot;);
#ifdef DOSISH_DRIVE_LETTER
    if (has_drive_letter(name) &amp;&amp; isdirsep(*(name + 2))) {
	const char *top = skiproot(name + 2);
	dirname = rb_str_new(name, 3);
	rb_str_cat(dirname, top, p - top);
    }
    else
#endif
    dirname = rb_str_new(name, p - name);
#ifdef DOSISH_DRIVE_LETTER
    if (has_drive_letter(name) &amp;&amp; root == name + 2 &amp;&amp; p - name == 2)
	rb_str_cat(dirname, &quot;.&quot;, 1);
#endif
    OBJ_INFECT(dirname, fname);
    return dirname;
}

/*
 *  call-seq:
 *     File.extname(path) -&gt; string
 *  
 *  Returns the extension (the portion of file name in &lt;i&gt;path&lt;/i&gt;
 *  after the period).
 *     
 *     File.extname(&quot;test.rb&quot;)         #=&gt; &quot;.rb&quot;
 *     File.extname(&quot;a/b/d/test.rb&quot;)   #=&gt; &quot;.rb&quot;
 *     File.extname(&quot;test&quot;)            #=&gt; &quot;&quot;
 *     File.extname(&quot;.profile&quot;)        #=&gt; &quot;&quot;
 *     
 */

static VALUE
rb_file_s_extname(klass, fname)
    VALUE klass, fname;
{
    const char *name, *p, *e;
    VALUE extname;

    name = StringValueCStr(fname);
    p = strrdirsep(name);	/* get the last path component */
    if (!p)
	p = name;
    else
	name = ++p;

    e = 0;
    while (*p) {
	if (*p == '.' || istrailinggabage(*p)) {
#if USE_NTFS
	    const char *last = p++, *dot = last;
	    while (istrailinggabage(*p)) {
		if (*p == '.') dot = p;
		p++;
	    }
	    if (!*p || *p == ':') {
		p = last;
		break;
	    }
	    e = dot;
	    continue;
#else
	    e = p;	  /* get the last dot of the last component */
#endif
	}
#if USE_NTFS
	else if (*p == ':') {
	    break;
	}
#endif
	else if (isdirsep(*p))
	    break;
	p = CharNext(p);
    }
    if (!e || e == name || e+1 == p)	/* no dot, or the only dot is first or end? */
	return rb_str_new(0, 0);
    extname = rb_str_new(e, p - e);	/* keep the dot, too! */
    OBJ_INFECT(extname, fname);
    return extname;
}

/*
 *  call-seq:
 *     File.split(file_name)   =&gt; array
 *  
 *  Splits the given string into a directory and a file component and
 *  returns them in a two-element array. See also
 *  &lt;code&gt;File::dirname&lt;/code&gt; and &lt;code&gt;File::basename&lt;/code&gt;.
 *     
 *     File.split(&quot;/home/gumby/.profile&quot;)   #=&gt; [&quot;/home/gumby&quot;, &quot;.profile&quot;]
 */

static VALUE
rb_file_s_split(klass, path)
    VALUE klass, path;
{
    StringValue(path);		/* get rid of converting twice */
    return rb_assoc_new(rb_file_s_dirname(Qnil, path), rb_file_s_basename(1,&amp;path));
}

static VALUE separator;

static VALUE rb_file_join _((VALUE ary, VALUE sep));

static VALUE
file_inspect_join(ary, arg)
    VALUE ary;
    VALUE *arg;
{
    return rb_file_join(arg[0], arg[1]);
}

static VALUE
rb_file_join(ary, sep)
    VALUE ary, sep;
{
    long len, i;
    int taint = 0;
    VALUE result, tmp;
    const char *name, *tail;

    if (RARRAY(ary)-&gt;len == 0) return rb_str_new(0, 0);
    if (OBJ_TAINTED(ary)) taint = 1;
    if (OBJ_TAINTED(sep)) taint = 1;

    len = 1;
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	if (TYPE(RARRAY(ary)-&gt;ptr[i]) == T_STRING) {
	    len += RSTRING(RARRAY(ary)-&gt;ptr[i])-&gt;len;
	}
	else {
	    len += 10;
	}
    }
    if (!NIL_P(sep) &amp;&amp; TYPE(sep) == T_STRING) {
	len += RSTRING(sep)-&gt;len * RARRAY(ary)-&gt;len - 1;
    }
    result = rb_str_buf_new(len);
    for (i=0; i&lt;RARRAY(ary)-&gt;len; i++) {
	tmp = RARRAY(ary)-&gt;ptr[i];
	switch (TYPE(tmp)) {
	  case T_STRING:
	    break;
	  case T_ARRAY:
	    if (rb_inspecting_p(tmp)) {
		tmp = rb_str_new2(&quot;[...]&quot;);
	    }
	    else {
		VALUE args[2];

		args[0] = tmp;
		args[1] = sep;
		tmp = rb_protect_inspect(file_inspect_join, ary, (VALUE)args);
	    }
	    break;
	  default:
	    StringValueCStr(tmp);
	}
	name = StringValueCStr(result);
	if (i &gt; 0 &amp;&amp; !NIL_P(sep)) {
	    tail = chompdirsep(name);
	    if (RSTRING(tmp)-&gt;ptr &amp;&amp; isdirsep(RSTRING(tmp)-&gt;ptr[0])) {
		RSTRING(result)-&gt;len = tail - name;
	    }
	    else if (!*tail) {
		rb_str_buf_append(result, sep);
	    }
	}
	rb_str_buf_append(result, tmp);
	if (OBJ_TAINTED(tmp)) taint = 1;
    }

    if (taint) OBJ_TAINT(result);
    return result;
}

/*
 *  call-seq:
 *     File.join(string, ...) -&gt; path
 *  
 *  Returns a new string formed by joining the strings using
 *  &lt;code&gt;File::SEPARATOR&lt;/code&gt;.
 *     
 *     File.join(&quot;usr&quot;, &quot;mail&quot;, &quot;gumby&quot;)   #=&gt; &quot;usr/mail/gumby&quot;
 *     
 */

static VALUE
rb_file_s_join(klass, args)
    VALUE klass, args;
{
    return rb_file_join(args, separator);
}

/*
 *  call-seq:
 *     File.truncate(file_name, integer)  =&gt; 0
 *  
 *  Truncates the file &lt;i&gt;file_name&lt;/i&gt; to be at most &lt;i&gt;integer&lt;/i&gt;
 *  bytes long. Not available on all platforms.
 *     
 *     f = File.new(&quot;out&quot;, &quot;w&quot;)
 *     f.write(&quot;1234567890&quot;)     #=&gt; 10
 *     f.close                   #=&gt; nil
 *     File.truncate(&quot;out&quot;, 5)   #=&gt; 0
 *     File.size(&quot;out&quot;)          #=&gt; 5
 *     
 */

static VALUE
rb_file_s_truncate(klass, path, len)
    VALUE klass, path, len;
{
    off_t pos;

    rb_secure(2);
    pos = NUM2OFFT(len);
    SafeStringValue(path);

#ifdef HAVE_TRUNCATE
    if (truncate(StringValueCStr(path), pos) &lt; 0)
	rb_sys_fail(RSTRING(path)-&gt;ptr);
#else
# ifdef HAVE_CHSIZE
    {
	int tmpfd;

#  ifdef _WIN32
	if ((tmpfd = open(StringValueCStr(path), O_RDWR)) &lt; 0) {
	    rb_sys_fail(RSTRING(path)-&gt;ptr);
	}
#  else
	if ((tmpfd = open(StringValueCStr(path), 0)) &lt; 0) {
	    rb_sys_fail(RSTRING(path)-&gt;ptr);
	}
#  endif
	if (chsize(tmpfd, pos) &lt; 0) {
	    close(tmpfd);
	    rb_sys_fail(RSTRING(path)-&gt;ptr);
	}
	close(tmpfd);
    }
# else
    rb_notimplement();
# endif
#endif
    return INT2FIX(0);
}

/*
 *  call-seq:
 *     file.truncate(integer)    =&gt; 0
 *  
 *  Truncates &lt;i&gt;file&lt;/i&gt; to at most &lt;i&gt;integer&lt;/i&gt; bytes. The file
 *  must be opened for writing. Not available on all platforms.
 *     
 *     f = File.new(&quot;out&quot;, &quot;w&quot;)
 *     f.syswrite(&quot;1234567890&quot;)   #=&gt; 10
 *     f.truncate(5)              #=&gt; 0
 *     f.close()                  #=&gt; nil
 *     File.size(&quot;out&quot;)           #=&gt; 5
 */

static VALUE
rb_file_truncate(obj, len)
    VALUE obj, len;
{
    rb_io_t *fptr;
    FILE *f;
    off_t pos;

    rb_secure(2);
    pos = NUM2OFFT(len);
    GetOpenFile(obj, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_WRITABLE)) {
	rb_raise(rb_eIOError, &quot;not opened for writing&quot;);
    }
    f = GetWriteFile(fptr);
    fflush(f);
    fseeko(f, (off_t)0, SEEK_CUR);
#ifdef HAVE_FTRUNCATE
    if (ftruncate(fileno(f), pos) &lt; 0)
	rb_sys_fail(fptr-&gt;path);
#else
# ifdef HAVE_CHSIZE
    if (chsize(fileno(f), pos) &lt; 0)
	rb_sys_fail(fptr-&gt;path);
# else
    rb_notimplement();
# endif
#endif
    return INT2FIX(0);
}

# ifndef LOCK_SH
#  define LOCK_SH 1
# endif
# ifndef LOCK_EX
#  define LOCK_EX 2
# endif
# ifndef LOCK_NB
#  define LOCK_NB 4
# endif
# ifndef LOCK_UN
#  define LOCK_UN 8
# endif

#ifdef __CYGWIN__
#include &lt;winerror.h&gt;
extern unsigned long __attribute__((stdcall)) GetLastError(void);

static int
cygwin_flock(int fd, int op)
{
    int old_errno = errno;
    int ret = flock(fd, op);
    if (GetLastError() == ERROR_NOT_LOCKED) {
	ret = 0;
	errno = old_errno;
    }
    return ret;
}
# define flock(fd, op) cygwin_flock(fd, op)
#endif

static int
rb_thread_flock(fd, op, fptr)
    int fd, op;
    rb_io_t *fptr;
{
    if (rb_thread_alone() || (op &amp; LOCK_NB)) {
	int ret;
	TRAP_BEG;
	ret = flock(fd, op);
	TRAP_END;
	return ret;
    }
    op |= LOCK_NB;
    while (flock(fd, op) &lt; 0) {
	switch (errno) {
	  case EAGAIN:
	  case EACCES:
#if defined(EWOULDBLOCK) &amp;&amp; EWOULDBLOCK != EAGAIN
	  case EWOULDBLOCK:
#endif
	    rb_thread_polling();	/* busy wait */
	    rb_io_check_closed(fptr);
	    continue;
	  default:
	    return -1;
	}
    }
    return 0;
}
#ifdef __CYGWIN__
# undef flock
#endif
#define flock(fd, op) rb_thread_flock(fd, op, fptr)

/*
 *  call-seq:
 *     file.flock (locking_constant ) =&gt;  0 or false
 *  
 *  Locks or unlocks a file according to &lt;i&gt;locking_constant&lt;/i&gt; (a
 *  logical &lt;em&gt;or&lt;/em&gt; of the values in the table below).
 *  Returns &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;File::LOCK_NB&lt;/code&gt; is
 *  specified and the operation would otherwise have blocked. Not
 *  available on all platforms.
 *     
 *  Locking constants (in class File):
 *
 *     LOCK_EX   | Exclusive lock. Only one process may hold an
 *               | exclusive lock for a given file at a time.
 *     ----------+------------------------------------------------
 *     LOCK_NB   | Don't block when locking. May be combined
 *               | with other lock options using logical or.
 *     ----------+------------------------------------------------
 *     LOCK_SH   | Shared lock. Multiple processes may each hold a
 *               | shared lock for a given file at the same time.
 *     ----------+------------------------------------------------
 *     LOCK_UN   | Unlock.
 *
 *  Example:
 *
 *     File.new(&quot;testfile&quot;).flock(File::LOCK_UN)   #=&gt; 0
 *     
 */

static VALUE
rb_file_flock(obj, operation)
    VALUE obj;
    VALUE operation;
{
#ifndef __CHECKER__
    rb_io_t *fptr;
    int op;

    rb_secure(2);
    op = NUM2INT(operation);
    GetOpenFile(obj, fptr);

    if (fptr-&gt;mode &amp; FMODE_WRITABLE) {
	fflush(GetWriteFile(fptr));
    }
  retry:
    if (flock(fileno(fptr-&gt;f), op) &lt; 0) {
	switch (errno) {
	  case EAGAIN:
	  case EACCES:
#if defined(EWOULDBLOCK) &amp;&amp; EWOULDBLOCK != EAGAIN
	  case EWOULDBLOCK:
#endif
	      return Qfalse;
	  case EINTR:
#if defined(ERESTART)
	  case ERESTART:
#endif
	    goto retry;
	}
	rb_sys_fail(fptr-&gt;path);
    }
#endif
    return INT2FIX(0);
}
#undef flock

static void
test_check(n, argc, argv)
    int n, argc;
    VALUE *argv;
{
    int i;

    n+=1;
    if (n != argc) rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for %d)&quot;, argc, n);
    for (i=1; i&lt;n; i++) {
	switch (TYPE(argv[i])) {
	  case T_STRING:
	  default:
	    SafeStringValue(argv[i]);
	    break;
	  case T_FILE:
	    break;
	}
    }
}

#define CHECK(n) test_check((n), argc, argv)

/*
 *  call-seq:
 *     test(int_cmd, file1 [, file2] ) =&gt; obj
 *  
 *  Uses the integer &lt;i&gt;aCmd&lt;/i&gt; to perform various tests on
 *  &lt;i&gt;file1&lt;/i&gt; (first table below) or on &lt;i&gt;file1&lt;/i&gt; and
 *  &lt;i&gt;file2&lt;/i&gt; (second table).
 *     
 *  File tests on a single file:
 *
 *    Test   Returns   Meaning
 *     ?A  | Time    | Last access time for file1
 *     ?b  | boolean | True if file1 is a block device
 *     ?c  | boolean | True if file1 is a character device
 *     ?C  | Time    | Last change time for file1
 *     ?d  | boolean | True if file1 exists and is a directory
 *     ?e  | boolean | True if file1 exists
 *     ?f  | boolean | True if file1 exists and is a regular file
 *     ?g  | boolean | True if file1 has the \CF{setgid} bit
 *         |         | set (false under NT)
 *     ?G  | boolean | True if file1 exists and has a group
 *         |         | ownership equal to the caller's group
 *     ?k  | boolean | True if file1 exists and has the sticky bit set
 *     ?l  | boolean | True if file1 exists and is a symbolic link
 *     ?M  | Time    | Last modification time for file1
 *     ?o  | boolean | True if file1 exists and is owned by 
 *         |         | the caller's effective uid
 *     ?O  | boolean | True if file1 exists and is owned by
 *         |         | the caller's real uid
 *     ?p  | boolean | True if file1 exists and is a fifo
 *     ?r  | boolean | True if file1 is readable by the effective
 *         |         | uid/gid of the caller
 *     ?R  | boolean | True if file is readable by the real
 *         |         | uid/gid of the caller
 *     ?s  | int/nil | If file1 has nonzero size, return the size,
 *         |         | otherwise return nil
 *     ?S  | boolean | True if file1 exists and is a socket
 *     ?u  | boolean | True if file1 has the setuid bit set
 *     ?w  | boolean | True if file1 exists and is writable by
 *         |         | the effective uid/gid
 *     ?W  | boolean | True if file1 exists and is writable by
 *         |         | the real uid/gid
 *     ?x  | boolean | True if file1 exists and is executable by
 *         |         | the effective uid/gid
 *     ?X  | boolean | True if file1 exists and is executable by
 *         |         | the real uid/gid
 *     ?z  | boolean | True if file1 exists and has a zero length
 *
 * Tests that take two files:
 *
 *     ?-  | boolean | True if file1 and file2 are identical
 *     ?=  | boolean | True if the modification times of file1
 *         |         | and file2 are equal
 *     ?&lt;  | boolean | True if the modification time of file1
 *         |         | is prior to that of file2
 *     ?&gt;  | boolean | True if the modification time of file1
 *         |         | is after that of file2
 */

static VALUE
rb_f_test(argc, argv)
    int argc;
    VALUE *argv;
{
    int cmd;

    if (argc == 0) rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
#if 0 /* 1.7 behavior? */
    if (argc == 1) {
	return RTEST(argv[0]) ? Qtrue : Qfalse;
    }
#endif
    cmd = NUM2CHR(argv[0]);
    if (cmd == 0) return Qfalse;
    if (strchr(&quot;bcdefgGkloOprRsSuwWxXz&quot;, cmd)) {
	CHECK(1);
	switch (cmd) {
	  case 'b':
	    return test_b(0, argv[1]);

	  case 'c':
	    return test_c(0, argv[1]);

	  case 'd':
	    return test_d(0, argv[1]);

	  case 'a':
	  case 'e':
	    return test_e(0, argv[1]);

	  case 'f':
	    return test_f(0, argv[1]);

	  case 'g':
	    return test_sgid(0, argv[1]);

	  case 'G':
	    return test_grpowned(0, argv[1]);

	  case 'k':
	    return test_sticky(0, argv[1]);

	  case 'l':
	    return test_l(0, argv[1]);

	  case 'o':
	    return test_owned(0, argv[1]);

	  case 'O':
	    return test_rowned(0, argv[1]);

	  case 'p':
	    return test_p(0, argv[1]);

	  case 'r':
	    return test_r(0, argv[1]);

	  case 'R':
	    return test_R(0, argv[1]);

	  case 's':
	    return test_s(0, argv[1]);

	  case 'S':
	    return test_S(0, argv[1]);

	  case 'u':
	    return test_suid(0, argv[1]);

	  case 'w':
	    return test_w(0, argv[1]);

	  case 'W':
	    return test_W(0, argv[1]);

	  case 'x':
	    return test_x(0, argv[1]);

	  case 'X':
	    return test_X(0, argv[1]);

	  case 'z':
	    return test_z(0, argv[1]);
	}
    }

    if (strchr(&quot;MAC&quot;, cmd)) {
	struct stat st;

	CHECK(1);
	if (rb_stat(argv[1], &amp;st) == -1) {
	    rb_sys_fail(RSTRING(argv[1])-&gt;ptr);
	}

	switch (cmd) {
	  case 'A':
	    return rb_time_new(st.st_atime, 0);
	  case 'M':
	    return rb_time_new(st.st_mtime, 0);
	  case 'C':
	    return rb_time_new(st.st_ctime, 0);
	}
    }

    if (cmd == '-') {
	CHECK(2);
	return test_identical(0, argv[1], argv[2]);
    }

    if (strchr(&quot;=&lt;&gt;&quot;, cmd)) {
	struct stat st1, st2;

	CHECK(2);
	if (rb_stat(argv[1], &amp;st1) &lt; 0) return Qfalse;
	if (rb_stat(argv[2], &amp;st2) &lt; 0) return Qfalse;

	switch (cmd) {
	  case '=':
	    if (st1.st_mtime == st2.st_mtime) return Qtrue;
	    return Qfalse;

	  case '&gt;':
	    if (st1.st_mtime &gt; st2.st_mtime) return Qtrue;
	    return Qfalse;

	  case '&lt;':
	    if (st1.st_mtime &lt; st2.st_mtime) return Qtrue;
	    return Qfalse;
	}
    }
    /* unknown command */
    rb_raise(rb_eArgError, &quot;unknown command ?%c&quot;, cmd);
    return Qnil;		/* not reached */
}



/*
 *  Document-class: File::Stat
 *
 *  Objects of class &lt;code&gt;File::Stat&lt;/code&gt; encapsulate common status
 *  information for &lt;code&gt;File&lt;/code&gt; objects. The information is
 *  recorded at the moment the &lt;code&gt;File::Stat&lt;/code&gt; object is
 *  created; changes made to the file after that point will not be
 *  reflected. &lt;code&gt;File::Stat&lt;/code&gt; objects are returned by
 *  &lt;code&gt;IO#stat&lt;/code&gt;, &lt;code&gt;File::stat&lt;/code&gt;,
 *  &lt;code&gt;File#lstat&lt;/code&gt;, and &lt;code&gt;File::lstat&lt;/code&gt;. Many of these
 *  methods return platform-specific values, and not all values are
 *  meaningful on all systems. See also &lt;code&gt;Kernel#test&lt;/code&gt;.
 */

static VALUE rb_stat_s_alloc _((VALUE));
static VALUE
rb_stat_s_alloc(klass)
    VALUE klass;
{
    return stat_new_0(klass, 0);
}

/*
 * call-seq:
 *
 *   File::Stat.new(file_name)  =&gt; stat
 *
 * Create a File::Stat object for the given file name (raising an
 * exception if the file doesn't exist).
 */

static VALUE
rb_stat_init(obj, fname)
    VALUE obj, fname;
{
    struct stat st, *nst;

    SafeStringValue(fname);

    if (stat(StringValueCStr(fname), &amp;st) == -1) {
	rb_sys_fail(RSTRING(fname)-&gt;ptr);
    }
    if (DATA_PTR(obj)) {
	free(DATA_PTR(obj));
	DATA_PTR(obj) = NULL;
    }
    nst = ALLOC(struct stat);
    *nst = st;
    DATA_PTR(obj) = nst;

    return Qnil;
}

/* :nodoc: */
static VALUE
rb_stat_init_copy(copy, orig)
    VALUE copy, orig;
{
    struct stat *nst;

    if (copy == orig) return orig;
    rb_check_frozen(copy);
    /* need better argument type check */
    if (!rb_obj_is_instance_of(orig, rb_obj_class(copy))) {
	rb_raise(rb_eTypeError, &quot;wrong argument class&quot;);
    }
    if (DATA_PTR(copy)) {
	free(DATA_PTR(copy));
	DATA_PTR(copy) = 0;
    }
    if (DATA_PTR(orig)) {
	nst = ALLOC(struct stat);
	*nst = *(struct stat*)DATA_PTR(orig);
	DATA_PTR(copy) = nst;
    }

    return copy;
}

/*
 *  call-seq:
 *     stat.ftype   =&gt; string
 *  
 *  Identifies the type of &lt;i&gt;stat&lt;/i&gt;. The return string is one of:
 *  ``&lt;code&gt;file&lt;/code&gt;'', ``&lt;code&gt;directory&lt;/code&gt;'',
 *  ``&lt;code&gt;characterSpecial&lt;/code&gt;'', ``&lt;code&gt;blockSpecial&lt;/code&gt;'',
 *  ``&lt;code&gt;fifo&lt;/code&gt;'', ``&lt;code&gt;link&lt;/code&gt;'',
 *  ``&lt;code&gt;socket&lt;/code&gt;'', or ``&lt;code&gt;unknown&lt;/code&gt;''.
 *     
 *     File.stat(&quot;/dev/tty&quot;).ftype   #=&gt; &quot;characterSpecial&quot;
 *     
 */

static VALUE
rb_stat_ftype(obj)
    VALUE obj;
{
    return rb_file_ftype(get_stat(obj));
}

/*
 *  call-seq:
 *     stat.directory?   =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is a directory,
 *  &lt;code&gt;false&lt;/code&gt; otherwise.
 *     
 *     File.stat(&quot;testfile&quot;).directory?   #=&gt; false
 *     File.stat(&quot;.&quot;).directory?          #=&gt; true
 */

static VALUE
rb_stat_d(obj)
    VALUE obj;
{
    if (S_ISDIR(get_stat(obj)-&gt;st_mode)) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.pipe?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if the operating system supports pipes and
 *  &lt;i&gt;stat&lt;/i&gt; is a pipe; &lt;code&gt;false&lt;/code&gt; otherwise.
 */

static VALUE
rb_stat_p(obj)
    VALUE obj;
{
#ifdef S_IFIFO
    if (S_ISFIFO(get_stat(obj)-&gt;st_mode)) return Qtrue;

#endif
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.symlink?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is a symbolic link,
 *  &lt;code&gt;false&lt;/code&gt; if it isn't or if the operating system doesn't
 *  support this feature. As &lt;code&gt;File::stat&lt;/code&gt; automatically
 *  follows symbolic links, &lt;code&gt;symlink?&lt;/code&gt; will always be
 *  &lt;code&gt;false&lt;/code&gt; for an object returned by
 *  &lt;code&gt;File::stat&lt;/code&gt;.
 *     
 *     File.symlink(&quot;testfile&quot;, &quot;alink&quot;)   #=&gt; 0
 *     File.stat(&quot;alink&quot;).symlink?         #=&gt; false
 *     File.lstat(&quot;alink&quot;).symlink?        #=&gt; true
 *     
 */

static VALUE
rb_stat_l(obj)
    VALUE obj;
{
#ifdef S_ISLNK
    if (S_ISLNK(get_stat(obj)-&gt;st_mode)) return Qtrue;
#endif
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.socket?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is a socket,
 *  &lt;code&gt;false&lt;/code&gt; if it isn't or if the operating system doesn't
 *  support this feature.
 *     
 *     File.stat(&quot;testfile&quot;).socket?   #=&gt; false
 *     
 */

static VALUE
rb_stat_S(obj)
    VALUE obj;
{
#ifdef S_ISSOCK
    if (S_ISSOCK(get_stat(obj)-&gt;st_mode)) return Qtrue;

#endif
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.blockdev?   =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if the file is a block device,
 *  &lt;code&gt;false&lt;/code&gt; if it isn't or if the operating system doesn't
 *  support this feature.
 *     
 *     File.stat(&quot;testfile&quot;).blockdev?    #=&gt; false
 *     File.stat(&quot;/dev/hda1&quot;).blockdev?   #=&gt; true
 *     
 */

static VALUE
rb_stat_b(obj)
    VALUE obj;
{
#ifdef S_ISBLK
    if (S_ISBLK(get_stat(obj)-&gt;st_mode)) return Qtrue;

#endif
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.chardev?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if the file is a character device,
 *  &lt;code&gt;false&lt;/code&gt; if it isn't or if the operating system doesn't
 *  support this feature.
 *     
 *     File.stat(&quot;/dev/tty&quot;).chardev?   #=&gt; true
 *     
 */

static VALUE
rb_stat_c(obj)
    VALUE obj;
{
    if (S_ISCHR(get_stat(obj)-&gt;st_mode)) return Qtrue;

    return Qfalse;
}

/*
 *  call-seq:
 *     stat.owned?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if the effective user id of the process is
 *  the same as the owner of &lt;i&gt;stat&lt;/i&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).owned?      #=&gt; true
 *     File.stat(&quot;/etc/passwd&quot;).owned?   #=&gt; false
 *     
 */

static VALUE
rb_stat_owned(obj)
    VALUE obj;
{
    if (get_stat(obj)-&gt;st_uid == geteuid()) return Qtrue;
    return Qfalse;
}

static VALUE
rb_stat_rowned(obj)
    VALUE obj;
{
    if (get_stat(obj)-&gt;st_uid == getuid()) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.grpowned?   =&gt; true or false
 *  
 *  Returns true if the effective group id of the process is the same as
 *  the group id of &lt;i&gt;stat&lt;/i&gt;. On Windows NT, returns &lt;code&gt;false&lt;/code&gt;.
 *     
 *     File.stat(&quot;testfile&quot;).grpowned?      #=&gt; true
 *     File.stat(&quot;/etc/passwd&quot;).grpowned?   #=&gt; false
 *     
 */

static VALUE
rb_stat_grpowned(obj)
    VALUE obj;
{
#ifndef _WIN32
    if (group_member(get_stat(obj)-&gt;st_gid)) return Qtrue;
#endif
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.readable?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is readable by the
 *  effective user id of this process.
 *     
 *     File.stat(&quot;testfile&quot;).readable?   #=&gt; true
 *     
 */

static VALUE
rb_stat_r(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (geteuid() == 0) return Qtrue;
#endif
#ifdef S_IRUSR
    if (rb_stat_owned(obj))
	return st-&gt;st_mode &amp; S_IRUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IRGRP
    if (rb_stat_grpowned(obj))
	return st-&gt;st_mode &amp; S_IRGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IROTH
    if (!(st-&gt;st_mode &amp; S_IROTH)) return Qfalse;
#endif
    return Qtrue;
}



/*
 *  call-seq:
 *     stat.readable_real? -&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is readable by the real
 *  user id of this process.
 *     
 *     File.stat(&quot;testfile&quot;).readable_real?   #=&gt; true
 *     
 */

static VALUE
rb_stat_R(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (getuid() == 0) return Qtrue;
#endif
#ifdef S_IRUSR
    if (rb_stat_rowned(obj))
	return st-&gt;st_mode &amp; S_IRUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IRGRP
    if (group_member(get_stat(obj)-&gt;st_gid))
	return st-&gt;st_mode &amp; S_IRGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IROTH
    if (!(st-&gt;st_mode &amp; S_IROTH)) return Qfalse;
#endif
    return Qtrue;
}

/*
 *  call-seq:
 *     stat.writable? -&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is writable by the
 *  effective user id of this process.
 *     
 *     File.stat(&quot;testfile&quot;).writable?   #=&gt; true
 *     
 */

static VALUE
rb_stat_w(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (geteuid() == 0) return Qtrue;
#endif
#ifdef S_IWUSR
    if (rb_stat_owned(obj))
	return st-&gt;st_mode &amp; S_IWUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IWGRP
    if (rb_stat_grpowned(obj))
	return st-&gt;st_mode &amp; S_IWGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IWOTH
    if (!(st-&gt;st_mode &amp; S_IWOTH)) return Qfalse;
#endif
    return Qtrue;
}

/*
 *  call-seq:
 *     stat.writable_real? -&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is writable by the real
 *  user id of this process.
 *     
 *     File.stat(&quot;testfile&quot;).writable_real?   #=&gt; true
 *     
 */

static VALUE
rb_stat_W(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (getuid() == 0) return Qtrue;
#endif
#ifdef S_IWUSR
    if (rb_stat_rowned(obj))
	return st-&gt;st_mode &amp; S_IWUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IWGRP
    if (group_member(get_stat(obj)-&gt;st_gid))
	return st-&gt;st_mode &amp; S_IWGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IWOTH
    if (!(st-&gt;st_mode &amp; S_IWOTH)) return Qfalse;
#endif
    return Qtrue;
}

/*
 *  call-seq:
 *     stat.executable?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is executable or if the
 *  operating system doesn't distinguish executable files from
 *  nonexecutable files. The tests are made using the effective owner of
 *  the process.
 *     
 *     File.stat(&quot;testfile&quot;).executable?   #=&gt; false
 *     
 */

static VALUE
rb_stat_x(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (geteuid() == 0) {
	return st-&gt;st_mode &amp; S_IXUGO ? Qtrue : Qfalse;
    }
#endif
#ifdef S_IXUSR
    if (rb_stat_owned(obj))
	return st-&gt;st_mode &amp; S_IXUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IXGRP
    if (rb_stat_grpowned(obj))
	return st-&gt;st_mode &amp; S_IXGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IXOTH
    if (!(st-&gt;st_mode &amp; S_IXOTH)) return Qfalse;
#endif
    return Qtrue;
}

/*
 *  call-seq:
 *     stat.executable_real?    =&gt; true or false
 *  
 *  Same as &lt;code&gt;executable?&lt;/code&gt;, but tests using the real owner of
 *  the process.
 */


static VALUE
rb_stat_X(obj)
    VALUE obj;
{
    struct stat *st = get_stat(obj);

#ifdef USE_GETEUID
    if (getuid() == 0) {
	return st-&gt;st_mode &amp; S_IXUGO ? Qtrue : Qfalse;
    }
#endif
#ifdef S_IXUSR
    if (rb_stat_rowned(obj))
	return st-&gt;st_mode &amp; S_IXUSR ? Qtrue : Qfalse;
#endif
#ifdef S_IXGRP
    if (group_member(get_stat(obj)-&gt;st_gid))
	return st-&gt;st_mode &amp; S_IXGRP ? Qtrue : Qfalse;
#endif
#ifdef S_IXOTH
    if (!(st-&gt;st_mode &amp; S_IXOTH)) return Qfalse;
#endif
    return Qtrue;
}

/*
 *  call-seq:
 *     stat.file?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is a regular file (not
 *  a device file, pipe, socket, etc.).
 *     
 *     File.stat(&quot;testfile&quot;).file?   #=&gt; true
 *     
 */

static VALUE
rb_stat_f(obj)
    VALUE obj;
{
    if (S_ISREG(get_stat(obj)-&gt;st_mode)) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.zero?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; is a zero-length file;
 *  &lt;code&gt;false&lt;/code&gt; otherwise.
 *     
 *     File.stat(&quot;testfile&quot;).zero?   #=&gt; false
 *     
 */

static VALUE
rb_stat_z(obj)
    VALUE obj;
{
    if (get_stat(obj)-&gt;st_size == 0) return Qtrue;
    return Qfalse;
}


/*
 *  call-seq:
 *     state.size    =&gt; integer
 *  
 *  Returns the size of &lt;i&gt;stat&lt;/i&gt; in bytes.
 *     
 *     File.stat(&quot;testfile&quot;).size   #=&gt; 66
 *     
 */

static VALUE
rb_stat_s(obj)
    VALUE obj;
{
    off_t size = get_stat(obj)-&gt;st_size;

    if (size == 0) return Qnil;
    return OFFT2NUM(size);
}

/*
 *  call-seq:
 *     stat.setuid?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; has the set-user-id
 *  permission bit set, &lt;code&gt;false&lt;/code&gt; if it doesn't or if the
 *  operating system doesn't support this feature.
 *     
 *     File.stat(&quot;/bin/su&quot;).setuid?   #=&gt; true
 */

static VALUE
rb_stat_suid(obj)
    VALUE obj;
{
#ifdef S_ISUID
    if (get_stat(obj)-&gt;st_mode &amp; S_ISUID) return Qtrue;
#endif
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.setgid?   =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; has the set-group-id
 *  permission bit set, &lt;code&gt;false&lt;/code&gt; if it doesn't or if the
 *  operating system doesn't support this feature.
 *     
 *     File.stat(&quot;/usr/sbin/lpc&quot;).setgid?   #=&gt; true
 *     
 */

static VALUE
rb_stat_sgid(obj)
    VALUE obj;
{
#ifdef S_ISGID
    if (get_stat(obj)-&gt;st_mode &amp; S_ISGID) return Qtrue;
#endif
    return Qfalse;
}

/*
 *  call-seq:
 *     stat.sticky?    =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;stat&lt;/i&gt; has its sticky bit set,
 *  &lt;code&gt;false&lt;/code&gt; if it doesn't or if the operating system doesn't
 *  support this feature.
 *     
 *     File.stat(&quot;testfile&quot;).sticky?   #=&gt; false
 *     
 */

static VALUE
rb_stat_sticky(obj)
    VALUE obj;
{
#ifdef S_ISVTX
    if (get_stat(obj)-&gt;st_mode &amp; S_ISVTX) return Qtrue;
#endif
    return Qfalse;
}

VALUE rb_mFConst;

void
rb_file_const(name, value)
    const char *name;
    VALUE value;
{
    rb_define_const(rb_mFConst, name, value);
}

static int
is_absolute_path(path)
    const char *path;
{
#ifdef DOSISH_DRIVE_LETTER
    if (has_drive_letter(path) &amp;&amp; isdirsep(path[2])) return 1;
#endif
#ifdef DOSISH_UNC
    if (isdirsep(path[0]) &amp;&amp; isdirsep(path[1])) return 1;
#endif
#ifndef DOSISH
    if (path[0] == '/') return 1;
#endif
    return 0;
}

#ifndef ENABLE_PATH_CHECK
# if defined DOSISH || defined __CYGWIN__
#   define ENABLE_PATH_CHECK 0
# else
#   define ENABLE_PATH_CHECK 1
# endif
#endif

#if ENABLE_PATH_CHECK
static int
path_check_0(fpath, execpath)
     VALUE fpath;
     int execpath;
{
    struct stat st;
    const char *p0 = StringValueCStr(fpath);
    char *p = 0, *s;

    if (!is_absolute_path(p0)) {
	char *buf = my_getcwd();
	VALUE newpath;

	newpath = rb_str_new2(buf);
	free(buf);

	rb_str_cat2(newpath, &quot;/&quot;);
	rb_str_cat2(newpath, p0);
	p0 = RSTRING(fpath = newpath)-&gt;ptr;
    }
    for (;;) {
#ifndef S_IWOTH
# define S_IWOTH 002
#endif
	if (stat(p0, &amp;st) == 0 &amp;&amp; S_ISDIR(st.st_mode) &amp;&amp; (st.st_mode &amp; S_IWOTH)
#ifdef S_ISVTX
	    &amp;&amp; !(p &amp;&amp; execpath &amp;&amp; (st.st_mode &amp; S_ISVTX))
#endif
	    ) {
	    rb_warn(&quot;Insecure world writable dir %s in %sPATH, mode 0%o&quot;,
		    p0, (execpath ? &quot;&quot; : &quot;LOAD_&quot;), st.st_mode);
	    if (p) *p = '/';
	    return 0;
	}
	s = strrdirsep(p0);
	if (p) *p = '/';
	if (!s || s == p0) return 1;
	p = s;
	*p = '\0';
    }
}
#endif

static int
fpath_check(path)
    const char *path;
{
#if ENABLE_PATH_CHECK
    return path_check_0(rb_str_new2(path), Qfalse);
#else
    return 1;
#endif
}

int
rb_path_check(path)
    const char *path;
{
#if ENABLE_PATH_CHECK
    const char *p0, *p, *pend;
    const char sep = PATH_SEP_CHAR;

    if (!path) return 1;

    pend = path + strlen(path);
    p0 = path;
    p = strchr(path, sep);
    if (!p) p = pend;

    for (;;) {
	if (!path_check_0(rb_str_new(p0, p - p0), Qtrue)) {
	    return 0;		/* not safe */
	}
	p0 = p + 1;
	if (p0 &gt; pend) break;
	p = strchr(p0, sep);
	if (!p) p = pend;
    }
#endif
    return 1;
}

#if defined(__MACOS__) || defined(riscos)
static int
is_macos_native_path(path)
    const char *path;
{
    if (strchr(path, ':')) return 1;
    return 0;
}
#endif

static int
file_load_ok(file)
    const char *file;
{
    FILE *f;

    if (!file) return 0;
    f = fopen(file, &quot;r&quot;);
    if (f == NULL) return 0;
    fclose(f);
    return 1;
}

extern VALUE rb_load_path;

int
rb_find_file_ext(filep, ext)
    VALUE *filep;
    const char * const *ext;
{
    const char *path, *found;
    const char *f = RSTRING(*filep)-&gt;ptr;
    VALUE fname;
    long i, j;

    if (f[0] == '~') {
	fname = rb_file_expand_path(*filep, Qnil);
	if (rb_safe_level() &gt;= 2 &amp;&amp; OBJ_TAINTED(fname)) {
	    rb_raise(rb_eSecurityError, &quot;loading from unsafe file %s&quot;, f);
	}
	OBJ_FREEZE(fname);
	f = StringValueCStr(fname);
	*filep = fname;
    }

    if (is_absolute_path(f)) {
	for (i=0; ext[i]; i++) {
	    fname = rb_str_dup(*filep);
	    rb_str_cat2(fname, ext[i]);
	    OBJ_FREEZE(fname);
	    if (file_load_ok(StringValueCStr(fname))) {
		*filep = fname;
		return i+1;
	    }
	}
	return 0;
    }

    if (!rb_load_path) return 0;

    Check_Type(rb_load_path, T_ARRAY);
    for (i=0;i&lt;RARRAY(rb_load_path)-&gt;len;i++) {
	VALUE str = RARRAY(rb_load_path)-&gt;ptr[i];

	SafeStringValue(str);
	if (RSTRING(str)-&gt;len == 0) continue;
	path = RSTRING(str)-&gt;ptr;
	for (j=0; ext[j]; j++) {
	    fname = rb_str_dup(*filep);
	    rb_str_cat2(fname, ext[j]);
	    OBJ_FREEZE(fname);
	    found = dln_find_file(StringValueCStr(fname), path);
	    if (found &amp;&amp; file_load_ok(found)) {
		*filep = fname;
		return j+1;
	    }
	}
    }
    return 0;
}

VALUE
rb_find_file(path)
    VALUE path;
{
    VALUE tmp;
    const char *f = StringValueCStr(path);
    const char *lpath;

    if (f[0] == '~') {
	path = rb_file_expand_path(path, Qnil);
	if (rb_safe_level() &gt;= 1 &amp;&amp; OBJ_TAINTED(path)) {
	    rb_raise(rb_eSecurityError, &quot;loading from unsafe path %s&quot;, f);
	}
	OBJ_FREEZE(path);
	f = StringValueCStr(path);
    }

#if defined(__MACOS__) || defined(riscos)
    if (is_macos_native_path(f)) {
	if (rb_safe_level() &gt;= 1 &amp;&amp; !fpath_check(f)) {
	    rb_raise(rb_eSecurityError, &quot;loading from unsafe file %s&quot;, f);
	}
	if (file_load_ok(f)) return path;
    }
#endif

    if (is_absolute_path(f)) {
	if (rb_safe_level() &gt;= 1 &amp;&amp; !fpath_check(f)) {
	    rb_raise(rb_eSecurityError, &quot;loading from unsafe file %s&quot;, f);
	}
	if (file_load_ok(f)) return path;
    }

    if (rb_safe_level() &gt;= 4) {
	rb_raise(rb_eSecurityError, &quot;loading from non-absolute path %s&quot;, f);
    }

    if (rb_load_path) {
	long i;

	Check_Type(rb_load_path, T_ARRAY);
	tmp = rb_ary_new();
	for (i=0;i&lt;RARRAY(rb_load_path)-&gt;len;i++) {
	    VALUE str = RARRAY(rb_load_path)-&gt;ptr[i];
	    SafeStringValue(str);
	    if (RSTRING(str)-&gt;len &gt; 0) {
		rb_ary_push(tmp, str);
	    }
	}
	tmp = rb_ary_join(tmp, rb_str_new2(PATH_SEP));
	if (RSTRING(tmp)-&gt;len == 0) {
	    lpath = 0;
	}
	else {
	    lpath = RSTRING(tmp)-&gt;ptr;
	}
    }
    else {
	lpath = 0;
    }

    if (!lpath) {
	return 0;		/* no path, no load */
    }
    if (!(f = dln_find_file(f, lpath))) {
	return 0;
    }
    if (rb_safe_level() &gt;= 1 &amp;&amp; !fpath_check(f)) {
	rb_raise(rb_eSecurityError, &quot;loading from unsafe file %s&quot;, f);
    }
    if (file_load_ok(f)) {
	tmp = rb_str_new2(f);
	OBJ_FREEZE(tmp);
	return tmp;
    }
    return 0;
}

static void
define_filetest_function(name, func, argc)
    const char *name;
    VALUE (*func)();
    int argc;
{
    rb_define_module_function(rb_mFileTest, name, func, argc);
    rb_define_singleton_method(rb_cFile, name, func, argc);
}


/*
 *  A &lt;code&gt;File&lt;/code&gt; is an abstraction of any file object accessible
 *  by the program and is closely associated with class &lt;code&gt;IO&lt;/code&gt;
 *  &lt;code&gt;File&lt;/code&gt; includes the methods of module
 *  &lt;code&gt;FileTest&lt;/code&gt; as class methods, allowing you to write (for
 *  example) &lt;code&gt;File.exist?(&quot;foo&quot;)&lt;/code&gt;.
 *     
 *  In the description of File methods,
 *  &lt;em&gt;permission bits&lt;/em&gt; are a platform-specific
 *  set of bits that indicate permissions of a file. On Unix-based
 *  systems, permissions are viewed as a set of three octets, for the
 *  owner, the group, and the rest of the world. For each of these
 *  entities, permissions may be set to read, write, or execute the
 *  file:
 *     
 *  The permission bits &lt;code&gt;0644&lt;/code&gt; (in octal) would thus be
 *  interpreted as read/write for owner, and read-only for group and
 *  other. Higher-order bits may also be used to indicate the type of
 *  file (plain, directory, pipe, socket, and so on) and various other
 *  special features. If the permissions are for a directory, the
 *  meaning of the execute bit changes; when set the directory can be
 *  searched.
 *     
 *  On non-Posix operating systems, there may be only the ability to
 *  make a file read-only or read-write. In this case, the remaining
 *  permission bits will be synthesized to resemble typical values. For
 *  instance, on Windows NT the default permission bits are
 *  &lt;code&gt;0644&lt;/code&gt;, which means read/write for owner, read-only for
 *  all others. The only change that can be made is to make the file
 *  read-only, which is reported as &lt;code&gt;0444&lt;/code&gt;.
 */

void
Init_File()
{
    rb_mFileTest = rb_define_module(&quot;FileTest&quot;);
    rb_cFile = rb_define_class(&quot;File&quot;, rb_cIO);

    define_filetest_function(&quot;directory?&quot;, test_d, 1);
    define_filetest_function(&quot;exist?&quot;, test_e, 1);
    define_filetest_function(&quot;exists?&quot;, test_e, 1); /* temporary */
    define_filetest_function(&quot;readable?&quot;, test_r, 1);
    define_filetest_function(&quot;readable_real?&quot;, test_R, 1);
    define_filetest_function(&quot;writable?&quot;, test_w, 1);
    define_filetest_function(&quot;writable_real?&quot;, test_W, 1);
    define_filetest_function(&quot;executable?&quot;, test_x, 1);
    define_filetest_function(&quot;executable_real?&quot;, test_X, 1);
    define_filetest_function(&quot;file?&quot;, test_f, 1);
    define_filetest_function(&quot;zero?&quot;, test_z, 1);
    define_filetest_function(&quot;size?&quot;, test_s, 1);
    define_filetest_function(&quot;size&quot;, rb_file_s_size, 1);
    define_filetest_function(&quot;owned?&quot;, test_owned, 1);
    define_filetest_function(&quot;grpowned?&quot;, test_grpowned, 1);

    define_filetest_function(&quot;pipe?&quot;, test_p, 1);
    define_filetest_function(&quot;symlink?&quot;, test_l, 1);
    define_filetest_function(&quot;socket?&quot;, test_S, 1);

    define_filetest_function(&quot;blockdev?&quot;, test_b, 1);
    define_filetest_function(&quot;chardev?&quot;, test_c, 1);

    define_filetest_function(&quot;setuid?&quot;, test_suid, 1);
    define_filetest_function(&quot;setgid?&quot;, test_sgid, 1);
    define_filetest_function(&quot;sticky?&quot;, test_sticky, 1);

    define_filetest_function(&quot;identical?&quot;, test_identical, 2);

    rb_define_singleton_method(rb_cFile, &quot;stat&quot;,  rb_file_s_stat, 1);
    rb_define_singleton_method(rb_cFile, &quot;lstat&quot;, rb_file_s_lstat, 1);
    rb_define_singleton_method(rb_cFile, &quot;ftype&quot;, rb_file_s_ftype, 1);

    rb_define_singleton_method(rb_cFile, &quot;atime&quot;, rb_file_s_atime, 1);
    rb_define_singleton_method(rb_cFile, &quot;mtime&quot;, rb_file_s_mtime, 1);
    rb_define_singleton_method(rb_cFile, &quot;ctime&quot;, rb_file_s_ctime, 1);

    rb_define_singleton_method(rb_cFile, &quot;utime&quot;, rb_file_s_utime, -1);
    rb_define_singleton_method(rb_cFile, &quot;chmod&quot;, rb_file_s_chmod, -1);
    rb_define_singleton_method(rb_cFile, &quot;chown&quot;, rb_file_s_chown, -1);
    rb_define_singleton_method(rb_cFile, &quot;lchmod&quot;, rb_file_s_lchmod, -1);
    rb_define_singleton_method(rb_cFile, &quot;lchown&quot;, rb_file_s_lchown, -1);

    rb_define_singleton_method(rb_cFile, &quot;link&quot;, rb_file_s_link, 2);
    rb_define_singleton_method(rb_cFile, &quot;symlink&quot;, rb_file_s_symlink, 2);
    rb_define_singleton_method(rb_cFile, &quot;readlink&quot;, rb_file_s_readlink, 1);

    rb_define_singleton_method(rb_cFile, &quot;unlink&quot;, rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, &quot;delete&quot;, rb_file_s_unlink, -2);
    rb_define_singleton_method(rb_cFile, &quot;rename&quot;, rb_file_s_rename, 2);
    rb_define_singleton_method(rb_cFile, &quot;umask&quot;, rb_file_s_umask, -1);
    rb_define_singleton_method(rb_cFile, &quot;truncate&quot;, rb_file_s_truncate, 2);
    rb_define_singleton_method(rb_cFile, &quot;expand_path&quot;, rb_file_s_expand_path, -1);
    rb_define_singleton_method(rb_cFile, &quot;basename&quot;, rb_file_s_basename, -1);
    rb_define_singleton_method(rb_cFile, &quot;dirname&quot;, rb_file_s_dirname, 1);
    rb_define_singleton_method(rb_cFile, &quot;extname&quot;, rb_file_s_extname, 1);

    separator = rb_obj_freeze(rb_str_new2(&quot;/&quot;));
    rb_define_const(rb_cFile, &quot;Separator&quot;, separator);
    rb_define_const(rb_cFile, &quot;SEPARATOR&quot;, separator);
    rb_define_singleton_method(rb_cFile, &quot;split&quot;,  rb_file_s_split, 1);
    rb_define_singleton_method(rb_cFile, &quot;join&quot;,   rb_file_s_join, -2);

#ifdef DOSISH
    rb_define_const(rb_cFile, &quot;ALT_SEPARATOR&quot;, rb_obj_freeze(rb_str_new2(&quot;\\&quot;)));
#else
    rb_define_const(rb_cFile, &quot;ALT_SEPARATOR&quot;, Qnil);
#endif
    rb_define_const(rb_cFile, &quot;PATH_SEPARATOR&quot;, rb_obj_freeze(rb_str_new2(PATH_SEP)));

    rb_define_method(rb_cIO, &quot;stat&quot;,  rb_io_stat, 0); /* this is IO's method */
    rb_define_method(rb_cFile, &quot;lstat&quot;,  rb_file_lstat, 0);

    rb_define_method(rb_cFile, &quot;atime&quot;, rb_file_atime, 0);
    rb_define_method(rb_cFile, &quot;mtime&quot;, rb_file_mtime, 0);
    rb_define_method(rb_cFile, &quot;ctime&quot;, rb_file_ctime, 0);

    rb_define_method(rb_cFile, &quot;chmod&quot;, rb_file_chmod, 1);
    rb_define_method(rb_cFile, &quot;chown&quot;, rb_file_chown, 2);
    rb_define_method(rb_cFile, &quot;truncate&quot;, rb_file_truncate, 1);

    rb_define_method(rb_cFile, &quot;flock&quot;, rb_file_flock, 1);

    rb_mFConst = rb_define_module_under(rb_cFile, &quot;Constants&quot;);
    rb_include_module(rb_cIO, rb_mFConst);
    rb_file_const(&quot;LOCK_SH&quot;, INT2FIX(LOCK_SH));
    rb_file_const(&quot;LOCK_EX&quot;, INT2FIX(LOCK_EX));
    rb_file_const(&quot;LOCK_UN&quot;, INT2FIX(LOCK_UN));
    rb_file_const(&quot;LOCK_NB&quot;, INT2FIX(LOCK_NB));

    rb_define_method(rb_cFile, &quot;path&quot;,  rb_file_path, 0);
    rb_define_global_function(&quot;test&quot;, rb_f_test, -1);

    rb_cStat = rb_define_class_under(rb_cFile, &quot;Stat&quot;, rb_cObject);
    rb_define_alloc_func(rb_cStat,  rb_stat_s_alloc);
    rb_define_method(rb_cStat, &quot;initialize&quot;, rb_stat_init, 1);
    rb_define_method(rb_cStat, &quot;initialize_copy&quot;, rb_stat_init_copy, 1);

    rb_include_module(rb_cStat, rb_mComparable);

    rb_define_method(rb_cStat, &quot;&lt;=&gt;&quot;, rb_stat_cmp, 1);

    rb_define_method(rb_cStat, &quot;dev&quot;, rb_stat_dev, 0);
    rb_define_method(rb_cStat, &quot;dev_major&quot;, rb_stat_dev_major, 0);
    rb_define_method(rb_cStat, &quot;dev_minor&quot;, rb_stat_dev_minor, 0);
    rb_define_method(rb_cStat, &quot;ino&quot;, rb_stat_ino, 0);
    rb_define_method(rb_cStat, &quot;mode&quot;, rb_stat_mode, 0);
    rb_define_method(rb_cStat, &quot;nlink&quot;, rb_stat_nlink, 0);
    rb_define_method(rb_cStat, &quot;uid&quot;, rb_stat_uid, 0);
    rb_define_method(rb_cStat, &quot;gid&quot;, rb_stat_gid, 0);
    rb_define_method(rb_cStat, &quot;rdev&quot;, rb_stat_rdev, 0);
    rb_define_method(rb_cStat, &quot;rdev_major&quot;, rb_stat_rdev_major, 0);
    rb_define_method(rb_cStat, &quot;rdev_minor&quot;, rb_stat_rdev_minor, 0);
    rb_define_method(rb_cStat, &quot;size&quot;, rb_stat_size, 0);
    rb_define_method(rb_cStat, &quot;blksize&quot;, rb_stat_blksize, 0);
    rb_define_method(rb_cStat, &quot;blocks&quot;, rb_stat_blocks, 0);
    rb_define_method(rb_cStat, &quot;atime&quot;, rb_stat_atime, 0);
    rb_define_method(rb_cStat, &quot;mtime&quot;, rb_stat_mtime, 0);
    rb_define_method(rb_cStat, &quot;ctime&quot;, rb_stat_ctime, 0);

    rb_define_method(rb_cStat, &quot;inspect&quot;, rb_stat_inspect, 0);

    rb_define_method(rb_cStat, &quot;ftype&quot;, rb_stat_ftype, 0);

    rb_define_method(rb_cStat, &quot;directory?&quot;,  rb_stat_d, 0);
    rb_define_method(rb_cStat, &quot;readable?&quot;,  rb_stat_r, 0);
    rb_define_method(rb_cStat, &quot;readable_real?&quot;,  rb_stat_R, 0);
    rb_define_method(rb_cStat, &quot;writable?&quot;,  rb_stat_w, 0);
    rb_define_method(rb_cStat, &quot;writable_real?&quot;,  rb_stat_W, 0);
    rb_define_method(rb_cStat, &quot;executable?&quot;,  rb_stat_x, 0);
    rb_define_method(rb_cStat, &quot;executable_real?&quot;,  rb_stat_X, 0);
    rb_define_method(rb_cStat, &quot;file?&quot;,  rb_stat_f, 0);
    rb_define_method(rb_cStat, &quot;zero?&quot;,  rb_stat_z, 0);
    rb_define_method(rb_cStat, &quot;size?&quot;,  rb_stat_s, 0);
    rb_define_method(rb_cStat, &quot;owned?&quot;,  rb_stat_owned, 0);
    rb_define_method(rb_cStat, &quot;grpowned?&quot;,  rb_stat_grpowned, 0);

    rb_define_method(rb_cStat, &quot;pipe?&quot;,  rb_stat_p, 0);
    rb_define_method(rb_cStat, &quot;symlink?&quot;,  rb_stat_l, 0);
    rb_define_method(rb_cStat, &quot;socket?&quot;,  rb_stat_S, 0);

    rb_define_method(rb_cStat, &quot;blockdev?&quot;,  rb_stat_b, 0);
    rb_define_method(rb_cStat, &quot;chardev?&quot;,  rb_stat_c, 0);

    rb_define_method(rb_cStat, &quot;setuid?&quot;,  rb_stat_suid, 0);
    rb_define_method(rb_cStat, &quot;setgid?&quot;,  rb_stat_sgid, 0);
    rb_define_method(rb_cStat, &quot;sticky?&quot;,  rb_stat_sticky, 0);
}
</pre>
    </div>