  <div id="fileHeader">
    <h1>struct.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/struct.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat May 31 06:44:49 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  struct.c -

  $Author: knu $
  $Date: 2008-05-31 20:44:49 +0900 (Sat, 31 May 2008) $
  created at: Tue Mar 22 18:44:30 JST 1995

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;env.h&quot;

VALUE rb_cStruct;

static VALUE struct_alloc _((VALUE));

VALUE
rb_struct_iv_get(c, name)
    VALUE c;
    const char *name;
{
    ID id;

    id = rb_intern(name);
    for (;;) {
	if (rb_ivar_defined(c, id))
	    return rb_ivar_get(c, id);
	c = RCLASS(c)-&gt;super;
	if (c == 0 || c == rb_cStruct)
	    return Qnil;
    }
}

VALUE
rb_struct_s_members(klass)
    VALUE klass;
{
    VALUE members = rb_struct_iv_get(klass, &quot;__members__&quot;);

    if (NIL_P(members)) {
	rb_raise(rb_eTypeError, &quot;uninitialized struct&quot;);
    }
    if (TYPE(members) != T_ARRAY) {
	rb_raise(rb_eTypeError, &quot;corrupted struct&quot;);
    }
    return members;
}

VALUE
rb_struct_members(s)
    VALUE s;
{
    VALUE members = rb_struct_s_members(rb_obj_class(s));

    if (RSTRUCT(s)-&gt;len != RARRAY(members)-&gt;len) {
	rb_raise(rb_eTypeError, &quot;struct size differs (%d required %d given)&quot;,
		 RARRAY(members)-&gt;len, RSTRUCT(s)-&gt;len);
    }
    return members;
}

static VALUE
rb_struct_s_members_m(klass)
    VALUE klass;
{
    VALUE members, ary;
    VALUE *p, *pend;

    members = rb_struct_s_members(klass);
    ary = rb_ary_new2(RARRAY(members)-&gt;len);
    p = RARRAY(members)-&gt;ptr; pend = p + RARRAY(members)-&gt;len;
    while (p &lt; pend) {
	rb_ary_push(ary, rb_str_new2(rb_id2name(SYM2ID(*p))));
	p++;
    }

    return ary;
}

/*
 *  call-seq:
 *     struct.members    =&gt; array
 *  
 *  Returns an array of strings representing the names of the instance
 *  variables.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.members   #=&gt; [&quot;name&quot;, &quot;address&quot;, &quot;zip&quot;]
 */

static VALUE
rb_struct_members_m(obj)
    VALUE obj;
{
    return rb_struct_s_members_m(rb_obj_class(obj));
}

VALUE
rb_struct_getmember(obj, id)
    VALUE obj;
    ID id;
{
    VALUE members, slot;
    long i;

    members = rb_struct_members(obj);
    slot = ID2SYM(id);
    for (i=0; i&lt;RARRAY(members)-&gt;len; i++) {
	if (RARRAY(members)-&gt;ptr[i] == slot) {
	    return RSTRUCT(obj)-&gt;ptr[i];
	}
    }
    rb_name_error(id, &quot;%s is not struct member&quot;, rb_id2name(id));
    return Qnil;		/* not reached */
}

static VALUE
rb_struct_ref(obj)
    VALUE obj;
{
    return rb_struct_getmember(obj, ruby_frame-&gt;orig_func);
}

static VALUE rb_struct_ref0(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[0];}
static VALUE rb_struct_ref1(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[1];}
static VALUE rb_struct_ref2(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[2];}
static VALUE rb_struct_ref3(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[3];}
static VALUE rb_struct_ref4(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[4];}
static VALUE rb_struct_ref5(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[5];}
static VALUE rb_struct_ref6(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[6];}
static VALUE rb_struct_ref7(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[7];}
static VALUE rb_struct_ref8(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[8];}
static VALUE rb_struct_ref9(obj) VALUE obj; {return RSTRUCT(obj)-&gt;ptr[9];}

static VALUE (*ref_func[10])() = {
    rb_struct_ref0,
    rb_struct_ref1,
    rb_struct_ref2,
    rb_struct_ref3,
    rb_struct_ref4,
    rb_struct_ref5,
    rb_struct_ref6,
    rb_struct_ref7,
    rb_struct_ref8,
    rb_struct_ref9,
};

static void
rb_struct_modify(s)
    VALUE s;
{
    if (OBJ_FROZEN(s)) rb_error_frozen(&quot;Struct&quot;);
    if (!OBJ_TAINTED(s) &amp;&amp; rb_safe_level() &gt;= 4)
       rb_raise(rb_eSecurityError, &quot;Insecure: can't modify Struct&quot;);
}

static VALUE
rb_struct_set(obj, val)
    VALUE obj, val;
{
    VALUE members, slot;
    ID id;
    long i;

    members = rb_struct_members(obj);
    rb_struct_modify(obj);
    id = ruby_frame-&gt;orig_func;
    for (i=0; i&lt;RARRAY(members)-&gt;len; i++) {
	slot = RARRAY(members)-&gt;ptr[i];
	if (rb_id_attrset(SYM2ID(slot)) == id) {
	    return RSTRUCT(obj)-&gt;ptr[i] = val;
	}
    }
    rb_name_error(ruby_frame-&gt;last_func, &quot;`%s' is not a struct member&quot;,
		  rb_id2name(id));
    return Qnil;		/* not reached */
}

static VALUE
make_struct(name, members, klass)
    VALUE name, members, klass;
{
    VALUE nstr;
    ID id;
    long i;

    OBJ_FREEZE(members);
    if (NIL_P(name)) {
	nstr = rb_class_new(klass);
	rb_make_metaclass(nstr, RBASIC(klass)-&gt;klass);
	rb_class_inherited(klass, nstr);
    }
    else {
	char *cname = StringValuePtr(name);
	id = rb_intern(cname);
	if (!rb_is_const_id(id)) {
	    rb_name_error(id, &quot;identifier %s needs to be constant&quot;, cname);
	}
	if (rb_const_defined_at(klass, id)) {
	    rb_warn(&quot;redefining constant Struct::%s&quot;, cname);
	    rb_mod_remove_const(klass, ID2SYM(id));
	}
	nstr = rb_define_class_under(klass, rb_id2name(id), klass);
    }
    rb_iv_set(nstr, &quot;__size__&quot;, LONG2NUM(RARRAY(members)-&gt;len));
    rb_iv_set(nstr, &quot;__members__&quot;, members);

    rb_define_alloc_func(nstr, struct_alloc);
    rb_define_singleton_method(nstr, &quot;new&quot;, rb_class_new_instance, -1);
    rb_define_singleton_method(nstr, &quot;[]&quot;, rb_class_new_instance, -1);
    rb_define_singleton_method(nstr, &quot;members&quot;, rb_struct_s_members_m, 0);
    for (i=0; i&lt; RARRAY(members)-&gt;len; i++) {
	ID id = SYM2ID(RARRAY(members)-&gt;ptr[i]);
	if (rb_is_local_id(id) || rb_is_const_id(id)) {
	    if (i&lt;10) {
		rb_define_method_id(nstr, id, ref_func[i], 0);
	    }
	    else {
		rb_define_method_id(nstr, id, rb_struct_ref, 0);
	    }
	    rb_define_method_id(nstr, rb_id_attrset(id), rb_struct_set, 1);
	}
    }

    return nstr;
}

#ifdef HAVE_STDARG_PROTOTYPES
#include &lt;stdarg.h&gt;
#define va_init_list(a,b) va_start(a,b)
#else
#include &lt;varargs.h&gt;
#define va_init_list(a,b) va_start(a)
#endif

VALUE
#ifdef HAVE_STDARG_PROTOTYPES
rb_struct_define(const char *name, ...)
#else
rb_struct_define(name, va_alist)
    const char *name;
    va_dcl
#endif
{
    va_list ar;
    VALUE nm, ary;
    char *mem;

    if (!name) nm = Qnil;
    else nm = rb_str_new2(name);
    ary = rb_ary_new();

    va_init_list(ar, name);
    while ((mem = va_arg(ar, char*)) != 0) {
	ID slot = rb_intern(mem);
	rb_ary_push(ary, ID2SYM(slot));
    }
    va_end(ar);

    return make_struct(nm, ary, rb_cStruct);
}

/*
 *  call-seq:
 *     Struct.new( [aString] [, aSym]+&gt; )    =&gt; StructClass
 *     StructClass.new(arg, ...)             =&gt; obj
 *     StructClass[arg, ...]                 =&gt; obj
 *
 *  Creates a new class, named by &lt;i&gt;aString&lt;/i&gt;, containing accessor
 *  methods for the given symbols. If the name &lt;i&gt;aString&lt;/i&gt; is
 *  omitted, an anonymous structure class will be created. Otherwise,
 *  the name of this struct will appear as a constant in class
 *  &lt;code&gt;Struct&lt;/code&gt;, so it must be unique for all
 *  &lt;code&gt;Struct&lt;/code&gt;s in the system and should start with a capital
 *  letter. Assigning a structure class to a constant effectively gives
 *  the class the name of the constant.
 *     
 *  &lt;code&gt;Struct::new&lt;/code&gt; returns a new &lt;code&gt;Class&lt;/code&gt; object,
 *  which can then be used to create specific instances of the new
 *  structure. The number of actual parameters must be
 *  less than or equal to the number of attributes defined for this
 *  class; unset parameters default to \nil{}.  Passing too many
 *  parameters will raise an \E{ArgumentError}.
 *
 *  The remaining methods listed in this section (class and instance)
 *  are defined for this generated class. 
 *     
 *     # Create a structure with a name in Struct
 *     Struct.new(&quot;Customer&quot;, :name, :address)    #=&gt; Struct::Customer
 *     Struct::Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)   #=&gt; #&lt;Struct::Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;
 *     
 *     # Create a structure named by its constant
 *     Customer = Struct.new(:name, :address)     #=&gt; Customer
 *     Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)           #=&gt; #&lt;Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;
 */

static VALUE
rb_struct_s_def(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE name, rest;
    long i;
    VALUE st;
    ID id;

    rb_scan_args(argc, argv, &quot;1*&quot;, &amp;name, &amp;rest);
    if (!NIL_P(name) &amp;&amp; SYMBOL_P(name)) {
	rb_ary_unshift(rest, name);
	name = Qnil;
    }
    for (i=0; i&lt;RARRAY(rest)-&gt;len; i++) {
	id = rb_to_id(RARRAY(rest)-&gt;ptr[i]);
	RARRAY(rest)-&gt;ptr[i] = ID2SYM(id);
    }
    st = make_struct(name, rest, klass);
    if (rb_block_given_p()) {
	rb_mod_module_eval(0, 0, st);
    }

    return st;
}

/*
 */

static VALUE
rb_struct_initialize(self, values)
    VALUE self, values;
{
    VALUE klass = rb_obj_class(self);
    VALUE size;
    long n;

    rb_struct_modify(self);
    size = rb_struct_iv_get(klass, &quot;__size__&quot;);
    n = FIX2LONG(size);
    if (n &lt; RARRAY(values)-&gt;len) {
	rb_raise(rb_eArgError, &quot;struct size differs&quot;);
    }
    MEMCPY(RSTRUCT(self)-&gt;ptr, RARRAY(values)-&gt;ptr, VALUE, RARRAY(values)-&gt;len);
    if (n &gt; RARRAY(values)-&gt;len) {
	rb_mem_clear(RSTRUCT(self)-&gt;ptr+RARRAY(values)-&gt;len,
		     n-RARRAY(values)-&gt;len);
    }
    return Qnil;
}

static VALUE
struct_alloc(klass)
    VALUE klass;
{
    VALUE size;
    long n;
    NEWOBJ(st, struct RStruct);
    OBJSETUP(st, klass, T_STRUCT);

    size = rb_struct_iv_get(klass, &quot;__size__&quot;);
    n = FIX2LONG(size);

    st-&gt;ptr = ALLOC_N(VALUE, n);
    rb_mem_clear(st-&gt;ptr, n);
    st-&gt;len = n;

    return (VALUE)st;
}

VALUE
rb_struct_alloc(klass, values)
    VALUE klass, values;
{
    return rb_class_new_instance(RARRAY(values)-&gt;len, RARRAY(values)-&gt;ptr, klass);
}

VALUE
#ifdef HAVE_STDARG_PROTOTYPES
rb_struct_new(VALUE klass, ...)
#else
rb_struct_new(klass, va_alist)
    VALUE klass;
    va_dcl
#endif
{
    VALUE sz, *mem;
    long size, i;
    va_list args;

    sz = rb_struct_iv_get(klass, &quot;__size__&quot;);
    size = FIX2LONG(sz); 
    mem = ALLOCA_N(VALUE, size);
    va_init_list(args, klass);
    for (i=0; i&lt;size; i++) {
	mem[i] = va_arg(args, VALUE);
    }
    va_end(args);

    return rb_class_new_instance(size, mem, klass);
}

/*
 *  call-seq:
 *     struct.each {|obj| block }  =&gt; struct
 *  
 *  Calls &lt;i&gt;block&lt;/i&gt; once for each instance variable, passing the
 *  value as a parameter.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.each {|x| puts(x) }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Joe Smith
 *     123 Maple, Anytown NC
 *     12345
 */

static VALUE
rb_struct_each(s)
    VALUE s;
{
    long i;

    RETURN_ENUMERATOR(s, 0, 0);
    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
	rb_yield(RSTRUCT(s)-&gt;ptr[i]);
    }
    return s;
}

/*
 *  call-seq:
 *     struct.each_pair {|sym, obj| block }     =&gt; struct
 *  
 *  Calls &lt;i&gt;block&lt;/i&gt; once for each instance variable, passing the name
 *  (as a symbol) and the value as parameters.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.each_pair {|name, value| puts(&quot;#{name} =&gt; #{value}&quot;) }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     name =&gt; Joe Smith
 *     address =&gt; 123 Maple, Anytown NC
 *     zip =&gt; 12345
 */

static VALUE
rb_struct_each_pair(s)
    VALUE s;
{
    VALUE members;
    long i;

    RETURN_ENUMERATOR(s, 0, 0);
    members = rb_struct_members(s);
    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
	rb_yield_values(2, rb_ary_entry(members, i), RSTRUCT(s)-&gt;ptr[i]);
    }
    return s;
}

static VALUE
inspect_struct(s)
    VALUE s;
{
    const char *cname = rb_class2name(rb_obj_class(s));
    VALUE str, members;
    long i;

    members = rb_struct_members(s);
    str = rb_str_buf_new2(&quot;#&lt;struct &quot;);
    rb_str_cat2(str, cname);
    rb_str_cat2(str, &quot; &quot;);
    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
	VALUE slot;
	ID id;
	const char *p;

	if (i &gt; 0) {
	    rb_str_cat2(str, &quot;, &quot;);
	}
	slot = RARRAY(members)-&gt;ptr[i];
	id = SYM2ID(slot);
	if (rb_is_local_id(id) || rb_is_const_id(id)) {
	    p = rb_id2name(id);
	    rb_str_cat2(str, p);
	}
	else {
	    rb_str_append(str, rb_inspect(slot));
	}
	rb_str_cat2(str, &quot;=&quot;);
	rb_str_append(str, rb_inspect(RSTRUCT(s)-&gt;ptr[i]));
    }
    rb_str_cat2(str, &quot;&gt;&quot;);
    OBJ_INFECT(str, s);

    return str;
}

/*
 * call-seq:
 *   struct.to_s      =&gt; string
 *   struct.inspect   =&gt; string
 *
 * Describe the contents of this struct in a string.
 */

static VALUE
rb_struct_inspect(s)
    VALUE s;
{
    if (rb_inspecting_p(s)) {
	const char *cname = rb_class2name(rb_obj_class(s));
	size_t len = strlen(cname) + 14;
	VALUE str = rb_str_new(0, len);

	snprintf(RSTRING(str)-&gt;ptr, len+1, &quot;#&lt;struct %s:...&gt;&quot;, cname);
	RSTRING(str)-&gt;len = strlen(RSTRING(str)-&gt;ptr);
	return str;
    }
    return rb_protect_inspect(inspect_struct, s, 0);
}

/*
 *  call-seq:
 *     struct.to_a     =&gt; array
 *     struct.values   =&gt; array
 *  
 *  Returns the values for this instance as an array.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.to_a[1]   #=&gt; &quot;123 Maple, Anytown NC&quot;
 */

static VALUE
rb_struct_to_a(s)
    VALUE s;
{
    return rb_ary_new4(RSTRUCT(s)-&gt;len, RSTRUCT(s)-&gt;ptr);
}

/* :nodoc: */
static VALUE
rb_struct_init_copy(copy, s)
    VALUE copy, s;
{
    if (copy == s) return copy;
    rb_check_frozen(copy);
    if (!rb_obj_is_instance_of(s, rb_obj_class(copy))) {
	rb_raise(rb_eTypeError, &quot;wrong argument class&quot;);
    }
    if (RSTRUCT(copy)-&gt;len != RSTRUCT(s)-&gt;len) {
	rb_raise(rb_eTypeError, &quot;struct size mismatch&quot;);
    }
    MEMCPY(RSTRUCT(copy)-&gt;ptr, RSTRUCT(s)-&gt;ptr, VALUE, RSTRUCT(copy)-&gt;len);

    return copy;
}

static VALUE
rb_struct_aref_id(s, id)
    VALUE s;
    ID id;
{
    VALUE members;
    long i, len;

    members = rb_struct_members(s);
    len = RARRAY(members)-&gt;len;
    for (i=0; i&lt;len; i++) {
	if (SYM2ID(RARRAY(members)-&gt;ptr[i]) == id) {
	    return RSTRUCT(s)-&gt;ptr[i];
	}
    }
    rb_name_error(id, &quot;no member '%s' in struct&quot;, rb_id2name(id));
    return Qnil;		/* not reached */
}

/*
 *  call-seq:
 *     struct[symbol]    =&gt; anObject
 *     struct[fixnum]    =&gt; anObject 
 *  
 *  Attribute Reference---Returns the value of the instance variable
 *  named by &lt;i&gt;symbol&lt;/i&gt;, or indexed (0..length-1) by
 *  &lt;i&gt;fixnum&lt;/i&gt;. Will raise &lt;code&gt;NameError&lt;/code&gt; if the named
 *  variable does not exist, or &lt;code&gt;IndexError&lt;/code&gt; if the index is
 *  out of range.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     
 *     joe[&quot;name&quot;]   #=&gt; &quot;Joe Smith&quot;
 *     joe[:name]    #=&gt; &quot;Joe Smith&quot;
 *     joe[0]        #=&gt; &quot;Joe Smith&quot;
 */

VALUE
rb_struct_aref(s, idx)
    VALUE s, idx;
{
    long i;

    if (TYPE(idx) == T_STRING || TYPE(idx) == T_SYMBOL) {
	return rb_struct_aref_id(s, rb_to_id(idx));
    }

    i = NUM2LONG(idx);
    if (i &lt; 0) i = RSTRUCT(s)-&gt;len + i;
    if (i &lt; 0)
        rb_raise(rb_eIndexError, &quot;offset %ld too small for struct(size:%ld)&quot;,
		 i, RSTRUCT(s)-&gt;len);
    if (RSTRUCT(s)-&gt;len &lt;= i)
        rb_raise(rb_eIndexError, &quot;offset %ld too large for struct(size:%ld)&quot;,
		 i, RSTRUCT(s)-&gt;len);
    return RSTRUCT(s)-&gt;ptr[i];
}

static VALUE
rb_struct_aset_id(s, id, val)
    VALUE s, val;
    ID id;
{
    VALUE members;
    long i, len;

    members = rb_struct_members(s);
    rb_struct_modify(s);
    len = RARRAY(members)-&gt;len;
    if (RSTRUCT(s)-&gt;len != RARRAY(members)-&gt;len) {
	rb_raise(rb_eTypeError, &quot;struct size differs (%d required %d given)&quot;,
		 RARRAY(members)-&gt;len, RSTRUCT(s)-&gt;len);
    }
    for (i=0; i&lt;len; i++) {
	if (SYM2ID(RARRAY(members)-&gt;ptr[i]) == id) {
	    RSTRUCT(s)-&gt;ptr[i] = val;
	    return val;
	}
    }
    rb_name_error(id, &quot;no member '%s' in struct&quot;, rb_id2name(id));
}

/*
 *  call-seq:
 *     struct[symbol] = obj    =&gt; obj
 *     struct[fixnum] = obj    =&gt; obj
 *  
 *  Attribute Assignment---Assigns to the instance variable named by
 *  &lt;i&gt;symbol&lt;/i&gt; or &lt;i&gt;fixnum&lt;/i&gt; the value &lt;i&gt;obj&lt;/i&gt; and
 *  returns it. Will raise a &lt;code&gt;NameError&lt;/code&gt; if the named
 *  variable does not exist, or an &lt;code&gt;IndexError&lt;/code&gt; if the index
 *  is out of range.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     
 *     joe[&quot;name&quot;] = &quot;Luke&quot;
 *     joe[:zip]   = &quot;90210&quot;
 *     
 *     joe.name   #=&gt; &quot;Luke&quot;
 *     joe.zip    #=&gt; &quot;90210&quot;
 */

VALUE
rb_struct_aset(s, idx, val)
    VALUE s, idx, val;
{
    long i;

    if (TYPE(idx) == T_STRING || TYPE(idx) == T_SYMBOL) {
	return rb_struct_aset_id(s, rb_to_id(idx), val);
    }

    i = NUM2LONG(idx);
    if (i &lt; 0) i = RSTRUCT(s)-&gt;len + i;
    if (i &lt; 0) {
        rb_raise(rb_eIndexError, &quot;offset %ld too small for struct(size:%ld)&quot;,
		 i, RSTRUCT(s)-&gt;len);
    }
    if (RSTRUCT(s)-&gt;len &lt;= i) {
        rb_raise(rb_eIndexError, &quot;offset %ld too large for struct(size:%ld)&quot;,
		 i, RSTRUCT(s)-&gt;len);
    }
    rb_struct_modify(s);
    return RSTRUCT(s)-&gt;ptr[i] = val;
}

static VALUE struct_entry _((VALUE, long));
static VALUE
struct_entry(s, n)
    VALUE s;
    long n;
{
    return rb_struct_aref(s, LONG2NUM(n));
}

/* 
 * call-seq:
 *   struct.values_at(selector,... )  =&gt; an_array
 *
 *   Returns an array containing the elements in
 *   _self_ corresponding to the given selector(s). The selectors
 *   may be either integer indices or ranges. 
 *   See also &lt;/code&gt;.select&lt;code&gt;.
 * 
 *      a = %w{ a b c d e f }
 *      a.values_at(1, 3, 5)
 *      a.values_at(1, 3, 5, 7)
 *      a.values_at(-1, -3, -5, -7)
 *      a.values_at(1..3, 2...5)
 */

static VALUE
rb_struct_values_at(argc, argv, s)
    int argc;
    VALUE *argv;
    VALUE s;
{
    return rb_values_at(s, RSTRUCT(s)-&gt;len, argc, argv, struct_entry);
}

/*
 *  call-seq:
 *     struct.select {|i| block }    =&gt; array
 *  
 *  Invokes the block passing in successive elements from
 *  &lt;i&gt;struct&lt;/i&gt;, returning an array containing those elements
 *  for which the block returns a true value (equivalent to
 *  &lt;code&gt;Enumerable#select&lt;/code&gt;).
 *     
 *     Lots = Struct.new(:a, :b, :c, :d, :e, :f)
 *     l = Lots.new(11, 22, 33, 44, 55, 66)
 *     l.select {|v| (v % 2).zero? }   #=&gt; [22, 44, 66]
 */

static VALUE
rb_struct_select(argc, argv, s)
    int argc;
    VALUE *argv;
    VALUE s;
{
    VALUE result;
    long i;

    if (argc &gt; 0) {
	rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 0)&quot;, argc);
    }
    result = rb_ary_new();
    for (i = 0; i &lt; RSTRUCT(s)-&gt;len; i++) {
	if (RTEST(rb_yield(RSTRUCT(s)-&gt;ptr[i]))) {
	    rb_ary_push(result, RSTRUCT(s)-&gt;ptr[i]);
	}
    }

    return result;
}

/*
 *  call-seq:
 *     struct == other_struct     =&gt; true or false
 *  
 *  Equality---Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;other_struct&lt;/i&gt; is
 *  equal to this one: they must be of the same class as generated by
 *  &lt;code&gt;Struct::new&lt;/code&gt;, and the values of all instance variables
 *  must be equal (according to &lt;code&gt;Object#==&lt;/code&gt;).
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe   = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joejr = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     jane  = Customer.new(&quot;Jane Doe&quot;, &quot;456 Elm, Anytown NC&quot;, 12345)
 *     joe == joejr   #=&gt; true
 *     joe == jane    #=&gt; false
 */

static VALUE
rb_struct_equal(s, s2)
    VALUE s, s2;
{
    long i;

    if (s == s2) return Qtrue;
    if (TYPE(s2) != T_STRUCT) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT(s)-&gt;len != RSTRUCT(s2)-&gt;len) {
	rb_bug(&quot;inconsistent struct&quot;); /* should never happen */
    }

    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
	if (!rb_equal(RSTRUCT(s)-&gt;ptr[i], RSTRUCT(s2)-&gt;ptr[i])) return Qfalse;
    }
    return Qtrue;
}

/*
 * call-seq:
 *   struct.hash   =&gt; fixnum
 *
 * Return a hash value based on this struct's contents.
 */

static VALUE
rb_struct_hash(s)
    VALUE s;
{
    long i, h;
    VALUE n;

    h = rb_hash(rb_obj_class(s));
    for (i = 0; i &lt; RSTRUCT(s)-&gt;len; i++) {
	h = (h &lt;&lt; 1) | (h&lt;0 ? 1 : 0);
	n = rb_hash(RSTRUCT(s)-&gt;ptr[i]);
	h ^= NUM2LONG(n);
    }
    return LONG2FIX(h);
}

/*
 * code-seq:
 *   struct.eql?(other)   =&gt; true or false
 *
 * Two structures are equal if they are the same object, or if all their
 * fields are equal (using &lt;code&gt;eql?&lt;/code&gt;).
 */

static VALUE
rb_struct_eql(s, s2)
    VALUE s, s2;
{
    long i;

    if (s == s2) return Qtrue;
    if (TYPE(s2) != T_STRUCT) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT(s)-&gt;len != RSTRUCT(s2)-&gt;len) {
	rb_bug(&quot;inconsistent struct&quot;); /* should never happen */
    }

    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
	if (!rb_eql(RSTRUCT(s)-&gt;ptr[i], RSTRUCT(s2)-&gt;ptr[i])) return Qfalse;
    }
    return Qtrue;
}

/*
 *  call-seq:
 *     struct.length    =&gt; fixnum
 *     struct.size      =&gt; fixnum
 *  
 *  Returns the number of instance variables.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.length   #=&gt; 3
 */

static VALUE
rb_struct_size(s)
    VALUE s;
{
    return LONG2FIX(RSTRUCT(s)-&gt;len);
}

/*
 *  A &lt;code&gt;Struct&lt;/code&gt; is a convenient way to bundle a number of
 *  attributes together, using accessor methods, without having to write
 *  an explicit class.
 *     
 *  The &lt;code&gt;Struct&lt;/code&gt; class is a generator of specific classes,
 *  each one of which is defined to hold a set of variables and their
 *  accessors. In these examples, we'll call the generated class
 *  ``&lt;i&gt;Customer&lt;/i&gt;Class,'' and we'll show an example instance of that
 *  class as ``&lt;i&gt;Customer&lt;/i&gt;Inst.''
 *     
 *  In the descriptions that follow, the parameter &lt;i&gt;symbol&lt;/i&gt; refers
 *  to a symbol, which is either a quoted string or a
 *  &lt;code&gt;Symbol&lt;/code&gt; (such as &lt;code&gt;:name&lt;/code&gt;).
 */
void
Init_Struct()
{
    rb_cStruct = rb_define_class(&quot;Struct&quot;, rb_cObject);
    rb_include_module(rb_cStruct, rb_mEnumerable);

    rb_undef_alloc_func(rb_cStruct);
    rb_define_singleton_method(rb_cStruct, &quot;new&quot;, rb_struct_s_def, -1);

    rb_define_method(rb_cStruct, &quot;initialize&quot;, rb_struct_initialize, -2);
    rb_define_method(rb_cStruct, &quot;initialize_copy&quot;, rb_struct_init_copy, 1);

    rb_define_method(rb_cStruct, &quot;==&quot;, rb_struct_equal, 1);
    rb_define_method(rb_cStruct, &quot;eql?&quot;, rb_struct_eql, 1);
    rb_define_method(rb_cStruct, &quot;hash&quot;, rb_struct_hash, 0);

    rb_define_method(rb_cStruct, &quot;to_s&quot;, rb_struct_inspect, 0);
    rb_define_method(rb_cStruct, &quot;inspect&quot;, rb_struct_inspect, 0);
    rb_define_method(rb_cStruct, &quot;to_a&quot;, rb_struct_to_a, 0);
    rb_define_method(rb_cStruct, &quot;values&quot;, rb_struct_to_a, 0);
    rb_define_method(rb_cStruct, &quot;size&quot;, rb_struct_size, 0);
    rb_define_method(rb_cStruct, &quot;length&quot;, rb_struct_size, 0);

    rb_define_method(rb_cStruct, &quot;each&quot;, rb_struct_each, 0);
    rb_define_method(rb_cStruct, &quot;each_pair&quot;, rb_struct_each_pair, 0);
    rb_define_method(rb_cStruct, &quot;[]&quot;, rb_struct_aref, 1);
    rb_define_method(rb_cStruct, &quot;[]=&quot;, rb_struct_aset, 2);
    rb_define_method(rb_cStruct, &quot;select&quot;, rb_struct_select, -1);
    rb_define_method(rb_cStruct, &quot;values_at&quot;, rb_struct_values_at, -1);

    rb_define_method(rb_cStruct, &quot;members&quot;, rb_struct_members_m, 0);
}
</pre>
    </div>