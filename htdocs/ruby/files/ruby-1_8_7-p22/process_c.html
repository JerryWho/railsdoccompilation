  <div id="fileHeader">
    <h1>process.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/process.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 05:39:57 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  process.c -

  $Author: knu $
  $Date: 2008-06-06 19:39:57 +0900 (Fri, 06 Jun 2008) $
  created at: Tue Aug 10 14:30:50 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto
  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
  Copyright (C) 2000  Information-technology Promotion Agency, Japan

**********************************************************************/

#include &quot;ruby.h&quot;
#include &quot;rubysig.h&quot;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#ifdef HAVE_STDLIB_H
#include &lt;stdlib.h&gt;
#endif
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif
#ifdef __DJGPP__
#include &lt;process.h&gt;
#endif

#include &lt;time.h&gt;
#include &lt;ctype.h&gt;

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif

struct timeval rb_time_interval _((VALUE));

#ifdef HAVE_SYS_WAIT_H
# include &lt;sys/wait.h&gt;
#endif
#ifdef HAVE_GETPRIORITY
# include &lt;sys/resource.h&gt;
#endif
#include &quot;st.h&quot;

#ifdef __EMX__
#undef HAVE_GETPGRP
#endif

#ifdef HAVE_SYS_TIMES_H
#include &lt;sys/times.h&gt;
#endif

#ifdef HAVE_GRP_H
#include &lt;grp.h&gt;
#endif

#if defined(HAVE_TIMES) || defined(_WIN32)
static VALUE S_Tms;
#endif

#ifndef WIFEXITED
#define WIFEXITED(w)    (((w) &amp; 0xff) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)  (((w) &amp; 0x7f) &gt; 0 &amp;&amp; (((w) &amp; 0x7f) &lt; 0x7f))
#endif
#ifndef WIFSTOPPED
#define WIFSTOPPED(w)   (((w) &amp; 0xff) == 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)  (((w) &gt;&gt; 8) &amp; 0xff)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)     ((w) &amp; 0x7f)
#endif
#ifndef WSTOPSIG
#define WSTOPSIG        WEXITSTATUS
#endif

#if defined(__APPLE__) &amp;&amp; ( defined(__MACH__) || defined(__DARWIN__) ) &amp;&amp; !defined(__MacOS_X__)
#define __MacOS_X__ 1
#endif

#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__)
#define HAVE_44BSD_SETUID 1
#define HAVE_44BSD_SETGID 1
#endif

#ifdef __NetBSD__
#undef HAVE_SETRUID
#undef HAVE_SETRGID
#endif

#ifdef BROKEN_SETREUID
#define setreuid ruby_setreuid
#endif
#ifdef BROKEN_SETREGID
#define setregid ruby_setregid
#endif

#if defined(HAVE_44BSD_SETUID) || defined(__MacOS_X__)
#if !defined(USE_SETREUID) &amp;&amp; !defined(BROKEN_SETREUID)
#define OBSOLETE_SETREUID 1
#endif
#if !defined(USE_SETREGID) &amp;&amp; !defined(BROKEN_SETREGID)
#define OBSOLETE_SETREGID 1
#endif
#endif

#define preserving_errno(stmts) \
	do {int saved_errno = errno; stmts; errno = saved_errno;} while (0)


/*
 *  call-seq:
 *     Process.pid   =&gt; fixnum
 *
 *  Returns the process id of this process. Not available on all
 *  platforms.
 *
 *     Process.pid   #=&gt; 27415
 */

static VALUE
get_pid()
{
    rb_secure(2);
    return INT2FIX(getpid());
}


/*
 *  call-seq:
 *     Process.ppid   =&gt; fixnum
 *
 *  Returns the process id of the parent of this process. Always
 *  returns 0 on NT. Not available on all platforms.
 *
 *     puts &quot;I am #{Process.pid}&quot;
 *     Process.fork { puts &quot;Dad is #{Process.ppid}&quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     I am 27417
 *     Dad is 27417
 */

static VALUE
get_ppid()
{
    rb_secure(2);
#ifdef _WIN32
    return INT2FIX(0);
#else
    return INT2FIX(getppid());
#endif
}


/*********************************************************************
 *
 * Document-class: Process::Status
 *
 *  &lt;code&gt;Process::Status&lt;/code&gt; encapsulates the information on the
 *  status of a running or terminated system process. The built-in
 *  variable &lt;code&gt;$?&lt;/code&gt; is either +nil+ or a
 *  &lt;code&gt;Process::Status&lt;/code&gt; object.
 *
 *     fork { exit 99 }   #=&gt; 26557
 *     Process.wait       #=&gt; 26557
 *     $?.class           #=&gt; Process::Status
 *     $?.to_i            #=&gt; 25344
 *     $? &gt;&gt; 8            #=&gt; 99
 *     $?.stopped?        #=&gt; false
 *     $?.exited?         #=&gt; true
 *     $?.exitstatus      #=&gt; 99
 *
 *  Posix systems record information on processes using a 16-bit
 *  integer.  The lower bits record the process status (stopped,
 *  exited, signaled) and the upper bits possibly contain additional
 *  information (for example the program's return code in the case of
 *  exited processes). Pre Ruby 1.8, these bits were exposed directly
 *  to the Ruby program. Ruby now encapsulates these in a
 *  &lt;code&gt;Process::Status&lt;/code&gt; object. To maximize compatibility,
 *  however, these objects retain a bit-oriented interface. In the
 *  descriptions that follow, when we talk about the integer value of
 *  _stat_, we're referring to this 16 bit value.
 */

static VALUE rb_cProcStatus;
VALUE rb_last_status = Qnil;

static void
last_status_set(status, pid)
    int status, pid;
{
    rb_last_status = rb_obj_alloc(rb_cProcStatus);
    rb_iv_set(rb_last_status, &quot;status&quot;, INT2FIX(status));
    rb_iv_set(rb_last_status, &quot;pid&quot;, INT2FIX(pid));
}


/*
 *  call-seq:
 *     stat.to_i     =&gt; fixnum
 *     stat.to_int   =&gt; fixnum
 *
 *  Returns the bits in _stat_ as a &lt;code&gt;Fixnum&lt;/code&gt;. Poking
 *  around in these bits is platform dependent.
 *
 *     fork { exit 0xab }         #=&gt; 26566
 *     Process.wait               #=&gt; 26566
 *     sprintf('%04x', $?.to_i)   #=&gt; &quot;ab00&quot;
 */

static VALUE
pst_to_i(st)
    VALUE st;
{
    return rb_iv_get(st, &quot;status&quot;);
}


/*
 *  call-seq:
 *     stat.to_s   =&gt; string
 *
 *  Equivalent to _stat_&lt;code&gt;.to_i.to_s&lt;/code&gt;.
 */

static VALUE
pst_to_s(st)
    VALUE st;
{
    return rb_fix2str(pst_to_i(st), 10);
}


/*
 *  call-seq:
 *     stat.pid   =&gt; fixnum
 *
 *  Returns the process ID that this status object represents.
 *
 *     fork { exit }   #=&gt; 26569
 *     Process.wait    #=&gt; 26569
 *     $?.pid          #=&gt; 26569
 */

static VALUE
pst_pid(st)
    VALUE st;
{
    return rb_iv_get(st, &quot;pid&quot;);
}


/*
 *  call-seq:
 *     stat.inspect   =&gt; string
 *
 *  Override the inspection method.
 */

static VALUE
pst_inspect(st)
    VALUE st;
{
    VALUE pid;
    int status;
    VALUE str;
    char buf[256];

    pid = pst_pid(st);
    status = NUM2INT(st);

    snprintf(buf, sizeof(buf), &quot;#&lt;%s: pid=%ld&quot;, rb_class2name(CLASS_OF(st)), NUM2LONG(pid));
    str = rb_str_new2(buf);
    if (WIFSTOPPED(status)) {
	int stopsig = WSTOPSIG(status);
	const char *signame = ruby_signal_name(stopsig);
	if (signame) {
	    snprintf(buf, sizeof(buf), &quot;,stopped(SIG%s=%d)&quot;, signame, stopsig);
	}
	else {
	    snprintf(buf, sizeof(buf), &quot;,stopped(%d)&quot;, stopsig);
	}
	rb_str_cat2(str, buf);
    }
    if (WIFSIGNALED(status)) {
	int termsig = WTERMSIG(status);
	const char *signame = ruby_signal_name(termsig);
	if (signame) {
	    snprintf(buf, sizeof(buf), &quot;,signaled(SIG%s=%d)&quot;, signame, termsig);
	}
	else {
	    snprintf(buf, sizeof(buf), &quot;,signaled(%d)&quot;, termsig);
	}
	rb_str_cat2(str, buf);
    }
    if (WIFEXITED(status)) {
	snprintf(buf, sizeof(buf), &quot;,exited(%d)&quot;, WEXITSTATUS(status));
	rb_str_cat2(str, buf);
    }
#ifdef WCOREDUMP
    if (WCOREDUMP(status)) {
	rb_str_cat2(str, &quot;,coredumped&quot;);
    }
#endif
    rb_str_cat2(str, &quot;&gt;&quot;);
    return str;
}


/*
 *  call-seq:
 *     stat == other   =&gt; true or false
 *
 *  Returns +true+ if the integer value of _stat_
 *  equals &lt;em&gt;other&lt;/em&gt;.
 */

static VALUE
pst_equal(st1, st2)
    VALUE st1, st2;
{
    if (st1 == st2) return Qtrue;
    return rb_equal(pst_to_i(st1), st2);
}


/*
 *  call-seq:
 *     stat &amp; num   =&gt; fixnum
 *
 *  Logical AND of the bits in _stat_ with &lt;em&gt;num&lt;/em&gt;.
 *
 *     fork { exit 0x37 }
 *     Process.wait
 *     sprintf('%04x', $?.to_i)       #=&gt; &quot;3700&quot;
 *     sprintf('%04x', $? &amp; 0x1e00)   #=&gt; &quot;1600&quot;
 */

static VALUE
pst_bitand(st1, st2)
    VALUE st1, st2;
{
    int status = NUM2INT(st1) &amp; NUM2INT(st2);

    return INT2NUM(status);
}


/*
 *  call-seq:
 *     stat &gt;&gt; num   =&gt; fixnum
 *
 *  Shift the bits in _stat_ right &lt;em&gt;num&lt;/em&gt; places.
 *
 *     fork { exit 99 }   #=&gt; 26563
 *     Process.wait       #=&gt; 26563
 *     $?.to_i            #=&gt; 25344
 *     $? &gt;&gt; 8            #=&gt; 99
 */

static VALUE
pst_rshift(st1, st2)
    VALUE st1, st2;
{
    int status = NUM2INT(st1) &gt;&gt; NUM2INT(st2);

    return INT2NUM(status);
}


/*
 *  call-seq:
 *     stat.stopped?   =&gt; true or false
 *
 *  Returns +true+ if this process is stopped. This is only
 *  returned if the corresponding &lt;code&gt;wait&lt;/code&gt; call had the
 *  &lt;code&gt;WUNTRACED&lt;/code&gt; flag set.
 */

static VALUE
pst_wifstopped(st)
    VALUE st;
{
    int status = NUM2INT(st);

    if (WIFSTOPPED(status))
	return Qtrue;
    else
	return Qfalse;
}


/*
 *  call-seq:
 *     stat.stopsig   =&gt; fixnum or nil
 *
 *  Returns the number of the signal that caused _stat_ to stop
 *  (or +nil+ if self is not stopped).
 */

static VALUE
pst_wstopsig(st)
    VALUE st;
{
    int status = NUM2INT(st);

    if (WIFSTOPPED(status))
	return INT2NUM(WSTOPSIG(status));
    return Qnil;
}


/*
 *  call-seq:
 *     stat.signaled?   =&gt; true or false
 *
 *  Returns +true+ if _stat_ terminated because of
 *  an uncaught signal.
 */

static VALUE
pst_wifsignaled(st)
    VALUE st;
{
    int status = NUM2INT(st);

    if (WIFSIGNALED(status))
	return Qtrue;
    else
	return Qfalse;
}


/*
 *  call-seq:
 *     stat.termsig   =&gt; fixnum or nil
 *
 *  Returns the number of the signal that caused _stat_ to
 *  terminate (or +nil+ if self was not terminated by an
 *  uncaught signal).
 */

static VALUE
pst_wtermsig(st)
    VALUE st;
{
    int status = NUM2INT(st);

    if (WIFSIGNALED(status))
	return INT2NUM(WTERMSIG(status));
    return Qnil;
}


/*
 *  call-seq:
 *     stat.exited?   =&gt; true or false
 *
 *  Returns +true+ if _stat_ exited normally (for
 *  example using an &lt;code&gt;exit()&lt;/code&gt; call or finishing the
 *  program).
 */

static VALUE
pst_wifexited(st)
    VALUE st;
{
    int status = NUM2INT(st);

    if (WIFEXITED(status))
	return Qtrue;
    else
	return Qfalse;
}


/*
 *  call-seq:
 *     stat.exitstatus   =&gt; fixnum or nil
 *
 *  Returns the least significant eight bits of the return code of
 *  _stat_. Only available if &lt;code&gt;exited?&lt;/code&gt; is
 *  +true+.
 *
 *     fork { }           #=&gt; 26572
 *     Process.wait       #=&gt; 26572
 *     $?.exited?         #=&gt; true
 *     $?.exitstatus      #=&gt; 0
 *
 *     fork { exit 99 }   #=&gt; 26573
 *     Process.wait       #=&gt; 26573
 *     $?.exited?         #=&gt; true
 *     $?.exitstatus      #=&gt; 99
 */

static VALUE
pst_wexitstatus(st)
    VALUE st;
{
    int status = NUM2INT(st);

    if (WIFEXITED(status))
	return INT2NUM(WEXITSTATUS(status));
    return Qnil;
}


/*
 *  call-seq:
 *     stat.success?   =&gt; true, false or nil
 *
 *  Returns +true+ if _stat_ is successful, +false+ if not.
 *  Returns +nil+ if &lt;code&gt;exited?&lt;/code&gt; is not +true+.
 */

static VALUE
pst_success_p(st)
    VALUE st;
{
    int status = NUM2INT(st);

    if (!WIFEXITED(status))
	return Qnil;
    return WEXITSTATUS(status) == EXIT_SUCCESS ? Qtrue : Qfalse;
}


/*
 *  call-seq:
 *     stat.coredump?   =&gt; true or false
 *
 *  Returns +true+ if _stat_ generated a coredump
 *  when it terminated. Not available on all platforms.
 */

static VALUE
pst_wcoredump(st)
    VALUE st;
{
#ifdef WCOREDUMP
    int status = NUM2INT(st);

    if (WCOREDUMP(status))
	return Qtrue;
    else
	return Qfalse;
#else
    return Qfalse;
#endif
}

#if !defined(HAVE_WAITPID) &amp;&amp; !defined(HAVE_WAIT4)
#define NO_WAITPID
static st_table *pid_tbl;
#endif

int
rb_waitpid(pid, st, flags)
    int pid;
    int *st;
    int flags;
{
    int result;
#ifndef NO_WAITPID
    int oflags = flags;
    if (!rb_thread_alone()) {	/* there're other threads to run */
	flags |= WNOHANG;
    }

  retry:
    TRAP_BEG;
#ifdef HAVE_WAITPID
    result = waitpid(pid, st, flags);
#else  /* HAVE_WAIT4 */
    result = wait4(pid, st, flags, NULL);
#endif
    TRAP_END;
    if (result &lt; 0) {
	if (errno == EINTR) {
	    rb_thread_polling();
	    goto retry;
	}
	return -1;
    }
    if (result == 0) {
	if (oflags &amp; WNOHANG) return 0;
	rb_thread_polling();
	if (rb_thread_alone()) flags = oflags;
	goto retry;
    }
#else  /* NO_WAITPID */
    if (pid_tbl &amp;&amp; st_lookup(pid_tbl, pid, st)) {
	last_status_set(*st, pid);
	st_delete(pid_tbl, (st_data_t*)&amp;pid, NULL);
	return pid;
    }

    if (flags) {
	rb_raise(rb_eArgError, &quot;can't do waitpid with flags&quot;);
    }

    for (;;) {
	TRAP_BEG;
	result = wait(st);
	TRAP_END;
	if (result &lt; 0) {
	    if (errno == EINTR) {
		rb_thread_schedule();
		continue;
	    }
	    return -1;
	}
	if (result == pid) {
	    break;
	}
	if (!pid_tbl)
	    pid_tbl = st_init_numtable();
	st_insert(pid_tbl, pid, st);
	if (!rb_thread_alone()) rb_thread_schedule();
    }
#endif
    if (result &gt; 0) {
	last_status_set(*st, result);
    }
    return result;
}

#ifdef NO_WAITPID
struct wait_data {
    int pid;
    int status;
};

static int
wait_each(pid, status, data)
    int pid, status;
    struct wait_data *data;
{
    if (data-&gt;status != -1) return ST_STOP;

    data-&gt;pid = pid;
    data-&gt;status = status;
    return ST_DELETE;
}

static int
waitall_each(pid, status, ary)
    int pid, status;
    VALUE ary;
{
    last_status_set(status, pid);
    rb_ary_push(ary, rb_assoc_new(INT2NUM(pid), rb_last_status));
    return ST_DELETE;
}
#endif


/* [MG]:FIXME: I wasn't sure how this should be done, since ::wait()
   has historically been documented as if it didn't take any arguments
   despite the fact that it's just an alias for ::waitpid(). The way I
   have it below is more truthful, but a little confusing.

   I also took the liberty of putting in the pid values, as they're
   pretty useful, and it looked as if the original 'ri' output was
   supposed to contain them after &quot;[...]depending on the value of
   aPid:&quot;.

   The 'ansi' and 'bs' formats of the ri output don't display the
   definition list for some reason, but the plain text one does.
 */

/*
 *  call-seq:
 *     Process.wait()                     =&gt; fixnum
 *     Process.wait(pid=-1, flags=0)      =&gt; fixnum
 *     Process.waitpid(pid=-1, flags=0)   =&gt; fixnum
 *
 *  Waits for a child process to exit, returns its process id, and
 *  sets &lt;code&gt;$?&lt;/code&gt; to a &lt;code&gt;Process::Status&lt;/code&gt; object
 *  containing information on that process. Which child it waits on
 *  depends on the value of _pid_:
 *
 *  &gt; 0::   Waits for the child whose process ID equals _pid_.
 *
 *  0::     Waits for any child whose process group ID equals that of the
 *          calling process.
 *
 *  -1::    Waits for any child process (the default if no _pid_ is
 *          given).
 *
 *  &lt; -1::  Waits for any child whose process group ID equals the absolute
 *          value of _pid_.
 *
 *  The _flags_ argument may be a logical or of the flag values
 *  &lt;code&gt;Process::WNOHANG&lt;/code&gt; (do not block if no child available)
 *  or &lt;code&gt;Process::WUNTRACED&lt;/code&gt; (return stopped children that
 *  haven't been reported). Not all flags are available on all
 *  platforms, but a flag value of zero will work on all platforms.
 *
 *  Calling this method raises a &lt;code&gt;SystemError&lt;/code&gt; if there are
 *  no child processes. Not available on all platforms.
 *
 *     include Process
 *     fork { exit 99 }                 #=&gt; 27429
 *     wait                             #=&gt; 27429
 *     $?.exitstatus                    #=&gt; 99
 *
 *     pid = fork { sleep 3 }           #=&gt; 27440
 *     Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
 *     waitpid(pid, Process::WNOHANG)   #=&gt; nil
 *     Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
 *     waitpid(pid, 0)                  #=&gt; 27440
 *     Time.now                         #=&gt; Wed Apr 09 08:57:12 CDT 2003
 */

static VALUE
proc_wait(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE vpid, vflags;
    int pid, flags, status;

    rb_secure(2);
    flags = 0;
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;vpid, &amp;vflags);
    if (argc == 0) {
	pid = -1;
    }
    else {
	pid = NUM2INT(vpid);
	if (argc == 2 &amp;&amp; !NIL_P(vflags)) {
	    flags = NUM2UINT(vflags);
	}
    }
    if ((pid = rb_waitpid(pid, &amp;status, flags)) &lt; 0)
	rb_sys_fail(0);
    if (pid == 0) {
	return rb_last_status = Qnil;
    }
    return INT2FIX(pid);
}


/*
 *  call-seq:
 *     Process.wait2(pid=-1, flags=0)      =&gt; [pid, status]
 *     Process.waitpid2(pid=-1, flags=0)   =&gt; [pid, status]
 *
 *  Waits for a child process to exit (see Process::waitpid for exact
 *  semantics) and returns an array containing the process id and the
 *  exit status (a &lt;code&gt;Process::Status&lt;/code&gt; object) of that
 *  child. Raises a &lt;code&gt;SystemError&lt;/code&gt; if there are no child
 *  processes.
 *
 *     Process.fork { exit 99 }   #=&gt; 27437
 *     pid, status = Process.wait2
 *     pid                        #=&gt; 27437
 *     status.exitstatus          #=&gt; 99
 */

static VALUE
proc_wait2(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE pid = proc_wait(argc, argv);
    if (NIL_P(pid)) return Qnil;
    return rb_assoc_new(pid, rb_last_status);
}


/*
 *  call-seq:
 *     Process.waitall   =&gt; [ [pid1,status1], ...]
 *
 *  Waits for all children, returning an array of
 *  _pid_/_status_ pairs (where _status_ is a
 *  &lt;code&gt;Process::Status&lt;/code&gt; object).
 *
 *     fork { sleep 0.2; exit 2 }   #=&gt; 27432
 *     fork { sleep 0.1; exit 1 }   #=&gt; 27433
 *     fork {            exit 0 }   #=&gt; 27434
 *     p Process.waitall
 *
 *  &lt;em&gt;produces&lt;/em&gt;:
 *
 *     [[27434, #&lt;Process::Status: pid=27434,exited(0)&gt;],
 *      [27433, #&lt;Process::Status: pid=27433,exited(1)&gt;],
 *      [27432, #&lt;Process::Status: pid=27432,exited(2)&gt;]]
 */

static VALUE
proc_waitall()
{
    VALUE result;
    int pid, status;

    rb_secure(2);
    result = rb_ary_new();
#ifdef NO_WAITPID
    if (pid_tbl) {
	st_foreach(pid_tbl, waitall_each, result);
    }

    for (pid = -1;;) {
	pid = wait(&amp;status);
	if (pid == -1) {
	    if (errno == ECHILD)
		break;
	    if (errno == EINTR) {
		rb_thread_schedule();
		continue;
	    }
	    rb_sys_fail(0);
	}
	last_status_set(status, pid);
	rb_ary_push(result, rb_assoc_new(INT2NUM(pid), rb_last_status));
    }
#else
    rb_last_status = Qnil;
    for (pid = -1;;) {
	pid = rb_waitpid(-1, &amp;status, 0);
	if (pid == -1) {
	    if (errno == ECHILD)
		break;
	    rb_sys_fail(0);
	}
	rb_ary_push(result, rb_assoc_new(INT2NUM(pid), rb_last_status));
    }
#endif
    return result;
}

static VALUE
detach_process_watcher(arg)
    void *arg;
{
    int pid = (int)(VALUE)arg, status;

    while (rb_waitpid(pid, &amp;status, WNOHANG) == 0) {
	rb_thread_sleep(1);
    }
    return rb_last_status;
}

VALUE
rb_detach_process(pid)
    int pid;
{
    return rb_thread_create(detach_process_watcher, (void*)(VALUE)pid);
}


/*
 *  call-seq:
 *     Process.detach(pid)   =&gt; thread
 *
 *  Some operating systems retain the status of terminated child
 *  processes until the parent collects that status (normally using
 *  some variant of &lt;code&gt;wait()&lt;/code&gt;. If the parent never collects
 *  this status, the child stays around as a &lt;em&gt;zombie&lt;/em&gt; process.
 *  &lt;code&gt;Process::detach&lt;/code&gt; prevents this by setting up a
 *  separate Ruby thread whose sole job is to reap the status of the
 *  process _pid_ when it terminates. Use &lt;code&gt;detach&lt;/code&gt;
 *  only when you do not intent to explicitly wait for the child to
 *  terminate.  &lt;code&gt;detach&lt;/code&gt; only checks the status
 *  periodically (currently once each second).
 *
 *  The waiting thread returns the exit status of the detached process
 *  when it terminates, so you can use &lt;code&gt;Thread#join&lt;/code&gt; to
 *  know the result.  If specified _pid_ is not a valid child process
 *  ID, the thread returns +nil+ immediately.
 *
 *  In this first example, we don't reap the first child process, so
 *  it appears as a zombie in the process status display.
 *
 *     p1 = fork { sleep 0.1 }
 *     p2 = fork { sleep 0.2 }
 *     Process.waitpid(p2)
 *     sleep 2
 *     system(&quot;ps -ho pid,state -p #{p1}&quot;)
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     27389 Z
 *
 *  In the next example, &lt;code&gt;Process::detach&lt;/code&gt; is used to reap
 *  the child automatically.
 *
 *     p1 = fork { sleep 0.1 }
 *     p2 = fork { sleep 0.2 }
 *     Process.detach(p1)
 *     Process.waitpid(p2)
 *     sleep 2
 *     system(&quot;ps -ho pid,state -p #{p1}&quot;)
 *
 *  &lt;em&gt;(produces no output)&lt;/em&gt;
 */

static VALUE
proc_detach(VALUE obj, VALUE pid)
{
    rb_secure(2);
    return rb_detach_process(NUM2INT(pid));
}

#ifndef HAVE_STRING_H
char *strtok();
#endif

#ifdef HAVE_SETITIMER
#define before_exec() rb_thread_stop_timer()
#define after_exec() rb_thread_start_timer()
#else
#define before_exec()
#define after_exec()
#endif

extern char *dln_find_exe();

static void
security(str)
    char *str;
{
    if (rb_env_path_tainted()) {
	if (rb_safe_level() &gt; 0) {
	    rb_raise(rb_eSecurityError, &quot;Insecure PATH - %s&quot;, str);
	}
    }
}

static int
proc_exec_v(argv, prog)
    char **argv;
    char *prog;
{
    if (!prog)
	prog = argv[0];
    security(prog);
    prog = dln_find_exe(prog, 0);
    if (!prog)
	return -1;

#if (defined(MSDOS) &amp;&amp; !defined(DJGPP)) || defined(__human68k__) || defined(__EMX__) || defined(OS2)
    {
#if defined(__human68k__)
#define COMMAND &quot;command.x&quot;
#endif
#if defined(__EMX__) || defined(OS2) /* OS/2 emx */
#define COMMAND &quot;cmd.exe&quot;
#endif
#if (defined(MSDOS) &amp;&amp; !defined(DJGPP))
#define COMMAND &quot;command.com&quot;
#endif
	char *extension;

	if ((extension = strrchr(prog, '.')) != NULL &amp;&amp; strcasecmp(extension, &quot;.bat&quot;) == 0) {
	    char **new_argv;
	    char *p;
	    int n;

	    for (n = 0; argv[n]; n++)
		/* no-op */;
	    new_argv = ALLOCA_N(char*, n + 2);
	    for (; n &gt; 0; n--)
		new_argv[n + 1] = argv[n];
	    new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
	    for (p = new_argv[1]; *p != '\0'; p++)
		if (*p == '/')
		    *p = '\\';
	    new_argv[0] = COMMAND;
	    argv = new_argv;
	    prog = dln_find_exe(argv[0], 0);
	    if (!prog) {
		errno = ENOENT;
		return -1;
	    }
	}
    }
#endif /* MSDOS or __human68k__ or __EMX__ */
    before_exec();
    execv(prog, argv);
    preserving_errno(after_exec());
    return -1;
}

static int
proc_exec_n(argc, argv, progv)
    int argc;
    VALUE *argv;
    VALUE progv;
{
    char *prog = 0;
    char **args;
    int i;

    if (progv) {
	prog = RSTRING(progv)-&gt;ptr;
    }
    args = ALLOCA_N(char*, argc+1);
    for (i=0; i&lt;argc; i++) {
	SafeStringValue(argv[i]);
	args[i] = RSTRING(argv[i])-&gt;ptr;
    }
    args[i] = 0;
    if (args[0]) {
	return proc_exec_v(args, prog);
    }
    return -1;
}

int
rb_proc_exec(str)
    const char *str;
{
#ifndef _WIN32
    const char *s = str;
    char *ss, *t;
    char **argv, **a;
#endif

    while (*str &amp;&amp; ISSPACE(*str))
	str++;

#ifdef _WIN32
    before_exec();
    do_spawn(P_OVERLAY, (char *)str);
    after_exec();
#else
    for (s=str; *s; s++) {
	if (*s != ' ' &amp;&amp; !ISALPHA(*s) &amp;&amp; strchr(&quot;*?{}[]&lt;&gt;()~&amp;|\\$;'`\&quot;\n&quot;,*s)) {
#if defined(MSDOS)
	    int status;
	    before_exec();
	    status = system(str);
	    after_exec();
	    if (status != -1)
		exit(status);
#else
#if defined(__human68k__) || defined(__CYGWIN32__) || defined(__EMX__)
	    char *shell = dln_find_exe(&quot;sh&quot;, 0);
	    int status = -1;
	    before_exec();
	    if (shell)
		execl(shell, &quot;sh&quot;, &quot;-c&quot;, str, (char *) NULL);
	    else
		status = system(str);
	    after_exec();
	    if (status != -1)
		exit(status);
#else
	    before_exec();
	    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, str, (char *)NULL);
	    preserving_errno(after_exec());
#endif
#endif
	    return -1;
	}
    }
    a = argv = ALLOCA_N(char*, (s-str)/2+2);
    ss = ALLOCA_N(char, s-str+1);
    strcpy(ss, str);
    if ((*a++ = strtok(ss, &quot; \t&quot;)) != 0) {
	while ((t = strtok(NULL, &quot; \t&quot;)) != 0) {
	    *a++ = t;
	}
	*a = NULL;
    }
    if (argv[0]) {
	return proc_exec_v(argv, 0);
    }
    errno = ENOENT;
#endif	/* _WIN32 */
    return -1;
}

#if defined(__human68k__) || defined(__DJGPP__) || defined(_WIN32)
static int
proc_spawn_v(argv, prog)
    char **argv;
    char *prog;
{
#if defined(__human68k__)
    char *extension;
#endif
    int status;

    if (!prog)
	prog = argv[0];
    security(prog);
    prog = dln_find_exe(prog, 0);
    if (!prog)
	return -1;

#if defined(__human68k__)
    if ((extension = strrchr(prog, '.')) != NULL &amp;&amp; strcasecmp(extension, &quot;.bat&quot;) == 0) {
	char **new_argv;
	char *p;
	int n;

	for (n = 0; argv[n]; n++)
	    /* no-op */;
	new_argv = ALLOCA_N(char*, n + 2);
	for (; n &gt; 0; n--)
	    new_argv[n + 1] = argv[n];
	new_argv[1] = strcpy(ALLOCA_N(char, strlen(argv[0]) + 1), argv[0]);
	for (p = new_argv[1]; *p != '\0'; p++)
	    if (*p == '/')
		*p = '\\';
	new_argv[0] = COMMAND;
	argv = new_argv;
	prog = dln_find_exe(argv[0], 0);
	if (!prog) {
	    errno = ENOENT;
	    return -1;
	}
    }
#endif
    before_exec();
#if defined(_WIN32)
    status = do_aspawn(P_WAIT, prog, argv);
#else
    status = spawnv(P_WAIT, prog, argv);
#endif
    after_exec();
    return status;
}

static int
proc_spawn_n(argc, argv, prog)
    int argc;
    VALUE *argv;
    VALUE prog;
{
    char **args;
    int i;

    args = ALLOCA_N(char*, argc + 1);
    for (i = 0; i &lt; argc; i++) {
	SafeStringValue(argv[i]);
	args[i] = StringValueCStr(argv[i]);
    }
    if (prog)
	SafeStringValue(prog);
    args[i] = (char*) 0;
    if (args[0])
	return proc_spawn_v(args, prog ? StringValueCStr(prog) : 0);
    return -1;
}

#if !defined(_WIN32)
static int
proc_spawn(sv)
    VALUE sv;
{
    char *str;
    char *s, *t;
    char **argv, **a;
    int status;

    SafeStringValue(sv);
    str = s = StringValueCStr(sv);
    for (s = str; *s; s++) {
	if (*s != ' ' &amp;&amp; !ISALPHA(*s) &amp;&amp; strchr(&quot;*?{}[]&lt;&gt;()~&amp;|\\$;'`\&quot;\n&quot;,*s)) {
	    char *shell = dln_find_exe(&quot;sh&quot;, 0);
	    before_exec();
	    status = shell?spawnl(P_WAIT,shell,&quot;sh&quot;,&quot;-c&quot;,str,(char*)NULL):system(str);
	    after_exec();
	    return status;
	}
    }
    a = argv = ALLOCA_N(char*, (s - str) / 2 + 2);
    s = ALLOCA_N(char, s - str + 1);
    strcpy(s, str);
    if (*a++ = strtok(s, &quot; \t&quot;)) {
	while (t = strtok(NULL, &quot; \t&quot;))
	    *a++ = t;
	*a = NULL;
    }
    return argv[0] ? proc_spawn_v(argv, 0) : -1;
}
#endif
#endif

struct rb_exec_arg {
    int argc;
    VALUE *argv;
    VALUE prog;
};

static void
proc_prepare_args(e, argc, argv, prog)
    struct rb_exec_arg *e;
    int argc;
    VALUE *argv;
    VALUE prog;
{
    int i;

    MEMZERO(e, struct rb_exec_arg, 1);
    if (prog) {
	SafeStringValue(prog);
	StringValueCStr(prog);
    }
    for (i = 0; i &lt; argc; i++) {
	SafeStringValue(argv[i]);
	StringValueCStr(argv[i]);
    }
    security(RSTRING(prog ? prog : argv[0])-&gt;ptr);
    e-&gt;prog = prog;
    e-&gt;argc = argc;
    e-&gt;argv = argv;
}

static VALUE
proc_exec_args(earg)
    VALUE earg;
{
    struct rb_exec_arg *e = (struct rb_exec_arg *)earg;
    int argc = e-&gt;argc;
    VALUE *argv = e-&gt;argv;
    VALUE prog = e-&gt;prog;

    if (argc == 1 &amp;&amp; prog == 0) {
	return (VALUE)rb_proc_exec(RSTRING(argv[0])-&gt;ptr);
    }
    else {
	return (VALUE)proc_exec_n(argc, argv, prog);
    }
}

/*
 *  call-seq:
 *     exec(command [, arg, ...])
 *
 *  Replaces the current process by running the given external _command_.
 *  If +exec+ is given a single argument, that argument is
 *  taken as a line that is subject to shell expansion before being
 *  executed. If multiple arguments are given, the second and subsequent
 *  arguments are passed as parameters to _command_ with no shell
 *  expansion. If the first argument is a two-element array, the first
 *  element is the command to be executed, and the second argument is
 *  used as the &lt;code&gt;argv[0]&lt;/code&gt; value, which may show up in process
 *  listings. In MSDOS environments, the command is executed in a
 *  subshell; otherwise, one of the &lt;code&gt;exec(2)&lt;/code&gt; system calls is
 *  used, so the running command may inherit some of the environment of
 *  the original program (including open file descriptors).
 *
 *     exec &quot;echo *&quot;       # echoes list of files in current directory
 *     # never get here
 *
 *
 *     exec &quot;echo&quot;, &quot;*&quot;    # echoes an asterisk
 *     # never get here
 */

VALUE
rb_f_exec(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE prog = 0;
    VALUE tmp;
    struct rb_exec_arg earg;

    if (argc == 0) {
	rb_last_status = Qnil;
	rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }

    tmp = rb_check_array_type(argv[0]);
    if (!NIL_P(tmp)) {
	if (RARRAY(tmp)-&gt;len != 2) {
	    rb_raise(rb_eArgError, &quot;wrong first argument&quot;);
	}
	prog = RARRAY(tmp)-&gt;ptr[0];
	argv[0] = RARRAY(tmp)-&gt;ptr[1];
	SafeStringValue(prog);
    }
    proc_prepare_args(&amp;earg, argc, argv, prog);
    proc_exec_args((VALUE)&amp;earg);
    rb_sys_fail(RSTRING(argv[0])-&gt;ptr);
    return Qnil;		/* dummy */
}


/*
 *  call-seq:
 *     Kernel.fork  [{ block }]   =&gt; fixnum or nil
 *     Process.fork [{ block }]   =&gt; fixnum or nil
 *
 *  Creates a subprocess. If a block is specified, that block is run
 *  in the subprocess, and the subprocess terminates with a status of
 *  zero. Otherwise, the +fork+ call returns twice, once in
 *  the parent, returning the process ID of the child, and once in
 *  the child, returning _nil_. The child process can exit using
 *  &lt;code&gt;Kernel.exit!&lt;/code&gt; to avoid running any
 *  &lt;code&gt;at_exit&lt;/code&gt; functions. The parent process should
 *  use &lt;code&gt;Process.wait&lt;/code&gt; to collect the termination statuses
 *  of its children or use &lt;code&gt;Process.detach&lt;/code&gt; to register
 *  disinterest in their status; otherwise, the operating system
 *  may accumulate zombie processes.
 *
 *  The thread calling fork is the only thread in the created child process.
 *  fork doesn't copy other threads.
 */

static VALUE
rb_f_fork(obj)
    VALUE obj;
{
#if !defined(__human68k__) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(__MACOS__) &amp;&amp; !defined(__EMX__) &amp;&amp; !defined(__VMS)
    int pid;

    rb_secure(2);

#ifndef __VMS
    fflush(stdout);
    fflush(stderr);
#endif

    switch (pid = fork()) {
      case 0:
#ifdef linux
	after_exec();
#endif
	rb_thread_atfork();
	if (rb_block_given_p()) {
	    int status;

	    rb_protect(rb_yield, Qundef, &amp;status);
	    ruby_stop(status);
	}
	return Qnil;

      case -1:
	rb_sys_fail(&quot;fork(2)&quot;);
	return Qnil;

      default:
	return INT2FIX(pid);
    }
#else
    rb_notimplement();
#endif
}


/*
 *  call-seq:
 *     Process.exit!(fixnum=-1)
 *
 *  Exits the process immediately. No exit handlers are
 *  run. &lt;em&gt;fixnum&lt;/em&gt; is returned to the underlying system as the
 *  exit status.
 *
 *     Process.exit!(0)
 */

static VALUE
rb_f_exit_bang(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE status;
    int istatus;

    rb_secure(4);
    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;status) == 1) {
	switch (status) {
	  case Qtrue:
	    istatus = EXIT_SUCCESS;
	    break;
	  case Qfalse:
	    istatus = EXIT_FAILURE;
	    break;
	  default:
	    istatus = NUM2INT(status);
	    break;
	}
    }
    else {
	istatus = EXIT_FAILURE;
    }
    _exit(istatus);

    return Qnil;		/* not reached */
}

#if defined(sun)
#define signal(a,b) sigset(a,b)
#endif

void
rb_syswait(pid)
    int pid;
{
    static int overriding;
#ifdef SIGHUP
    RETSIGTYPE (*hfunc)_((int)) = 0;
#endif
#ifdef SIGQUIT
    RETSIGTYPE (*qfunc)_((int)) = 0;
#endif
    RETSIGTYPE (*ifunc)_((int)) = 0;
    int status;
    int i, hooked = Qfalse;

    if (!overriding) {
#ifdef SIGHUP
	hfunc = signal(SIGHUP, SIG_IGN);
#endif
#ifdef SIGQUIT
	qfunc = signal(SIGQUIT, SIG_IGN);
#endif
	ifunc = signal(SIGINT, SIG_IGN);
	overriding = Qtrue;
	hooked = Qtrue;
    }

    do {
	i = rb_waitpid(pid, &amp;status, 0);
    } while (i == -1 &amp;&amp; errno == EINTR);

    if (hooked) {
#ifdef SIGHUP
	signal(SIGHUP, hfunc);
#endif
#ifdef SIGQUIT
	signal(SIGQUIT, qfunc);
#endif
	signal(SIGINT, ifunc);
	overriding = Qfalse;
    }
}

/*
 *  call-seq:
 *     system(cmd [, arg, ...])    =&gt; true or false
 *
 *  Executes _cmd_ in a subshell, returning +true+ if
 *  the command was found and ran successfully, +false+
 *  otherwise. An error status is available in &lt;code&gt;$?&lt;/code&gt;. The
 *  arguments are processed in the same way as for
 *  &lt;code&gt;Kernel::exec&lt;/code&gt;.
 *
 *     system(&quot;echo *&quot;)
 *     system(&quot;echo&quot;, &quot;*&quot;)
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     config.h main.rb
 *     *
 */

static VALUE
rb_f_system(argc, argv)
    int argc;
    VALUE *argv;
{
    int status;
#if defined(__EMX__)
    VALUE cmd;

    fflush(stdout);
    fflush(stderr);
    if (argc == 0) {
	rb_last_status = Qnil;
	rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }

    if (TYPE(argv[0]) == T_ARRAY) {
	if (RARRAY(argv[0])-&gt;len != 2) {
	    rb_raise(rb_eArgError, &quot;wrong first argument&quot;);
	}
	argv[0] = RARRAY(argv[0])-&gt;ptr[0];
    }
    cmd = rb_ary_join(rb_ary_new4(argc, argv), rb_str_new2(&quot; &quot;));

    SafeStringValue(cmd);
    status = do_spawn(RSTRING(cmd)-&gt;ptr);
    last_status_set(status, 0);
#elif defined(__human68k__) || defined(__DJGPP__) || defined(_WIN32)
    volatile VALUE prog = 0;

    fflush(stdout);
    fflush(stderr);
    if (argc == 0) {
	rb_last_status = Qnil;
	rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }

    if (TYPE(argv[0]) == T_ARRAY) {
	if (RARRAY(argv[0])-&gt;len != 2) {
	    rb_raise(rb_eArgError, &quot;wrong first argument&quot;);
	}
	prog = RARRAY(argv[0])-&gt;ptr[0];
	argv[0] = RARRAY(argv[0])-&gt;ptr[1];
    }

    if (argc == 1 &amp;&amp; prog == 0) {
#if defined(_WIN32)
	SafeStringValue(argv[0]);
	status = do_spawn(P_WAIT, StringValueCStr(argv[0]));
#else
	status = proc_spawn(argv[0]);
#endif
    }
    else {
	status = proc_spawn_n(argc, argv, prog);
    }
#if !defined(_WIN32)
    last_status_set(status == -1 ? 127 : status, 0);
#else
    if (status == -1)
	last_status_set(0x7f &lt;&lt; 8, 0);
#endif
#elif defined(__VMS)
    VALUE cmd;

    if (argc == 0) {
	rb_last_status = Qnil;
	rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }

    if (TYPE(argv[0]) == T_ARRAY) {
	if (RARRAY(argv[0])-&gt;len != 2) {
	    rb_raise(rb_eArgError, &quot;wrong first argument&quot;);
	}
	argv[0] = RARRAY(argv[0])-&gt;ptr[0];
    }
    cmd = rb_ary_join(rb_ary_new4(argc, argv), rb_str_new2(&quot; &quot;));

    SafeStringValue(cmd);
    status = system(StringValueCStr(cmd));
    last_status_set((status &amp; 0xff) &lt;&lt; 8, 0);
#else
    volatile VALUE prog = 0;
    int pid;
    struct rb_exec_arg earg;
    RETSIGTYPE (*chfunc)(int);

    fflush(stdout);
    fflush(stderr);
    if (argc == 0) {
	rb_last_status = Qnil;
	rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }

    if (TYPE(argv[0]) == T_ARRAY) {
	if (RARRAY(argv[0])-&gt;len != 2) {
	    rb_raise(rb_eArgError, &quot;wrong first argument&quot;);
	}
	prog = RARRAY(argv[0])-&gt;ptr[0];
	argv[0] = RARRAY(argv[0])-&gt;ptr[1];
    }
    proc_prepare_args(&amp;earg, argc, argv, prog);

    chfunc = signal(SIGCHLD, SIG_DFL);
  retry:
    pid = fork();
    if (pid == 0) {
	/* child process */
	rb_thread_atfork();
	rb_protect(proc_exec_args, (VALUE)&amp;earg, NULL);
	_exit(127);
    }
    if (pid &lt; 0) {
	if (errno == EAGAIN) {
	    rb_thread_sleep(1);
	    goto retry;
	}
    }
    else {
	rb_syswait(pid);
    }
    signal(SIGCHLD, chfunc);
    if (pid &lt; 0) rb_sys_fail(0);
    status = NUM2INT(rb_last_status);
#endif

    if (status == EXIT_SUCCESS) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     sleep([duration])    =&gt; fixnum
 *
 *  Suspends the current thread for _duration_ seconds (which may be any number,
 *  including a +Float+ with fractional seconds). Returns the actual number of
 *  seconds slept (rounded), which may be less than that asked for if another
 *  thread calls &lt;code&gt;Thread#run&lt;/code&gt;. Zero arguments causes +sleep+ to sleep
 *  forever.
 *
 *     Time.new    #=&gt; Wed Apr 09 08:56:32 CDT 2003
 *     sleep 1.2   #=&gt; 1
 *     Time.new    #=&gt; Wed Apr 09 08:56:33 CDT 2003
 *     sleep 1.9   #=&gt; 2
 *     Time.new    #=&gt; Wed Apr 09 08:56:35 CDT 2003
 */

static VALUE
rb_f_sleep(argc, argv)
    int argc;
    VALUE *argv;
{
    int beg, end;

    beg = time(0);
    if (argc == 0) {
	rb_thread_sleep_forever();
    }
    else if (argc == 1) {
	rb_thread_wait_for(rb_time_interval(argv[0]));
    }
    else {
	rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }

    end = time(0) - beg;

    return INT2FIX(end);
}


#if defined(SIGCLD) &amp;&amp; !defined(SIGCHLD)
# define SIGCHLD SIGCLD
#endif

/*
 *  call-seq:
 *     Process.getpgrp   =&gt; integer
 *
 *  Returns the process group ID for this process. Not available on
 *  all platforms.
 *
 *     Process.getpgid(0)   #=&gt; 25527
 *     Process.getpgrp      #=&gt; 25527
 */

static VALUE
proc_getpgrp()
{
#if defined(HAVE_GETPGRP) &amp;&amp; defined(GETPGRP_VOID)
    int pgrp;
#endif

    rb_secure(2);
#if defined(HAVE_GETPGRP) &amp;&amp; defined(GETPGRP_VOID)
    pgrp = getpgrp();
    if (pgrp &lt; 0) rb_sys_fail(0);
    return INT2FIX(pgrp);
#else
# ifdef HAVE_GETPGID
    pgrp = getpgid(0);
    if (pgrp &lt; 0) rb_sys_fail(0);
    return INT2FIX(pgrp);
# else
    rb_notimplement();
# endif
#endif
}


/*
 *  call-seq:
 *     Process.setpgrp   =&gt; 0
 *
 *  Equivalent to &lt;code&gt;setpgid(0,0)&lt;/code&gt;. Not available on all
 *  platforms.
 */

static VALUE
proc_setpgrp()
{
    rb_secure(2);
  /* check for posix setpgid() first; this matches the posix */
  /* getpgrp() above.  It appears that configure will set SETPGRP_VOID */
  /* even though setpgrp(0,0) would be prefered. The posix call avoids */
  /* this confusion. */
#ifdef HAVE_SETPGID
    if (setpgid(0,0) &lt; 0) rb_sys_fail(0);
#elif defined(HAVE_SETPGRP) &amp;&amp; defined(SETPGRP_VOID)
    if (setpgrp() &lt; 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return INT2FIX(0);
}


/*
 *  call-seq:
 *     Process.getpgid(pid)   =&gt; integer
 *
 *  Returns the process group ID for the given process id. Not
 *  available on all platforms.
 *
 *     Process.getpgid(Process.ppid())   #=&gt; 25527
 */

static VALUE
proc_getpgid(obj, pid)
    VALUE obj, pid;
{
#if defined(HAVE_GETPGID) &amp;&amp; !defined(__CHECKER__)
    int i;

    rb_secure(2);
    i = getpgid(NUM2INT(pid));
    if (i &lt; 0) rb_sys_fail(0);
    return INT2NUM(i);
#else
    rb_notimplement();
#endif
}


/*
 *  call-seq:
 *     Process.setpgid(pid, integer)   =&gt; 0
 *
 *  Sets the process group ID of _pid_ (0 indicates this
 *  process) to &lt;em&gt;integer&lt;/em&gt;. Not available on all platforms.
 */

static VALUE
proc_setpgid(obj, pid, pgrp)
    VALUE obj, pid, pgrp;
{
#ifdef HAVE_SETPGID
    int ipid, ipgrp;

    rb_secure(2);
    ipid = NUM2INT(pid);
    ipgrp = NUM2INT(pgrp);

    if (setpgid(ipid, ipgrp) &lt; 0) rb_sys_fail(0);
    return INT2FIX(0);
#else
    rb_notimplement();
#endif
}


/*
 *  call-seq:
 *     Process.setsid   =&gt; fixnum
 *
 *  Establishes this process as a new session and process group
 *  leader, with no controlling tty. Returns the session id. Not
 *  available on all platforms.
 *
 *     Process.setsid   #=&gt; 27422
 */

static VALUE
proc_setsid()
{
#if defined(HAVE_SETSID)
    int pid;

    rb_secure(2);
    pid = setsid();
    if (pid &lt; 0) rb_sys_fail(0);
    return INT2FIX(pid);
#elif defined(HAVE_SETPGRP) &amp;&amp; defined(TIOCNOTTY)
  rb_pid_t pid;
  int ret;

  rb_secure(2);
  pid = getpid();
#if defined(SETPGRP_VOID)
  ret = setpgrp();
  /* If `pid_t setpgrp(void)' is equivalent to setsid(),
     `ret' will be the same value as `pid', and following open() will fail.
     In Linux, `int setpgrp(void)' is equivalent to setpgid(0, 0). */
#else
  ret = setpgrp(0, pid);
#endif
  if (ret == -1) rb_sys_fail(0);

  if ((fd = open(&quot;/dev/tty&quot;, O_RDWR)) &gt;= 0) {
    ioctl(fd, TIOCNOTTY, NULL);
    close(fd);
  }
  return INT2FIX(pid);
#else
    rb_notimplement();
#endif
}


/*
 *  call-seq:
 *     Process.getpriority(kind, integer)   =&gt; fixnum
 *
 *  Gets the scheduling priority for specified process, process group,
 *  or user. &lt;em&gt;kind&lt;/em&gt; indicates the kind of entity to find: one
 *  of &lt;code&gt;Process::PRIO_PGRP&lt;/code&gt;,
 *  &lt;code&gt;Process::PRIO_USER&lt;/code&gt;, or
 *  &lt;code&gt;Process::PRIO_PROCESS&lt;/code&gt;. _integer_ is an id
 *  indicating the particular process, process group, or user (an id
 *  of 0 means _current_). Lower priorities are more favorable
 *  for scheduling. Not available on all platforms.
 *
 *     Process.getpriority(Process::PRIO_USER, 0)      #=&gt; 19
 *     Process.getpriority(Process::PRIO_PROCESS, 0)   #=&gt; 19
 */

static VALUE
proc_getpriority(obj, which, who)
    VALUE obj, which, who;
{
#ifdef HAVE_GETPRIORITY
    int prio, iwhich, iwho;

    rb_secure(2);
    iwhich = NUM2INT(which);
    iwho   = NUM2INT(who);

    errno = 0;
    prio = getpriority(iwhich, iwho);
    if (errno) rb_sys_fail(0);
    return INT2FIX(prio);
#else
    rb_notimplement();
#endif
}


/*
 *  call-seq:
 *     Process.setpriority(kind, integer, priority)   =&gt; 0
 *
 *  See &lt;code&gt;Process#getpriority&lt;/code&gt;.
 *
 *     Process.setpriority(Process::PRIO_USER, 0, 19)      #=&gt; 0
 *     Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=&gt; 0
 *     Process.getpriority(Process::PRIO_USER, 0)          #=&gt; 19
 *     Process.getpriority(Process::PRIO_PROCESS, 0)       #=&gt; 19
 */

static VALUE
proc_setpriority(obj, which, who, prio)
    VALUE obj, which, who, prio;
{
#ifdef HAVE_GETPRIORITY
    int iwhich, iwho, iprio;

    rb_secure(2);
    iwhich = NUM2INT(which);
    iwho   = NUM2INT(who);
    iprio  = NUM2INT(prio);

    if (setpriority(iwhich, iwho, iprio) &lt; 0)
	rb_sys_fail(0);
    return INT2FIX(0);
#else
    rb_notimplement();
#endif
}

#if SIZEOF_RLIM_T == SIZEOF_INT
# define RLIM2NUM(v) UINT2NUM(v)
# define NUM2RLIM(v) NUM2UINT(v)
#elif SIZEOF_RLIM_T == SIZEOF_LONG
# define RLIM2NUM(v) ULONG2NUM(v)
# define NUM2RLIM(v) NUM2ULONG(v)
#elif SIZEOF_RLIM_T == SIZEOF_LONG_LONG
# define RLIM2NUM(v) ULL2NUM(v)
# define NUM2RLIM(v) NUM2ULL(v)
#endif

/*
 *  call-seq:
 *     Process.getrlimit(resource)   =&gt; [cur_limit, max_limit]
 *
 *  Gets the resource limit of the process.
 *  _cur_limit_ means current (soft) limit and
 *  _max_limit_ means maximum (hard) limit.
 *
 *  _resource_ indicates the kind of resource to limit:
 *  such as &lt;code&gt;Process::RLIMIT_CORE&lt;/code&gt;,
 *  &lt;code&gt;Process::RLIMIT_CPU&lt;/code&gt;, etc.
 *  See Process.setrlimit for details.
 *
 *  _cur_limit_ and _max_limit_ may be &lt;code&gt;Process::RLIM_INFINITY&lt;/code&gt;,
 *  &lt;code&gt;Process::RLIM_SAVED_MAX&lt;/code&gt; or
 *  &lt;code&gt;Process::RLIM_SAVED_CUR&lt;/code&gt;.
 *  See Process.setrlimit and the system getrlimit(2) manual for details.
 */

static VALUE
proc_getrlimit(VALUE obj, VALUE resource)
{
#if defined(HAVE_GETRLIMIT) &amp;&amp; defined(RLIM2NUM)
    struct rlimit rlim;

    rb_secure(2);

    if (getrlimit(NUM2INT(resource), &amp;rlim) &lt; 0) {
        rb_sys_fail(&quot;getrlimit&quot;);
    }
    return rb_assoc_new(RLIM2NUM(rlim.rlim_cur), RLIM2NUM(rlim.rlim_max));
#else
    rb_notimplement();
#endif
}

/*
 *  call-seq:
 *     Process.setrlimit(resource, cur_limit, max_limit)        =&gt; nil
 *     Process.setrlimit(resource, cur_limit)                   =&gt; nil
 *
 *  Sets the resource limit of the process.
 *  _cur_limit_ means current (soft) limit and
 *  _max_limit_ means maximum (hard) limit.
 *
 *  If _max_limit_ is not given, _cur_limit_ is used.
 *
 *  _resource_ indicates the kind of resource to limit.
 *  The list of resources are OS dependent.
 *  Ruby may support following resources.
 *
 *  [Process::RLIMIT_CORE] core size (bytes) (SUSv3)
 *  [Process::RLIMIT_CPU] CPU time (seconds) (SUSv3)
 *  [Process::RLIMIT_DATA] data segment (bytes) (SUSv3)
 *  [Process::RLIMIT_FSIZE] file size (bytes) (SUSv3)
 *  [Process::RLIMIT_NOFILE] file descriptors (number) (SUSv3)
 *  [Process::RLIMIT_STACK] stack size (bytes) (SUSv3)
 *  [Process::RLIMIT_AS] total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but 4.4BSD-Lite)
 *  [Process::RLIMIT_MEMLOCK] total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)
 *  [Process::RLIMIT_NPROC] number of processes for the user (number) (4.4BSD, GNU/Linux)
 *  [Process::RLIMIT_RSS] resident memory size (bytes) (4.2BSD, GNU/Linux)
 *  [Process::RLIMIT_SBSIZE] all socket buffers (bytes) (NetBSD, FreeBSD)
 *
 *  Other &lt;code&gt;Process::RLIMIT_???&lt;/code&gt; constants may be defined.
 *
 *  _cur_limit_ and _max_limit_ may be &lt;code&gt;Process::RLIM_INFINITY&lt;/code&gt;,
 *  which means that the resource is not limited.
 *  They may be &lt;code&gt;Process::RLIM_SAVED_MAX&lt;/code&gt; or
 *  &lt;code&gt;Process::RLIM_SAVED_CUR&lt;/code&gt; too.
 *  See system setrlimit(2) manual for details.
 *
 */

static VALUE
proc_setrlimit(int argc, VALUE *argv, VALUE obj)
{
#if defined(HAVE_SETRLIMIT) &amp;&amp; defined(NUM2RLIM)
    VALUE resource, rlim_cur, rlim_max;
    struct rlimit rlim;

    rb_secure(2);

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;resource, &amp;rlim_cur, &amp;rlim_max);
    if (rlim_max == Qnil)
        rlim_max = rlim_cur;

    rlim.rlim_cur = NUM2RLIM(rlim_cur);
    rlim.rlim_max = NUM2RLIM(rlim_max);

    if (setrlimit(NUM2INT(resource), &amp;rlim) &lt; 0) {
        rb_sys_fail(&quot;setrlimit&quot;);
    }
    return Qnil;
#else
    rb_notimplement();
#endif
}

static int under_uid_switch = 0;
static void
check_uid_switch()
{
    rb_secure(2);
    if (under_uid_switch) {
	rb_raise(rb_eRuntimeError, &quot;can't handle UID while evaluating block given to Process::UID.switch method&quot;);
    }
}

static int under_gid_switch = 0;
static void
check_gid_switch()
{
    rb_secure(2);
    if (under_gid_switch) {
	rb_raise(rb_eRuntimeError, &quot;can't handle GID while evaluating block given to Process::UID.switch method&quot;);
    }
}


/*********************************************************************
 * Document-class: Process::Sys
 *
 *  The &lt;code&gt;Process::Sys&lt;/code&gt; module contains UID and GID
 *  functions which provide direct bindings to the system calls of the
 *  same names instead of the more-portable versions of the same
 *  functionality found in the &lt;code&gt;Process&lt;/code&gt;,
 *  &lt;code&gt;Process::UID&lt;/code&gt;, and &lt;code&gt;Process::GID&lt;/code&gt; modules.
 */


/*
 *  call-seq:
 *     Process::Sys.setuid(integer)   =&gt; nil
 *
 *  Set the user ID of the current process to _integer_. Not
 *  available on all platforms.
 *
 */

static VALUE
p_sys_setuid(obj, id)
    VALUE obj, id;
{
#if defined HAVE_SETUID
    check_uid_switch();
    if (setuid(NUM2INT(id)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}



/*
 *  call-seq:
 *     Process::Sys.setruid(integer)   =&gt; nil
 *
 *  Set the real user ID of the calling process to _integer_.
 *  Not available on all platforms.
 *
 */

static VALUE
p_sys_setruid(obj, id)
    VALUE obj, id;
{
#if defined HAVE_SETRUID
    check_uid_switch();
    if (setruid(NUM2INT(id)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}


/*
 *  call-seq:
 *     Process::Sys.seteuid(integer)   =&gt; nil
 *
 *  Set the effective user ID of the calling process to
 *  _integer_.  Not available on all platforms.
 *
 */

static VALUE
p_sys_seteuid(obj, id)
    VALUE obj, id;
{
#if defined HAVE_SETEUID
    check_uid_switch();
    if (seteuid(NUM2INT(id)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}


/*
 *  call-seq:
 *     Process::Sys.setreuid(rid, eid)   =&gt; nil
 *
 *  Sets the (integer) real and/or effective user IDs of the current
 *  process to _rid_ and _eid_, respectively. A value of
 *  &lt;code&gt;-1&lt;/code&gt; for either means to leave that ID unchanged. Not
 *  available on all platforms.
 *
 */

static VALUE
p_sys_setreuid(obj, rid, eid)
    VALUE obj, rid, eid;
{
#if defined HAVE_SETREUID
    check_uid_switch();
    if (setreuid(NUM2INT(rid),NUM2INT(eid)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}


/*
 *  call-seq:
 *     Process::Sys.setresuid(rid, eid, sid)   =&gt; nil
 *
 *  Sets the (integer) real, effective, and saved user IDs of the
 *  current process to _rid_, _eid_, and _sid_ respectively. A
 *  value of &lt;code&gt;-1&lt;/code&gt; for any value means to
 *  leave that ID unchanged. Not available on all platforms.
 *
 */

static VALUE
p_sys_setresuid(obj, rid, eid, sid)
    VALUE obj, rid, eid, sid;
{
#if defined HAVE_SETRESUID
    check_uid_switch();
    if (setresuid(NUM2INT(rid),NUM2INT(eid),NUM2INT(sid)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}


/*
 *  call-seq:
 *     Process.uid           =&gt; fixnum
 *     Process::UID.rid      =&gt; fixnum
 *     Process::Sys.getuid   =&gt; fixnum
 *
 *  Returns the (real) user ID of this process.
 *
 *     Process.uid   #=&gt; 501
 */

static VALUE
proc_getuid(obj)
    VALUE obj;
{
    int uid = getuid();
    return INT2FIX(uid);
}


/*
 *  call-seq:
 *     Process.uid= integer   =&gt; numeric
 *
 *  Sets the (integer) user ID for this process. Not available on all
 *  platforms.
 */

static VALUE
proc_setuid(obj, id)
    VALUE obj, id;
{
    int uid = NUM2INT(id);

    check_uid_switch();
#if defined(HAVE_SETRESUID) &amp;&amp;  !defined(__CHECKER__)
    if (setresuid(uid, -1, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREUID
    if (setreuid(uid, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETRUID
    if (setruid(uid) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETUID
    {
	if (geteuid() == uid) {
	    if (setuid(uid) &lt; 0) rb_sys_fail(0);
	}
	else {
	    rb_notimplement();
	}
    }
#else
    rb_notimplement();
#endif
    return INT2FIX(uid);
}


/********************************************************************
 *
 * Document-class: Process::UID
 *
 *  The &lt;code&gt;Process::UID&lt;/code&gt; module contains a collection of
 *  module functions which can be used to portably get, set, and
 *  switch the current process's real, effective, and saved user IDs.
 *
 */

static int SAVED_USER_ID = -1;

#ifdef BROKEN_SETREUID
int
setreuid(ruid, euid)
    rb_uid_t ruid, euid;
{
    if (ruid != -1 &amp;&amp; ruid != getuid()) {
	if (euid == -1) euid = geteuid();
	if (setuid(ruid) &lt; 0) return -1;
    }
    if (euid != -1 &amp;&amp; euid != geteuid()) {
	if (seteuid(euid) &lt; 0) return -1;
    }
    return 0;
}
#endif

/*
 *  call-seq:
 *     Process::UID.change_privilege(integer)   =&gt; fixnum
 *
 *  Change the current process's real and effective user ID to that
 *  specified by _integer_. Returns the new user ID. Not
 *  available on all platforms.
 *
 *     [Process.uid, Process.euid]          #=&gt; [0, 0]
 *     Process::UID.change_privilege(31)    #=&gt; 31
 *     [Process.uid, Process.euid]          #=&gt; [31, 31]
 */

static VALUE
p_uid_change_privilege(obj, id)
    VALUE obj, id;
{
    int uid;

    check_uid_switch();

    uid = NUM2INT(id);

    if (geteuid() == 0) { /* root-user */
#if defined(HAVE_SETRESUID)
	if (setresuid(uid, uid, uid) &lt; 0) rb_sys_fail(0);
	SAVED_USER_ID = uid;
#elif defined(HAVE_SETUID)
	if (setuid(uid) &lt; 0) rb_sys_fail(0);
	SAVED_USER_ID = uid;
#elif defined(HAVE_SETREUID) &amp;&amp; !defined(OBSOLETE_SETREUID)
	if (getuid() == uid) {
	    if (SAVED_USER_ID == uid) {
		if (setreuid(-1, uid) &lt; 0) rb_sys_fail(0);
	    } else {
		if (uid == 0) { /* (r,e,s) == (root, root, x) */
		    if (setreuid(-1, SAVED_USER_ID) &lt; 0) rb_sys_fail(0);
		    if (setreuid(SAVED_USER_ID, 0) &lt; 0) rb_sys_fail(0);
		    SAVED_USER_ID = 0; /* (r,e,s) == (x, root, root) */
		    if (setreuid(uid, uid) &lt; 0) rb_sys_fail(0);
		    SAVED_USER_ID = uid;
		} else {
		    if (setreuid(0, -1) &lt; 0) rb_sys_fail(0);
		    SAVED_USER_ID = 0;
		    if (setreuid(uid, uid) &lt; 0) rb_sys_fail(0);
		    SAVED_USER_ID = uid;
		}
	    }
	} else {
	    if (setreuid(uid, uid) &lt; 0) rb_sys_fail(0);
	    SAVED_USER_ID = uid;
	}
#elif defined(HAVE_SETRUID) &amp;&amp; defined(HAVE_SETEUID)
	if (getuid() == uid) {
	    if (SAVED_USER_ID == uid) {
		if (seteuid(uid) &lt; 0) rb_sys_fail(0);
	    } else {
		if (uid == 0) {
		    if (setruid(SAVED_USER_ID) &lt; 0) rb_sys_fail(0);
		    SAVED_USER_ID = 0;
		    if (setruid(0) &lt; 0) rb_sys_fail(0);
		} else {
		    if (setruid(0) &lt; 0) rb_sys_fail(0);
		    SAVED_USER_ID = 0;
		    if (seteuid(uid) &lt; 0) rb_sys_fail(0);
		    if (setruid(uid) &lt; 0) rb_sys_fail(0);
		    SAVED_USER_ID = uid;
		}
	    }
	} else {
	    if (seteuid(uid) &lt; 0) rb_sys_fail(0);
	    if (setruid(uid) &lt; 0) rb_sys_fail(0);
	    SAVED_USER_ID = uid;
	}
#else
	rb_notimplement();
#endif
    } else { /* unprivileged user */
#if defined(HAVE_SETRESUID)
	if (setresuid((getuid() == uid)? -1: uid,
		      (geteuid() == uid)? -1: uid,
		      (SAVED_USER_ID == uid)? -1: uid) &lt; 0) rb_sys_fail(0);
	SAVED_USER_ID = uid;
#elif defined(HAVE_SETREUID) &amp;&amp; !defined(OBSOLETE_SETREUID)
	if (SAVED_USER_ID == uid) {
	    if (setreuid((getuid() == uid)? -1: uid,
			 (geteuid() == uid)? -1: uid) &lt; 0) rb_sys_fail(0);
	} else if (getuid() != uid) {
	    if (setreuid(uid, (geteuid() == uid)? -1: uid) &lt; 0) rb_sys_fail(0);
	    SAVED_USER_ID = uid;
	} else if (/* getuid() == uid &amp;&amp; */ geteuid() != uid) {
	    if (setreuid(geteuid(), uid) &lt; 0) rb_sys_fail(0);
	    SAVED_USER_ID = uid;
	    if (setreuid(uid, -1) &lt; 0) rb_sys_fail(0);
	} else { /* getuid() == uid &amp;&amp; geteuid() == uid */
	    if (setreuid(-1, SAVED_USER_ID) &lt; 0) rb_sys_fail(0);
	    if (setreuid(SAVED_USER_ID, uid) &lt; 0) rb_sys_fail(0);
	    SAVED_USER_ID = uid;
	    if (setreuid(uid, -1) &lt; 0) rb_sys_fail(0);
	}
#elif defined(HAVE_SETRUID) &amp;&amp; defined(HAVE_SETEUID)
	if (SAVED_USER_ID == uid) {
	    if (geteuid() != uid &amp;&amp; seteuid(uid) &lt; 0) rb_sys_fail(0);
	    if (getuid() != uid &amp;&amp; setruid(uid) &lt; 0) rb_sys_fail(0);
	} else if (/* SAVED_USER_ID != uid &amp;&amp; */ geteuid() == uid) {
	    if (getuid() != uid) {
		if (setruid(uid) &lt; 0) rb_sys_fail(0);
		SAVED_USER_ID = uid;
	    } else {
		if (setruid(SAVED_USER_ID) &lt; 0) rb_sys_fail(0);
		SAVED_USER_ID = uid;
		if (setruid(uid) &lt; 0) rb_sys_fail(0);
	    }
	} else if (/* geteuid() != uid &amp;&amp; */ getuid() == uid) {
	    if (seteuid(uid) &lt; 0) rb_sys_fail(0);
	    if (setruid(SAVED_USER_ID) &lt; 0) rb_sys_fail(0);
	    SAVED_USER_ID = uid;
	    if (setruid(uid) &lt; 0) rb_sys_fail(0);
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#elif defined HAVE_44BSD_SETUID
	if (getuid() == uid) {
	    /* (r,e,s)==(uid,?,?) ==&gt; (uid,uid,uid) */
	    if (setuid(uid) &lt; 0) rb_sys_fail(0);
	    SAVED_USER_ID = uid;
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#elif defined HAVE_SETEUID
	if (getuid() == uid &amp;&amp; SAVED_USER_ID == uid) {
	    if (seteuid(uid) &lt; 0) rb_sys_fail(0);
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#elif defined HAVE_SETUID
	if (getuid() == uid &amp;&amp; SAVED_USER_ID == uid) {
	    if (setuid(uid) &lt; 0) rb_sys_fail(0);
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#else
	rb_notimplement();
#endif
    }
    return INT2FIX(uid);
}



/*
 *  call-seq:
 *     Process::Sys.setgid(integer)   =&gt; nil
 *
 *  Set the group ID of the current process to _integer_. Not
 *  available on all platforms.
 *
 */

static VALUE
p_sys_setgid(obj, id)
    VALUE obj, id;
{
#if defined HAVE_SETGID
    check_gid_switch();
    if (setgid(NUM2INT(id)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}


/*
 *  call-seq:
 *     Process::Sys.setrgid(integer)   =&gt; nil
 *
 *  Set the real group ID of the calling process to _integer_.
 *  Not available on all platforms.
 *
 */

static VALUE
p_sys_setrgid(obj, id)
    VALUE obj, id;
{
#if defined HAVE_SETRGID
    check_gid_switch();
    if (setrgid(NUM2INT(id)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}



/*
 *  call-seq:
 *     Process::Sys.setegid(integer)   =&gt; nil
 *
 *  Set the effective group ID of the calling process to
 *  _integer_.  Not available on all platforms.
 *
 */

static VALUE
p_sys_setegid(obj, id)
    VALUE obj, id;
{
#if defined HAVE_SETEGID
    check_gid_switch();
    if (setegid(NUM2INT(id)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}


/*
 *  call-seq:
 *     Process::Sys.setregid(rid, eid)   =&gt; nil
 *
 *  Sets the (integer) real and/or effective group IDs of the current
 *  process to &lt;em&gt;rid&lt;/em&gt; and &lt;em&gt;eid&lt;/em&gt;, respectively. A value of
 *  &lt;code&gt;-1&lt;/code&gt; for either means to leave that ID unchanged. Not
 *  available on all platforms.
 *
 */

static VALUE
p_sys_setregid(obj, rid, eid)
    VALUE obj, rid, eid;
{
#if defined HAVE_SETREGID
    check_gid_switch();
    if (setregid(NUM2INT(rid),NUM2INT(eid)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}

/*
 *  call-seq:
 *     Process::Sys.setresgid(rid, eid, sid)   =&gt; nil
 *
 *  Sets the (integer) real, effective, and saved user IDs of the
 *  current process to &lt;em&gt;rid&lt;/em&gt;, &lt;em&gt;eid&lt;/em&gt;, and &lt;em&gt;sid&lt;/em&gt;
 *  respectively. A value of &lt;code&gt;-1&lt;/code&gt; for any value means to
 *  leave that ID unchanged. Not available on all platforms.
 *
 */

static VALUE
p_sys_setresgid(obj, rid, eid, sid)
    VALUE obj, rid, eid, sid;
{
#if defined HAVE_SETRESGID
    check_gid_switch();
    if (setresgid(NUM2INT(rid),NUM2INT(eid),NUM2INT(sid)) != 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return Qnil;
}


/*
 *  call-seq:
 *     Process::Sys.issetugid   =&gt; true or false
 *
 *  Returns +true+ if the process was created as a result
 *  of an execve(2) system call which had either of the setuid or
 *  setgid bits set (and extra privileges were given as a result) or
 *  if it has changed any of its real, effective or saved user or
 *  group IDs since it began execution.
 *
 */

static VALUE
p_sys_issetugid(obj)
    VALUE obj;
{
#if defined HAVE_ISSETUGID
    rb_secure(2);
    if (issetugid()) {
	return Qtrue;
    } else {
	return Qfalse;
    }
#else
    rb_notimplement();
    return Qnil;		/* not reached */
#endif
}


/*
 *  call-seq:
 *     Process.gid           =&gt; fixnum
 *     Process::GID.rid      =&gt; fixnum
 *     Process::Sys.getgid   =&gt; fixnum
 *
 *  Returns the (real) group ID for this process.
 *
 *     Process.gid   #=&gt; 500
 */

static VALUE
proc_getgid(obj)
    VALUE obj;
{
    int gid = getgid();
    return INT2FIX(gid);
}


/*
 *  call-seq:
 *     Process.gid= fixnum   =&gt; fixnum
 *
 *  Sets the group ID for this process.
 */

static VALUE
proc_setgid(obj, id)
    VALUE obj, id;
{
    int gid = NUM2INT(id);

    check_gid_switch();
#if defined(HAVE_SETRESGID) &amp;&amp; !defined(__CHECKER__)
    if (setresgid(gid, -1, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREGID
    if (setregid(gid, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETRGID
    if (setrgid(gid) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETGID
    {
	if (getegid() == gid) {
	    if (setgid(gid) &lt; 0) rb_sys_fail(0);
	}
	else {
	    rb_notimplement();
	}
    }
#else
    rb_notimplement();
#endif
    return INT2FIX(gid);
}


static size_t maxgroups = 32;


/*
 *  call-seq:
 *     Process.groups   =&gt; array
 *
 *  Get an &lt;code&gt;Array&lt;/code&gt; of the gids of groups in the
 *  supplemental group access list for this process.
 *
 *     Process.groups   #=&gt; [27, 6, 10, 11]
 *
 */

static VALUE
proc_getgroups(VALUE obj)
{
#ifdef HAVE_GETGROUPS
    VALUE ary;
    size_t ngroups;
    rb_gid_t *groups;
    int i;

    groups = ALLOCA_N(rb_gid_t, maxgroups);

    ngroups = getgroups(maxgroups, groups);
    if (ngroups == -1)
	rb_sys_fail(0);

    ary = rb_ary_new();
    for (i = 0; i &lt; ngroups; i++)
	rb_ary_push(ary, INT2NUM(groups[i]));

    return ary;
#else
    rb_notimplement();
    return Qnil;
#endif
}


/*
 *  call-seq:
 *     Process.groups= array   =&gt; array
 *
 *  Set the supplemental group access list to the given
 *  &lt;code&gt;Array&lt;/code&gt; of group IDs.
 *
 *     Process.groups   #=&gt; [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
 *     Process.groups = [27, 6, 10, 11]   #=&gt; [27, 6, 10, 11]
 *     Process.groups   #=&gt; [27, 6, 10, 11]
 *
 */

static VALUE
proc_setgroups(VALUE obj, VALUE ary)
{
#ifdef HAVE_SETGROUPS
    size_t ngroups;
    rb_gid_t *groups;
    int i;
    struct group *gr;

    Check_Type(ary, T_ARRAY);

    ngroups = RARRAY(ary)-&gt;len;
    if (ngroups &gt; maxgroups)
	rb_raise(rb_eArgError, &quot;too many groups, %d max&quot;, maxgroups);

    groups = ALLOCA_N(rb_gid_t, ngroups);

    for (i = 0; i &lt; ngroups &amp;&amp; i &lt; RARRAY(ary)-&gt;len; i++) {
	VALUE g = RARRAY(ary)-&gt;ptr[i];

	if (FIXNUM_P(g)) {
	    groups[i] = FIX2INT(g);
	}
	else {
	    VALUE tmp = rb_check_string_type(g);

	    if (NIL_P(tmp)) {
		groups[i] = NUM2INT(g);
	    }
	    else {
		gr = getgrnam(RSTRING(tmp)-&gt;ptr);
		if (gr == NULL)
		    rb_raise(rb_eArgError,
			     &quot;can't find group for %s&quot;, RSTRING(tmp)-&gt;ptr);
		groups[i] = gr-&gt;gr_gid;
	    }
	}
    }

    i = setgroups(ngroups, groups);
    if (i == -1)
	rb_sys_fail(0);

    return proc_getgroups(obj);
#else
    rb_notimplement();
    return Qnil;
#endif
}


/*
 *  call-seq:
 *     Process.initgroups(username, gid)   =&gt; array
 *
 *  Initializes the supplemental group access list by reading the
 *  system group database and using all groups of which the given user
 *  is a member. The group with the specified &lt;em&gt;gid&lt;/em&gt; is also
 *  added to the list. Returns the resulting &lt;code&gt;Array&lt;/code&gt; of the
 *  gids of all the groups in the supplementary group access list. Not
 *  available on all platforms.
 *
 *     Process.groups   #=&gt; [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
 *     Process.initgroups( &quot;mgranger&quot;, 30 )   #=&gt; [30, 6, 10, 11]
 *     Process.groups   #=&gt; [30, 6, 10, 11]
 *
 */

static VALUE
proc_initgroups(obj, uname, base_grp)
    VALUE obj, uname, base_grp;
{
#ifdef HAVE_INITGROUPS
    if (initgroups(StringValuePtr(uname), (rb_gid_t)NUM2INT(base_grp)) != 0) {
	rb_sys_fail(0);
    }
    return proc_getgroups(obj);
#else
    rb_notimplement();
    return Qnil;
#endif
}


/*
 *  call-seq:
 *     Process.maxgroups   =&gt; fixnum
 *
 *  Returns the maximum number of gids allowed in the supplemental
 *  group access list.
 *
 *     Process.maxgroups   #=&gt; 32
 */

static VALUE
proc_getmaxgroups(obj)
    VALUE obj;
{
    return INT2FIX(maxgroups);
}


/*
 *  call-seq:
 *     Process.maxgroups= fixnum   =&gt; fixnum
 *
 *  Sets the maximum number of gids allowed in the supplemental group
 *  access list.
 */

static VALUE
proc_setmaxgroups(VALUE obj, VALUE val)
{
    size_t  ngroups = FIX2INT(val);

    if (ngroups &gt; 4096)
	ngroups = 4096;

    maxgroups = ngroups;

    return INT2FIX(maxgroups);
}


/********************************************************************
 *
 * Document-class: Process::GID
 *
 *  The &lt;code&gt;Process::GID&lt;/code&gt; module contains a collection of
 *  module functions which can be used to portably get, set, and
 *  switch the current process's real, effective, and saved group IDs.
 *
 */

static int SAVED_GROUP_ID = -1;

#ifdef BROKEN_SETREGID
int
setregid(rgid, egid)
    rb_gid_t rgid, egid;
{
    if (rgid != -1 &amp;&amp; rgid != getgid()) {
	if (egid == -1) egid = getegid();
	if (setgid(rgid) &lt; 0) return -1;
    }
    if (egid != -1 &amp;&amp; egid != getegid()) {
	if (setegid(egid) &lt; 0) return -1;
    }
    return 0;
}
#endif

/*
 *  call-seq:
 *     Process::GID.change_privilege(integer)   =&gt; fixnum
 *
 *  Change the current process's real and effective group ID to that
 *  specified by _integer_. Returns the new group ID. Not
 *  available on all platforms.
 *
 *     [Process.gid, Process.egid]          #=&gt; [0, 0]
 *     Process::GID.change_privilege(33)    #=&gt; 33
 *     [Process.gid, Process.egid]          #=&gt; [33, 33]
 */

static VALUE
p_gid_change_privilege(obj, id)
    VALUE obj, id;
{
    int gid;

    check_gid_switch();

    gid = NUM2INT(id);

    if (geteuid() == 0) { /* root-user */
#if defined(HAVE_SETRESGID)
	if (setresgid(gid, gid, gid) &lt; 0) rb_sys_fail(0);
	SAVED_GROUP_ID = gid;
#elif defined HAVE_SETGID
	if (setgid(gid) &lt; 0) rb_sys_fail(0);
	SAVED_GROUP_ID = gid;
#elif defined(HAVE_SETREGID) &amp;&amp; !defined(OBSOLETE_SETREGID)
	if (getgid() == gid) {
	    if (SAVED_GROUP_ID == gid) {
		if (setregid(-1, gid) &lt; 0) rb_sys_fail(0);
	    } else {
		if (gid == 0) { /* (r,e,s) == (root, y, x) */
		    if (setregid(-1, SAVED_GROUP_ID) &lt; 0) rb_sys_fail(0);
		    if (setregid(SAVED_GROUP_ID, 0) &lt; 0) rb_sys_fail(0);
		    SAVED_GROUP_ID = 0; /* (r,e,s) == (x, root, root) */
		    if (setregid(gid, gid) &lt; 0) rb_sys_fail(0);
		    SAVED_GROUP_ID = gid;
		} else { /* (r,e,s) == (z, y, x) */
		    if (setregid(0, 0) &lt; 0) rb_sys_fail(0);
		    SAVED_GROUP_ID = 0;
		    if (setregid(gid, gid) &lt; 0) rb_sys_fail(0);
		    SAVED_GROUP_ID = gid;
		}
	    }
	} else {
	    if (setregid(gid, gid) &lt; 0) rb_sys_fail(0);
	    SAVED_GROUP_ID = gid;
	}
#elif defined(HAVE_SETRGID) &amp;&amp; defined (HAVE_SETEGID)
	if (getgid() == gid) {
	    if (SAVED_GROUP_ID == gid) {
		if (setegid(gid) &lt; 0) rb_sys_fail(0);
	    } else {
		if (gid == 0) {
		    if (setegid(gid) &lt; 0) rb_sys_fail(0);
		    if (setrgid(SAVED_GROUP_ID) &lt; 0) rb_sys_fail(0);
		    SAVED_GROUP_ID = 0;
		    if (setrgid(0) &lt; 0) rb_sys_fail(0);
		} else {
		    if (setrgid(0) &lt; 0) rb_sys_fail(0);
		    SAVED_GROUP_ID = 0;
		    if (setegid(gid) &lt; 0) rb_sys_fail(0);
		    if (setrgid(gid) &lt; 0) rb_sys_fail(0);
		    SAVED_GROUP_ID = gid;
		}
	    }
	} else {
	    if (setegid(gid) &lt; 0) rb_sys_fail(0);
	    if (setrgid(gid) &lt; 0) rb_sys_fail(0);
	    SAVED_GROUP_ID = gid;
	}
#else
	rb_notimplement();
#endif
    } else { /* unprivileged user */
#if defined(HAVE_SETRESGID)
	if (setresgid((getgid() == gid)? -1: gid,
		      (getegid() == gid)? -1: gid,
		      (SAVED_GROUP_ID == gid)? -1: gid) &lt; 0) rb_sys_fail(0);
	SAVED_GROUP_ID = gid;
#elif defined(HAVE_SETREGID) &amp;&amp; !defined(OBSOLETE_SETREGID)
	if (SAVED_GROUP_ID == gid) {
	    if (setregid((getgid() == gid)? -1: gid,
			 (getegid() == gid)? -1: gid) &lt; 0) rb_sys_fail(0);
	} else if (getgid() != gid) {
	    if (setregid(gid, (getegid() == gid)? -1: gid) &lt; 0) rb_sys_fail(0);
	    SAVED_GROUP_ID = gid;
	} else if (/* getgid() == gid &amp;&amp; */ getegid() != gid) {
	    if (setregid(getegid(), gid) &lt; 0) rb_sys_fail(0);
	    SAVED_GROUP_ID = gid;
	    if (setregid(gid, -1) &lt; 0) rb_sys_fail(0);
	} else { /* getgid() == gid &amp;&amp; getegid() == gid */
	    if (setregid(-1, SAVED_GROUP_ID) &lt; 0) rb_sys_fail(0);
	    if (setregid(SAVED_GROUP_ID, gid) &lt; 0) rb_sys_fail(0);
	    SAVED_GROUP_ID = gid;
	    if (setregid(gid, -1) &lt; 0) rb_sys_fail(0);
	}
#elif defined(HAVE_SETRGID) &amp;&amp; defined(HAVE_SETEGID)
	if (SAVED_GROUP_ID == gid) {
	    if (getegid() != gid &amp;&amp; setegid(gid) &lt; 0) rb_sys_fail(0);
	    if (getgid() != gid &amp;&amp; setrgid(gid) &lt; 0) rb_sys_fail(0);
	} else if (/* SAVED_GROUP_ID != gid &amp;&amp; */ getegid() == gid) {
	    if (getgid() != gid) {
		if (setrgid(gid) &lt; 0) rb_sys_fail(0);
		SAVED_GROUP_ID = gid;
	    } else {
		if (setrgid(SAVED_GROUP_ID) &lt; 0) rb_sys_fail(0);
		SAVED_GROUP_ID = gid;
		if (setrgid(gid) &lt; 0) rb_sys_fail(0);
	    }
	} else if (/* getegid() != gid &amp;&amp; */ getgid() == gid) {
	    if (setegid(gid) &lt; 0) rb_sys_fail(0);
	    if (setrgid(SAVED_GROUP_ID) &lt; 0) rb_sys_fail(0);
	    SAVED_GROUP_ID = gid;
	    if (setrgid(gid) &lt; 0) rb_sys_fail(0);
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#elif defined HAVE_44BSD_SETGID
	if (getgid() == gid) {
	    /* (r,e,s)==(gid,?,?) ==&gt; (gid,gid,gid) */
	    if (setgid(gid) &lt; 0) rb_sys_fail(0);
	    SAVED_GROUP_ID = gid;
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#elif defined HAVE_SETEGID
	if (getgid() == gid &amp;&amp; SAVED_GROUP_ID == gid) {
	    if (setegid(gid) &lt; 0) rb_sys_fail(0);
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#elif defined HAVE_SETGID
	if (getgid() == gid &amp;&amp; SAVED_GROUP_ID == gid) {
	    if (setgid(gid) &lt; 0) rb_sys_fail(0);
	} else {
	    errno = EPERM;
	    rb_sys_fail(0);
	}
#else
	rb_notimplement();
#endif
    }
    return INT2FIX(gid);
}


/*
 *  call-seq:
 *     Process.euid           =&gt; fixnum
 *     Process::UID.eid       =&gt; fixnum
 *     Process::Sys.geteuid   =&gt; fixnum
 *
 *  Returns the effective user ID for this process.
 *
 *     Process.euid   #=&gt; 501
 */

static VALUE
proc_geteuid(obj)
    VALUE obj;
{
    int euid = geteuid();
    return INT2FIX(euid);
}


/*
 *  call-seq:
 *     Process.euid= integer
 *
 *  Sets the effective user ID for this process. Not available on all
 *  platforms.
 */

static VALUE
proc_seteuid(obj, euid)
    VALUE obj, euid;
{
    check_uid_switch();
#if defined(HAVE_SETRESUID) &amp;&amp; !defined(__CHECKER__)
    if (setresuid(-1, NUM2INT(euid), -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREUID
    if (setreuid(-1, NUM2INT(euid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETEUID
    if (seteuid(NUM2INT(euid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETUID
    euid = NUM2INT(euid);
    if (euid == getuid()) {
	if (setuid(euid) &lt; 0) rb_sys_fail(0);
    }
    else {
	rb_notimplement();
    }
#else
    rb_notimplement();
#endif
    return euid;
}

static VALUE
rb_seteuid_core(euid)
    int euid;
{
    int uid;

    check_uid_switch();

    uid = getuid();

#if defined(HAVE_SETRESUID) &amp;&amp; !defined(__CHECKER__)
    if (uid != euid) {
	if (setresuid(-1,euid,euid) &lt; 0) rb_sys_fail(0);
	SAVED_USER_ID = euid;
    } else {
	if (setresuid(-1,euid,-1) &lt; 0) rb_sys_fail(0);
    }
#elif defined(HAVE_SETREUID) &amp;&amp; !defined(OBSOLETE_SETREUID)
    if (setreuid(-1, euid) &lt; 0) rb_sys_fail(0);
    if (uid != euid) {
	if (setreuid(euid,uid) &lt; 0) rb_sys_fail(0);
	if (setreuid(uid,euid) &lt; 0) rb_sys_fail(0);
	SAVED_USER_ID = euid;
    }
#elif defined HAVE_SETEUID
    if (seteuid(euid) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETUID
    if (geteuid() == 0) rb_sys_fail(0);
    if (setuid(euid) &lt; 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return INT2FIX(euid);
}


/*
 *  call-seq:
 *     Process::UID.grant_privilege(integer)   =&gt; fixnum
 *     Process::UID.eid= integer               =&gt; fixnum
 *
 *  Set the effective user ID, and if possible, the saved user ID of
 *  the process to the given _integer_. Returns the new
 *  effective user ID. Not available on all platforms.
 *
 *     [Process.uid, Process.euid]          #=&gt; [0, 0]
 *     Process::UID.grant_privilege(31)     #=&gt; 31
 *     [Process.uid, Process.euid]          #=&gt; [0, 31]
 */

static VALUE
p_uid_grant_privilege(obj, id)
    VALUE obj, id;
{
    return rb_seteuid_core(NUM2INT(id));
}


/*
 *  call-seq:
 *     Process.egid          =&gt; fixnum
 *     Process::GID.eid      =&gt; fixnum
 *     Process::Sys.geteid   =&gt; fixnum
 *
 *  Returns the effective group ID for this process. Not available on
 *  all platforms.
 *
 *     Process.egid   #=&gt; 500
 */

static VALUE
proc_getegid(obj)
    VALUE obj;
{
    int egid = getegid();

    return INT2FIX(egid);
}


/*
 *  call-seq:
 *     Process.egid = fixnum   =&gt; fixnum
 *
 *  Sets the effective group ID for this process. Not available on all
 *  platforms.
 */

static VALUE
proc_setegid(obj, egid)
    VALUE obj, egid;
{
    check_gid_switch();

#if defined(HAVE_SETRESGID) &amp;&amp; !defined(__CHECKER__)
    if (setresgid(-1, NUM2INT(egid), -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREGID
    if (setregid(-1, NUM2INT(egid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETEGID
    if (setegid(NUM2INT(egid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETGID
    egid = NUM2INT(egid);
    if (egid == getgid()) {
	if (setgid(egid) &lt; 0) rb_sys_fail(0);
    }
    else {
	rb_notimplement();
    }
#else
    rb_notimplement();
#endif
    return egid;
}

static VALUE
rb_setegid_core(egid)
    int egid;
{
    int gid;

    check_gid_switch();

    gid = getgid();

#if defined(HAVE_SETRESGID) &amp;&amp; !defined(__CHECKER__)
    if (gid != egid) {
	if (setresgid(-1,egid,egid) &lt; 0) rb_sys_fail(0);
	SAVED_GROUP_ID = egid;
    } else {
	if (setresgid(-1,egid,-1) &lt; 0) rb_sys_fail(0);
    }
#elif defined(HAVE_SETREGID) &amp;&amp; !defined(OBSOLETE_SETREGID)
    if (setregid(-1, egid) &lt; 0) rb_sys_fail(0);
    if (gid != egid) {
	if (setregid(egid,gid) &lt; 0) rb_sys_fail(0);
	if (setregid(gid,egid) &lt; 0) rb_sys_fail(0);
	SAVED_GROUP_ID = egid;
    }
#elif defined HAVE_SETEGID
    if (setegid(egid) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETGID
    if (geteuid() == 0 /* root user */) rb_sys_fail(0);
    if (setgid(egid) &lt; 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return INT2FIX(egid);
}


/*
 *  call-seq:
 *     Process::GID.grant_privilege(integer)    =&gt; fixnum
 *     Process::GID.eid = integer               =&gt; fixnum
 *
 *  Set the effective group ID, and if possible, the saved group ID of
 *  the process to the given _integer_. Returns the new
 *  effective group ID. Not available on all platforms.
 *
 *     [Process.gid, Process.egid]          #=&gt; [0, 0]
 *     Process::GID.grant_privilege(31)     #=&gt; 33
 *     [Process.gid, Process.egid]          #=&gt; [0, 33]
 */

static VALUE
p_gid_grant_privilege(obj, id)
    VALUE obj, id;
{
    return rb_setegid_core(NUM2INT(id));
}


/*
 *  call-seq:
 *     Process::UID.re_exchangeable?   =&gt; true or false
 *
 *  Returns +true+ if the real and effective user IDs of a
 *  process may be exchanged on the current platform.
 *
 */

static VALUE
p_uid_exchangeable()
{
#if defined(HAVE_SETRESUID) &amp;&amp;  !defined(__CHECKER__)
    return Qtrue;
#elif defined(HAVE_SETREUID) &amp;&amp; !defined(OBSOLETE_SETREUID)
    return Qtrue;
#else
    return Qfalse;
#endif
}


/*
 *  call-seq:
 *     Process::UID.re_exchange   =&gt; fixnum
 *
 *  Exchange real and effective user IDs and return the new effective
 *  user ID. Not available on all platforms.
 *
 *     [Process.uid, Process.euid]   #=&gt; [0, 31]
 *     Process::UID.re_exchange      #=&gt; 0
 *     [Process.uid, Process.euid]   #=&gt; [31, 0]
 */

static VALUE
p_uid_exchange(obj)
    VALUE obj;
{
    int uid, euid;

    check_uid_switch();

    uid = getuid();
    euid = geteuid();

#if defined(HAVE_SETRESUID) &amp;&amp;  !defined(__CHECKER__)
    if (setresuid(euid, uid, uid) &lt; 0) rb_sys_fail(0);
    SAVED_USER_ID = uid;
#elif defined(HAVE_SETREUID) &amp;&amp; !defined(OBSOLETE_SETREUID)
    if (setreuid(euid,uid) &lt; 0) rb_sys_fail(0);
    SAVED_USER_ID = uid;
#else
    rb_notimplement();
#endif
    return INT2FIX(uid);
}


/*
 *  call-seq:
 *     Process::GID.re_exchangeable?   =&gt; true or false
 *
 *  Returns +true+ if the real and effective group IDs of a
 *  process may be exchanged on the current platform.
 *
 */

static VALUE
p_gid_exchangeable()
{
#if defined(HAVE_SETRESGID) &amp;&amp;  !defined(__CHECKER__)
    return Qtrue;
#elif defined(HAVE_SETREGID) &amp;&amp; !defined(OBSOLETE_SETREGID)
    return Qtrue;
#else
    return Qfalse;
#endif
}


/*
 *  call-seq:
 *     Process::GID.re_exchange   =&gt; fixnum
 *
 *  Exchange real and effective group IDs and return the new effective
 *  group ID. Not available on all platforms.
 *
 *     [Process.gid, Process.egid]   #=&gt; [0, 33]
 *     Process::GID.re_exchange      #=&gt; 0
 *     [Process.gid, Process.egid]   #=&gt; [33, 0]
 */

static VALUE
p_gid_exchange(obj)
    VALUE obj;
{
    int gid, egid;

    check_gid_switch();

    gid = getgid();
    egid = getegid();

#if defined(HAVE_SETRESGID) &amp;&amp;  !defined(__CHECKER__)
    if (setresgid(egid, gid, gid) &lt; 0) rb_sys_fail(0);
    SAVED_GROUP_ID = gid;
#elif defined(HAVE_SETREGID) &amp;&amp; !defined(OBSOLETE_SETREGID)
    if (setregid(egid,gid) &lt; 0) rb_sys_fail(0);
    SAVED_GROUP_ID = gid;
#else
    rb_notimplement();
#endif
    return INT2FIX(gid);
}

/* [MG] :FIXME: Is this correct? I'm not sure how to phrase this. */

/*
 *  call-seq:
 *     Process::UID.sid_available?   =&gt; true or false
 *
 *  Returns +true+ if the current platform has saved user
 *  ID functionality.
 *
 */

static VALUE
p_uid_have_saved_id()
{
#if defined(HAVE_SETRESUID) || defined(HAVE_SETEUID) || defined(_POSIX_SAVED_IDS)
    return Qtrue;
#else
    return Qfalse;
#endif
}


#if defined(HAVE_SETRESUID) || defined(HAVE_SETEUID) || defined(_POSIX_SAVED_IDS)
static VALUE
p_uid_sw_ensure(id)
    int id;
{
    under_uid_switch = 0;
    return rb_seteuid_core(id);
}


/*
 *  call-seq:
 *     Process::UID.switch              =&gt; fixnum
 *     Process::UID.switch {|| block}   =&gt; object
 *
 *  Switch the effective and real user IDs of the current process. If
 *  a &lt;em&gt;block&lt;/em&gt; is given, the user IDs will be switched back
 *  after the block is executed. Returns the new effective user ID if
 *  called without a block, and the return value of the block if one
 *  is given.
 *
 */

static VALUE
p_uid_switch(obj)
    VALUE obj;
{
    int uid, euid;

    check_uid_switch();

    uid = getuid();
    euid = geteuid();

    if (uid != euid) {
	proc_seteuid(obj, INT2FIX(uid));
	if (rb_block_given_p()) {
	    under_uid_switch = 1;
	    return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, SAVED_USER_ID);
	} else {
	    return INT2FIX(euid);
	}
    } else if (euid != SAVED_USER_ID) {
	proc_seteuid(obj, INT2FIX(SAVED_USER_ID));
	if (rb_block_given_p()) {
	    under_uid_switch = 1;
	    return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, euid);
	} else {
	    return INT2FIX(uid);
	}
    } else {
	errno = EPERM;
	rb_sys_fail(0);
    }

#else
static VALUE
p_uid_sw_ensure(obj)
    VALUE obj;
{
    under_uid_switch = 0;
    return p_uid_exchange(obj);
}

static VALUE
p_uid_switch(obj)
    VALUE obj;
{
    int uid, euid;

    check_uid_switch();

    uid = getuid();
    euid = geteuid();

    if (uid == euid) {
	errno = EPERM;
	rb_sys_fail(0);
    }
    p_uid_exchange(obj);
    if (rb_block_given_p()) {
	under_uid_switch = 1;
	return rb_ensure(rb_yield, Qnil, p_uid_sw_ensure, obj);
    } else {
	return INT2FIX(euid);
    }
#endif
}


/* [MG] :FIXME: Is this correct? I'm not sure how to phrase this. */

/*
 *  call-seq:
 *     Process::GID.sid_available?   =&gt; true or false
 *
 *  Returns +true+ if the current platform has saved group
 *  ID functionality.
 *
 */

static VALUE
p_gid_have_saved_id()
{
#if defined(HAVE_SETRESGID) || defined(HAVE_SETEGID) || defined(_POSIX_SAVED_IDS)
    return Qtrue;
#else
    return Qfalse;
#endif
}

#if defined(HAVE_SETRESGID) || defined(HAVE_SETEGID) || defined(_POSIX_SAVED_IDS)
static VALUE
p_gid_sw_ensure(id)
    int id;
{
    under_gid_switch = 0;
    return rb_setegid_core(id);
}


/*
 *  call-seq:
 *     Process::GID.switch              =&gt; fixnum
 *     Process::GID.switch {|| block}   =&gt; object
 *
 *  Switch the effective and real group IDs of the current process. If
 *  a &lt;em&gt;block&lt;/em&gt; is given, the group IDs will be switched back
 *  after the block is executed. Returns the new effective group ID if
 *  called without a block, and the return value of the block if one
 *  is given.
 *
 */

static VALUE
p_gid_switch(obj)
    VALUE obj;
{
    int gid, egid;

    check_gid_switch();

    gid = getgid();
    egid = getegid();

    if (gid != egid) {
	proc_setegid(obj, INT2FIX(gid));
	if (rb_block_given_p()) {
	    under_gid_switch = 1;
	    return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, SAVED_GROUP_ID);
	} else {
	    return INT2FIX(egid);
	}
    } else if (egid != SAVED_GROUP_ID) {
	proc_setegid(obj, INT2FIX(SAVED_GROUP_ID));
	if (rb_block_given_p()) {
	    under_gid_switch = 1;
	    return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, egid);
	} else {
	    return INT2FIX(gid);
	}
    } else {
	errno = EPERM;
	rb_sys_fail(0);
    }
#else
static VALUE
p_gid_sw_ensure(obj)
    VALUE obj;
{
    under_gid_switch = 0;
    return p_gid_exchange(obj);
}

static VALUE
p_gid_switch(obj)
    VALUE obj;
{
    int gid, egid;

    check_gid_switch();

    gid = getgid();
    egid = getegid();

    if (gid == egid) {
	errno = EPERM;
	rb_sys_fail(0);
    }
    p_gid_exchange(obj);
    if (rb_block_given_p()) {
	under_gid_switch = 1;
	return rb_ensure(rb_yield, Qnil, p_gid_sw_ensure, obj);
    } else {
	return INT2FIX(egid);
    }
#endif
}


/*
 *  call-seq:
 *     Process.times   =&gt; aStructTms
 *
 *  Returns a &lt;code&gt;Tms&lt;/code&gt; structure (see &lt;code&gt;Struct::Tms&lt;/code&gt;
 *  on page 388) that contains user and system CPU times for this
 *  process.
 *
 *     t = Process.times
 *     [ t.utime, t.stime ]   #=&gt; [0.0, 0.02]
 */

VALUE
rb_proc_times(obj)
    VALUE obj;
{
#if defined(HAVE_TIMES) &amp;&amp; !defined(__CHECKER__)
    const double hertz =
#ifdef HAVE__SC_CLK_TCK
	(double)sysconf(_SC_CLK_TCK);
#else
#ifndef HZ
# ifdef CLK_TCK
#   define HZ CLK_TCK
# else
#   define HZ 60
# endif
#endif /* HZ */
	HZ;
#endif
    struct tms buf;
    volatile VALUE utime, stime, cutime, sctime;

    times(&amp;buf);
    return rb_struct_new(S_Tms,
			 utime = rb_float_new(buf.tms_utime / hertz),
			 stime = rb_float_new(buf.tms_stime / hertz),
			 cutime = rb_float_new(buf.tms_cutime / hertz),
			 sctime = rb_float_new(buf.tms_cstime / hertz));
#else
    rb_notimplement();
#endif
}

VALUE rb_mProcess;
VALUE rb_mProcUID;
VALUE rb_mProcGID;
VALUE rb_mProcID_Syscall;


/*
 *  The &lt;code&gt;Process&lt;/code&gt; module is a collection of methods used to
 *  manipulate processes.
 */

void
Init_process()
{
    rb_define_virtual_variable(&quot;$$&quot;, get_pid, 0);
    rb_define_readonly_variable(&quot;$?&quot;, &amp;rb_last_status);
    rb_define_global_function(&quot;exec&quot;, rb_f_exec, -1);
    rb_define_global_function(&quot;fork&quot;, rb_f_fork, 0);
    rb_define_global_function(&quot;exit!&quot;, rb_f_exit_bang, -1);
    rb_define_global_function(&quot;system&quot;, rb_f_system, -1);
    rb_define_global_function(&quot;sleep&quot;, rb_f_sleep, -1);

    rb_mProcess = rb_define_module(&quot;Process&quot;);

#if !defined(_WIN32) &amp;&amp; !defined(DJGPP)
#ifdef WNOHANG
    rb_define_const(rb_mProcess, &quot;WNOHANG&quot;, INT2FIX(WNOHANG));
#else
    rb_define_const(rb_mProcess, &quot;WNOHANG&quot;, INT2FIX(0));
#endif
#ifdef WUNTRACED
    rb_define_const(rb_mProcess, &quot;WUNTRACED&quot;, INT2FIX(WUNTRACED));
#else
    rb_define_const(rb_mProcess, &quot;WUNTRACED&quot;, INT2FIX(0));
#endif
#endif

    rb_define_singleton_method(rb_mProcess, &quot;exec&quot;, rb_f_exec, -1);
    rb_define_singleton_method(rb_mProcess, &quot;fork&quot;, rb_f_fork, 0);
    rb_define_singleton_method(rb_mProcess, &quot;exit!&quot;, rb_f_exit_bang, -1);
    rb_define_singleton_method(rb_mProcess, &quot;exit&quot;, rb_f_exit, -1);   /* in eval.c */
    rb_define_singleton_method(rb_mProcess, &quot;abort&quot;, rb_f_abort, -1); /* in eval.c */

    rb_define_module_function(rb_mProcess, &quot;kill&quot;, rb_f_kill, -1); /* in signal.c */
    rb_define_module_function(rb_mProcess, &quot;wait&quot;, proc_wait, -1);
    rb_define_module_function(rb_mProcess, &quot;wait2&quot;, proc_wait2, -1);
    rb_define_module_function(rb_mProcess, &quot;waitpid&quot;, proc_wait, -1);
    rb_define_module_function(rb_mProcess, &quot;waitpid2&quot;, proc_wait2, -1);
    rb_define_module_function(rb_mProcess, &quot;waitall&quot;, proc_waitall, 0);
    rb_define_module_function(rb_mProcess, &quot;detach&quot;, proc_detach, 1);

    rb_cProcStatus = rb_define_class_under(rb_mProcess, &quot;Status&quot;, rb_cObject);
    rb_undef_method(CLASS_OF(rb_cProcStatus), &quot;new&quot;);

    rb_define_method(rb_cProcStatus, &quot;==&quot;, pst_equal, 1);
    rb_define_method(rb_cProcStatus, &quot;&amp;&quot;, pst_bitand, 1);
    rb_define_method(rb_cProcStatus, &quot;&gt;&gt;&quot;, pst_rshift, 1);
    rb_define_method(rb_cProcStatus, &quot;to_i&quot;, pst_to_i, 0);
    rb_define_method(rb_cProcStatus, &quot;to_int&quot;, pst_to_i, 0);
    rb_define_method(rb_cProcStatus, &quot;to_s&quot;, pst_to_s, 0);
    rb_define_method(rb_cProcStatus, &quot;inspect&quot;, pst_inspect, 0);

    rb_define_method(rb_cProcStatus, &quot;pid&quot;, pst_pid, 0);

    rb_define_method(rb_cProcStatus, &quot;stopped?&quot;, pst_wifstopped, 0);
    rb_define_method(rb_cProcStatus, &quot;stopsig&quot;, pst_wstopsig, 0);
    rb_define_method(rb_cProcStatus, &quot;signaled?&quot;, pst_wifsignaled, 0);
    rb_define_method(rb_cProcStatus, &quot;termsig&quot;, pst_wtermsig, 0);
    rb_define_method(rb_cProcStatus, &quot;exited?&quot;, pst_wifexited, 0);
    rb_define_method(rb_cProcStatus, &quot;exitstatus&quot;, pst_wexitstatus, 0);
    rb_define_method(rb_cProcStatus, &quot;success?&quot;, pst_success_p, 0);
    rb_define_method(rb_cProcStatus, &quot;coredump?&quot;, pst_wcoredump, 0);

    rb_define_module_function(rb_mProcess, &quot;pid&quot;, get_pid, 0);
    rb_define_module_function(rb_mProcess, &quot;ppid&quot;, get_ppid, 0);

    rb_define_module_function(rb_mProcess, &quot;getpgrp&quot;, proc_getpgrp, 0);
    rb_define_module_function(rb_mProcess, &quot;setpgrp&quot;, proc_setpgrp, 0);
    rb_define_module_function(rb_mProcess, &quot;getpgid&quot;, proc_getpgid, 1);
    rb_define_module_function(rb_mProcess, &quot;setpgid&quot;, proc_setpgid, 2);

    rb_define_module_function(rb_mProcess, &quot;setsid&quot;, proc_setsid, 0);

    rb_define_module_function(rb_mProcess, &quot;getpriority&quot;, proc_getpriority, 2);
    rb_define_module_function(rb_mProcess, &quot;setpriority&quot;, proc_setpriority, 3);

#ifdef HAVE_GETPRIORITY
    rb_define_const(rb_mProcess, &quot;PRIO_PROCESS&quot;, INT2FIX(PRIO_PROCESS));
    rb_define_const(rb_mProcess, &quot;PRIO_PGRP&quot;, INT2FIX(PRIO_PGRP));
    rb_define_const(rb_mProcess, &quot;PRIO_USER&quot;, INT2FIX(PRIO_USER));
#endif

    rb_define_module_function(rb_mProcess, &quot;getrlimit&quot;, proc_getrlimit, 1);
    rb_define_module_function(rb_mProcess, &quot;setrlimit&quot;, proc_setrlimit, -1);
#ifdef RLIM2NUM
    {
        VALUE inf = RLIM2NUM(RLIM_INFINITY), v;
        rb_define_const(rb_mProcess, &quot;RLIM_INFINITY&quot;, inf);
#ifdef RLIM_SAVED_MAX
        v = RLIM_INFINITY == RLIM_SAVED_MAX ? inf : RLIM2NUM(RLIM_SAVED_MAX);
        rb_define_const(rb_mProcess, &quot;RLIM_SAVED_MAX&quot;, v);
#endif
#ifdef RLIM_SAVED_CUR
        v = RLIM_INFINITY == RLIM_SAVED_CUR ? inf : RLIM2NUM(RLIM_SAVED_CUR);
        rb_define_const(rb_mProcess, &quot;RLIM_SAVED_CUR&quot;, v);
#endif
    }
#ifdef RLIMIT_CORE
    rb_define_const(rb_mProcess, &quot;RLIMIT_CORE&quot;, INT2FIX(RLIMIT_CORE));
#endif
#ifdef RLIMIT_CPU
    rb_define_const(rb_mProcess, &quot;RLIMIT_CPU&quot;, INT2FIX(RLIMIT_CPU));
#endif
#ifdef RLIMIT_DATA
    rb_define_const(rb_mProcess, &quot;RLIMIT_DATA&quot;, INT2FIX(RLIMIT_DATA));
#endif
#ifdef RLIMIT_FSIZE
    rb_define_const(rb_mProcess, &quot;RLIMIT_FSIZE&quot;, INT2FIX(RLIMIT_FSIZE));
#endif
#ifdef RLIMIT_NOFILE
    rb_define_const(rb_mProcess, &quot;RLIMIT_NOFILE&quot;, INT2FIX(RLIMIT_NOFILE));
#endif
#ifdef RLIMIT_STACK
    rb_define_const(rb_mProcess, &quot;RLIMIT_STACK&quot;, INT2FIX(RLIMIT_STACK));
#endif
#ifdef RLIMIT_AS
    rb_define_const(rb_mProcess, &quot;RLIMIT_AS&quot;, INT2FIX(RLIMIT_AS));
#endif
#ifdef RLIMIT_MEMLOCK
    rb_define_const(rb_mProcess, &quot;RLIMIT_MEMLOCK&quot;, INT2FIX(RLIMIT_MEMLOCK));
#endif
#ifdef RLIMIT_NPROC
    rb_define_const(rb_mProcess, &quot;RLIMIT_NPROC&quot;, INT2FIX(RLIMIT_NPROC));
#endif
#ifdef RLIMIT_RSS
    rb_define_const(rb_mProcess, &quot;RLIMIT_RSS&quot;, INT2FIX(RLIMIT_RSS));
#endif
#ifdef RLIMIT_SBSIZE
    rb_define_const(rb_mProcess, &quot;RLIMIT_SBSIZE&quot;, INT2FIX(RLIMIT_SBSIZE));
#endif
#endif

    rb_define_module_function(rb_mProcess, &quot;uid&quot;, proc_getuid, 0);
    rb_define_module_function(rb_mProcess, &quot;uid=&quot;, proc_setuid, 1);
    rb_define_module_function(rb_mProcess, &quot;gid&quot;, proc_getgid, 0);
    rb_define_module_function(rb_mProcess, &quot;gid=&quot;, proc_setgid, 1);
    rb_define_module_function(rb_mProcess, &quot;euid&quot;, proc_geteuid, 0);
    rb_define_module_function(rb_mProcess, &quot;euid=&quot;, proc_seteuid, 1);
    rb_define_module_function(rb_mProcess, &quot;egid&quot;, proc_getegid, 0);
    rb_define_module_function(rb_mProcess, &quot;egid=&quot;, proc_setegid, 1);
    rb_define_module_function(rb_mProcess, &quot;initgroups&quot;, proc_initgroups, 2);
    rb_define_module_function(rb_mProcess, &quot;groups&quot;, proc_getgroups, 0);
    rb_define_module_function(rb_mProcess, &quot;groups=&quot;, proc_setgroups, 1);
    rb_define_module_function(rb_mProcess, &quot;maxgroups&quot;, proc_getmaxgroups, 0);
    rb_define_module_function(rb_mProcess, &quot;maxgroups=&quot;, proc_setmaxgroups, 1);

    rb_define_module_function(rb_mProcess, &quot;times&quot;, rb_proc_times, 0);

#if defined(HAVE_TIMES) || defined(_WIN32)
    S_Tms = rb_struct_define(&quot;Tms&quot;, &quot;utime&quot;, &quot;stime&quot;, &quot;cutime&quot;, &quot;cstime&quot;, NULL);
#endif

    SAVED_USER_ID = geteuid();
    SAVED_GROUP_ID = getegid();

    rb_mProcUID = rb_define_module_under(rb_mProcess, &quot;UID&quot;);
    rb_mProcGID = rb_define_module_under(rb_mProcess, &quot;GID&quot;);

    rb_define_module_function(rb_mProcUID, &quot;rid&quot;, proc_getuid, 0);
    rb_define_module_function(rb_mProcGID, &quot;rid&quot;, proc_getgid, 0);
    rb_define_module_function(rb_mProcUID, &quot;eid&quot;, proc_geteuid, 0);
    rb_define_module_function(rb_mProcGID, &quot;eid&quot;, proc_getegid, 0);
    rb_define_module_function(rb_mProcUID, &quot;change_privilege&quot;, p_uid_change_privilege, 1);
    rb_define_module_function(rb_mProcGID, &quot;change_privilege&quot;, p_gid_change_privilege, 1);
    rb_define_module_function(rb_mProcUID, &quot;grant_privilege&quot;, p_uid_grant_privilege, 1);
    rb_define_module_function(rb_mProcGID, &quot;grant_privilege&quot;, p_gid_grant_privilege, 1);
    rb_define_alias(rb_singleton_class(rb_mProcUID), &quot;eid=&quot;, &quot;grant_privilege&quot;);
    rb_define_alias(rb_singleton_class(rb_mProcGID), &quot;eid=&quot;, &quot;grant_privilege&quot;);
    rb_define_module_function(rb_mProcUID, &quot;re_exchange&quot;, p_uid_exchange, 0);
    rb_define_module_function(rb_mProcGID, &quot;re_exchange&quot;, p_gid_exchange, 0);
    rb_define_module_function(rb_mProcUID, &quot;re_exchangeable?&quot;, p_uid_exchangeable, 0);
    rb_define_module_function(rb_mProcGID, &quot;re_exchangeable?&quot;, p_gid_exchangeable, 0);
    rb_define_module_function(rb_mProcUID, &quot;sid_available?&quot;, p_uid_have_saved_id, 0);
    rb_define_module_function(rb_mProcGID, &quot;sid_available?&quot;, p_gid_have_saved_id, 0);
    rb_define_module_function(rb_mProcUID, &quot;switch&quot;, p_uid_switch, 0);
    rb_define_module_function(rb_mProcGID, &quot;switch&quot;, p_gid_switch, 0);

    rb_mProcID_Syscall = rb_define_module_under(rb_mProcess, &quot;Sys&quot;);

    rb_define_module_function(rb_mProcID_Syscall, &quot;getuid&quot;, proc_getuid, 0);
    rb_define_module_function(rb_mProcID_Syscall, &quot;geteuid&quot;, proc_geteuid, 0);
    rb_define_module_function(rb_mProcID_Syscall, &quot;getgid&quot;, proc_getgid, 0);
    rb_define_module_function(rb_mProcID_Syscall, &quot;getegid&quot;, proc_getegid, 0);

    rb_define_module_function(rb_mProcID_Syscall, &quot;setuid&quot;, p_sys_setuid, 1);
    rb_define_module_function(rb_mProcID_Syscall, &quot;setgid&quot;, p_sys_setgid, 1);

    rb_define_module_function(rb_mProcID_Syscall, &quot;setruid&quot;, p_sys_setruid, 1);
    rb_define_module_function(rb_mProcID_Syscall, &quot;setrgid&quot;, p_sys_setrgid, 1);

    rb_define_module_function(rb_mProcID_Syscall, &quot;seteuid&quot;, p_sys_seteuid, 1);
    rb_define_module_function(rb_mProcID_Syscall, &quot;setegid&quot;, p_sys_setegid, 1);

    rb_define_module_function(rb_mProcID_Syscall, &quot;setreuid&quot;, p_sys_setreuid, 2);
    rb_define_module_function(rb_mProcID_Syscall, &quot;setregid&quot;, p_sys_setregid, 2);

    rb_define_module_function(rb_mProcID_Syscall, &quot;setresuid&quot;, p_sys_setresuid, 3);
    rb_define_module_function(rb_mProcID_Syscall, &quot;setresgid&quot;, p_sys_setresgid, 3);
    rb_define_module_function(rb_mProcID_Syscall, &quot;issetugid&quot;, p_sys_issetugid, 0);
}
</pre>
    </div>