  <div id="fileHeader">
    <h1>compar.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/compar.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Feb 12 17:01:19 -0600 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  compar.c -

  $Author: shyouhei $
  $Date: 2007-02-13 08:01:19 +0900 (Tue, 13 Feb 2007) $
  created at: Thu Aug 26 14:39:48 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;

VALUE rb_mComparable;

static ID cmp;

int
rb_cmpint(val, a, b)
    VALUE val, a, b;
{
    if (NIL_P(val)) {
	rb_cmperr(a, b);
    }
    if (FIXNUM_P(val)) return FIX2INT(val);
    if (TYPE(val) == T_BIGNUM) {
	if (RBIGNUM(val)-&gt;sign) return 1;
	return -1;
    }
    if (RTEST(rb_funcall(val, '&gt;', 1, INT2FIX(0)))) return 1;
    if (RTEST(rb_funcall(val, '&lt;', 1, INT2FIX(0)))) return -1;
    return 0;
}

void
rb_cmperr(x, y)
    VALUE x, y;
{
    const char *classname;

    if (SPECIAL_CONST_P(y)) {
	y = rb_inspect(y);
	classname = StringValuePtr(y);
    }
    else {
	classname = rb_obj_classname(y);
    }
    rb_raise(rb_eArgError, &quot;comparison of %s with %s failed&quot;,
	     rb_obj_classname(x), classname);
}

#define cmperr() (rb_cmperr(x, y), Qnil)

static VALUE
cmp_eq(a)
    VALUE *a;
{
    VALUE c = rb_funcall(a[0], cmp, 1, a[1]);

    if (NIL_P(c)) return Qnil;
    if (rb_cmpint(c, a[0], a[1]) == 0) return Qtrue;
    return Qfalse;
}

static VALUE
cmp_failed()
{
    return Qnil;
}

/*
 *  call-seq:
 *     obj == other    =&gt; true or false
 *  
 *  Compares two objects based on the receiver's &lt;code&gt;&lt;=&gt;&lt;/code&gt;
 *  method, returning true if it returns 0. Also returns true if
 *  _obj_ and _other_ are the same object.
 */

static VALUE
cmp_equal(x, y)
    VALUE x, y;
{
    VALUE a[2];

    if (x == y) return Qtrue;

    a[0] = x; a[1] = y;
    return rb_rescue(cmp_eq, (VALUE)a, cmp_failed, 0);
}

/*
 *  call-seq:
 *     obj &gt; other    =&gt; true or false
 *  
 *  Compares two objects based on the receiver's &lt;code&gt;&lt;=&gt;&lt;/code&gt;
 *  method, returning true if it returns 1.
 */

static VALUE
cmp_gt(x, y)
    VALUE x, y;
{
    VALUE c = rb_funcall(x, cmp, 1, y);

    if (NIL_P(c)) return cmperr();
    if (rb_cmpint(c, x, y) &gt; 0) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     obj &gt;= other    =&gt; true or false
 *  
 *  Compares two objects based on the receiver's &lt;code&gt;&lt;=&gt;&lt;/code&gt;
 *  method, returning true if it returns 0 or 1.
 */

static VALUE
cmp_ge(x, y)
    VALUE x, y;
{
    VALUE c = rb_funcall(x, cmp, 1, y);

    if (NIL_P(c)) return cmperr();
    if (rb_cmpint(c, x, y) &gt;= 0) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     obj &lt; other    =&gt; true or false
 *  
 *  Compares two objects based on the receiver's &lt;code&gt;&lt;=&gt;&lt;/code&gt;
 *  method, returning true if it returns -1.
 */

static VALUE
cmp_lt(x, y)
    VALUE x, y;
{
    VALUE c = rb_funcall(x, cmp, 1, y);

    if (NIL_P(c)) return cmperr();
    if (rb_cmpint(c, x, y) &lt; 0) return Qtrue;
    return Qfalse;
}


/*
 *  call-seq:
 *     obj &lt;= other    =&gt; true or false
 *  
 *  Compares two objects based on the receiver's &lt;code&gt;&lt;=&gt;&lt;/code&gt;
 *  method, returning true if it returns -1 or 0.
 */

static VALUE
cmp_le(x, y)
    VALUE x, y;
{
    VALUE c = rb_funcall(x, cmp, 1, y);

    if (NIL_P(c)) return cmperr();
    if (rb_cmpint(c, x, y) &lt;= 0) return Qtrue;
    return Qfalse;
}

/*
 *  call-seq:
 *     obj.between?(min, max)    =&gt; true or false
 *  
 *  Returns &lt;code&gt;false&lt;/code&gt; if &lt;i&gt;obj&lt;/i&gt; &lt;code&gt;&lt;=&gt;&lt;/code&gt;
 *  &lt;i&gt;min&lt;/i&gt; is less than zero or if &lt;i&gt;anObject&lt;/i&gt; &lt;code&gt;&lt;=&gt;&lt;/code&gt;
 *  &lt;i&gt;max&lt;/i&gt; is greater than zero, &lt;code&gt;true&lt;/code&gt; otherwise.
 *     
 *     3.between?(1, 5)               #=&gt; true
 *     6.between?(1, 5)               #=&gt; false
 *     'cat'.between?('ant', 'dog')   #=&gt; true
 *     'gnu'.between?('ant', 'dog')   #=&gt; false
 *     
 */

static VALUE
cmp_between(x, min, max)
    VALUE x, min, max;
{
    if (RTEST(cmp_lt(x, min))) return Qfalse;
    if (RTEST(cmp_gt(x, max))) return Qfalse;
    return Qtrue;
}

/*
 *  The &lt;code&gt;Comparable&lt;/code&gt; mixin is used by classes whose objects
 *  may be ordered. The class must define the &lt;code&gt;&lt;=&gt;&lt;/code&gt; operator,
 *  which compares the receiver against another object, returning -1, 0,
 *  or +1 depending on whether the receiver is less than, equal to, or
 *  greater than the other object. &lt;code&gt;Comparable&lt;/code&gt; uses
 *  &lt;code&gt;&lt;=&gt;&lt;/code&gt; to implement the conventional comparison operators
 *  (&lt;code&gt;&lt;&lt;/code&gt;, &lt;code&gt;&lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&gt;=&lt;/code&gt;,
 *  and &lt;code&gt;&gt;&lt;/code&gt;) and the method &lt;code&gt;between?&lt;/code&gt;.
 *     
 *     class SizeMatters
 *       include Comparable
 *       attr :str
 *       def &lt;=&gt;(anOther)
 *         str.size &lt;=&gt; anOther.str.size
 *       end
 *       def initialize(str)
 *         @str = str
 *       end
 *       def inspect
 *         @str
 *       end
 *     end
 *     
 *     s1 = SizeMatters.new(&quot;Z&quot;)
 *     s2 = SizeMatters.new(&quot;YY&quot;)
 *     s3 = SizeMatters.new(&quot;XXX&quot;)
 *     s4 = SizeMatters.new(&quot;WWWW&quot;)
 *     s5 = SizeMatters.new(&quot;VVVVV&quot;)
 *     
 *     s1 &lt; s2                       #=&gt; true
 *     s4.between?(s1, s3)           #=&gt; false
 *     s4.between?(s3, s5)           #=&gt; true
 *     [ s3, s2, s5, s4, s1 ].sort   #=&gt; [Z, YY, XXX, WWWW, VVVVV]
 *     
 */

void
Init_Comparable()
{
    rb_mComparable = rb_define_module(&quot;Comparable&quot;);
    rb_define_method(rb_mComparable, &quot;==&quot;, cmp_equal, 1);
    rb_define_method(rb_mComparable, &quot;&gt;&quot;, cmp_gt, 1);
    rb_define_method(rb_mComparable, &quot;&gt;=&quot;, cmp_ge, 1);
    rb_define_method(rb_mComparable, &quot;&lt;&quot;, cmp_lt, 1);
    rb_define_method(rb_mComparable, &quot;&lt;=&quot;, cmp_le, 1);
    rb_define_method(rb_mComparable, &quot;between?&quot;, cmp_between, 2);

    cmp = rb_intern(&quot;&lt;=&gt;&quot;);
}
</pre>
    </div>