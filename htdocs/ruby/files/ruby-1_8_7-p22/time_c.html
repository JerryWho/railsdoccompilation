  <div id="fileHeader">
    <h1>time.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ruby-1.8.7-p22/time.c
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jun 06 05:39:57 -0500 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>/**********************************************************************

  time.c -

  $Author: knu $
  $Date: 2008-06-06 19:39:57 +0900 (Fri, 06 Jun 2008) $
  created at: Tue Dec 28 14:31:59 JST 1993

  Copyright (C) 1993-2003 Yukihiro Matsumoto

**********************************************************************/

#include &quot;ruby.h&quot;
#include &lt;sys/types.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;

#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif

#include &lt;math.h&gt;

VALUE rb_cTime;

struct time_object {
    struct timeval tv;
    struct tm tm;
    int gmt;
    int tm_got;
};

#define GetTimeval(obj, tobj) \
    Data_Get_Struct(obj, struct time_object, tobj)

static void time_free _((void *));
static VALUE time_utc_offset _((VALUE));

static void
time_free(tobj)
    void *tobj;
{
    if (tobj) free(tobj);
}

static VALUE time_s_alloc _((VALUE));
static VALUE
time_s_alloc(klass)
    VALUE klass;
{
    VALUE obj;
    struct time_object *tobj;

    obj = Data_Make_Struct(klass, struct time_object, 0, time_free, tobj);
    tobj-&gt;tm_got=0;
    tobj-&gt;tv.tv_sec = 0;
    tobj-&gt;tv.tv_usec = 0;

    return obj;
}

static void
time_modify(time)
    VALUE time;
{
    rb_check_frozen(time);
    if (!OBJ_TAINTED(time) &amp;&amp; rb_safe_level() &gt;= 4)
	rb_raise(rb_eSecurityError, &quot;Insecure: can't modify Time&quot;);
}

/*
 *  Document-method: now
 *
 *  Synonym for &lt;code&gt;Time.new&lt;/code&gt;. Returns a +Time+ object
 *  initialized tot he current system time.
 *
 *  call-seq:
 *     Time.new -&gt; time
 *  
 *  Returns a &lt;code&gt;Time&lt;/code&gt; object initialized to the current system
 *  time. &lt;b&gt;Note:&lt;/b&gt; The object created will be created using the
 *  resolution available on your system clock, and so may include
 *  fractional seconds.
 *     
 *     a = Time.new      #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     b = Time.new      #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     a == b            #=&gt; false
 *     &quot;%.6f&quot; % a.to_f   #=&gt; &quot;1049896563.230740&quot;
 *     &quot;%.6f&quot; % b.to_f   #=&gt; &quot;1049896563.231466&quot;
 *     
 */

static VALUE
time_init(time)
    VALUE time;
{
    struct time_object *tobj;

    time_modify(time);
    GetTimeval(time, tobj);
    tobj-&gt;tm_got=0;
    tobj-&gt;tv.tv_sec = 0;
    tobj-&gt;tv.tv_usec = 0;
    if (gettimeofday(&amp;tobj-&gt;tv, 0) &lt; 0) {
	rb_sys_fail(&quot;gettimeofday&quot;);
    }

    return time;
}

#define NDIV(x,y) (-(-((x)+1)/(y))-1)
#define NMOD(x,y) ((y)-(-((x)+1)%(y))-1)

static void
time_overflow_p(secp, usecp)
    time_t *secp, *usecp;
{
    time_t tmp, sec = *secp, usec = *usecp;

    if (usec &gt;= 1000000) {	/* usec positive overflow */
	tmp = sec + usec / 1000000;
	usec %= 1000000;
	if (sec &gt; 0 &amp;&amp; tmp &lt; 0) {
	    rb_raise(rb_eRangeError, &quot;out of Time range&quot;);
	}
	sec = tmp;
    }
    if (usec &lt; 0) {		/* usec negative overflow */
	tmp = sec + NDIV(usec,1000000); /* negative div */
	usec = NMOD(usec,1000000);      /* negative mod */
	if (sec &lt; 0 &amp;&amp; tmp &gt; 0) {
	    rb_raise(rb_eRangeError, &quot;out of Time range&quot;);
	}
	sec = tmp;
    }
#ifndef NEGATIVE_TIME_T
    if (sec &lt; 0 || (sec == 0 &amp;&amp; usec &lt; 0))
	rb_raise(rb_eArgError, &quot;time must be positive&quot;);
#endif
    *secp = sec;
    *usecp = usec;
}

static VALUE time_new_internal _((VALUE, time_t, time_t));
static VALUE
time_new_internal(klass, sec, usec)
    VALUE klass;
    time_t sec, usec;
{
    VALUE time = time_s_alloc(klass);
    struct time_object *tobj;

    GetTimeval(time, tobj);
    time_overflow_p(&amp;sec, &amp;usec);
    tobj-&gt;tv.tv_sec = sec;
    tobj-&gt;tv.tv_usec = usec;

    return time;
}

VALUE
rb_time_new(sec, usec)
    time_t sec, usec;
{
    return time_new_internal(rb_cTime, sec, usec);
}

static struct timeval
time_timeval(time, interval)
    VALUE time;
    int interval;
{
    struct timeval t;
    const char *tstr = interval ? &quot;time interval&quot; : &quot;time&quot;;

#ifndef NEGATIVE_TIME_T
    interval = 1;
#endif

    switch (TYPE(time)) {
      case T_FIXNUM:
	t.tv_sec = FIX2LONG(time);
	if (interval &amp;&amp; t.tv_sec &lt; 0)
	    rb_raise(rb_eArgError, &quot;%s must be positive&quot;, tstr);
	t.tv_usec = 0;
	break;

      case T_FLOAT:
	if (interval &amp;&amp; RFLOAT(time)-&gt;value &lt; 0.0)
	    rb_raise(rb_eArgError, &quot;%s must be positive&quot;, tstr);
	else {
	    double f, d;

	    d = modf(RFLOAT(time)-&gt;value, &amp;f);
	    t.tv_sec = (time_t)f;
	    if (f != t.tv_sec) {
		rb_raise(rb_eRangeError, &quot;%f out of Time range&quot;, RFLOAT(time)-&gt;value);
	    }
	    t.tv_usec = (time_t)(d*1e6+0.5);
	}
	break;

      case T_BIGNUM:
	t.tv_sec = NUM2LONG(time);
	if (interval &amp;&amp; t.tv_sec &lt; 0)
	    rb_raise(rb_eArgError, &quot;%s must be positive&quot;, tstr);
	t.tv_usec = 0;
	break;

      default:
	rb_raise(rb_eTypeError, &quot;can't convert %s into %s&quot;,
		 rb_obj_classname(time), tstr);
	break;
    }
    return t;
}

struct timeval
rb_time_interval(time)
    VALUE time;
{
    return time_timeval(time, Qtrue);
}

struct timeval
rb_time_timeval(time)
    VALUE time;
{
    struct time_object *tobj;
    struct timeval t;

    if (TYPE(time) == T_DATA &amp;&amp; RDATA(time)-&gt;dfree == time_free) {
	GetTimeval(time, tobj);
	t = tobj-&gt;tv;
	return t;
    }
    return time_timeval(time, Qfalse);
}

/*
 *  call-seq:
 *     Time.at( aTime ) =&gt; time
 *     Time.at( seconds [, microseconds] ) =&gt; time
 *  
 *  Creates a new time object with the value given by &lt;i&gt;aTime&lt;/i&gt;, or
 *  the given number of &lt;i&gt;seconds&lt;/i&gt; (and optional
 *  &lt;i&gt;microseconds&lt;/i&gt;) from epoch. A non-portable feature allows the
 *  offset to be negative on some systems.
 *     
 *     Time.at(0)            #=&gt; Wed Dec 31 18:00:00 CST 1969
 *     Time.at(946702800)    #=&gt; Fri Dec 31 23:00:00 CST 1999
 *     Time.at(-284061600)   #=&gt; Sat Dec 31 00:00:00 CST 1960
 */

static VALUE
time_s_at(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    struct timeval tv;
    VALUE time, t;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;time, &amp;t) == 2) {
	tv.tv_sec = NUM2LONG(time);
	tv.tv_usec = NUM2LONG(t);
    }
    else {
	tv = rb_time_timeval(time);
    }
    t = time_new_internal(klass, tv.tv_sec, tv.tv_usec);
    if (TYPE(time) == T_DATA &amp;&amp; RDATA(time)-&gt;dfree == time_free) {
	struct time_object *tobj, *tobj2;

	GetTimeval(time, tobj);
	GetTimeval(t, tobj2);
	tobj2-&gt;gmt = tobj-&gt;gmt;
    }
    return t;
}

static const char months[][4] = {
    &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;,
    &quot;jul&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;,
};

static long
obj2long(obj)
    VALUE obj;
{
    if (TYPE(obj) == T_STRING) {
	obj = rb_str_to_inum(obj, 10, Qfalse);
    }

    return NUM2LONG(obj);
}

static void
time_arg(argc, argv, tm, usec)
    int argc;
    VALUE *argv;
    struct tm *tm;
    time_t *usec;
{
    VALUE v[8];
    int i;
    long year;

    MEMZERO(tm, struct tm, 1);
    *usec = 0;
    if (argc == 10) {
	v[0] = argv[5];
	v[1] = argv[4];
	v[2] = argv[3];
	v[3] = argv[2];
	v[4] = argv[1];
	v[5] = argv[0];
	v[6] = Qnil;
	tm-&gt;tm_isdst = RTEST(argv[8]) ? 1 : 0;
    }
    else {
	rb_scan_args(argc, argv, &quot;17&quot;, &amp;v[0],&amp;v[1],&amp;v[2],&amp;v[3],&amp;v[4],&amp;v[5],&amp;v[6],&amp;v[7]);
	/* v[6] may be usec or zone (parsedate) */
	/* v[7] is wday (parsedate; ignored) */
	tm-&gt;tm_wday = -1;
	tm-&gt;tm_isdst = -1;
    }

    year = obj2long(v[0]);

    if (0 &lt;= year &amp;&amp; year &lt; 39) {
	year += 100;
	rb_warning(&quot;2 digits year is used&quot;);
    }
    else if (69 &lt;= year &amp;&amp; year &lt; 139) {
	rb_warning(&quot;2 or 3 digits year is used&quot;);
    }
    else {
	year -= 1900;
    }

    tm-&gt;tm_year = year;

    if (NIL_P(v[1])) {
	tm-&gt;tm_mon = 0;
    }
    else {
	VALUE s = rb_check_string_type(v[1]);
	if (!NIL_P(s)) {
	    tm-&gt;tm_mon = -1;
	    for (i=0; i&lt;12; i++) {
		if (RSTRING(s)-&gt;len == 3 &amp;&amp;
		    strcasecmp(months[i], RSTRING(s)-&gt;ptr) == 0) {
		    tm-&gt;tm_mon = i;
		    break;
		}
	    }
	    if (tm-&gt;tm_mon == -1) {
		char c = RSTRING(s)-&gt;ptr[0];

		if ('0' &lt;= c &amp;&amp; c &lt;= '9') {
		    tm-&gt;tm_mon = obj2long(s)-1;
		}
	    }
	}
	else {
	    tm-&gt;tm_mon = obj2long(v[1])-1;
	}
    }
    if (NIL_P(v[2])) {
	tm-&gt;tm_mday = 1;
    }
    else {
	tm-&gt;tm_mday = obj2long(v[2]);
    }
    tm-&gt;tm_hour = NIL_P(v[3])?0:obj2long(v[3]);
    tm-&gt;tm_min  = NIL_P(v[4])?0:obj2long(v[4]);
    tm-&gt;tm_sec  = NIL_P(v[5])?0:obj2long(v[5]);
    if (!NIL_P(v[6])) {
	if (argc == 8) {
	    /* v[6] is timezone, but ignored */
	}
	else if (argc == 7) {
	    *usec = obj2long(v[6]);
	}
    }

    /* value validation */
    if (
           tm-&gt;tm_year != year ||
#ifndef NEGATIVE_TIME_T
           tm-&gt;tm_year &lt; 69 ||
#endif
	   tm-&gt;tm_mon  &lt; 0 || tm-&gt;tm_mon  &gt; 11
	|| tm-&gt;tm_mday &lt; 1 || tm-&gt;tm_mday &gt; 31
	|| tm-&gt;tm_hour &lt; 0 || tm-&gt;tm_hour &gt; 23
	|| tm-&gt;tm_min  &lt; 0 || tm-&gt;tm_min  &gt; 59
	|| tm-&gt;tm_sec  &lt; 0 || tm-&gt;tm_sec  &gt; 60)
	rb_raise(rb_eArgError, &quot;argument out of range&quot;);
}

static VALUE time_gmtime _((VALUE));
static VALUE time_localtime _((VALUE));
static VALUE time_get_tm _((VALUE, int));

static int
leap_year_p(y)
    long y;
{
  return ((y % 4 == 0) &amp;&amp; (y % 100 != 0)) || (y % 400 == 0);
}

#define DIV(n,d) ((n)&lt;0 ? NDIV((n),(d)) : (n)/(d))

static time_t
timegm_noleapsecond(tm)
    struct tm *tm;
{
    static int common_year_yday_offset[] = {
        -1,
        -1 + 31,
        -1 + 31 + 28,
        -1 + 31 + 28 + 31,
        -1 + 31 + 28 + 31 + 30,
        -1 + 31 + 28 + 31 + 30 + 31,
        -1 + 31 + 28 + 31 + 30 + 31 + 30,
        -1 + 31 + 28 + 31 + 30 + 31 + 30 + 31,
        -1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
        -1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
        -1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
        -1 + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30
          /* 1    2    3    4    5    6    7    8    9    10   11 */
    };
    static int leap_year_yday_offset[] = {
        -1,
        -1 + 31,
        -1 + 31 + 29,
        -1 + 31 + 29 + 31,
        -1 + 31 + 29 + 31 + 30,
        -1 + 31 + 29 + 31 + 30 + 31,
        -1 + 31 + 29 + 31 + 30 + 31 + 30,
        -1 + 31 + 29 + 31 + 30 + 31 + 30 + 31,
        -1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31,
        -1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
        -1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
        -1 + 31 + 29 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30
          /* 1    2    3    4    5    6    7    8    9    10   11 */
    };

    long tm_year = tm-&gt;tm_year;
    int tm_yday = tm-&gt;tm_mday;
    if (leap_year_p(tm_year + 1900))
        tm_yday += leap_year_yday_offset[tm-&gt;tm_mon];
    else
        tm_yday += common_year_yday_offset[tm-&gt;tm_mon];

    /*
     *  `Seconds Since the Epoch' in SUSv3:
     *  tm_sec + tm_min*60 + tm_hour*3600 + tm_yday*86400 +
     *  (tm_year-70)*31536000 + ((tm_year-69)/4)*86400 -
     *  ((tm_year-1)/100)*86400 + ((tm_year+299)/400)*86400
     */
    return tm-&gt;tm_sec + tm-&gt;tm_min*60 + tm-&gt;tm_hour*3600 +
           (time_t)(tm_yday +
                    (tm_year-70)*365 +
                    DIV(tm_year-69,4) -
                    DIV(tm_year-1,100) +
                    DIV(tm_year+299,400))*86400;
}

static int
tmcmp(a, b)
    struct tm *a;
    struct tm *b;
{
    if (a-&gt;tm_year != b-&gt;tm_year)
        return a-&gt;tm_year &lt; b-&gt;tm_year ? -1 : 1;
    else if (a-&gt;tm_mon != b-&gt;tm_mon)
        return a-&gt;tm_mon &lt; b-&gt;tm_mon ? -1 : 1;
    else if (a-&gt;tm_mday != b-&gt;tm_mday)
        return a-&gt;tm_mday &lt; b-&gt;tm_mday ? -1 : 1;
    else if (a-&gt;tm_hour != b-&gt;tm_hour)
        return a-&gt;tm_hour &lt; b-&gt;tm_hour ? -1 : 1;
    else if (a-&gt;tm_min != b-&gt;tm_min)
        return a-&gt;tm_min &lt; b-&gt;tm_min ? -1 : 1;
    else if (a-&gt;tm_sec != b-&gt;tm_sec)
        return a-&gt;tm_sec &lt; b-&gt;tm_sec ? -1 : 1;
    else
        return 0;
}

#if SIZEOF_TIME_T == SIZEOF_LONG
typedef unsigned long unsigned_time_t;
#elif SIZEOF_TIME_T == SIZEOF_INT
typedef unsigned int unsigned_time_t;
#elif SIZEOF_TIME_T == SIZEOF_LONG_LONG
typedef unsigned LONG_LONG unsigned_time_t;
#else
# error cannot find integer type which size is same as time_t.
#endif

static time_t
search_time_t(tptr, utc_p)
    struct tm *tptr;
    int utc_p;
{
    time_t guess, guess_lo, guess_hi;
    struct tm *tm, tm_lo, tm_hi;
    int d, have_guess;
    int find_dst;

    find_dst = 0 &lt; tptr-&gt;tm_isdst;

#ifdef NEGATIVE_TIME_T
    guess_lo = (time_t)~((unsigned_time_t)~(time_t)0 &gt;&gt; 1);
#else
    guess_lo = 0;
#endif
    guess_hi = ((time_t)-1) &lt; ((time_t)0) ?
	       (time_t)((unsigned_time_t)~(time_t)0 &gt;&gt; 1) :
	       ~(time_t)0;

    guess = timegm_noleapsecond(tptr);
    tm = (utc_p ? gmtime : localtime)(&amp;guess);
    if (tm) {
        d = tmcmp(tptr, tm);
        if (d == 0) return guess;
        if (d &lt; 0) {
            guess_hi = guess;
            guess -= 24 * 60 * 60;
        }
        else {
            guess_lo = guess;
            guess += 24 * 60 * 60;
        }
        if (guess_lo &lt; guess &amp;&amp; guess &lt; guess_hi &amp;&amp;
            (tm = (utc_p ? gmtime : localtime)(&amp;guess)) != NULL) {
            d = tmcmp(tptr, tm);
            if (d == 0) return guess;
            if (d &lt; 0)
                guess_hi = guess;
            else
                guess_lo = guess;
        }
    }

    tm = (utc_p ? gmtime : localtime)(&amp;guess_lo);
    if (!tm) goto error;
    d = tmcmp(tptr, tm);
    if (d &lt; 0) goto out_of_range;
    if (d == 0) return guess_lo;
    tm_lo = *tm;

    tm = (utc_p ? gmtime : localtime)(&amp;guess_hi);
    if (!tm) goto error;
    d = tmcmp(tptr, tm);
    if (d &gt; 0) goto out_of_range;
    if (d == 0) return guess_hi;
    tm_hi = *tm;

    have_guess = 0;

    while (guess_lo + 1 &lt; guess_hi) {
      /* there is a gap between guess_lo and guess_hi. */
      unsigned long range = 0;
      if (!have_guess) {
	int a, b;
	/*
	  Try precious guess by a linear interpolation at first.
	  `a' and `b' is a coefficient of guess_lo and guess_hi as:

	    guess = (guess_lo * a + guess_hi * b) / (a + b)

	  However this causes overflow in most cases, following assignment
	  is used instead:

	    guess = guess_lo / d * a + (guess_lo % d) * a / d
		  + guess_hi / d * b + (guess_hi % d) * b / d
	      where d = a + b

	  To avoid overflow in this assignment, `d' is restricted to less than
	  sqrt(2**31).  By this restriction and other reasons, the guess is
	  not accurate and some error is expected.  `range' approximates 
	  the maximum error.

	  When these parameters are not suitable, i.e. guess is not within
	  guess_lo and guess_hi, simple guess by binary search is used.
	*/
	range = 366 * 24 * 60 * 60;
	a = (tm_hi.tm_year - tptr-&gt;tm_year);
	b = (tptr-&gt;tm_year - tm_lo.tm_year);
	/* 46000 is selected as `some big number less than sqrt(2**31)'. */
	if (a + b &lt;= 46000 / 12) {
	  range = 31 * 24 * 60 * 60;
	  a *= 12;
	  b *= 12;
	  a += tm_hi.tm_mon - tptr-&gt;tm_mon;
	  b += tptr-&gt;tm_mon - tm_lo.tm_mon;
	  if (a + b &lt;= 46000 / 31) {
	    range = 24 * 60 * 60;
	    a *= 31;
	    b *= 31;
	    a += tm_hi.tm_mday - tptr-&gt;tm_mday;
	    b += tptr-&gt;tm_mday - tm_lo.tm_mday;
	    if (a + b &lt;= 46000 / 24) {
	      range = 60 * 60;
	      a *= 24;
	      b *= 24;
	      a += tm_hi.tm_hour - tptr-&gt;tm_hour;
	      b += tptr-&gt;tm_hour - tm_lo.tm_hour;
	      if (a + b &lt;= 46000 / 60) {
		range = 60;
		a *= 60;
		b *= 60;
		a += tm_hi.tm_min - tptr-&gt;tm_min;
		b += tptr-&gt;tm_min - tm_lo.tm_min;
		if (a + b &lt;= 46000 / 60) {
		  range = 1;
		  a *= 60;
		  b *= 60;
		  a += tm_hi.tm_sec - tptr-&gt;tm_sec;
		  b += tptr-&gt;tm_sec - tm_lo.tm_sec;
		}
	      }
	    }
	  }
	}
	if (a &lt;= 0) a = 1;
	if (b &lt;= 0) b = 1;
	d = a + b;
	/*
	  Although `/' and `%' may produce unexpected result with negative
	  argument, it doesn't cause serious problem because there is a
	  fail safe.
	*/
	guess = guess_lo / d * a + (guess_lo % d) * a / d
	      + guess_hi / d * b + (guess_hi % d) * b / d;
	have_guess = 1;
      }

      if (guess &lt;= guess_lo || guess_hi &lt;= guess) {
	/* Precious guess is invalid. try binary search. */ 
	guess = guess_lo / 2 + guess_hi / 2;
	if (guess &lt;= guess_lo)
	  guess = guess_lo + 1;
	else if (guess &gt;= guess_hi)
	  guess = guess_hi - 1;
	range = 0;
      }

      tm = (utc_p ? gmtime : localtime)(&amp;guess);
      if (!tm) goto error;
      have_guess = 0;

      d = tmcmp(tptr, tm);
      if (d &lt; 0) {
        guess_hi = guess;
	tm_hi = *tm;
	if (range) {
	  guess = guess - range;
	  range = 0;
	  if (guess_lo &lt; guess &amp;&amp; guess &lt; guess_hi)
	    have_guess = 1;
	}
      }
      else if (d &gt; 0) {
        guess_lo = guess;
	tm_lo = *tm;
	if (range) {
	  guess = guess + range;
	  range = 0;
	  if (guess_lo &lt; guess &amp;&amp; guess &lt; guess_hi)
	    have_guess = 1;
	}
      }
      else {
	if (!utc_p) {
	  /* If localtime is nonmonotonic, another result may exist. */
	  time_t guess2;
	  if (find_dst) {
	    guess2 = guess - 2 * 60 * 60;
	    tm = localtime(&amp;guess2);
	    if (tm) {
	      if (tptr-&gt;tm_hour != (tm-&gt;tm_hour + 2) % 24 ||
		  tptr-&gt;tm_min != tm-&gt;tm_min ||
		  tptr-&gt;tm_sec != tm-&gt;tm_sec) {
		guess2 -= (tm-&gt;tm_hour - tptr-&gt;tm_hour) * 60 * 60 +
			  (tm-&gt;tm_min - tptr-&gt;tm_min) * 60 +
			  (tm-&gt;tm_sec - tptr-&gt;tm_sec);
		if (tptr-&gt;tm_mday != tm-&gt;tm_mday)
		  guess2 += 24 * 60 * 60;
		if (guess != guess2) {
		  tm = localtime(&amp;guess2);
		  if (tmcmp(tptr, tm) == 0) {
		    if (guess &lt; guess2)
		      return guess;
		    else
		      return guess2;
		  }
		}
	      }
	    }
	  }
	  else {
	    guess2 = guess + 2 * 60 * 60;
	    tm = localtime(&amp;guess2);
	    if (tm) {
	      if ((tptr-&gt;tm_hour + 2) % 24 != tm-&gt;tm_hour ||
		  tptr-&gt;tm_min != tm-&gt;tm_min ||
		  tptr-&gt;tm_sec != tm-&gt;tm_sec) {
		guess2 -= (tm-&gt;tm_hour - tptr-&gt;tm_hour) * 60 * 60 +
			  (tm-&gt;tm_min - tptr-&gt;tm_min) * 60 +
			  (tm-&gt;tm_sec - tptr-&gt;tm_sec);
		if (tptr-&gt;tm_mday != tm-&gt;tm_mday)
		  guess2 -= 24 * 60 * 60;
		if (guess != guess2) {
		  tm = localtime(&amp;guess2);
		  if (tmcmp(tptr, tm) == 0) {
		    if (guess &lt; guess2)
		      return guess2;
		    else
		      return guess;
		  }
		}
	      }
	    }
	  }
	}
	return guess;
      }
    }
    /* Given argument has no corresponding time_t. Let's outerpolation. */
    if (tm_lo.tm_year == tptr-&gt;tm_year &amp;&amp; tm_lo.tm_mon == tptr-&gt;tm_mon) {
      return guess_lo +
        (tptr-&gt;tm_mday - tm_lo.tm_mday) * 24 * 60 * 60 +
        (tptr-&gt;tm_hour - tm_lo.tm_hour) * 60 * 60 +
        (tptr-&gt;tm_min - tm_lo.tm_min) * 60 +
        (tptr-&gt;tm_sec - tm_lo.tm_sec);
    }
    else if (tm_hi.tm_year == tptr-&gt;tm_year &amp;&amp; tm_hi.tm_mon == tptr-&gt;tm_mon) {
      return guess_hi +
        (tptr-&gt;tm_mday - tm_hi.tm_mday) * 24 * 60 * 60 +
        (tptr-&gt;tm_hour - tm_hi.tm_hour) * 60 * 60 +
        (tptr-&gt;tm_min - tm_hi.tm_min) * 60 +
        (tptr-&gt;tm_sec - tm_hi.tm_sec);
    }

  out_of_range:
    rb_raise(rb_eArgError, &quot;time out of range&quot;);

  error:
    rb_raise(rb_eArgError, &quot;gmtime/localtime error&quot;);
    return 0;			/* not reached */
}

static time_t
make_time_t(tptr, utc_p)
    struct tm *tptr;
    int utc_p;
{
    time_t t;
#ifdef NEGATIVE_TIME_T
    struct tm *tmp;
#endif
    struct tm buf;
    buf = *tptr;
    if (utc_p) {
#if defined(HAVE_TIMEGM)
	if ((t = timegm(&amp;buf)) != -1)
            return t;
#ifdef NEGATIVE_TIME_T
        if ((tmp = gmtime(&amp;t)) &amp;&amp;
            tptr-&gt;tm_year == tmp-&gt;tm_year &amp;&amp;
            tptr-&gt;tm_mon == tmp-&gt;tm_mon &amp;&amp;
            tptr-&gt;tm_mday == tmp-&gt;tm_mday &amp;&amp;
            tptr-&gt;tm_hour == tmp-&gt;tm_hour &amp;&amp;
            tptr-&gt;tm_min == tmp-&gt;tm_min &amp;&amp;
            tptr-&gt;tm_sec == tmp-&gt;tm_sec)
            return t;
#endif
#endif
	return search_time_t(&amp;buf, utc_p);
    }
    else {
#if defined(HAVE_MKTIME)
	if ((t = mktime(&amp;buf)) != -1)
            return t;
#ifdef NEGATIVE_TIME_T
        if ((tmp = localtime(&amp;t)) &amp;&amp;
            tptr-&gt;tm_year == tmp-&gt;tm_year &amp;&amp;
            tptr-&gt;tm_mon == tmp-&gt;tm_mon &amp;&amp;
            tptr-&gt;tm_mday == tmp-&gt;tm_mday &amp;&amp;
            tptr-&gt;tm_hour == tmp-&gt;tm_hour &amp;&amp;
            tptr-&gt;tm_min == tmp-&gt;tm_min &amp;&amp;
            tptr-&gt;tm_sec == tmp-&gt;tm_sec)
            return t;
#endif
#endif
	return search_time_t(&amp;buf, utc_p);
    }
}

static VALUE
time_utc_or_local(argc, argv, utc_p, klass)
    int argc;
    VALUE *argv;
    int utc_p;
    VALUE klass;
{
    struct tm tm;
    VALUE time;
    time_t usec;

    time_arg(argc, argv, &amp;tm, &amp;usec);
    time = time_new_internal(klass, make_time_t(&amp;tm, utc_p), usec);
    if (utc_p) return time_gmtime(time);
    return time_localtime(time);
}

/*
 *  call-seq:
 *     Time.utc( year [, month, day, hour, min, sec, usec] ) =&gt; time
 *     Time.utc( sec, min, hour, day, month, year, wday, yday, isdst, tz
 *     ) =&gt; time
 *     Time.gm( year [, month, day, hour, min, sec, usec] ) =&gt; time
 *     Time.gm( sec, min, hour, day, month, year, wday, yday, isdst, tz
 *     ) =&gt; time
 *     
 *  Creates a time based on given values, interpreted as UTC (GMT). The
 *  year must be specified. Other values default to the minimum value
 *  for that field (and may be &lt;code&gt;nil&lt;/code&gt; or omitted). Months may
 *  be specified by numbers from 1 to 12, or by the three-letter English
 *  month names. Hours are specified on a 24-hour clock (0..23). Raises
 *  an &lt;code&gt;ArgumentError&lt;/code&gt; if any values are out of range. Will
 *  also accept ten arguments in the order output by
 *  &lt;code&gt;Time#to_a&lt;/code&gt;.
 *
 *     Time.utc(2000,&quot;jan&quot;,1,20,15,1)  #=&gt; Sat Jan 01 20:15:01 UTC 2000
 *     Time.gm(2000,&quot;jan&quot;,1,20,15,1)   #=&gt; Sat Jan 01 20:15:01 UTC 2000
 */
static VALUE
time_s_mkutc(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return time_utc_or_local(argc, argv, Qtrue, klass);
}

/*
 *  call-seq:
 *     Time.local( year [, month, day, hour, min, sec, usec] ) =&gt; time
 *     Time.local( sec, min, hour, day, month, year, wday, yday, isdst,
 *     tz ) =&gt; time
 *     Time.mktime( year, month, day, hour, min, sec, usec )   =&gt; time
 *  
 *  Same as &lt;code&gt;Time::gm&lt;/code&gt;, but interprets the values in the
 *  local time zone.
 *     
 *     Time.local(2000,&quot;jan&quot;,1,20,15,1)   #=&gt; Sat Jan 01 20:15:01 CST 2000
 */

static VALUE
time_s_mktime(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    return time_utc_or_local(argc, argv, Qfalse, klass);
}

/*
 *  call-seq:
 *     time.to_i   =&gt; int
 *     time.tv_sec =&gt; int
 *  
 *  Returns the value of &lt;i&gt;time&lt;/i&gt; as an integer number of seconds
 *  since epoch.
 *     
 *     t = Time.now
 *     &quot;%10.5f&quot; % t.to_f   #=&gt; &quot;1049896564.17839&quot;
 *     t.to_i              #=&gt; 1049896564
 */

static VALUE
time_to_i(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return LONG2NUM(tobj-&gt;tv.tv_sec);
}

/*
 *  call-seq:
 *     time.to_f =&gt; float
 *  
 *  Returns the value of &lt;i&gt;time&lt;/i&gt; as a floating point number of
 *  seconds since epoch.
 *     
 *     t = Time.now
 *     &quot;%10.5f&quot; % t.to_f   #=&gt; &quot;1049896564.13654&quot;
 *     t.to_i              #=&gt; 1049896564
 */

static VALUE
time_to_f(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return rb_float_new((double)tobj-&gt;tv.tv_sec+(double)tobj-&gt;tv.tv_usec/1e6);
}

/*
 *  call-seq:
 *     time.usec    =&gt; int
 *     time.tv_usec =&gt; int
 *  
 *  Returns just the number of microseconds for &lt;i&gt;time&lt;/i&gt;.
 *     
 *     t = Time.now        #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     &quot;%10.6f&quot; % t.to_f   #=&gt; &quot;1049896564.259970&quot;
 *     t.usec              #=&gt; 259970
 */

static VALUE
time_usec(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    return LONG2NUM(tobj-&gt;tv.tv_usec);
}

/*
 *  call-seq:
 *     time &lt;=&gt; other_time =&gt; -1, 0, +1 
 *     time &lt;=&gt; numeric    =&gt; -1, 0, +1
 *  
 *  Comparison---Compares &lt;i&gt;time&lt;/i&gt; with &lt;i&gt;other_time&lt;/i&gt; or with
 *  &lt;i&gt;numeric&lt;/i&gt;, which is the number of seconds (possibly
 *  fractional) since epoch.
 *     
 *     t = Time.now       #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t2 = t + 2592000   #=&gt; Fri May 09 08:56:03 CDT 2003
 *     t &lt;=&gt; t2           #=&gt; -1
 *     t2 &lt;=&gt; t           #=&gt; 1
 *     t &lt;=&gt; t            #=&gt; 0
 */

static VALUE
time_cmp(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj1, *tobj2;

    GetTimeval(time1, tobj1);
    if (TYPE(time2) == T_DATA &amp;&amp; RDATA(time2)-&gt;dfree == time_free) {
	GetTimeval(time2, tobj2);
	if (tobj1-&gt;tv.tv_sec == tobj2-&gt;tv.tv_sec) {
	    if (tobj1-&gt;tv.tv_usec == tobj2-&gt;tv.tv_usec) return INT2FIX(0);
	    if (tobj1-&gt;tv.tv_usec &gt; tobj2-&gt;tv.tv_usec) return INT2FIX(1);
	    return INT2FIX(-1);
	}
	if (tobj1-&gt;tv.tv_sec &gt; tobj2-&gt;tv.tv_sec) return INT2FIX(1);
	return INT2FIX(-1);
    }

    return Qnil;
}

/*
 * call-seq:
 *  time.eql?(other_time)
 *
 * Return &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;time&lt;/i&gt; and &lt;i&gt;other_time&lt;/i&gt; are
 * both &lt;code&gt;Time&lt;/code&gt; objects with the same seconds and fractional
 * seconds.
 */

static VALUE
time_eql(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj1, *tobj2;

    GetTimeval(time1, tobj1);
    if (TYPE(time2) == T_DATA &amp;&amp; RDATA(time2)-&gt;dfree == time_free) {
	GetTimeval(time2, tobj2);
	if (tobj1-&gt;tv.tv_sec == tobj2-&gt;tv.tv_sec) {
	    if (tobj1-&gt;tv.tv_usec == tobj2-&gt;tv.tv_usec) return Qtrue;
	}
    }
    return Qfalse;
}

/*
 *  call-seq:
 *     time.utc? =&gt; true or false
 *     time.gmt? =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;time&lt;/i&gt; represents a time in UTC
 *  (GMT).
 *     
 *     t = Time.now                        #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     t.utc?                              #=&gt; false
 *     t = Time.gm(2000,&quot;jan&quot;,1,20,15,1)   #=&gt; Sat Jan 01 20:15:01 UTC 2000
 *     t.utc?                              #=&gt; true
 *
 *     t = Time.now                        #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t.gmt?                              #=&gt; false
 *     t = Time.gm(2000,1,1,20,15,1)       #=&gt; Sat Jan 01 20:15:01 UTC 2000
 *     t.gmt?                              #=&gt; true
 */

static VALUE
time_utc_p(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;gmt) return Qtrue;
    return Qfalse;
}

/*
 * call-seq:
 *   time.hash   =&gt; fixnum
 *
 * Return a hash code for this time object.
 */

static VALUE
time_hash(time)
    VALUE time;
{
    struct time_object *tobj;
    long hash;

    GetTimeval(time, tobj);
    hash = tobj-&gt;tv.tv_sec ^ tobj-&gt;tv.tv_usec;
    return LONG2FIX(hash);
}

/* :nodoc: */
static VALUE
time_init_copy(copy, time)
    VALUE copy, time;
{
    struct time_object *tobj, *tcopy;

    if (copy == time) return copy;
    time_modify(copy);
    if (TYPE(time) != T_DATA || RDATA(time)-&gt;dfree != time_free) {
	rb_raise(rb_eTypeError, &quot;wrong argument type&quot;);
    }
    GetTimeval(time, tobj);
    GetTimeval(copy, tcopy);
    MEMCPY(tcopy, tobj, struct time_object, 1);

    return copy;
}

static VALUE
time_dup(time)
    VALUE time;
{
    VALUE dup = time_s_alloc(CLASS_OF(time));
    time_init_copy(dup, time);
    return dup;
}

/*
 *  call-seq:
 *     time.localtime =&gt; time
 *  
 *  Converts &lt;i&gt;time&lt;/i&gt; to local time (using the local time zone in
 *  effect for this process) modifying the receiver.
 *     
 *     t = Time.gm(2000, &quot;jan&quot;, 1, 20, 15, 1)
 *     t.gmt?        #=&gt; true
 *     t.localtime   #=&gt; Sat Jan 01 14:15:01 CST 2000
 *     t.gmt?        #=&gt; false
 */

static VALUE
time_localtime(time)
    VALUE time;
{
    struct time_object *tobj;
    struct tm *tm_tmp;
    time_t t;

    GetTimeval(time, tobj);
    if (!tobj-&gt;gmt) {
	if (tobj-&gt;tm_got)
	    return time;
    }
    else {
	time_modify(time);
    }
    t = tobj-&gt;tv.tv_sec;
    tm_tmp = localtime(&amp;t);
    if (!tm_tmp)
	rb_raise(rb_eArgError, &quot;localtime error&quot;);
    tobj-&gt;tm = *tm_tmp;
    tobj-&gt;tm_got = 1;
    tobj-&gt;gmt = 0;
    return time;
}

/*
 *  call-seq:
 *     time.gmtime    =&gt; time
 *     time.utc       =&gt; time
 *  
 *  Converts &lt;i&gt;time&lt;/i&gt; to UTC (GMT), modifying the receiver.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t.gmt?         #=&gt; false
 *     t.gmtime       #=&gt; Wed Apr 09 13:56:03 UTC 2003
 *     t.gmt?         #=&gt; true
 *
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     t.utc?         #=&gt; false
 *     t.utc          #=&gt; Wed Apr 09 13:56:04 UTC 2003
 *     t.utc?         #=&gt; true
 */

static VALUE
time_gmtime(time)
    VALUE time;
{
    struct time_object *tobj;
    struct tm *tm_tmp;
    time_t t;

    GetTimeval(time, tobj);
    if (tobj-&gt;gmt) {
	if (tobj-&gt;tm_got)
	    return time;
    }
    else {
	time_modify(time);
    }
    t = tobj-&gt;tv.tv_sec;
    tm_tmp = gmtime(&amp;t);
    if (!tm_tmp)
	rb_raise(rb_eArgError, &quot;gmtime error&quot;);
    tobj-&gt;tm = *tm_tmp;
    tobj-&gt;tm_got = 1;
    tobj-&gt;gmt = 1;
    return time;
}

/*
 *  call-seq:
 *     time.getlocal =&gt; new_time
 *  
 *  Returns a new &lt;code&gt;new_time&lt;/code&gt; object representing &lt;i&gt;time&lt;/i&gt; in
 *  local time (using the local time zone in effect for this process).
 *     
 *     t = Time.gm(2000,1,1,20,15,1)   #=&gt; Sat Jan 01 20:15:01 UTC 2000
 *     t.gmt?                          #=&gt; true
 *     l = t.getlocal                  #=&gt; Sat Jan 01 14:15:01 CST 2000
 *     l.gmt?                          #=&gt; false
 *     t == l                          #=&gt; true
 */

static VALUE
time_getlocaltime(time)
    VALUE time;
{
    return time_localtime(time_dup(time));
}

/*
 *  call-seq:
 *     time.getgm  =&gt; new_time
 *     time.getutc =&gt; new_time
 *  
 *  Returns a new &lt;code&gt;new_time&lt;/code&gt; object representing &lt;i&gt;time&lt;/i&gt; in
 *  UTC.
 *     
 *     t = Time.local(2000,1,1,20,15,1)   #=&gt; Sat Jan 01 20:15:01 CST 2000
 *     t.gmt?                             #=&gt; false
 *     y = t.getgm                        #=&gt; Sun Jan 02 02:15:01 UTC 2000
 *     y.gmt?                             #=&gt; true
 *     t == y                             #=&gt; true
 */

static VALUE
time_getgmtime(time)
    VALUE time;
{
    return time_gmtime(time_dup(time));
}

static VALUE
time_get_tm(time, gmt)
    VALUE time;
    int gmt;
{
    if (gmt) return time_gmtime(time);
    return time_localtime(time);
}

/*
 *  call-seq:
 *     time.asctime =&gt; string
 *     time.ctime   =&gt; string
 *  
 *  Returns a canonical string representation of &lt;i&gt;time&lt;/i&gt;.
 *     
 *     Time.now.asctime   #=&gt; &quot;Wed Apr  9 08:56:03 2003&quot;
 */

static VALUE
time_asctime(time)
    VALUE time;
{
    struct time_object *tobj;
    char *s;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    s = asctime(&amp;tobj-&gt;tm);
    if (s[24] == '\n') s[24] = '\0';

    return rb_str_new2(s);
}

/*
 *  call-seq:
 *     time.inspect =&gt; string
 *     time.to_s    =&gt; string
 *  
 *  Returns a string representing &lt;i&gt;time&lt;/i&gt;. Equivalent to calling
 *  &lt;code&gt;Time#strftime&lt;/code&gt; with a format string of ``&lt;code&gt;%a&lt;/code&gt;
 *  &lt;code&gt;%b&lt;/code&gt; &lt;code&gt;%d&lt;/code&gt; &lt;code&gt;%H:%M:%S&lt;/code&gt;
 *  &lt;code&gt;%Z&lt;/code&gt; &lt;code&gt;%Y&lt;/code&gt;''.
 *     
 *     Time.now.to_s   #=&gt; &quot;Wed Apr 09 08:56:04 CDT 2003&quot;
 */

static VALUE
time_to_s(time)
    VALUE time;
{
    struct time_object *tobj;
    char buf[128];
    int len;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    if (tobj-&gt;gmt == 1) {
	len = strftime(buf, 128, &quot;%a %b %d %H:%M:%S UTC %Y&quot;, &amp;tobj-&gt;tm);
    }
    else {
	time_t off;
	char buf2[32];
	char sign = '+';
#if defined(HAVE_STRUCT_TM_TM_GMTOFF)
	off = tobj-&gt;tm.tm_gmtoff;
#else
	VALUE tmp = time_utc_offset(time);
	off = NUM2INT(tmp);
#endif
	if (off &lt; 0) {
	    sign = '-';
	    off = -off;
	}
	sprintf(buf2, &quot;%%a %%b %%d %%H:%%M:%%S %c%02d%02d %%Y&quot;,
		sign, (int)(off/3600), (int)(off%3600/60));
	len = strftime(buf, 128, buf2, &amp;tobj-&gt;tm);
    }
    return rb_str_new(buf, len);
}

static VALUE
time_add(tobj, offset, sign)
    struct time_object *tobj;
    VALUE offset;
    int sign;
{
    double v = NUM2DBL(offset);
    double f, d;
    unsigned_time_t sec_off;
    time_t usec_off, sec, usec;
    VALUE result;

    if (v &lt; 0) {
        v = -v;
        sign = -sign;
    }
    d = modf(v, &amp;f);
    sec_off = (unsigned_time_t)f;
    if (f != (double)sec_off)
        rb_raise(rb_eRangeError, &quot;time %s %f out of Time range&quot;,
            sign &lt; 0 ? &quot;-&quot; : &quot;+&quot;, v);
    usec_off = (time_t)(d*1e6+0.5);

    if (sign &lt; 0) {
        sec = tobj-&gt;tv.tv_sec - sec_off;
        usec = tobj-&gt;tv.tv_usec - usec_off;
        if (sec &gt; tobj-&gt;tv.tv_sec)
            rb_raise(rb_eRangeError, &quot;time - %f out of Time range&quot;, v);
    }
    else {
        sec = tobj-&gt;tv.tv_sec + sec_off;
        usec = tobj-&gt;tv.tv_usec + usec_off;
        if (sec &lt; tobj-&gt;tv.tv_sec)
            rb_raise(rb_eRangeError, &quot;time + %f out of Time range&quot;, v);
    }
    result = rb_time_new(sec, usec);
    if (tobj-&gt;gmt) {
	GetTimeval(result, tobj);
	tobj-&gt;gmt = 1;
    }
    return result;
}

/*
 *  call-seq:
 *     time + numeric =&gt; time
 *  
 *  Addition---Adds some number of seconds (possibly fractional) to
 *  &lt;i&gt;time&lt;/i&gt; and returns that value as a new time.
 *     
 *     t = Time.now         #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t + (60 * 60 * 24)   #=&gt; Thu Apr 10 08:56:03 CDT 2003
 */

static VALUE
time_plus(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj;
    GetTimeval(time1, tobj);

    if (TYPE(time2) == T_DATA &amp;&amp; RDATA(time2)-&gt;dfree == time_free) {
	rb_raise(rb_eTypeError, &quot;time + time?&quot;);
    }
    return time_add(tobj, time2, 1);
}

/*
 *  call-seq:
 *     time - other_time =&gt; float
 *     time - numeric    =&gt; time
 *  
 *  Difference---Returns a new time that represents the difference
 *  between two times, or subtracts the given number of seconds in
 *  &lt;i&gt;numeric&lt;/i&gt; from &lt;i&gt;time&lt;/i&gt;.
 *     
 *     t = Time.now       #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t2 = t + 2592000   #=&gt; Fri May 09 08:56:03 CDT 2003
 *     t2 - t             #=&gt; 2592000.0
 *     t2 - 2592000       #=&gt; Wed Apr 09 08:56:03 CDT 2003
 */

static VALUE
time_minus(time1, time2)
    VALUE time1, time2;
{
    struct time_object *tobj;

    GetTimeval(time1, tobj);
    if (TYPE(time2) == T_DATA &amp;&amp; RDATA(time2)-&gt;dfree == time_free) {
	struct time_object *tobj2;
        double f;

	GetTimeval(time2, tobj2);
	f = (double)tobj-&gt;tv.tv_sec - (double)tobj2-&gt;tv.tv_sec;
	f += ((double)tobj-&gt;tv.tv_usec - (double)tobj2-&gt;tv.tv_usec)*1e-6;
	/* XXX: should check float overflow on 64bit time_t platforms */

	return rb_float_new(f);
    }
    return time_add(tobj, time2, -1);
}

/*
 * call-seq:
 *   time.succ   =&gt; new_time
 *
 * Return a new time object, one second later than &lt;code&gt;time&lt;/code&gt;.
 */

static VALUE
time_succ(time)
    VALUE time;
{
    struct time_object *tobj;
    int gmt;

    GetTimeval(time, tobj);
    gmt = tobj-&gt;gmt;
    time = rb_time_new(tobj-&gt;tv.tv_sec + 1, tobj-&gt;tv.tv_usec);
    GetTimeval(time, tobj);
    tobj-&gt;gmt = gmt;
    return time;
}

/*
 *  call-seq:
 *     time.sec =&gt; fixnum
 *  
 *  Returns the second of the minute (0..60)&lt;em&gt;[Yes, seconds really can
 *  range from zero to 60. This allows the system to inject leap seconds
 *  every now and then to correct for the fact that years are not really
 *  a convenient number of hours long.]&lt;/em&gt; for &lt;i&gt;time&lt;/i&gt;.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     t.sec          #=&gt; 4
 */

static VALUE
time_sec(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return INT2FIX(tobj-&gt;tm.tm_sec);
}

/*
 *  call-seq:
 *     time.min =&gt; fixnum
 *  
 *  Returns the minute of the hour (0..59) for &lt;i&gt;time&lt;/i&gt;.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t.min          #=&gt; 56
 */

static VALUE
time_min(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return INT2FIX(tobj-&gt;tm.tm_min);
}

/*
 *  call-seq:
 *     time.hour =&gt; fixnum
 *  
 *  Returns the hour of the day (0..23) for &lt;i&gt;time&lt;/i&gt;.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t.hour         #=&gt; 8
 */

static VALUE
time_hour(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return INT2FIX(tobj-&gt;tm.tm_hour);
}

/*
 *  call-seq:
 *     time.day  =&gt; fixnum
 *     time.mday =&gt; fixnum
 *  
 *  Returns the day of the month (1..n) for &lt;i&gt;time&lt;/i&gt;.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t.day          #=&gt; 9
 *     t.mday         #=&gt; 9
 */

static VALUE
time_mday(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return INT2FIX(tobj-&gt;tm.tm_mday);
}

/*
 *  call-seq:
 *     time.mon   =&gt; fixnum
 *     time.month =&gt; fixnum
 *  
 *  Returns the month of the year (1..12) for &lt;i&gt;time&lt;/i&gt;.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:03 CDT 2003
 *     t.mon          #=&gt; 4
 *     t.month        #=&gt; 4
 */

static VALUE
time_mon(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return INT2FIX(tobj-&gt;tm.tm_mon+1);
}

/*
 *  call-seq:
 *     time.year =&gt; fixnum
 *  
 *  Returns the year for &lt;i&gt;time&lt;/i&gt; (including the century).
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     t.year         #=&gt; 2003
 */

static VALUE
time_year(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return LONG2NUM((long)tobj-&gt;tm.tm_year+1900);
}

/*
 *  call-seq:
 *     time.wday =&gt; fixnum
 *  
 *  Returns an integer representing the day of the week, 0..6, with
 *  Sunday == 0.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     t.wday         #=&gt; 3
 */

static VALUE
time_wday(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return INT2FIX(tobj-&gt;tm.tm_wday);
}

/*
 *  call-seq:
 *     time.yday =&gt; fixnum
 *  
 *  Returns an integer representing the day of the year, 1..366.
 *     
 *     t = Time.now   #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     t.yday         #=&gt; 99
 */

static VALUE
time_yday(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return INT2FIX(tobj-&gt;tm.tm_yday+1);
}

/*
 *  call-seq:
 *     time.isdst =&gt; true or false
 *     time.dst?  =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;time&lt;/i&gt; occurs during Daylight
 *  Saving Time in its time zone.
 *     
 *     Time.local(2000, 7, 1).isdst   #=&gt; true
 *     Time.local(2000, 1, 1).isdst   #=&gt; false
 *     Time.local(2000, 7, 1).dst?    #=&gt; true
 *     Time.local(2000, 1, 1).dst?    #=&gt; false
 */

static VALUE
time_isdst(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return tobj-&gt;tm.tm_isdst?Qtrue:Qfalse;
}

/*
 *  call-seq:
 *     time.zone =&gt; string
 *  
 *  Returns the name of the time zone used for &lt;i&gt;time&lt;/i&gt;. As of Ruby
 *  1.8, returns ``UTC'' rather than ``GMT'' for UTC times.
 *     
 *     t = Time.gm(2000, &quot;jan&quot;, 1, 20, 15, 1)
 *     t.zone   #=&gt; &quot;UTC&quot;
 *     t = Time.local(2000, &quot;jan&quot;, 1, 20, 15, 1)
 *     t.zone   #=&gt; &quot;CST&quot;
 */

static VALUE
time_zone(time)
    VALUE time;
{
    struct time_object *tobj;
#if !defined(HAVE_TM_ZONE) &amp;&amp; (!defined(HAVE_TZNAME) || !defined(HAVE_DAYLIGHT))
    char buf[64];
    int len;
#endif
    
    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }

    if (tobj-&gt;gmt == 1) {
	return rb_str_new2(&quot;UTC&quot;);
    }
#if defined(HAVE_TM_ZONE)
    return rb_str_new2(tobj-&gt;tm.tm_zone);
#elif defined(HAVE_TZNAME) &amp;&amp; defined(HAVE_DAYLIGHT)
    return rb_str_new2(tzname[daylight &amp;&amp; tobj-&gt;tm.tm_isdst]);
#else
    len = strftime(buf, 64, &quot;%Z&quot;, &amp;tobj-&gt;tm);
    return rb_str_new(buf, len);
#endif
}

/*
 *  call-seq:
 *     time.gmt_offset =&gt; fixnum
 *     time.gmtoff     =&gt; fixnum
 *     time.utc_offset =&gt; fixnum
 *  
 *  Returns the offset in seconds between the timezone of &lt;i&gt;time&lt;/i&gt;
 *  and UTC.
 *     
 *     t = Time.gm(2000,1,1,20,15,1)   #=&gt; Sat Jan 01 20:15:01 UTC 2000
 *     t.gmt_offset                    #=&gt; 0
 *     l = t.getlocal                  #=&gt; Sat Jan 01 14:15:01 CST 2000
 *     l.gmt_offset                    #=&gt; -21600
 */

static VALUE
time_utc_offset(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }

    if (tobj-&gt;gmt == 1) {
	return INT2FIX(0);
    }
    else {
#if defined(HAVE_STRUCT_TM_TM_GMTOFF)
	return INT2NUM(tobj-&gt;tm.tm_gmtoff);
#else
	struct tm *u, *l;
	time_t t;
	long off;
	l = &amp;tobj-&gt;tm;
	t = tobj-&gt;tv.tv_sec;
	u = gmtime(&amp;t);
	if (!u)
	    rb_raise(rb_eArgError, &quot;gmtime error&quot;);
	if (l-&gt;tm_year != u-&gt;tm_year)
	    off = l-&gt;tm_year &lt; u-&gt;tm_year ? -1 : 1;
	else if (l-&gt;tm_mon != u-&gt;tm_mon)
	    off = l-&gt;tm_mon &lt; u-&gt;tm_mon ? -1 : 1;
	else if (l-&gt;tm_mday != u-&gt;tm_mday)
	    off = l-&gt;tm_mday &lt; u-&gt;tm_mday ? -1 : 1;
	else
	    off = 0;
	off = off * 24 + l-&gt;tm_hour - u-&gt;tm_hour;
	off = off * 60 + l-&gt;tm_min - u-&gt;tm_min;
	off = off * 60 + l-&gt;tm_sec - u-&gt;tm_sec;
	return LONG2FIX(off);
#endif
    }
}

/*
 *  call-seq:
 *     time.to_a =&gt; array
 *  
 *  Returns a ten-element &lt;i&gt;array&lt;/i&gt; of values for &lt;i&gt;time&lt;/i&gt;:
 *  {&lt;code&gt;[ sec, min, hour, day, month, year, wday, yday, isdst, zone
 *  ]&lt;/code&gt;}. See the individual methods for an explanation of the
 *  valid ranges of each value. The ten elements can be passed directly
 *  to &lt;code&gt;Time::utc&lt;/code&gt; or &lt;code&gt;Time::local&lt;/code&gt; to create a
 *  new &lt;code&gt;Time&lt;/code&gt;.
 *     
 *     now = Time.now   #=&gt; Wed Apr 09 08:56:04 CDT 2003
 *     t = now.to_a     #=&gt; [4, 56, 8, 9, 4, 2003, 3, 99, true, &quot;CDT&quot;]
 */

static VALUE
time_to_a(time)
    VALUE time;
{
    struct time_object *tobj;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    return rb_ary_new3(10,
		    INT2FIX(tobj-&gt;tm.tm_sec),
		    INT2FIX(tobj-&gt;tm.tm_min),
		    INT2FIX(tobj-&gt;tm.tm_hour),
		    INT2FIX(tobj-&gt;tm.tm_mday),
		    INT2FIX(tobj-&gt;tm.tm_mon+1),
		    LONG2NUM((long)tobj-&gt;tm.tm_year+1900),
		    INT2FIX(tobj-&gt;tm.tm_wday),
		    INT2FIX(tobj-&gt;tm.tm_yday+1),
		    tobj-&gt;tm.tm_isdst?Qtrue:Qfalse,
		    time_zone(time));
}

#define SMALLBUF 100
static int
rb_strftime(buf, format, time)
    char **buf;
    const char *format;
    struct tm *time;
{
    int size, len, flen;

    (*buf)[0] = '\0';
    flen = strlen(format);
    if (flen == 0) {
	return 0;
    }
    errno = 0;
    len = strftime(*buf, SMALLBUF, format, time);
    if (len != 0 || (**buf == '\0' &amp;&amp; errno != ERANGE)) return len;
    for (size=1024; ; size*=2) {
	*buf = xmalloc(size);
	(*buf)[0] = '\0';
	len = strftime(*buf, size, format, time);
	/*
	 * buflen can be zero EITHER because there's not enough
	 * room in the string, or because the control command
	 * goes to the empty string. Make a reasonable guess that
	 * if the buffer is 1024 times bigger than the length of the
	 * format string, it's not failing for lack of room.
	 */
	if (len &gt; 0 || size &gt;= 1024 * flen) return len;
	free(*buf);
    }
    /* not reached */
}

/*
 *  call-seq:
 *     time.strftime( string ) =&gt; string
 *  
 *  Formats &lt;i&gt;time&lt;/i&gt; according to the directives in the given format
 *  string. Any text not listed as a directive will be passed through
 *  to the output string.
 *
 *  Format meaning:
 *    %a - The abbreviated weekday name (``Sun'')
 *    %A - The  full  weekday  name (``Sunday'')
 *    %b - The abbreviated month name (``Jan'')
 *    %B - The  full  month  name (``January'')
 *    %c - The preferred local date and time representation
 *    %d - Day of the month (01..31)
 *    %H - Hour of the day, 24-hour clock (00..23)
 *    %I - Hour of the day, 12-hour clock (01..12)
 *    %j - Day of the year (001..366)
 *    %m - Month of the year (01..12)
 *    %M - Minute of the hour (00..59)
 *    %p - Meridian indicator (``AM''  or  ``PM'')
 *    %S - Second of the minute (00..60)
 *    %U - Week  number  of the current year,
 *            starting with the first Sunday as the first
 *            day of the first week (00..53)
 *    %W - Week  number  of the current year,
 *            starting with the first Monday as the first
 *            day of the first week (00..53)
 *    %w - Day of the week (Sunday is 0, 0..6)
 *    %x - Preferred representation for the date alone, no time
 *    %X - Preferred representation for the time alone, no date
 *    %y - Year without a century (00..99)
 *    %Y - Year with century
 *    %Z - Time zone name
 *    %% - Literal ``%'' character
 *     
 *     t = Time.now
 *     t.strftime(&quot;Printed on %m/%d/%Y&quot;)   #=&gt; &quot;Printed on 04/09/2003&quot;
 *     t.strftime(&quot;at %I:%M%p&quot;)            #=&gt; &quot;at 08:56AM&quot;
 */

static VALUE
time_strftime(time, format)
    VALUE time, format;
{
    struct time_object *tobj;
    char buffer[SMALLBUF], *buf = buffer;
    const char *fmt;
    long len;
    VALUE str;

    GetTimeval(time, tobj);
    if (tobj-&gt;tm_got == 0) {
	time_get_tm(time, tobj-&gt;gmt);
    }
    StringValue(format);
    format = rb_str_new4(format);
    fmt = RSTRING(format)-&gt;ptr;
    len = RSTRING(format)-&gt;len;
    if (len == 0) {
	rb_warning(&quot;strftime called with empty format string&quot;);
    }
    else if (strlen(fmt) &lt; len) {
	/* Ruby string may contain \0's. */
	const char *p = fmt, *pe = fmt + len;

	str = rb_str_new(0, 0);
	while (p &lt; pe) {
	    len = rb_strftime(&amp;buf, p, &amp;tobj-&gt;tm);
	    rb_str_cat(str, buf, len);
	    p += strlen(p);
	    if (buf != buffer) {
		free(buf);
		buf = buffer;
	    }
	    for (fmt = p; p &lt; pe &amp;&amp; !*p; ++p);
	    if (p &gt; fmt) rb_str_cat(str, fmt, p - fmt);
	}
	return str;
    }
    else {
	len = rb_strftime(&amp;buf, RSTRING(format)-&gt;ptr, &amp;tobj-&gt;tm);
    }
    str = rb_str_new(buf, len);
    if (buf != buffer) free(buf);
    return str;
}

/*
 *  call-seq:
 *     Time.times =&gt; struct_tms
 *  
 *  Deprecated in favor of &lt;code&gt;Process::times&lt;/code&gt;
 */

static VALUE
time_s_times(obj)
    VALUE obj;
{
    rb_warn(&quot;obsolete method Time::times; use Process::times&quot;);
    return rb_proc_times(obj);
}

/*
 * undocumented
 */

static VALUE
time_mdump(time)
    VALUE time;
{
    struct time_object *tobj;
    struct tm *tm;
    unsigned long p, s;
    char buf[8];
    time_t t;
    int i;

    GetTimeval(time, tobj);

    t = tobj-&gt;tv.tv_sec;
    tm = gmtime(&amp;t);

    if ((tm-&gt;tm_year &amp; 0xffff) != tm-&gt;tm_year)
	rb_raise(rb_eArgError, &quot;year too big to marshal&quot;);

    p = 0x1UL        &lt;&lt; 31 | /*  1 */
	tm-&gt;tm_year  &lt;&lt; 14 | /* 16 */
	tm-&gt;tm_mon   &lt;&lt; 10 | /*  4 */
	tm-&gt;tm_mday  &lt;&lt;  5 | /*  5 */
	tm-&gt;tm_hour;         /*  5 */
    s = tm-&gt;tm_min   &lt;&lt; 26 | /*  6 */
	tm-&gt;tm_sec   &lt;&lt; 20 | /*  6 */
	tobj-&gt;tv.tv_usec;    /* 20 */

    for (i=0; i&lt;4; i++) {
	buf[i] = p &amp; 0xff;
	p = RSHIFT(p, 8);
    }
    for (i=4; i&lt;8; i++) {
	buf[i] = s &amp; 0xff;
	s = RSHIFT(s, 8);
    }

    return rb_str_new(buf, 8);
}

/*
 * call-seq:
 *   time._dump   =&gt; string
 *
 * Dump _time_ for marshaling.
 */

static VALUE
time_dump(argc, argv, time)
    int argc;
    VALUE *argv;
    VALUE time;
{
    VALUE str;

    rb_scan_args(argc, argv, &quot;01&quot;, 0);
    str = time_mdump(time); 
    if (FL_TEST(time, FL_EXIVAR)) {
	rb_copy_generic_ivar(str, time);
	FL_SET(str, FL_EXIVAR);
    }

    return str;
}

/*
 * undocumented
 */

static VALUE
time_mload(time, str)
    VALUE time, str;
{
    struct time_object *tobj;
    unsigned long p, s;
    time_t sec, usec;
    unsigned char *buf;
    struct tm tm;
    int i;

    time_modify(time);
    StringValue(str);
    buf = (unsigned char *)RSTRING(str)-&gt;ptr;
    if (RSTRING(str)-&gt;len != 8) {
	rb_raise(rb_eTypeError, &quot;marshaled time format differ&quot;);
    }

    p = s = 0;
    for (i=0; i&lt;4; i++) {
	p |= buf[i]&lt;&lt;(8*i);
    }
    for (i=4; i&lt;8; i++) {
	s |= buf[i]&lt;&lt;(8*(i-4));
    }

    if ((p &amp; (1UL&lt;&lt;31)) == 0) {
	sec = p;
	usec = s;
    }
    else {
       p &amp;= ~(1UL&lt;&lt;31);
	tm.tm_year = (p &gt;&gt; 14) &amp; 0xffff;
	tm.tm_mon  = (p &gt;&gt; 10) &amp; 0xf;
	tm.tm_mday = (p &gt;&gt;  5) &amp; 0x1f;
	tm.tm_hour =  p        &amp; 0x1f;
	tm.tm_min  = (s &gt;&gt; 26) &amp; 0x3f;
	tm.tm_sec  = (s &gt;&gt; 20) &amp; 0x3f;
	tm.tm_isdst = 0;

	sec = make_time_t(&amp;tm, Qtrue);
	usec = (time_t)(s &amp; 0xfffff);
    }
    time_overflow_p(&amp;sec, &amp;usec);

    GetTimeval(time, tobj);
    tobj-&gt;tm_got = 0;
    tobj-&gt;tv.tv_sec = sec;
    tobj-&gt;tv.tv_usec = usec;
    return time;
}

/*
 * call-seq:
 *   Time._load(string)   =&gt; time
 *
 * Unmarshal a dumped +Time+ object.
 */

static VALUE
time_load(klass, str)
    VALUE klass, str;
{
    VALUE time = time_s_alloc(klass);

    if (FL_TEST(str, FL_EXIVAR)) {
	rb_copy_generic_ivar(time, str);
	FL_SET(time, FL_EXIVAR);
    }
    time_mload(time, str);
    return time;
}

/*
 *  &lt;code&gt;Time&lt;/code&gt; is an abstraction of dates and times. Time is
 *  stored internally as the number of seconds and microseconds since
 *  the &lt;em&gt;epoch&lt;/em&gt;, January 1, 1970 00:00 UTC. On some operating
 *  systems, this offset is allowed to be negative. Also see the
 *  library modules &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;ParseDate&lt;/code&gt;. The
 *  &lt;code&gt;Time&lt;/code&gt; class treats GMT (Greenwich Mean Time) and UTC
 *  (Coordinated Universal Time)&lt;em&gt;[Yes, UTC really does stand for
 *  Coordinated Universal Time. There was a committee involved.]&lt;/em&gt;
 *  as equivalent.  GMT is the older way of referring to these
 *  baseline times but persists in the names of calls on Posix
 *  systems.
 *     
 *  All times are stored with some number of microseconds. Be aware of
 *  this fact when comparing times with each other---times that are
 *  apparently equal when displayed may be different when compared.
 */

void
Init_Time()
{
    rb_cTime = rb_define_class(&quot;Time&quot;, rb_cObject);
    rb_include_module(rb_cTime, rb_mComparable);

    rb_define_alloc_func(rb_cTime, time_s_alloc);
    rb_define_singleton_method(rb_cTime, &quot;now&quot;, rb_class_new_instance, -1);
    rb_define_singleton_method(rb_cTime, &quot;at&quot;, time_s_at, -1);
    rb_define_singleton_method(rb_cTime, &quot;utc&quot;, time_s_mkutc, -1);
    rb_define_singleton_method(rb_cTime, &quot;gm&quot;, time_s_mkutc, -1);
    rb_define_singleton_method(rb_cTime, &quot;local&quot;, time_s_mktime, -1);
    rb_define_singleton_method(rb_cTime, &quot;mktime&quot;, time_s_mktime, -1);

    rb_define_singleton_method(rb_cTime, &quot;times&quot;, time_s_times, 0);

    rb_define_method(rb_cTime, &quot;to_i&quot;, time_to_i, 0);
    rb_define_method(rb_cTime, &quot;to_f&quot;, time_to_f, 0);
    rb_define_method(rb_cTime, &quot;&lt;=&gt;&quot;, time_cmp, 1);
    rb_define_method(rb_cTime, &quot;eql?&quot;, time_eql, 1);
    rb_define_method(rb_cTime, &quot;hash&quot;, time_hash, 0);
    rb_define_method(rb_cTime, &quot;initialize&quot;, time_init, 0);
    rb_define_method(rb_cTime, &quot;initialize_copy&quot;, time_init_copy, 1);

    rb_define_method(rb_cTime, &quot;localtime&quot;, time_localtime, 0);
    rb_define_method(rb_cTime, &quot;gmtime&quot;, time_gmtime, 0);
    rb_define_method(rb_cTime, &quot;utc&quot;, time_gmtime, 0);
    rb_define_method(rb_cTime, &quot;getlocal&quot;, time_getlocaltime, 0);
    rb_define_method(rb_cTime, &quot;getgm&quot;, time_getgmtime, 0);
    rb_define_method(rb_cTime, &quot;getutc&quot;, time_getgmtime, 0);

    rb_define_method(rb_cTime, &quot;ctime&quot;, time_asctime, 0);
    rb_define_method(rb_cTime, &quot;asctime&quot;, time_asctime, 0);
    rb_define_method(rb_cTime, &quot;to_s&quot;, time_to_s, 0);
    rb_define_method(rb_cTime, &quot;inspect&quot;, time_to_s, 0);
    rb_define_method(rb_cTime, &quot;to_a&quot;, time_to_a, 0);

    rb_define_method(rb_cTime, &quot;+&quot;, time_plus, 1);
    rb_define_method(rb_cTime, &quot;-&quot;, time_minus, 1);

    rb_define_method(rb_cTime, &quot;succ&quot;, time_succ, 0);
    rb_define_method(rb_cTime, &quot;sec&quot;, time_sec, 0);
    rb_define_method(rb_cTime, &quot;min&quot;, time_min, 0);
    rb_define_method(rb_cTime, &quot;hour&quot;, time_hour, 0);
    rb_define_method(rb_cTime, &quot;mday&quot;, time_mday, 0);
    rb_define_method(rb_cTime, &quot;day&quot;, time_mday, 0);
    rb_define_method(rb_cTime, &quot;mon&quot;, time_mon, 0);
    rb_define_method(rb_cTime, &quot;month&quot;, time_mon, 0);
    rb_define_method(rb_cTime, &quot;year&quot;, time_year, 0);
    rb_define_method(rb_cTime, &quot;wday&quot;, time_wday, 0);
    rb_define_method(rb_cTime, &quot;yday&quot;, time_yday, 0);
    rb_define_method(rb_cTime, &quot;isdst&quot;, time_isdst, 0);
    rb_define_method(rb_cTime, &quot;dst?&quot;, time_isdst, 0);
    rb_define_method(rb_cTime, &quot;zone&quot;, time_zone, 0);
    rb_define_method(rb_cTime, &quot;gmtoff&quot;, time_utc_offset, 0);
    rb_define_method(rb_cTime, &quot;gmt_offset&quot;, time_utc_offset, 0);
    rb_define_method(rb_cTime, &quot;utc_offset&quot;, time_utc_offset, 0);

    rb_define_method(rb_cTime, &quot;utc?&quot;, time_utc_p, 0);
    rb_define_method(rb_cTime, &quot;gmt?&quot;, time_utc_p, 0);

    rb_define_method(rb_cTime, &quot;tv_sec&quot;, time_to_i, 0);
    rb_define_method(rb_cTime, &quot;tv_usec&quot;, time_usec, 0);
    rb_define_method(rb_cTime, &quot;usec&quot;, time_usec, 0);

    rb_define_method(rb_cTime, &quot;strftime&quot;, time_strftime, 1);

    /* methods for marshaling */
    rb_define_method(rb_cTime, &quot;_dump&quot;, time_dump, -1);
    rb_define_singleton_method(rb_cTime, &quot;_load&quot;, time_load, 1);
#if 0
    /* Time will support marshal_dump and marshal_load in the future (1.9 maybe) */
    rb_define_method(rb_cTime, &quot;marshal_dump&quot;, time_mdump, 0);
    rb_define_method(rb_cTime, &quot;marshal_load&quot;, time_mload, 1);
#endif
}
</pre>
    </div>