  <div id="C00000110">
<div class='banner'>
  <span class="file-title-prefix">Class</span><br />Regexp<br/>
  In:
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/re_c.html');">ruby-1.8.7-p22/re.c</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/eregex_rb.html');">ruby-1.8.7-p22/lib/eregex.rb</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/yaml/rubytypes_rb.html');">ruby-1.8.7-p22/lib/yaml/rubytypes.rb</a>

Parent:&nbsp;
        <a href="#" onclick="jsHref('classes/YAML/Object.html');">
Object
         </a>
</div>
 <!-- banner header -->

  <div id="bodyContent" >
      <div id="content">

  <div class="description"><p>
Document-class: <a href="index.html?a=C00000110&name=Regexp">Regexp</a>
</p>
<p>
A <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt> holds a
regular expression, used to match a pattern against strings. Regexps are
created using the <tt>/&#8230;/</tt> and <tt>%r{&#8230;}</tt> literals, and
by the <tt>Regexp::new</tt> constructor.
</p>
</div>



  <div class="sectiontitle">Methods</div>
  <ul>
  <li><a href="index.html?a=M001227&name=&amp;" >&amp;</a></li>
  <li><a href="index.html?a=M001215&name===" >==</a></li>
  <li><a href="index.html?a=M001217&name====" >===</a></li>
  <li><a href="index.html?a=M001216&name==~" >=~</a></li>
  <li><a href="index.html?a=M001223&name=casefold?" >casefold?</a></li>
  <li><a href="index.html?a=M001207&name=compile" >compile</a></li>
  <li><a href="index.html?a=M001214&name=eql?" >eql?</a></li>
  <li><a href="index.html?a=M001209&name=escape" >escape</a></li>
  <li><a href="index.html?a=M001213&name=hash" >hash</a></li>
  <li><a href="index.html?a=M001221&name=inspect" >inspect</a></li>
  <li><a href="index.html?a=M001225&name=kcode" >kcode</a></li>
  <li><a href="index.html?a=M001211&name=last_match" >last_match</a></li>
  <li><a href="index.html?a=M001219&name=match" >match</a></li>
  <li><a href="index.html?a=M001212&name=new" >new</a></li>
  <li><a href="index.html?a=M001224&name=options" >options</a></li>
  <li><a href="index.html?a=M001208&name=quote" >quote</a></li>
  <li><a href="index.html?a=M001222&name=source" >source</a></li>
  <li><a href="index.html?a=M001220&name=to_s" >to_s</a></li>
  <li><a href="index.html?a=M001229&name=to_yaml" >to_yaml</a></li>
  <li><a href="index.html?a=M001210&name=union" >union</a></li>
  <li><a href="index.html?a=M001228&name=yaml_new" >yaml_new</a></li>
  <li><a href="index.html?a=M001226&name=|" >|</a></li>
  <li><a href="index.html?a=M001218&name=~" >~</a></li>
  </ul>




  <div class="sectiontitle">Constants</div>
  <table border='0' cellpadding='5'>
  <tr valign='top'>
    <td class="attr-name">IGNORECASE</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RE_OPTION_IGNORECASE)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">EXTENDED</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RE_OPTION_EXTENDED)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">MULTILINE</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RE_OPTION_MULTILINE)</td>
  </tr>
  </table>


<div class="sectiontitle">Public Class methods</div>
<div id="M001207" class="method">
  <div id="M001207_title" class="title">
    <b>compile</b>(...)
  </div>
  <div class="description">
  <p>
Synonym for <tt><a
href="index.html?a=M001212&name=Regexp.new">Regexp.new</a></tt>
</p>
  </div>
</div>
<div id="M001209" class="method">
  <div id="M001209_title" class="title">
    <b>Regexp.escape(str)   => a_str<br />
Regexp.quote(str)    => a_str<br />
</b>
  </div>
  <div class="description">
  <p>
Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped. For any string, <tt><a
href="index.html?a=M001209&name=Regexp.escape">Regexp.escape</a>(<em>str</em>)=~<em>str</em></tt>
will be true.
</p>
<pre>
   Regexp.escape('\\*?{}.')   #=&gt; \\\\\*\?\{\}\.
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001209_source')" id="l_M001209_source">show source</a> ]</p>
  <div id="M001209_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Regexp.escape(str)   =&gt; a_str
 *     Regexp.quote(str)    =&gt; a_str
 *  
 *  Escapes any characters that would have special meaning in a regular
 *  expression. Returns a new escaped string, or self if no characters are
 *  escaped.  For any string,
 *  &lt;code&gt;Regexp.escape(&lt;i&gt;str&lt;/i&gt;)=~&lt;i&gt;str&lt;/i&gt;&lt;/code&gt; will be true.
 *     
 *     Regexp.escape('\\*?{}.')   #=&gt; \\\\\*\?\{\}\.
 */

static VALUE
rb_reg_s_quote(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE str, kcode;
    int kcode_saved = reg_kcode;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;kcode);
    if (!NIL_P(kcode)) {
        rb_set_kcode(StringValuePtr(kcode));
        curr_kcode = reg_kcode;
        reg_kcode = kcode_saved;
    }
    StringValue(str);
    str = rb_reg_quote(str);
    rb_kcode_reset_option();
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M001211" class="method">
  <div id="M001211_title" class="title">
    <b>Regexp.last_match           => matchdata<br />
Regexp.last_match(fixnum)   => str<br />
</b>
  </div>
  <div class="description">
  <p>
The first form returns the <tt><a
href="index.html?a=C00000118&name=MatchData">MatchData</a></tt> object
generated by the last successful pattern match. Equivalent to reading the
global variable <tt>$~</tt>. The second form returns the nth field in this
<tt><a href="index.html?a=C00000118&name=MatchData">MatchData</a></tt>
object.
</p>
<pre>
   /c(.)t/ =~ 'cat'       #=&gt; 0
   Regexp.last_match      #=&gt; #&lt;MatchData:0x401b3d30&gt;
   Regexp.last_match(0)   #=&gt; &quot;cat&quot;
   Regexp.last_match(1)   #=&gt; &quot;a&quot;
   Regexp.last_match(2)   #=&gt; nil
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001211_source')" id="l_M001211_source">show source</a> ]</p>
  <div id="M001211_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Regexp.last_match           =&gt; matchdata
 *     Regexp.last_match(fixnum)   =&gt; str
 *  
 *  The first form returns the &lt;code&gt;MatchData&lt;/code&gt; object generated by the
 *  last successful pattern match. Equivalent to reading the global variable
 *  &lt;code&gt;$~&lt;/code&gt;. The second form returns the nth field in this
 *  &lt;code&gt;MatchData&lt;/code&gt; object.
 *     
 *     /c(.)t/ =~ 'cat'       #=&gt; 0
 *     Regexp.last_match      #=&gt; #&lt;MatchData:0x401b3d30&gt;
 *     Regexp.last_match(0)   #=&gt; &quot;cat&quot;
 *     Regexp.last_match(1)   #=&gt; &quot;a&quot;
 *     Regexp.last_match(2)   #=&gt; nil
 */

static VALUE
rb_reg_s_last_match(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE nth;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;nth) == 1) {
        return rb_reg_nth_match(NUM2INT(nth), rb_backref_get());
    }
    return match_getter();
}
</pre>
  </div>
</div>
</div>
<div id="M001212" class="method">
  <div id="M001212_title" class="title">
    <b>Regexp.new(string [, options [, lang]])       => regexp<br />
Regexp.new(regexp)                            => regexp<br />
Regexp.compile(string [, options [, lang]])   => regexp<br />
Regexp.compile(regexp)                        => regexp<br />
</b>
  </div>
  <div class="description">
  <p>
Constructs a new regular expression from <em>pattern</em>, which can be
either a <tt><a href="index.html?a=C00000055&name=String">String</a></tt>
or a <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt> (in
which case that regexp&#8217;s options are propagated, and new options may
not be specified (a change as of Ruby 1.8). If <em>options</em> is a <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt>, it should be one
or more of the constants <tt>Regexp::EXTENDED</tt>,
<tt>Regexp::IGNORECASE</tt>, and <tt>Regexp::MULTILINE</tt>, <em>or</em>-ed
together. Otherwise, if <em>options</em> is not <tt>nil</tt>, the regexp
will be case insensitive. The <em>lang</em> parameter enables multibyte
support for the regexp: `n&#8217;, `N&#8217; = none, `e&#8217;, `E&#8217; =
EUC, `s&#8217;, `S&#8217; = SJIS, `u&#8217;, `U&#8217; = UTF-8.
</p>
<pre>
   r1 = Regexp.new('^a-z+:\\s+\w+')           #=&gt; /^a-z+:\s+\w+/
   r2 = Regexp.new('cat', true)               #=&gt; /cat/i
   r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x
   r4 = Regexp.new(r2)                        #=&gt; /cat/i
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001212_source')" id="l_M001212_source">show source</a> ]</p>
  <div id="M001212_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Regexp.new(string [, options [, lang]])       =&gt; regexp
 *     Regexp.new(regexp)                            =&gt; regexp
 *     Regexp.compile(string [, options [, lang]])   =&gt; regexp
 *     Regexp.compile(regexp)                        =&gt; regexp
 *  
 *  Constructs a new regular expression from &lt;i&gt;pattern&lt;/i&gt;, which can be either
 *  a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Regexp&lt;/code&gt; (in which case that regexp's
 *  options are propagated, and new options may not be specified (a change as of
 *  Ruby 1.8). If &lt;i&gt;options&lt;/i&gt; is a &lt;code&gt;Fixnum&lt;/code&gt;, it should be one or
 *  more of the constants &lt;code&gt;Regexp::EXTENDED&lt;/code&gt;,
 *  &lt;code&gt;Regexp::IGNORECASE&lt;/code&gt;, and &lt;code&gt;Regexp::MULTILINE&lt;/code&gt;,
 *  &lt;em&gt;or&lt;/em&gt;-ed together. Otherwise, if &lt;i&gt;options&lt;/i&gt; is not
 *  &lt;code&gt;nil&lt;/code&gt;, the regexp will be case insensitive. The &lt;i&gt;lang&lt;/i&gt;
 *  parameter enables multibyte support for the regexp: `n', `N' = none, `e',
 *  `E' = EUC, `s', `S' = SJIS, `u', `U' = UTF-8.
 * 
 *     r1 = Regexp.new('^a-z+:\\s+\w+')           #=&gt; /^a-z+:\s+\w+/
 *     r2 = Regexp.new('cat', true)               #=&gt; /cat/i
 *     r3 = Regexp.new('dog', Regexp::EXTENDED)   #=&gt; /dog/x
 *     r4 = Regexp.new(r2)                        #=&gt; /cat/i
 */

static VALUE
rb_reg_initialize_m(argc, argv, self)
    int argc;
    VALUE *argv;
    VALUE self;
{
    const char *s;
    long len;
    int flags = 0;

    if (argc == 0 || argc &gt; 3) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }
    if (TYPE(argv[0]) == T_REGEXP) {
        if (argc &gt; 1) {
            rb_warn(&quot;flags%s ignored&quot;, (argc == 3) ? &quot; and encoding&quot;: &quot;&quot;);
        }
        rb_reg_check(argv[0]);
        flags = RREGEXP(argv[0])-&gt;ptr-&gt;options &amp; 0xf;
        if (FL_TEST(argv[0], KCODE_FIXED)) {
            switch (RBASIC(argv[0])-&gt;flags &amp; KCODE_MASK) {
              case KCODE_NONE:
                flags |= 16;
                break;
              case KCODE_EUC:
                flags |= 32;
                break;
              case KCODE_SJIS:
                flags |= 48;
                break;
              case KCODE_UTF8:
                flags |= 64;
                break;
              default:
                break;
            }
        }
        s = RREGEXP(argv[0])-&gt;str;
        len = RREGEXP(argv[0])-&gt;len;
    }
    else {
        if (argc &gt;= 2) {
            if (FIXNUM_P(argv[1])) flags = FIX2INT(argv[1]);
            else if (RTEST(argv[1])) flags = RE_OPTION_IGNORECASE;
        }
        if (argc == 3 &amp;&amp; !NIL_P(argv[2])) {
            char *kcode = StringValuePtr(argv[2]);

            flags &amp;= ~0x70;
            switch (kcode[0]) {
              case 'n': case 'N':
                flags |= 16;
                break;
              case 'e': case 'E':
                flags |= 32;
                break;
              case 's': case 'S':
                flags |= 48;
                break;
              case 'u': case 'U':
                flags |= 64;
                break;
              default:
                break;
            }
        }
        s = StringValuePtr(argv[0]);
        len = RSTRING(argv[0])-&gt;len;
    }
    rb_reg_initialize(self, s, len, flags);
    return self;
}
</pre>
  </div>
</div>
</div>
<div id="M001208" class="method">
  <div id="M001208_title" class="title">
    <b>Regexp.escape(str)   => a_str<br />
Regexp.quote(str)    => a_str<br />
</b>
  </div>
  <div class="description">
  <p>
Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string, or self if no characters are
escaped. For any string, <tt><a
href="index.html?a=M001209&name=Regexp.escape">Regexp.escape</a>(<em>str</em>)=~<em>str</em></tt>
will be true.
</p>
<pre>
   Regexp.escape('\\*?{}.')   #=&gt; \\\\\*\?\{\}\.
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001208_source')" id="l_M001208_source">show source</a> ]</p>
  <div id="M001208_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Regexp.escape(str)   =&gt; a_str
 *     Regexp.quote(str)    =&gt; a_str
 *  
 *  Escapes any characters that would have special meaning in a regular
 *  expression. Returns a new escaped string, or self if no characters are
 *  escaped.  For any string,
 *  &lt;code&gt;Regexp.escape(&lt;i&gt;str&lt;/i&gt;)=~&lt;i&gt;str&lt;/i&gt;&lt;/code&gt; will be true.
 *     
 *     Regexp.escape('\\*?{}.')   #=&gt; \\\\\*\?\{\}\.
 */

static VALUE
rb_reg_s_quote(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE str, kcode;
    int kcode_saved = reg_kcode;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;str, &amp;kcode);
    if (!NIL_P(kcode)) {
        rb_set_kcode(StringValuePtr(kcode));
        curr_kcode = reg_kcode;
        reg_kcode = kcode_saved;
    }
    StringValue(str);
    str = rb_reg_quote(str);
    rb_kcode_reset_option();
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M001210" class="method">
  <div id="M001210_title" class="title">
    <b>Regexp.union(pat1, pat2, ...)            => new_regexp<br />
Regexp.union(pats_ary)                   => new_regexp<br />
</b>
  </div>
  <div class="description">
  <p>
Return a <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt>
object that is the union of the given <em>pattern</em>s, i.e., will match
any of its parts. The <em>pattern</em>s can be <a
href="index.html?a=C00000110&name=Regexp">Regexp</a> objects, in which case
their options will be preserved, or Strings. If no patterns are given,
returns <tt>/(?!)/</tt>.
</p>
<pre>
   Regexp.union                         #=&gt; /(?!)/
   Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/
   Regexp.union(&quot;a+b*c&quot;)                #=&gt; /a\+b\*c/
   Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/
   Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) #=&gt; /skiing|sledding/
   Regexp.union(/dogs/, /cats/i)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001210_source')" id="l_M001210_source">show source</a> ]</p>
  <div id="M001210_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Regexp.union(pat1, pat2, ...)            =&gt; new_regexp
 *     Regexp.union(pats_ary)                   =&gt; new_regexp
 *  
 *  Return a &lt;code&gt;Regexp&lt;/code&gt; object that is the union of the given
 *  &lt;em&gt;pattern&lt;/em&gt;s, i.e., will match any of its parts. The &lt;em&gt;pattern&lt;/em&gt;s
 *  can be Regexp objects, in which case their options will be preserved, or
 *  Strings. If no patterns are given, returns &lt;code&gt;/(?!)/&lt;/code&gt;.
 *     
 *     Regexp.union                         #=&gt; /(?!)/
 *     Regexp.union(&quot;penzance&quot;)             #=&gt; /penzance/
 *     Regexp.union(&quot;a+b*c&quot;)                #=&gt; /a\+b\*c/
 *     Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   #=&gt; /skiing|sledding/
 *     Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) #=&gt; /skiing|sledding/
 *     Regexp.union(/dogs/, /cats/i)        #=&gt; /(?-mix:dogs)|(?i-mx:cats)/
 */
static VALUE
rb_reg_s_union_m(VALUE self, VALUE args)
{
    VALUE v;
    if (RARRAY_LEN(args) == 1 &amp;&amp;
        !NIL_P(v = rb_check_array_type(rb_ary_entry(args, 0)))) {
        return rb_reg_s_union(self, v);
    }
    return rb_reg_s_union(self, args);
}
</pre>
  </div>
</div>
</div>
<div id="M001228" class="method">
  <div id="M001228_title" class="title">
    <b>yaml_new</b>( klass, tag, val )
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001228_source')" id="l_M001228_source">show source</a> ]</p>
  <div id="M001228_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 255</span>
255:     <span class="ruby-keyword kw">def</span> <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">yaml_new</span>( <span class="ruby-identifier">klass</span>, <span class="ruby-identifier">tag</span>, <span class="ruby-identifier">val</span> )
256:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">String</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">val</span> <span class="ruby-keyword kw">and</span> <span class="ruby-identifier">val</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^\/(.*)\/([mix]*)$/</span>
257:             <span class="ruby-identifier">val</span> = { <span class="ruby-value str">'regexp'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">$1</span>, <span class="ruby-value str">'mods'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">$2</span> }
258:         <span class="ruby-keyword kw">end</span>
259:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Hash</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">val</span>
260:             <span class="ruby-identifier">mods</span> = <span class="ruby-keyword kw">nil</span>
261:             <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">val</span>[<span class="ruby-value str">'mods'</span>].<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>
262:                 <span class="ruby-identifier">mods</span> = <span class="ruby-value">0x00</span>
263:                 <span class="ruby-identifier">mods</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">EXTENDED</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">val</span>[<span class="ruby-value str">'mods'</span>].<span class="ruby-identifier">include?</span>( <span class="ruby-value str">'x'</span> )
264:                 <span class="ruby-identifier">mods</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">IGNORECASE</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">val</span>[<span class="ruby-value str">'mods'</span>].<span class="ruby-identifier">include?</span>( <span class="ruby-value str">'i'</span> )
265:                 <span class="ruby-identifier">mods</span> <span class="ruby-operator">|=</span> <span class="ruby-constant">Regexp</span><span class="ruby-operator">::</span><span class="ruby-constant">MULTILINE</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">val</span>[<span class="ruby-value str">'mods'</span>].<span class="ruby-identifier">include?</span>( <span class="ruby-value str">'m'</span> )
266:             <span class="ruby-keyword kw">end</span>
267:             <span class="ruby-identifier">val</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-value str">'mods'</span> )
268:             <span class="ruby-identifier">r</span> = <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-identifier">object_maker</span>( <span class="ruby-identifier">klass</span>, {} )
269:             <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">instance_method</span>(<span class="ruby-identifier">:initialize</span>).
270:                   <span class="ruby-identifier">bind</span>(<span class="ruby-identifier">r</span>).
271:                   <span class="ruby-identifier">call</span>( <span class="ruby-identifier">val</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-value str">'regexp'</span> ), <span class="ruby-identifier">mods</span> )
272:             <span class="ruby-identifier">val</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">r</span>.<span class="ruby-identifier">instance_variable_set</span>( <span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span> ) }
273:             <span class="ruby-identifier">r</span>
274:         <span class="ruby-keyword kw">else</span>
275:             <span class="ruby-identifier">raise</span> <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-constant">TypeError</span>, <span class="ruby-value str">&quot;Invalid Regular expression: &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">inspect</span>
276:         <span class="ruby-keyword kw">end</span>
277:     <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div class="sectiontitle">Public Instance methods</div>
<div id="M001227" class="method">
  <div id="M001227_title" class="title">
    <b>&amp;</b>(other)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001227_source')" id="l_M001227_source">show source</a> ]</p>
  <div id="M001227_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/eregex.rb, line 29</span>
29:   <span class="ruby-keyword kw">def</span> <span class="ruby-operator">&amp;</span>(<span class="ruby-identifier">other</span>)
30:     <span class="ruby-constant">RegAnd</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">other</span>)
31:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M001215" class="method">
  <div id="M001215_title" class="title">
    <b>rxp == other_rxp      => true or false<br />
rxp.eql?(other_rxp)   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Equality&#8212;Two regexps are equal if their patterns are identical, they
have the same character set code, and their <tt>casefold?</tt> values are
the same.
</p>
<pre>
   /abc/  == /abc/x   #=&gt; false
   /abc/  == /abc/i   #=&gt; false
   /abc/u == /abc/n   #=&gt; false
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001215_source')" id="l_M001215_source">show source</a> ]</p>
  <div id="M001215_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp == other_rxp      =&gt; true or false
 *     rxp.eql?(other_rxp)   =&gt; true or false
 *  
 *  Equality---Two regexps are equal if their patterns are identical, they have
 *  the same character set code, and their &lt;code&gt;casefold?&lt;/code&gt; values are the
 *  same.
 *     
 *     /abc/  == /abc/x   #=&gt; false
 *     /abc/  == /abc/i   #=&gt; false
 *     /abc/u == /abc/n   #=&gt; false
 */

static VALUE
rb_reg_equal(re1, re2)
    VALUE re1, re2;
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (RREGEXP(re1)-&gt;len != RREGEXP(re2)-&gt;len) return Qfalse;
    if (memcmp(RREGEXP(re1)-&gt;str, RREGEXP(re2)-&gt;str, RREGEXP(re1)-&gt;len) == 0 &amp;&amp;
        rb_reg_cur_kcode(re1) == rb_reg_cur_kcode(re2) &amp;&amp;
        RREGEXP(re1)-&gt;ptr-&gt;options == RREGEXP(re2)-&gt;ptr-&gt;options) {
        return Qtrue;
    }
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M001217" class="method">
  <div id="M001217_title" class="title">
    <b>rxp === str   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Case Equality&#8212;Synonym for <tt><a
href="index.html?a=C00000110&name=Regexp">Regexp</a>#=~</tt> used in case
statements.
</p>
<pre>
   a = &quot;HELLO&quot;
   case a
   when /^[a-z]*$/; print &quot;Lower case\n&quot;
   when /^[A-Z]*$/; print &quot;Upper case\n&quot;
   else;            print &quot;Mixed case\n&quot;
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Upper case
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001217_source')" id="l_M001217_source">show source</a> ]</p>
  <div id="M001217_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp === str   =&gt; true or false
 *  
 *  Case Equality---Synonym for &lt;code&gt;Regexp#=~&lt;/code&gt; used in case statements.
 *     
 *     a = &quot;HELLO&quot;
 *     case a
 *     when /^[a-z]*$/; print &quot;Lower case\n&quot;
 *     when /^[A-Z]*$/; print &quot;Upper case\n&quot;
 *     else;            print &quot;Mixed case\n&quot;
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Upper case
 */

VALUE
rb_reg_eqq(re, str)
    VALUE re, str;
{
    long start;

    if (TYPE(str) != T_STRING) {
        str = rb_check_string_type(str);
        if (NIL_P(str)) {
            rb_backref_set(Qnil);
            return Qfalse;
        }
    }
    StringValue(str);
    start = rb_reg_search(re, str, 0, 0);
    if (start &lt; 0) {
        return Qfalse;
    }
    return Qtrue;
}
</pre>
  </div>
</div>
</div>
<div id="M001216" class="method">
  <div id="M001216_title" class="title">
    <b>rxp.match(str)   => matchdata or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a <tt><a
href="index.html?a=C00000118&name=MatchData">MatchData</a></tt> object
describing the match, or <tt>nil</tt> if there was no match. This is
equivalent to retrieving the value of the special variable <tt>$~</tt>
following a normal match.
</p>
<pre>
   /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001216_source')" id="l_M001216_source">show source</a> ]</p>
  <div id="M001216_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp.match(str)   =&gt; matchdata or nil
 *  
 *  Returns a &lt;code&gt;MatchData&lt;/code&gt; object describing the match, or
 *  &lt;code&gt;nil&lt;/code&gt; if there was no match. This is equivalent to retrieving the
 *  value of the special variable &lt;code&gt;$~&lt;/code&gt; following a normal match.
 *     
 *     /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
 */

VALUE
rb_reg_match(re, str)
    VALUE re, str;
{
    long start;

    if (NIL_P(str)) {
        rb_backref_set(Qnil);
        return Qnil;
    }
    StringValue(str);
    start = rb_reg_search(re, str, 0, 0);
    if (start &lt; 0) {
        return Qnil;
    }
    return LONG2FIX(start);
}
</pre>
  </div>
</div>
</div>
<div id="M001223" class="method">
  <div id="M001223_title" class="title">
    <b>rxp.casefold?   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the value of the case-insensitive flag.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001223_source')" id="l_M001223_source">show source</a> ]</p>
  <div id="M001223_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp.casefold?   =&gt; true or false
 *  
 *  Returns the value of the case-insensitive flag.
 */

static VALUE
rb_reg_casefold_p(re)
    VALUE re;
{
    rb_reg_check(re);
    if (RREGEXP(re)-&gt;ptr-&gt;options &amp; RE_OPTION_IGNORECASE) return Qtrue;
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M001214" class="method">
  <div id="M001214_title" class="title">
    <b>rxp == other_rxp      => true or false<br />
rxp.eql?(other_rxp)   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Equality&#8212;Two regexps are equal if their patterns are identical, they
have the same character set code, and their <tt>casefold?</tt> values are
the same.
</p>
<pre>
   /abc/  == /abc/x   #=&gt; false
   /abc/  == /abc/i   #=&gt; false
   /abc/u == /abc/n   #=&gt; false
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001214_source')" id="l_M001214_source">show source</a> ]</p>
  <div id="M001214_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp == other_rxp      =&gt; true or false
 *     rxp.eql?(other_rxp)   =&gt; true or false
 *  
 *  Equality---Two regexps are equal if their patterns are identical, they have
 *  the same character set code, and their &lt;code&gt;casefold?&lt;/code&gt; values are the
 *  same.
 *     
 *     /abc/  == /abc/x   #=&gt; false
 *     /abc/  == /abc/i   #=&gt; false
 *     /abc/u == /abc/n   #=&gt; false
 */

static VALUE
rb_reg_equal(re1, re2)
    VALUE re1, re2;
{
    if (re1 == re2) return Qtrue;
    if (TYPE(re2) != T_REGEXP) return Qfalse;
    rb_reg_check(re1); rb_reg_check(re2);
    if (RREGEXP(re1)-&gt;len != RREGEXP(re2)-&gt;len) return Qfalse;
    if (memcmp(RREGEXP(re1)-&gt;str, RREGEXP(re2)-&gt;str, RREGEXP(re1)-&gt;len) == 0 &amp;&amp;
        rb_reg_cur_kcode(re1) == rb_reg_cur_kcode(re2) &amp;&amp;
        RREGEXP(re1)-&gt;ptr-&gt;options == RREGEXP(re2)-&gt;ptr-&gt;options) {
        return Qtrue;
    }
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M001213" class="method">
  <div id="M001213_title" class="title">
    <b>rxp.hash   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Produce a hash based on the text and options of this regular expression.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001213_source')" id="l_M001213_source">show source</a> ]</p>
  <div id="M001213_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *   rxp.hash   =&gt; fixnum
 *
 * Produce a hash based on the text and options of this regular expression.
 */

static VALUE
rb_reg_hash(re)
    VALUE re;
{
    int hashval, len;
    char *p;

    rb_reg_check(re);
    hashval = RREGEXP(re)-&gt;ptr-&gt;options;
    len = RREGEXP(re)-&gt;len;
    p  = RREGEXP(re)-&gt;str;
    while (len--) {
        hashval = hashval * 33 + *p++;
    }
    hashval = hashval + (hashval&gt;&gt;5);
    
    return INT2FIX(hashval);
}
</pre>
  </div>
</div>
</div>
<div id="M001221" class="method">
  <div id="M001221_title" class="title">
    <b>rxp.inspect   => string<br />
</b>
  </div>
  <div class="description">
  <p>
Produce a nicely formatted string-version of <em>rxp</em>. Perhaps
surprisingly, <tt><a
href="index.html?a=M001221&name=inspect">inspect</a></tt> actually produces
the more natural version of the string than <tt><a
href="index.html?a=M001220&name=to_s">to_s</a></tt>.
</p>
<pre>
    /ab+c/ix.to_s         #=&gt; /ab+c/ix
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001221_source')" id="l_M001221_source">show source</a> ]</p>
  <div id="M001221_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *    rxp.inspect   =&gt; string
 *
 * Produce a nicely formatted string-version of _rxp_. Perhaps surprisingly,
 * &lt;code&gt;#inspect&lt;/code&gt; actually produces the more natural version of
 * the string than &lt;code&gt;#to_s&lt;/code&gt;.
 *
 *     /ab+c/ix.to_s         #=&gt; /ab+c/ix
*/

static VALUE
rb_reg_inspect(re)
    VALUE re;
{
    rb_reg_check(re);
    return rb_reg_desc(RREGEXP(re)-&gt;str, RREGEXP(re)-&gt;len, re);
}
</pre>
  </div>
</div>
</div>
<div id="M001225" class="method">
  <div id="M001225_title" class="title">
    <b>rxp.kcode   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the character set code for the regexp.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001225_source')" id="l_M001225_source">show source</a> ]</p>
  <div id="M001225_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp.kcode   =&gt; str
 *  
 *  Returns the character set code for the regexp.
 */

static VALUE
rb_reg_kcode_m(re)
    VALUE re;
{
    const char *kcode;

    if (FL_TEST(re, KCODE_FIXED)) {
        switch (RBASIC(re)-&gt;flags &amp; KCODE_MASK) {
          case KCODE_NONE:
            kcode = &quot;none&quot;; break;
          case KCODE_EUC:
            kcode = &quot;euc&quot;; break;
          case KCODE_SJIS:
            kcode = &quot;sjis&quot;; break;
          case KCODE_UTF8:
            kcode = &quot;utf8&quot;; break;
          default:
            rb_bug(&quot;unknown kcode - should not happen&quot;);
            break;
        }
        return rb_str_new2(kcode);
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M001219" class="method">
  <div id="M001219_title" class="title">
    <b>rxp.match(str)   => matchdata or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a <tt><a
href="index.html?a=C00000118&name=MatchData">MatchData</a></tt> object
describing the match, or <tt>nil</tt> if there was no match. This is
equivalent to retrieving the value of the special variable <tt>$~</tt>
following a normal match.
</p>
<pre>
   /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001219_source')" id="l_M001219_source">show source</a> ]</p>
  <div id="M001219_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp.match(str)   =&gt; matchdata or nil
 *  
 *  Returns a &lt;code&gt;MatchData&lt;/code&gt; object describing the match, or
 *  &lt;code&gt;nil&lt;/code&gt; if there was no match. This is equivalent to retrieving the
 *  value of the special variable &lt;code&gt;$~&lt;/code&gt; following a normal match.
 *     
 *     /(.)(.)(.)/.match(&quot;abc&quot;)[2]   #=&gt; &quot;b&quot;
 */

static VALUE
rb_reg_match_m(re, str)
    VALUE re, str;
{
    VALUE result = rb_reg_match(re, str);

    if (NIL_P(result)) return Qnil;
    result = rb_backref_get();
    rb_match_busy(result);
    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M001224" class="method">
  <div id="M001224_title" class="title">
    <b>rxp.options   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the set of bits corresponding to the options used when creating
this <a href="index.html?a=C00000110&name=Regexp">Regexp</a> (see
<tt>Regexp::new</tt> for details. Note that additional bits may be set in
the returned options: these are used internally by the regular expression
code. These extra bits are ignored if the options are passed to
<tt>Regexp::new</tt>.
</p>
<pre>
   Regexp::IGNORECASE                  #=&gt; 1
   Regexp::EXTENDED                    #=&gt; 2
   Regexp::MULTILINE                   #=&gt; 4

   /cat/.options                       #=&gt; 128
   /cat/ix.options                     #=&gt; 131
   Regexp.new('cat', true).options     #=&gt; 129
   Regexp.new('cat', 0, 's').options   #=&gt; 384

   r = /cat/ix
   Regexp.new(r.source, r.options)     #=&gt; /cat/ix
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001224_source')" id="l_M001224_source">show source</a> ]</p>
  <div id="M001224_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp.options   =&gt; fixnum
 *  
 *  Returns the set of bits corresponding to the options used when creating this
 *  Regexp (see &lt;code&gt;Regexp::new&lt;/code&gt; for details. Note that additional bits
 *  may be set in the returned options: these are used internally by the regular
 *  expression code. These extra bits are ignored if the options are passed to
 *  &lt;code&gt;Regexp::new&lt;/code&gt;.
 *     
 *     Regexp::IGNORECASE                  #=&gt; 1
 *     Regexp::EXTENDED                    #=&gt; 2
 *     Regexp::MULTILINE                   #=&gt; 4
 *     
 *     /cat/.options                       #=&gt; 128
 *     /cat/ix.options                     #=&gt; 131
 *     Regexp.new('cat', true).options     #=&gt; 129
 *     Regexp.new('cat', 0, 's').options   #=&gt; 384
 *     
 *     r = /cat/ix
 *     Regexp.new(r.source, r.options)     #=&gt; /cat/ix
 */

static VALUE
rb_reg_options_m(re)
    VALUE re;
{
    int options = rb_reg_options(re);
    return INT2NUM(options);
}
</pre>
  </div>
</div>
</div>
<div id="M001222" class="method">
  <div id="M001222_title" class="title">
    <b>rxp.source   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the original string of the pattern.
</p>
<pre>
   /ab+c/ix.source   #=&gt; &quot;ab+c&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001222_source')" id="l_M001222_source">show source</a> ]</p>
  <div id="M001222_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp.source   =&gt; str
 *  
 *  Returns the original string of the pattern.
 *     
 *     /ab+c/ix.source   #=&gt; &quot;ab+c&quot;
 */

static VALUE
rb_reg_source(re)
    VALUE re;
{
    VALUE str;

    rb_reg_check(re);
    str = rb_str_new(RREGEXP(re)-&gt;str,RREGEXP(re)-&gt;len);
    if (OBJ_TAINTED(re)) OBJ_TAINT(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M001220" class="method">
  <div id="M001220_title" class="title">
    <b>rxp.to_s   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a string containing the regular expression and its options (using
the <tt>(?xxx:yyy)</tt> notation. This string can be fed back in to
<tt>Regexp::new</tt> to a regular expression with the same semantics as the
original. (However, <tt><a
href="index.html?a=C00000110&name=Regexp">Regexp</a>#==</tt> may not return
true when comparing the two, as the source of the regular expression itself
may differ, as the example shows). <tt><a
href="index.html?a=M001221&name=Regexp#inspect">Regexp#inspect</a></tt>
produces a generally more readable version of <em>rxp</em>.
</p>
<pre>
   r1 = /ab+c/ix         #=&gt; /ab+c/ix
   s1 = r1.to_s          #=&gt; &quot;(?ix-m:ab+c)&quot;
   r2 = Regexp.new(s1)   #=&gt; /(?ix-m:ab+c)/
   r1 == r2              #=&gt; false
   r1.source             #=&gt; &quot;ab+c&quot;
   r2.source             #=&gt; &quot;(?ix-m:ab+c)&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001220_source')" id="l_M001220_source">show source</a> ]</p>
  <div id="M001220_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     rxp.to_s   =&gt; str
 *  
 *  Returns a string containing the regular expression and its options (using the
 *  &lt;code&gt;(?xxx:yyy)&lt;/code&gt; notation. This string can be fed back in to
 *  &lt;code&gt;Regexp::new&lt;/code&gt; to a regular expression with the same semantics as
 *  the original. (However, &lt;code&gt;Regexp#==&lt;/code&gt; may not return true when
 *  comparing the two, as the source of the regular expression itself may
 *  differ, as the example shows).  &lt;code&gt;Regexp#inspect&lt;/code&gt; produces a
 *  generally more readable version of &lt;i&gt;rxp&lt;/i&gt;.
 *     
 *     r1 = /ab+c/ix         #=&gt; /ab+c/ix
 *     s1 = r1.to_s          #=&gt; &quot;(?ix-m:ab+c)&quot;
 *     r2 = Regexp.new(s1)   #=&gt; /(?ix-m:ab+c)/
 *     r1 == r2              #=&gt; false
 *     r1.source             #=&gt; &quot;ab+c&quot;
 *     r2.source             #=&gt; &quot;(?ix-m:ab+c)&quot;
 */

static VALUE
rb_reg_to_s(re)
    VALUE re;
{
    int options;
    const int embeddable = RE_OPTION_MULTILINE|RE_OPTION_IGNORECASE|RE_OPTION_EXTENDED;
    long len;
    const char* ptr;
    VALUE str = rb_str_buf_new2(&quot;(?&quot;);

    rb_reg_check(re);

    options = RREGEXP(re)-&gt;ptr-&gt;options;
    ptr = RREGEXP(re)-&gt;str;
    len = RREGEXP(re)-&gt;len;
  again:
    if (len &gt;= 4 &amp;&amp; ptr[0] == '(' &amp;&amp; ptr[1] == '?') {
        int err = 1;
        ptr += 2;
        if ((len -= 2) &gt; 0) {
            do {
                if (*ptr == 'm') {
                    options |= RE_OPTION_MULTILINE;
                }
                else if (*ptr == 'i') {
                    options |= RE_OPTION_IGNORECASE;
                }
                else if (*ptr == 'x') {
                    options |= RE_OPTION_EXTENDED;
                }
                else break;
                ++ptr;
            } while (--len &gt; 0);
        }
        if (len &gt; 1 &amp;&amp; *ptr == '-') {
            ++ptr;
            --len;
            do {
                if (*ptr == 'm') {
                    options &amp;= ~RE_OPTION_MULTILINE;
                }
                else if (*ptr == 'i') {
                    options &amp;= ~RE_OPTION_IGNORECASE;
                }
                else if (*ptr == 'x') {
                    options &amp;= ~RE_OPTION_EXTENDED;
                }
                else break;
                ++ptr;
            } while (--len &gt; 0);
        }
        if (*ptr == ')') {
            --len;
            ++ptr;
            goto again;
        }
        if (*ptr == ':' &amp;&amp; ptr[len-1] == ')') {
            Regexp *rp;
            rb_kcode_set_option(re);
            rp = ALLOC(Regexp);
            MEMZERO((char *)rp, Regexp, 1);
            err = re_compile_pattern(++ptr, len -= 2, rp) != 0;
            rb_kcode_reset_option();
            re_free_pattern(rp);
        }
        if (err) {
            options = RREGEXP(re)-&gt;ptr-&gt;options;
            ptr = RREGEXP(re)-&gt;str;
            len = RREGEXP(re)-&gt;len;
        }
    }

    if (options &amp; RE_OPTION_MULTILINE) rb_str_buf_cat2(str, &quot;m&quot;);
    if (options &amp; RE_OPTION_IGNORECASE) rb_str_buf_cat2(str, &quot;i&quot;);
    if (options &amp; RE_OPTION_EXTENDED) rb_str_buf_cat2(str, &quot;x&quot;);

    if ((options &amp; embeddable) != embeddable) {
        rb_str_buf_cat2(str, &quot;-&quot;);
        if (!(options &amp; RE_OPTION_MULTILINE)) rb_str_buf_cat2(str, &quot;m&quot;);
        if (!(options &amp; RE_OPTION_IGNORECASE)) rb_str_buf_cat2(str, &quot;i&quot;);
        if (!(options &amp; RE_OPTION_EXTENDED)) rb_str_buf_cat2(str, &quot;x&quot;);
    }

    rb_str_buf_cat2(str, &quot;:&quot;);
    rb_reg_expr_str(str, ptr, len);
    rb_str_buf_cat2(str, &quot;)&quot;);

    OBJ_INFECT(str, re);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M001229" class="method">
  <div id="M001229_title" class="title">
    <b>to_yaml</b>( opts = {} )
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001229_source')" id="l_M001229_source">show source</a> ]</p>
  <div id="M001229_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 278</span>
278:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">to_yaml</span>( <span class="ruby-identifier">opts</span> = {} )
279:                 <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-identifier">quick_emit</span>( <span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">opts</span> ) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">out</span><span class="ruby-operator">|</span>
280:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">to_yaml_properties</span>.<span class="ruby-identifier">empty?</span>
281:                 <span class="ruby-identifier">out</span>.<span class="ruby-identifier">scalar</span>( <span class="ruby-identifier">taguri</span>, <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">inspect</span>, <span class="ruby-identifier">:plain</span> )
282:             <span class="ruby-keyword kw">else</span>
283:                 <span class="ruby-identifier">out</span>.<span class="ruby-identifier">map</span>( <span class="ruby-identifier">taguri</span>, <span class="ruby-identifier">to_yaml_style</span> ) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">map</span><span class="ruby-operator">|</span>
284:                     <span class="ruby-identifier">src</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">inspect</span>
285:                     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">src</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/\A\/(.*)\/([a-z]*)\Z/</span>
286:                         <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>( <span class="ruby-value str">'regexp'</span>, <span class="ruby-identifier">$1</span> )
287:                         <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>( <span class="ruby-value str">'mods'</span>, <span class="ruby-identifier">$2</span> )
288:                     <span class="ruby-keyword kw">else</span>
289:                                 <span class="ruby-identifier">raise</span> <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-constant">TypeError</span>, <span class="ruby-value str">&quot;Invalid Regular expression: &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">src</span>
290:                     <span class="ruby-keyword kw">end</span>
291:                     <span class="ruby-identifier">to_yaml_properties</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
292:                         <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>( <span class="ruby-identifier">m</span>, <span class="ruby-identifier">instance_variable_get</span>( <span class="ruby-identifier">m</span> ) )
293:                     <span class="ruby-keyword kw">end</span>
294:                 <span class="ruby-keyword kw">end</span>
295:             <span class="ruby-keyword kw">end</span>
296:         <span class="ruby-keyword kw">end</span>
297:         <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M001226" class="method">
  <div id="M001226_title" class="title">
    <b>|</b>(other)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001226_source')" id="l_M001226_source">show source</a> ]</p>
  <div id="M001226_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/eregex.rb, line 26</span>
26:   <span class="ruby-keyword kw">def</span> <span class="ruby-operator">|</span>(<span class="ruby-identifier">other</span>)
27:     <span class="ruby-constant">RegOr</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">other</span>)
28:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M001218" class="method">
  <div id="M001218_title" class="title">
    <b>~ rxp   => integer or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Match&#8212;Matches <em>rxp</em> against the contents of <tt>$_</tt>.
Equivalent to <tt><em>rxp</em> =~ $_</tt>.
</p>
<pre>
   $_ = &quot;input data&quot;
   ~ /at/   #=&gt; 7
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001218_source')" id="l_M001218_source">show source</a> ]</p>
  <div id="M001218_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     ~ rxp   =&gt; integer or nil
 *  
 *  Match---Matches &lt;i&gt;rxp&lt;/i&gt; against the contents of &lt;code&gt;$_&lt;/code&gt;.
 *  Equivalent to &lt;code&gt;&lt;i&gt;rxp&lt;/i&gt; =~ $_&lt;/code&gt;.
 *     
 *     $_ = &quot;input data&quot;
 *     ~ /at/   #=&gt; 7
 */

VALUE
rb_reg_match2(re)
    VALUE re;
{
    long start;
    VALUE line = rb_lastline_get();

    if (TYPE(line) != T_STRING) {
        rb_backref_set(Qnil);
        return Qnil;
    }

    start = rb_reg_search(re, line, 0, 0);
    if (start &lt; 0) {
        return Qnil;
    }
    return LONG2FIX(start);
}
</pre>
  </div>
</div>
</div>
</div>

  </div>