  <div id="C00001016">
<div class='banner'>
  <span class="file-title-prefix">Module</span><br />Marshal<br/>
  In:
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/marshal_c.html');">ruby-1.8.7-p22/marshal.c</a>

</div>
 <!-- banner header -->

  <div id="bodyContent" >
      <div id="content">

  <div class="description"><p>
The marshaling library converts collections of Ruby objects into a byte
stream, allowing them to be stored outside the currently active script.
This data may subsequently be read and the original objects reconstituted.
Marshaled data has major and minor version numbers stored along with the
object information. In normal use, marshaling can only load data written
with the same major version number and an equal or lower minor version
number. If Ruby&#8217;s ``verbose&#8217;&#8217; flag is set (normally using
-d, -v, -w, or &#8212;verbose) the major and minor numbers must match
exactly. <a href="index.html?a=C00001016&name=Marshal">Marshal</a>
versioning is independent of Ruby&#8217;s version numbers. You can extract
the version by reading the first two bytes of marshaled data.
</p>
<pre>
    str = Marshal.dump(&quot;thing&quot;)
    RUBY_VERSION   #=&gt; &quot;1.8.0&quot;
    str[0]         #=&gt; 4
    str[1]         #=&gt; 8
</pre>
<p>
Some objects cannot be dumped: if the objects to be dumped include
bindings, procedure or method objects, instances of class <a
href="index.html?a=C00000245&name=IO">IO</a>, or singleton objects, a <a
href="index.html?a=C00000091&name=TypeError">TypeError</a> will be raised.
If your class has special serialization needs (for example, if you want to
serialize in some specific format), or if it contains objects that would
otherwise not be serializable, you can implement your own serialization
strategy by defining two methods, _dump and _load: The instance method
_dump should return a <a
href="index.html?a=C00000055&name=String">String</a> object containing all
the information necessary to reconstitute objects of this class and all
referenced objects up to a maximum depth given as an integer parameter (a
value of -1 implies that you should disable depth checking). The class
method _load should take a <a
href="index.html?a=C00000055&name=String">String</a> and return an object
of this class.
</p>
</div>



  <div class="sectiontitle">Methods</div>
  <ul>
  <li><a href="index.html?a=M005185&name=dump" >dump</a></li>
  <li><a href="index.html?a=M005186&name=load" >load</a></li>
  <li><a href="index.html?a=M005187&name=restore" >restore</a></li>
  </ul>




  <div class="sectiontitle">Constants</div>
  <table border='0' cellpadding='5'>
  <tr valign='top'>
    <td class="attr-name">MAJOR_VERSION</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(MARSHAL_MAJOR)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">MINOR_VERSION</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(MARSHAL_MINOR)</td>
  </tr>
  </table>


<div class="sectiontitle">Public Class methods</div>
<div id="M005185" class="method">
  <div id="M005185_title" class="title">
    <b>dump( obj [, anIO] , limit=--1 ) => anIO<br />
</b>
  </div>
  <div class="description">
  <p>
Serializes obj and all descendent objects. If anIO is specified, the
serialized data will be written to it, otherwise the data will be returned
as a <a href="index.html?a=C00000055&name=String">String</a>. If limit is
specified, the traversal of subobjects will be limited to that depth. If
limit is negative, no checking of depth will be performed.
</p>
<pre>
    class Klass
      def initialize(str)
        @str = str
      end
      def sayHello
        @str
      end
    end
</pre>
<p>
(produces no output)
</p>
<pre>
    o = Klass.new(&quot;hello\n&quot;)
    data = Marshal.dump(o)
    obj = Marshal.load(data)
    obj.sayHello   #=&gt; &quot;hello\n&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M005185_source')" id="l_M005185_source">show source</a> ]</p>
  <div id="M005185_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *      dump( obj [, anIO] , limit=--1 ) =&gt; anIO
 *
 * Serializes obj and all descendent objects. If anIO is
 * specified, the serialized data will be written to it, otherwise the
 * data will be returned as a String. If limit is specified, the
 * traversal of subobjects will be limited to that depth. If limit is
 * negative, no checking of depth will be performed.
 *
 *     class Klass
 *       def initialize(str)
 *         @str = str
 *       end
 *       def sayHello
 *         @str
 *       end
 *     end
 *
 * (produces no output)
 *
 *     o = Klass.new(&quot;hello\n&quot;)
 *     data = Marshal.dump(o)
 *     obj = Marshal.load(data)
 *     obj.sayHello   #=&gt; &quot;hello\n&quot;
 */
static VALUE
marshal_dump(argc, argv)
    int argc;
    VALUE* argv;
{
    VALUE obj, port, a1, a2;
    int limit = -1;
    struct dump_arg arg;
    struct dump_call_arg c_arg;

    port = Qnil;
    rb_scan_args(argc, argv, &quot;12&quot;, &amp;obj, &amp;a1, &amp;a2);
    if (argc == 3) {
        if (!NIL_P(a2)) limit = NUM2INT(a2);
        if (NIL_P(a1)) goto type_error;
        port = a1;
    }
    else if (argc == 2) {
        if (FIXNUM_P(a1)) limit = FIX2INT(a1);
        else if (NIL_P(a1)) goto type_error;
        else port = a1;
    }
    arg.dest = 0;
    arg.str = rb_str_buf_new(0);
    RBASIC(arg.str)-&gt;klass = 0;
    if (!NIL_P(port)) {
        if (!rb_obj_respond_to(port, s_write, Qtrue)) {
          type_error:
            rb_raise(rb_eTypeError, &quot;instance of IO needed&quot;);
        }
        arg.dest = port;
        if (rb_obj_respond_to(port, s_binmode, Qtrue)) {
            rb_funcall2(port, s_binmode, 0, 0);
            reentrant_check(arg.str, s_dump_data);
        }
    }
    else {
        port = arg.str;
    }

    arg.symbols = st_init_numtable();
    arg.data    = st_init_numtable();
    arg.taint   = Qfalse;
    c_arg.obj   = obj;
    c_arg.arg   = &amp;arg;
    c_arg.limit = limit;

    w_byte(MARSHAL_MAJOR, &amp;arg);
    w_byte(MARSHAL_MINOR, &amp;arg);

    rb_ensure(dump, (VALUE)&amp;c_arg, dump_ensure, (VALUE)&amp;arg);
    RBASIC(arg.str)-&gt;klass = rb_cString;

    return port;
}
</pre>
  </div>
</div>
</div>
<div id="M005186" class="method">
  <div id="M005186_title" class="title">
    <b>load( source [, proc] ) => obj<br />
restore( source [, proc] ) => obj<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the result of converting the serialized data in source into a Ruby
object (possibly with associated subordinate objects). source may be either
an instance of <a href="index.html?a=C00000245&name=IO">IO</a> or an object
that responds to to_str. If proc is specified, it will be passed each
object as it is deserialized.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M005186_source')" id="l_M005186_source">show source</a> ]</p>
  <div id="M005186_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *     load( source [, proc] ) =&gt; obj
 *     restore( source [, proc] ) =&gt; obj
 * 
 * Returns the result of converting the serialized data in source into a
 * Ruby object (possibly with associated subordinate objects). source
 * may be either an instance of IO or an object that responds to
 * to_str. If proc is specified, it will be passed each object as it
 * is deserialized.
 */
static VALUE
marshal_load(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE port, proc;
    int major, minor;
    VALUE v;
    struct load_arg arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;port, &amp;proc);
    v = rb_check_string_type(port);
    if (!NIL_P(v)) {
        arg.taint = OBJ_TAINTED(port); /* original taintedness */
        port = v;
    }
    else if (rb_obj_respond_to(port, s_getc, Qtrue) &amp;&amp; rb_obj_respond_to(port, s_read, Qtrue)) {
        if (rb_obj_respond_to(port, s_binmode, Qtrue)) {
            rb_funcall2(port, s_binmode, 0, 0);
        }
        arg.taint = Qtrue;
    }
    else {
        rb_raise(rb_eTypeError, &quot;instance of IO needed&quot;);
    }
    arg.src = port;
    arg.offset = 0;
    arg.data = 0;

    major = r_byte(&amp;arg);
    minor = r_byte(&amp;arg);
    if (major != MARSHAL_MAJOR || minor &gt; MARSHAL_MINOR) {
        rb_raise(rb_eTypeError, &quot;incompatible marshal file format (can't be read)\n\
\tformat version %d.%d required; %d.%d given&quot;,
                 MARSHAL_MAJOR, MARSHAL_MINOR, major, minor);
    }
    if (RTEST(ruby_verbose) &amp;&amp; minor != MARSHAL_MINOR) {
        rb_warn(&quot;incompatible marshal file format (can be read)\n\
\tformat version %d.%d required; %d.%d given&quot;,
                MARSHAL_MAJOR, MARSHAL_MINOR, major, minor);
    }

    arg.symbols = st_init_numtable();
    arg.data   = rb_hash_new();
    RBASIC(arg.data)-&gt;klass = 0;
    if (NIL_P(proc)) arg.proc = 0;
    else             arg.proc = proc;
    v = rb_ensure(load, (VALUE)&amp;arg, load_ensure, (VALUE)&amp;arg);
    RBASIC(arg.data)-&gt;klass = rb_cHash;

    return v;
}
</pre>
  </div>
</div>
</div>
<div id="M005187" class="method">
  <div id="M005187_title" class="title">
    <b>load( source [, proc] ) => obj<br />
restore( source [, proc] ) => obj<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the result of converting the serialized data in source into a Ruby
object (possibly with associated subordinate objects). source may be either
an instance of <a href="index.html?a=C00000245&name=IO">IO</a> or an object
that responds to to_str. If proc is specified, it will be passed each
object as it is deserialized.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M005187_source')" id="l_M005187_source">show source</a> ]</p>
  <div id="M005187_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *     load( source [, proc] ) =&gt; obj
 *     restore( source [, proc] ) =&gt; obj
 * 
 * Returns the result of converting the serialized data in source into a
 * Ruby object (possibly with associated subordinate objects). source
 * may be either an instance of IO or an object that responds to
 * to_str. If proc is specified, it will be passed each object as it
 * is deserialized.
 */
static VALUE
marshal_load(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE port, proc;
    int major, minor;
    VALUE v;
    struct load_arg arg;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;port, &amp;proc);
    v = rb_check_string_type(port);
    if (!NIL_P(v)) {
        arg.taint = OBJ_TAINTED(port); /* original taintedness */
        port = v;
    }
    else if (rb_obj_respond_to(port, s_getc, Qtrue) &amp;&amp; rb_obj_respond_to(port, s_read, Qtrue)) {
        if (rb_obj_respond_to(port, s_binmode, Qtrue)) {
            rb_funcall2(port, s_binmode, 0, 0);
        }
        arg.taint = Qtrue;
    }
    else {
        rb_raise(rb_eTypeError, &quot;instance of IO needed&quot;);
    }
    arg.src = port;
    arg.offset = 0;
    arg.data = 0;

    major = r_byte(&amp;arg);
    minor = r_byte(&amp;arg);
    if (major != MARSHAL_MAJOR || minor &gt; MARSHAL_MINOR) {
        rb_raise(rb_eTypeError, &quot;incompatible marshal file format (can't be read)\n\
\tformat version %d.%d required; %d.%d given&quot;,
                 MARSHAL_MAJOR, MARSHAL_MINOR, major, minor);
    }
    if (RTEST(ruby_verbose) &amp;&amp; minor != MARSHAL_MINOR) {
        rb_warn(&quot;incompatible marshal file format (can be read)\n\
\tformat version %d.%d required; %d.%d given&quot;,
                MARSHAL_MAJOR, MARSHAL_MINOR, major, minor);
    }

    arg.symbols = st_init_numtable();
    arg.data   = rb_hash_new();
    RBASIC(arg.data)-&gt;klass = 0;
    if (NIL_P(proc)) arg.proc = 0;
    else             arg.proc = proc;
    v = rb_ensure(load, (VALUE)&amp;arg, load_ensure, (VALUE)&amp;arg);
    RBASIC(arg.data)-&gt;klass = rb_cHash;

    return v;
}
</pre>
  </div>
</div>
</div>
</div>

  </div>