  <div id="C00000348">
<div class='banner'>
  <span class="file-title-prefix">Module</span><br />Process<br/>
  In:
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/process_c.html');">ruby-1.8.7-p22/process.c</a>

</div>
 <!-- banner header -->

  <div id="bodyContent" >
      <div id="content">

  <div class="description"><p>
The <tt><a href="index.html?a=C00000348&name=Process">Process</a></tt>
module is a collection of methods used to manipulate processes.
</p>
</div>



  <div class="sectiontitle">Methods</div>
  <ul>
  <li><a href="index.html?a=M003125&name=abort" >abort</a></li>
  <li><a href="index.html?a=M003132&name=detach" >detach</a></li>
  <li><a href="index.html?a=M003150&name=egid" >egid</a></li>
  <li><a href="index.html?a=M003151&name=egid=" >egid=</a></li>
  <li><a href="index.html?a=M003148&name=euid" >euid</a></li>
  <li><a href="index.html?a=M003149&name=euid=" >euid=</a></li>
  <li><a href="index.html?a=M003121&name=exec" >exec</a></li>
  <li><a href="index.html?a=M003124&name=exit" >exit</a></li>
  <li><a href="index.html?a=M003123&name=exit!" >exit!</a></li>
  <li><a href="index.html?a=M003122&name=fork" >fork</a></li>
  <li><a href="index.html?a=M003137&name=getpgid" >getpgid</a></li>
  <li><a href="index.html?a=M003135&name=getpgrp" >getpgrp</a></li>
  <li><a href="index.html?a=M003140&name=getpriority" >getpriority</a></li>
  <li><a href="index.html?a=M003142&name=getrlimit" >getrlimit</a></li>
  <li><a href="index.html?a=M003146&name=gid" >gid</a></li>
  <li><a href="index.html?a=M003147&name=gid=" >gid=</a></li>
  <li><a href="index.html?a=M003153&name=groups" >groups</a></li>
  <li><a href="index.html?a=M003154&name=groups=" >groups=</a></li>
  <li><a href="index.html?a=M003152&name=initgroups" >initgroups</a></li>
  <li><a href="index.html?a=M003126&name=kill" >kill</a></li>
  <li><a href="index.html?a=M003155&name=maxgroups" >maxgroups</a></li>
  <li><a href="index.html?a=M003156&name=maxgroups=" >maxgroups=</a></li>
  <li><a href="index.html?a=M003133&name=pid" >pid</a></li>
  <li><a href="index.html?a=M003134&name=ppid" >ppid</a></li>
  <li><a href="index.html?a=M003138&name=setpgid" >setpgid</a></li>
  <li><a href="index.html?a=M003136&name=setpgrp" >setpgrp</a></li>
  <li><a href="index.html?a=M003141&name=setpriority" >setpriority</a></li>
  <li><a href="index.html?a=M003143&name=setrlimit" >setrlimit</a></li>
  <li><a href="index.html?a=M003139&name=setsid" >setsid</a></li>
  <li><a href="index.html?a=M003157&name=times" >times</a></li>
  <li><a href="index.html?a=M003144&name=uid" >uid</a></li>
  <li><a href="index.html?a=M003145&name=uid=" >uid=</a></li>
  <li><a href="index.html?a=M003127&name=wait" >wait</a></li>
  <li><a href="index.html?a=M003128&name=wait2" >wait2</a></li>
  <li><a href="index.html?a=M003131&name=waitall" >waitall</a></li>
  <li><a href="index.html?a=M003129&name=waitpid" >waitpid</a></li>
  <li><a href="index.html?a=M003130&name=waitpid2" >waitpid2</a></li>
  </ul>



  <div class="sectiontitle">Classes and Modules</div>
  Module "<a href="#" onclick="jsHref('classes/Process/GID.html');" class="link">Process::GID</a>"<br />
Module "<a href="#" onclick="jsHref('classes/Process/Sys.html');" class="link">Process::Sys</a>"<br />
Module "<a href="#" onclick="jsHref('classes/Process/UID.html');" class="link">Process::UID</a>"<br />
Class "<a href="#" onclick="jsHref('classes/Process/Status.html');" class="link">Process::Status</a>"<br />


  <div class="sectiontitle">Constants</div>
  <table border='0' cellpadding='5'>
  <tr valign='top'>
    <td class="attr-name">WNOHANG</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(WNOHANG)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">WNOHANG</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(0)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">WUNTRACED</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(WUNTRACED)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">WUNTRACED</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(0)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">PRIO_PROCESS</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(PRIO_PROCESS)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">PRIO_PGRP</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(PRIO_PGRP)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">PRIO_USER</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(PRIO_USER)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIM_INFINITY</td>
    <td>=</td>
    <td class="attr-value">inf</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIM_SAVED_MAX</td>
    <td>=</td>
    <td class="attr-value">v</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIM_SAVED_CUR</td>
    <td>=</td>
    <td class="attr-value">v</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_CORE</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_CORE)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_CPU</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_CPU)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_DATA</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_DATA)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_FSIZE</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_FSIZE)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_NOFILE</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_NOFILE)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_STACK</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_STACK)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_AS</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_AS)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_MEMLOCK</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_MEMLOCK)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_NPROC</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_NPROC)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_RSS</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_RSS)</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RLIMIT_SBSIZE</td>
    <td>=</td>
    <td class="attr-value">INT2FIX(RLIMIT_SBSIZE)</td>
  </tr>
  </table>


<div class="sectiontitle">Public Class methods</div>
<div id="M003125" class="method">
  <div id="M003125_title" class="title">
    <b>abort<br />
Kernel::abort<br />
Process::abort<br />
</b>
  </div>
  <div class="description">
  <p>
Terminate execution immediately, effectively by calling <tt><a
href="index.html?a=M006181&name=Kernel.exit">Kernel.exit</a>(1)</tt>. If
<em>msg</em> is given, it is written to STDERR prior to terminating.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003125_source')" id="l_M003125_source">show source</a> ]</p>
  <div id="M003125_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     abort
 *     Kernel::abort
 *     Process::abort
 *  
 *  Terminate execution immediately, effectively by calling
 *  &lt;code&gt;Kernel.exit(1)&lt;/code&gt;. If _msg_ is given, it is written
 *  to STDERR prior to terminating.
 */

VALUE
rb_f_abort(argc, argv)
    int argc;
    VALUE *argv;
{
    rb_secure(4);
    if (argc == 0) {
	if (!NIL_P(ruby_errinfo)) {
	    error_print();
	}
	rb_exit(EXIT_FAILURE);
    }
    else {
	VALUE mesg;

	rb_scan_args(argc, argv, &quot;1&quot;, &amp;mesg);
	StringValue(mesg);
	rb_io_puts(1, &amp;mesg, rb_stderr);
	terminate_process(EXIT_FAILURE, mesg);
    }
    return Qnil;		/* not reached */
}
</pre>
  </div>
</div>
</div>
<div id="M003132" class="method">
  <div id="M003132_title" class="title">
    <b>Process.detach(pid)   => thread<br />
</b>
  </div>
  <div class="description">
  <p>
Some operating systems retain the status of terminated child processes
until the parent collects that status (normally using some variant of
<tt>wait()</tt>. If the parent never collects this status, the child stays
around as a <em>zombie</em> process. <tt>Process::detach</tt> prevents this
by setting up a separate Ruby thread whose sole job is to reap the status
of the process <em>pid</em> when it terminates. Use <tt>detach</tt> only
when you do not intent to explicitly wait for the child to terminate.
<tt>detach</tt> only checks the status periodically (currently once each
second).
</p>
<p>
The waiting thread returns the exit status of the detached process when it
terminates, so you can use <tt><a
href="index.html?a=M000439&name=Thread#join">Thread#join</a></tt> to know
the result. If specified <em>pid</em> is not a valid child process ID, the
thread returns <tt>nil</tt> immediately.
</p>
<p>
In this first example, we don&#8217;t reap the first child process, so it
appears as a zombie in the process status display.
</p>
<pre>
   p1 = fork { sleep 0.1 }
   p2 = fork { sleep 0.2 }
   Process.waitpid(p2)
   sleep 2
   system(&quot;ps -ho pid,state -p #{p1}&quot;)
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   27389 Z
</pre>
<p>
In the next example, <tt>Process::detach</tt> is used to reap the child
automatically.
</p>
<pre>
   p1 = fork { sleep 0.1 }
   p2 = fork { sleep 0.2 }
   Process.detach(p1)
   Process.waitpid(p2)
   sleep 2
   system(&quot;ps -ho pid,state -p #{p1}&quot;)
</pre>
<p>
<em>(produces no output)</em>
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003132_source')" id="l_M003132_source">show source</a> ]</p>
  <div id="M003132_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.detach(pid)   =&gt; thread
 *
 *  Some operating systems retain the status of terminated child
 *  processes until the parent collects that status (normally using
 *  some variant of &lt;code&gt;wait()&lt;/code&gt;. If the parent never collects
 *  this status, the child stays around as a &lt;em&gt;zombie&lt;/em&gt; process.
 *  &lt;code&gt;Process::detach&lt;/code&gt; prevents this by setting up a
 *  separate Ruby thread whose sole job is to reap the status of the
 *  process _pid_ when it terminates. Use &lt;code&gt;detach&lt;/code&gt;
 *  only when you do not intent to explicitly wait for the child to
 *  terminate.  &lt;code&gt;detach&lt;/code&gt; only checks the status
 *  periodically (currently once each second).
 *
 *  The waiting thread returns the exit status of the detached process
 *  when it terminates, so you can use &lt;code&gt;Thread#join&lt;/code&gt; to
 *  know the result.  If specified _pid_ is not a valid child process
 *  ID, the thread returns +nil+ immediately.
 *
 *  In this first example, we don't reap the first child process, so
 *  it appears as a zombie in the process status display.
 *
 *     p1 = fork { sleep 0.1 }
 *     p2 = fork { sleep 0.2 }
 *     Process.waitpid(p2)
 *     sleep 2
 *     system(&quot;ps -ho pid,state -p #{p1}&quot;)
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     27389 Z
 *
 *  In the next example, &lt;code&gt;Process::detach&lt;/code&gt; is used to reap
 *  the child automatically.
 *
 *     p1 = fork { sleep 0.1 }
 *     p2 = fork { sleep 0.2 }
 *     Process.detach(p1)
 *     Process.waitpid(p2)
 *     sleep 2
 *     system(&quot;ps -ho pid,state -p #{p1}&quot;)
 *
 *  &lt;em&gt;(produces no output)&lt;/em&gt;
 */

static VALUE
proc_detach(VALUE obj, VALUE pid)
{
    rb_secure(2);
    return rb_detach_process(NUM2INT(pid));
}
</pre>
  </div>
</div>
</div>
<div id="M003150" class="method">
  <div id="M003150_title" class="title">
    <b>Process.egid          => fixnum<br />
Process::GID.eid      => fixnum<br />
Process::Sys.geteid   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the effective group ID for this process. Not available on all
platforms.
</p>
<pre>
   Process.egid   #=&gt; 500
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003150_source')" id="l_M003150_source">show source</a> ]</p>
  <div id="M003150_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.egid          =&gt; fixnum
 *     Process::GID.eid      =&gt; fixnum
 *     Process::Sys.geteid   =&gt; fixnum
 *
 *  Returns the effective group ID for this process. Not available on
 *  all platforms.
 *
 *     Process.egid   #=&gt; 500
 */

static VALUE
proc_getegid(obj)
    VALUE obj;
{
    int egid = getegid();

    return INT2FIX(egid);
}
</pre>
  </div>
</div>
</div>
<div id="M003151" class="method">
  <div id="M003151_title" class="title">
    <b>Process.egid = fixnum   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Sets the effective group ID for this process. Not available on all
platforms.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003151_source')" id="l_M003151_source">show source</a> ]</p>
  <div id="M003151_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.egid = fixnum   =&gt; fixnum
 *
 *  Sets the effective group ID for this process. Not available on all
 *  platforms.
 */

static VALUE
proc_setegid(obj, egid)
    VALUE obj, egid;
{
    check_gid_switch();

#if defined(HAVE_SETRESGID) &amp;&amp; !defined(__CHECKER__)
    if (setresgid(-1, NUM2INT(egid), -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREGID
    if (setregid(-1, NUM2INT(egid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETEGID
    if (setegid(NUM2INT(egid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETGID
    egid = NUM2INT(egid);
    if (egid == getgid()) {
        if (setgid(egid) &lt; 0) rb_sys_fail(0);
    }
    else {
        rb_notimplement();
    }
#else
    rb_notimplement();
#endif
    return egid;
}
</pre>
  </div>
</div>
</div>
<div id="M003148" class="method">
  <div id="M003148_title" class="title">
    <b>Process.euid           => fixnum<br />
Process::UID.eid       => fixnum<br />
Process::Sys.geteuid   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the effective user ID for this process.
</p>
<pre>
   Process.euid   #=&gt; 501
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003148_source')" id="l_M003148_source">show source</a> ]</p>
  <div id="M003148_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.euid           =&gt; fixnum
 *     Process::UID.eid       =&gt; fixnum
 *     Process::Sys.geteuid   =&gt; fixnum
 *
 *  Returns the effective user ID for this process.
 *
 *     Process.euid   #=&gt; 501
 */

static VALUE
proc_geteuid(obj)
    VALUE obj;
{
    int euid = geteuid();
    return INT2FIX(euid);
}
</pre>
  </div>
</div>
</div>
<div id="M003149" class="method">
  <div id="M003149_title" class="title">
    <b>Process.euid= integer<br />
</b>
  </div>
  <div class="description">
  <p>
Sets the effective user ID for this process. Not available on all
platforms.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003149_source')" id="l_M003149_source">show source</a> ]</p>
  <div id="M003149_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.euid= integer
 *
 *  Sets the effective user ID for this process. Not available on all
 *  platforms.
 */

static VALUE
proc_seteuid(obj, euid)
    VALUE obj, euid;
{
    check_uid_switch();
#if defined(HAVE_SETRESUID) &amp;&amp; !defined(__CHECKER__)
    if (setresuid(-1, NUM2INT(euid), -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREUID
    if (setreuid(-1, NUM2INT(euid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETEUID
    if (seteuid(NUM2INT(euid)) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETUID
    euid = NUM2INT(euid);
    if (euid == getuid()) {
        if (setuid(euid) &lt; 0) rb_sys_fail(0);
    }
    else {
        rb_notimplement();
    }
#else
    rb_notimplement();
#endif
    return euid;
}
</pre>
  </div>
</div>
</div>
<div id="M003121" class="method">
  <div id="M003121_title" class="title">
    <b>exec(command [, arg, ...])<br />
</b>
  </div>
  <div class="description">
  <p>
Replaces the current process by running the given external
<em>command</em>. If <tt>exec</tt> is given a single argument, that
argument is taken as a line that is subject to shell expansion before being
executed. If multiple arguments are given, the second and subsequent
arguments are passed as parameters to <em>command</em> with no shell
expansion. If the first argument is a two-element array, the first element
is the command to be executed, and the second argument is used as the
<tt>argv[0]</tt> value, which may show up in process listings. In MSDOS
environments, the command is executed in a subshell; otherwise, one of the
<tt>exec(2)</tt> system calls is used, so the running command may inherit
some of the environment of the original program (including open file
descriptors).
</p>
<pre>
   exec &quot;echo *&quot;       # echoes list of files in current directory
   # never get here

   exec &quot;echo&quot;, &quot;*&quot;    # echoes an asterisk
   # never get here
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003121_source')" id="l_M003121_source">show source</a> ]</p>
  <div id="M003121_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     exec(command [, arg, ...])
 *
 *  Replaces the current process by running the given external _command_.
 *  If +exec+ is given a single argument, that argument is
 *  taken as a line that is subject to shell expansion before being
 *  executed. If multiple arguments are given, the second and subsequent
 *  arguments are passed as parameters to _command_ with no shell
 *  expansion. If the first argument is a two-element array, the first
 *  element is the command to be executed, and the second argument is
 *  used as the &lt;code&gt;argv[0]&lt;/code&gt; value, which may show up in process
 *  listings. In MSDOS environments, the command is executed in a
 *  subshell; otherwise, one of the &lt;code&gt;exec(2)&lt;/code&gt; system calls is
 *  used, so the running command may inherit some of the environment of
 *  the original program (including open file descriptors).
 *
 *     exec &quot;echo *&quot;       # echoes list of files in current directory
 *     # never get here
 *
 *
 *     exec &quot;echo&quot;, &quot;*&quot;    # echoes an asterisk
 *     # never get here
 */

VALUE
rb_f_exec(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE prog = 0;
    VALUE tmp;
    struct rb_exec_arg earg;

    if (argc == 0) {
        rb_last_status = Qnil;
        rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }

    tmp = rb_check_array_type(argv[0]);
    if (!NIL_P(tmp)) {
        if (RARRAY(tmp)-&gt;len != 2) {
            rb_raise(rb_eArgError, &quot;wrong first argument&quot;);
        }
        prog = RARRAY(tmp)-&gt;ptr[0];
        argv[0] = RARRAY(tmp)-&gt;ptr[1];
        SafeStringValue(prog);
    }
    proc_prepare_args(&amp;earg, argc, argv, prog);
    proc_exec_args((VALUE)&amp;earg);
    rb_sys_fail(RSTRING(argv[0])-&gt;ptr);
    return Qnil;                /* dummy */
}
</pre>
  </div>
</div>
</div>
<div id="M003124" class="method">
  <div id="M003124_title" class="title">
    <b>exit(integer=0)<br />
Kernel::exit(integer=0)<br />
Process::exit(integer=0)<br />
</b>
  </div>
  <div class="description">
  <p>
Initiates the termination of the Ruby script by raising the <tt><a
href="index.html?a=C00000098&name=SystemExit">SystemExit</a></tt>
exception. This exception may be caught. The optional parameter is used to
return a status code to the invoking environment.
</p>
<pre>
   begin
     exit
     puts &quot;never get here&quot;
   rescue SystemExit
     puts &quot;rescued a SystemExit exception&quot;
   end
   puts &quot;after begin block&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   rescued a SystemExit exception
   after begin block
</pre>
<p>
Just prior to termination, Ruby executes any <tt>at_exit</tt> functions
(see Kernel::at_exit) and runs any object finalizers (see
ObjectSpace::define_finalizer).
</p>
<pre>
   at_exit { puts &quot;at_exit function&quot; }
   ObjectSpace.define_finalizer(&quot;string&quot;,  proc { puts &quot;in finalizer&quot; })
   exit
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   at_exit function
   in finalizer
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003124_source')" id="l_M003124_source">show source</a> ]</p>
  <div id="M003124_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     exit(integer=0)
 *     Kernel::exit(integer=0)
 *     Process::exit(integer=0)
 *  
 *  Initiates the termination of the Ruby script by raising the
 *  &lt;code&gt;SystemExit&lt;/code&gt; exception. This exception may be caught. The
 *  optional parameter is used to return a status code to the invoking
 *  environment.
 *     
 *     begin
 *       exit
 *       puts &quot;never get here&quot;
 *     rescue SystemExit
 *       puts &quot;rescued a SystemExit exception&quot;
 *     end
 *     puts &quot;after begin block&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     rescued a SystemExit exception
 *     after begin block
 *     
 *  Just prior to termination, Ruby executes any &lt;code&gt;at_exit&lt;/code&gt; functions
 *  (see Kernel::at_exit) and runs any object finalizers (see
 *  ObjectSpace::define_finalizer).
 *     
 *     at_exit { puts &quot;at_exit function&quot; }
 *     ObjectSpace.define_finalizer(&quot;string&quot;,  proc { puts &quot;in finalizer&quot; })
 *     exit
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     at_exit function
 *     in finalizer
 */

VALUE
rb_f_exit(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE status;
    int istatus;

    rb_secure(4);
    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;status) == 1) {
	switch (status) {
	  case Qtrue:
	    istatus = EXIT_SUCCESS;
	    break;
	  case Qfalse:
	    istatus = EXIT_FAILURE;
	    break;
	  default:
	    istatus = NUM2INT(status);
#if EXIT_SUCCESS != 0
	    if (istatus == 0) istatus = EXIT_SUCCESS;
#endif
	    break;
	}
    }
    else {
	istatus = EXIT_SUCCESS;
    }
    rb_exit(istatus);
    return Qnil;		/* not reached */
}
</pre>
  </div>
</div>
</div>
<div id="M003123" class="method">
  <div id="M003123_title" class="title">
    <b>Process.exit!(fixnum=-1)<br />
</b>
  </div>
  <div class="description">
  <p>
Exits the process immediately. No exit handlers are run. <em>fixnum</em> is
returned to the underlying system as the exit status.
</p>
<pre>
   Process.exit!(0)
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003123_source')" id="l_M003123_source">show source</a> ]</p>
  <div id="M003123_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.exit!(fixnum=-1)
 *
 *  Exits the process immediately. No exit handlers are
 *  run. &lt;em&gt;fixnum&lt;/em&gt; is returned to the underlying system as the
 *  exit status.
 *
 *     Process.exit!(0)
 */

static VALUE
rb_f_exit_bang(argc, argv, obj)
    int argc;
    VALUE *argv;
    VALUE obj;
{
    VALUE status;
    int istatus;

    rb_secure(4);
    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;status) == 1) {
        switch (status) {
          case Qtrue:
            istatus = EXIT_SUCCESS;
            break;
          case Qfalse:
            istatus = EXIT_FAILURE;
            break;
          default:
            istatus = NUM2INT(status);
            break;
        }
    }
    else {
        istatus = EXIT_FAILURE;
    }
    _exit(istatus);

    return Qnil;                /* not reached */
}
</pre>
  </div>
</div>
</div>
<div id="M003122" class="method">
  <div id="M003122_title" class="title">
    <b>Kernel.fork  [{ block }]   => fixnum or nil<br />
Process.fork [{ block }]   => fixnum or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Creates a subprocess. If a block is specified, that block is run in the
subprocess, and the subprocess terminates with a status of zero. Otherwise,
the <tt>fork</tt> call returns twice, once in the parent, returning the
process ID of the child, and once in the child, returning <em>nil</em>. The
child process can exit using <tt><a
href="index.html?a=M006181&name=Kernel.exit">Kernel.exit</a>!</tt> to avoid
running any <tt>at_exit</tt> functions. The parent process should use
<tt><a href="index.html?a=M003127&name=Process.wait">Process.wait</a></tt>
to collect the termination statuses of its children or use <tt><a
href="index.html?a=M003132&name=Process.detach">Process.detach</a></tt> to
register disinterest in their status; otherwise, the operating system may
accumulate zombie processes.
</p>
<p>
The thread calling fork is the only thread in the created child process.
fork doesn&#8217;t copy other threads.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003122_source')" id="l_M003122_source">show source</a> ]</p>
  <div id="M003122_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Kernel.fork  [{ block }]   =&gt; fixnum or nil
 *     Process.fork [{ block }]   =&gt; fixnum or nil
 *
 *  Creates a subprocess. If a block is specified, that block is run
 *  in the subprocess, and the subprocess terminates with a status of
 *  zero. Otherwise, the +fork+ call returns twice, once in
 *  the parent, returning the process ID of the child, and once in
 *  the child, returning _nil_. The child process can exit using
 *  &lt;code&gt;Kernel.exit!&lt;/code&gt; to avoid running any
 *  &lt;code&gt;at_exit&lt;/code&gt; functions. The parent process should
 *  use &lt;code&gt;Process.wait&lt;/code&gt; to collect the termination statuses
 *  of its children or use &lt;code&gt;Process.detach&lt;/code&gt; to register
 *  disinterest in their status; otherwise, the operating system
 *  may accumulate zombie processes.
 *
 *  The thread calling fork is the only thread in the created child process.
 *  fork doesn't copy other threads.
 */

static VALUE
rb_f_fork(obj)
    VALUE obj;
{
#if !defined(__human68k__) &amp;&amp; !defined(_WIN32) &amp;&amp; !defined(__MACOS__) &amp;&amp; !defined(__EMX__) &amp;&amp; !defined(__VMS)
    int pid;

    rb_secure(2);

#ifndef __VMS
    fflush(stdout);
    fflush(stderr);
#endif

    switch (pid = fork()) {
      case 0:
#ifdef linux
        after_exec();
#endif
        rb_thread_atfork();
        if (rb_block_given_p()) {
            int status;

            rb_protect(rb_yield, Qundef, &amp;status);
            ruby_stop(status);
        }
        return Qnil;

      case -1:
        rb_sys_fail(&quot;fork(2)&quot;);
        return Qnil;

      default:
        return INT2FIX(pid);
    }
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003137" class="method">
  <div id="M003137_title" class="title">
    <b>Process.getpgid(pid)   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the process group ID for the given process id. Not available on all
platforms.
</p>
<pre>
   Process.getpgid(Process.ppid())   #=&gt; 25527
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003137_source')" id="l_M003137_source">show source</a> ]</p>
  <div id="M003137_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.getpgid(pid)   =&gt; integer
 *
 *  Returns the process group ID for the given process id. Not
 *  available on all platforms.
 *
 *     Process.getpgid(Process.ppid())   #=&gt; 25527
 */

static VALUE
proc_getpgid(obj, pid)
    VALUE obj, pid;
{
#if defined(HAVE_GETPGID) &amp;&amp; !defined(__CHECKER__)
    int i;

    rb_secure(2);
    i = getpgid(NUM2INT(pid));
    if (i &lt; 0) rb_sys_fail(0);
    return INT2NUM(i);
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003135" class="method">
  <div id="M003135_title" class="title">
    <b>Process.getpgrp   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the process group ID for this process. Not available on all
platforms.
</p>
<pre>
   Process.getpgid(0)   #=&gt; 25527
   Process.getpgrp      #=&gt; 25527
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003135_source')" id="l_M003135_source">show source</a> ]</p>
  <div id="M003135_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.getpgrp   =&gt; integer
 *
 *  Returns the process group ID for this process. Not available on
 *  all platforms.
 *
 *     Process.getpgid(0)   #=&gt; 25527
 *     Process.getpgrp      #=&gt; 25527
 */

static VALUE
proc_getpgrp()
{
#if defined(HAVE_GETPGRP) &amp;&amp; defined(GETPGRP_VOID)
    int pgrp;
#endif

    rb_secure(2);
#if defined(HAVE_GETPGRP) &amp;&amp; defined(GETPGRP_VOID)
    pgrp = getpgrp();
    if (pgrp &lt; 0) rb_sys_fail(0);
    return INT2FIX(pgrp);
#else
# ifdef HAVE_GETPGID
    pgrp = getpgid(0);
    if (pgrp &lt; 0) rb_sys_fail(0);
    return INT2FIX(pgrp);
# else
    rb_notimplement();
# endif
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003140" class="method">
  <div id="M003140_title" class="title">
    <b>Process.getpriority(kind, integer)   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Gets the scheduling priority for specified process, process group, or user.
<em>kind</em> indicates the kind of entity to find: one of
<tt>Process::PRIO_PGRP</tt>, <tt>Process::PRIO_USER</tt>, or
<tt>Process::PRIO_PROCESS</tt>. <em>integer</em> is an id indicating the
particular process, process group, or user (an id of 0 means
<em>current</em>). Lower priorities are more favorable for scheduling. Not
available on all platforms.
</p>
<pre>
   Process.getpriority(Process::PRIO_USER, 0)      #=&gt; 19
   Process.getpriority(Process::PRIO_PROCESS, 0)   #=&gt; 19
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003140_source')" id="l_M003140_source">show source</a> ]</p>
  <div id="M003140_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.getpriority(kind, integer)   =&gt; fixnum
 *
 *  Gets the scheduling priority for specified process, process group,
 *  or user. &lt;em&gt;kind&lt;/em&gt; indicates the kind of entity to find: one
 *  of &lt;code&gt;Process::PRIO_PGRP&lt;/code&gt;,
 *  &lt;code&gt;Process::PRIO_USER&lt;/code&gt;, or
 *  &lt;code&gt;Process::PRIO_PROCESS&lt;/code&gt;. _integer_ is an id
 *  indicating the particular process, process group, or user (an id
 *  of 0 means _current_). Lower priorities are more favorable
 *  for scheduling. Not available on all platforms.
 *
 *     Process.getpriority(Process::PRIO_USER, 0)      #=&gt; 19
 *     Process.getpriority(Process::PRIO_PROCESS, 0)   #=&gt; 19
 */

static VALUE
proc_getpriority(obj, which, who)
    VALUE obj, which, who;
{
#ifdef HAVE_GETPRIORITY
    int prio, iwhich, iwho;

    rb_secure(2);
    iwhich = NUM2INT(which);
    iwho   = NUM2INT(who);

    errno = 0;
    prio = getpriority(iwhich, iwho);
    if (errno) rb_sys_fail(0);
    return INT2FIX(prio);
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003142" class="method">
  <div id="M003142_title" class="title">
    <b>Process.getrlimit(resource)   => [cur_limit, max_limit]<br />
</b>
  </div>
  <div class="description">
  <p>
Gets the resource limit of the process. <em>cur_limit</em> means current
(soft) limit and <em>max_limit</em> means maximum (hard) limit.
</p>
<p>
<em>resource</em> indicates the kind of resource to limit: such as
<tt>Process::RLIMIT_CORE</tt>, <tt>Process::RLIMIT_CPU</tt>, etc. See <a
href="index.html?a=M003143&name=Process.setrlimit">Process.setrlimit</a>
for details.
</p>
<p>
<em>cur_limit</em> and <em>max_limit</em> may be
<tt>Process::RLIM_INFINITY</tt>, <tt>Process::RLIM_SAVED_MAX</tt> or
<tt>Process::RLIM_SAVED_CUR</tt>. See <a
href="index.html?a=M003143&name=Process.setrlimit">Process.setrlimit</a>
and the system getrlimit(2) manual for details.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003142_source')" id="l_M003142_source">show source</a> ]</p>
  <div id="M003142_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.getrlimit(resource)   =&gt; [cur_limit, max_limit]
 *
 *  Gets the resource limit of the process.
 *  _cur_limit_ means current (soft) limit and
 *  _max_limit_ means maximum (hard) limit.
 *
 *  _resource_ indicates the kind of resource to limit:
 *  such as &lt;code&gt;Process::RLIMIT_CORE&lt;/code&gt;,
 *  &lt;code&gt;Process::RLIMIT_CPU&lt;/code&gt;, etc.
 *  See Process.setrlimit for details.
 *
 *  _cur_limit_ and _max_limit_ may be &lt;code&gt;Process::RLIM_INFINITY&lt;/code&gt;,
 *  &lt;code&gt;Process::RLIM_SAVED_MAX&lt;/code&gt; or
 *  &lt;code&gt;Process::RLIM_SAVED_CUR&lt;/code&gt;.
 *  See Process.setrlimit and the system getrlimit(2) manual for details.
 */

static VALUE
proc_getrlimit(VALUE obj, VALUE resource)
{
#if defined(HAVE_GETRLIMIT) &amp;&amp; defined(RLIM2NUM)
    struct rlimit rlim;

    rb_secure(2);

    if (getrlimit(NUM2INT(resource), &amp;rlim) &lt; 0) {
        rb_sys_fail(&quot;getrlimit&quot;);
    }
    return rb_assoc_new(RLIM2NUM(rlim.rlim_cur), RLIM2NUM(rlim.rlim_max));
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003146" class="method">
  <div id="M003146_title" class="title">
    <b>Process.gid           => fixnum<br />
Process::GID.rid      => fixnum<br />
Process::Sys.getgid   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the (real) group ID for this process.
</p>
<pre>
   Process.gid   #=&gt; 500
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003146_source')" id="l_M003146_source">show source</a> ]</p>
  <div id="M003146_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.gid           =&gt; fixnum
 *     Process::GID.rid      =&gt; fixnum
 *     Process::Sys.getgid   =&gt; fixnum
 *
 *  Returns the (real) group ID for this process.
 *
 *     Process.gid   #=&gt; 500
 */

static VALUE
proc_getgid(obj)
    VALUE obj;
{
    int gid = getgid();
    return INT2FIX(gid);
}
</pre>
  </div>
</div>
</div>
<div id="M003147" class="method">
  <div id="M003147_title" class="title">
    <b>Process.gid= fixnum   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Sets the group ID for this process.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003147_source')" id="l_M003147_source">show source</a> ]</p>
  <div id="M003147_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.gid= fixnum   =&gt; fixnum
 *
 *  Sets the group ID for this process.
 */

static VALUE
proc_setgid(obj, id)
    VALUE obj, id;
{
    int gid = NUM2INT(id);

    check_gid_switch();
#if defined(HAVE_SETRESGID) &amp;&amp; !defined(__CHECKER__)
    if (setresgid(gid, -1, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREGID
    if (setregid(gid, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETRGID
    if (setrgid(gid) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETGID
    {
        if (getegid() == gid) {
            if (setgid(gid) &lt; 0) rb_sys_fail(0);
        }
        else {
            rb_notimplement();
        }
    }
#else
    rb_notimplement();
#endif
    return INT2FIX(gid);
}
</pre>
  </div>
</div>
</div>
<div id="M003153" class="method">
  <div id="M003153_title" class="title">
    <b>Process.groups   => array<br />
</b>
  </div>
  <div class="description">
  <p>
Get an <tt><a href="index.html?a=C00000243&name=Array">Array</a></tt> of
the gids of groups in the supplemental group access list for this process.
</p>
<pre>
   Process.groups   #=&gt; [27, 6, 10, 11]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003153_source')" id="l_M003153_source">show source</a> ]</p>
  <div id="M003153_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.groups   =&gt; array
 *
 *  Get an &lt;code&gt;Array&lt;/code&gt; of the gids of groups in the
 *  supplemental group access list for this process.
 *
 *     Process.groups   #=&gt; [27, 6, 10, 11]
 *
 */

static VALUE
proc_getgroups(VALUE obj)
{
#ifdef HAVE_GETGROUPS
    VALUE ary;
    size_t ngroups;
    rb_gid_t *groups;
    int i;

    groups = ALLOCA_N(rb_gid_t, maxgroups);

    ngroups = getgroups(maxgroups, groups);
    if (ngroups == -1)
        rb_sys_fail(0);

    ary = rb_ary_new();
    for (i = 0; i &lt; ngroups; i++)
        rb_ary_push(ary, INT2NUM(groups[i]));

    return ary;
#else
    rb_notimplement();
    return Qnil;
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003154" class="method">
  <div id="M003154_title" class="title">
    <b>Process.groups= array   => array<br />
</b>
  </div>
  <div class="description">
  <p>
<a href="index.html?a=C00000201&name=Set">Set</a> the supplemental group
access list to the given <tt><a
href="index.html?a=C00000243&name=Array">Array</a></tt> of group IDs.
</p>
<pre>
   Process.groups   #=&gt; [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
   Process.groups = [27, 6, 10, 11]   #=&gt; [27, 6, 10, 11]
   Process.groups   #=&gt; [27, 6, 10, 11]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003154_source')" id="l_M003154_source">show source</a> ]</p>
  <div id="M003154_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.groups= array   =&gt; array
 *
 *  Set the supplemental group access list to the given
 *  &lt;code&gt;Array&lt;/code&gt; of group IDs.
 *
 *     Process.groups   #=&gt; [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
 *     Process.groups = [27, 6, 10, 11]   #=&gt; [27, 6, 10, 11]
 *     Process.groups   #=&gt; [27, 6, 10, 11]
 *
 */

static VALUE
proc_setgroups(VALUE obj, VALUE ary)
{
#ifdef HAVE_SETGROUPS
    size_t ngroups;
    rb_gid_t *groups;
    int i;
    struct group *gr;

    Check_Type(ary, T_ARRAY);

    ngroups = RARRAY(ary)-&gt;len;
    if (ngroups &gt; maxgroups)
        rb_raise(rb_eArgError, &quot;too many groups, %d max&quot;, maxgroups);

    groups = ALLOCA_N(rb_gid_t, ngroups);

    for (i = 0; i &lt; ngroups &amp;&amp; i &lt; RARRAY(ary)-&gt;len; i++) {
        VALUE g = RARRAY(ary)-&gt;ptr[i];

        if (FIXNUM_P(g)) {
            groups[i] = FIX2INT(g);
        }
        else {
            VALUE tmp = rb_check_string_type(g);

            if (NIL_P(tmp)) {
                groups[i] = NUM2INT(g);
            }
            else {
                gr = getgrnam(RSTRING(tmp)-&gt;ptr);
                if (gr == NULL)
                    rb_raise(rb_eArgError,
                             &quot;can't find group for %s&quot;, RSTRING(tmp)-&gt;ptr);
                groups[i] = gr-&gt;gr_gid;
            }
        }
    }

    i = setgroups(ngroups, groups);
    if (i == -1)
        rb_sys_fail(0);

    return proc_getgroups(obj);
#else
    rb_notimplement();
    return Qnil;
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003152" class="method">
  <div id="M003152_title" class="title">
    <b>Process.initgroups(username, gid)   => array<br />
</b>
  </div>
  <div class="description">
  <p>
Initializes the supplemental group access list by reading the system group
database and using all groups of which the given user is a member. The
group with the specified <em>gid</em> is also added to the list. Returns
the resulting <tt><a
href="index.html?a=C00000243&name=Array">Array</a></tt> of the gids of all
the groups in the supplementary group access list. Not available on all
platforms.
</p>
<pre>
   Process.groups   #=&gt; [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
   Process.initgroups( &quot;mgranger&quot;, 30 )   #=&gt; [30, 6, 10, 11]
   Process.groups   #=&gt; [30, 6, 10, 11]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003152_source')" id="l_M003152_source">show source</a> ]</p>
  <div id="M003152_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.initgroups(username, gid)   =&gt; array
 *
 *  Initializes the supplemental group access list by reading the
 *  system group database and using all groups of which the given user
 *  is a member. The group with the specified &lt;em&gt;gid&lt;/em&gt; is also
 *  added to the list. Returns the resulting &lt;code&gt;Array&lt;/code&gt; of the
 *  gids of all the groups in the supplementary group access list. Not
 *  available on all platforms.
 *
 *     Process.groups   #=&gt; [0, 1, 2, 3, 4, 6, 10, 11, 20, 26, 27]
 *     Process.initgroups( &quot;mgranger&quot;, 30 )   #=&gt; [30, 6, 10, 11]
 *     Process.groups   #=&gt; [30, 6, 10, 11]
 *
 */

static VALUE
proc_initgroups(obj, uname, base_grp)
    VALUE obj, uname, base_grp;
{
#ifdef HAVE_INITGROUPS
    if (initgroups(StringValuePtr(uname), (rb_gid_t)NUM2INT(base_grp)) != 0) {
        rb_sys_fail(0);
    }
    return proc_getgroups(obj);
#else
    rb_notimplement();
    return Qnil;
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003126" class="method">
  <div id="M003126_title" class="title">
    <b>Process.kill(signal, pid, ...)    => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Sends the given signal to the specified process id(s), or to the current
process if <em>pid</em> is zero. <em>signal</em> may be an integer signal
number or a POSIX signal name (either with or without a <tt>SIG</tt>
prefix). If <em>signal</em> is negative (or starts with a minus sign),
kills process groups instead of processes. Not all signals are available on
all platforms.
</p>
<pre>
   pid = fork do
      Signal.trap(&quot;HUP&quot;) { puts &quot;Ouch!&quot;; exit }
      # ... do some work ...
   end
   # ...
   Process.kill(&quot;HUP&quot;, pid)
   Process.wait
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Ouch!
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003126_source')" id="l_M003126_source">show source</a> ]</p>
  <div id="M003126_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.kill(signal, pid, ...)    =&gt; fixnum
 *  
 *  Sends the given signal to the specified process id(s), or to the
 *  current process if _pid_ is zero. _signal_ may be an
 *  integer signal number or a POSIX signal name (either with or without
 *  a +SIG+ prefix). If _signal_ is negative (or starts
 *  with a minus sign), kills process groups instead of
 *  processes. Not all signals are available on all platforms.
 *     
 *     pid = fork do
 *        Signal.trap(&quot;HUP&quot;) { puts &quot;Ouch!&quot;; exit }
 *        # ... do some work ...
 *     end
 *     # ...
 *     Process.kill(&quot;HUP&quot;, pid)
 *     Process.wait
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Ouch!
 */

VALUE
rb_f_kill(argc, argv)
    int argc;
    VALUE *argv;
{
    int negative = 0;
    int sig;
    int i;
    const char *s;

    rb_secure(2);
    if (argc &lt; 2)
	rb_raise(rb_eArgError, &quot;wrong number of arguments -- kill(sig, pid...)&quot;);
    switch (TYPE(argv[0])) {
      case T_FIXNUM:
	sig = FIX2INT(argv[0]);
	break;

      case T_SYMBOL:
	s = rb_id2name(SYM2ID(argv[0]));
	if (!s) rb_raise(rb_eArgError, &quot;bad signal&quot;);
	goto str_signal;

      case T_STRING:
	s = RSTRING(argv[0])-&gt;ptr;
	if (s[0] == '-') {
	    negative++;
	    s++;
	}
      str_signal:
	if (strncmp(&quot;SIG&quot;, s, 3) == 0)
	    s += 3;
	if((sig = signm2signo(s)) == 0)
	    rb_raise(rb_eArgError, &quot;unsupported name `SIG%s'&quot;, s);

	if (negative)
	    sig = -sig;
	break;

      default:
        {
	    VALUE str;

	    str = rb_check_string_type(argv[0]);
	    if (!NIL_P(str)) {
		s = RSTRING(str)-&gt;ptr;
		goto str_signal;
	    }
	    rb_raise(rb_eArgError, &quot;bad signal type %s&quot;,
		     rb_obj_classname(argv[0]));
	}
	break;
    }

    if (sig &lt; 0) {
	sig = -sig;
	for (i=1; i&lt;argc; i++) {
	    int pid = NUM2INT(argv[i]);
#ifdef HAS_KILLPG
	    if (killpg(pid, sig) &lt; 0)
#else
	    if (kill(-pid, sig) &lt; 0)
#endif
		rb_sys_fail(0);
	}
    }
    else {
	for (i=1; i&lt;argc; i++) {
	    Check_Type(argv[i], T_FIXNUM);
	    if (kill(FIX2INT(argv[i]), sig) &lt; 0)
		rb_sys_fail(0);
	}
    }
    return INT2FIX(i-1);
}
</pre>
  </div>
</div>
</div>
<div id="M003155" class="method">
  <div id="M003155_title" class="title">
    <b>Process.maxgroups   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the maximum number of gids allowed in the supplemental group access
list.
</p>
<pre>
   Process.maxgroups   #=&gt; 32
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003155_source')" id="l_M003155_source">show source</a> ]</p>
  <div id="M003155_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.maxgroups   =&gt; fixnum
 *
 *  Returns the maximum number of gids allowed in the supplemental
 *  group access list.
 *
 *     Process.maxgroups   #=&gt; 32
 */

static VALUE
proc_getmaxgroups(obj)
    VALUE obj;
{
    return INT2FIX(maxgroups);
}
</pre>
  </div>
</div>
</div>
<div id="M003156" class="method">
  <div id="M003156_title" class="title">
    <b>Process.maxgroups= fixnum   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Sets the maximum number of gids allowed in the supplemental group access
list.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003156_source')" id="l_M003156_source">show source</a> ]</p>
  <div id="M003156_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.maxgroups= fixnum   =&gt; fixnum
 *
 *  Sets the maximum number of gids allowed in the supplemental group
 *  access list.
 */

static VALUE
proc_setmaxgroups(VALUE obj, VALUE val)
{
    size_t  ngroups = FIX2INT(val);

    if (ngroups &gt; 4096)
        ngroups = 4096;

    maxgroups = ngroups;

    return INT2FIX(maxgroups);
}
</pre>
  </div>
</div>
</div>
<div id="M003133" class="method">
  <div id="M003133_title" class="title">
    <b>Process.pid   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the process id of this process. Not available on all platforms.
</p>
<pre>
   Process.pid   #=&gt; 27415
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003133_source')" id="l_M003133_source">show source</a> ]</p>
  <div id="M003133_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.pid   =&gt; fixnum
 *
 *  Returns the process id of this process. Not available on all
 *  platforms.
 *
 *     Process.pid   #=&gt; 27415
 */

static VALUE
get_pid()
{
    rb_secure(2);
    return INT2FIX(getpid());
}
</pre>
  </div>
</div>
</div>
<div id="M003134" class="method">
  <div id="M003134_title" class="title">
    <b>Process.ppid   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the process id of the parent of this process. Always returns 0 on
NT. Not available on all platforms.
</p>
<pre>
   puts &quot;I am #{Process.pid}&quot;
   Process.fork { puts &quot;Dad is #{Process.ppid}&quot; }
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   I am 27417
   Dad is 27417
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003134_source')" id="l_M003134_source">show source</a> ]</p>
  <div id="M003134_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.ppid   =&gt; fixnum
 *
 *  Returns the process id of the parent of this process. Always
 *  returns 0 on NT. Not available on all platforms.
 *
 *     puts &quot;I am #{Process.pid}&quot;
 *     Process.fork { puts &quot;Dad is #{Process.ppid}&quot; }
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     I am 27417
 *     Dad is 27417
 */

static VALUE
get_ppid()
{
    rb_secure(2);
#ifdef _WIN32
    return INT2FIX(0);
#else
    return INT2FIX(getppid());
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003138" class="method">
  <div id="M003138_title" class="title">
    <b>Process.setpgid(pid, integer)   => 0<br />
</b>
  </div>
  <div class="description">
  <p>
Sets the process group ID of <em>pid</em> (0 indicates this process) to
<em>integer</em>. Not available on all platforms.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003138_source')" id="l_M003138_source">show source</a> ]</p>
  <div id="M003138_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.setpgid(pid, integer)   =&gt; 0
 *
 *  Sets the process group ID of _pid_ (0 indicates this
 *  process) to &lt;em&gt;integer&lt;/em&gt;. Not available on all platforms.
 */

static VALUE
proc_setpgid(obj, pid, pgrp)
    VALUE obj, pid, pgrp;
{
#ifdef HAVE_SETPGID
    int ipid, ipgrp;

    rb_secure(2);
    ipid = NUM2INT(pid);
    ipgrp = NUM2INT(pgrp);

    if (setpgid(ipid, ipgrp) &lt; 0) rb_sys_fail(0);
    return INT2FIX(0);
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003136" class="method">
  <div id="M003136_title" class="title">
    <b>Process.setpgrp   => 0<br />
</b>
  </div>
  <div class="description">
  <p>
Equivalent to <tt>setpgid(0,0)</tt>. Not available on all platforms.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003136_source')" id="l_M003136_source">show source</a> ]</p>
  <div id="M003136_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.setpgrp   =&gt; 0
 *
 *  Equivalent to &lt;code&gt;setpgid(0,0)&lt;/code&gt;. Not available on all
 *  platforms.
 */

static VALUE
proc_setpgrp()
{
    rb_secure(2);
  /* check for posix setpgid() first; this matches the posix */
  /* getpgrp() above.  It appears that configure will set SETPGRP_VOID */
  /* even though setpgrp(0,0) would be prefered. The posix call avoids */
  /* this confusion. */
#ifdef HAVE_SETPGID
    if (setpgid(0,0) &lt; 0) rb_sys_fail(0);
#elif defined(HAVE_SETPGRP) &amp;&amp; defined(SETPGRP_VOID)
    if (setpgrp() &lt; 0) rb_sys_fail(0);
#else
    rb_notimplement();
#endif
    return INT2FIX(0);
}
</pre>
  </div>
</div>
</div>
<div id="M003141" class="method">
  <div id="M003141_title" class="title">
    <b>Process.setpriority(kind, integer, priority)   => 0<br />
</b>
  </div>
  <div class="description">
  <p>
See <tt><a
href="index.html?a=M003140&name=Process#getpriority">Process#getpriority</a></tt>.
</p>
<pre>
   Process.setpriority(Process::PRIO_USER, 0, 19)      #=&gt; 0
   Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=&gt; 0
   Process.getpriority(Process::PRIO_USER, 0)          #=&gt; 19
   Process.getpriority(Process::PRIO_PROCESS, 0)       #=&gt; 19
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003141_source')" id="l_M003141_source">show source</a> ]</p>
  <div id="M003141_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.setpriority(kind, integer, priority)   =&gt; 0
 *
 *  See &lt;code&gt;Process#getpriority&lt;/code&gt;.
 *
 *     Process.setpriority(Process::PRIO_USER, 0, 19)      #=&gt; 0
 *     Process.setpriority(Process::PRIO_PROCESS, 0, 19)   #=&gt; 0
 *     Process.getpriority(Process::PRIO_USER, 0)          #=&gt; 19
 *     Process.getpriority(Process::PRIO_PROCESS, 0)       #=&gt; 19
 */

static VALUE
proc_setpriority(obj, which, who, prio)
    VALUE obj, which, who, prio;
{
#ifdef HAVE_GETPRIORITY
    int iwhich, iwho, iprio;

    rb_secure(2);
    iwhich = NUM2INT(which);
    iwho   = NUM2INT(who);
    iprio  = NUM2INT(prio);

    if (setpriority(iwhich, iwho, iprio) &lt; 0)
        rb_sys_fail(0);
    return INT2FIX(0);
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003143" class="method">
  <div id="M003143_title" class="title">
    <b>Process.setrlimit(resource, cur_limit, max_limit)        => nil<br />
Process.setrlimit(resource, cur_limit)                   => nil<br />
</b>
  </div>
  <div class="description">
  <p>
Sets the resource limit of the process. <em>cur_limit</em> means current
(soft) limit and <em>max_limit</em> means maximum (hard) limit.
</p>
<p>
If <em>max_limit</em> is not given, <em>cur_limit</em> is used.
</p>
<p>
<em>resource</em> indicates the kind of resource to limit. The list of
resources are OS dependent. Ruby may support following resources.
</p>
<dl>
<dt>Process::RLIMIT_CORE</dt><dd>core size (bytes) (SUSv3)

</dd>
<dt>Process::RLIMIT_CPU</dt><dd>CPU time (seconds) (SUSv3)

</dd>
<dt>Process::RLIMIT_DATA</dt><dd>data segment (bytes) (SUSv3)

</dd>
<dt>Process::RLIMIT_FSIZE</dt><dd>file size (bytes) (SUSv3)

</dd>
<dt>Process::RLIMIT_NOFILE</dt><dd>file descriptors (number) (SUSv3)

</dd>
<dt>Process::RLIMIT_STACK</dt><dd>stack size (bytes) (SUSv3)

</dd>
<dt>Process::RLIMIT_AS</dt><dd>total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but
4.4BSD-Lite)

</dd>
<dt>Process::RLIMIT_MEMLOCK</dt><dd>total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)

</dd>
<dt>Process::RLIMIT_NPROC</dt><dd>number of processes for the user (number) (4.4BSD, GNU/Linux)

</dd>
<dt>Process::RLIMIT_RSS</dt><dd>resident memory size (bytes) (4.2BSD, GNU/Linux)

</dd>
<dt>Process::RLIMIT_SBSIZE</dt><dd>all socket buffers (bytes) (NetBSD, FreeBSD)

</dd>
</dl>
<p>
Other <tt>Process::RLIMIT_???</tt> constants may be defined.
</p>
<p>
<em>cur_limit</em> and <em>max_limit</em> may be
<tt>Process::RLIM_INFINITY</tt>, which means that the resource is not
limited. They may be <tt>Process::RLIM_SAVED_MAX</tt> or
<tt>Process::RLIM_SAVED_CUR</tt> too. See system setrlimit(2) manual for
details.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003143_source')" id="l_M003143_source">show source</a> ]</p>
  <div id="M003143_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.setrlimit(resource, cur_limit, max_limit)        =&gt; nil
 *     Process.setrlimit(resource, cur_limit)                   =&gt; nil
 *
 *  Sets the resource limit of the process.
 *  _cur_limit_ means current (soft) limit and
 *  _max_limit_ means maximum (hard) limit.
 *
 *  If _max_limit_ is not given, _cur_limit_ is used.
 *
 *  _resource_ indicates the kind of resource to limit.
 *  The list of resources are OS dependent.
 *  Ruby may support following resources.
 *
 *  [Process::RLIMIT_CORE] core size (bytes) (SUSv3)
 *  [Process::RLIMIT_CPU] CPU time (seconds) (SUSv3)
 *  [Process::RLIMIT_DATA] data segment (bytes) (SUSv3)
 *  [Process::RLIMIT_FSIZE] file size (bytes) (SUSv3)
 *  [Process::RLIMIT_NOFILE] file descriptors (number) (SUSv3)
 *  [Process::RLIMIT_STACK] stack size (bytes) (SUSv3)
 *  [Process::RLIMIT_AS] total available memory (bytes) (SUSv3, NetBSD, FreeBSD, OpenBSD but 4.4BSD-Lite)
 *  [Process::RLIMIT_MEMLOCK] total size for mlock(2) (bytes) (4.4BSD, GNU/Linux)
 *  [Process::RLIMIT_NPROC] number of processes for the user (number) (4.4BSD, GNU/Linux)
 *  [Process::RLIMIT_RSS] resident memory size (bytes) (4.2BSD, GNU/Linux)
 *  [Process::RLIMIT_SBSIZE] all socket buffers (bytes) (NetBSD, FreeBSD)
 *
 *  Other &lt;code&gt;Process::RLIMIT_???&lt;/code&gt; constants may be defined.
 *
 *  _cur_limit_ and _max_limit_ may be &lt;code&gt;Process::RLIM_INFINITY&lt;/code&gt;,
 *  which means that the resource is not limited.
 *  They may be &lt;code&gt;Process::RLIM_SAVED_MAX&lt;/code&gt; or
 *  &lt;code&gt;Process::RLIM_SAVED_CUR&lt;/code&gt; too.
 *  See system setrlimit(2) manual for details.
 *
 */

static VALUE
proc_setrlimit(int argc, VALUE *argv, VALUE obj)
{
#if defined(HAVE_SETRLIMIT) &amp;&amp; defined(NUM2RLIM)
    VALUE resource, rlim_cur, rlim_max;
    struct rlimit rlim;

    rb_secure(2);

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;resource, &amp;rlim_cur, &amp;rlim_max);
    if (rlim_max == Qnil)
        rlim_max = rlim_cur;

    rlim.rlim_cur = NUM2RLIM(rlim_cur);
    rlim.rlim_max = NUM2RLIM(rlim_max);

    if (setrlimit(NUM2INT(resource), &amp;rlim) &lt; 0) {
        rb_sys_fail(&quot;setrlimit&quot;);
    }
    return Qnil;
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003139" class="method">
  <div id="M003139_title" class="title">
    <b>Process.setsid   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Establishes this process as a new session and process group leader, with no
controlling tty. Returns the session id. Not available on all platforms.
</p>
<pre>
   Process.setsid   #=&gt; 27422
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003139_source')" id="l_M003139_source">show source</a> ]</p>
  <div id="M003139_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.setsid   =&gt; fixnum
 *
 *  Establishes this process as a new session and process group
 *  leader, with no controlling tty. Returns the session id. Not
 *  available on all platforms.
 *
 *     Process.setsid   #=&gt; 27422
 */

static VALUE
proc_setsid()
{
#if defined(HAVE_SETSID)
    int pid;

    rb_secure(2);
    pid = setsid();
    if (pid &lt; 0) rb_sys_fail(0);
    return INT2FIX(pid);
#elif defined(HAVE_SETPGRP) &amp;&amp; defined(TIOCNOTTY)
  rb_pid_t pid;
  int ret;

  rb_secure(2);
  pid = getpid();
#if defined(SETPGRP_VOID)
  ret = setpgrp();
  /* If `pid_t setpgrp(void)' is equivalent to setsid(),
     `ret' will be the same value as `pid', and following open() will fail.
     In Linux, `int setpgrp(void)' is equivalent to setpgid(0, 0). */
#else
  ret = setpgrp(0, pid);
#endif
  if (ret == -1) rb_sys_fail(0);

  if ((fd = open(&quot;/dev/tty&quot;, O_RDWR)) &gt;= 0) {
    ioctl(fd, TIOCNOTTY, NULL);
    close(fd);
  }
  return INT2FIX(pid);
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003157" class="method">
  <div id="M003157_title" class="title">
    <b>Process.times   => aStructTms<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a <tt>Tms</tt> structure (see <tt>Struct::Tms</tt> on page 388)
that contains user and system CPU times for this process.
</p>
<pre>
   t = Process.times
   [ t.utime, t.stime ]   #=&gt; [0.0, 0.02]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003157_source')" id="l_M003157_source">show source</a> ]</p>
  <div id="M003157_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.times   =&gt; aStructTms
 *
 *  Returns a &lt;code&gt;Tms&lt;/code&gt; structure (see &lt;code&gt;Struct::Tms&lt;/code&gt;
 *  on page 388) that contains user and system CPU times for this
 *  process.
 *
 *     t = Process.times
 *     [ t.utime, t.stime ]   #=&gt; [0.0, 0.02]
 */

VALUE
rb_proc_times(obj)
    VALUE obj;
{
#if defined(HAVE_TIMES) &amp;&amp; !defined(__CHECKER__)
    const double hertz =
#ifdef HAVE__SC_CLK_TCK
        (double)sysconf(_SC_CLK_TCK);
#else
#ifndef HZ
# ifdef CLK_TCK
#   define HZ CLK_TCK
# else
#   define HZ 60
# endif
#endif /* HZ */
        HZ;
#endif
    struct tms buf;
    volatile VALUE utime, stime, cutime, sctime;

    times(&amp;buf);
    return rb_struct_new(S_Tms,
                         utime = rb_float_new(buf.tms_utime / hertz),
                         stime = rb_float_new(buf.tms_stime / hertz),
                         cutime = rb_float_new(buf.tms_cutime / hertz),
                         sctime = rb_float_new(buf.tms_cstime / hertz));
#else
    rb_notimplement();
#endif
}
</pre>
  </div>
</div>
</div>
<div id="M003144" class="method">
  <div id="M003144_title" class="title">
    <b>Process.uid           => fixnum<br />
Process::UID.rid      => fixnum<br />
Process::Sys.getuid   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the (real) user ID of this process.
</p>
<pre>
   Process.uid   #=&gt; 501
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003144_source')" id="l_M003144_source">show source</a> ]</p>
  <div id="M003144_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.uid           =&gt; fixnum
 *     Process::UID.rid      =&gt; fixnum
 *     Process::Sys.getuid   =&gt; fixnum
 *
 *  Returns the (real) user ID of this process.
 *
 *     Process.uid   #=&gt; 501
 */

static VALUE
proc_getuid(obj)
    VALUE obj;
{
    int uid = getuid();
    return INT2FIX(uid);
}
</pre>
  </div>
</div>
</div>
<div id="M003145" class="method">
  <div id="M003145_title" class="title">
    <b>Process.uid= integer   => numeric<br />
</b>
  </div>
  <div class="description">
  <p>
Sets the (integer) user ID for this process. Not available on all
platforms.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003145_source')" id="l_M003145_source">show source</a> ]</p>
  <div id="M003145_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.uid= integer   =&gt; numeric
 *
 *  Sets the (integer) user ID for this process. Not available on all
 *  platforms.
 */

static VALUE
proc_setuid(obj, id)
    VALUE obj, id;
{
    int uid = NUM2INT(id);

    check_uid_switch();
#if defined(HAVE_SETRESUID) &amp;&amp;  !defined(__CHECKER__)
    if (setresuid(uid, -1, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETREUID
    if (setreuid(uid, -1) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETRUID
    if (setruid(uid) &lt; 0) rb_sys_fail(0);
#elif defined HAVE_SETUID
    {
        if (geteuid() == uid) {
            if (setuid(uid) &lt; 0) rb_sys_fail(0);
        }
        else {
            rb_notimplement();
        }
    }
#else
    rb_notimplement();
#endif
    return INT2FIX(uid);
}
</pre>
  </div>
</div>
</div>
<div id="M003127" class="method">
  <div id="M003127_title" class="title">
    <b>Process.wait()                     => fixnum<br />
Process.wait(pid=-1, flags=0)      => fixnum<br />
Process.waitpid(pid=-1, flags=0)   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Waits for a child process to exit, returns its process id, and sets
<tt>$?</tt> to a <tt><a
href="index.html?a=C00000352&name=Process::Status">Process::Status</a></tt>
object containing information on that process. Which child it waits on
depends on the value of <em>pid</em>:
</p>
<table>
<tr><td valign="top">&gt; 0:</td><td>Waits for the child whose process ID equals <em>pid</em>.

</td></tr>
<tr><td valign="top">0:</td><td>Waits for any child whose process group ID equals that of the calling
process.

</td></tr>
<tr><td valign="top">-1:</td><td>Waits for any child process (the default if no <em>pid</em> is given).

</td></tr>
<tr><td valign="top">&lt; -1:</td><td>Waits for any child whose process group ID equals the absolute value of
<em>pid</em>.

</td></tr>
</table>
<p>
The <em>flags</em> argument may be a logical or of the flag values
<tt>Process::WNOHANG</tt> (do not block if no child available) or
<tt>Process::WUNTRACED</tt> (return stopped children that haven&#8217;t
been reported). Not all flags are available on all platforms, but a flag
value of zero will work on all platforms.
</p>
<p>
Calling this method raises a <tt>SystemError</tt> if there are no child
processes. Not available on all platforms.
</p>
<pre>
   include Process
   fork { exit 99 }                 #=&gt; 27429
   wait                             #=&gt; 27429
   $?.exitstatus                    #=&gt; 99

   pid = fork { sleep 3 }           #=&gt; 27440
   Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
   waitpid(pid, Process::WNOHANG)   #=&gt; nil
   Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
   waitpid(pid, 0)                  #=&gt; 27440
   Time.now                         #=&gt; Wed Apr 09 08:57:12 CDT 2003
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003127_source')" id="l_M003127_source">show source</a> ]</p>
  <div id="M003127_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.wait()                     =&gt; fixnum
 *     Process.wait(pid=-1, flags=0)      =&gt; fixnum
 *     Process.waitpid(pid=-1, flags=0)   =&gt; fixnum
 *
 *  Waits for a child process to exit, returns its process id, and
 *  sets &lt;code&gt;$?&lt;/code&gt; to a &lt;code&gt;Process::Status&lt;/code&gt; object
 *  containing information on that process. Which child it waits on
 *  depends on the value of _pid_:
 *
 *  &gt; 0::   Waits for the child whose process ID equals _pid_.
 *
 *  0::     Waits for any child whose process group ID equals that of the
 *          calling process.
 *
 *  -1::    Waits for any child process (the default if no _pid_ is
 *          given).
 *
 *  &lt; -1::  Waits for any child whose process group ID equals the absolute
 *          value of _pid_.
 *
 *  The _flags_ argument may be a logical or of the flag values
 *  &lt;code&gt;Process::WNOHANG&lt;/code&gt; (do not block if no child available)
 *  or &lt;code&gt;Process::WUNTRACED&lt;/code&gt; (return stopped children that
 *  haven't been reported). Not all flags are available on all
 *  platforms, but a flag value of zero will work on all platforms.
 *
 *  Calling this method raises a &lt;code&gt;SystemError&lt;/code&gt; if there are
 *  no child processes. Not available on all platforms.
 *
 *     include Process
 *     fork { exit 99 }                 #=&gt; 27429
 *     wait                             #=&gt; 27429
 *     $?.exitstatus                    #=&gt; 99
 *
 *     pid = fork { sleep 3 }           #=&gt; 27440
 *     Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
 *     waitpid(pid, Process::WNOHANG)   #=&gt; nil
 *     Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
 *     waitpid(pid, 0)                  #=&gt; 27440
 *     Time.now                         #=&gt; Wed Apr 09 08:57:12 CDT 2003
 */

static VALUE
proc_wait(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE vpid, vflags;
    int pid, flags, status;

    rb_secure(2);
    flags = 0;
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;vpid, &amp;vflags);
    if (argc == 0) {
        pid = -1;
    }
    else {
        pid = NUM2INT(vpid);
        if (argc == 2 &amp;&amp; !NIL_P(vflags)) {
            flags = NUM2UINT(vflags);
        }
    }
    if ((pid = rb_waitpid(pid, &amp;status, flags)) &lt; 0)
        rb_sys_fail(0);
    if (pid == 0) {
        return rb_last_status = Qnil;
    }
    return INT2FIX(pid);
}
</pre>
  </div>
</div>
</div>
<div id="M003128" class="method">
  <div id="M003128_title" class="title">
    <b>Process.wait2(pid=-1, flags=0)      => [pid, status]<br />
Process.waitpid2(pid=-1, flags=0)   => [pid, status]<br />
</b>
  </div>
  <div class="description">
  <p>
Waits for a child process to exit (see Process::waitpid for exact
semantics) and returns an array containing the process id and the exit
status (a <tt><a
href="index.html?a=C00000352&name=Process::Status">Process::Status</a></tt>
object) of that child. Raises a <tt>SystemError</tt> if there are no child
processes.
</p>
<pre>
   Process.fork { exit 99 }   #=&gt; 27437
   pid, status = Process.wait2
   pid                        #=&gt; 27437
   status.exitstatus          #=&gt; 99
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003128_source')" id="l_M003128_source">show source</a> ]</p>
  <div id="M003128_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.wait2(pid=-1, flags=0)      =&gt; [pid, status]
 *     Process.waitpid2(pid=-1, flags=0)   =&gt; [pid, status]
 *
 *  Waits for a child process to exit (see Process::waitpid for exact
 *  semantics) and returns an array containing the process id and the
 *  exit status (a &lt;code&gt;Process::Status&lt;/code&gt; object) of that
 *  child. Raises a &lt;code&gt;SystemError&lt;/code&gt; if there are no child
 *  processes.
 *
 *     Process.fork { exit 99 }   #=&gt; 27437
 *     pid, status = Process.wait2
 *     pid                        #=&gt; 27437
 *     status.exitstatus          #=&gt; 99
 */

static VALUE
proc_wait2(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE pid = proc_wait(argc, argv);
    if (NIL_P(pid)) return Qnil;
    return rb_assoc_new(pid, rb_last_status);
}
</pre>
  </div>
</div>
</div>
<div id="M003131" class="method">
  <div id="M003131_title" class="title">
    <b>Process.waitall   => [ [pid1,status1], ...]<br />
</b>
  </div>
  <div class="description">
  <p>
Waits for all children, returning an array of <em>pid</em>/<em>status</em>
pairs (where <em>status</em> is a <tt><a
href="index.html?a=C00000352&name=Process::Status">Process::Status</a></tt>
object).
</p>
<pre>
   fork { sleep 0.2; exit 2 }   #=&gt; 27432
   fork { sleep 0.1; exit 1 }   #=&gt; 27433
   fork {            exit 0 }   #=&gt; 27434
   p Process.waitall
</pre>
<p>
<em>produces</em>:
</p>
<pre>
   [[27434, #&lt;Process::Status: pid=27434,exited(0)&gt;],
    [27433, #&lt;Process::Status: pid=27433,exited(1)&gt;],
    [27432, #&lt;Process::Status: pid=27432,exited(2)&gt;]]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003131_source')" id="l_M003131_source">show source</a> ]</p>
  <div id="M003131_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.waitall   =&gt; [ [pid1,status1], ...]
 *
 *  Waits for all children, returning an array of
 *  _pid_/_status_ pairs (where _status_ is a
 *  &lt;code&gt;Process::Status&lt;/code&gt; object).
 *
 *     fork { sleep 0.2; exit 2 }   #=&gt; 27432
 *     fork { sleep 0.1; exit 1 }   #=&gt; 27433
 *     fork {            exit 0 }   #=&gt; 27434
 *     p Process.waitall
 *
 *  &lt;em&gt;produces&lt;/em&gt;:
 *
 *     [[27434, #&lt;Process::Status: pid=27434,exited(0)&gt;],
 *      [27433, #&lt;Process::Status: pid=27433,exited(1)&gt;],
 *      [27432, #&lt;Process::Status: pid=27432,exited(2)&gt;]]
 */

static VALUE
proc_waitall()
{
    VALUE result;
    int pid, status;

    rb_secure(2);
    result = rb_ary_new();
#ifdef NO_WAITPID
    if (pid_tbl) {
        st_foreach(pid_tbl, waitall_each, result);
    }

    for (pid = -1;;) {
        pid = wait(&amp;status);
        if (pid == -1) {
            if (errno == ECHILD)
                break;
            if (errno == EINTR) {
                rb_thread_schedule();
                continue;
            }
            rb_sys_fail(0);
        }
        last_status_set(status, pid);
        rb_ary_push(result, rb_assoc_new(INT2NUM(pid), rb_last_status));
    }
#else
    rb_last_status = Qnil;
    for (pid = -1;;) {
        pid = rb_waitpid(-1, &amp;status, 0);
        if (pid == -1) {
            if (errno == ECHILD)
                break;
            rb_sys_fail(0);
        }
        rb_ary_push(result, rb_assoc_new(INT2NUM(pid), rb_last_status));
    }
#endif
    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M003129" class="method">
  <div id="M003129_title" class="title">
    <b>Process.wait()                     => fixnum<br />
Process.wait(pid=-1, flags=0)      => fixnum<br />
Process.waitpid(pid=-1, flags=0)   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Waits for a child process to exit, returns its process id, and sets
<tt>$?</tt> to a <tt><a
href="index.html?a=C00000352&name=Process::Status">Process::Status</a></tt>
object containing information on that process. Which child it waits on
depends on the value of <em>pid</em>:
</p>
<table>
<tr><td valign="top">&gt; 0:</td><td>Waits for the child whose process ID equals <em>pid</em>.

</td></tr>
<tr><td valign="top">0:</td><td>Waits for any child whose process group ID equals that of the calling
process.

</td></tr>
<tr><td valign="top">-1:</td><td>Waits for any child process (the default if no <em>pid</em> is given).

</td></tr>
<tr><td valign="top">&lt; -1:</td><td>Waits for any child whose process group ID equals the absolute value of
<em>pid</em>.

</td></tr>
</table>
<p>
The <em>flags</em> argument may be a logical or of the flag values
<tt>Process::WNOHANG</tt> (do not block if no child available) or
<tt>Process::WUNTRACED</tt> (return stopped children that haven&#8217;t
been reported). Not all flags are available on all platforms, but a flag
value of zero will work on all platforms.
</p>
<p>
Calling this method raises a <tt>SystemError</tt> if there are no child
processes. Not available on all platforms.
</p>
<pre>
   include Process
   fork { exit 99 }                 #=&gt; 27429
   wait                             #=&gt; 27429
   $?.exitstatus                    #=&gt; 99

   pid = fork { sleep 3 }           #=&gt; 27440
   Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
   waitpid(pid, Process::WNOHANG)   #=&gt; nil
   Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
   waitpid(pid, 0)                  #=&gt; 27440
   Time.now                         #=&gt; Wed Apr 09 08:57:12 CDT 2003
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003129_source')" id="l_M003129_source">show source</a> ]</p>
  <div id="M003129_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.wait()                     =&gt; fixnum
 *     Process.wait(pid=-1, flags=0)      =&gt; fixnum
 *     Process.waitpid(pid=-1, flags=0)   =&gt; fixnum
 *
 *  Waits for a child process to exit, returns its process id, and
 *  sets &lt;code&gt;$?&lt;/code&gt; to a &lt;code&gt;Process::Status&lt;/code&gt; object
 *  containing information on that process. Which child it waits on
 *  depends on the value of _pid_:
 *
 *  &gt; 0::   Waits for the child whose process ID equals _pid_.
 *
 *  0::     Waits for any child whose process group ID equals that of the
 *          calling process.
 *
 *  -1::    Waits for any child process (the default if no _pid_ is
 *          given).
 *
 *  &lt; -1::  Waits for any child whose process group ID equals the absolute
 *          value of _pid_.
 *
 *  The _flags_ argument may be a logical or of the flag values
 *  &lt;code&gt;Process::WNOHANG&lt;/code&gt; (do not block if no child available)
 *  or &lt;code&gt;Process::WUNTRACED&lt;/code&gt; (return stopped children that
 *  haven't been reported). Not all flags are available on all
 *  platforms, but a flag value of zero will work on all platforms.
 *
 *  Calling this method raises a &lt;code&gt;SystemError&lt;/code&gt; if there are
 *  no child processes. Not available on all platforms.
 *
 *     include Process
 *     fork { exit 99 }                 #=&gt; 27429
 *     wait                             #=&gt; 27429
 *     $?.exitstatus                    #=&gt; 99
 *
 *     pid = fork { sleep 3 }           #=&gt; 27440
 *     Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
 *     waitpid(pid, Process::WNOHANG)   #=&gt; nil
 *     Time.now                         #=&gt; Wed Apr 09 08:57:09 CDT 2003
 *     waitpid(pid, 0)                  #=&gt; 27440
 *     Time.now                         #=&gt; Wed Apr 09 08:57:12 CDT 2003
 */

static VALUE
proc_wait(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE vpid, vflags;
    int pid, flags, status;

    rb_secure(2);
    flags = 0;
    rb_scan_args(argc, argv, &quot;02&quot;, &amp;vpid, &amp;vflags);
    if (argc == 0) {
        pid = -1;
    }
    else {
        pid = NUM2INT(vpid);
        if (argc == 2 &amp;&amp; !NIL_P(vflags)) {
            flags = NUM2UINT(vflags);
        }
    }
    if ((pid = rb_waitpid(pid, &amp;status, flags)) &lt; 0)
        rb_sys_fail(0);
    if (pid == 0) {
        return rb_last_status = Qnil;
    }
    return INT2FIX(pid);
}
</pre>
  </div>
</div>
</div>
<div id="M003130" class="method">
  <div id="M003130_title" class="title">
    <b>Process.wait2(pid=-1, flags=0)      => [pid, status]<br />
Process.waitpid2(pid=-1, flags=0)   => [pid, status]<br />
</b>
  </div>
  <div class="description">
  <p>
Waits for a child process to exit (see Process::waitpid for exact
semantics) and returns an array containing the process id and the exit
status (a <tt><a
href="index.html?a=C00000352&name=Process::Status">Process::Status</a></tt>
object) of that child. Raises a <tt>SystemError</tt> if there are no child
processes.
</p>
<pre>
   Process.fork { exit 99 }   #=&gt; 27437
   pid, status = Process.wait2
   pid                        #=&gt; 27437
   status.exitstatus          #=&gt; 99
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M003130_source')" id="l_M003130_source">show source</a> ]</p>
  <div id="M003130_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Process.wait2(pid=-1, flags=0)      =&gt; [pid, status]
 *     Process.waitpid2(pid=-1, flags=0)   =&gt; [pid, status]
 *
 *  Waits for a child process to exit (see Process::waitpid for exact
 *  semantics) and returns an array containing the process id and the
 *  exit status (a &lt;code&gt;Process::Status&lt;/code&gt; object) of that
 *  child. Raises a &lt;code&gt;SystemError&lt;/code&gt; if there are no child
 *  processes.
 *
 *     Process.fork { exit 99 }   #=&gt; 27437
 *     pid, status = Process.wait2
 *     pid                        #=&gt; 27437
 *     status.exitstatus          #=&gt; 99
 */

static VALUE
proc_wait2(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE pid = proc_wait(argc, argv);
    if (NIL_P(pid)) return Qnil;
    return rb_assoc_new(pid, rb_last_status);
}
</pre>
  </div>
</div>
</div>
</div>

  </div>