  <div id="C00000226">
<div class='banner'>
  <span class="file-title-prefix">Class</span><br />ThreadGroup<br/>
  In:
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/eval_c.html');">ruby-1.8.7-p22/eval.c</a>

Parent:&nbsp;
        <a href="#" onclick="jsHref('classes/YAML/Object.html');">
Object
         </a>
</div>
 <!-- banner header -->

  <div id="bodyContent" >
      <div id="content">

  <div class="description"><p>
<tt><a href="index.html?a=C00000226&name=ThreadGroup">ThreadGroup</a></tt>
provides a means of keeping track of a number of threads as a group. A
<tt><a href="index.html?a=C00000029&name=Thread">Thread</a></tt> can belong
to only one <tt><a
href="index.html?a=C00000226&name=ThreadGroup">ThreadGroup</a></tt> at a
time; adding a thread to a new group will remove it from any previous
group.
</p>
<p>
Newly created threads belong to the same group as the thread from which
they were created.
</p>
</div>



  <div class="sectiontitle">Methods</div>
  <ul>
  <li><a href="index.html?a=M001955&name=add" >add</a></li>
  <li><a href="index.html?a=M001953&name=enclose" >enclose</a></li>
  <li><a href="index.html?a=M001954&name=enclosed?" >enclosed?</a></li>
  <li><a href="index.html?a=M001952&name=list" >list</a></li>
  </ul>




  <div class="sectiontitle">Constants</div>
  <table border='0' cellpadding='5'>
  <tr valign='top'>
    <td class="attr-name">Default</td>
    <td>=</td>
    <td class="attr-value">thgroup_default</td>
  </tr>
  </table>


<div class="sectiontitle">Public Instance methods</div>
<div id="M001955" class="method">
  <div id="M001955_title" class="title">
    <b>thgrp.add(thread)   => thgrp<br />
</b>
  </div>
  <div class="description">
  <p>
Adds the given <em>thread</em> to this group, removing it from any other
group to which it may have previously belonged.
</p>
<pre>
   puts &quot;Initial group is #{ThreadGroup::Default.list}&quot;
   tg = ThreadGroup.new
   t1 = Thread.new { sleep }
   t2 = Thread.new { sleep }
   puts &quot;t1 is #{t1}&quot;
   puts &quot;t2 is #{t2}&quot;
   tg.add(t1)
   puts &quot;Initial group now #{ThreadGroup::Default.list}&quot;
   puts &quot;tg group now #{tg.list}&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Initial group is #&lt;Thread:0x401bdf4c&gt;
   t1 is #&lt;Thread:0x401b3c90&gt;
   t2 is #&lt;Thread:0x401b3c18&gt;
   Initial group now #&lt;Thread:0x401b3c18&gt;#&lt;Thread:0x401bdf4c&gt;
   tg group now #&lt;Thread:0x401b3c90&gt;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001955_source')" id="l_M001955_source">show source</a> ]</p>
  <div id="M001955_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     thgrp.add(thread)   =&gt; thgrp
 *  
 *  Adds the given &lt;em&gt;thread&lt;/em&gt; to this group, removing it from any other
 *  group to which it may have previously belonged.
 *     
 *     puts &quot;Initial group is #{ThreadGroup::Default.list}&quot;
 *     tg = ThreadGroup.new
 *     t1 = Thread.new { sleep }
 *     t2 = Thread.new { sleep }
 *     puts &quot;t1 is #{t1}&quot;
 *     puts &quot;t2 is #{t2}&quot;
 *     tg.add(t1)
 *     puts &quot;Initial group now #{ThreadGroup::Default.list}&quot;
 *     puts &quot;tg group now #{tg.list}&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Initial group is #&lt;Thread:0x401bdf4c&gt;
 *     t1 is #&lt;Thread:0x401b3c90&gt;
 *     t2 is #&lt;Thread:0x401b3c18&gt;
 *     Initial group now #&lt;Thread:0x401b3c18&gt;#&lt;Thread:0x401bdf4c&gt;
 *     tg group now #&lt;Thread:0x401b3c90&gt;
 */

static VALUE
thgroup_add(group, thread)
    VALUE group, thread;
{
    rb_thread_t th;
    struct thgroup *data;

    rb_secure(4);
    th = rb_thread_check(thread);
    if (!th-&gt;next || !th-&gt;prev) {
        rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Thread)&quot;,
                 rb_obj_classname(thread));
    }

    if (OBJ_FROZEN(group)) {
      rb_raise(rb_eThreadError, &quot;can't move to the frozen thread group&quot;);
    }
    Data_Get_Struct(group, struct thgroup, data);
    if (data-&gt;enclosed) {
        rb_raise(rb_eThreadError, &quot;can't move to the enclosed thread group&quot;);
    }

    if (!th-&gt;thgroup) {
        return Qnil;
    }
    if (OBJ_FROZEN(th-&gt;thgroup)) {
        rb_raise(rb_eThreadError, &quot;can't move from the frozen thread group&quot;);
    }
    Data_Get_Struct(th-&gt;thgroup, struct thgroup, data);
    if (data-&gt;enclosed) {
        rb_raise(rb_eThreadError, &quot;can't move from the enclosed thread group&quot;);
    }

    th-&gt;thgroup = group;
    return group;
}
</pre>
  </div>
</div>
</div>
<div id="M001953" class="method">
  <div id="M001953_title" class="title">
    <b>thgrp.enclose   => thgrp<br />
</b>
  </div>
  <div class="description">
  <p>
Prevents threads from being added to or removed from the receiving <tt><a
href="index.html?a=C00000226&name=ThreadGroup">ThreadGroup</a></tt>. New
threads can still be started in an enclosed <tt><a
href="index.html?a=C00000226&name=ThreadGroup">ThreadGroup</a></tt>.
</p>
<pre>
   ThreadGroup::Default.enclose        #=&gt; #&lt;ThreadGroup:0x4029d914&gt;
   thr = Thread::new { Thread.stop }   #=&gt; #&lt;Thread:0x402a7210 sleep&gt;
   tg = ThreadGroup::new               #=&gt; #&lt;ThreadGroup:0x402752d4&gt;
   tg.add thr
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   ThreadError: can't move from the enclosed thread group
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001953_source')" id="l_M001953_source">show source</a> ]</p>
  <div id="M001953_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     thgrp.enclose   =&gt; thgrp
 *  
 *  Prevents threads from being added to or removed from the receiving
 *  &lt;code&gt;ThreadGroup&lt;/code&gt;. New threads can still be started in an enclosed
 *  &lt;code&gt;ThreadGroup&lt;/code&gt;.
 *     
 *     ThreadGroup::Default.enclose        #=&gt; #&lt;ThreadGroup:0x4029d914&gt;
 *     thr = Thread::new { Thread.stop }   #=&gt; #&lt;Thread:0x402a7210 sleep&gt;
 *     tg = ThreadGroup::new               #=&gt; #&lt;ThreadGroup:0x402752d4&gt;
 *     tg.add thr
 *
 *  &lt;em&gt;produces:&lt;/em&gt;
 *
 *     ThreadError: can't move from the enclosed thread group
 */

static VALUE
thgroup_enclose(group)
    VALUE group;
{
    struct thgroup *data;

    Data_Get_Struct(group, struct thgroup, data);
    data-&gt;enclosed = 1;

    return group;
}
</pre>
  </div>
</div>
</div>
<div id="M001954" class="method">
  <div id="M001954_title" class="title">
    <b>thgrp.enclosed?   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Returns <tt>true</tt> if <em>thgrp</em> is enclosed. See also <a
href="index.html?a=M001953&name=ThreadGroup#enclose">ThreadGroup#enclose</a>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001954_source')" id="l_M001954_source">show source</a> ]</p>
  <div id="M001954_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     thgrp.enclosed?   =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;em&gt;thgrp&lt;/em&gt; is enclosed. See also
 *  ThreadGroup#enclose.
 */

static VALUE
thgroup_enclosed_p(group)
    VALUE group;
{
    struct thgroup *data;

    Data_Get_Struct(group, struct thgroup, data);
    if (data-&gt;enclosed) return Qtrue;
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M001952" class="method">
  <div id="M001952_title" class="title">
    <b>thgrp.list   => array<br />
</b>
  </div>
  <div class="description">
  <p>
Returns an array of all existing <tt><a
href="index.html?a=C00000029&name=Thread">Thread</a></tt> objects that
belong to this group.
</p>
<pre>
   ThreadGroup::Default.list   #=&gt; [#&lt;Thread:0x401bdf4c run&gt;]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M001952_source')" id="l_M001952_source">show source</a> ]</p>
  <div id="M001952_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     thgrp.list   =&gt; array
 *  
 *  Returns an array of all existing &lt;code&gt;Thread&lt;/code&gt; objects that belong to
 *  this group.
 *     
 *     ThreadGroup::Default.list   #=&gt; [#&lt;Thread:0x401bdf4c run&gt;]
 */

static VALUE
thgroup_list(group)
    VALUE group;
{
    struct thgroup *data;
    rb_thread_t th;
    VALUE ary;

    Data_Get_Struct(group, struct thgroup, data);
    ary = rb_ary_new();

    FOREACH_THREAD(th) {
        if (th-&gt;thgroup == data-&gt;group) {
            rb_ary_push(ary, th-&gt;thread);
        }
    }
    END_FOREACH(th);

    return ary;
}
</pre>
  </div>
</div>
</div>
</div>

  </div>