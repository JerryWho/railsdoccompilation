  <div id="C00000061">
<div class='banner'>
  <span class="file-title-prefix">Class</span><br />Struct<br/>
  In:
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/struct_c.html');">ruby-1.8.7-p22/struct.c</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/pp_rb.html');">ruby-1.8.7-p22/lib/pp.rb</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/yaml/rubytypes_rb.html');">ruby-1.8.7-p22/lib/yaml/rubytypes.rb</a>

Parent:&nbsp;
        <a href="#" onclick="jsHref('classes/YAML/Object.html');">
Object
         </a>
</div>
 <!-- banner header -->

  <div id="bodyContent" >
      <div id="content">

  <div class="description"><p>
A <tt><a href="index.html?a=C00000061&name=Struct">Struct</a></tt> is a
convenient way to bundle a number of attributes together, using accessor
methods, without having to write an explicit class.
</p>
<p>
The <tt><a href="index.html?a=C00000061&name=Struct">Struct</a></tt> class
is a generator of specific classes, each one of which is defined to hold a
set of variables and their accessors. In these examples, we&#8217;ll call
the generated class ``<em>Customer</em><a
href="index.html?a=C00000299&name=Class">Class</a>,&#8217;&#8217; and
we&#8217;ll show an example instance of that class as
``<em>Customer</em>Inst.&#8217;&#8216;
</p>
<p>
In the descriptions that follow, the parameter <em>symbol</em> refers to a
symbol, which is either a quoted string or a <tt><a
href="index.html?a=C00000284&name=Symbol">Symbol</a></tt> (such as
<tt>:name</tt>).
</p>
</div>



  <div class="sectiontitle">Methods</div>
  <ul>
  <li><a href="index.html?a=M000888&name===" >==</a></li>
  <li><a href="index.html?a=M000899&name=[]" >[]</a></li>
  <li><a href="index.html?a=M000900&name=[]=" >[]=</a></li>
  <li><a href="index.html?a=M000897&name=each" >each</a></li>
  <li><a href="index.html?a=M000898&name=each_pair" >each_pair</a></li>
  <li><a href="index.html?a=M000889&name=eql?" >eql?</a></li>
  <li><a href="index.html?a=M000890&name=hash" >hash</a></li>
  <li><a href="index.html?a=M000892&name=inspect" >inspect</a></li>
  <li><a href="index.html?a=M000896&name=length" >length</a></li>
  <li><a href="index.html?a=M000903&name=members" >members</a></li>
  <li><a href="index.html?a=M000886&name=new" >new</a></li>
  <li><a href="index.html?a=M000887&name=new" >new</a></li>
  <li><a href="index.html?a=M000904&name=pretty_print" >pretty_print</a></li>
  <li><a href="index.html?a=M000905&name=pretty_print_cycle" >pretty_print_cycle</a></li>
  <li><a href="index.html?a=M000901&name=select" >select</a></li>
  <li><a href="index.html?a=M000895&name=size" >size</a></li>
  <li><a href="index.html?a=M000893&name=to_a" >to_a</a></li>
  <li><a href="index.html?a=M000891&name=to_s" >to_s</a></li>
  <li><a href="index.html?a=M000909&name=to_yaml" >to_yaml</a></li>
  <li><a href="index.html?a=M000894&name=values" >values</a></li>
  <li><a href="index.html?a=M000902&name=values_at" >values_at</a></li>
  <li><a href="index.html?a=M000908&name=yaml_new" >yaml_new</a></li>
  <li><a href="index.html?a=M000906&name=yaml_tag_class_name" >yaml_tag_class_name</a></li>
  <li><a href="index.html?a=M000907&name=yaml_tag_read_class" >yaml_tag_read_class</a></li>
  </ul>

<div class="sectiontitle">Included Modules</div>
<ul>
  <li><a href="#" onclick="jsHref('classes/Enumerable.html');">Enumerable</a></li>
</ul>





<div class="sectiontitle">Public Class methods</div>
<div id="M000886" class="method">
  <div id="M000886_title" class="title">
    <b>Struct.new( [aString] [, aSym]+> )    => StructClass<br />
StructClass.new(arg, ...)             => obj<br />
StructClass[arg, ...]                 => obj<br />
</b>
  </div>
  <div class="description">
  <p>
Creates a new class, named by <em>aString</em>, containing accessor methods
for the given symbols. If the name <em>aString</em> is omitted, an
anonymous structure class will be created. Otherwise, the name of this
struct will appear as a constant in class <tt><a
href="index.html?a=C00000061&name=Struct">Struct</a></tt>, so it must be
unique for all <tt><a
href="index.html?a=C00000061&name=Struct">Struct</a></tt>s in the system
and should start with a capital letter. Assigning a structure class to a
constant effectively gives the class the name of the constant.
</p>
<p>
<tt>Struct::new</tt> returns a new <tt><a
href="index.html?a=C00000299&name=Class">Class</a></tt> object, which can
then be used to create specific instances of the new structure. The number
of actual parameters must be less than or equal to the number of attributes
defined for this class; unset parameters default to \nil{}. Passing too
many parameters will raise an \E{<a
href="index.html?a=C00000316&name=ArgumentError">ArgumentError</a>}.
</p>
<p>
The remaining methods listed in this section (class and instance) are
defined for this generated class.
</p>
<pre>
   # Create a structure with a name in Struct
   Struct.new(&quot;Customer&quot;, :name, :address)    #=&gt; Struct::Customer
   Struct::Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)   #=&gt; #&lt;Struct::Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;

   # Create a structure named by its constant
   Customer = Struct.new(:name, :address)     #=&gt; Customer
   Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)           #=&gt; #&lt;Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000886_source')" id="l_M000886_source">show source</a> ]</p>
  <div id="M000886_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     Struct.new( [aString] [, aSym]+&gt; )    =&gt; StructClass
 *     StructClass.new(arg, ...)             =&gt; obj
 *     StructClass[arg, ...]                 =&gt; obj
 *
 *  Creates a new class, named by &lt;i&gt;aString&lt;/i&gt;, containing accessor
 *  methods for the given symbols. If the name &lt;i&gt;aString&lt;/i&gt; is
 *  omitted, an anonymous structure class will be created. Otherwise,
 *  the name of this struct will appear as a constant in class
 *  &lt;code&gt;Struct&lt;/code&gt;, so it must be unique for all
 *  &lt;code&gt;Struct&lt;/code&gt;s in the system and should start with a capital
 *  letter. Assigning a structure class to a constant effectively gives
 *  the class the name of the constant.
 *     
 *  &lt;code&gt;Struct::new&lt;/code&gt; returns a new &lt;code&gt;Class&lt;/code&gt; object,
 *  which can then be used to create specific instances of the new
 *  structure. The number of actual parameters must be
 *  less than or equal to the number of attributes defined for this
 *  class; unset parameters default to \nil{}.  Passing too many
 *  parameters will raise an \E{ArgumentError}.
 *
 *  The remaining methods listed in this section (class and instance)
 *  are defined for this generated class. 
 *     
 *     # Create a structure with a name in Struct
 *     Struct.new(&quot;Customer&quot;, :name, :address)    #=&gt; Struct::Customer
 *     Struct::Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)   #=&gt; #&lt;Struct::Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;
 *     
 *     # Create a structure named by its constant
 *     Customer = Struct.new(:name, :address)     #=&gt; Customer
 *     Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)           #=&gt; #&lt;Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;
 */

static VALUE
rb_struct_s_def(argc, argv, klass)
    int argc;
    VALUE *argv;
    VALUE klass;
{
    VALUE name, rest;
    long i;
    VALUE st;
    ID id;

    rb_scan_args(argc, argv, &quot;1*&quot;, &amp;name, &amp;rest);
    if (!NIL_P(name) &amp;&amp; SYMBOL_P(name)) {
        rb_ary_unshift(rest, name);
        name = Qnil;
    }
    for (i=0; i&lt;RARRAY(rest)-&gt;len; i++) {
        id = rb_to_id(RARRAY(rest)-&gt;ptr[i]);
        RARRAY(rest)-&gt;ptr[i] = ID2SYM(id);
    }
    st = make_struct(name, rest, klass);
    if (rb_block_given_p()) {
        rb_mod_module_eval(0, 0, st);
    }

    return st;
}
</pre>
  </div>
</div>
</div>
<div id="M000887" class="method">
  <div id="M000887_title" class="title">
    <b>new</b>(...)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000887_source')" id="l_M000887_source">show source</a> ]</p>
  <div id="M000887_source" class="dyn-source">
<pre>
/*
 */

static VALUE
rb_struct_initialize(self, values)
    VALUE self, values;
{
    VALUE klass = rb_obj_class(self);
    VALUE size;
    long n;

    rb_struct_modify(self);
    size = rb_struct_iv_get(klass, &quot;__size__&quot;);
    n = FIX2LONG(size);
    if (n &lt; RARRAY(values)-&gt;len) {
        rb_raise(rb_eArgError, &quot;struct size differs&quot;);
    }
    MEMCPY(RSTRUCT(self)-&gt;ptr, RARRAY(values)-&gt;ptr, VALUE, RARRAY(values)-&gt;len);
    if (n &gt; RARRAY(values)-&gt;len) {
        rb_mem_clear(RSTRUCT(self)-&gt;ptr+RARRAY(values)-&gt;len,
                     n-RARRAY(values)-&gt;len);
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000908" class="method">
  <div id="M000908_title" class="title">
    <b>yaml_new</b>( klass, tag, val )
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000908_source')" id="l_M000908_source">show source</a> ]</p>
  <div id="M000908_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 52</span>
52:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">yaml_new</span>( <span class="ruby-identifier">klass</span>, <span class="ruby-identifier">tag</span>, <span class="ruby-identifier">val</span> )
53:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Hash</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">val</span>
54:             <span class="ruby-identifier">struct_type</span> = <span class="ruby-keyword kw">nil</span>
55: 
56:             <span class="ruby-comment cmt">#</span>
57:             <span class="ruby-comment cmt"># Use existing Struct if it exists</span>
58:             <span class="ruby-comment cmt">#</span>
59:             <span class="ruby-identifier">props</span> = {}
60:             <span class="ruby-identifier">val</span>.<span class="ruby-identifier">delete_if</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">props</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">v</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^@/</span> }
61:             <span class="ruby-keyword kw">begin</span>
62:                 <span class="ruby-identifier">struct_name</span>, <span class="ruby-identifier">struct_type</span> = <span class="ruby-constant">YAML</span>.<span class="ruby-identifier">read_type_class</span>( <span class="ruby-identifier">tag</span>, <span class="ruby-constant">Struct</span> )
63:             <span class="ruby-keyword kw">rescue</span> <span class="ruby-constant">NameError</span>
64:             <span class="ruby-keyword kw">end</span>
65:             <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">struct_type</span>
66:                 <span class="ruby-identifier">struct_def</span> = [ <span class="ruby-identifier">tag</span>.<span class="ruby-identifier">split</span>( <span class="ruby-value str">':'</span>, <span class="ruby-value">4</span> ).<span class="ruby-identifier">last</span> ]
67:                 <span class="ruby-identifier">struct_type</span> = <span class="ruby-constant">Struct</span>.<span class="ruby-identifier">new</span>( <span class="ruby-operator">*</span><span class="ruby-identifier">struct_def</span>.<span class="ruby-identifier">concat</span>( <span class="ruby-identifier">val</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">k</span>.<span class="ruby-identifier">intern</span> } ) ) 
68:             <span class="ruby-keyword kw">end</span>
69: 
70:             <span class="ruby-comment cmt">#</span>
71:             <span class="ruby-comment cmt"># Set the Struct properties</span>
72:             <span class="ruby-comment cmt">#</span>
73:             <span class="ruby-identifier">st</span> = <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-identifier">object_maker</span>( <span class="ruby-identifier">struct_type</span>, {} )
74:             <span class="ruby-identifier">st</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
75:                 <span class="ruby-identifier">st</span>.<span class="ruby-identifier">send</span>( <span class="ruby-node">&quot;#{m}=&quot;</span>, <span class="ruby-identifier">val</span>[<span class="ruby-identifier">m</span>] )
76:             <span class="ruby-keyword kw">end</span>
77:             <span class="ruby-identifier">props</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span>
78:                 <span class="ruby-identifier">st</span>.<span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span>)
79:             <span class="ruby-keyword kw">end</span>
80:             <span class="ruby-identifier">st</span>
81:         <span class="ruby-keyword kw">else</span>
82:             <span class="ruby-identifier">raise</span> <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-constant">TypeError</span>, <span class="ruby-value str">&quot;Invalid Ruby Struct: &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">inspect</span>
83:         <span class="ruby-keyword kw">end</span>
84:     <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000906" class="method">
  <div id="M000906_title" class="title">
    <b>yaml_tag_class_name</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000906_source')" id="l_M000906_source">show source</a> ]</p>
  <div id="M000906_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 50</span>
50:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">yaml_tag_class_name</span>; <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">gsub</span>( <span class="ruby-value str">&quot;Struct::&quot;</span>, <span class="ruby-value str">&quot;&quot;</span> ); <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000907" class="method">
  <div id="M000907_title" class="title">
    <b>yaml_tag_read_class</b>( name )
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000907_source')" id="l_M000907_source">show source</a> ]</p>
  <div id="M000907_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 51</span>
51:     <span class="ruby-keyword kw">def</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">yaml_tag_read_class</span>( <span class="ruby-identifier">name</span> ); <span class="ruby-node">&quot;Struct::#{ name }&quot;</span>; <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div class="sectiontitle">Public Instance methods</div>
<div id="M000888" class="method">
  <div id="M000888_title" class="title">
    <b>struct == other_struct     => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Equality&#8212;Returns <tt>true</tt> if <em>other_struct</em> is equal to
this one: they must be of the same class as generated by
<tt>Struct::new</tt>, and the values of all instance variables must be
equal (according to <tt><a
href="index.html?a=C00000023&name=Object">Object</a>#==</tt>).
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe   = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joejr = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   jane  = Customer.new(&quot;Jane Doe&quot;, &quot;456 Elm, Anytown NC&quot;, 12345)
   joe == joejr   #=&gt; true
   joe == jane    #=&gt; false
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000888_source')" id="l_M000888_source">show source</a> ]</p>
  <div id="M000888_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct == other_struct     =&gt; true or false
 *  
 *  Equality---Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;other_struct&lt;/i&gt; is
 *  equal to this one: they must be of the same class as generated by
 *  &lt;code&gt;Struct::new&lt;/code&gt;, and the values of all instance variables
 *  must be equal (according to &lt;code&gt;Object#==&lt;/code&gt;).
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe   = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joejr = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     jane  = Customer.new(&quot;Jane Doe&quot;, &quot;456 Elm, Anytown NC&quot;, 12345)
 *     joe == joejr   #=&gt; true
 *     joe == jane    #=&gt; false
 */

static VALUE
rb_struct_equal(s, s2)
    VALUE s, s2;
{
    long i;

    if (s == s2) return Qtrue;
    if (TYPE(s2) != T_STRUCT) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT(s)-&gt;len != RSTRUCT(s2)-&gt;len) {
        rb_bug(&quot;inconsistent struct&quot;); /* should never happen */
    }

    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
        if (!rb_equal(RSTRUCT(s)-&gt;ptr[i], RSTRUCT(s2)-&gt;ptr[i])) return Qfalse;
    }
    return Qtrue;
}
</pre>
  </div>
</div>
</div>
<div id="M000899" class="method">
  <div id="M000899_title" class="title">
    <b>struct[symbol]    => anObject<br />
struct[fixnum]    => anObject <br />
</b>
  </div>
  <div class="description">
  <p>
Attribute Reference&#8212;Returns the value of the instance variable named
by <em>symbol</em>, or indexed (0..length-1) by <em>fixnum</em>. Will raise
<tt><a href="index.html?a=C00000001&name=NameError">NameError</a></tt> if
the named variable does not exist, or <tt><a
href="index.html?a=C00000084&name=IndexError">IndexError</a></tt> if the
index is out of range.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)

   joe[&quot;name&quot;]   #=&gt; &quot;Joe Smith&quot;
   joe[:name]    #=&gt; &quot;Joe Smith&quot;
   joe[0]        #=&gt; &quot;Joe Smith&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000899_source')" id="l_M000899_source">show source</a> ]</p>
  <div id="M000899_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct[symbol]    =&gt; anObject
 *     struct[fixnum]    =&gt; anObject 
 *  
 *  Attribute Reference---Returns the value of the instance variable
 *  named by &lt;i&gt;symbol&lt;/i&gt;, or indexed (0..length-1) by
 *  &lt;i&gt;fixnum&lt;/i&gt;. Will raise &lt;code&gt;NameError&lt;/code&gt; if the named
 *  variable does not exist, or &lt;code&gt;IndexError&lt;/code&gt; if the index is
 *  out of range.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     
 *     joe[&quot;name&quot;]   #=&gt; &quot;Joe Smith&quot;
 *     joe[:name]    #=&gt; &quot;Joe Smith&quot;
 *     joe[0]        #=&gt; &quot;Joe Smith&quot;
 */

VALUE
rb_struct_aref(s, idx)
    VALUE s, idx;
{
    long i;

    if (TYPE(idx) == T_STRING || TYPE(idx) == T_SYMBOL) {
        return rb_struct_aref_id(s, rb_to_id(idx));
    }

    i = NUM2LONG(idx);
    if (i &lt; 0) i = RSTRUCT(s)-&gt;len + i;
    if (i &lt; 0)
        rb_raise(rb_eIndexError, &quot;offset %ld too small for struct(size:%ld)&quot;,
                 i, RSTRUCT(s)-&gt;len);
    if (RSTRUCT(s)-&gt;len &lt;= i)
        rb_raise(rb_eIndexError, &quot;offset %ld too large for struct(size:%ld)&quot;,
                 i, RSTRUCT(s)-&gt;len);
    return RSTRUCT(s)-&gt;ptr[i];
}
</pre>
  </div>
</div>
</div>
<div id="M000900" class="method">
  <div id="M000900_title" class="title">
    <b>struct[symbol] = obj    => obj<br />
struct[fixnum] = obj    => obj<br />
</b>
  </div>
  <div class="description">
  <p>
Attribute Assignment&#8212;Assigns to the instance variable named by
<em>symbol</em> or <em>fixnum</em> the value <em>obj</em> and returns it.
Will raise a <tt><a
href="index.html?a=C00000001&name=NameError">NameError</a></tt> if the
named variable does not exist, or an <tt><a
href="index.html?a=C00000084&name=IndexError">IndexError</a></tt> if the
index is out of range.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)

   joe[&quot;name&quot;] = &quot;Luke&quot;
   joe[:zip]   = &quot;90210&quot;

   joe.name   #=&gt; &quot;Luke&quot;
   joe.zip    #=&gt; &quot;90210&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000900_source')" id="l_M000900_source">show source</a> ]</p>
  <div id="M000900_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct[symbol] = obj    =&gt; obj
 *     struct[fixnum] = obj    =&gt; obj
 *  
 *  Attribute Assignment---Assigns to the instance variable named by
 *  &lt;i&gt;symbol&lt;/i&gt; or &lt;i&gt;fixnum&lt;/i&gt; the value &lt;i&gt;obj&lt;/i&gt; and
 *  returns it. Will raise a &lt;code&gt;NameError&lt;/code&gt; if the named
 *  variable does not exist, or an &lt;code&gt;IndexError&lt;/code&gt; if the index
 *  is out of range.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     
 *     joe[&quot;name&quot;] = &quot;Luke&quot;
 *     joe[:zip]   = &quot;90210&quot;
 *     
 *     joe.name   #=&gt; &quot;Luke&quot;
 *     joe.zip    #=&gt; &quot;90210&quot;
 */

VALUE
rb_struct_aset(s, idx, val)
    VALUE s, idx, val;
{
    long i;

    if (TYPE(idx) == T_STRING || TYPE(idx) == T_SYMBOL) {
        return rb_struct_aset_id(s, rb_to_id(idx), val);
    }

    i = NUM2LONG(idx);
    if (i &lt; 0) i = RSTRUCT(s)-&gt;len + i;
    if (i &lt; 0) {
        rb_raise(rb_eIndexError, &quot;offset %ld too small for struct(size:%ld)&quot;,
                 i, RSTRUCT(s)-&gt;len);
    }
    if (RSTRUCT(s)-&gt;len &lt;= i) {
        rb_raise(rb_eIndexError, &quot;offset %ld too large for struct(size:%ld)&quot;,
                 i, RSTRUCT(s)-&gt;len);
    }
    rb_struct_modify(s);
    return RSTRUCT(s)-&gt;ptr[i] = val;
}
</pre>
  </div>
</div>
</div>
<div id="M000897" class="method">
  <div id="M000897_title" class="title">
    <b>struct.each {|obj| block }  => struct<br />
</b>
  </div>
  <div class="description">
  <p>
Calls <em>block</em> once for each instance variable, passing the value as
a parameter.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joe.each {|x| puts(x) }
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Joe Smith
   123 Maple, Anytown NC
   12345
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000897_source')" id="l_M000897_source">show source</a> ]</p>
  <div id="M000897_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.each {|obj| block }  =&gt; struct
 *  
 *  Calls &lt;i&gt;block&lt;/i&gt; once for each instance variable, passing the
 *  value as a parameter.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.each {|x| puts(x) }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Joe Smith
 *     123 Maple, Anytown NC
 *     12345
 */

static VALUE
rb_struct_each(s)
    VALUE s;
{
    long i;

    RETURN_ENUMERATOR(s, 0, 0);
    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
        rb_yield(RSTRUCT(s)-&gt;ptr[i]);
    }
    return s;
}
</pre>
  </div>
</div>
</div>
<div id="M000898" class="method">
  <div id="M000898_title" class="title">
    <b>struct.each_pair {|sym, obj| block }     => struct<br />
</b>
  </div>
  <div class="description">
  <p>
Calls <em>block</em> once for each instance variable, passing the name (as
a symbol) and the value as parameters.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joe.each_pair {|name, value| puts(&quot;#{name} =&gt; #{value}&quot;) }
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   name =&gt; Joe Smith
   address =&gt; 123 Maple, Anytown NC
   zip =&gt; 12345
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000898_source')" id="l_M000898_source">show source</a> ]</p>
  <div id="M000898_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.each_pair {|sym, obj| block }     =&gt; struct
 *  
 *  Calls &lt;i&gt;block&lt;/i&gt; once for each instance variable, passing the name
 *  (as a symbol) and the value as parameters.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.each_pair {|name, value| puts(&quot;#{name} =&gt; #{value}&quot;) }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     name =&gt; Joe Smith
 *     address =&gt; 123 Maple, Anytown NC
 *     zip =&gt; 12345
 */

static VALUE
rb_struct_each_pair(s)
    VALUE s;
{
    VALUE members;
    long i;

    RETURN_ENUMERATOR(s, 0, 0);
    members = rb_struct_members(s);
    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
        rb_yield_values(2, rb_ary_entry(members, i), RSTRUCT(s)-&gt;ptr[i]);
    }
    return s;
}
</pre>
  </div>
</div>
</div>
<div id="M000889" class="method">
  <div id="M000889_title" class="title">
    <b>eql?</b>(p1)
  </div>
  <div class="description">
  <p>
code-seq:
</p>
<pre>
  struct.eql?(other)   =&gt; true or false
</pre>
<p>
Two structures are equal if they are the same object, or if all their
fields are equal (using <tt>eql?</tt>).
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000889_source')" id="l_M000889_source">show source</a> ]</p>
  <div id="M000889_source" class="dyn-source">
<pre>
/*
 * code-seq:
 *   struct.eql?(other)   =&gt; true or false
 *
 * Two structures are equal if they are the same object, or if all their
 * fields are equal (using &lt;code&gt;eql?&lt;/code&gt;).
 */

static VALUE
rb_struct_eql(s, s2)
    VALUE s, s2;
{
    long i;

    if (s == s2) return Qtrue;
    if (TYPE(s2) != T_STRUCT) return Qfalse;
    if (rb_obj_class(s) != rb_obj_class(s2)) return Qfalse;
    if (RSTRUCT(s)-&gt;len != RSTRUCT(s2)-&gt;len) {
        rb_bug(&quot;inconsistent struct&quot;); /* should never happen */
    }

    for (i=0; i&lt;RSTRUCT(s)-&gt;len; i++) {
        if (!rb_eql(RSTRUCT(s)-&gt;ptr[i], RSTRUCT(s2)-&gt;ptr[i])) return Qfalse;
    }
    return Qtrue;
}
</pre>
  </div>
</div>
</div>
<div id="M000890" class="method">
  <div id="M000890_title" class="title">
    <b>struct.hash   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Return a hash value based on this struct&#8217;s contents.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000890_source')" id="l_M000890_source">show source</a> ]</p>
  <div id="M000890_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *   struct.hash   =&gt; fixnum
 *
 * Return a hash value based on this struct's contents.
 */

static VALUE
rb_struct_hash(s)
    VALUE s;
{
    long i, h;
    VALUE n;

    h = rb_hash(rb_obj_class(s));
    for (i = 0; i &lt; RSTRUCT(s)-&gt;len; i++) {
        h = (h &lt;&lt; 1) | (h&lt;0 ? 1 : 0);
        n = rb_hash(RSTRUCT(s)-&gt;ptr[i]);
        h ^= NUM2LONG(n);
    }
    return LONG2FIX(h);
}
</pre>
  </div>
</div>
</div>
<div id="M000892" class="method">
  <div id="M000892_title" class="title">
    <b>struct.to_s      => string<br />
struct.inspect   => string<br />
</b>
  </div>
  <div class="description">
  <p>
Describe the contents of this struct in a string.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000892_source')" id="l_M000892_source">show source</a> ]</p>
  <div id="M000892_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *   struct.to_s      =&gt; string
 *   struct.inspect   =&gt; string
 *
 * Describe the contents of this struct in a string.
 */

static VALUE
rb_struct_inspect(s)
    VALUE s;
{
    if (rb_inspecting_p(s)) {
        const char *cname = rb_class2name(rb_obj_class(s));
        size_t len = strlen(cname) + 14;
        VALUE str = rb_str_new(0, len);

        snprintf(RSTRING(str)-&gt;ptr, len+1, &quot;#&lt;struct %s:...&gt;&quot;, cname);
        RSTRING(str)-&gt;len = strlen(RSTRING(str)-&gt;ptr);
        return str;
    }
    return rb_protect_inspect(inspect_struct, s, 0);
}
</pre>
  </div>
</div>
</div>
<div id="M000896" class="method">
  <div id="M000896_title" class="title">
    <b>struct.length    => fixnum<br />
struct.size      => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the number of instance variables.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joe.length   #=&gt; 3
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000896_source')" id="l_M000896_source">show source</a> ]</p>
  <div id="M000896_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.length    =&gt; fixnum
 *     struct.size      =&gt; fixnum
 *  
 *  Returns the number of instance variables.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.length   #=&gt; 3
 */

static VALUE
rb_struct_size(s)
    VALUE s;
{
    return LONG2FIX(RSTRUCT(s)-&gt;len);
}
</pre>
  </div>
</div>
</div>
<div id="M000903" class="method">
  <div id="M000903_title" class="title">
    <b>struct.members    => array<br />
</b>
  </div>
  <div class="description">
  <p>
Returns an array of strings representing the names of the instance
variables.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joe.members   #=&gt; [&quot;name&quot;, &quot;address&quot;, &quot;zip&quot;]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000903_source')" id="l_M000903_source">show source</a> ]</p>
  <div id="M000903_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.members    =&gt; array
 *  
 *  Returns an array of strings representing the names of the instance
 *  variables.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.members   #=&gt; [&quot;name&quot;, &quot;address&quot;, &quot;zip&quot;]
 */

static VALUE
rb_struct_members_m(obj)
    VALUE obj;
{
    return rb_struct_s_members_m(rb_obj_class(obj));
}
</pre>
  </div>
</div>
</div>
<div id="M000904" class="method">
  <div id="M000904_title" class="title">
    <b>pretty_print</b>(q)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000904_source')" id="l_M000904_source">show source</a> ]</p>
  <div id="M000904_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/pp.rb, line 331</span>
331:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pretty_print</span>(<span class="ruby-identifier">q</span>)
332:     <span class="ruby-identifier">q</span>.<span class="ruby-identifier">group</span>(<span class="ruby-value">1</span>, <span class="ruby-value str">'#&lt;struct '</span> <span class="ruby-operator">+</span> <span class="ruby-constant">PP</span>.<span class="ruby-identifier">mcall</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-constant">Kernel</span>, <span class="ruby-identifier">:class</span>).<span class="ruby-identifier">name</span>, <span class="ruby-value str">'&gt;'</span>) {
333:       <span class="ruby-identifier">q</span>.<span class="ruby-identifier">seplist</span>(<span class="ruby-constant">PP</span>.<span class="ruby-identifier">mcall</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-constant">Struct</span>, <span class="ruby-identifier">:members</span>), <span class="ruby-identifier">lambda</span> { <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span> <span class="ruby-value str">&quot;,&quot;</span> }) {<span class="ruby-operator">|</span><span class="ruby-identifier">member</span><span class="ruby-operator">|</span>
334:         <span class="ruby-identifier">q</span>.<span class="ruby-identifier">breakable</span>
335:         <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span> <span class="ruby-identifier">member</span>.<span class="ruby-identifier">to_s</span>
336:         <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span> <span class="ruby-value str">'='</span>
337:         <span class="ruby-identifier">q</span>.<span class="ruby-identifier">group</span>(<span class="ruby-value">1</span>) {
338:           <span class="ruby-identifier">q</span>.<span class="ruby-identifier">breakable</span> <span class="ruby-value str">''</span>
339:           <span class="ruby-identifier">q</span>.<span class="ruby-identifier">pp</span> <span class="ruby-keyword kw">self</span>[<span class="ruby-identifier">member</span>]
340:         }
341:       }
342:     }
343:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000905" class="method">
  <div id="M000905_title" class="title">
    <b>pretty_print_cycle</b>(q)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000905_source')" id="l_M000905_source">show source</a> ]</p>
  <div id="M000905_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/pp.rb, line 345</span>
345:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">pretty_print_cycle</span>(<span class="ruby-identifier">q</span>)
346:     <span class="ruby-identifier">q</span>.<span class="ruby-identifier">text</span> <span class="ruby-identifier">sprintf</span>(<span class="ruby-value str">&quot;#&lt;struct %s:...&gt;&quot;</span>, <span class="ruby-constant">PP</span>.<span class="ruby-identifier">mcall</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-constant">Kernel</span>, <span class="ruby-identifier">:class</span>).<span class="ruby-identifier">name</span>)
347:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000901" class="method">
  <div id="M000901_title" class="title">
    <b>struct.select {|i| block }    => array<br />
</b>
  </div>
  <div class="description">
  <p>
Invokes the block passing in successive elements from <em>struct</em>,
returning an array containing those elements for which the block returns a
true value (equivalent to <tt><a
href="index.html?a=M003077&name=Enumerable#select">Enumerable#select</a></tt>).
</p>
<pre>
   Lots = Struct.new(:a, :b, :c, :d, :e, :f)
   l = Lots.new(11, 22, 33, 44, 55, 66)
   l.select {|v| (v % 2).zero? }   #=&gt; [22, 44, 66]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000901_source')" id="l_M000901_source">show source</a> ]</p>
  <div id="M000901_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.select {|i| block }    =&gt; array
 *  
 *  Invokes the block passing in successive elements from
 *  &lt;i&gt;struct&lt;/i&gt;, returning an array containing those elements
 *  for which the block returns a true value (equivalent to
 *  &lt;code&gt;Enumerable#select&lt;/code&gt;).
 *     
 *     Lots = Struct.new(:a, :b, :c, :d, :e, :f)
 *     l = Lots.new(11, 22, 33, 44, 55, 66)
 *     l.select {|v| (v % 2).zero? }   #=&gt; [22, 44, 66]
 */

static VALUE
rb_struct_select(argc, argv, s)
    int argc;
    VALUE *argv;
    VALUE s;
{
    VALUE result;
    long i;

    if (argc &gt; 0) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 0)&quot;, argc);
    }
    result = rb_ary_new();
    for (i = 0; i &lt; RSTRUCT(s)-&gt;len; i++) {
        if (RTEST(rb_yield(RSTRUCT(s)-&gt;ptr[i]))) {
            rb_ary_push(result, RSTRUCT(s)-&gt;ptr[i]);
        }
    }

    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M000895" class="method">
  <div id="M000895_title" class="title">
    <b>struct.length    => fixnum<br />
struct.size      => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the number of instance variables.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joe.length   #=&gt; 3
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000895_source')" id="l_M000895_source">show source</a> ]</p>
  <div id="M000895_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.length    =&gt; fixnum
 *     struct.size      =&gt; fixnum
 *  
 *  Returns the number of instance variables.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.length   #=&gt; 3
 */

static VALUE
rb_struct_size(s)
    VALUE s;
{
    return LONG2FIX(RSTRUCT(s)-&gt;len);
}
</pre>
  </div>
</div>
</div>
<div id="M000893" class="method">
  <div id="M000893_title" class="title">
    <b>struct.to_a     => array<br />
struct.values   => array<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the values for this instance as an array.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joe.to_a[1]   #=&gt; &quot;123 Maple, Anytown NC&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000893_source')" id="l_M000893_source">show source</a> ]</p>
  <div id="M000893_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.to_a     =&gt; array
 *     struct.values   =&gt; array
 *  
 *  Returns the values for this instance as an array.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.to_a[1]   #=&gt; &quot;123 Maple, Anytown NC&quot;
 */

static VALUE
rb_struct_to_a(s)
    VALUE s;
{
    return rb_ary_new4(RSTRUCT(s)-&gt;len, RSTRUCT(s)-&gt;ptr);
}
</pre>
  </div>
</div>
</div>
<div id="M000891" class="method">
  <div id="M000891_title" class="title">
    <b>struct.to_s      => string<br />
struct.inspect   => string<br />
</b>
  </div>
  <div class="description">
  <p>
Describe the contents of this struct in a string.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000891_source')" id="l_M000891_source">show source</a> ]</p>
  <div id="M000891_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *   struct.to_s      =&gt; string
 *   struct.inspect   =&gt; string
 *
 * Describe the contents of this struct in a string.
 */

static VALUE
rb_struct_inspect(s)
    VALUE s;
{
    if (rb_inspecting_p(s)) {
        const char *cname = rb_class2name(rb_obj_class(s));
        size_t len = strlen(cname) + 14;
        VALUE str = rb_str_new(0, len);

        snprintf(RSTRING(str)-&gt;ptr, len+1, &quot;#&lt;struct %s:...&gt;&quot;, cname);
        RSTRING(str)-&gt;len = strlen(RSTRING(str)-&gt;ptr);
        return str;
    }
    return rb_protect_inspect(inspect_struct, s, 0);
}
</pre>
  </div>
</div>
</div>
<div id="M000909" class="method">
  <div id="M000909_title" class="title">
    <b>to_yaml</b>( opts = {} )
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000909_source')" id="l_M000909_source">show source</a> ]</p>
  <div id="M000909_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 85</span>
85:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">to_yaml</span>( <span class="ruby-identifier">opts</span> = {} )
86:                 <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-identifier">quick_emit</span>( <span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">opts</span> ) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">out</span><span class="ruby-operator">|</span>
87:                         <span class="ruby-comment cmt">#</span>
88:                         <span class="ruby-comment cmt"># Basic struct is passed as a YAML map</span>
89:                         <span class="ruby-comment cmt">#</span>
90:             <span class="ruby-identifier">out</span>.<span class="ruby-identifier">map</span>( <span class="ruby-identifier">taguri</span>, <span class="ruby-identifier">to_yaml_style</span> ) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">map</span><span class="ruby-operator">|</span>
91:                                 <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">members</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
92:                     <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>( <span class="ruby-identifier">m</span>, <span class="ruby-keyword kw">self</span>[<span class="ruby-identifier">m</span>] )
93:                 <span class="ruby-keyword kw">end</span>
94:                                 <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">to_yaml_properties</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
95:                     <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>( <span class="ruby-identifier">m</span>, <span class="ruby-identifier">instance_variable_get</span>( <span class="ruby-identifier">m</span> ) )
96:                 <span class="ruby-keyword kw">end</span>
97:             <span class="ruby-keyword kw">end</span>
98:         <span class="ruby-keyword kw">end</span>
99:         <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000894" class="method">
  <div id="M000894_title" class="title">
    <b>struct.to_a     => array<br />
struct.values   => array<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the values for this instance as an array.
</p>
<pre>
   Customer = Struct.new(:name, :address, :zip)
   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
   joe.to_a[1]   #=&gt; &quot;123 Maple, Anytown NC&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000894_source')" id="l_M000894_source">show source</a> ]</p>
  <div id="M000894_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     struct.to_a     =&gt; array
 *     struct.values   =&gt; array
 *  
 *  Returns the values for this instance as an array.
 *     
 *     Customer = Struct.new(:name, :address, :zip)
 *     joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)
 *     joe.to_a[1]   #=&gt; &quot;123 Maple, Anytown NC&quot;
 */

static VALUE
rb_struct_to_a(s)
    VALUE s;
{
    return rb_ary_new4(RSTRUCT(s)-&gt;len, RSTRUCT(s)-&gt;ptr);
}
</pre>
  </div>
</div>
</div>
<div id="M000902" class="method">
  <div id="M000902_title" class="title">
    <b>struct.values_at(selector,... )  => an_array<br />
</b>
  </div>
  <div class="description">
  <p>
Returns an array containing the elements in <em>self</em> corresponding to
the given selector(s). The selectors may be either integer indices or
ranges. See also &lt;/code&gt;.select&lt;code&gt;.
</p>
<pre>
   a = %w{ a b c d e f }
   a.values_at(1, 3, 5)
   a.values_at(1, 3, 5, 7)
   a.values_at(-1, -3, -5, -7)
   a.values_at(1..3, 2...5)
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000902_source')" id="l_M000902_source">show source</a> ]</p>
  <div id="M000902_source" class="dyn-source">
<pre>
/* 
 * call-seq:
 *   struct.values_at(selector,... )  =&gt; an_array
 *
 *   Returns an array containing the elements in
 *   _self_ corresponding to the given selector(s). The selectors
 *   may be either integer indices or ranges. 
 *   See also &lt;/code&gt;.select&lt;code&gt;.
 * 
 *      a = %w{ a b c d e f }
 *      a.values_at(1, 3, 5)
 *      a.values_at(1, 3, 5, 7)
 *      a.values_at(-1, -3, -5, -7)
 *      a.values_at(1..3, 2...5)
 */

static VALUE
rb_struct_values_at(argc, argv, s)
    int argc;
    VALUE *argv;
    VALUE s;
{
    return rb_values_at(s, RSTRUCT(s)-&gt;len, argc, argv, struct_entry);
}
</pre>
  </div>
</div>
</div>
</div>

  </div>