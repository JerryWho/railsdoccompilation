  <div id="C00000055">
<div class='banner'>
  <span class="file-title-prefix">Class</span><br />String<br/>
  In:
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/string_c.html');">ruby-1.8.7-p22/string.c</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/jcode_rb.html');">ruby-1.8.7-p22/lib/jcode.rb</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/scanf_rb.html');">ruby-1.8.7-p22/lib/scanf.rb</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/shellwords_rb.html');">ruby-1.8.7-p22/lib/shellwords.rb</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/lib/yaml/rubytypes_rb.html');">ruby-1.8.7-p22/lib/yaml/rubytypes.rb</a>
<a href="#" onclick="jsHref('files/ruby-1_8_7-p22/ext/nkf/lib/kconv_rb.html');">ruby-1.8.7-p22/ext/nkf/lib/kconv.rb</a>

</div>
 <!-- banner header -->

  <div id="bodyContent" >
      <div id="content">

  <div class="description"><p>
A <tt><a href="index.html?a=C00000055&name=String">String</a></tt> object
holds and manipulates an arbitrary sequence of bytes, typically
representing characters. <a
href="index.html?a=C00000055&name=String">String</a> objects may be created
using <tt>String::new</tt> or as literals.
</p>
<p>
Because of aliasing issues, users of strings should be aware of the methods
that modify the contents of a <tt><a
href="index.html?a=C00000055&name=String">String</a></tt> object.
Typically, methods with names ending in ``!&#8217;&#8217; modify their
receiver, while those without a ``!&#8217;&#8217; return a new <tt><a
href="index.html?a=C00000055&name=String">String</a></tt>. However, there
are exceptions, such as <tt><a
href="index.html?a=C00000055&name=String">String</a>#[]=</tt>.
</p>
</div>



  <div class="sectiontitle">Methods</div>
  <ul>
  <li><a href="index.html?a=M000754&name=%" >%</a></li>
  <li><a href="index.html?a=M000753&name=*" >*</a></li>
  <li><a href="index.html?a=M000752&name=+" >+</a></li>
  <li><a href="index.html?a=M000792&name=&lt;&lt;" >&lt;&lt;</a></li>
  <li><a href="index.html?a=M000747&name=&lt;=&gt;" >&lt;=&gt;</a></li>
  <li><a href="index.html?a=M000748&name===" >==</a></li>
  <li><a href="index.html?a=M000762&name==~" >=~</a></li>
  <li><a href="index.html?a=M000755&name=[]" >[]</a></li>
  <li><a href="index.html?a=M000756&name=[]=" >[]=</a></li>
  <li><a href="index.html?a=M000857&name=block_scanf" >block_scanf</a></li>
  <li><a href="index.html?a=M000831&name=bytes" >bytes</a></li>
  <li><a href="index.html?a=M000760&name=bytesize" >bytesize</a></li>
  <li><a href="index.html?a=M000780&name=capitalize" >capitalize</a></li>
  <li><a href="index.html?a=M000784&name=capitalize!" >capitalize!</a></li>
  <li><a href="index.html?a=M000751&name=casecmp" >casecmp</a></li>
  <li><a href="index.html?a=M000802&name=center" >center</a></li>
  <li><a href="index.html?a=M000832&name=chars" >chars</a></li>
  <li><a href="index.html?a=M000806&name=chomp" >chomp</a></li>
  <li><a href="index.html?a=M000813&name=chomp!" >chomp!</a></li>
  <li><a href="index.html?a=M000805&name=chop" >chop</a></li>
  <li><a href="index.html?a=M000851&name=chop" >chop</a></li>
  <li><a href="index.html?a=M000812&name=chop!" >chop!</a></li>
  <li><a href="index.html?a=M000850&name=chop!" >chop!</a></li>
  <li><a href="index.html?a=M000791&name=concat" >concat</a></li>
  <li><a href="index.html?a=M000821&name=count" >count</a></li>
  <li><a href="index.html?a=M000793&name=crypt" >crypt</a></li>
  <li><a href="index.html?a=M000845&name=delete" >delete</a></li>
  <li><a href="index.html?a=M000819&name=delete" >delete</a></li>
  <li><a href="index.html?a=M000844&name=delete!" >delete!</a></li>
  <li><a href="index.html?a=M000824&name=delete!" >delete!</a></li>
  <li><a href="index.html?a=M000779&name=downcase" >downcase</a></li>
  <li><a href="index.html?a=M000783&name=downcase!" >downcase!</a></li>
  <li><a href="index.html?a=M000777&name=dump" >dump</a></li>
  <li><a href="index.html?a=M000827&name=each" >each</a></li>
  <li><a href="index.html?a=M000828&name=each_byte" >each_byte</a></li>
  <li><a href="index.html?a=M000855&name=each_char" >each_char</a></li>
  <li><a href="index.html?a=M000829&name=each_char" >each_char</a></li>
  <li><a href="index.html?a=M000826&name=each_line" >each_line</a></li>
  <li><a href="index.html?a=M000761&name=empty?" >empty?</a></li>
  <li><a href="index.html?a=M000839&name=end_regexp" >end_regexp</a></li>
  <li><a href="index.html?a=M000798&name=end_with?" >end_with?</a></li>
  <li><a href="index.html?a=M000749&name=eql?" >eql?</a></li>
  <li><a href="index.html?a=M000804&name=gsub" >gsub</a></li>
  <li><a href="index.html?a=M000811&name=gsub!" >gsub!</a></li>
  <li><a href="index.html?a=M000750&name=hash" >hash</a></li>
  <li><a href="index.html?a=M000786&name=hex" >hex</a></li>
  <li><a href="index.html?a=M000796&name=include?" >include?</a></li>
  <li><a href="index.html?a=M000769&name=index" >index</a></li>
  <li><a href="index.html?a=M000746&name=initialize_copy" >initialize_copy</a></li>
  <li><a href="index.html?a=M000757&name=insert" >insert</a></li>
  <li><a href="index.html?a=M000776&name=inspect" >inspect</a></li>
  <li><a href="index.html?a=M000794&name=intern" >intern</a></li>
  <li><a href="index.html?a=M000861&name=is_binary_data?" >is_binary_data?</a></li>
  <li><a href="index.html?a=M000860&name=is_complex_yaml?" >is_complex_yaml?</a></li>
  <li><a href="index.html?a=M000870&name=iseuc" >iseuc</a></li>
  <li><a href="index.html?a=M000871&name=issjis" >issjis</a></li>
  <li><a href="index.html?a=M000872&name=isutf8" >isutf8</a></li>
  <li><a href="index.html?a=M000854&name=jcount" >jcount</a></li>
  <li><a href="index.html?a=M000852&name=jlength" >jlength</a></li>
  <li><a href="index.html?a=M000853&name=jsize" >jsize</a></li>
  <li><a href="index.html?a=M000864&name=kconv" >kconv</a></li>
  <li><a href="index.html?a=M000758&name=length" >length</a></li>
  <li><a href="index.html?a=M000830&name=lines" >lines</a></li>
  <li><a href="index.html?a=M000800&name=ljust" >ljust</a></li>
  <li><a href="index.html?a=M000808&name=lstrip" >lstrip</a></li>
  <li><a href="index.html?a=M000815&name=lstrip!" >lstrip!</a></li>
  <li><a href="index.html?a=M000763&name=match" >match</a></li>
  <li><a href="index.html?a=M000838&name=mbchar?" >mbchar?</a></li>
  <li><a href="index.html?a=M000745&name=new" >new</a></li>
  <li><a href="index.html?a=M000766&name=next" >next</a></li>
  <li><a href="index.html?a=M000767&name=next!" >next!</a></li>
  <li><a href="index.html?a=M000787&name=oct" >oct</a></li>
  <li><a href="index.html?a=M000836&name=partition" >partition</a></li>
  <li><a href="index.html?a=M000771&name=replace" >replace</a></li>
  <li><a href="index.html?a=M000789&name=reverse" >reverse</a></li>
  <li><a href="index.html?a=M000790&name=reverse!" >reverse!</a></li>
  <li><a href="index.html?a=M000770&name=rindex" >rindex</a></li>
  <li><a href="index.html?a=M000801&name=rjust" >rjust</a></li>
  <li><a href="index.html?a=M000837&name=rpartition" >rpartition</a></li>
  <li><a href="index.html?a=M000809&name=rstrip" >rstrip</a></li>
  <li><a href="index.html?a=M000816&name=rstrip!" >rstrip!</a></li>
  <li><a href="index.html?a=M000799&name=scan" >scan</a></li>
  <li><a href="index.html?a=M000856&name=scanf" >scanf</a></li>
  <li><a href="index.html?a=M000859&name=shellescape" >shellescape</a></li>
  <li><a href="index.html?a=M000858&name=shellsplit" >shellsplit</a></li>
  <li><a href="index.html?a=M000759&name=size" >size</a></li>
  <li><a href="index.html?a=M000834&name=slice" >slice</a></li>
  <li><a href="index.html?a=M000835&name=slice!" >slice!</a></li>
  <li><a href="index.html?a=M000788&name=split" >split</a></li>
  <li><a href="index.html?a=M000847&name=squeeze" >squeeze</a></li>
  <li><a href="index.html?a=M000820&name=squeeze" >squeeze</a></li>
  <li><a href="index.html?a=M000846&name=squeeze!" >squeeze!</a></li>
  <li><a href="index.html?a=M000825&name=squeeze!" >squeeze!</a></li>
  <li><a href="index.html?a=M000797&name=start_with?" >start_with?</a></li>
  <li><a href="index.html?a=M000807&name=strip" >strip</a></li>
  <li><a href="index.html?a=M000814&name=strip!" >strip!</a></li>
  <li><a href="index.html?a=M000803&name=sub" >sub</a></li>
  <li><a href="index.html?a=M000810&name=sub!" >sub!</a></li>
  <li><a href="index.html?a=M000764&name=succ" >succ</a></li>
  <li><a href="index.html?a=M000841&name=succ" >succ</a></li>
  <li><a href="index.html?a=M000765&name=succ!" >succ!</a></li>
  <li><a href="index.html?a=M000840&name=succ!" >succ!</a></li>
  <li><a href="index.html?a=M000833&name=sum" >sum</a></li>
  <li><a href="index.html?a=M000781&name=swapcase" >swapcase</a></li>
  <li><a href="index.html?a=M000785&name=swapcase!" >swapcase!</a></li>
  <li><a href="index.html?a=M000773&name=to_f" >to_f</a></li>
  <li><a href="index.html?a=M000772&name=to_i" >to_i</a></li>
  <li><a href="index.html?a=M000774&name=to_s" >to_s</a></li>
  <li><a href="index.html?a=M000775&name=to_str" >to_str</a></li>
  <li><a href="index.html?a=M000795&name=to_sym" >to_sym</a></li>
  <li><a href="index.html?a=M000863&name=to_yaml" >to_yaml</a></li>
  <li><a href="index.html?a=M000866&name=toeuc" >toeuc</a></li>
  <li><a href="index.html?a=M000865&name=tojis" >tojis</a></li>
  <li><a href="index.html?a=M000867&name=tosjis" >tosjis</a></li>
  <li><a href="index.html?a=M000869&name=toutf16" >toutf16</a></li>
  <li><a href="index.html?a=M000868&name=toutf8" >toutf8</a></li>
  <li><a href="index.html?a=M000843&name=tr" >tr</a></li>
  <li><a href="index.html?a=M000817&name=tr" >tr</a></li>
  <li><a href="index.html?a=M000842&name=tr!" >tr!</a></li>
  <li><a href="index.html?a=M000822&name=tr!" >tr!</a></li>
  <li><a href="index.html?a=M000849&name=tr_s" >tr_s</a></li>
  <li><a href="index.html?a=M000818&name=tr_s" >tr_s</a></li>
  <li><a href="index.html?a=M000848&name=tr_s!" >tr_s!</a></li>
  <li><a href="index.html?a=M000823&name=tr_s!" >tr_s!</a></li>
  <li><a href="index.html?a=M000744&name=unpack" >unpack</a></li>
  <li><a href="index.html?a=M000778&name=upcase" >upcase</a></li>
  <li><a href="index.html?a=M000782&name=upcase!" >upcase!</a></li>
  <li><a href="index.html?a=M000768&name=upto" >upto</a></li>
  <li><a href="index.html?a=M000862&name=yaml_new" >yaml_new</a></li>
  </ul>

<div class="sectiontitle">Included Modules</div>
<ul>
  <li><a href="#" onclick="jsHref('classes/Comparable.html');">Comparable</a></li>
  <li><a href="#" onclick="jsHref('classes/Enumerable.html');">Enumerable</a></li>
</ul>



  <div class="sectiontitle">Constants</div>
  <table border='0' cellpadding='5'>
  <tr valign='top'>
    <td class="attr-name">PATTERN_SJIS</td>
    <td>=</td>
    <td class="attr-value">'[\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]'</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">PATTERN_EUC</td>
    <td>=</td>
    <td class="attr-value">'[\xa1-\xfe][\xa1-\xfe]'</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">PATTERN_UTF8</td>
    <td>=</td>
    <td class="attr-value">'[\xc0-\xdf][\x80-\xbf]|[\xe0-\xef][\x80-\xbf][\x80-\xbf]'</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RE_SJIS</td>
    <td>=</td>
    <td class="attr-value">Regexp.new(PATTERN_SJIS, 0, 'n')</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RE_EUC</td>
    <td>=</td>
    <td class="attr-value">Regexp.new(PATTERN_EUC, 0, 'n')</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">RE_UTF8</td>
    <td>=</td>
    <td class="attr-value">Regexp.new(PATTERN_UTF8, 0, 'n')</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">SUCC</td>
    <td>=</td>
    <td class="attr-value">{}</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">HashCache</td>
    <td>=</td>
    <td class="attr-value">{}</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">TrPatternCache</td>
    <td>=</td>
    <td class="attr-value">{}</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">DeletePatternCache</td>
    <td>=</td>
    <td class="attr-value">{}</td>
  </tr>
  <tr valign='top'>
    <td class="attr-name">SqueezePatternCache</td>
    <td>=</td>
    <td class="attr-value">{}</td>
  </tr>
  </table>


<div class="sectiontitle">Public Class methods</div>
<div id="M000745" class="method">
  <div id="M000745_title" class="title">
    <b>String.new(str="")   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a new string object containing a copy of <em>str</em>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000745_source')" id="l_M000745_source">show source</a> ]</p>
  <div id="M000745_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     String.new(str=&quot;&quot;)   =&gt; new_str
 *  
 *  Returns a new string object containing a copy of &lt;i&gt;str&lt;/i&gt;.
 */

static VALUE
rb_str_init(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE orig;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;orig) == 1)
        rb_str_replace(str, orig);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000862" class="method">
  <div id="M000862_title" class="title">
    <b>yaml_new</b>( klass, tag, val )
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000862_source')" id="l_M000862_source">show source</a> ]</p>
  <div id="M000862_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 148</span>
148:     <span class="ruby-keyword kw">def</span> <span class="ruby-constant">String</span>.<span class="ruby-identifier">yaml_new</span>( <span class="ruby-identifier">klass</span>, <span class="ruby-identifier">tag</span>, <span class="ruby-identifier">val</span> )
149:         <span class="ruby-identifier">val</span> = <span class="ruby-identifier">val</span>.<span class="ruby-identifier">unpack</span>(<span class="ruby-value str">&quot;m&quot;</span>)[<span class="ruby-value">0</span>] <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;tag:yaml.org,2002:binary&quot;</span>
150:         <span class="ruby-identifier">val</span> = { <span class="ruby-value str">'str'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-identifier">val</span> } <span class="ruby-keyword kw">if</span> <span class="ruby-constant">String</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">val</span>
151:         <span class="ruby-keyword kw">if</span> <span class="ruby-constant">Hash</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">val</span>
152:             <span class="ruby-identifier">s</span> = <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">allocate</span>
153:             <span class="ruby-comment cmt"># Thank you, NaHi</span>
154:             <span class="ruby-constant">String</span>.<span class="ruby-identifier">instance_method</span>(<span class="ruby-identifier">:initialize</span>).
155:                   <span class="ruby-identifier">bind</span>(<span class="ruby-identifier">s</span>).
156:                   <span class="ruby-identifier">call</span>( <span class="ruby-identifier">val</span>.<span class="ruby-identifier">delete</span>( <span class="ruby-value str">'str'</span> ) )
157:             <span class="ruby-identifier">val</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>,<span class="ruby-identifier">v</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">instance_variable_set</span>( <span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span> ) }
158:             <span class="ruby-identifier">s</span>
159:         <span class="ruby-keyword kw">else</span>
160:             <span class="ruby-identifier">raise</span> <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-constant">TypeError</span>, <span class="ruby-value str">&quot;Invalid String: &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">inspect</span>
161:         <span class="ruby-keyword kw">end</span>
162:     <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div class="sectiontitle">Public Instance methods</div>
<div id="M000754" class="method">
  <div id="M000754_title" class="title">
    <b>str % arg   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Format&#8212;Uses <em>str</em> as a format specification, and returns the
result of applying it to <em>arg</em>. If the format specification contains
more than one substitution, then <em>arg</em> must be an <tt><a
href="index.html?a=C00000243&name=Array">Array</a></tt> containing the
values to be substituted. See <tt>Kernel::sprintf</tt> for details of the
format string.
</p>
<pre>
   &quot;%05d&quot; % 123                       #=&gt; &quot;00123&quot;
   &quot;%-5s: %08x&quot; % [ &quot;ID&quot;, self.id ]   #=&gt; &quot;ID   : 200e14d6&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000754_source')" id="l_M000754_source">show source</a> ]</p>
  <div id="M000754_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str % arg   =&gt; new_str
 *  
 *  Format---Uses &lt;i&gt;str&lt;/i&gt; as a format specification, and returns the result
 *  of applying it to &lt;i&gt;arg&lt;/i&gt;. If the format specification contains more than
 *  one substitution, then &lt;i&gt;arg&lt;/i&gt; must be an &lt;code&gt;Array&lt;/code&gt; containing
 *  the values to be substituted. See &lt;code&gt;Kernel::sprintf&lt;/code&gt; for details
 *  of the format string.
 *     
 *     &quot;%05d&quot; % 123                       #=&gt; &quot;00123&quot;
 *     &quot;%-5s: %08x&quot; % [ &quot;ID&quot;, self.id ]   #=&gt; &quot;ID   : 200e14d6&quot;
 */

static VALUE
rb_str_format_m(str, arg)
    VALUE str, arg;
{
    VALUE tmp = rb_check_array_type(arg);

    if (!NIL_P(tmp)) {
        return rb_str_format(RARRAY_LEN(tmp), RARRAY_PTR(tmp), str);
    }
    return rb_str_format(1, &amp;arg, str);
}
</pre>
  </div>
</div>
</div>
<div id="M000753" class="method">
  <div id="M000753_title" class="title">
    <b>str * integer   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Copy&#8212;Returns a new <tt><a
href="index.html?a=C00000055&name=String">String</a></tt> containing
<em>integer</em> copies of the receiver.
</p>
<pre>
   &quot;Ho! &quot; * 3   #=&gt; &quot;Ho! Ho! Ho! &quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000753_source')" id="l_M000753_source">show source</a> ]</p>
  <div id="M000753_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str * integer   =&gt; new_str
 *  
 *  Copy---Returns a new &lt;code&gt;String&lt;/code&gt; containing &lt;i&gt;integer&lt;/i&gt; copies of
 *  the receiver.
 *     
 *     &quot;Ho! &quot; * 3   #=&gt; &quot;Ho! Ho! Ho! &quot;
 */

VALUE
rb_str_times(str, times)
    VALUE str;
    VALUE times;
{
    VALUE str2;
    long i, len;

    len = NUM2LONG(times);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (len &amp;&amp; LONG_MAX/len &lt;  RSTRING(str)-&gt;len) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }

    str2 = rb_str_new5(str,0, len *= RSTRING(str)-&gt;len);
    for (i = 0; i &lt; len; i += RSTRING(str)-&gt;len) {
        memcpy(RSTRING(str2)-&gt;ptr + i,
               RSTRING(str)-&gt;ptr, RSTRING(str)-&gt;len);
    }
    RSTRING(str2)-&gt;ptr[RSTRING(str2)-&gt;len] = '\0';

    OBJ_INFECT(str2, str);

    return str2;
}
</pre>
  </div>
</div>
</div>
<div id="M000752" class="method">
  <div id="M000752_title" class="title">
    <b>str + other_str   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Concatenation&#8212;Returns a new <tt><a
href="index.html?a=C00000055&name=String">String</a></tt> containing
<em>other_str</em> concatenated to <em>str</em>.
</p>
<pre>
   &quot;Hello from &quot; + self.to_s   #=&gt; &quot;Hello from main&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000752_source')" id="l_M000752_source">show source</a> ]</p>
  <div id="M000752_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str + other_str   =&gt; new_str
 *  
 *  Concatenation---Returns a new &lt;code&gt;String&lt;/code&gt; containing
 *  &lt;i&gt;other_str&lt;/i&gt; concatenated to &lt;i&gt;str&lt;/i&gt;.
 *     
 *     &quot;Hello from &quot; + self.to_s   #=&gt; &quot;Hello from main&quot;
 */

VALUE
rb_str_plus(str1, str2)
    VALUE str1, str2;
{
    VALUE str3;

    StringValue(str2);
    str3 = rb_str_new(0, RSTRING(str1)-&gt;len+RSTRING(str2)-&gt;len);
    memcpy(RSTRING(str3)-&gt;ptr, RSTRING(str1)-&gt;ptr, RSTRING(str1)-&gt;len);
    memcpy(RSTRING(str3)-&gt;ptr + RSTRING(str1)-&gt;len,
           RSTRING(str2)-&gt;ptr, RSTRING(str2)-&gt;len);
    RSTRING(str3)-&gt;ptr[RSTRING(str3)-&gt;len] = '\0';

    if (OBJ_TAINTED(str1) || OBJ_TAINTED(str2))
        OBJ_TAINT(str3);
    return str3;
}
</pre>
  </div>
</div>
</div>
<div id="M000792" class="method">
  <div id="M000792_title" class="title">
    <b>str << fixnum        => str<br />
str.concat(fixnum)   => str<br />
str << obj           => str<br />
str.concat(obj)      => str<br />
</b>
  </div>
  <div class="description">
  <p>
Append&#8212;Concatenates the given object to <em>str</em>. If the object
is a <tt><a href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt>
between 0 and 255, it is converted to a character before concatenation.
</p>
<pre>
   a = &quot;hello &quot;
   a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
   a.concat(33)   #=&gt; &quot;hello world!&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000792_source')" id="l_M000792_source">show source</a> ]</p>
  <div id="M000792_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str &lt;&lt; fixnum        =&gt; str
 *     str.concat(fixnum)   =&gt; str
 *     str &lt;&lt; obj           =&gt; str
 *     str.concat(obj)      =&gt; str
 *  
 *  Append---Concatenates the given object to &lt;i&gt;str&lt;/i&gt;. If the object is a
 *  &lt;code&gt;Fixnum&lt;/code&gt; between 0 and 255, it is converted to a character before
 *  concatenation.
 *     
 *     a = &quot;hello &quot;
 *     a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
 *     a.concat(33)   #=&gt; &quot;hello world!&quot;
 */

VALUE
rb_str_concat(str1, str2)
    VALUE str1, str2;
{
    if (FIXNUM_P(str2)) {
        int i = FIX2INT(str2);
        if (0 &lt;= i &amp;&amp; i &lt;= 0xff) { /* byte */
            char c = i;
            return rb_str_cat(str1, &amp;c, 1);
        }
    }
    str1 = rb_str_append(str1, str2);

    return str1;
}
</pre>
  </div>
</div>
</div>
<div id="M000747" class="method">
  <div id="M000747_title" class="title">
    <b>str <=> other_str   => -1, 0, +1<br />
</b>
  </div>
  <div class="description">
  <p>
Comparison&#8212;Returns -1 if <em>other_str</em> is less than, 0 if
<em>other_str</em> is equal to, and +1 if <em>other_str</em> is greater
than <em>str</em>. If the strings are of different lengths, and the strings
are equal when compared up to the shortest length, then the longer string
is considered greater than the shorter one. If the variable <tt>$=</tt> is
<tt>false</tt>, the comparison is based on comparing the binary values of
each character in the string. In older versions of Ruby, setting
<tt>$=</tt> allowed case-insensitive comparisons; this is now deprecated in
favor of using <tt><a
href="index.html?a=M000751&name=String#casecmp">String#casecmp</a></tt>.
</p>
<p>
<tt>&lt;=&gt;</tt> is the basis for the methods <tt>&lt;</tt>,
<tt>&lt;=</tt>, <tt>&gt;</tt>, <tt>&gt;=</tt>, and <tt>between?</tt>,
included from module <tt><a
href="index.html?a=C00001584&name=Comparable">Comparable</a></tt>. The
method <tt><a href="index.html?a=C00000055&name=String">String</a>#==</tt>
does not use <tt><a
href="index.html?a=C00001584&name=Comparable">Comparable</a>#==</tt>.
</p>
<pre>
   &quot;abcdef&quot; &lt;=&gt; &quot;abcde&quot;     #=&gt; 1
   &quot;abcdef&quot; &lt;=&gt; &quot;abcdef&quot;    #=&gt; 0
   &quot;abcdef&quot; &lt;=&gt; &quot;abcdefg&quot;   #=&gt; -1
   &quot;abcdef&quot; &lt;=&gt; &quot;ABCDEF&quot;    #=&gt; 1
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000747_source')" id="l_M000747_source">show source</a> ]</p>
  <div id="M000747_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str &lt;=&gt; other_str   =&gt; -1, 0, +1
 *  
 *  Comparison---Returns -1 if &lt;i&gt;other_str&lt;/i&gt; is less than, 0 if
 *  &lt;i&gt;other_str&lt;/i&gt; is equal to, and +1 if &lt;i&gt;other_str&lt;/i&gt; is greater than
 *  &lt;i&gt;str&lt;/i&gt;. If the strings are of different lengths, and the strings are
 *  equal when compared up to the shortest length, then the longer string is
 *  considered greater than the shorter one. If the variable &lt;code&gt;$=&lt;/code&gt; is
 *  &lt;code&gt;false&lt;/code&gt;, the comparison is based on comparing the binary values
 *  of each character in the string. In older versions of Ruby, setting
 *  &lt;code&gt;$=&lt;/code&gt; allowed case-insensitive comparisons; this is now deprecated
 *  in favor of using &lt;code&gt;String#casecmp&lt;/code&gt;.
 *
 *  &lt;code&gt;&lt;=&gt;&lt;/code&gt; is the basis for the methods &lt;code&gt;&lt;&lt;/code&gt;,
 *  &lt;code&gt;&lt;=&lt;/code&gt;, &lt;code&gt;&gt;&lt;/code&gt;, &lt;code&gt;&gt;=&lt;/code&gt;, and &lt;code&gt;between?&lt;/code&gt;,
 *  included from module &lt;code&gt;Comparable&lt;/code&gt;.  The method
 *  &lt;code&gt;String#==&lt;/code&gt; does not use &lt;code&gt;Comparable#==&lt;/code&gt;.
 *     
 *     &quot;abcdef&quot; &lt;=&gt; &quot;abcde&quot;     #=&gt; 1
 *     &quot;abcdef&quot; &lt;=&gt; &quot;abcdef&quot;    #=&gt; 0
 *     &quot;abcdef&quot; &lt;=&gt; &quot;abcdefg&quot;   #=&gt; -1
 *     &quot;abcdef&quot; &lt;=&gt; &quot;ABCDEF&quot;    #=&gt; 1
 */

static VALUE
rb_str_cmp_m(str1, str2)
    VALUE str1, str2;
{
    long result;

    if (TYPE(str2) != T_STRING) {
        if (!rb_respond_to(str2, rb_intern(&quot;to_str&quot;))) {
            return Qnil;
        }
        else if (!rb_respond_to(str2, rb_intern(&quot;&lt;=&gt;&quot;))) {
            return Qnil;
        }
        else {
            VALUE tmp = rb_funcall(str2, rb_intern(&quot;&lt;=&gt;&quot;), 1, str1);

            if (NIL_P(tmp)) return Qnil;
            if (!FIXNUM_P(tmp)) {
                return rb_funcall(LONG2FIX(0), '-', 1, tmp);
            }
            result = -FIX2LONG(tmp);
        }
    }
    else {
        result = rb_str_cmp(str1, str2);
    }
    return LONG2NUM(result);
}
</pre>
  </div>
</div>
</div>
<div id="M000748" class="method">
  <div id="M000748_title" class="title">
    <b>str == obj   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Equality&#8212;If <em>obj</em> is not a <tt><a
href="index.html?a=C00000055&name=String">String</a></tt>, returns
<tt>false</tt>. Otherwise, returns <tt>true</tt> if <em>str</em>
<tt>&lt;=&gt;</tt> <em>obj</em> returns zero.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000748_source')" id="l_M000748_source">show source</a> ]</p>
  <div id="M000748_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str == obj   =&gt; true or false
 *  
 *  Equality---If &lt;i&gt;obj&lt;/i&gt; is not a &lt;code&gt;String&lt;/code&gt;, returns
 *  &lt;code&gt;false&lt;/code&gt;. Otherwise, returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt;
 *  &lt;code&gt;&lt;=&gt;&lt;/code&gt; &lt;i&gt;obj&lt;/i&gt; returns zero.
 */

static VALUE
rb_str_equal(str1, str2)
    VALUE str1, str2;
{
    if (str1 == str2) return Qtrue;
    if (TYPE(str2) != T_STRING) {
        if (!rb_respond_to(str2, rb_intern(&quot;to_str&quot;))) {
            return Qfalse;
        }
        return rb_equal(str2, str1);
    }
    if (RSTRING(str1)-&gt;len == RSTRING(str2)-&gt;len &amp;&amp;
        rb_str_cmp(str1, str2) == 0) {
        return Qtrue;
    }
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M000762" class="method">
  <div id="M000762_title" class="title">
    <b>str =~ obj   => fixnum or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Match&#8212;If <em>obj</em> is a <tt><a
href="index.html?a=C00000110&name=Regexp">Regexp</a></tt>, use it as a
pattern to match against <em>str</em>,and returns the position the match
starts, or <tt>nil</tt> if there is no match. Otherwise, invokes
<em>obj.=~</em>, passing <em>str</em> as an argument. The default
<tt>=~</tt> in <tt><a
href="index.html?a=C00000023&name=Object">Object</a></tt> returns
<tt>false</tt>.
</p>
<pre>
   &quot;cat o' 9 tails&quot; =~ /\d/   #=&gt; 7
   &quot;cat o' 9 tails&quot; =~ 9      #=&gt; false
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000762_source')" id="l_M000762_source">show source</a> ]</p>
  <div id="M000762_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str =~ obj   =&gt; fixnum or nil
 *  
 *  Match---If &lt;i&gt;obj&lt;/i&gt; is a &lt;code&gt;Regexp&lt;/code&gt;, use it as a pattern to match
 *  against &lt;i&gt;str&lt;/i&gt;,and returns the position the match starts, or 
 *  &lt;code&gt;nil&lt;/code&gt; if there is no match. Otherwise, invokes
 *  &lt;i&gt;obj.=~&lt;/i&gt;, passing &lt;i&gt;str&lt;/i&gt; as an argument. The default
 *  &lt;code&gt;=~&lt;/code&gt; in &lt;code&gt;Object&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
 *     
 *     &quot;cat o' 9 tails&quot; =~ /\d/   #=&gt; 7
 *     &quot;cat o' 9 tails&quot; =~ 9      #=&gt; false
 */

static VALUE
rb_str_match(x, y)
    VALUE x, y;
{
    switch (TYPE(y)) {
      case T_STRING:
        rb_raise(rb_eTypeError, &quot;type mismatch: String given&quot;);

      case T_REGEXP:
        return rb_reg_match(y, x);

      default:
        return rb_funcall(y, rb_intern(&quot;=~&quot;), 1, x);
    }
}
</pre>
  </div>
</div>
</div>
<div id="M000755" class="method">
  <div id="M000755_title" class="title">
    <b>str[fixnum]                 => fixnum or nil<br />
str[fixnum, fixnum]         => new_str or nil<br />
str[range]                  => new_str or nil<br />
str[regexp]                 => new_str or nil<br />
str[regexp, fixnum]         => new_str or nil<br />
str[other_str]              => new_str or nil<br />
str.slice(fixnum)           => fixnum or nil<br />
str.slice(fixnum, fixnum)   => new_str or nil<br />
str.slice(range)            => new_str or nil<br />
str.slice(regexp)           => new_str or nil<br />
str.slice(regexp, fixnum)   => new_str or nil<br />
str.slice(other_str)        => new_str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Element Reference&#8212;If passed a single <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt>, returns the code
of the character at that position. If passed two <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt> objects, returns
a substring starting at the offset given by the first, and a length given
by the second. If given a range, a substring containing characters at
offsets given by the range is returned. In all three cases, if an offset is
negative, it is counted from the end of <em>str</em>. Returns <tt>nil</tt>
if the initial offset falls outside the string, the length is negative, or
the beginning of the range is greater than the end.
</p>
<p>
If a <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt> is
supplied, the matching portion of <em>str</em> is returned. If a numeric
parameter follows the regular expression, that component of the <tt><a
href="index.html?a=C00000118&name=MatchData">MatchData</a></tt> is returned
instead. If a <tt><a
href="index.html?a=C00000055&name=String">String</a></tt> is given, that
string is returned if it occurs in <em>str</em>. In both cases,
<tt>nil</tt> is returned if there is no match.
</p>
<pre>
   a = &quot;hello there&quot;
   a[1]                   #=&gt; 101
   a[1,3]                 #=&gt; &quot;ell&quot;
   a[1..3]                #=&gt; &quot;ell&quot;
   a[-3,2]                #=&gt; &quot;er&quot;
   a[-4..-2]              #=&gt; &quot;her&quot;
   a[12..-1]              #=&gt; nil
   a[-2..-4]              #=&gt; &quot;&quot;
   a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
   a[/[aeiou](.)\1/, 2]   #=&gt; nil
   a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
   a[&quot;bye&quot;]               #=&gt; nil
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000755_source')" id="l_M000755_source">show source</a> ]</p>
  <div id="M000755_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str[fixnum]                 =&gt; fixnum or nil
 *     str[fixnum, fixnum]         =&gt; new_str or nil
 *     str[range]                  =&gt; new_str or nil
 *     str[regexp]                 =&gt; new_str or nil
 *     str[regexp, fixnum]         =&gt; new_str or nil
 *     str[other_str]              =&gt; new_str or nil
 *     str.slice(fixnum)           =&gt; fixnum or nil
 *     str.slice(fixnum, fixnum)   =&gt; new_str or nil
 *     str.slice(range)            =&gt; new_str or nil
 *     str.slice(regexp)           =&gt; new_str or nil
 *     str.slice(regexp, fixnum)   =&gt; new_str or nil
 *     str.slice(other_str)        =&gt; new_str or nil
 *  
 *  Element Reference---If passed a single &lt;code&gt;Fixnum&lt;/code&gt;, returns the code
 *  of the character at that position. If passed two &lt;code&gt;Fixnum&lt;/code&gt;
 *  objects, returns a substring starting at the offset given by the first, and
 *  a length given by the second. If given a range, a substring containing
 *  characters at offsets given by the range is returned. In all three cases, if
 *  an offset is negative, it is counted from the end of &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if the initial offset falls outside the string, the length
 *  is negative, or the beginning of the range is greater than the end.
 *     
 *  If a &lt;code&gt;Regexp&lt;/code&gt; is supplied, the matching portion of &lt;i&gt;str&lt;/i&gt; is
 *  returned. If a numeric parameter follows the regular expression, that
 *  component of the &lt;code&gt;MatchData&lt;/code&gt; is returned instead. If a
 *  &lt;code&gt;String&lt;/code&gt; is given, that string is returned if it occurs in
 *  &lt;i&gt;str&lt;/i&gt;. In both cases, &lt;code&gt;nil&lt;/code&gt; is returned if there is no
 *  match.
 *     
 *     a = &quot;hello there&quot;
 *     a[1]                   #=&gt; 101
 *     a[1,3]                 #=&gt; &quot;ell&quot;
 *     a[1..3]                #=&gt; &quot;ell&quot;
 *     a[-3,2]                #=&gt; &quot;er&quot;
 *     a[-4..-2]              #=&gt; &quot;her&quot;
 *     a[12..-1]              #=&gt; nil
 *     a[-2..-4]              #=&gt; &quot;&quot;
 *     a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
 *     a[/[aeiou](.)\1/, 2]   #=&gt; nil
 *     a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
 *     a[&quot;bye&quot;]               #=&gt; nil
 */

static VALUE
rb_str_aref_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    if (argc == 2) {
        if (TYPE(argv[0]) == T_REGEXP) {
            return rb_str_subpat(str, argv[0], NUM2INT(argv[1]));
        }
        return rb_str_substr(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]));
    }
    if (argc != 1) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1)&quot;, argc);
    }
    return rb_str_aref(str, argv[0]);
}
</pre>
  </div>
</div>
</div>
<div id="M000756" class="method">
  <div id="M000756_title" class="title">
    <b>str[fixnum] = fixnum<br />
str[fixnum] = new_str<br />
str[fixnum, fixnum] = new_str<br />
str[range] = aString<br />
str[regexp] = new_str<br />
str[regexp, fixnum] = new_str<br />
str[other_str] = new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Element Assignment&#8212;Replaces some or all of the content of
<em>str</em>. The portion of the string affected is determined using the
same criteria as <tt><a
href="index.html?a=C00000055&name=String">String</a>#[]</tt>. If the
replacement string is not the same length as the text it is replacing, the
string will be adjusted accordingly. If the regular expression or string is
used as the index doesn&#8217;t match a position in the string, <tt><a
href="index.html?a=C00000084&name=IndexError">IndexError</a></tt> is
raised. If the regular expression form is used, the optional second <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt> allows you to
specify which portion of the match to replace (effectively using the <tt><a
href="index.html?a=C00000118&name=MatchData">MatchData</a></tt> indexing
rules. The forms that take a <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt> will raise an
<tt><a href="index.html?a=C00000084&name=IndexError">IndexError</a></tt> if
the value is out of range; the <tt><a
href="index.html?a=C00000051&name=Range">Range</a></tt> form will raise a
<tt><a href="index.html?a=C00000210&name=RangeError">RangeError</a></tt>,
and the <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt>
and <tt><a href="index.html?a=C00000055&name=String">String</a></tt> forms
will silently ignore the assignment.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000756_source')" id="l_M000756_source">show source</a> ]</p>
  <div id="M000756_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str[fixnum] = fixnum
 *     str[fixnum] = new_str
 *     str[fixnum, fixnum] = new_str
 *     str[range] = aString
 *     str[regexp] = new_str
 *     str[regexp, fixnum] = new_str
 *     str[other_str] = new_str
 *  
 *  Element Assignment---Replaces some or all of the content of &lt;i&gt;str&lt;/i&gt;. The
 *  portion of the string affected is determined using the same criteria as
 *  &lt;code&gt;String#[]&lt;/code&gt;. If the replacement string is not the same length as
 *  the text it is replacing, the string will be adjusted accordingly. If the
 *  regular expression or string is used as the index doesn't match a position
 *  in the string, &lt;code&gt;IndexError&lt;/code&gt; is raised. If the regular expression
 *  form is used, the optional second &lt;code&gt;Fixnum&lt;/code&gt; allows you to specify
 *  which portion of the match to replace (effectively using the
 *  &lt;code&gt;MatchData&lt;/code&gt; indexing rules. The forms that take a
 *  &lt;code&gt;Fixnum&lt;/code&gt; will raise an &lt;code&gt;IndexError&lt;/code&gt; if the value is
 *  out of range; the &lt;code&gt;Range&lt;/code&gt; form will raise a
 *  &lt;code&gt;RangeError&lt;/code&gt;, and the &lt;code&gt;Regexp&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt;
 *  forms will silently ignore the assignment.
 */

static VALUE
rb_str_aset_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    if (argc == 3) {
        if (TYPE(argv[0]) == T_REGEXP) {
            rb_str_subpat_set(str, argv[0], NUM2INT(argv[1]), argv[2]);
        }
        else {
            rb_str_splice(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
        }
        return argv[2];
    }
    if (argc != 2) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2)&quot;, argc);
    }
    return rb_str_aset(str, argv[0], argv[1]);
}
</pre>
  </div>
</div>
</div>
<div id="M000857" class="method">
  <div id="M000857_title" class="title">
    <b>block_scanf</b>(fstr) {|current| ...}
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000857_source')" id="l_M000857_source">show source</a> ]</p>
  <div id="M000857_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/scanf.rb, line 684</span>
684:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">block_scanf</span>(<span class="ruby-identifier">fstr</span>,<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>)
685:     <span class="ruby-identifier">fs</span> = <span class="ruby-constant">Scanf</span><span class="ruby-operator">::</span><span class="ruby-constant">FormatString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">fstr</span>)
686:     <span class="ruby-identifier">str</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">dup</span>
687:     <span class="ruby-identifier">final</span> = []
688:     <span class="ruby-keyword kw">begin</span>
689:       <span class="ruby-identifier">current</span> = <span class="ruby-identifier">str</span>.<span class="ruby-identifier">scanf</span>(<span class="ruby-identifier">fs</span>)
690:       <span class="ruby-identifier">final</span>.<span class="ruby-identifier">push</span>(<span class="ruby-keyword kw">yield</span>(<span class="ruby-identifier">current</span>)) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">current</span>.<span class="ruby-identifier">empty?</span>
691:       <span class="ruby-identifier">str</span> = <span class="ruby-identifier">fs</span>.<span class="ruby-identifier">string_left</span>
692:     <span class="ruby-keyword kw">end</span> <span class="ruby-keyword kw">until</span> <span class="ruby-identifier">current</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">str</span>.<span class="ruby-identifier">empty?</span>
693:     <span class="ruby-keyword kw">return</span> <span class="ruby-identifier">final</span>
694:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000831" class="method">
  <div id="M000831_title" class="title">
    <b>str.bytes   => anEnumerator<br />
str.bytes {|fixnum| block }    => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns an enumerator that gives each byte in the string. If a block is
given, it iterates over each byte in the string.
</p>
<pre>
   &quot;hello&quot;.bytes.to_a        #=&gt; [104, 101, 108, 108, 111]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000831_source')" id="l_M000831_source">show source</a> ]</p>
  <div id="M000831_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.each_byte {|fixnum| block }    =&gt; str
 *  
 *  Passes each byte in &lt;i&gt;str&lt;/i&gt; to the given block.
 *     
 *     &quot;hello&quot;.each_byte {|c| print c, ' ' }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     104 101 108 108 111
 */

static VALUE
rb_str_each_byte(str)
    VALUE str;
{
    long i;

    RETURN_ENUMERATOR(str, 0, 0);
    for (i=0; i&lt;RSTRING(str)-&gt;len; i++) {
        rb_yield(INT2FIX(RSTRING(str)-&gt;ptr[i] &amp; 0xff));
    }
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000760" class="method">
  <div id="M000760_title" class="title">
    <b>str.length   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the length of <em>str</em>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000760_source')" id="l_M000760_source">show source</a> ]</p>
  <div id="M000760_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.length   =&gt; integer
 *  
 *  Returns the length of &lt;i&gt;str&lt;/i&gt;.
 */

static VALUE
rb_str_length(str)
    VALUE str;
{
    return LONG2NUM(RSTRING(str)-&gt;len);
}
</pre>
  </div>
</div>
</div>
<div id="M000780" class="method">
  <div id="M000780_title" class="title">
    <b>str.capitalize   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with the first character converted to
uppercase and the remainder to lowercase.
</p>
<pre>
   &quot;hello&quot;.capitalize    #=&gt; &quot;Hello&quot;
   &quot;HELLO&quot;.capitalize    #=&gt; &quot;Hello&quot;
   &quot;123ABC&quot;.capitalize   #=&gt; &quot;123abc&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000780_source')" id="l_M000780_source">show source</a> ]</p>
  <div id="M000780_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.capitalize   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with the first character converted to uppercase
 *  and the remainder to lowercase.
 *     
 *     &quot;hello&quot;.capitalize    #=&gt; &quot;Hello&quot;
 *     &quot;HELLO&quot;.capitalize    #=&gt; &quot;Hello&quot;
 *     &quot;123ABC&quot;.capitalize   #=&gt; &quot;123abc&quot;
 */

static VALUE
rb_str_capitalize(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_capitalize_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000784" class="method">
  <div id="M000784_title" class="title">
    <b>str.capitalize!   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Modifies <em>str</em> by converting the first character to uppercase and
the remainder to lowercase. Returns <tt>nil</tt> if no changes are made.
</p>
<pre>
   a = &quot;hello&quot;
   a.capitalize!   #=&gt; &quot;Hello&quot;
   a               #=&gt; &quot;Hello&quot;
   a.capitalize!   #=&gt; nil
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000784_source')" id="l_M000784_source">show source</a> ]</p>
  <div id="M000784_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.capitalize!   =&gt; str or nil
 *  
 *  Modifies &lt;i&gt;str&lt;/i&gt; by converting the first character to uppercase and the
 *  remainder to lowercase. Returns &lt;code&gt;nil&lt;/code&gt; if no changes are made.
 *     
 *     a = &quot;hello&quot;
 *     a.capitalize!   #=&gt; &quot;Hello&quot;
 *     a               #=&gt; &quot;Hello&quot;
 *     a.capitalize!   #=&gt; nil
 */

static VALUE
rb_str_capitalize_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    if (RSTRING(str)-&gt;len == 0 || !RSTRING(str)-&gt;ptr) return Qnil;
    s = RSTRING(str)-&gt;ptr; send = s + RSTRING(str)-&gt;len;
    if (ISLOWER(*s)) {
        *s = toupper(*s);
        modify = 1;
    }
    while (++s &lt; send) {
        if (ismbchar(*s)) {
            s+=mbclen(*s) - 1;
        }
        else if (ISUPPER(*s)) {
            *s = tolower(*s);
            modify = 1;
        }
    }
    if (modify) return str;
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000751" class="method">
  <div id="M000751_title" class="title">
    <b>str.casecmp(other_str)   => -1, 0, +1<br />
</b>
  </div>
  <div class="description">
  <p>
Case-insensitive version of <tt><a
href="index.html?a=C00000055&name=String">String</a>#&lt;=&gt;</tt>.
</p>
<pre>
   &quot;abcdef&quot;.casecmp(&quot;abcde&quot;)     #=&gt; 1
   &quot;aBcDeF&quot;.casecmp(&quot;abcdef&quot;)    #=&gt; 0
   &quot;abcdef&quot;.casecmp(&quot;abcdefg&quot;)   #=&gt; -1
   &quot;abcdef&quot;.casecmp(&quot;ABCDEF&quot;)    #=&gt; 0
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000751_source')" id="l_M000751_source">show source</a> ]</p>
  <div id="M000751_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.casecmp(other_str)   =&gt; -1, 0, +1
 *  
 *  Case-insensitive version of &lt;code&gt;String#&lt;=&gt;&lt;/code&gt;.
 *     
 *     &quot;abcdef&quot;.casecmp(&quot;abcde&quot;)     #=&gt; 1
 *     &quot;aBcDeF&quot;.casecmp(&quot;abcdef&quot;)    #=&gt; 0
 *     &quot;abcdef&quot;.casecmp(&quot;abcdefg&quot;)   #=&gt; -1
 *     &quot;abcdef&quot;.casecmp(&quot;ABCDEF&quot;)    #=&gt; 0
 */

static VALUE
rb_str_casecmp(str1, str2)
    VALUE str1, str2;
{
    long len;
    int retval;

    StringValue(str2);
    len = lesser(RSTRING(str1)-&gt;len, RSTRING(str2)-&gt;len);
    retval = rb_memcicmp(RSTRING(str1)-&gt;ptr, RSTRING(str2)-&gt;ptr, len);
    if (retval == 0) {
        if (RSTRING(str1)-&gt;len == RSTRING(str2)-&gt;len) return INT2FIX(0);
        if (RSTRING(str1)-&gt;len &gt; RSTRING(str2)-&gt;len) return INT2FIX(1);
        return INT2FIX(-1);
    }
    if (retval == 0) return INT2FIX(0);
    if (retval &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}
</pre>
  </div>
</div>
</div>
<div id="M000802" class="method">
  <div id="M000802_title" class="title">
    <b>str.center(integer, padstr)   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt><a href="index.html?a=C00000055&name=String">String</a></tt> of
length <em>integer</em> with <em>str</em> centered and padded with
<em>padstr</em>; otherwise, returns <em>str</em>.
</p>
<pre>
   &quot;hello&quot;.center(4)         #=&gt; &quot;hello&quot;
   &quot;hello&quot;.center(20)        #=&gt; &quot;       hello        &quot;
   &quot;hello&quot;.center(20, '123') #=&gt; &quot;1231231hello12312312&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000802_source')" id="l_M000802_source">show source</a> ]</p>
  <div id="M000802_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.center(integer, padstr)   =&gt; new_str
 *  
 *  If &lt;i&gt;integer&lt;/i&gt; is greater than the length of &lt;i&gt;str&lt;/i&gt;, returns a new
 *  &lt;code&gt;String&lt;/code&gt; of length &lt;i&gt;integer&lt;/i&gt; with &lt;i&gt;str&lt;/i&gt; centered and
 *  padded with &lt;i&gt;padstr&lt;/i&gt;; otherwise, returns &lt;i&gt;str&lt;/i&gt;.
 *     
 *     &quot;hello&quot;.center(4)         #=&gt; &quot;hello&quot;
 *     &quot;hello&quot;.center(20)        #=&gt; &quot;       hello        &quot;
 *     &quot;hello&quot;.center(20, '123') #=&gt; &quot;1231231hello12312312&quot;
 */

static VALUE
rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}
</pre>
  </div>
</div>
</div>
<div id="M000832" class="method">
  <div id="M000832_title" class="title">
    <b>str.chars                   => anEnumerator<br />
str.chars {|substr| block } => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns an enumerator that gives each character in the string. If a block
is given, it iterates over each character in the string.
</p>
<pre>
   &quot;foo&quot;.chars.to_a   #=&gt; [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000832_source')" id="l_M000832_source">show source</a> ]</p>
  <div id="M000832_source" class="dyn-source">
<pre>
/*
 *  Document-method: each_char
 *  call-seq:
 *     str.each_char {|cstr| block }    =&gt; str
 *  
 *  Passes each character in &lt;i&gt;str&lt;/i&gt; to the given block.
 *     
 *     &quot;hello&quot;.each_char {|c| print c, ' ' }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     h e l l o 
 */

static VALUE
rb_str_each_char(VALUE str)
{
    int i, len, n;
    const char *ptr;

    RETURN_ENUMERATOR(str, 0, 0);
    str = rb_str_new4(str);
    ptr = RSTRING(str)-&gt;ptr;
    len = RSTRING(str)-&gt;len;
    for (i = 0; i &lt; len; i += n) {
        n = mbclen(ptr[i]);
        rb_yield(rb_str_substr(str, i, n));
    }
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000806" class="method">
  <div id="M000806_title" class="title">
    <b>str.chomp(separator=$/)   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a new <tt><a
href="index.html?a=C00000055&name=String">String</a></tt> with the given
record separator removed from the end of <em>str</em> (if present). If
<tt>$/</tt> has not been changed from the default Ruby record separator,
then <tt>chomp</tt> also removes carriage return characters (that is it
will remove <tt>\n</tt>, <tt>\r</tt>, and <tt>\r\n</tt>).
</p>
<pre>
   &quot;hello&quot;.chomp            #=&gt; &quot;hello&quot;
   &quot;hello\n&quot;.chomp          #=&gt; &quot;hello&quot;
   &quot;hello\r\n&quot;.chomp        #=&gt; &quot;hello&quot;
   &quot;hello\n\r&quot;.chomp        #=&gt; &quot;hello\n&quot;
   &quot;hello\r&quot;.chomp          #=&gt; &quot;hello&quot;
   &quot;hello \n there&quot;.chomp   #=&gt; &quot;hello \n there&quot;
   &quot;hello&quot;.chomp(&quot;llo&quot;)     #=&gt; &quot;he&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000806_source')" id="l_M000806_source">show source</a> ]</p>
  <div id="M000806_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.chomp(separator=$/)   =&gt; new_str
 *  
 *  Returns a new &lt;code&gt;String&lt;/code&gt; with the given record separator removed
 *  from the end of &lt;i&gt;str&lt;/i&gt; (if present). If &lt;code&gt;$/&lt;/code&gt; has not been
 *  changed from the default Ruby record separator, then &lt;code&gt;chomp&lt;/code&gt; also
 *  removes carriage return characters (that is it will remove &lt;code&gt;\n&lt;/code&gt;,
 *  &lt;code&gt;\r&lt;/code&gt;, and &lt;code&gt;\r\n&lt;/code&gt;).
 *     
 *     &quot;hello&quot;.chomp            #=&gt; &quot;hello&quot;
 *     &quot;hello\n&quot;.chomp          #=&gt; &quot;hello&quot;
 *     &quot;hello\r\n&quot;.chomp        #=&gt; &quot;hello&quot;
 *     &quot;hello\n\r&quot;.chomp        #=&gt; &quot;hello\n&quot;
 *     &quot;hello\r&quot;.chomp          #=&gt; &quot;hello&quot;
 *     &quot;hello \n there&quot;.chomp   #=&gt; &quot;hello \n there&quot;
 *     &quot;hello&quot;.chomp(&quot;llo&quot;)     #=&gt; &quot;he&quot;
 */

static VALUE
rb_str_chomp(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_chomp_bang(argc, argv, str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000813" class="method">
  <div id="M000813_title" class="title">
    <b>str.chomp!(separator=$/)   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Modifies <em>str</em> in place as described for <tt><a
href="index.html?a=M000806&name=String#chomp">String#chomp</a></tt>,
returning <em>str</em>, or <tt>nil</tt> if no modifications were made.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000813_source')" id="l_M000813_source">show source</a> ]</p>
  <div id="M000813_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.chomp!(separator=$/)   =&gt; str or nil
 *  
 *  Modifies &lt;i&gt;str&lt;/i&gt; in place as described for &lt;code&gt;String#chomp&lt;/code&gt;,
 *  returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no modifications were made.
 */

static VALUE
rb_str_chomp_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE rs;
    int newline;
    char *p;
    long len, rslen;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs) == 0) {
        len = RSTRING(str)-&gt;len;
        if (len == 0) return Qnil;
        p = RSTRING(str)-&gt;ptr;
        rs = rb_rs;
        if (rs == rb_default_rs) {
          smart_chomp:
            rb_str_modify(str);
            if (RSTRING(str)-&gt;ptr[len-1] == '\n') {
                RSTRING(str)-&gt;len--;
                if (RSTRING(str)-&gt;len &gt; 0 &amp;&amp;
                    RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len-1] == '\r') {
                    RSTRING(str)-&gt;len--;
                }
            }
            else if (RSTRING(str)-&gt;ptr[len-1] == '\r') {
                RSTRING(str)-&gt;len--;
            }
            else {
                return Qnil;
            }
            RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
            return str;
        }
    }
    if (NIL_P(rs)) return Qnil;
    StringValue(rs);
    len = RSTRING(str)-&gt;len;
    if (len == 0) return Qnil;
    p = RSTRING(str)-&gt;ptr;
    rslen = RSTRING(rs)-&gt;len;
    if (rslen == 0) {
        while (len&gt;0 &amp;&amp; p[len-1] == '\n') {
            len--;
            if (len&gt;0 &amp;&amp; p[len-1] == '\r')
                len--;
        }
        if (len &lt; RSTRING(str)-&gt;len) {
            rb_str_modify(str);
            RSTRING(str)-&gt;len = len;
            RSTRING(str)-&gt;ptr[len] = '\0';
            return str;
        }
        return Qnil;
    }
    if (rslen &gt; len) return Qnil;
    newline = RSTRING(rs)-&gt;ptr[rslen-1];
    if (rslen == 1 &amp;&amp; newline == '\n')
        goto smart_chomp;

    if (p[len-1] == newline &amp;&amp;
        (rslen &lt;= 1 ||
         rb_memcmp(RSTRING(rs)-&gt;ptr, p+len-rslen, rslen) == 0)) {
        rb_str_modify(str);
        RSTRING(str)-&gt;len -= rslen;
        RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
        return str;
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000805" class="method">
  <div id="M000805_title" class="title">
    <b>str.chop   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a new <tt><a
href="index.html?a=C00000055&name=String">String</a></tt> with the last
character removed. If the string ends with <tt>\r\n</tt>, both characters
are removed. Applying <tt>chop</tt> to an empty string returns an empty
string. <tt><a
href="index.html?a=M000806&name=String#chomp">String#chomp</a></tt> is
often a safer alternative, as it leaves the string unchanged if it
doesn&#8217;t end in a record separator.
</p>
<pre>
   &quot;string\r\n&quot;.chop   #=&gt; &quot;string&quot;
   &quot;string\n\r&quot;.chop   #=&gt; &quot;string\n&quot;
   &quot;string\n&quot;.chop     #=&gt; &quot;string&quot;
   &quot;string&quot;.chop       #=&gt; &quot;strin&quot;
   &quot;x&quot;.chop.chop       #=&gt; &quot;&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000805_source')" id="l_M000805_source">show source</a> ]</p>
  <div id="M000805_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.chop   =&gt; new_str
 *  
 *  Returns a new &lt;code&gt;String&lt;/code&gt; with the last character removed.  If the
 *  string ends with &lt;code&gt;\r\n&lt;/code&gt;, both characters are removed. Applying
 *  &lt;code&gt;chop&lt;/code&gt; to an empty string returns an empty
 *  string. &lt;code&gt;String#chomp&lt;/code&gt; is often a safer alternative, as it leaves
 *  the string unchanged if it doesn't end in a record separator.
 *     
 *     &quot;string\r\n&quot;.chop   #=&gt; &quot;string&quot;
 *     &quot;string\n\r&quot;.chop   #=&gt; &quot;string\n&quot;
 *     &quot;string\n&quot;.chop     #=&gt; &quot;string&quot;
 *     &quot;string&quot;.chop       #=&gt; &quot;strin&quot;
 *     &quot;x&quot;.chop.chop       #=&gt; &quot;&quot;
 */

static VALUE
rb_str_chop(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_chop_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000851" class="method">
  <div id="M000851_title" class="title">
    <b>chop</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000851_source')" id="l_M000851_source">show source</a> ]</p>
  <div id="M000851_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 196</span>
196:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">chop</span>
197:     (<span class="ruby-identifier">str</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">dup</span>).<span class="ruby-identifier">chop!</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">str</span>
198:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000812" class="method">
  <div id="M000812_title" class="title">
    <b>str.chop!   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Processes <em>str</em> as for <tt><a
href="index.html?a=M000805&name=String#chop">String#chop</a></tt>,
returning <em>str</em>, or <tt>nil</tt> if <em>str</em> is the empty
string. See also <tt><a
href="index.html?a=M000806&name=String#chomp">String#chomp</a>!</tt>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000812_source')" id="l_M000812_source">show source</a> ]</p>
  <div id="M000812_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.chop!   =&gt; str or nil
 *  
 *  Processes &lt;i&gt;str&lt;/i&gt; as for &lt;code&gt;String#chop&lt;/code&gt;, returning &lt;i&gt;str&lt;/i&gt;,
 *  or &lt;code&gt;nil&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; is the empty string.  See also
 *  &lt;code&gt;String#chomp!&lt;/code&gt;.
 */

static VALUE
rb_str_chop_bang(str)
    VALUE str;
{
    if (RSTRING(str)-&gt;len &gt; 0) {
        rb_str_modify(str);
        RSTRING(str)-&gt;len--;
        if (RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] == '\n') {
            if (RSTRING(str)-&gt;len &gt; 0 &amp;&amp;
                RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len-1] == '\r') {
                RSTRING(str)-&gt;len--;
            }
        }
        RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
        return str;
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000850" class="method">
  <div id="M000850_title" class="title">
    <b>chop!</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000850_source')" id="l_M000850_source">show source</a> ]</p>
  <div id="M000850_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 192</span>
192:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">chop!</span>
193:     <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-regexp re">/(?:.|\r?\n)\z/</span>, <span class="ruby-value str">''</span>)
194:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000791" class="method">
  <div id="M000791_title" class="title">
    <b>str << fixnum        => str<br />
str.concat(fixnum)   => str<br />
str << obj           => str<br />
str.concat(obj)      => str<br />
</b>
  </div>
  <div class="description">
  <p>
Append&#8212;Concatenates the given object to <em>str</em>. If the object
is a <tt><a href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt>
between 0 and 255, it is converted to a character before concatenation.
</p>
<pre>
   a = &quot;hello &quot;
   a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
   a.concat(33)   #=&gt; &quot;hello world!&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000791_source')" id="l_M000791_source">show source</a> ]</p>
  <div id="M000791_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str &lt;&lt; fixnum        =&gt; str
 *     str.concat(fixnum)   =&gt; str
 *     str &lt;&lt; obj           =&gt; str
 *     str.concat(obj)      =&gt; str
 *  
 *  Append---Concatenates the given object to &lt;i&gt;str&lt;/i&gt;. If the object is a
 *  &lt;code&gt;Fixnum&lt;/code&gt; between 0 and 255, it is converted to a character before
 *  concatenation.
 *     
 *     a = &quot;hello &quot;
 *     a &lt;&lt; &quot;world&quot;   #=&gt; &quot;hello world&quot;
 *     a.concat(33)   #=&gt; &quot;hello world!&quot;
 */

VALUE
rb_str_concat(str1, str2)
    VALUE str1, str2;
{
    if (FIXNUM_P(str2)) {
        int i = FIX2INT(str2);
        if (0 &lt;= i &amp;&amp; i &lt;= 0xff) { /* byte */
            char c = i;
            return rb_str_cat(str1, &amp;c, 1);
        }
    }
    str1 = rb_str_append(str1, str2);

    return str1;
}
</pre>
  </div>
</div>
</div>
<div id="M000821" class="method">
  <div id="M000821_title" class="title">
    <b>str.count([other_str]+)   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Each <em>other_str</em> parameter defines a set of characters to count. The
intersection of these sets defines the characters to count in <em>str</em>.
Any <em>other_str</em> that starts with a caret (^) is negated. The
sequence c1&#8212;c2 means all characters between c1 and c2.
</p>
<pre>
   a = &quot;hello world&quot;
   a.count &quot;lo&quot;            #=&gt; 5
   a.count &quot;lo&quot;, &quot;o&quot;       #=&gt; 2
   a.count &quot;hello&quot;, &quot;^l&quot;   #=&gt; 4
   a.count &quot;ej-m&quot;          #=&gt; 4
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000821_source')" id="l_M000821_source">show source</a> ]</p>
  <div id="M000821_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.count([other_str]+)   =&gt; fixnum
 *  
 *  Each &lt;i&gt;other_str&lt;/i&gt; parameter defines a set of characters to count.  The
 *  intersection of these sets defines the characters to count in
 *  &lt;i&gt;str&lt;/i&gt;. Any &lt;i&gt;other_str&lt;/i&gt; that starts with a caret (^) is
 *  negated. The sequence c1--c2 means all characters between c1 and c2.
 *     
 *     a = &quot;hello world&quot;
 *     a.count &quot;lo&quot;            #=&gt; 5
 *     a.count &quot;lo&quot;, &quot;o&quot;       #=&gt; 2
 *     a.count &quot;hello&quot;, &quot;^l&quot;   #=&gt; 4
 *     a.count &quot;ej-m&quot;          #=&gt; 4
 */

static VALUE
rb_str_count(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    char table[256];
    char *s, *send;
    int init = 1;
    int i;

    if (argc &lt; 1) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }
    for (i=0; i&lt;argc; i++) {
        VALUE s = argv[i];

        StringValue(s);
        tr_setup_table(s, table, init);
        init = 0;
    }

    s = RSTRING(str)-&gt;ptr;
    if (!s || RSTRING(str)-&gt;len == 0) return INT2FIX(0);
    send = s + RSTRING(str)-&gt;len;
    i = 0;
    while (s &lt; send) {
        if (table[*s++ &amp; 0xff]) {
            i++;
        }
    }
    return INT2NUM(i);
}
</pre>
  </div>
</div>
</div>
<div id="M000793" class="method">
  <div id="M000793_title" class="title">
    <b>str.crypt(other_str)   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Applies a one-way cryptographic hash to <em>str</em> by invoking the
standard library function <tt>crypt</tt>. The argument is the salt string,
which should be two characters long, each character drawn from
<tt>[a-zA-Z0-9./]</tt>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000793_source')" id="l_M000793_source">show source</a> ]</p>
  <div id="M000793_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.crypt(other_str)   =&gt; new_str
 *  
 *  Applies a one-way cryptographic hash to &lt;i&gt;str&lt;/i&gt; by invoking the standard
 *  library function &lt;code&gt;crypt&lt;/code&gt;. The argument is the salt string, which
 *  should be two characters long, each character drawn from
 *  &lt;code&gt;[a-zA-Z0-9./]&lt;/code&gt;.
 */

static VALUE
rb_str_crypt(str, salt)
    VALUE str, salt;
{
    extern char *crypt _((const char *, const char*));
    VALUE result;
    const char *s;

    StringValue(salt);
    if (RSTRING(salt)-&gt;len &lt; 2)
        rb_raise(rb_eArgError, &quot;salt too short(need &gt;=2 bytes)&quot;);

    if (RSTRING(str)-&gt;ptr) s = RSTRING(str)-&gt;ptr;
    else s = &quot;&quot;;
    result = rb_str_new2(crypt(s, RSTRING(salt)-&gt;ptr));
    OBJ_INFECT(result, str);
    OBJ_INFECT(result, salt);
    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M000845" class="method">
  <div id="M000845_title" class="title">
    <b>delete</b>(del)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000845_source')" id="l_M000845_source">show source</a> ]</p>
  <div id="M000845_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 156</span>
156:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">delete</span>(<span class="ruby-identifier">del</span>)
157:     (<span class="ruby-identifier">str</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">dup</span>).<span class="ruby-identifier">delete!</span>(<span class="ruby-identifier">del</span>) <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">str</span>
158:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000819" class="method">
  <div id="M000819_title" class="title">
    <b>str.delete([other_str]+)   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with all characters in the intersection of
its arguments deleted. Uses the same rules for building the set of
characters as <tt><a
href="index.html?a=M000821&name=String#count">String#count</a></tt>.
</p>
<pre>
   &quot;hello&quot;.delete &quot;l&quot;,&quot;lo&quot;        #=&gt; &quot;heo&quot;
   &quot;hello&quot;.delete &quot;lo&quot;            #=&gt; &quot;he&quot;
   &quot;hello&quot;.delete &quot;aeiou&quot;, &quot;^e&quot;   #=&gt; &quot;hell&quot;
   &quot;hello&quot;.delete &quot;ej-m&quot;          #=&gt; &quot;ho&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000819_source')" id="l_M000819_source">show source</a> ]</p>
  <div id="M000819_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.delete([other_str]+)   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with all characters in the intersection of its
 *  arguments deleted. Uses the same rules for building the set of characters as
 *  &lt;code&gt;String#count&lt;/code&gt;.
 *     
 *     &quot;hello&quot;.delete &quot;l&quot;,&quot;lo&quot;        #=&gt; &quot;heo&quot;
 *     &quot;hello&quot;.delete &quot;lo&quot;            #=&gt; &quot;he&quot;
 *     &quot;hello&quot;.delete &quot;aeiou&quot;, &quot;^e&quot;   #=&gt; &quot;hell&quot;
 *     &quot;hello&quot;.delete &quot;ej-m&quot;          #=&gt; &quot;ho&quot;
 */

static VALUE
rb_str_delete(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_delete_bang(argc, argv, str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000844" class="method">
  <div id="M000844_title" class="title">
    <b>delete!</b>(del)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000844_source')" id="l_M000844_source">show source</a> ]</p>
  <div id="M000844_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 151</span>
151:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">delete!</span>(<span class="ruby-identifier">del</span>)
152:     <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">del</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;&quot;</span>
153:     <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-constant">DeletePatternCache</span>[<span class="ruby-identifier">del</span>] <span class="ruby-operator">||=</span> <span class="ruby-node">/[#{_regex_quote(del)}]+/</span>, <span class="ruby-value str">''</span>)
154:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000824" class="method">
  <div id="M000824_title" class="title">
    <b>str.delete!([other_str]+>)   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Performs a <tt>delete</tt> operation in place, returning <em>str</em>, or
<tt>nil</tt> if <em>str</em> was not modified.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000824_source')" id="l_M000824_source">show source</a> ]</p>
  <div id="M000824_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.delete!([other_str]+&gt;)   =&gt; str or nil
 *  
 *  Performs a &lt;code&gt;delete&lt;/code&gt; operation in place, returning &lt;i&gt;str&lt;/i&gt;, or
 *  &lt;code&gt;nil&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; was not modified.
 */

static VALUE
rb_str_delete_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    char *s, *send, *t;
    char squeez[256];
    int modify = 0;
    int init = 1;
    int i;

    if (argc &lt; 1) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments&quot;);
    }
    for (i=0; i&lt;argc; i++) {
        VALUE s = argv[i];

        StringValue(s);
        tr_setup_table(s, squeez, init);
        init = 0;
    }

    rb_str_modify(str);
    s = t = RSTRING(str)-&gt;ptr;
    if (!s || RSTRING(str)-&gt;len == 0) return Qnil;
    send = s + RSTRING(str)-&gt;len;
    while (s &lt; send) {
        if (squeez[*s &amp; 0xff])
            modify = 1;
        else
            *t++ = *s;
        s++;
    }
    *t = '\0';
    RSTRING(str)-&gt;len = t - RSTRING(str)-&gt;ptr;

    if (modify) return str;
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000779" class="method">
  <div id="M000779_title" class="title">
    <b>str.downcase   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with all uppercase letters replaced with
their lowercase counterparts. The operation is locale
insensitive&#8212;only characters ``A&#8217;&#8217; to ``Z&#8217;&#8217;
are affected.
</p>
<pre>
   &quot;hEllO&quot;.downcase   #=&gt; &quot;hello&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000779_source')" id="l_M000779_source">show source</a> ]</p>
  <div id="M000779_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.downcase   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with all uppercase letters replaced with their
 *  lowercase counterparts. The operation is locale insensitive---only
 *  characters ``A'' to ``Z'' are affected.
 *     
 *     &quot;hEllO&quot;.downcase   #=&gt; &quot;hello&quot;
 */

static VALUE
rb_str_downcase(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_downcase_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000783" class="method">
  <div id="M000783_title" class="title">
    <b>str.downcase!   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Downcases the contents of <em>str</em>, returning <tt>nil</tt> if no
changes were made.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000783_source')" id="l_M000783_source">show source</a> ]</p>
  <div id="M000783_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.downcase!   =&gt; str or nil
 *  
 *  Downcases the contents of &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if no
 *  changes were made.
 */

static VALUE
rb_str_downcase_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    s = RSTRING(str)-&gt;ptr; send = s + RSTRING(str)-&gt;len;
    while (s &lt; send) {
        if (ismbchar(*s)) {
            s+=mbclen(*s) - 1;
        }
        else if (ISUPPER(*s)) {
            *s = tolower(*s);
            modify = 1;
        }
        s++;
    }

    if (modify) return str;
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000777" class="method">
  <div id="M000777_title" class="title">
    <b>str.dump   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Produces a version of <em>str</em> with all nonprinting characters replaced
by <tt>\nnn</tt> notation and all special characters escaped.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000777_source')" id="l_M000777_source">show source</a> ]</p>
  <div id="M000777_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.dump   =&gt; new_str
 *  
 *  Produces a version of &lt;i&gt;str&lt;/i&gt; with all nonprinting characters replaced by
 *  &lt;code&gt;\nnn&lt;/code&gt; notation and all special characters escaped.
 */

VALUE
rb_str_dump(str)
    VALUE str;
{
    long len;
    char *p, *pend;
    char *q, *qend;
    VALUE result;

    len = 2;                    /* &quot;&quot; */
    p = RSTRING(str)-&gt;ptr; pend = p + RSTRING(str)-&gt;len;
    while (p &lt; pend) {
        char c = *p++;
        switch (c) {
          case '&quot;':  case '\\':
          case '\n': case '\r':
          case '\t': case '\f':
          case '\013': case '\010': case '\007': case '\033':
            len += 2;
            break;

          case '#':
            len += IS_EVSTR(p, pend) ? 2 : 1;
            break;

          default:
            if (ISPRINT(c)) {
                len++;
            }
            else {
                len += 4;             /* \nnn */
            }
            break;
        }
    }

    result = rb_str_new5(str, 0, len);
    p = RSTRING(str)-&gt;ptr; pend = p + RSTRING(str)-&gt;len;
    q = RSTRING(result)-&gt;ptr; qend = q + len;

    *q++ = '&quot;';
    while (p &lt; pend) {
        char c = *p++;

        if (c == '&quot;' || c == '\\') {
            *q++ = '\\';
            *q++ = c;
        }
        else if (c == '#') {
            if (IS_EVSTR(p, pend)) *q++ = '\\';
            *q++ = '#';
        }
        else if (ISPRINT(c)) {
            *q++ = c;
        }
        else if (c == '\n') {
            *q++ = '\\';
            *q++ = 'n';
        }
        else if (c == '\r') {
            *q++ = '\\';
            *q++ = 'r';
        }
        else if (c == '\t') {
            *q++ = '\\';
            *q++ = 't';
        }
        else if (c == '\f') {
            *q++ = '\\';
            *q++ = 'f';
        }
        else if (c == '\013') {
            *q++ = '\\';
            *q++ = 'v';
        }
        else if (c == '\010') {
            *q++ = '\\';
            *q++ = 'b';
        }
        else if (c == '\007') {
            *q++ = '\\';
            *q++ = 'a';
        }
        else if (c == '\033') {
            *q++ = '\\';
            *q++ = 'e';
        }
        else {
            *q++ = '\\';
            sprintf(q, &quot;%03o&quot;, c&amp;0xff);
            q += 3;
        }
    }
    *q++ = '&quot;';

    OBJ_INFECT(result, str);
    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M000827" class="method">
  <div id="M000827_title" class="title">
    <b>str.each(separator=$/) {|substr| block }        => str<br />
str.each_line(separator=$/) {|substr| block }   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Splits <em>str</em> using the supplied parameter as the record separator
(<tt>$/</tt> by default), passing each substring in turn to the supplied
block. If a zero-length record separator is supplied, the string is split
into paragraphs delimited by multiple successive newlines.
</p>
<pre>
   print &quot;Example one\n&quot;
   &quot;hello\nworld&quot;.each {|s| p s}
   print &quot;Example two\n&quot;
   &quot;hello\nworld&quot;.each('l') {|s| p s}
   print &quot;Example three\n&quot;
   &quot;hello\n\n\nworld&quot;.each('') {|s| p s}
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Example one
   &quot;hello\n&quot;
   &quot;world&quot;
   Example two
   &quot;hel&quot;
   &quot;l&quot;
   &quot;o\nworl&quot;
   &quot;d&quot;
   Example three
   &quot;hello\n\n\n&quot;
   &quot;world&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000827_source')" id="l_M000827_source">show source</a> ]</p>
  <div id="M000827_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.each(separator=$/) {|substr| block }        =&gt; str
 *     str.each_line(separator=$/) {|substr| block }   =&gt; str
 *  
 *  Splits &lt;i&gt;str&lt;/i&gt; using the supplied parameter as the record separator
 *  (&lt;code&gt;$/&lt;/code&gt; by default), passing each substring in turn to the supplied
 *  block. If a zero-length record separator is supplied, the string is split
 *  into paragraphs delimited by multiple successive newlines.
 *     
 *     print &quot;Example one\n&quot;
 *     &quot;hello\nworld&quot;.each {|s| p s}
 *     print &quot;Example two\n&quot;
 *     &quot;hello\nworld&quot;.each('l') {|s| p s}
 *     print &quot;Example three\n&quot;
 *     &quot;hello\n\n\nworld&quot;.each('') {|s| p s}
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Example one
 *     &quot;hello\n&quot;
 *     &quot;world&quot;
 *     Example two
 *     &quot;hel&quot;
 *     &quot;l&quot;
 *     &quot;o\nworl&quot;
 *     &quot;d&quot;
 *     Example three
 *     &quot;hello\n\n\n&quot;
 *     &quot;world&quot;
 */

static VALUE
rb_str_each_line(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE rs;
    int newline;
    char *p = RSTRING(str)-&gt;ptr, *pend = p + RSTRING(str)-&gt;len, *s;
    char *ptr = p;
    long len = RSTRING(str)-&gt;len, rslen;
    VALUE line;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs) == 0) {
        rs = rb_rs;
    }
    RETURN_ENUMERATOR(str, argc, argv);
    if (NIL_P(rs)) {
        rb_yield(str);
        return str;
    }
    StringValue(rs);
    rslen = RSTRING(rs)-&gt;len;
    if (rslen == 0) {
        newline = '\n';
    }
    else {
        newline = RSTRING(rs)-&gt;ptr[rslen-1];
    }

    for (s = p, p += rslen; p &lt; pend; p++) {
        if (rslen == 0 &amp;&amp; *p == '\n') {
            if (*++p != '\n') continue;
            while (*p == '\n') p++;
        }
        if (RSTRING(str)-&gt;ptr &lt; p &amp;&amp; p[-1] == newline &amp;&amp;
            (rslen &lt;= 1 ||
             rb_memcmp(RSTRING(rs)-&gt;ptr, p-rslen, rslen) == 0)) {
            line = rb_str_new5(str, s, p - s);
            OBJ_INFECT(line, str);
            rb_yield(line);
            str_mod_check(str, ptr, len);
            s = p;
        }
    }

    if (s != pend) {
        if (p &gt; pend) p = pend;
        line = rb_str_new5(str, s, p - s);
        OBJ_INFECT(line, str);
        rb_yield(line);
    }

    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000828" class="method">
  <div id="M000828_title" class="title">
    <b>str.each_byte {|fixnum| block }    => str<br />
</b>
  </div>
  <div class="description">
  <p>
Passes each byte in <em>str</em> to the given block.
</p>
<pre>
   &quot;hello&quot;.each_byte {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   104 101 108 108 111
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000828_source')" id="l_M000828_source">show source</a> ]</p>
  <div id="M000828_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.each_byte {|fixnum| block }    =&gt; str
 *  
 *  Passes each byte in &lt;i&gt;str&lt;/i&gt; to the given block.
 *     
 *     &quot;hello&quot;.each_byte {|c| print c, ' ' }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     104 101 108 108 111
 */

static VALUE
rb_str_each_byte(str)
    VALUE str;
{
    long i;

    RETURN_ENUMERATOR(str, 0, 0);
    for (i=0; i&lt;RSTRING(str)-&gt;len; i++) {
        rb_yield(INT2FIX(RSTRING(str)-&gt;ptr[i] &amp; 0xff));
    }
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000855" class="method">
  <div id="M000855_title" class="title">
    <b>each_char</b>() {|x| ...}
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000855_source')" id="l_M000855_source">show source</a> ]</p>
  <div id="M000855_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 209</span>
209:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">each_char</span>
210:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
211:       <span class="ruby-identifier">scan</span>(<span class="ruby-regexp re">/./</span><span class="ruby-identifier">m</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">x</span><span class="ruby-operator">|</span>
212:         <span class="ruby-keyword kw">yield</span> <span class="ruby-identifier">x</span>
213:       <span class="ruby-keyword kw">end</span>
214:     <span class="ruby-keyword kw">else</span>
215:       <span class="ruby-identifier">scan</span>(<span class="ruby-regexp re">/./</span><span class="ruby-identifier">m</span>)
216:     <span class="ruby-keyword kw">end</span>
217:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000829" class="method">
  <div id="M000829_title" class="title">
    <b>str.each_char {|cstr| block }    => str<br />
</b>
  </div>
  <div class="description">
  <p>
Passes each character in <em>str</em> to the given block.
</p>
<pre>
   &quot;hello&quot;.each_char {|c| print c, ' ' }
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   h e l l o
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000829_source')" id="l_M000829_source">show source</a> ]</p>
  <div id="M000829_source" class="dyn-source">
<pre>
/*
 *  Document-method: each_char
 *  call-seq:
 *     str.each_char {|cstr| block }    =&gt; str
 *  
 *  Passes each character in &lt;i&gt;str&lt;/i&gt; to the given block.
 *     
 *     &quot;hello&quot;.each_char {|c| print c, ' ' }
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     h e l l o 
 */

static VALUE
rb_str_each_char(VALUE str)
{
    int i, len, n;
    const char *ptr;

    RETURN_ENUMERATOR(str, 0, 0);
    str = rb_str_new4(str);
    ptr = RSTRING(str)-&gt;ptr;
    len = RSTRING(str)-&gt;len;
    for (i = 0; i &lt; len; i += n) {
        n = mbclen(ptr[i]);
        rb_yield(rb_str_substr(str, i, n));
    }
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000826" class="method">
  <div id="M000826_title" class="title">
    <b>str.each(separator=$/) {|substr| block }        => str<br />
str.each_line(separator=$/) {|substr| block }   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Splits <em>str</em> using the supplied parameter as the record separator
(<tt>$/</tt> by default), passing each substring in turn to the supplied
block. If a zero-length record separator is supplied, the string is split
into paragraphs delimited by multiple successive newlines.
</p>
<pre>
   print &quot;Example one\n&quot;
   &quot;hello\nworld&quot;.each {|s| p s}
   print &quot;Example two\n&quot;
   &quot;hello\nworld&quot;.each('l') {|s| p s}
   print &quot;Example three\n&quot;
   &quot;hello\n\n\nworld&quot;.each('') {|s| p s}
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   Example one
   &quot;hello\n&quot;
   &quot;world&quot;
   Example two
   &quot;hel&quot;
   &quot;l&quot;
   &quot;o\nworl&quot;
   &quot;d&quot;
   Example three
   &quot;hello\n\n\n&quot;
   &quot;world&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000826_source')" id="l_M000826_source">show source</a> ]</p>
  <div id="M000826_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.each(separator=$/) {|substr| block }        =&gt; str
 *     str.each_line(separator=$/) {|substr| block }   =&gt; str
 *  
 *  Splits &lt;i&gt;str&lt;/i&gt; using the supplied parameter as the record separator
 *  (&lt;code&gt;$/&lt;/code&gt; by default), passing each substring in turn to the supplied
 *  block. If a zero-length record separator is supplied, the string is split
 *  into paragraphs delimited by multiple successive newlines.
 *     
 *     print &quot;Example one\n&quot;
 *     &quot;hello\nworld&quot;.each {|s| p s}
 *     print &quot;Example two\n&quot;
 *     &quot;hello\nworld&quot;.each('l') {|s| p s}
 *     print &quot;Example three\n&quot;
 *     &quot;hello\n\n\nworld&quot;.each('') {|s| p s}
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Example one
 *     &quot;hello\n&quot;
 *     &quot;world&quot;
 *     Example two
 *     &quot;hel&quot;
 *     &quot;l&quot;
 *     &quot;o\nworl&quot;
 *     &quot;d&quot;
 *     Example three
 *     &quot;hello\n\n\n&quot;
 *     &quot;world&quot;
 */

static VALUE
rb_str_each_line(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE rs;
    int newline;
    char *p = RSTRING(str)-&gt;ptr, *pend = p + RSTRING(str)-&gt;len, *s;
    char *ptr = p;
    long len = RSTRING(str)-&gt;len, rslen;
    VALUE line;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs) == 0) {
        rs = rb_rs;
    }
    RETURN_ENUMERATOR(str, argc, argv);
    if (NIL_P(rs)) {
        rb_yield(str);
        return str;
    }
    StringValue(rs);
    rslen = RSTRING(rs)-&gt;len;
    if (rslen == 0) {
        newline = '\n';
    }
    else {
        newline = RSTRING(rs)-&gt;ptr[rslen-1];
    }

    for (s = p, p += rslen; p &lt; pend; p++) {
        if (rslen == 0 &amp;&amp; *p == '\n') {
            if (*++p != '\n') continue;
            while (*p == '\n') p++;
        }
        if (RSTRING(str)-&gt;ptr &lt; p &amp;&amp; p[-1] == newline &amp;&amp;
            (rslen &lt;= 1 ||
             rb_memcmp(RSTRING(rs)-&gt;ptr, p-rslen, rslen) == 0)) {
            line = rb_str_new5(str, s, p - s);
            OBJ_INFECT(line, str);
            rb_yield(line);
            str_mod_check(str, ptr, len);
            s = p;
        }
    }

    if (s != pend) {
        if (p &gt; pend) p = pend;
        line = rb_str_new5(str, s, p - s);
        OBJ_INFECT(line, str);
        rb_yield(line);
    }

    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000761" class="method">
  <div id="M000761_title" class="title">
    <b>str.empty?   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Returns <tt>true</tt> if <em>str</em> has a length of zero.
</p>
<pre>
   &quot;hello&quot;.empty?   #=&gt; false
   &quot;&quot;.empty?        #=&gt; true
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000761_source')" id="l_M000761_source">show source</a> ]</p>
  <div id="M000761_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.empty?   =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; has a length of zero.
 *     
 *     &quot;hello&quot;.empty?   #=&gt; false
 *     &quot;&quot;.empty?        #=&gt; true
 */

static VALUE
rb_str_empty(str)
    VALUE str;
{
    if (RSTRING(str)-&gt;len == 0)
        return Qtrue;
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M000839" class="method">
  <div id="M000839_title" class="title">
    <b>end_regexp</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000839_source')" id="l_M000839_source">show source</a> ]</p>
  <div id="M000839_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 59</span>
59:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">end_regexp</span>
60:     <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">$KCODE</span>[<span class="ruby-value">0</span>]
61:     <span class="ruby-keyword kw">when</span> <span class="ruby-value">?s</span>, <span class="ruby-value">?S</span>
62:       <span class="ruby-node">/#{PATTERN_SJIS}$/o</span><span class="ruby-identifier">n</span>
63:     <span class="ruby-keyword kw">when</span> <span class="ruby-value">?e</span>, <span class="ruby-value">?E</span>
64:       <span class="ruby-node">/#{PATTERN_EUC}$/o</span><span class="ruby-identifier">n</span>
65:     <span class="ruby-keyword kw">when</span> <span class="ruby-value">?u</span>, <span class="ruby-value">?U</span>
66:       <span class="ruby-node">/#{PATTERN_UTF8}$/o</span><span class="ruby-identifier">n</span>
67:     <span class="ruby-keyword kw">else</span>
68:       <span class="ruby-regexp re">/.$/o</span><span class="ruby-identifier">n</span>
69:     <span class="ruby-keyword kw">end</span>
70:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000798" class="method">
  <div id="M000798_title" class="title">
    <b>str.end_with?([suffix]+)   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Returns true if <em>str</em> ends with the suffix given.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000798_source')" id="l_M000798_source">show source</a> ]</p>
  <div id="M000798_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.end_with?([suffix]+)   =&gt; true or false
 *  
 *  Returns true if &lt;i&gt;str&lt;/i&gt; ends with the suffix given.
 */

static VALUE
rb_str_end_with(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    int i;
    long pos;
    VALUE pat;

    for (i=0; i&lt;argc; i++) {
        VALUE suffix = rb_check_string_type(argv[i]);
        if (NIL_P(suffix)) continue;
        if (RSTRING(str)-&gt;len &lt; RSTRING(suffix)-&gt;len) continue;
        pat = get_arg_pat(suffix);
        pos = rb_reg_adjust_startpos(pat, str, RSTRING(str)-&gt;len - RSTRING(suffix)-&gt;len, 0);
        if (rb_reg_search(pat, str, pos, 0) &gt;= 0)
            return Qtrue;
    }
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M000749" class="method">
  <div id="M000749_title" class="title">
    <b>str.eql?(other)   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Two strings are equal if the have the same length and content.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000749_source')" id="l_M000749_source">show source</a> ]</p>
  <div id="M000749_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *   str.eql?(other)   =&gt; true or false
 *
 * Two strings are equal if the have the same length and content.
 */

static VALUE
rb_str_eql(str1, str2)
    VALUE str1, str2;
{
    if (TYPE(str2) != T_STRING || RSTRING(str1)-&gt;len != RSTRING(str2)-&gt;len)
        return Qfalse;

    if (memcmp(RSTRING(str1)-&gt;ptr, RSTRING(str2)-&gt;ptr,
               lesser(RSTRING(str1)-&gt;len, RSTRING(str2)-&gt;len)) == 0)
        return Qtrue;

    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M000804" class="method">
  <div id="M000804_title" class="title">
    <b>str.gsub(pattern, replacement)       => new_str<br />
str.gsub(pattern) {|match| block }   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with <em>all</em> occurrences of
<em>pattern</em> replaced with either <em>replacement</em> or the value of
the block. The <em>pattern</em> will typically be a <tt><a
href="index.html?a=C00000110&name=Regexp">Regexp</a></tt>; if it is a
<tt><a href="index.html?a=C00000055&name=String">String</a></tt> then no
regular expression metacharacters will be interpreted (that is
<tt>/\d/</tt> will match a digit, but <tt>&#8217;\d&#8217;</tt> will match
a backslash followed by a &#8216;d&#8217;).
</p>
<p>
If a string is used as the replacement, special variables from the match
(such as <tt>$&amp;</tt> and <tt>$1</tt>) cannot be substituted into it, as
substitution into the string occurs before the pattern match starts.
However, the sequences <tt>\1</tt>, <tt>\2</tt>, and so on may be used to
interpolate successive groups in the match.
</p>
<p>
In the block form, the current match string is passed in as a parameter,
and variables such as <tt>$1</tt>, <tt>$2</tt>, <tt>$`</tt>,
<tt>$&amp;</tt>, and <tt>$&#8217;</tt> will be set appropriately. The value
returned by the block will be substituted for the match on each call.
</p>
<p>
The result inherits any tainting in the original string or any supplied
replacement string.
</p>
<pre>
   &quot;hello&quot;.gsub(/[aeiou]/, '*')              #=&gt; &quot;h*ll*&quot;
   &quot;hello&quot;.gsub(/([aeiou])/, '&lt;\1&gt;')         #=&gt; &quot;h&lt;e&gt;ll&lt;o&gt;&quot;
   &quot;hello&quot;.gsub(/./) {|s| s[0].to_s + ' '}   #=&gt; &quot;104 101 108 108 111 &quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000804_source')" id="l_M000804_source">show source</a> ]</p>
  <div id="M000804_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.gsub(pattern, replacement)       =&gt; new_str
 *     str.gsub(pattern) {|match| block }   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with &lt;em&gt;all&lt;/em&gt; occurrences of &lt;i&gt;pattern&lt;/i&gt;
 *  replaced with either &lt;i&gt;replacement&lt;/i&gt; or the value of the block. The
 *  &lt;i&gt;pattern&lt;/i&gt; will typically be a &lt;code&gt;Regexp&lt;/code&gt;; if it is a
 *  &lt;code&gt;String&lt;/code&gt; then no regular expression metacharacters will be
 *  interpreted (that is &lt;code&gt;/\d/&lt;/code&gt; will match a digit, but
 *  &lt;code&gt;'\d'&lt;/code&gt; will match a backslash followed by a 'd').
 *     
 *  If a string is used as the replacement, special variables from the match
 *  (such as &lt;code&gt;$&amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt;) cannot be substituted into it,
 *  as substitution into the string occurs before the pattern match
 *  starts. However, the sequences &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;, and so on
 *  may be used to interpolate successive groups in the match.
 *     
 *  In the block form, the current match string is passed in as a parameter, and
 *  variables such as &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt;,
 *  &lt;code&gt;$&amp;&lt;/code&gt;, and &lt;code&gt;$'&lt;/code&gt; will be set appropriately. The value
 *  returned by the block will be substituted for the match on each call.
 *     
 *  The result inherits any tainting in the original string or any supplied
 *  replacement string.
 *     
 *     &quot;hello&quot;.gsub(/[aeiou]/, '*')              #=&gt; &quot;h*ll*&quot;
 *     &quot;hello&quot;.gsub(/([aeiou])/, '&lt;\1&gt;')         #=&gt; &quot;h&lt;e&gt;ll&lt;o&gt;&quot;
 *     &quot;hello&quot;.gsub(/./) {|s| s[0].to_s + ' '}   #=&gt; &quot;104 101 108 108 111 &quot;
 */

static VALUE
rb_str_gsub(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return str_gsub(argc, argv, str, 0);
}
</pre>
  </div>
</div>
</div>
<div id="M000811" class="method">
  <div id="M000811_title" class="title">
    <b>str.gsub!(pattern, replacement)        => str or nil<br />
str.gsub!(pattern) {|match| block }    => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Performs the substitutions of <tt><a
href="index.html?a=M000804&name=String#gsub">String#gsub</a></tt> in place,
returning <em>str</em>, or <tt>nil</tt> if no substitutions were performed.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000811_source')" id="l_M000811_source">show source</a> ]</p>
  <div id="M000811_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.gsub!(pattern, replacement)        =&gt; str or nil
 *     str.gsub!(pattern) {|match| block }    =&gt; str or nil
 *  
 *  Performs the substitutions of &lt;code&gt;String#gsub&lt;/code&gt; in place, returning
 *  &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no substitutions were performed.
 */

static VALUE
rb_str_gsub_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return str_gsub(argc, argv, str, 1);
}
</pre>
  </div>
</div>
</div>
<div id="M000750" class="method">
  <div id="M000750_title" class="title">
    <b>str.hash   => fixnum<br />
</b>
  </div>
  <div class="description">
  <p>
Return a hash based on the string&#8217;s length and content.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000750_source')" id="l_M000750_source">show source</a> ]</p>
  <div id="M000750_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *    str.hash   =&gt; fixnum
 *
 * Return a hash based on the string's length and content.
 */

static VALUE
rb_str_hash_m(str)
    VALUE str;
{
    int key = rb_str_hash(str);
    return INT2FIX(key);
}
</pre>
  </div>
</div>
</div>
<div id="M000786" class="method">
  <div id="M000786_title" class="title">
    <b>str.hex   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Treats leading characters from <em>str</em> as a string of hexadecimal
digits (with an optional sign and an optional <tt>0x</tt>) and returns the
corresponding number. Zero is returned on error.
</p>
<pre>
   &quot;0x0a&quot;.hex     #=&gt; 10
   &quot;-1234&quot;.hex    #=&gt; -4660
   &quot;0&quot;.hex        #=&gt; 0
   &quot;wombat&quot;.hex   #=&gt; 0
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000786_source')" id="l_M000786_source">show source</a> ]</p>
  <div id="M000786_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.hex   =&gt; integer
 *  
 *  Treats leading characters from &lt;i&gt;str&lt;/i&gt; as a string of hexadecimal digits
 *  (with an optional sign and an optional &lt;code&gt;0x&lt;/code&gt;) and returns the
 *  corresponding number. Zero is returned on error.
 *     
 *     &quot;0x0a&quot;.hex     #=&gt; 10
 *     &quot;-1234&quot;.hex    #=&gt; -4660
 *     &quot;0&quot;.hex        #=&gt; 0
 *     &quot;wombat&quot;.hex   #=&gt; 0
 */

static VALUE
rb_str_hex(str)
    VALUE str;
{
    return rb_str_to_inum(str, 16, Qfalse);
}
</pre>
  </div>
</div>
</div>
<div id="M000796" class="method">
  <div id="M000796_title" class="title">
    <b>str.include? other_str   => true or false<br />
str.include? fixnum      => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Returns <tt>true</tt> if <em>str</em> contains the given string or
character.
</p>
<pre>
   &quot;hello&quot;.include? &quot;lo&quot;   #=&gt; true
   &quot;hello&quot;.include? &quot;ol&quot;   #=&gt; false
   &quot;hello&quot;.include? ?h     #=&gt; true
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000796_source')" id="l_M000796_source">show source</a> ]</p>
  <div id="M000796_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.include? other_str   =&gt; true or false
 *     str.include? fixnum      =&gt; true or false
 *  
 *  Returns &lt;code&gt;true&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; contains the given string or
 *  character.
 *     
 *     &quot;hello&quot;.include? &quot;lo&quot;   #=&gt; true
 *     &quot;hello&quot;.include? &quot;ol&quot;   #=&gt; false
 *     &quot;hello&quot;.include? ?h     #=&gt; true
 */

static VALUE
rb_str_include(str, arg)
    VALUE str, arg;
{
    long i;

    if (FIXNUM_P(arg)) {
        if (memchr(RSTRING(str)-&gt;ptr, FIX2INT(arg), RSTRING(str)-&gt;len))
            return Qtrue;
        return Qfalse;
    }

    StringValue(arg);
    i = rb_str_index(str, arg, 0);

    if (i == -1) return Qfalse;
    return Qtrue;
}
</pre>
  </div>
</div>
</div>
<div id="M000769" class="method">
  <div id="M000769_title" class="title">
    <b>str.index(substring [, offset])   => fixnum or nil<br />
str.index(fixnum [, offset])      => fixnum or nil<br />
str.index(regexp [, offset])      => fixnum or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the index of the first occurrence of the given <em>substring</em>,
character (<em>fixnum</em>), or pattern (<em>regexp</em>) in <em>str</em>.
Returns <tt>nil</tt> if not found. If the second parameter is present, it
specifies the position in the string to begin the search.
</p>
<pre>
   &quot;hello&quot;.index('e')             #=&gt; 1
   &quot;hello&quot;.index('lo')            #=&gt; 3
   &quot;hello&quot;.index('a')             #=&gt; nil
   &quot;hello&quot;.index(101)             #=&gt; 1
   &quot;hello&quot;.index(/[aeiou]/, -3)   #=&gt; 4
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000769_source')" id="l_M000769_source">show source</a> ]</p>
  <div id="M000769_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.index(substring [, offset])   =&gt; fixnum or nil
 *     str.index(fixnum [, offset])      =&gt; fixnum or nil
 *     str.index(regexp [, offset])      =&gt; fixnum or nil
 *  
 *  Returns the index of the first occurrence of the given &lt;i&gt;substring&lt;/i&gt;,
 *  character (&lt;i&gt;fixnum&lt;/i&gt;), or pattern (&lt;i&gt;regexp&lt;/i&gt;) in &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if not found. If the second parameter is present, it
 *  specifies the position in the string to begin the search.
 *     
 *     &quot;hello&quot;.index('e')             #=&gt; 1
 *     &quot;hello&quot;.index('lo')            #=&gt; 3
 *     &quot;hello&quot;.index('a')             #=&gt; nil
 *     &quot;hello&quot;.index(101)             #=&gt; 1
 *     &quot;hello&quot;.index(/[aeiou]/, -3)   #=&gt; 4
 */

static VALUE
rb_str_index_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE sub;
    VALUE initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
    }
    else {
        pos = 0;
    }
    if (pos &lt; 0) {
        pos += RSTRING(str)-&gt;len;
        if (pos &lt; 0) {
            if (TYPE(sub) == T_REGEXP) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
    }

    switch (TYPE(sub)) {
      case T_REGEXP:
        pos = rb_reg_adjust_startpos(sub, str, pos, 0);
        pos = rb_reg_search(sub, str, pos, 0);
        break;

      case T_FIXNUM: {
        int c = FIX2INT(sub);
        long len = RSTRING(str)-&gt;len;
        unsigned char *p = (unsigned char*)RSTRING(str)-&gt;ptr;

        for (;pos&lt;len;pos++) {
            if (p[pos] == c) return LONG2NUM(pos);
        }
        return Qnil;
      }

      default: {
        VALUE tmp;

        tmp = rb_check_string_type(sub);
        if (NIL_P(tmp)) {
            rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
                     rb_obj_classname(sub));
        }
        sub = tmp;
      }
        /* fall through */
      case T_STRING:
        pos = rb_str_index(str, sub, pos);
        break;
    }

    if (pos == -1) return Qnil;
    return LONG2NUM(pos);
}
</pre>
  </div>
</div>
</div>
<div id="M000746" class="method">
  <div id="M000746_title" class="title">
    <b>str.replace(other_str)   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.
</p>
<pre>
   s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
   s.replace &quot;world&quot;   #=&gt; &quot;world&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000746_source')" id="l_M000746_source">show source</a> ]</p>
  <div id="M000746_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.replace(other_str)   =&gt; str
 *  
 *  Replaces the contents and taintedness of &lt;i&gt;str&lt;/i&gt; with the corresponding
 *  values in &lt;i&gt;other_str&lt;/i&gt;.
 *     
 *     s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
 *     s.replace &quot;world&quot;   #=&gt; &quot;world&quot;
 */

static VALUE
rb_str_replace(str, str2)
    VALUE str, str2;
{
    if (str == str2) return str;

    StringValue(str2);
    if (FL_TEST(str2, ELTS_SHARED)) {
        if (str_independent(str)) {
            free(RSTRING(str)-&gt;ptr);
        }
        RSTRING(str)-&gt;len = RSTRING(str2)-&gt;len;
        RSTRING(str)-&gt;ptr = RSTRING(str2)-&gt;ptr;
        FL_SET(str, ELTS_SHARED);
        FL_UNSET(str, STR_ASSOC);
        RSTRING(str)-&gt;aux.shared = RSTRING(str2)-&gt;aux.shared;
    }
    else {
        rb_str_modify(str);
        rb_str_resize(str, RSTRING(str2)-&gt;len);
        memcpy(RSTRING(str)-&gt;ptr, RSTRING(str2)-&gt;ptr, RSTRING(str2)-&gt;len);
        if (FL_TEST(str2, STR_ASSOC)) {
            FL_SET(str, STR_ASSOC);
            RSTRING(str)-&gt;aux.shared = RSTRING(str2)-&gt;aux.shared;
        }
    }

    OBJ_INFECT(str, str2);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000757" class="method">
  <div id="M000757_title" class="title">
    <b>str.insert(index, other_str)   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Inserts <em>other_str</em> before the character at the given
<em>index</em>, modifying <em>str</em>. Negative indices count from the end
of the string, and insert <em>after</em> the given character. The intent is
insert <em>aString</em> so that it starts at the given <em>index</em>.
</p>
<pre>
   &quot;abcd&quot;.insert(0, 'X')    #=&gt; &quot;Xabcd&quot;
   &quot;abcd&quot;.insert(3, 'X')    #=&gt; &quot;abcXd&quot;
   &quot;abcd&quot;.insert(4, 'X')    #=&gt; &quot;abcdX&quot;
   &quot;abcd&quot;.insert(-3, 'X')   #=&gt; &quot;abXcd&quot;
   &quot;abcd&quot;.insert(-1, 'X')   #=&gt; &quot;abcdX&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000757_source')" id="l_M000757_source">show source</a> ]</p>
  <div id="M000757_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.insert(index, other_str)   =&gt; str
 *  
 *  Inserts &lt;i&gt;other_str&lt;/i&gt; before the character at the given
 *  &lt;i&gt;index&lt;/i&gt;, modifying &lt;i&gt;str&lt;/i&gt;. Negative indices count from the
 *  end of the string, and insert &lt;em&gt;after&lt;/em&gt; the given character.
 *  The intent is insert &lt;i&gt;aString&lt;/i&gt; so that it starts at the given
 *  &lt;i&gt;index&lt;/i&gt;.
 *     
 *     &quot;abcd&quot;.insert(0, 'X')    #=&gt; &quot;Xabcd&quot;
 *     &quot;abcd&quot;.insert(3, 'X')    #=&gt; &quot;abcXd&quot;
 *     &quot;abcd&quot;.insert(4, 'X')    #=&gt; &quot;abcdX&quot;
 *     &quot;abcd&quot;.insert(-3, 'X')   #=&gt; &quot;abXcd&quot;
 *     &quot;abcd&quot;.insert(-1, 'X')   #=&gt; &quot;abcdX&quot;
 */

static VALUE
rb_str_insert(str, idx, str2)
    VALUE str, idx, str2;
{
    long pos = NUM2LONG(idx);

    if (pos == -1) {
        pos = RSTRING(str)-&gt;len;
    }
    else if (pos &lt; 0) {
        pos++;
    }
    rb_str_splice(str, pos, 0, str2);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000776" class="method">
  <div id="M000776_title" class="title">
    <b>str.inspect   => string<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a printable version of <em>str</em>, with special characters
escaped.
</p>
<pre>
   str = &quot;hello&quot;
   str[3] = 8
   str.inspect       #=&gt; &quot;hel\010o&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000776_source')" id="l_M000776_source">show source</a> ]</p>
  <div id="M000776_source" class="dyn-source">
<pre>
/*
 * call-seq:
 *   str.inspect   =&gt; string
 *
 * Returns a printable version of _str_, with special characters
 * escaped.
 *
 *    str = &quot;hello&quot;
 *    str[3] = 8
 *    str.inspect       #=&gt; &quot;hel\010o&quot;
 */

VALUE
rb_str_inspect(str)
    VALUE str;
{
    char *p, *pend;
    VALUE result = rb_str_buf_new2(&quot;\&quot;&quot;);
    char s[5];

    p = RSTRING(str)-&gt;ptr; pend = p + RSTRING(str)-&gt;len;
    while (p &lt; pend) {
        char c = *p++;
        if (ismbchar(c) &amp;&amp; p &lt; pend) {
            int len = mbclen(c);
            rb_str_buf_cat(result, p - 1, len);
            p += len - 1;
        }
        else if (c == '&quot;'|| c == '\\' || (c == '#' &amp;&amp; IS_EVSTR(p, pend))) {
            s[0] = '\\'; s[1] = c;
            rb_str_buf_cat(result, s, 2);
        }
        else if (ISPRINT(c)) {
            s[0] = c;
            rb_str_buf_cat(result, s, 1);
        }
        else if (c == '\n') {
            s[0] = '\\'; s[1] = 'n';
            rb_str_buf_cat(result, s, 2);
        }
        else if (c == '\r') {
            s[0] = '\\'; s[1] = 'r';
            rb_str_buf_cat(result, s, 2);
        }
        else if (c == '\t') {
            s[0] = '\\'; s[1] = 't';
            rb_str_buf_cat(result, s, 2);
        }
        else if (c == '\f') {
            s[0] = '\\'; s[1] = 'f';
            rb_str_buf_cat(result, s, 2);
        }
        else if (c == '\013') {
            s[0] = '\\'; s[1] = 'v';
            rb_str_buf_cat(result, s, 2);
        }
        else if (c == '\010') {
            s[0] = '\\'; s[1] = 'b';
            rb_str_buf_cat(result, s, 2);
        }
        else if (c == '\007') {
            s[0] = '\\'; s[1] = 'a';
            rb_str_buf_cat(result, s, 2);
        }
        else if (c == 033) {
            s[0] = '\\'; s[1] = 'e';
            rb_str_buf_cat(result, s, 2);
        }
        else {
            sprintf(s, &quot;\\%03o&quot;, c &amp; 0377);
            rb_str_buf_cat2(result, s);
        }
    }
    rb_str_buf_cat2(result, &quot;\&quot;&quot;);

    OBJ_INFECT(result, str);
    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M000794" class="method">
  <div id="M000794_title" class="title">
    <b>str.intern   => symbol<br />
str.to_sym   => symbol<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the <tt><a
href="index.html?a=C00000284&name=Symbol">Symbol</a></tt> corresponding to
<em>str</em>, creating the symbol if it did not previously exist. See
<tt><a
href="index.html?a=M002638&name=Symbol#id2name">Symbol#id2name</a></tt>.
</p>
<pre>
   &quot;Koala&quot;.intern         #=&gt; :Koala
   s = 'cat'.to_sym       #=&gt; :cat
   s == :cat              #=&gt; true
   s = '@cat'.to_sym      #=&gt; :@cat
   s == :@cat             #=&gt; true
</pre>
<p>
This can also be used to create symbols that cannot be represented using
the <tt>:xxx</tt> notation.
</p>
<pre>
   'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000794_source')" id="l_M000794_source">show source</a> ]</p>
  <div id="M000794_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.intern   =&gt; symbol
 *     str.to_sym   =&gt; symbol
 *  
 *  Returns the &lt;code&gt;Symbol&lt;/code&gt; corresponding to &lt;i&gt;str&lt;/i&gt;, creating the
 *  symbol if it did not previously exist. See &lt;code&gt;Symbol#id2name&lt;/code&gt;.
 *     
 *     &quot;Koala&quot;.intern         #=&gt; :Koala
 *     s = 'cat'.to_sym       #=&gt; :cat
 *     s == :cat              #=&gt; true
 *     s = '@cat'.to_sym      #=&gt; :@cat
 *     s == :@cat             #=&gt; true
 *
 *  This can also be used to create symbols that cannot be represented using the
 *  &lt;code&gt;:xxx&lt;/code&gt; notation.
 *     
 *     'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;
 */

VALUE
rb_str_intern(s)
    VALUE s;
{
    volatile VALUE str = s;
    ID id;

    if (!RSTRING(str)-&gt;ptr || RSTRING(str)-&gt;len == 0) {
        rb_raise(rb_eArgError, &quot;interning empty string&quot;);
    }
    if (strlen(RSTRING(str)-&gt;ptr) != RSTRING(str)-&gt;len)
        rb_raise(rb_eArgError, &quot;symbol string may not contain `\\0'&quot;);
    if (OBJ_TAINTED(str) &amp;&amp; rb_safe_level() &gt;= 1 &amp;&amp; !rb_sym_interned_p(str)) {
        rb_raise(rb_eSecurityError, &quot;Insecure: can't intern tainted string&quot;);
    }
    id = rb_intern(RSTRING(str)-&gt;ptr);
    return ID2SYM(id);
}
</pre>
  </div>
</div>
</div>
<div id="M000861" class="method">
  <div id="M000861_title" class="title">
    <b>is_binary_data?</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000861_source')" id="l_M000861_source">show source</a> ]</p>
  <div id="M000861_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 145</span>
145:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">is_binary_data?</span>
146:         ( <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">count</span>( <span class="ruby-value str">&quot;^ -~&quot;</span>, <span class="ruby-value str">&quot;^\r\n&quot;</span> ).<span class="ruby-identifier">fdiv</span>(<span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">size</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span><span class="ruby-value">.3</span> <span class="ruby-operator">||</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">index</span>( <span class="ruby-value str">&quot;\x00&quot;</span> ) ) <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">empty?</span>
147:     <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000860" class="method">
  <div id="M000860_title" class="title">
    <b>is_complex_yaml?</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000860_source')" id="l_M000860_source">show source</a> ]</p>
  <div id="M000860_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 142</span>
142:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">is_complex_yaml?</span>
143:         <span class="ruby-identifier">to_yaml_style</span> <span class="ruby-keyword kw">or</span> <span class="ruby-keyword kw">not</span> <span class="ruby-identifier">to_yaml_properties</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-keyword kw">or</span> <span class="ruby-keyword kw">self</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/\n.+/</span>
144:     <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000870" class="method">
  <div id="M000870_title" class="title">
    <b>String#iseuc   &rarr; obj or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Returns whether <tt>self</tt>&#8217;s encoding is EUC-JP or not.
</p>
<p>
<b>Note</b> don&#8217;t expect this return value is <a
href="index.html?a=C00000118&name=MatchData">MatchData</a>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000870_source')" id="l_M000870_source">show source</a> ]</p>
  <div id="M000870_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 350</span>
350:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">iseuc</span>;    <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">iseuc</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000871" class="method">
  <div id="M000871_title" class="title">
    <b>String#issjis   &rarr; obj or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Returns whether <tt>self</tt>&#8217;s encoding is Shift_JIS or not.
</p>
<p>
<b>Note</b> don&#8217;t expect this return value is <a
href="index.html?a=C00000118&name=MatchData">MatchData</a>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000871_source')" id="l_M000871_source">show source</a> ]</p>
  <div id="M000871_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 358</span>
358:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">issjis</span>;   <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">issjis</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000872" class="method">
  <div id="M000872_title" class="title">
    <b>String#isutf8   &rarr; obj or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Returns whether <tt>self</tt>&#8217;s encoding is UTF-8 or not.
</p>
<p>
<b>Note</b> don&#8217;t expect this return value is <a
href="index.html?a=C00000118&name=MatchData">MatchData</a>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000872_source')" id="l_M000872_source">show source</a> ]</p>
  <div id="M000872_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 366</span>
366:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">isutf8</span>;   <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">isutf8</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000854" class="method">
  <div id="M000854_title" class="title">
    <b>jcount</b>(str)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000854_source')" id="l_M000854_source">show source</a> ]</p>
  <div id="M000854_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 205</span>
205:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">jcount</span>(<span class="ruby-identifier">str</span>)
206:     <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-node">&quot;^#{str}&quot;</span>).<span class="ruby-identifier">jlength</span>
207:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000852" class="method">
  <div id="M000852_title" class="title">
    <b>jlength</b>()
  </div>
<div class="aka">
  This method is also aliased as
  <a href="index.html?a=M000853&name=jsize">jsize</a>
</div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000852_source')" id="l_M000852_source">show source</a> ]</p>
  <div id="M000852_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 200</span>
200:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">jlength</span>
201:     <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp re">/[^\Wa-zA-Z_\d]/</span>, <span class="ruby-value str">' '</span>).<span class="ruby-identifier">length</span>
202:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000853" class="method">
  <div id="M000853_title" class="title">
    <b>jsize</b>()
  </div>
  <div class="description">
  <p>
Alias for <a href="index.html?a=M000852&name=jlength">jlength</a>
</p>
  </div>
</div>
<div id="M000864" class="method">
  <div id="M000864_title" class="title">
    <b>String#kconv(out_code, in_code = Kconv::AUTO)<br />
</b>
  </div>
  <div class="description">
  <p>
Convert <tt>self</tt> to out_code. <tt>out_code</tt> and <tt>in_code</tt>
are given as constants of <a
href="index.html?a=C00001015&name=Kconv">Kconv</a>.
</p>
<p>
<b>Note</b> This method decode MIME encoded string and convert halfwidth
katakana to fullwidth katakana. If you don&#8217;t want to decode them, use
<a href="index.html?a=M005939&name=NKF.nkf">NKF.nkf</a>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000864_source')" id="l_M000864_source">show source</a> ]</p>
  <div id="M000864_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 277</span>
277:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">kconv</span>(<span class="ruby-identifier">out_code</span>, <span class="ruby-identifier">in_code</span>=<span class="ruby-constant">Kconv</span><span class="ruby-operator">::</span><span class="ruby-constant">AUTO</span>)
278:     <span class="ruby-constant">Kconv</span><span class="ruby-operator">::</span><span class="ruby-identifier">kconv</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">out_code</span>, <span class="ruby-identifier">in_code</span>)
279:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000758" class="method">
  <div id="M000758_title" class="title">
    <b>str.length   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the length of <em>str</em>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000758_source')" id="l_M000758_source">show source</a> ]</p>
  <div id="M000758_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.length   =&gt; integer
 *  
 *  Returns the length of &lt;i&gt;str&lt;/i&gt;.
 */

static VALUE
rb_str_length(str)
    VALUE str;
{
    return LONG2NUM(RSTRING(str)-&gt;len);
}
</pre>
  </div>
</div>
</div>
<div id="M000830" class="method">
  <div id="M000830_title" class="title">
    <b>str.lines(separator=$/)   => anEnumerator<br />
str.lines(separator=$/) {|substr| block }        => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns an enumerator that gives each line in the string. If a block is
given, it iterates over each line in the string.
</p>
<pre>
   &quot;foo\nbar\n&quot;.lines.to_a   #=&gt; [&quot;foo\n&quot;, &quot;bar\n&quot;]
   &quot;foo\nb ar&quot;.lines.sort    #=&gt; [&quot;b ar&quot;, &quot;foo\n&quot;]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000830_source')" id="l_M000830_source">show source</a> ]</p>
  <div id="M000830_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.each(separator=$/) {|substr| block }        =&gt; str
 *     str.each_line(separator=$/) {|substr| block }   =&gt; str
 *  
 *  Splits &lt;i&gt;str&lt;/i&gt; using the supplied parameter as the record separator
 *  (&lt;code&gt;$/&lt;/code&gt; by default), passing each substring in turn to the supplied
 *  block. If a zero-length record separator is supplied, the string is split
 *  into paragraphs delimited by multiple successive newlines.
 *     
 *     print &quot;Example one\n&quot;
 *     &quot;hello\nworld&quot;.each {|s| p s}
 *     print &quot;Example two\n&quot;
 *     &quot;hello\nworld&quot;.each('l') {|s| p s}
 *     print &quot;Example three\n&quot;
 *     &quot;hello\n\n\nworld&quot;.each('') {|s| p s}
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     Example one
 *     &quot;hello\n&quot;
 *     &quot;world&quot;
 *     Example two
 *     &quot;hel&quot;
 *     &quot;l&quot;
 *     &quot;o\nworl&quot;
 *     &quot;d&quot;
 *     Example three
 *     &quot;hello\n\n\n&quot;
 *     &quot;world&quot;
 */

static VALUE
rb_str_each_line(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE rs;
    int newline;
    char *p = RSTRING(str)-&gt;ptr, *pend = p + RSTRING(str)-&gt;len, *s;
    char *ptr = p;
    long len = RSTRING(str)-&gt;len, rslen;
    VALUE line;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;rs) == 0) {
        rs = rb_rs;
    }
    RETURN_ENUMERATOR(str, argc, argv);
    if (NIL_P(rs)) {
        rb_yield(str);
        return str;
    }
    StringValue(rs);
    rslen = RSTRING(rs)-&gt;len;
    if (rslen == 0) {
        newline = '\n';
    }
    else {
        newline = RSTRING(rs)-&gt;ptr[rslen-1];
    }

    for (s = p, p += rslen; p &lt; pend; p++) {
        if (rslen == 0 &amp;&amp; *p == '\n') {
            if (*++p != '\n') continue;
            while (*p == '\n') p++;
        }
        if (RSTRING(str)-&gt;ptr &lt; p &amp;&amp; p[-1] == newline &amp;&amp;
            (rslen &lt;= 1 ||
             rb_memcmp(RSTRING(rs)-&gt;ptr, p-rslen, rslen) == 0)) {
            line = rb_str_new5(str, s, p - s);
            OBJ_INFECT(line, str);
            rb_yield(line);
            str_mod_check(str, ptr, len);
            s = p;
        }
    }

    if (s != pend) {
        if (p &gt; pend) p = pend;
        line = rb_str_new5(str, s, p - s);
        OBJ_INFECT(line, str);
        rb_yield(line);
    }

    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000800" class="method">
  <div id="M000800_title" class="title">
    <b>str.ljust(integer, padstr=' ')   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt><a href="index.html?a=C00000055&name=String">String</a></tt> of
length <em>integer</em> with <em>str</em> left justified and padded with
<em>padstr</em>; otherwise, returns <em>str</em>.
</p>
<pre>
   &quot;hello&quot;.ljust(4)            #=&gt; &quot;hello&quot;
   &quot;hello&quot;.ljust(20)           #=&gt; &quot;hello               &quot;
   &quot;hello&quot;.ljust(20, '1234')   #=&gt; &quot;hello123412341234123&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000800_source')" id="l_M000800_source">show source</a> ]</p>
  <div id="M000800_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.ljust(integer, padstr=' ')   =&gt; new_str
 *  
 *  If &lt;i&gt;integer&lt;/i&gt; is greater than the length of &lt;i&gt;str&lt;/i&gt;, returns a new
 *  &lt;code&gt;String&lt;/code&gt; of length &lt;i&gt;integer&lt;/i&gt; with &lt;i&gt;str&lt;/i&gt; left justified
 *  and padded with &lt;i&gt;padstr&lt;/i&gt;; otherwise, returns &lt;i&gt;str&lt;/i&gt;.
 *     
 *     &quot;hello&quot;.ljust(4)            #=&gt; &quot;hello&quot;
 *     &quot;hello&quot;.ljust(20)           #=&gt; &quot;hello               &quot;
 *     &quot;hello&quot;.ljust(20, '1234')   #=&gt; &quot;hello123412341234123&quot;
 */

static VALUE
rb_str_ljust(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'l');
}
</pre>
  </div>
</div>
</div>
<div id="M000808" class="method">
  <div id="M000808_title" class="title">
    <b>str.lstrip   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with leading whitespace removed. See also
<tt><a
href="index.html?a=M000809&name=String#rstrip">String#rstrip</a></tt> and
<tt><a href="index.html?a=M000807&name=String#strip">String#strip</a></tt>.
</p>
<pre>
   &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
   &quot;hello&quot;.lstrip       #=&gt; &quot;hello&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000808_source')" id="l_M000808_source">show source</a> ]</p>
  <div id="M000808_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.lstrip   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with leading whitespace removed. See also
 *  &lt;code&gt;String#rstrip&lt;/code&gt; and &lt;code&gt;String#strip&lt;/code&gt;.
 *     
 *     &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
 *     &quot;hello&quot;.lstrip       #=&gt; &quot;hello&quot;
 */

static VALUE
rb_str_lstrip(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_lstrip_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000815" class="method">
  <div id="M000815_title" class="title">
    <b>str.lstrip!   => self or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Removes leading whitespace from <em>str</em>, returning <tt>nil</tt> if no
change was made. See also <tt><a
href="index.html?a=M000809&name=String#rstrip">String#rstrip</a>!</tt> and
<tt><a
href="index.html?a=M000807&name=String#strip">String#strip</a>!</tt>.
</p>
<pre>
   &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
   &quot;hello&quot;.lstrip!      #=&gt; nil
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000815_source')" id="l_M000815_source">show source</a> ]</p>
  <div id="M000815_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.lstrip!   =&gt; self or nil
 *  
 *  Removes leading whitespace from &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if no
 *  change was made. See also &lt;code&gt;String#rstrip!&lt;/code&gt; and
 *  &lt;code&gt;String#strip!&lt;/code&gt;.
 *     
 *     &quot;  hello  &quot;.lstrip   #=&gt; &quot;hello  &quot;
 *     &quot;hello&quot;.lstrip!      #=&gt; nil
 */

static VALUE
rb_str_lstrip_bang(str)
    VALUE str;
{
    char *s, *t, *e;

    s = RSTRING(str)-&gt;ptr;
    if (!s || RSTRING(str)-&gt;len == 0) return Qnil;
    e = t = s + RSTRING(str)-&gt;len;
    /* remove spaces at head */
    while (s &lt; t &amp;&amp; ISSPACE(*s)) s++;

    if (s &gt; RSTRING(str)-&gt;ptr) {
        rb_str_modify(str);
        RSTRING(str)-&gt;len = t-s;
        memmove(RSTRING(str)-&gt;ptr, s, RSTRING(str)-&gt;len);
        RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
        return str;
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000763" class="method">
  <div id="M000763_title" class="title">
    <b>str.match(pattern)   => matchdata or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Converts <em>pattern</em> to a <tt><a
href="index.html?a=C00000110&name=Regexp">Regexp</a></tt> (if it
isn&#8217;t already one), then invokes its <tt>match</tt> method on
<em>str</em>.
</p>
<pre>
   'hello'.match('(.)\1')      #=&gt; #&lt;MatchData:0x401b3d30&gt;
   'hello'.match('(.)\1')[0]   #=&gt; &quot;ll&quot;
   'hello'.match(/(.)\1/)[0]   #=&gt; &quot;ll&quot;
   'hello'.match('xx')         #=&gt; nil
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000763_source')" id="l_M000763_source">show source</a> ]</p>
  <div id="M000763_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.match(pattern)   =&gt; matchdata or nil
 *  
 *  Converts &lt;i&gt;pattern&lt;/i&gt; to a &lt;code&gt;Regexp&lt;/code&gt; (if it isn't already one),
 *  then invokes its &lt;code&gt;match&lt;/code&gt; method on &lt;i&gt;str&lt;/i&gt;.
 *     
 *     'hello'.match('(.)\1')      #=&gt; #&lt;MatchData:0x401b3d30&gt;
 *     'hello'.match('(.)\1')[0]   #=&gt; &quot;ll&quot;
 *     'hello'.match(/(.)\1/)[0]   #=&gt; &quot;ll&quot;
 *     'hello'.match('xx')         #=&gt; nil
 */

static VALUE
rb_str_match_m(str, re)
    VALUE str, re;
{
    return rb_funcall(get_pat(re, 0), rb_intern(&quot;match&quot;), 1, str);
}
</pre>
  </div>
</div>
</div>
<div id="M000838" class="method">
  <div id="M000838_title" class="title">
    <b>mbchar?</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000838_source')" id="l_M000838_source">show source</a> ]</p>
  <div id="M000838_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 46</span>
46:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">mbchar?</span>
47:     <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">$KCODE</span>[<span class="ruby-value">0</span>]
48:     <span class="ruby-keyword kw">when</span> <span class="ruby-value">?s</span>, <span class="ruby-value">?S</span>
49:       <span class="ruby-keyword kw">self</span> <span class="ruby-operator">=~</span> <span class="ruby-constant">RE_SJIS</span>
50:     <span class="ruby-keyword kw">when</span> <span class="ruby-value">?e</span>, <span class="ruby-value">?E</span>
51:       <span class="ruby-keyword kw">self</span> <span class="ruby-operator">=~</span> <span class="ruby-constant">RE_EUC</span>
52:     <span class="ruby-keyword kw">when</span> <span class="ruby-value">?u</span>, <span class="ruby-value">?U</span>
53:       <span class="ruby-keyword kw">self</span> <span class="ruby-operator">=~</span> <span class="ruby-constant">RE_UTF8</span>
54:     <span class="ruby-keyword kw">else</span>
55:       <span class="ruby-keyword kw">nil</span>
56:     <span class="ruby-keyword kw">end</span>
57:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000766" class="method">
  <div id="M000766_title" class="title">
    <b>str.succ   => new_str<br />
str.next   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the successor to <em>str</em>. The successor is calculated by
incrementing characters starting from the rightmost alphanumeric (or the
rightmost character if there are no alphanumerics) in the string.
Incrementing a digit always results in another digit, and incrementing a
letter results in another letter of the same case. Incrementing
nonalphanumerics uses the underlying character set&#8217;s collating
sequence.
</p>
<p>
If the increment generates a ``carry,&#8217;&#8217; the character to the
left of it is incremented. This process repeats until there is no carry,
adding an additional character if necessary.
</p>
<pre>
   &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
   &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
   &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
   &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
   &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
   &quot;***&quot;.succ         #=&gt; &quot;**+&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000766_source')" id="l_M000766_source">show source</a> ]</p>
  <div id="M000766_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.succ   =&gt; new_str
 *     str.next   =&gt; new_str
 *  
 *  Returns the successor to &lt;i&gt;str&lt;/i&gt;. The successor is calculated by
 *  incrementing characters starting from the rightmost alphanumeric (or
 *  the rightmost character if there are no alphanumerics) in the
 *  string. Incrementing a digit always results in another digit, and
 *  incrementing a letter results in another letter of the same case.
 *  Incrementing nonalphanumerics uses the underlying character set's
 *  collating sequence.
 *     
 *  If the increment generates a ``carry,'' the character to the left of
 *  it is incremented. This process repeats until there is no carry,
 *  adding an additional character if necessary.
 *     
 *     &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
 *     &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
 *     &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
 *     &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
 *     &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
 *     &quot;***&quot;.succ         #=&gt; &quot;**+&quot;
 */

static VALUE
rb_str_succ(orig)
    VALUE orig;
{
    VALUE str;
    char *sbeg, *s;
    int c = -1;
    long n = 0;

    str = rb_str_new5(orig, RSTRING(orig)-&gt;ptr, RSTRING(orig)-&gt;len);
    OBJ_INFECT(str, orig);
    if (RSTRING(str)-&gt;len == 0) return str;

    sbeg = RSTRING(str)-&gt;ptr; s = sbeg + RSTRING(str)-&gt;len - 1;

    while (sbeg &lt;= s) {
        if (ISALNUM(*s)) {
            if ((c = succ_char(s)) == 0) break;
            n = s - sbeg;
        }
        s--;
    }
    if (c == -1) {              /* str contains no alnum */
        sbeg = RSTRING(str)-&gt;ptr; s = sbeg + RSTRING(str)-&gt;len - 1;
        c = '\001';
        while (sbeg &lt;= s) {
            if ((*s += 1) != 0) break;
            s--;
        }
    }
    if (s &lt; sbeg) {
        RESIZE_CAPA(str, RSTRING(str)-&gt;len + 1);
        s = RSTRING(str)-&gt;ptr + n;
        memmove(s+1, s, RSTRING(str)-&gt;len - n);
        *s = c;
        RSTRING(str)-&gt;len += 1;
        RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
    }

    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000767" class="method">
  <div id="M000767_title" class="title">
    <b>str.succ!   => str<br />
str.next!   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Equivalent to <tt><a
href="index.html?a=M000764&name=String#succ">String#succ</a></tt>, but
modifies the receiver in place.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000767_source')" id="l_M000767_source">show source</a> ]</p>
  <div id="M000767_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.succ!   =&gt; str
 *     str.next!   =&gt; str
 *  
 *  Equivalent to &lt;code&gt;String#succ&lt;/code&gt;, but modifies the receiver in
 *  place.
 */

static VALUE
rb_str_succ_bang(str)
    VALUE str;
{
    rb_str_shared_replace(str, rb_str_succ(str));

    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000787" class="method">
  <div id="M000787_title" class="title">
    <b>str.oct   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Treats leading characters of <em>str</em> as a string of octal digits (with
an optional sign) and returns the corresponding number. Returns 0 if the
conversion fails.
</p>
<pre>
   &quot;123&quot;.oct       #=&gt; 83
   &quot;-377&quot;.oct      #=&gt; -255
   &quot;bad&quot;.oct       #=&gt; 0
   &quot;0377bad&quot;.oct   #=&gt; 255
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000787_source')" id="l_M000787_source">show source</a> ]</p>
  <div id="M000787_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.oct   =&gt; integer
 *  
 *  Treats leading characters of &lt;i&gt;str&lt;/i&gt; as a string of octal digits (with an
 *  optional sign) and returns the corresponding number.  Returns 0 if the
 *  conversion fails.
 *     
 *     &quot;123&quot;.oct       #=&gt; 83
 *     &quot;-377&quot;.oct      #=&gt; -255
 *     &quot;bad&quot;.oct       #=&gt; 0
 *     &quot;0377bad&quot;.oct   #=&gt; 255
 */

static VALUE
rb_str_oct(str)
    VALUE str;
{
    return rb_str_to_inum(str, -8, Qfalse);
}
</pre>
  </div>
</div>
</div>
<div id="M000836" class="method">
  <div id="M000836_title" class="title">
    <b>str.partition(sep)              => [head, sep, tail]<br />
</b>
  </div>
  <div class="description">
  <p>
Searches the string for <em>sep</em> and returns the part before it, the
<em>sep</em>, and the part after it. If <em>sep</em> is not found, returns
<em>str</em> and two empty strings. If no argument is given, <a
href="index.html?a=M003083&name=Enumerable#partition">Enumerable#partition</a>
is called.
</p>
<pre>
   &quot;hello&quot;.partition(&quot;l&quot;)         #=&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]
   &quot;hello&quot;.partition(&quot;x&quot;)         #=&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000836_source')" id="l_M000836_source">show source</a> ]</p>
  <div id="M000836_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.partition(sep)              =&gt; [head, sep, tail]
 *  
 *  Searches the string for &lt;i&gt;sep&lt;/i&gt; and returns the part before it,
 *  the &lt;i&gt;sep&lt;/i&gt;, and the part after it.  If &lt;i&gt;sep&lt;/i&gt; is not
 *  found, returns &lt;i&gt;str&lt;/i&gt; and two empty strings.  If no argument
 *  is given, Enumerable#partition is called.
 *     
 *     &quot;hello&quot;.partition(&quot;l&quot;)         #=&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]
 *     &quot;hello&quot;.partition(&quot;x&quot;)         #=&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]
 */

static VALUE
rb_str_partition(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE sep;
    long pos;

    if (argc == 0) return rb_call_super(argc, argv);
    rb_scan_args(argc, argv, &quot;1&quot;, &amp;sep);
    if (TYPE(sep) != T_REGEXP) {
        VALUE tmp;

        tmp = rb_check_string_type(sep);
        if (NIL_P(tmp)) {
            rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
                     rb_obj_classname(sep));
        }
        sep = get_arg_pat(tmp);
    }
    pos = rb_reg_search(sep, str, 0, 0);
    if (pos &lt; 0) {
      failed:
        return rb_ary_new3(3, str, rb_str_new(0,0),rb_str_new(0,0));
    }
    sep = rb_str_subpat(str, sep, 0);
    if (pos == 0 &amp;&amp; RSTRING(sep)-&gt;len == 0) goto failed;
    return rb_ary_new3(3, rb_str_substr(str, 0, pos),
                          sep,
                          rb_str_substr(str, pos+RSTRING(sep)-&gt;len,
                                             RSTRING(str)-&gt;len-pos-RSTRING(sep)-&gt;len));
}
</pre>
  </div>
</div>
</div>
<div id="M000771" class="method">
  <div id="M000771_title" class="title">
    <b>str.replace(other_str)   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Replaces the contents and taintedness of <em>str</em> with the
corresponding values in <em>other_str</em>.
</p>
<pre>
   s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
   s.replace &quot;world&quot;   #=&gt; &quot;world&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000771_source')" id="l_M000771_source">show source</a> ]</p>
  <div id="M000771_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.replace(other_str)   =&gt; str
 *  
 *  Replaces the contents and taintedness of &lt;i&gt;str&lt;/i&gt; with the corresponding
 *  values in &lt;i&gt;other_str&lt;/i&gt;.
 *     
 *     s = &quot;hello&quot;         #=&gt; &quot;hello&quot;
 *     s.replace &quot;world&quot;   #=&gt; &quot;world&quot;
 */

static VALUE
rb_str_replace(str, str2)
    VALUE str, str2;
{
    if (str == str2) return str;

    StringValue(str2);
    if (FL_TEST(str2, ELTS_SHARED)) {
        if (str_independent(str)) {
            free(RSTRING(str)-&gt;ptr);
        }
        RSTRING(str)-&gt;len = RSTRING(str2)-&gt;len;
        RSTRING(str)-&gt;ptr = RSTRING(str2)-&gt;ptr;
        FL_SET(str, ELTS_SHARED);
        FL_UNSET(str, STR_ASSOC);
        RSTRING(str)-&gt;aux.shared = RSTRING(str2)-&gt;aux.shared;
    }
    else {
        rb_str_modify(str);
        rb_str_resize(str, RSTRING(str2)-&gt;len);
        memcpy(RSTRING(str)-&gt;ptr, RSTRING(str2)-&gt;ptr, RSTRING(str2)-&gt;len);
        if (FL_TEST(str2, STR_ASSOC)) {
            FL_SET(str, STR_ASSOC);
            RSTRING(str)-&gt;aux.shared = RSTRING(str2)-&gt;aux.shared;
        }
    }

    OBJ_INFECT(str, str2);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000789" class="method">
  <div id="M000789_title" class="title">
    <b>str.reverse   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a new string with the characters from <em>str</em> in reverse
order.
</p>
<pre>
   &quot;stressed&quot;.reverse   #=&gt; &quot;desserts&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000789_source')" id="l_M000789_source">show source</a> ]</p>
  <div id="M000789_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.reverse   =&gt; new_str
 *  
 *  Returns a new string with the characters from &lt;i&gt;str&lt;/i&gt; in reverse order.
 *     
 *     &quot;stressed&quot;.reverse   #=&gt; &quot;desserts&quot;
 */

static VALUE
rb_str_reverse(str)
    VALUE str;
{
    VALUE obj;
    char *s, *e, *p;

    if (RSTRING(str)-&gt;len &lt;= 1) return rb_str_dup(str);

    obj = rb_str_new5(str, 0, RSTRING(str)-&gt;len);
    s = RSTRING(str)-&gt;ptr; e = s + RSTRING(str)-&gt;len - 1;
    p = RSTRING(obj)-&gt;ptr;

    while (e &gt;= s) {
        *p++ = *e--;
    }
    OBJ_INFECT(obj, str);

    return obj;
}
</pre>
  </div>
</div>
</div>
<div id="M000790" class="method">
  <div id="M000790_title" class="title">
    <b>str.reverse!   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Reverses <em>str</em> in place.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000790_source')" id="l_M000790_source">show source</a> ]</p>
  <div id="M000790_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.reverse!   =&gt; str
 *  
 *  Reverses &lt;i&gt;str&lt;/i&gt; in place.
 */

static VALUE
rb_str_reverse_bang(str)
    VALUE str;
{
    char *s, *e;
    char c;

    if (RSTRING(str)-&gt;len &gt; 1) {
        rb_str_modify(str);
        s = RSTRING(str)-&gt;ptr;
        e = s + RSTRING(str)-&gt;len - 1;
        while (s &lt; e) {
            c = *s;
            *s++ = *e;
            *e-- = c;
        }
    }
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000770" class="method">
  <div id="M000770_title" class="title">
    <b>str.rindex(substring [, fixnum])   => fixnum or nil<br />
str.rindex(fixnum [, fixnum])   => fixnum or nil<br />
str.rindex(regexp [, fixnum])   => fixnum or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the index of the last occurrence of the given <em>substring</em>,
character (<em>fixnum</em>), or pattern (<em>regexp</em>) in <em>str</em>.
Returns <tt>nil</tt> if not found. If the second parameter is present, it
specifies the position in the string to end the search&#8212;characters
beyond this point will not be considered.
</p>
<pre>
   &quot;hello&quot;.rindex('e')             #=&gt; 1
   &quot;hello&quot;.rindex('l')             #=&gt; 3
   &quot;hello&quot;.rindex('a')             #=&gt; nil
   &quot;hello&quot;.rindex(101)             #=&gt; 1
   &quot;hello&quot;.rindex(/[aeiou]/, -2)   #=&gt; 1
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000770_source')" id="l_M000770_source">show source</a> ]</p>
  <div id="M000770_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.rindex(substring [, fixnum])   =&gt; fixnum or nil
 *     str.rindex(fixnum [, fixnum])   =&gt; fixnum or nil
 *     str.rindex(regexp [, fixnum])   =&gt; fixnum or nil
 *  
 *  Returns the index of the last occurrence of the given &lt;i&gt;substring&lt;/i&gt;,
 *  character (&lt;i&gt;fixnum&lt;/i&gt;), or pattern (&lt;i&gt;regexp&lt;/i&gt;) in &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if not found. If the second parameter is present, it
 *  specifies the position in the string to end the search---characters beyond
 *  this point will not be considered.
 *     
 *     &quot;hello&quot;.rindex('e')             #=&gt; 1
 *     &quot;hello&quot;.rindex('l')             #=&gt; 3
 *     &quot;hello&quot;.rindex('a')             #=&gt; nil
 *     &quot;hello&quot;.rindex(101)             #=&gt; 1
 *     &quot;hello&quot;.rindex(/[aeiou]/, -2)   #=&gt; 1
 */

static VALUE
rb_str_rindex_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE sub;
    VALUE position;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;position) == 2) {
        pos = NUM2LONG(position);
        if (pos &lt; 0) {
            pos += RSTRING(str)-&gt;len;
            if (pos &lt; 0) {
                if (TYPE(sub) == T_REGEXP) {
                    rb_backref_set(Qnil);
                }
                return Qnil;
            }
        }
        if (pos &gt; RSTRING(str)-&gt;len) pos = RSTRING(str)-&gt;len;
    }
    else {
        pos = RSTRING(str)-&gt;len;
    }

    switch (TYPE(sub)) {
      case T_REGEXP:
        if (RREGEXP(sub)-&gt;len) {
            pos = rb_reg_adjust_startpos(sub, str, pos, 1);
            pos = rb_reg_search(sub, str, pos, 1);
        }
        if (pos &gt;= 0) return LONG2NUM(pos);
        break;

      default: {
        VALUE tmp;

        tmp = rb_check_string_type(sub);
        if (NIL_P(tmp)) {
            rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
                     rb_obj_classname(sub));
        }
        sub = tmp;
      }
        /* fall through */
      case T_STRING:
        pos = rb_str_rindex(str, sub, pos);
        if (pos &gt;= 0) return LONG2NUM(pos);
        break;

      case T_FIXNUM: {
        int c = FIX2INT(sub);
        unsigned char *p = (unsigned char*)RSTRING(str)-&gt;ptr + pos;
        unsigned char *pbeg = (unsigned char*)RSTRING(str)-&gt;ptr;

        if (pos == RSTRING(str)-&gt;len) {
            if (pos == 0) return Qnil;
            --p;
        }
        while (pbeg &lt;= p) {
            if (*p == c) return LONG2NUM((char*)p - RSTRING(str)-&gt;ptr);
            p--;
        }
        return Qnil;
      }
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000801" class="method">
  <div id="M000801_title" class="title">
    <b>str.rjust(integer, padstr=' ')   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
If <em>integer</em> is greater than the length of <em>str</em>, returns a
new <tt><a href="index.html?a=C00000055&name=String">String</a></tt> of
length <em>integer</em> with <em>str</em> right justified and padded with
<em>padstr</em>; otherwise, returns <em>str</em>.
</p>
<pre>
   &quot;hello&quot;.rjust(4)            #=&gt; &quot;hello&quot;
   &quot;hello&quot;.rjust(20)           #=&gt; &quot;               hello&quot;
   &quot;hello&quot;.rjust(20, '1234')   #=&gt; &quot;123412341234123hello&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000801_source')" id="l_M000801_source">show source</a> ]</p>
  <div id="M000801_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.rjust(integer, padstr=' ')   =&gt; new_str
 *  
 *  If &lt;i&gt;integer&lt;/i&gt; is greater than the length of &lt;i&gt;str&lt;/i&gt;, returns a new
 *  &lt;code&gt;String&lt;/code&gt; of length &lt;i&gt;integer&lt;/i&gt; with &lt;i&gt;str&lt;/i&gt; right justified
 *  and padded with &lt;i&gt;padstr&lt;/i&gt;; otherwise, returns &lt;i&gt;str&lt;/i&gt;.
 *     
 *     &quot;hello&quot;.rjust(4)            #=&gt; &quot;hello&quot;
 *     &quot;hello&quot;.rjust(20)           #=&gt; &quot;               hello&quot;
 *     &quot;hello&quot;.rjust(20, '1234')   #=&gt; &quot;123412341234123hello&quot;
 */

static VALUE
rb_str_rjust(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'r');
}
</pre>
  </div>
</div>
</div>
<div id="M000837" class="method">
  <div id="M000837_title" class="title">
    <b>str.rpartition(sep)            => [head, sep, tail]<br />
</b>
  </div>
  <div class="description">
  <p>
Searches <em>sep</em> in the string from the end of the string, and returns
the part before it, the <em>sep</em>, and the part after it. If
<em>sep</em> is not found, returns two empty strings and <em>str</em>.
</p>
<pre>
   &quot;hello&quot;.rpartition(&quot;l&quot;)         #=&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]
   &quot;hello&quot;.rpartition(&quot;x&quot;)         #=&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000837_source')" id="l_M000837_source">show source</a> ]</p>
  <div id="M000837_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.rpartition(sep)            =&gt; [head, sep, tail]
 *  
 *  Searches &lt;i&gt;sep&lt;/i&gt; in the string from the end of the string, and
 *  returns the part before it, the &lt;i&gt;sep&lt;/i&gt;, and the part after it.
 *  If &lt;i&gt;sep&lt;/i&gt; is not found, returns two empty strings and
 *  &lt;i&gt;str&lt;/i&gt;.
 *     
 *     &quot;hello&quot;.rpartition(&quot;l&quot;)         #=&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]
 *     &quot;hello&quot;.rpartition(&quot;x&quot;)         #=&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]
 */

static VALUE
rb_str_rpartition(str, sep)
    VALUE str;
    VALUE sep;
{
    long pos = RSTRING(str)-&gt;len;

    if (TYPE(sep) != T_REGEXP) {
        VALUE tmp;

        tmp = rb_check_string_type(sep);
        if (NIL_P(tmp)) {
            rb_raise(rb_eTypeError, &quot;type mismatch: %s given&quot;,
                     rb_obj_classname(sep));
        }
        sep = get_arg_pat(tmp);
    }
    pos = rb_reg_search(sep, str, pos, 1);
    if (pos &lt; 0) {
        return rb_ary_new3(3, rb_str_new(0,0),rb_str_new(0,0), str);
    }
    sep = rb_reg_nth_match(0, rb_backref_get());
    return rb_ary_new3(3, rb_str_substr(str, 0, pos),
                          sep,
                          rb_str_substr(str, pos+RSTRING(sep)-&gt;len,
                                             RSTRING(str)-&gt;len-pos-RSTRING(sep)-&gt;len));
}
</pre>
  </div>
</div>
</div>
<div id="M000809" class="method">
  <div id="M000809_title" class="title">
    <b>str.rstrip   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with trailing whitespace removed. See also
<tt><a
href="index.html?a=M000808&name=String#lstrip">String#lstrip</a></tt> and
<tt><a href="index.html?a=M000807&name=String#strip">String#strip</a></tt>.
</p>
<pre>
   &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
   &quot;hello&quot;.rstrip       #=&gt; &quot;hello&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000809_source')" id="l_M000809_source">show source</a> ]</p>
  <div id="M000809_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.rstrip   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with trailing whitespace removed. See also
 *  &lt;code&gt;String#lstrip&lt;/code&gt; and &lt;code&gt;String#strip&lt;/code&gt;.
 *     
 *     &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
 *     &quot;hello&quot;.rstrip       #=&gt; &quot;hello&quot;
 */

static VALUE
rb_str_rstrip(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_rstrip_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000816" class="method">
  <div id="M000816_title" class="title">
    <b>str.rstrip!   => self or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Removes trailing whitespace from <em>str</em>, returning <tt>nil</tt> if no
change was made. See also <tt><a
href="index.html?a=M000808&name=String#lstrip">String#lstrip</a>!</tt> and
<tt><a
href="index.html?a=M000807&name=String#strip">String#strip</a>!</tt>.
</p>
<pre>
   &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
   &quot;hello&quot;.rstrip!      #=&gt; nil
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000816_source')" id="l_M000816_source">show source</a> ]</p>
  <div id="M000816_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.rstrip!   =&gt; self or nil
 *  
 *  Removes trailing whitespace from &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if
 *  no change was made. See also &lt;code&gt;String#lstrip!&lt;/code&gt; and
 *  &lt;code&gt;String#strip!&lt;/code&gt;.
 *     
 *     &quot;  hello  &quot;.rstrip   #=&gt; &quot;  hello&quot;
 *     &quot;hello&quot;.rstrip!      #=&gt; nil
 */

static VALUE
rb_str_rstrip_bang(str)
    VALUE str;
{
    char *s, *t, *e;

    s = RSTRING(str)-&gt;ptr;
    if (!s || RSTRING(str)-&gt;len == 0) return Qnil;
    e = t = s + RSTRING(str)-&gt;len;

    /* remove trailing '\0's */
    while (s &lt; t &amp;&amp; t[-1] == '\0') t--;

    /* remove trailing spaces */
    while (s &lt; t &amp;&amp; ISSPACE(*(t-1))) t--;

    if (t &lt; e) {
        rb_str_modify(str);
        RSTRING(str)-&gt;len = t-s;
        RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
        return str;
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000799" class="method">
  <div id="M000799_title" class="title">
    <b>str.scan(pattern)                         => array<br />
str.scan(pattern) {|match, ...| block }   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Both forms iterate through <em>str</em>, matching the pattern (which may be
a <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt> or a
<tt><a href="index.html?a=C00000055&name=String">String</a></tt>). For each
match, a result is generated and either added to the result array or passed
to the block. If the pattern contains no groups, each individual result
consists of the matched string, <tt>$&amp;</tt>. If the pattern contains
groups, each individual result is itself an array containing one entry per
group.
</p>
<pre>
   a = &quot;cruel world&quot;
   a.scan(/\w+/)        #=&gt; [&quot;cruel&quot;, &quot;world&quot;]
   a.scan(/.../)        #=&gt; [&quot;cru&quot;, &quot;el &quot;, &quot;wor&quot;]
   a.scan(/(...)/)      #=&gt; [[&quot;cru&quot;], [&quot;el &quot;], [&quot;wor&quot;]]
   a.scan(/(..)(..)/)   #=&gt; [[&quot;cr&quot;, &quot;ue&quot;], [&quot;l &quot;, &quot;wo&quot;]]
</pre>
<p>
And the block form:
</p>
<pre>
   a.scan(/\w+/) {|w| print &quot;&lt;&lt;#{w}&gt;&gt; &quot; }
   print &quot;\n&quot;
   a.scan(/(.)(.)/) {|x,y| print y, x }
   print &quot;\n&quot;
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   &lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;
   rceu lowlr
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000799_source')" id="l_M000799_source">show source</a> ]</p>
  <div id="M000799_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.scan(pattern)                         =&gt; array
 *     str.scan(pattern) {|match, ...| block }   =&gt; str
 *  
 *  Both forms iterate through &lt;i&gt;str&lt;/i&gt;, matching the pattern (which may be a
 *  &lt;code&gt;Regexp&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt;). For each match, a result is
 *  generated and either added to the result array or passed to the block. If
 *  the pattern contains no groups, each individual result consists of the
 *  matched string, &lt;code&gt;$&amp;&lt;/code&gt;.  If the pattern contains groups, each
 *  individual result is itself an array containing one entry per group.
 *     
 *     a = &quot;cruel world&quot;
 *     a.scan(/\w+/)        #=&gt; [&quot;cruel&quot;, &quot;world&quot;]
 *     a.scan(/.../)        #=&gt; [&quot;cru&quot;, &quot;el &quot;, &quot;wor&quot;]
 *     a.scan(/(...)/)      #=&gt; [[&quot;cru&quot;], [&quot;el &quot;], [&quot;wor&quot;]]
 *     a.scan(/(..)(..)/)   #=&gt; [[&quot;cr&quot;, &quot;ue&quot;], [&quot;l &quot;, &quot;wo&quot;]]
 *     
 *  And the block form:
 *     
 *     a.scan(/\w+/) {|w| print &quot;&lt;&lt;#{w}&gt;&gt; &quot; }
 *     print &quot;\n&quot;
 *     a.scan(/(.)(.)/) {|x,y| print y, x }
 *     print &quot;\n&quot;
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     &lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;
 *     rceu lowlr
 */

static VALUE
rb_str_scan(str, pat)
    VALUE str, pat;
{
    VALUE result;
    long start = 0;
    VALUE match = Qnil;
    char *p = RSTRING(str)-&gt;ptr; long len = RSTRING(str)-&gt;len;

    pat = get_pat(pat, 1);
    if (!rb_block_given_p()) {
        VALUE ary = rb_ary_new();

        while (!NIL_P(result = scan_once(str, pat, &amp;start))) {
            match = rb_backref_get();
            rb_ary_push(ary, result);
        }
        rb_backref_set(match);
        return ary;
    }

    while (!NIL_P(result = scan_once(str, pat, &amp;start))) {
        match = rb_backref_get();
        rb_match_busy(match);
        rb_yield(result);
        str_mod_check(str, p, len);
        rb_backref_set(match); /* restore $~ value */
    }
    rb_backref_set(match);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000856" class="method">
  <div id="M000856_title" class="title">
    <b>scanf</b>(fstr,&amp;b)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000856_source')" id="l_M000856_source">show source</a> ]</p>
  <div id="M000856_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/scanf.rb, line 670</span>
670:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">scanf</span>(<span class="ruby-identifier">fstr</span>,<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>)
671:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">b</span>
672:       <span class="ruby-identifier">block_scanf</span>(<span class="ruby-identifier">fstr</span>,<span class="ruby-operator">&amp;</span><span class="ruby-identifier">b</span>)
673:     <span class="ruby-keyword kw">else</span>
674:       <span class="ruby-identifier">fs</span> = 
675:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">fstr</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">Scanf</span><span class="ruby-operator">::</span><span class="ruby-constant">FormatString</span>
676:           <span class="ruby-identifier">fstr</span> 
677:         <span class="ruby-keyword kw">else</span> 
678:           <span class="ruby-constant">Scanf</span><span class="ruby-operator">::</span><span class="ruby-constant">FormatString</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">fstr</span>)
679:         <span class="ruby-keyword kw">end</span>
680:       <span class="ruby-identifier">fs</span>.<span class="ruby-identifier">match</span>(<span class="ruby-keyword kw">self</span>)
681:     <span class="ruby-keyword kw">end</span>
682:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000859" class="method">
  <div id="M000859_title" class="title">
    <b>str.shellescape => string<br />
</b>
  </div>
  <div class="description">
  <p>
Escapes <tt>str</tt> so that it can be safely used in a Bourne shell
command line. See +Shellwords::shellescape+ for details.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000859_source')" id="l_M000859_source">show source</a> ]</p>
  <div id="M000859_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/shellwords.rb, line 155</span>
155:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">shellescape</span>
156:     <span class="ruby-constant">Shellwords</span>.<span class="ruby-identifier">escape</span>(<span class="ruby-keyword kw">self</span>)
157:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000858" class="method">
  <div id="M000858_title" class="title">
    <b>str.shellsplit => array<br />
</b>
  </div>
  <div class="description">
  <p>
Splits <tt>str</tt> into an array of tokens in the same way the UNIX Bourne
shell does. See +Shellwords::shellsplit+ for details.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000858_source')" id="l_M000858_source">show source</a> ]</p>
  <div id="M000858_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/shellwords.rb, line 144</span>
144:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">shellsplit</span>
145:     <span class="ruby-constant">Shellwords</span>.<span class="ruby-identifier">split</span>(<span class="ruby-keyword kw">self</span>)
146:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000759" class="method">
  <div id="M000759_title" class="title">
    <b>str.length   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the length of <em>str</em>.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000759_source')" id="l_M000759_source">show source</a> ]</p>
  <div id="M000759_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.length   =&gt; integer
 *  
 *  Returns the length of &lt;i&gt;str&lt;/i&gt;.
 */

static VALUE
rb_str_length(str)
    VALUE str;
{
    return LONG2NUM(RSTRING(str)-&gt;len);
}
</pre>
  </div>
</div>
</div>
<div id="M000834" class="method">
  <div id="M000834_title" class="title">
    <b>str[fixnum]                 => fixnum or nil<br />
str[fixnum, fixnum]         => new_str or nil<br />
str[range]                  => new_str or nil<br />
str[regexp]                 => new_str or nil<br />
str[regexp, fixnum]         => new_str or nil<br />
str[other_str]              => new_str or nil<br />
str.slice(fixnum)           => fixnum or nil<br />
str.slice(fixnum, fixnum)   => new_str or nil<br />
str.slice(range)            => new_str or nil<br />
str.slice(regexp)           => new_str or nil<br />
str.slice(regexp, fixnum)   => new_str or nil<br />
str.slice(other_str)        => new_str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Element Reference&#8212;If passed a single <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt>, returns the code
of the character at that position. If passed two <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt> objects, returns
a substring starting at the offset given by the first, and a length given
by the second. If given a range, a substring containing characters at
offsets given by the range is returned. In all three cases, if an offset is
negative, it is counted from the end of <em>str</em>. Returns <tt>nil</tt>
if the initial offset falls outside the string, the length is negative, or
the beginning of the range is greater than the end.
</p>
<p>
If a <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt> is
supplied, the matching portion of <em>str</em> is returned. If a numeric
parameter follows the regular expression, that component of the <tt><a
href="index.html?a=C00000118&name=MatchData">MatchData</a></tt> is returned
instead. If a <tt><a
href="index.html?a=C00000055&name=String">String</a></tt> is given, that
string is returned if it occurs in <em>str</em>. In both cases,
<tt>nil</tt> is returned if there is no match.
</p>
<pre>
   a = &quot;hello there&quot;
   a[1]                   #=&gt; 101
   a[1,3]                 #=&gt; &quot;ell&quot;
   a[1..3]                #=&gt; &quot;ell&quot;
   a[-3,2]                #=&gt; &quot;er&quot;
   a[-4..-2]              #=&gt; &quot;her&quot;
   a[12..-1]              #=&gt; nil
   a[-2..-4]              #=&gt; &quot;&quot;
   a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
   a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
   a[/[aeiou](.)\1/, 2]   #=&gt; nil
   a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
   a[&quot;bye&quot;]               #=&gt; nil
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000834_source')" id="l_M000834_source">show source</a> ]</p>
  <div id="M000834_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str[fixnum]                 =&gt; fixnum or nil
 *     str[fixnum, fixnum]         =&gt; new_str or nil
 *     str[range]                  =&gt; new_str or nil
 *     str[regexp]                 =&gt; new_str or nil
 *     str[regexp, fixnum]         =&gt; new_str or nil
 *     str[other_str]              =&gt; new_str or nil
 *     str.slice(fixnum)           =&gt; fixnum or nil
 *     str.slice(fixnum, fixnum)   =&gt; new_str or nil
 *     str.slice(range)            =&gt; new_str or nil
 *     str.slice(regexp)           =&gt; new_str or nil
 *     str.slice(regexp, fixnum)   =&gt; new_str or nil
 *     str.slice(other_str)        =&gt; new_str or nil
 *  
 *  Element Reference---If passed a single &lt;code&gt;Fixnum&lt;/code&gt;, returns the code
 *  of the character at that position. If passed two &lt;code&gt;Fixnum&lt;/code&gt;
 *  objects, returns a substring starting at the offset given by the first, and
 *  a length given by the second. If given a range, a substring containing
 *  characters at offsets given by the range is returned. In all three cases, if
 *  an offset is negative, it is counted from the end of &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if the initial offset falls outside the string, the length
 *  is negative, or the beginning of the range is greater than the end.
 *     
 *  If a &lt;code&gt;Regexp&lt;/code&gt; is supplied, the matching portion of &lt;i&gt;str&lt;/i&gt; is
 *  returned. If a numeric parameter follows the regular expression, that
 *  component of the &lt;code&gt;MatchData&lt;/code&gt; is returned instead. If a
 *  &lt;code&gt;String&lt;/code&gt; is given, that string is returned if it occurs in
 *  &lt;i&gt;str&lt;/i&gt;. In both cases, &lt;code&gt;nil&lt;/code&gt; is returned if there is no
 *  match.
 *     
 *     a = &quot;hello there&quot;
 *     a[1]                   #=&gt; 101
 *     a[1,3]                 #=&gt; &quot;ell&quot;
 *     a[1..3]                #=&gt; &quot;ell&quot;
 *     a[-3,2]                #=&gt; &quot;er&quot;
 *     a[-4..-2]              #=&gt; &quot;her&quot;
 *     a[12..-1]              #=&gt; nil
 *     a[-2..-4]              #=&gt; &quot;&quot;
 *     a[/[aeiou](.)\1/]      #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 0]   #=&gt; &quot;ell&quot;
 *     a[/[aeiou](.)\1/, 1]   #=&gt; &quot;l&quot;
 *     a[/[aeiou](.)\1/, 2]   #=&gt; nil
 *     a[&quot;lo&quot;]                #=&gt; &quot;lo&quot;
 *     a[&quot;bye&quot;]               #=&gt; nil
 */

static VALUE
rb_str_aref_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    if (argc == 2) {
        if (TYPE(argv[0]) == T_REGEXP) {
            return rb_str_subpat(str, argv[0], NUM2INT(argv[1]));
        }
        return rb_str_substr(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]));
    }
    if (argc != 1) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1)&quot;, argc);
    }
    return rb_str_aref(str, argv[0]);
}
</pre>
  </div>
</div>
</div>
<div id="M000835" class="method">
  <div id="M000835_title" class="title">
    <b>str.slice!(fixnum)           => fixnum or nil<br />
str.slice!(fixnum, fixnum)   => new_str or nil<br />
str.slice!(range)            => new_str or nil<br />
str.slice!(regexp)           => new_str or nil<br />
str.slice!(other_str)        => new_str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Deletes the specified portion from <em>str</em>, and returns the portion
deleted. The forms that take a <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt> will raise an
<tt><a href="index.html?a=C00000084&name=IndexError">IndexError</a></tt> if
the value is out of range; the <tt><a
href="index.html?a=C00000051&name=Range">Range</a></tt> form will raise a
<tt><a href="index.html?a=C00000210&name=RangeError">RangeError</a></tt>,
and the <tt><a href="index.html?a=C00000110&name=Regexp">Regexp</a></tt>
and <tt><a href="index.html?a=C00000055&name=String">String</a></tt> forms
will silently ignore the assignment.
</p>
<pre>
   string = &quot;this is a string&quot;
   string.slice!(2)        #=&gt; 105
   string.slice!(3..6)     #=&gt; &quot; is &quot;
   string.slice!(/s.*t/)   #=&gt; &quot;sa st&quot;
   string.slice!(&quot;r&quot;)      #=&gt; &quot;r&quot;
   string                  #=&gt; &quot;thing&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000835_source')" id="l_M000835_source">show source</a> ]</p>
  <div id="M000835_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.slice!(fixnum)           =&gt; fixnum or nil
 *     str.slice!(fixnum, fixnum)   =&gt; new_str or nil
 *     str.slice!(range)            =&gt; new_str or nil
 *     str.slice!(regexp)           =&gt; new_str or nil
 *     str.slice!(other_str)        =&gt; new_str or nil
 *  
 *  Deletes the specified portion from &lt;i&gt;str&lt;/i&gt;, and returns the portion
 *  deleted. The forms that take a &lt;code&gt;Fixnum&lt;/code&gt; will raise an
 *  &lt;code&gt;IndexError&lt;/code&gt; if the value is out of range; the &lt;code&gt;Range&lt;/code&gt;
 *  form will raise a &lt;code&gt;RangeError&lt;/code&gt;, and the &lt;code&gt;Regexp&lt;/code&gt; and
 *  &lt;code&gt;String&lt;/code&gt; forms will silently ignore the assignment.
 *     
 *     string = &quot;this is a string&quot;
 *     string.slice!(2)        #=&gt; 105
 *     string.slice!(3..6)     #=&gt; &quot; is &quot;
 *     string.slice!(/s.*t/)   #=&gt; &quot;sa st&quot;
 *     string.slice!(&quot;r&quot;)      #=&gt; &quot;r&quot;
 *     string                  #=&gt; &quot;thing&quot;
 */

static VALUE
rb_str_slice_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE result;
    VALUE buf[3];
    int i;

    if (argc &lt; 1 || 2 &lt; argc) {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 1)&quot;, argc);
    }
    for (i=0; i&lt;argc; i++) {
        buf[i] = argv[i];
    }
    buf[i] = rb_str_new(0,0);
    result = rb_str_aref_m(argc, buf, str);
    if (!NIL_P(result)) {
        rb_str_aset_m(argc+1, buf, str);
    }
    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M000788" class="method">
  <div id="M000788_title" class="title">
    <b>str.split(pattern=$;, [limit])   => anArray<br />
</b>
  </div>
  <div class="description">
  <p>
Divides <em>str</em> into substrings based on a delimiter, returning an
array of these substrings.
</p>
<p>
If <em>pattern</em> is a <tt><a
href="index.html?a=C00000055&name=String">String</a></tt>, then its
contents are used as the delimiter when splitting <em>str</em>. If
<em>pattern</em> is a single space, <em>str</em> is split on whitespace,
with leading whitespace and runs of contiguous whitespace characters
ignored.
</p>
<p>
If <em>pattern</em> is a <tt><a
href="index.html?a=C00000110&name=Regexp">Regexp</a></tt>, <em>str</em> is
divided where the pattern matches. Whenever the pattern matches a
zero-length string, <em>str</em> is split into individual characters.
</p>
<p>
If <em>pattern</em> is omitted, the value of <tt>$;</tt> is used. If
<tt>$;</tt> is <tt>nil</tt> (which is the default), <em>str</em> is split
on whitespace as if ` &#8217; were specified.
</p>
<p>
If the <em>limit</em> parameter is omitted, trailing null fields are
suppressed. If <em>limit</em> is a positive number, at most that number of
fields will be returned (if <em>limit</em> is <tt>1</tt>, the entire string
is returned as the only entry in an array). If negative, there is no limit
to the number of fields returned, and trailing null fields are not
suppressed.
</p>
<pre>
   &quot; now's  the time&quot;.split        #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
   &quot; now's  the time&quot;.split(' ')   #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
   &quot; now's  the time&quot;.split(/ /)   #=&gt; [&quot;&quot;, &quot;now's&quot;, &quot;&quot;, &quot;the&quot;, &quot;time&quot;]
   &quot;1, 2.34,56, 7&quot;.split(%r{,\s*}) #=&gt; [&quot;1&quot;, &quot;2.34&quot;, &quot;56&quot;, &quot;7&quot;]
   &quot;hello&quot;.split(//)               #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
   &quot;hello&quot;.split(//, 3)            #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;llo&quot;]
   &quot;hi mom&quot;.split(%r{\s*})         #=&gt; [&quot;h&quot;, &quot;i&quot;, &quot;m&quot;, &quot;o&quot;, &quot;m&quot;]

   &quot;mellow yellow&quot;.split(&quot;ello&quot;)   #=&gt; [&quot;m&quot;, &quot;w y&quot;, &quot;w&quot;]
   &quot;1,2,,3,4,,&quot;.split(',')         #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;]
   &quot;1,2,,3,4,,&quot;.split(',', 4)      #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3,4,,&quot;]
   &quot;1,2,,3,4,,&quot;.split(',', -4)     #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;]
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000788_source')" id="l_M000788_source">show source</a> ]</p>
  <div id="M000788_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.split(pattern=$;, [limit])   =&gt; anArray
 *  
 *  Divides &lt;i&gt;str&lt;/i&gt; into substrings based on a delimiter, returning an array
 *  of these substrings.
 *     
 *  If &lt;i&gt;pattern&lt;/i&gt; is a &lt;code&gt;String&lt;/code&gt;, then its contents are used as
 *  the delimiter when splitting &lt;i&gt;str&lt;/i&gt;. If &lt;i&gt;pattern&lt;/i&gt; is a single
 *  space, &lt;i&gt;str&lt;/i&gt; is split on whitespace, with leading whitespace and runs
 *  of contiguous whitespace characters ignored.
 *     
 *  If &lt;i&gt;pattern&lt;/i&gt; is a &lt;code&gt;Regexp&lt;/code&gt;, &lt;i&gt;str&lt;/i&gt; is divided where the
 *  pattern matches. Whenever the pattern matches a zero-length string,
 *  &lt;i&gt;str&lt;/i&gt; is split into individual characters.
 *     
 *  If &lt;i&gt;pattern&lt;/i&gt; is omitted, the value of &lt;code&gt;$;&lt;/code&gt; is used.  If
 *  &lt;code&gt;$;&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; (which is the default), &lt;i&gt;str&lt;/i&gt; is
 *  split on whitespace as if ` ' were specified.
 *     
 *  If the &lt;i&gt;limit&lt;/i&gt; parameter is omitted, trailing null fields are
 *  suppressed. If &lt;i&gt;limit&lt;/i&gt; is a positive number, at most that number of
 *  fields will be returned (if &lt;i&gt;limit&lt;/i&gt; is &lt;code&gt;1&lt;/code&gt;, the entire
 *  string is returned as the only entry in an array). If negative, there is no
 *  limit to the number of fields returned, and trailing null fields are not
 *  suppressed.
 *     
 *     &quot; now's  the time&quot;.split        #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
 *     &quot; now's  the time&quot;.split(' ')   #=&gt; [&quot;now's&quot;, &quot;the&quot;, &quot;time&quot;]
 *     &quot; now's  the time&quot;.split(/ /)   #=&gt; [&quot;&quot;, &quot;now's&quot;, &quot;&quot;, &quot;the&quot;, &quot;time&quot;]
 *     &quot;1, 2.34,56, 7&quot;.split(%r{,\s*}) #=&gt; [&quot;1&quot;, &quot;2.34&quot;, &quot;56&quot;, &quot;7&quot;]
 *     &quot;hello&quot;.split(//)               #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
 *     &quot;hello&quot;.split(//, 3)            #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;llo&quot;]
 *     &quot;hi mom&quot;.split(%r{\s*})         #=&gt; [&quot;h&quot;, &quot;i&quot;, &quot;m&quot;, &quot;o&quot;, &quot;m&quot;]
 *     
 *     &quot;mellow yellow&quot;.split(&quot;ello&quot;)   #=&gt; [&quot;m&quot;, &quot;w y&quot;, &quot;w&quot;]
 *     &quot;1,2,,3,4,,&quot;.split(',')         #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;]
 *     &quot;1,2,,3,4,,&quot;.split(',', 4)      #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3,4,,&quot;]
 *     &quot;1,2,,3,4,,&quot;.split(',', -4)     #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;]
 */

static VALUE
rb_str_split_m(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE spat;
    VALUE limit;
    int awk_split = Qfalse;
    long beg, end, i = 0;
    int lim = 0;
    VALUE result, tmp;

    if (rb_scan_args(argc, argv, &quot;02&quot;, &amp;spat, &amp;limit) == 2) {
        lim = NUM2INT(limit);
        if (lim &lt;= 0) limit = Qnil;
        else if (lim == 1) {
            if (RSTRING(str)-&gt;len == 0)
                return rb_ary_new2(0);
            return rb_ary_new3(1, str);
        }
        i = 1;
    }

    if (NIL_P(spat)) {
        if (!NIL_P(rb_fs)) {
            spat = rb_fs;
            goto fs_set;
        }
        awk_split = Qtrue;
    }
    else {
      fs_set:
        if (TYPE(spat) == T_STRING &amp;&amp; RSTRING(spat)-&gt;len == 1) {
            if (RSTRING(spat)-&gt;ptr[0] == ' ') {
                awk_split = Qtrue;
            }
            else {
                spat = rb_reg_regcomp(rb_reg_quote(spat));
            }
        }
        else {
            spat = get_pat(spat, 1);
        }
    }

    result = rb_ary_new();
    beg = 0;
    if (awk_split) {
        char *ptr = RSTRING(str)-&gt;ptr;
        long len = RSTRING(str)-&gt;len;
        char *eptr = ptr + len;
        int skip = 1;

        for (end = beg = 0; ptr&lt;eptr; ptr++) {
            if (skip) {
                if (ISSPACE(*ptr)) {
                    beg++;
                }
                else {
                    end = beg+1;
                    skip = 0;
                    if (!NIL_P(limit) &amp;&amp; lim &lt;= i) break;
                }
            }
            else {
                if (ISSPACE(*ptr)) {
                    rb_ary_push(result, rb_str_substr(str, beg, end-beg));
                    skip = 1;
                    beg = end + 1;
                    if (!NIL_P(limit)) ++i;
                }
                else {
                    end++;
                }
            }
        }
    }
    else {
        long start = beg;
        long idx;
        int last_null = 0;
        struct re_registers *regs;

        while ((end = rb_reg_search(spat, str, start, 0)) &gt;= 0) {
            regs = RMATCH(rb_backref_get())-&gt;regs;
            if (start == end &amp;&amp; BEG(0) == END(0)) {
                if (!RSTRING(str)-&gt;ptr) {
                    rb_ary_push(result, rb_str_new(&quot;&quot;, 0));
                    break;
                }
                else if (last_null == 1) {
                    rb_ary_push(result, rb_str_substr(str, beg, mbclen2(RSTRING(str)-&gt;ptr[beg],spat)));
                    beg = start;
                }
                else {
                    start += mbclen2(RSTRING(str)-&gt;ptr[start],spat);
                    last_null = 1;
                    continue;
                }
            }
            else {
                rb_ary_push(result, rb_str_substr(str, beg, end-beg));
                beg = start = END(0);
            }
            last_null = 0;

            for (idx=1; idx &lt; regs-&gt;num_regs; idx++) {
                if (BEG(idx) == -1) continue;
                if (BEG(idx) == END(idx))
                    tmp = rb_str_new5(str, 0, 0);
                else
                    tmp = rb_str_substr(str, BEG(idx), END(idx)-BEG(idx));
                rb_ary_push(result, tmp);
            }
            if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
        }
    }
    if (RSTRING(str)-&gt;len &gt; 0 &amp;&amp; (!NIL_P(limit) || RSTRING(str)-&gt;len &gt; beg || lim &lt; 0)) {
        if (RSTRING(str)-&gt;len == beg)
            tmp = rb_str_new5(str, 0, 0);
        else
            tmp = rb_str_substr(str, beg, RSTRING(str)-&gt;len-beg);
        rb_ary_push(result, tmp);
    }
    if (NIL_P(limit) &amp;&amp; lim == 0) {
        while (RARRAY(result)-&gt;len &gt; 0 &amp;&amp;
               RSTRING(RARRAY(result)-&gt;ptr[RARRAY(result)-&gt;len-1])-&gt;len == 0)
            rb_ary_pop(result);
    }

    return result;
}
</pre>
  </div>
</div>
</div>
<div id="M000847" class="method">
  <div id="M000847_title" class="title">
    <b>squeeze</b>(del=nil)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000847_source')" id="l_M000847_source">show source</a> ]</p>
  <div id="M000847_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 171</span>
171:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">squeeze</span>(<span class="ruby-identifier">del</span>=<span class="ruby-keyword kw">nil</span>)
172:     (<span class="ruby-identifier">str</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">dup</span>).<span class="ruby-identifier">squeeze!</span>(<span class="ruby-identifier">del</span>) <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">str</span>
173:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000820" class="method">
  <div id="M000820_title" class="title">
    <b>str.squeeze([other_str]*)    => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Builds a set of characters from the <em>other_str</em> parameter(s) using
the procedure described for <tt><a
href="index.html?a=M000821&name=String#count">String#count</a></tt>.
Returns a new string where runs of the same character that occur in this
set are replaced by a single character. If no arguments are given, all runs
of identical characters are replaced by a single character.
</p>
<pre>
   &quot;yellow moon&quot;.squeeze                  #=&gt; &quot;yelow mon&quot;
   &quot;  now   is  the&quot;.squeeze(&quot; &quot;)         #=&gt; &quot; now is the&quot;
   &quot;putters shoot balls&quot;.squeeze(&quot;m-z&quot;)   #=&gt; &quot;puters shot balls&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000820_source')" id="l_M000820_source">show source</a> ]</p>
  <div id="M000820_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.squeeze([other_str]*)    =&gt; new_str
 *  
 *  Builds a set of characters from the &lt;i&gt;other_str&lt;/i&gt; parameter(s) using the
 *  procedure described for &lt;code&gt;String#count&lt;/code&gt;. Returns a new string
 *  where runs of the same character that occur in this set are replaced by a
 *  single character. If no arguments are given, all runs of identical
 *  characters are replaced by a single character.
 *     
 *     &quot;yellow moon&quot;.squeeze                  #=&gt; &quot;yelow mon&quot;
 *     &quot;  now   is  the&quot;.squeeze(&quot; &quot;)         #=&gt; &quot; now is the&quot;
 *     &quot;putters shoot balls&quot;.squeeze(&quot;m-z&quot;)   #=&gt; &quot;puters shot balls&quot;
 */

static VALUE
rb_str_squeeze(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_squeeze_bang(argc, argv, str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000846" class="method">
  <div id="M000846_title" class="title">
    <b>squeeze!</b>(del=nil)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000846_source')" id="l_M000846_source">show source</a> ]</p>
  <div id="M000846_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 160</span>
160:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">squeeze!</span>(<span class="ruby-identifier">del</span>=<span class="ruby-keyword kw">nil</span>)
161:     <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">del</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;&quot;</span>
162:     <span class="ruby-identifier">pattern</span> =
163:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">del</span>
164:         <span class="ruby-constant">SqueezePatternCache</span>[<span class="ruby-identifier">del</span>] <span class="ruby-operator">||=</span> <span class="ruby-node">/([#{_regex_quote(del)}])\1+/</span>
165:       <span class="ruby-keyword kw">else</span>
166:         <span class="ruby-regexp re">/(.|\n)\1+/</span>
167:       <span class="ruby-keyword kw">end</span>
168:     <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-value str">'\1'</span>)
169:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000825" class="method">
  <div id="M000825_title" class="title">
    <b>str.squeeze!([other_str]*)   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Squeezes <em>str</em> in place, returning either <em>str</em>, or
<tt>nil</tt> if no changes were made.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000825_source')" id="l_M000825_source">show source</a> ]</p>
  <div id="M000825_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.squeeze!([other_str]*)   =&gt; str or nil
 *  
 *  Squeezes &lt;i&gt;str&lt;/i&gt; in place, returning either &lt;i&gt;str&lt;/i&gt;, or
 *  &lt;code&gt;nil&lt;/code&gt; if no changes were made.
 */

static VALUE
rb_str_squeeze_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    char squeez[256];
    char *s, *send, *t;
    int c, save, modify = 0;
    int init = 1;
    int i;

    if (argc == 0) {
        for (i=0; i&lt;256; i++) {
            squeez[i] = 1;
        }
    }
    else {
        for (i=0; i&lt;argc; i++) {
            VALUE s = argv[i];

            StringValue(s);
            tr_setup_table(s, squeez, init);
            init = 0;
        }
    }

    rb_str_modify(str);
    s = t = RSTRING(str)-&gt;ptr;
    if (!s || RSTRING(str)-&gt;len == 0) return Qnil;
    send = s + RSTRING(str)-&gt;len;
    save = -1;
    while (s &lt; send) {
        c = *s++ &amp; 0xff;
        if (c != save || !squeez[c]) {
            *t++ = save = c;
        }
    }
    *t = '\0';
    if (t - RSTRING(str)-&gt;ptr != RSTRING(str)-&gt;len) {
        RSTRING(str)-&gt;len = t - RSTRING(str)-&gt;ptr;
        modify = 1;
    }

    if (modify) return str;
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000797" class="method">
  <div id="M000797_title" class="title">
    <b>str.start_with?([prefix]+)   => true or false<br />
</b>
  </div>
  <div class="description">
  <p>
Returns true if <em>str</em> starts with the prefix given.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000797_source')" id="l_M000797_source">show source</a> ]</p>
  <div id="M000797_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.start_with?([prefix]+)   =&gt; true or false
 *  
 *  Returns true if &lt;i&gt;str&lt;/i&gt; starts with the prefix given.
 */

static VALUE
rb_str_start_with(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    int i;
    VALUE pat;

    for (i=0; i&lt;argc; i++) {
        VALUE prefix = rb_check_string_type(argv[i]);
        if (NIL_P(prefix)) continue;
        if (RSTRING(str)-&gt;len &lt; RSTRING(prefix)-&gt;len) continue;
        pat = get_arg_pat(prefix);
        if (rb_reg_search(pat, str, 0, 1) &gt;= 0)
            return Qtrue;
    }
    return Qfalse;
}
</pre>
  </div>
</div>
</div>
<div id="M000807" class="method">
  <div id="M000807_title" class="title">
    <b>str.strip   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with leading and trailing whitespace
removed.
</p>
<pre>
   &quot;    hello    &quot;.strip   #=&gt; &quot;hello&quot;
   &quot;\tgoodbye\r\n&quot;.strip   #=&gt; &quot;goodbye&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000807_source')" id="l_M000807_source">show source</a> ]</p>
  <div id="M000807_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.strip   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with leading and trailing whitespace removed.
 *     
 *     &quot;    hello    &quot;.strip   #=&gt; &quot;hello&quot;
 *     &quot;\tgoodbye\r\n&quot;.strip   #=&gt; &quot;goodbye&quot;
 */

static VALUE
rb_str_strip(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_strip_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000814" class="method">
  <div id="M000814_title" class="title">
    <b>str.strip!   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Removes leading and trailing whitespace from <em>str</em>. Returns
<tt>nil</tt> if <em>str</em> was not altered.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000814_source')" id="l_M000814_source">show source</a> ]</p>
  <div id="M000814_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.strip!   =&gt; str or nil
 *  
 *  Removes leading and trailing whitespace from &lt;i&gt;str&lt;/i&gt;. Returns
 *  &lt;code&gt;nil&lt;/code&gt; if &lt;i&gt;str&lt;/i&gt; was not altered.
 */

static VALUE
rb_str_strip_bang(str)
    VALUE str;
{
    VALUE l = rb_str_lstrip_bang(str);
    VALUE r = rb_str_rstrip_bang(str);

    if (NIL_P(l) &amp;&amp; NIL_P(r)) return Qnil;
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000803" class="method">
  <div id="M000803_title" class="title">
    <b>str.sub(pattern, replacement)         => new_str<br />
str.sub(pattern) {|match| block }     => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with the <em>first</em> occurrence of
<em>pattern</em> replaced with either <em>replacement</em> or the value of
the block. The <em>pattern</em> will typically be a <tt><a
href="index.html?a=C00000110&name=Regexp">Regexp</a></tt>; if it is a
<tt><a href="index.html?a=C00000055&name=String">String</a></tt> then no
regular expression metacharacters will be interpreted (that is
<tt>/\d/</tt> will match a digit, but <tt>&#8217;\d&#8217;</tt> will match
a backslash followed by a &#8216;d&#8217;).
</p>
<p>
If the method call specifies <em>replacement</em>, special variables such
as <tt>$&amp;</tt> will not be useful, as substitution into the string
occurs before the pattern match starts. However, the sequences <tt>\1</tt>,
<tt>\2</tt>, etc., may be used.
</p>
<p>
In the block form, the current match string is passed in as a parameter,
and variables such as <tt>$1</tt>, <tt>$2</tt>, <tt>$`</tt>,
<tt>$&amp;</tt>, and <tt>$&#8217;</tt> will be set appropriately. The value
returned by the block will be substituted for the match on each call.
</p>
<p>
The result inherits any tainting in the original string or any supplied
replacement string.
</p>
<pre>
   &quot;hello&quot;.sub(/[aeiou]/, '*')               #=&gt; &quot;h*llo&quot;
   &quot;hello&quot;.sub(/([aeiou])/, '&lt;\1&gt;')          #=&gt; &quot;h&lt;e&gt;llo&quot;
   &quot;hello&quot;.sub(/./) {|s| s[0].to_s + ' ' }   #=&gt; &quot;104 ello&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000803_source')" id="l_M000803_source">show source</a> ]</p>
  <div id="M000803_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.sub(pattern, replacement)         =&gt; new_str
 *     str.sub(pattern) {|match| block }     =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with the &lt;em&gt;first&lt;/em&gt; occurrence of
 *  &lt;i&gt;pattern&lt;/i&gt; replaced with either &lt;i&gt;replacement&lt;/i&gt; or the value of the
 *  block. The &lt;i&gt;pattern&lt;/i&gt; will typically be a &lt;code&gt;Regexp&lt;/code&gt;; if it is
 *  a &lt;code&gt;String&lt;/code&gt; then no regular expression metacharacters will be
 *  interpreted (that is &lt;code&gt;/\d/&lt;/code&gt; will match a digit, but
 *  &lt;code&gt;'\d'&lt;/code&gt; will match a backslash followed by a 'd').
 *     
 *  If the method call specifies &lt;i&gt;replacement&lt;/i&gt;, special variables such as
 *  &lt;code&gt;$&amp;&lt;/code&gt; will not be useful, as substitution into the string occurs
 *  before the pattern match starts. However, the sequences &lt;code&gt;\1&lt;/code&gt;,
 *  &lt;code&gt;\2&lt;/code&gt;, etc., may be used.
 *     
 *  In the block form, the current match string is passed in as a parameter, and
 *  variables such as &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$`&lt;/code&gt;,
 *  &lt;code&gt;$&amp;&lt;/code&gt;, and &lt;code&gt;$'&lt;/code&gt; will be set appropriately. The value
 *  returned by the block will be substituted for the match on each call.
 *     
 *  The result inherits any tainting in the original string or any supplied
 *  replacement string.
 *     
 *     &quot;hello&quot;.sub(/[aeiou]/, '*')               #=&gt; &quot;h*llo&quot;
 *     &quot;hello&quot;.sub(/([aeiou])/, '&lt;\1&gt;')          #=&gt; &quot;h&lt;e&gt;llo&quot;
 *     &quot;hello&quot;.sub(/./) {|s| s[0].to_s + ' ' }   #=&gt; &quot;104 ello&quot;
 */

static VALUE
rb_str_sub(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_sub_bang(argc, argv, str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000810" class="method">
  <div id="M000810_title" class="title">
    <b>str.sub!(pattern, replacement)          => str or nil<br />
str.sub!(pattern) {|match| block }      => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Performs the substitutions of <tt><a
href="index.html?a=M000803&name=String#sub">String#sub</a></tt> in place,
returning <em>str</em>, or <tt>nil</tt> if no substitutions were performed.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000810_source')" id="l_M000810_source">show source</a> ]</p>
  <div id="M000810_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.sub!(pattern, replacement)          =&gt; str or nil
 *     str.sub!(pattern) {|match| block }      =&gt; str or nil
 *  
 *  Performs the substitutions of &lt;code&gt;String#sub&lt;/code&gt; in place,
 *  returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no substitutions were
 *  performed.
 */

static VALUE
rb_str_sub_bang(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE pat, repl, match;
    struct re_registers *regs;
    int iter = 0;
    int tainted = 0;
    long plen;

    if (argc == 1 &amp;&amp; rb_block_given_p()) {
        iter = 1;
    }
    else if (argc == 2) {
        repl = argv[1];
        StringValue(repl);
        if (OBJ_TAINTED(repl)) tainted = 1;
    }
    else {
        rb_raise(rb_eArgError, &quot;wrong number of arguments (%d for 2)&quot;, argc);
    }

    pat = get_pat(argv[0], 1);
    if (rb_reg_search(pat, str, 0, 0) &gt;= 0) {
        match = rb_backref_get();
        regs = RMATCH(match)-&gt;regs;

        if (iter) {
            char *p = RSTRING(str)-&gt;ptr; long len = RSTRING(str)-&gt;len;

            rb_match_busy(match);
            repl = rb_obj_as_string(rb_yield(rb_reg_nth_match(0, match)));
            str_mod_check(str, p, len);
            str_frozen_check(str);
            rb_backref_set(match);
        }
        else {
            repl = rb_reg_regsub(repl, str, regs);
        }
        rb_str_modify(str);
        if (OBJ_TAINTED(repl)) tainted = 1;
        plen = END(0) - BEG(0);
        if (RSTRING(repl)-&gt;len &gt; plen) {
            RESIZE_CAPA(str, RSTRING(str)-&gt;len + RSTRING(repl)-&gt;len - plen);
        }
        if (RSTRING(repl)-&gt;len != plen) {
            memmove(RSTRING(str)-&gt;ptr + BEG(0) + RSTRING(repl)-&gt;len,
                    RSTRING(str)-&gt;ptr + BEG(0) + plen,
                    RSTRING(str)-&gt;len - BEG(0) - plen);
        }
        memcpy(RSTRING(str)-&gt;ptr + BEG(0),
               RSTRING(repl)-&gt;ptr, RSTRING(repl)-&gt;len);
        RSTRING(str)-&gt;len += RSTRING(repl)-&gt;len - plen;
        RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
        if (tainted) OBJ_TAINT(str);

        return str;
    }
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000764" class="method">
  <div id="M000764_title" class="title">
    <b>str.succ   => new_str<br />
str.next   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the successor to <em>str</em>. The successor is calculated by
incrementing characters starting from the rightmost alphanumeric (or the
rightmost character if there are no alphanumerics) in the string.
Incrementing a digit always results in another digit, and incrementing a
letter results in another letter of the same case. Incrementing
nonalphanumerics uses the underlying character set&#8217;s collating
sequence.
</p>
<p>
If the increment generates a ``carry,&#8217;&#8217; the character to the
left of it is incremented. This process repeats until there is no carry,
adding an additional character if necessary.
</p>
<pre>
   &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
   &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
   &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
   &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
   &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
   &quot;***&quot;.succ         #=&gt; &quot;**+&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000764_source')" id="l_M000764_source">show source</a> ]</p>
  <div id="M000764_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.succ   =&gt; new_str
 *     str.next   =&gt; new_str
 *  
 *  Returns the successor to &lt;i&gt;str&lt;/i&gt;. The successor is calculated by
 *  incrementing characters starting from the rightmost alphanumeric (or
 *  the rightmost character if there are no alphanumerics) in the
 *  string. Incrementing a digit always results in another digit, and
 *  incrementing a letter results in another letter of the same case.
 *  Incrementing nonalphanumerics uses the underlying character set's
 *  collating sequence.
 *     
 *  If the increment generates a ``carry,'' the character to the left of
 *  it is incremented. This process repeats until there is no carry,
 *  adding an additional character if necessary.
 *     
 *     &quot;abcd&quot;.succ        #=&gt; &quot;abce&quot;
 *     &quot;THX1138&quot;.succ     #=&gt; &quot;THX1139&quot;
 *     &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   #=&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;
 *     &quot;1999zzz&quot;.succ     #=&gt; &quot;2000aaa&quot;
 *     &quot;ZZZ9999&quot;.succ     #=&gt; &quot;AAAA0000&quot;
 *     &quot;***&quot;.succ         #=&gt; &quot;**+&quot;
 */

static VALUE
rb_str_succ(orig)
    VALUE orig;
{
    VALUE str;
    char *sbeg, *s;
    int c = -1;
    long n = 0;

    str = rb_str_new5(orig, RSTRING(orig)-&gt;ptr, RSTRING(orig)-&gt;len);
    OBJ_INFECT(str, orig);
    if (RSTRING(str)-&gt;len == 0) return str;

    sbeg = RSTRING(str)-&gt;ptr; s = sbeg + RSTRING(str)-&gt;len - 1;

    while (sbeg &lt;= s) {
        if (ISALNUM(*s)) {
            if ((c = succ_char(s)) == 0) break;
            n = s - sbeg;
        }
        s--;
    }
    if (c == -1) {              /* str contains no alnum */
        sbeg = RSTRING(str)-&gt;ptr; s = sbeg + RSTRING(str)-&gt;len - 1;
        c = '\001';
        while (sbeg &lt;= s) {
            if ((*s += 1) != 0) break;
            s--;
        }
    }
    if (s &lt; sbeg) {
        RESIZE_CAPA(str, RSTRING(str)-&gt;len + 1);
        s = RSTRING(str)-&gt;ptr + n;
        memmove(s+1, s, RSTRING(str)-&gt;len - n);
        *s = c;
        RSTRING(str)-&gt;len += 1;
        RSTRING(str)-&gt;ptr[RSTRING(str)-&gt;len] = '\0';
    }

    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000841" class="method">
  <div id="M000841_title" class="title">
    <b>succ</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000841_source')" id="l_M000841_source">show source</a> ]</p>
  <div id="M000841_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 92</span>
92:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">succ</span>
93:     <span class="ruby-identifier">str</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">dup</span>
94:     <span class="ruby-identifier">str</span>.<span class="ruby-identifier">succ!</span> <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">str</span>
95:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000765" class="method">
  <div id="M000765_title" class="title">
    <b>str.succ!   => str<br />
str.next!   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Equivalent to <tt><a
href="index.html?a=M000764&name=String#succ">String#succ</a></tt>, but
modifies the receiver in place.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000765_source')" id="l_M000765_source">show source</a> ]</p>
  <div id="M000765_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.succ!   =&gt; str
 *     str.next!   =&gt; str
 *  
 *  Equivalent to &lt;code&gt;String#succ&lt;/code&gt;, but modifies the receiver in
 *  place.
 */

static VALUE
rb_str_succ_bang(str)
    VALUE str;
{
    rb_str_shared_replace(str, rb_str_succ(str));

    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000840" class="method">
  <div id="M000840_title" class="title">
    <b>succ!</b>()
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000840_source')" id="l_M000840_source">show source</a> ]</p>
  <div id="M000840_source" class="dyn-source">
<pre>
    <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 78</span>
78:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">succ!</span>
79:     <span class="ruby-identifier">reg</span> = <span class="ruby-identifier">end_regexp</span>
80:     <span class="ruby-keyword kw">if</span>  <span class="ruby-identifier">$KCODE</span> <span class="ruby-operator">!=</span> <span class="ruby-value str">'NONE'</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-keyword kw">self</span> <span class="ruby-operator">=~</span> <span class="ruby-identifier">reg</span>
81:       <span class="ruby-identifier">succ_table</span> = <span class="ruby-constant">SUCC</span>[<span class="ruby-identifier">$KCODE</span>[<span class="ruby-value">0</span>,<span class="ruby-value">1</span>].<span class="ruby-identifier">downcase</span>]
82:       <span class="ruby-keyword kw">begin</span>
83:         <span class="ruby-keyword kw">self</span>[<span class="ruby-value">-1</span>] <span class="ruby-operator">+=</span> <span class="ruby-identifier">succ_table</span>[<span class="ruby-keyword kw">self</span>[<span class="ruby-value">-1</span>]]
84:         <span class="ruby-keyword kw">self</span>[<span class="ruby-value">-2</span>] <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">self</span>[<span class="ruby-value">-1</span>] <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
85:       <span class="ruby-keyword kw">end</span> <span class="ruby-keyword kw">while</span> <span class="ruby-keyword kw">self</span> <span class="ruby-operator">!~</span> <span class="ruby-identifier">reg</span>
86:       <span class="ruby-keyword kw">self</span>
87:     <span class="ruby-keyword kw">else</span>
88:       <span class="ruby-identifier">original_succ!</span>
89:     <span class="ruby-keyword kw">end</span>
90:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000833" class="method">
  <div id="M000833_title" class="title">
    <b>str.sum(n=16)   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a basic <em>n</em>-bit checksum of the characters in <em>str</em>,
where <em>n</em> is the optional <tt><a
href="index.html?a=C00000089&name=Fixnum">Fixnum</a></tt> parameter,
defaulting to 16. The result is simply the sum of the binary value of each
character in <em>str</em> modulo <tt>2n - 1</tt>. This is not a
particularly good checksum.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000833_source')" id="l_M000833_source">show source</a> ]</p>
  <div id="M000833_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.sum(n=16)   =&gt; integer
 *  
 *  Returns a basic &lt;em&gt;n&lt;/em&gt;-bit checksum of the characters in &lt;i&gt;str&lt;/i&gt;,
 *  where &lt;em&gt;n&lt;/em&gt; is the optional &lt;code&gt;Fixnum&lt;/code&gt; parameter, defaulting
 *  to 16. The result is simply the sum of the binary value of each character in
 *  &lt;i&gt;str&lt;/i&gt; modulo &lt;code&gt;2n - 1&lt;/code&gt;. This is not a particularly good
 *  checksum.
 */

static VALUE
rb_str_sum(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE vbits;
    int bits;
    char *ptr, *p, *pend;
    long len;

    if (rb_scan_args(argc, argv, &quot;01&quot;, &amp;vbits) == 0) {
        bits = 16;
    }
    else bits = NUM2INT(vbits);

    ptr = p = RSTRING(str)-&gt;ptr;
    len = RSTRING(str)-&gt;len;
    pend = p + len;
    if (bits &gt;= sizeof(long)*CHAR_BIT) {
        VALUE sum = INT2FIX(0);

        while (p &lt; pend) {
            str_mod_check(str, ptr, len);
            sum = rb_funcall(sum, '+', 1, INT2FIX((unsigned char)*p));
            p++;
        }
        if (bits != 0) {
            VALUE mod;

            mod = rb_funcall(INT2FIX(1), rb_intern(&quot;&lt;&lt;&quot;), 1, INT2FIX(bits));
            mod = rb_funcall(mod, '-', 1, INT2FIX(1));
            sum = rb_funcall(sum, '&amp;', 1, mod);
        }
        return sum;
    }
    else {
       unsigned long sum = 0;

        while (p &lt; pend) {
            str_mod_check(str, ptr, len);
            sum += (unsigned char)*p;
            p++;
        }
        if (bits != 0) {
           sum &amp;= (((unsigned long)1)&lt;&lt;bits)-1;
        }
        return rb_int2inum(sum);
    }
}
</pre>
  </div>
</div>
</div>
<div id="M000781" class="method">
  <div id="M000781_title" class="title">
    <b>str.swapcase   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with uppercase alphabetic characters
converted to lowercase and lowercase characters converted to uppercase.
</p>
<pre>
   &quot;Hello&quot;.swapcase          #=&gt; &quot;hELLO&quot;
   &quot;cYbEr_PuNk11&quot;.swapcase   #=&gt; &quot;CyBeR_pUnK11&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000781_source')" id="l_M000781_source">show source</a> ]</p>
  <div id="M000781_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.swapcase   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with uppercase alphabetic characters converted
 *  to lowercase and lowercase characters converted to uppercase.
 *     
 *     &quot;Hello&quot;.swapcase          #=&gt; &quot;hELLO&quot;
 *     &quot;cYbEr_PuNk11&quot;.swapcase   #=&gt; &quot;CyBeR_pUnK11&quot;
 */

static VALUE
rb_str_swapcase(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_swapcase_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000785" class="method">
  <div id="M000785_title" class="title">
    <b>str.swapcase!   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Equivalent to <tt><a
href="index.html?a=M000781&name=String#swapcase">String#swapcase</a></tt>,
but modifies the receiver in place, returning <em>str</em>, or <tt>nil</tt>
if no changes were made.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000785_source')" id="l_M000785_source">show source</a> ]</p>
  <div id="M000785_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.swapcase!   =&gt; str or nil
 *  
 *  Equivalent to &lt;code&gt;String#swapcase&lt;/code&gt;, but modifies the receiver in
 *  place, returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no changes were made.
 */

static VALUE
rb_str_swapcase_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    s = RSTRING(str)-&gt;ptr; send = s + RSTRING(str)-&gt;len;
    while (s &lt; send) {
        if (ismbchar(*s)) {
            s+=mbclen(*s) - 1;
        }
        else if (ISUPPER(*s)) {
            *s = tolower(*s);
            modify = 1;
        }
        else if (ISLOWER(*s)) {
            *s = toupper(*s);
            modify = 1;
        }
        s++;
    }

    if (modify) return str;
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000773" class="method">
  <div id="M000773_title" class="title">
    <b>str.to_f   => float<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the result of interpreting leading characters in <em>str</em> as a
floating point number. Extraneous characters past the end of a valid number
are ignored. If there is not a valid number at the start of <em>str</em>,
<tt>0.0</tt> is returned. This method never raises an exception.
</p>
<pre>
   &quot;123.45e1&quot;.to_f        #=&gt; 1234.5
   &quot;45.67 degrees&quot;.to_f   #=&gt; 45.67
   &quot;thx1138&quot;.to_f         #=&gt; 0.0
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000773_source')" id="l_M000773_source">show source</a> ]</p>
  <div id="M000773_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.to_f   =&gt; float
 *  
 *  Returns the result of interpreting leading characters in &lt;i&gt;str&lt;/i&gt; as a
 *  floating point number. Extraneous characters past the end of a valid number
 *  are ignored. If there is not a valid number at the start of &lt;i&gt;str&lt;/i&gt;,
 *  &lt;code&gt;0.0&lt;/code&gt; is returned. This method never raises an exception.
 *     
 *     &quot;123.45e1&quot;.to_f        #=&gt; 1234.5
 *     &quot;45.67 degrees&quot;.to_f   #=&gt; 45.67
 *     &quot;thx1138&quot;.to_f         #=&gt; 0.0
 */

static VALUE
rb_str_to_f(str)
    VALUE str;
{
    return rb_float_new(rb_str_to_dbl(str, Qfalse));
}
</pre>
  </div>
</div>
</div>
<div id="M000772" class="method">
  <div id="M000772_title" class="title">
    <b>str.to_i(base=10)   => integer<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the result of interpreting leading characters in <em>str</em> as an
integer base <em>base</em> (between 2 and 36). Extraneous characters past
the end of a valid number are ignored. If there is not a valid number at
the start of <em>str</em>, <tt>0</tt> is returned. This method never raises
an exception.
</p>
<pre>
   &quot;12345&quot;.to_i             #=&gt; 12345
   &quot;99 red balloons&quot;.to_i   #=&gt; 99
   &quot;0a&quot;.to_i                #=&gt; 0
   &quot;0a&quot;.to_i(16)            #=&gt; 10
   &quot;hello&quot;.to_i             #=&gt; 0
   &quot;1100101&quot;.to_i(2)        #=&gt; 101
   &quot;1100101&quot;.to_i(8)        #=&gt; 294977
   &quot;1100101&quot;.to_i(10)       #=&gt; 1100101
   &quot;1100101&quot;.to_i(16)       #=&gt; 17826049
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000772_source')" id="l_M000772_source">show source</a> ]</p>
  <div id="M000772_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.to_i(base=10)   =&gt; integer
 *  
 *  Returns the result of interpreting leading characters in &lt;i&gt;str&lt;/i&gt; as an
 *  integer base &lt;i&gt;base&lt;/i&gt; (between 2 and 36). Extraneous characters past the
 *  end of a valid number are ignored. If there is not a valid number at the
 *  start of &lt;i&gt;str&lt;/i&gt;, &lt;code&gt;0&lt;/code&gt; is returned. This method never raises an
 *  exception.
 *     
 *     &quot;12345&quot;.to_i             #=&gt; 12345
 *     &quot;99 red balloons&quot;.to_i   #=&gt; 99
 *     &quot;0a&quot;.to_i                #=&gt; 0
 *     &quot;0a&quot;.to_i(16)            #=&gt; 10
 *     &quot;hello&quot;.to_i             #=&gt; 0
 *     &quot;1100101&quot;.to_i(2)        #=&gt; 101
 *     &quot;1100101&quot;.to_i(8)        #=&gt; 294977
 *     &quot;1100101&quot;.to_i(10)       #=&gt; 1100101
 *     &quot;1100101&quot;.to_i(16)       #=&gt; 17826049
 */

static VALUE
rb_str_to_i(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    VALUE b;
    int base;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;b);
    if (argc == 0) base = 10;
    else base = NUM2INT(b);

    if (base &lt; 0) {
        rb_raise(rb_eArgError, &quot;illegal radix %d&quot;, base);
    }
    return rb_str_to_inum(str, base, Qfalse);
}
</pre>
  </div>
</div>
</div>
<div id="M000774" class="method">
  <div id="M000774_title" class="title">
    <b>str.to_s     => str<br />
str.to_str   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the receiver.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000774_source')" id="l_M000774_source">show source</a> ]</p>
  <div id="M000774_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.to_s     =&gt; str
 *     str.to_str   =&gt; str
 *  
 *  Returns the receiver.
 */

static VALUE
rb_str_to_s(str)
    VALUE str;
{
    if (rb_obj_class(str) != rb_cString) {
        VALUE dup = str_alloc(rb_cString);
        rb_str_replace(dup, str);
        return dup;
    }
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000775" class="method">
  <div id="M000775_title" class="title">
    <b>str.to_s     => str<br />
str.to_str   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the receiver.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000775_source')" id="l_M000775_source">show source</a> ]</p>
  <div id="M000775_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.to_s     =&gt; str
 *     str.to_str   =&gt; str
 *  
 *  Returns the receiver.
 */

static VALUE
rb_str_to_s(str)
    VALUE str;
{
    if (rb_obj_class(str) != rb_cString) {
        VALUE dup = str_alloc(rb_cString);
        rb_str_replace(dup, str);
        return dup;
    }
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000795" class="method">
  <div id="M000795_title" class="title">
    <b>str.intern   => symbol<br />
str.to_sym   => symbol<br />
</b>
  </div>
  <div class="description">
  <p>
Returns the <tt><a
href="index.html?a=C00000284&name=Symbol">Symbol</a></tt> corresponding to
<em>str</em>, creating the symbol if it did not previously exist. See
<tt><a
href="index.html?a=M002638&name=Symbol#id2name">Symbol#id2name</a></tt>.
</p>
<pre>
   &quot;Koala&quot;.intern         #=&gt; :Koala
   s = 'cat'.to_sym       #=&gt; :cat
   s == :cat              #=&gt; true
   s = '@cat'.to_sym      #=&gt; :@cat
   s == :@cat             #=&gt; true
</pre>
<p>
This can also be used to create symbols that cannot be represented using
the <tt>:xxx</tt> notation.
</p>
<pre>
   'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000795_source')" id="l_M000795_source">show source</a> ]</p>
  <div id="M000795_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.intern   =&gt; symbol
 *     str.to_sym   =&gt; symbol
 *  
 *  Returns the &lt;code&gt;Symbol&lt;/code&gt; corresponding to &lt;i&gt;str&lt;/i&gt;, creating the
 *  symbol if it did not previously exist. See &lt;code&gt;Symbol#id2name&lt;/code&gt;.
 *     
 *     &quot;Koala&quot;.intern         #=&gt; :Koala
 *     s = 'cat'.to_sym       #=&gt; :cat
 *     s == :cat              #=&gt; true
 *     s = '@cat'.to_sym      #=&gt; :@cat
 *     s == :@cat             #=&gt; true
 *
 *  This can also be used to create symbols that cannot be represented using the
 *  &lt;code&gt;:xxx&lt;/code&gt; notation.
 *     
 *     'cat and dog'.to_sym   #=&gt; :&quot;cat and dog&quot;
 */

VALUE
rb_str_intern(s)
    VALUE s;
{
    volatile VALUE str = s;
    ID id;

    if (!RSTRING(str)-&gt;ptr || RSTRING(str)-&gt;len == 0) {
        rb_raise(rb_eArgError, &quot;interning empty string&quot;);
    }
    if (strlen(RSTRING(str)-&gt;ptr) != RSTRING(str)-&gt;len)
        rb_raise(rb_eArgError, &quot;symbol string may not contain `\\0'&quot;);
    if (OBJ_TAINTED(str) &amp;&amp; rb_safe_level() &gt;= 1 &amp;&amp; !rb_sym_interned_p(str)) {
        rb_raise(rb_eSecurityError, &quot;Insecure: can't intern tainted string&quot;);
    }
    id = rb_intern(RSTRING(str)-&gt;ptr);
    return ID2SYM(id);
}
</pre>
  </div>
</div>
</div>
<div id="M000863" class="method">
  <div id="M000863_title" class="title">
    <b>to_yaml</b>( opts = {} )
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000863_source')" id="l_M000863_source">show source</a> ]</p>
  <div id="M000863_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/yaml/rubytypes.rb, line 163</span>
163:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">to_yaml</span>( <span class="ruby-identifier">opts</span> = {} )
164:                 <span class="ruby-constant">YAML</span><span class="ruby-operator">::</span><span class="ruby-identifier">quick_emit</span>( <span class="ruby-identifier">is_complex_yaml?</span> <span class="ruby-value">? </span><span class="ruby-keyword kw">self</span> <span class="ruby-operator">:</span> <span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">opts</span> ) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">out</span><span class="ruby-operator">|</span>
165:             <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">is_binary_data?</span>
166:                 <span class="ruby-identifier">out</span>.<span class="ruby-identifier">scalar</span>( <span class="ruby-value str">&quot;tag:yaml.org,2002:binary&quot;</span>, [<span class="ruby-keyword kw">self</span>].<span class="ruby-identifier">pack</span>(<span class="ruby-value str">&quot;m&quot;</span>), <span class="ruby-identifier">:literal</span> )
167:             <span class="ruby-keyword kw">elsif</span> <span class="ruby-identifier">to_yaml_properties</span>.<span class="ruby-identifier">empty?</span>
168:                 <span class="ruby-identifier">out</span>.<span class="ruby-identifier">scalar</span>( <span class="ruby-identifier">taguri</span>, <span class="ruby-keyword kw">self</span>, <span class="ruby-keyword kw">self</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp re">/^:/</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">:quote2</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">to_yaml_style</span> )
169:             <span class="ruby-keyword kw">else</span>
170:                 <span class="ruby-identifier">out</span>.<span class="ruby-identifier">map</span>( <span class="ruby-identifier">taguri</span>, <span class="ruby-identifier">to_yaml_style</span> ) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">map</span><span class="ruby-operator">|</span>
171:                     <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>( <span class="ruby-value str">'str'</span>, <span class="ruby-node">&quot;#{self}&quot;</span> )
172:                     <span class="ruby-identifier">to_yaml_properties</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
173:                         <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>( <span class="ruby-identifier">m</span>, <span class="ruby-identifier">instance_variable_get</span>( <span class="ruby-identifier">m</span> ) )
174:                     <span class="ruby-keyword kw">end</span>
175:                 <span class="ruby-keyword kw">end</span>
176:             <span class="ruby-keyword kw">end</span>
177:         <span class="ruby-keyword kw">end</span>
178:         <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000866" class="method">
  <div id="M000866_title" class="title">
    <b>String#toeuc   &rarr; string<br />
</b>
  </div>
  <div class="description">
  <p>
Convert <tt>self</tt> to EUC-JP
</p>
<p>
<b>Note</b> This method decode MIME encoded string and convert halfwidth
katakana to fullwidth katakana. If you don&#8217;t want it, use <a
href="index.html?a=M005939&name=NKF.nkf">NKF.nkf</a>(&#8217;-exm0&#8217;,
str).
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000866_source')" id="l_M000866_source">show source</a> ]</p>
  <div id="M000866_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 305</span>
305:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">toeuc</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">toeuc</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000865" class="method">
  <div id="M000865_title" class="title">
    <b>String#tojis   &rarr; string<br />
</b>
  </div>
  <div class="description">
  <p>
Convert <tt>self</tt> to ISO-2022-JP
</p>
<p>
<b>Note</b> This method decode MIME encoded string and convert halfwidth
katakana to fullwidth katakana. If you don&#8217;t want it, use <a
href="index.html?a=M005939&name=NKF.nkf">NKF.nkf</a>(&#8217;-jxm0&#8217;,
str).
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000865_source')" id="l_M000865_source">show source</a> ]</p>
  <div id="M000865_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 294</span>
294:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">tojis</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">tojis</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000867" class="method">
  <div id="M000867_title" class="title">
    <b>String#tosjis   &rarr; string<br />
</b>
  </div>
  <div class="description">
  <p>
Convert <tt>self</tt> to Shift_JIS
</p>
<p>
<b>Note</b> This method decode MIME encoded string and convert halfwidth
katakana to fullwidth katakana. If you don&#8217;t want it, use <a
href="index.html?a=M005939&name=NKF.nkf">NKF.nkf</a>(&#8217;-sxm0&#8217;,
str).
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000867_source')" id="l_M000867_source">show source</a> ]</p>
  <div id="M000867_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 316</span>
316:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">tosjis</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">tosjis</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000869" class="method">
  <div id="M000869_title" class="title">
    <b>String#toutf16   &rarr; string<br />
</b>
  </div>
  <div class="description">
  <p>
Convert <tt>self</tt> to UTF-16
</p>
<p>
<b>Note</b> This method decode MIME encoded string and convert halfwidth
katakana to fullwidth katakana. If you don&#8217;t want it, use <a
href="index.html?a=M005939&name=NKF.nkf">NKF.nkf</a>(&#8217;-w16xm0&#8217;,
str).
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000869_source')" id="l_M000869_source">show source</a> ]</p>
  <div id="M000869_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 338</span>
338:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">toutf16</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">toutf16</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000868" class="method">
  <div id="M000868_title" class="title">
    <b>String#toutf8   &rarr; string<br />
</b>
  </div>
  <div class="description">
  <p>
Convert <tt>self</tt> to UTF-8
</p>
<p>
<b>Note</b> This method decode MIME encoded string and convert halfwidth
katakana to fullwidth katakana. If you don&#8217;t want it, use <a
href="index.html?a=M005939&name=NKF.nkf">NKF.nkf</a>(&#8217;-wxm0&#8217;,
str).
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000868_source')" id="l_M000868_source">show source</a> ]</p>
  <div id="M000868_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/ext/nkf/lib/kconv.rb, line 327</span>
327:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">toutf8</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">toutf8</span>(<span class="ruby-keyword kw">self</span>) <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000843" class="method">
  <div id="M000843_title" class="title">
    <b>tr</b>(from, to)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000843_source')" id="l_M000843_source">show source</a> ]</p>
  <div id="M000843_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 147</span>
147:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">tr</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>)
148:     (<span class="ruby-identifier">str</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">dup</span>).<span class="ruby-identifier">tr!</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>) <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">str</span>
149:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000817" class="method">
  <div id="M000817_title" class="title">
    <b>str.tr(from_str, to_str)   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with the characters in <em>from_str</em>
replaced by the corresponding characters in <em><a
href="index.html?a=M000775&name=to_str">to_str</a></em>. If <em><a
href="index.html?a=M000775&name=to_str">to_str</a></em> is shorter than
<em>from_str</em>, it is padded with its last character. Both strings may
use the c1&#8212;c2 notation to denote ranges of characters, and
<em>from_str</em> may start with a <tt>^</tt>, which denotes all characters
except those listed.
</p>
<pre>
   &quot;hello&quot;.tr('aeiou', '*')    #=&gt; &quot;h*ll*&quot;
   &quot;hello&quot;.tr('^aeiou', '*')   #=&gt; &quot;*e**o&quot;
   &quot;hello&quot;.tr('el', 'ip')      #=&gt; &quot;hippo&quot;
   &quot;hello&quot;.tr('a-y', 'b-z')    #=&gt; &quot;ifmmp&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000817_source')" id="l_M000817_source">show source</a> ]</p>
  <div id="M000817_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.tr(from_str, to_str)   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with the characters in &lt;i&gt;from_str&lt;/i&gt; replaced
 *  by the corresponding characters in &lt;i&gt;to_str&lt;/i&gt;. If &lt;i&gt;to_str&lt;/i&gt; is
 *  shorter than &lt;i&gt;from_str&lt;/i&gt;, it is padded with its last character. Both
 *  strings may use the c1--c2 notation to denote ranges of characters, and
 *  &lt;i&gt;from_str&lt;/i&gt; may start with a &lt;code&gt;^&lt;/code&gt;, which denotes all
 *  characters except those listed.
 *     
 *     &quot;hello&quot;.tr('aeiou', '*')    #=&gt; &quot;h*ll*&quot;
 *     &quot;hello&quot;.tr('^aeiou', '*')   #=&gt; &quot;*e**o&quot;
 *     &quot;hello&quot;.tr('el', 'ip')      #=&gt; &quot;hippo&quot;
 *     &quot;hello&quot;.tr('a-y', 'b-z')    #=&gt; &quot;ifmmp&quot;
 */

static VALUE
rb_str_tr(str, src, repl)
    VALUE str, src, repl;
{
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 0);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000842" class="method">
  <div id="M000842_title" class="title">
    <b>tr!</b>(from, to)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000842_source')" id="l_M000842_source">show source</a> ]</p>
  <div id="M000842_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 133</span>
133:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">tr!</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>)
134:     <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">from</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;&quot;</span>
135:     <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">delete!</span>(<span class="ruby-identifier">from</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">to</span> <span class="ruby-operator">==</span> <span class="ruby-value str">&quot;&quot;</span>
136: 
137:     <span class="ruby-identifier">pattern</span> = <span class="ruby-constant">TrPatternCache</span>[<span class="ruby-identifier">from</span>] <span class="ruby-operator">||=</span> <span class="ruby-node">/[#{_regex_quote(from)}]/</span>
138:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">from</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?^</span>
139:       <span class="ruby-identifier">last</span> = <span class="ruby-regexp re">/.$/</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">to</span>)[<span class="ruby-value">0</span>]
140:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">last</span>)
141:     <span class="ruby-keyword kw">else</span>
142:       <span class="ruby-identifier">h</span> = <span class="ruby-constant">HashCache</span>[<span class="ruby-identifier">from</span> <span class="ruby-operator">+</span> <span class="ruby-value str">&quot;1-0&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">to</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">expand_ch_hash</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>)
143:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-identifier">pattern</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">c</span><span class="ruby-operator">|</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">c</span>] <span class="ruby-keyword kw">end</span>
144:     <span class="ruby-keyword kw">end</span>
145:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000822" class="method">
  <div id="M000822_title" class="title">
    <b>str.tr!(from_str, to_str)   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Translates <em>str</em> in place, using the same rules as <tt><a
href="index.html?a=M000817&name=String#tr">String#tr</a></tt>. Returns
<em>str</em>, or <tt>nil</tt> if no changes were made.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000822_source')" id="l_M000822_source">show source</a> ]</p>
  <div id="M000822_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.tr!(from_str, to_str)   =&gt; str or nil
 *  
 *  Translates &lt;i&gt;str&lt;/i&gt; in place, using the same rules as
 *  &lt;code&gt;String#tr&lt;/code&gt;. Returns &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no
 *  changes were made.
 */

static VALUE
rb_str_tr_bang(str, src, repl)
    VALUE str, src, repl;
{
    return tr_trans(str, src, repl, 0);
}
</pre>
  </div>
</div>
</div>
<div id="M000849" class="method">
  <div id="M000849_title" class="title">
    <b>tr_s</b>(from, to)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000849_source')" id="l_M000849_source">show source</a> ]</p>
  <div id="M000849_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 188</span>
188:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">tr_s</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>)
189:     (<span class="ruby-identifier">str</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">dup</span>).<span class="ruby-identifier">tr_s!</span>(<span class="ruby-identifier">from</span>,<span class="ruby-identifier">to</span>) <span class="ruby-keyword kw">or</span> <span class="ruby-identifier">str</span>
190:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000818" class="method">
  <div id="M000818_title" class="title">
    <b>str.tr_s(from_str, to_str)   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Processes a copy of <em>str</em> as described under <tt><a
href="index.html?a=M000817&name=String#tr">String#tr</a></tt>, then removes
duplicate characters in regions that were affected by the translation.
</p>
<pre>
   &quot;hello&quot;.tr_s('l', 'r')     #=&gt; &quot;hero&quot;
   &quot;hello&quot;.tr_s('el', '*')    #=&gt; &quot;h*o&quot;
   &quot;hello&quot;.tr_s('el', 'hx')   #=&gt; &quot;hhxo&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000818_source')" id="l_M000818_source">show source</a> ]</p>
  <div id="M000818_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.tr_s(from_str, to_str)   =&gt; new_str
 *  
 *  Processes a copy of &lt;i&gt;str&lt;/i&gt; as described under &lt;code&gt;String#tr&lt;/code&gt;,
 *  then removes duplicate characters in regions that were affected by the
 *  translation.
 *     
 *     &quot;hello&quot;.tr_s('l', 'r')     #=&gt; &quot;hero&quot;
 *     &quot;hello&quot;.tr_s('el', '*')    #=&gt; &quot;h*o&quot;
 *     &quot;hello&quot;.tr_s('el', 'hx')   #=&gt; &quot;hhxo&quot;
 */

static VALUE
rb_str_tr_s(str, src, repl)
    VALUE str, src, repl;
{
    str = rb_str_dup(str);
    tr_trans(str, src, repl, 1);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000848" class="method">
  <div id="M000848_title" class="title">
    <b>tr_s!</b>(from, to)
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000848_source')" id="l_M000848_source">show source</a> ]</p>
  <div id="M000848_source" class="dyn-source">
<pre>
     <span class="ruby-comment cmt"># File ruby-1.8.7-p22/lib/jcode.rb, line 175</span>
175:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">tr_s!</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>)
176:     <span class="ruby-keyword kw">return</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">delete!</span>(<span class="ruby-identifier">from</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">to</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
177: 
178:     <span class="ruby-identifier">pattern</span> = <span class="ruby-constant">SqueezePatternCache</span>[<span class="ruby-identifier">from</span>] <span class="ruby-operator">||=</span> <span class="ruby-node">/([#{_regex_quote(from)}])\1*/</span>
179:     <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">from</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">==</span> <span class="ruby-value">?^</span>
180:       <span class="ruby-identifier">last</span> = <span class="ruby-regexp re">/.$/</span>.<span class="ruby-identifier">match</span>(<span class="ruby-identifier">to</span>)[<span class="ruby-value">0</span>]
181:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">last</span>)
182:     <span class="ruby-keyword kw">else</span>
183:       <span class="ruby-identifier">h</span> = <span class="ruby-constant">HashCache</span>[<span class="ruby-identifier">from</span> <span class="ruby-operator">+</span> <span class="ruby-value str">&quot;1-0&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">to</span>] <span class="ruby-operator">||=</span> <span class="ruby-identifier">expand_ch_hash</span>(<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span>)
184:       <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">gsub!</span>(<span class="ruby-identifier">pattern</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-identifier">h</span>[<span class="ruby-identifier">$1</span>] <span class="ruby-keyword kw">end</span>
185:     <span class="ruby-keyword kw">end</span>
186:   <span class="ruby-keyword kw">end</span>
</pre>
  </div>
</div>
</div>
<div id="M000823" class="method">
  <div id="M000823_title" class="title">
    <b>str.tr_s!(from_str, to_str)   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Performs <tt><a
href="index.html?a=M000818&name=String#tr_s">String#tr_s</a></tt>
processing on <em>str</em> in place, returning <em>str</em>, or
<tt>nil</tt> if no changes were made.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000823_source')" id="l_M000823_source">show source</a> ]</p>
  <div id="M000823_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.tr_s!(from_str, to_str)   =&gt; str or nil
 *  
 *  Performs &lt;code&gt;String#tr_s&lt;/code&gt; processing on &lt;i&gt;str&lt;/i&gt; in place,
 *  returning &lt;i&gt;str&lt;/i&gt;, or &lt;code&gt;nil&lt;/code&gt; if no changes were made.
 */

static VALUE
rb_str_tr_s_bang(str, src, repl)
    VALUE str, src, repl;
{
    return tr_trans(str, src, repl, 1);
}
</pre>
  </div>
</div>
</div>
<div id="M000744" class="method">
  <div id="M000744_title" class="title">
    <b>str.unpack(format)   => anArray<br />
</b>
  </div>
  <div class="description">
  <p>
Decodes <em>str</em> (which may contain binary data) according to the
format string, returning an array of each value extracted. The format
string consists of a sequence of single-character directives, summarized in
the table at the end of this entry. Each directive may be followed by a
number, indicating the number of times to repeat with this directive. An
asterisk (``<tt>*</tt>&#8217;&#8217;) will use up all remaining elements.
The directives <tt>sSiIlL</tt> may each be followed by an underscore
(``<tt>_</tt>&#8217;&#8217;) to use the underlying platform&#8217;s native
size for the specified type; otherwise, it uses a platform-independent
consistent size. Spaces are ignored in the format string. See also <tt><a
href="index.html?a=M002138&name=Array#pack">Array#pack</a></tt>.
</p>
<pre>
   &quot;abc \0\0abc \0\0&quot;.unpack('A6Z6')   #=&gt; [&quot;abc&quot;, &quot;abc &quot;]
   &quot;abc \0\0&quot;.unpack('a3a3')           #=&gt; [&quot;abc&quot;, &quot; \000\000&quot;]
   &quot;abc \0abc \0&quot;.unpack('Z*Z*')       #=&gt; [&quot;abc &quot;, &quot;abc &quot;]
   &quot;aa&quot;.unpack('b8B8')                 #=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]
   &quot;aaa&quot;.unpack('h2H2c')               #=&gt; [&quot;16&quot;, &quot;61&quot;, 97]
   &quot;\xfe\xff\xfe\xff&quot;.unpack('sS')     #=&gt; [-2, 65534]
   &quot;now=20is&quot;.unpack('M*')             #=&gt; [&quot;now is&quot;]
   &quot;whole&quot;.unpack('xax2aX2aX1aX2a')    #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
</pre>
<p>
This table summarizes the various formats and the Ruby classes returned by
each.
</p>
<pre>
   Format | Returns | Function
   -------+---------+-----------------------------------------
     A    | String  | with trailing nulls and spaces removed
   -------+---------+-----------------------------------------
     a    | String  | string
   -------+---------+-----------------------------------------
     B    | String  | extract bits from each character (msb first)
   -------+---------+-----------------------------------------
     b    | String  | extract bits from each character (lsb first)
   -------+---------+-----------------------------------------
     C    | Fixnum  | extract a character as an unsigned integer
   -------+---------+-----------------------------------------
     c    | Fixnum  | extract a character as an integer
   -------+---------+-----------------------------------------
     d,D  | Float   | treat sizeof(double) characters as
          |         | a native double
   -------+---------+-----------------------------------------
     E    | Float   | treat sizeof(double) characters as
          |         | a double in little-endian byte order
   -------+---------+-----------------------------------------
     e    | Float   | treat sizeof(float) characters as
          |         | a float in little-endian byte order
   -------+---------+-----------------------------------------
     f,F  | Float   | treat sizeof(float) characters as
          |         | a native float
   -------+---------+-----------------------------------------
     G    | Float   | treat sizeof(double) characters as
          |         | a double in network byte order
   -------+---------+-----------------------------------------
     g    | Float   | treat sizeof(float) characters as a
          |         | float in network byte order
   -------+---------+-----------------------------------------
     H    | String  | extract hex nibbles from each character
          |         | (most significant first)
   -------+---------+-----------------------------------------
     h    | String  | extract hex nibbles from each character
          |         | (least significant first)
   -------+---------+-----------------------------------------
     I    | Integer | treat sizeof(int) (modified by _)
          |         | successive characters as an unsigned
          |         | native integer
   -------+---------+-----------------------------------------
     i    | Integer | treat sizeof(int) (modified by _)
          |         | successive characters as a signed
          |         | native integer
   -------+---------+-----------------------------------------
     L    | Integer | treat four (modified by _) successive
          |         | characters as an unsigned native
          |         | long integer
   -------+---------+-----------------------------------------
     l    | Integer | treat four (modified by _) successive
          |         | characters as a signed native
          |         | long integer
   -------+---------+-----------------------------------------
     M    | String  | quoted-printable
   -------+---------+-----------------------------------------
     m    | String  | base64-encoded
   -------+---------+-----------------------------------------
     N    | Integer | treat four characters as an unsigned
          |         | long in network byte order
   -------+---------+-----------------------------------------
     n    | Fixnum  | treat two characters as an unsigned
          |         | short in network byte order
   -------+---------+-----------------------------------------
     P    | String  | treat sizeof(char *) characters as a
          |         | pointer, and  return \emph{len} characters
          |         | from the referenced location
   -------+---------+-----------------------------------------
     p    | String  | treat sizeof(char *) characters as a
          |         | pointer to a  null-terminated string
   -------+---------+-----------------------------------------
     Q    | Integer | treat 8 characters as an unsigned
          |         | quad word (64 bits)
   -------+---------+-----------------------------------------
     q    | Integer | treat 8 characters as a signed
          |         | quad word (64 bits)
   -------+---------+-----------------------------------------
     S    | Fixnum  | treat two (different if _ used)
          |         | successive characters as an unsigned
          |         | short in native byte order
   -------+---------+-----------------------------------------
     s    | Fixnum  | Treat two (different if _ used)
          |         | successive characters as a signed short
          |         | in native byte order
   -------+---------+-----------------------------------------
     U    | Integer | UTF-8 characters as unsigned integers
   -------+---------+-----------------------------------------
     u    | String  | UU-encoded
   -------+---------+-----------------------------------------
     V    | Fixnum  | treat four characters as an unsigned
          |         | long in little-endian byte order
   -------+---------+-----------------------------------------
     v    | Fixnum  | treat two characters as an unsigned
          |         | short in little-endian byte order
   -------+---------+-----------------------------------------
     w    | Integer | BER-compressed integer (see Array.pack)
   -------+---------+-----------------------------------------
     X    | ---     | skip backward one character
   -------+---------+-----------------------------------------
     x    | ---     | skip forward one character
   -------+---------+-----------------------------------------
     Z    | String  | with trailing nulls removed
          |         | upto first null with *
   -------+---------+-----------------------------------------
     @    | ---     | skip to the offset given by the
          |         | length argument
   -------+---------+-----------------------------------------
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000744_source')" id="l_M000744_source">show source</a> ]</p>
  <div id="M000744_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.unpack(format)   =&gt; anArray
 *  
 *  Decodes &lt;i&gt;str&lt;/i&gt; (which may contain binary data) according to the
 *  format string, returning an array of each value extracted. The
 *  format string consists of a sequence of single-character directives,
 *  summarized in the table at the end of this entry.
 *  Each directive may be followed
 *  by a number, indicating the number of times to repeat with this
 *  directive. An asterisk (``&lt;code&gt;*&lt;/code&gt;'') will use up all
 *  remaining elements. The directives &lt;code&gt;sSiIlL&lt;/code&gt; may each be
 *  followed by an underscore (``&lt;code&gt;_&lt;/code&gt;'') to use the underlying
 *  platform's native size for the specified type; otherwise, it uses a
 *  platform-independent consistent size. Spaces are ignored in the
 *  format string. See also &lt;code&gt;Array#pack&lt;/code&gt;.
 *     
 *     &quot;abc \0\0abc \0\0&quot;.unpack('A6Z6')   #=&gt; [&quot;abc&quot;, &quot;abc &quot;]
 *     &quot;abc \0\0&quot;.unpack('a3a3')           #=&gt; [&quot;abc&quot;, &quot; \000\000&quot;]
 *     &quot;abc \0abc \0&quot;.unpack('Z*Z*')       #=&gt; [&quot;abc &quot;, &quot;abc &quot;]
 *     &quot;aa&quot;.unpack('b8B8')                 #=&gt; [&quot;10000110&quot;, &quot;01100001&quot;]
 *     &quot;aaa&quot;.unpack('h2H2c')               #=&gt; [&quot;16&quot;, &quot;61&quot;, 97]
 *     &quot;\xfe\xff\xfe\xff&quot;.unpack('sS')     #=&gt; [-2, 65534]
 *     &quot;now=20is&quot;.unpack('M*')             #=&gt; [&quot;now is&quot;]
 *     &quot;whole&quot;.unpack('xax2aX2aX1aX2a')    #=&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]
 *
 *  This table summarizes the various formats and the Ruby classes
 *  returned by each.
 *     
 *     Format | Returns | Function
 *     -------+---------+-----------------------------------------
 *       A    | String  | with trailing nulls and spaces removed
 *     -------+---------+-----------------------------------------
 *       a    | String  | string
 *     -------+---------+-----------------------------------------
 *       B    | String  | extract bits from each character (msb first)
 *     -------+---------+-----------------------------------------
 *       b    | String  | extract bits from each character (lsb first)
 *     -------+---------+-----------------------------------------
 *       C    | Fixnum  | extract a character as an unsigned integer
 *     -------+---------+-----------------------------------------
 *       c    | Fixnum  | extract a character as an integer
 *     -------+---------+-----------------------------------------
 *       d,D  | Float   | treat sizeof(double) characters as
 *            |         | a native double
 *     -------+---------+-----------------------------------------
 *       E    | Float   | treat sizeof(double) characters as
 *            |         | a double in little-endian byte order
 *     -------+---------+-----------------------------------------
 *       e    | Float   | treat sizeof(float) characters as
 *            |         | a float in little-endian byte order
 *     -------+---------+-----------------------------------------
 *       f,F  | Float   | treat sizeof(float) characters as
 *            |         | a native float
 *     -------+---------+-----------------------------------------
 *       G    | Float   | treat sizeof(double) characters as
 *            |         | a double in network byte order
 *     -------+---------+-----------------------------------------
 *       g    | Float   | treat sizeof(float) characters as a
 *            |         | float in network byte order
 *     -------+---------+-----------------------------------------
 *       H    | String  | extract hex nibbles from each character
 *            |         | (most significant first)
 *     -------+---------+-----------------------------------------
 *       h    | String  | extract hex nibbles from each character
 *            |         | (least significant first)
 *     -------+---------+-----------------------------------------
 *       I    | Integer | treat sizeof(int) (modified by _)
 *            |         | successive characters as an unsigned
 *            |         | native integer
 *     -------+---------+-----------------------------------------
 *       i    | Integer | treat sizeof(int) (modified by _)
 *            |         | successive characters as a signed
 *            |         | native integer
 *     -------+---------+-----------------------------------------
 *       L    | Integer | treat four (modified by _) successive
 *            |         | characters as an unsigned native
 *            |         | long integer
 *     -------+---------+-----------------------------------------
 *       l    | Integer | treat four (modified by _) successive
 *            |         | characters as a signed native
 *            |         | long integer
 *     -------+---------+-----------------------------------------
 *       M    | String  | quoted-printable
 *     -------+---------+-----------------------------------------
 *       m    | String  | base64-encoded
 *     -------+---------+-----------------------------------------
 *       N    | Integer | treat four characters as an unsigned
 *            |         | long in network byte order
 *     -------+---------+-----------------------------------------
 *       n    | Fixnum  | treat two characters as an unsigned
 *            |         | short in network byte order
 *     -------+---------+-----------------------------------------
 *       P    | String  | treat sizeof(char *) characters as a
 *            |         | pointer, and  return \emph{len} characters
 *            |         | from the referenced location
 *     -------+---------+-----------------------------------------
 *       p    | String  | treat sizeof(char *) characters as a
 *            |         | pointer to a  null-terminated string
 *     -------+---------+-----------------------------------------
 *       Q    | Integer | treat 8 characters as an unsigned 
 *            |         | quad word (64 bits)
 *     -------+---------+-----------------------------------------
 *       q    | Integer | treat 8 characters as a signed 
 *            |         | quad word (64 bits)
 *     -------+---------+-----------------------------------------
 *       S    | Fixnum  | treat two (different if _ used)
 *            |         | successive characters as an unsigned
 *            |         | short in native byte order
 *     -------+---------+-----------------------------------------
 *       s    | Fixnum  | Treat two (different if _ used) 
 *            |         | successive characters as a signed short
 *            |         | in native byte order
 *     -------+---------+-----------------------------------------
 *       U    | Integer | UTF-8 characters as unsigned integers
 *     -------+---------+-----------------------------------------
 *       u    | String  | UU-encoded
 *     -------+---------+-----------------------------------------
 *       V    | Fixnum  | treat four characters as an unsigned
 *            |         | long in little-endian byte order
 *     -------+---------+-----------------------------------------
 *       v    | Fixnum  | treat two characters as an unsigned
 *            |         | short in little-endian byte order
 *     -------+---------+-----------------------------------------
 *       w    | Integer | BER-compressed integer (see Array.pack)
 *     -------+---------+-----------------------------------------
 *       X    | ---     | skip backward one character
 *     -------+---------+-----------------------------------------
 *       x    | ---     | skip forward one character
 *     -------+---------+-----------------------------------------
 *       Z    | String  | with trailing nulls removed
 *            |         | upto first null with *
 *     -------+---------+-----------------------------------------
 *       @    | ---     | skip to the offset given by the 
 *            |         | length argument
 *     -------+---------+-----------------------------------------
 */

static VALUE
pack_unpack(str, fmt)
    VALUE str, fmt;
{
    static const char hexdigits[] = &quot;0123456789abcdef0123456789ABCDEFx&quot;;
    char *s, *send;
    char *p, *pend;
    VALUE ary;
    char type;
    long len;
    int tmp, star;
#ifdef NATINT_PACK
    int natint;                 /* native integer */
#endif

    StringValue(str);
    StringValue(fmt);
    s = RSTRING(str)-&gt;ptr;
    send = s + RSTRING(str)-&gt;len;
    p = RSTRING(fmt)-&gt;ptr;
    pend = p + RSTRING(fmt)-&gt;len;

    ary = rb_ary_new();
    while (p &lt; pend) {
        type = *p++;
#ifdef NATINT_PACK
        natint = 0;
#endif

        if (ISSPACE(type)) continue;
        if (type == '#') {
            while ((p &lt; pend) &amp;&amp; (*p != '\n')) {
                p++;
            }
            continue;
        }
        star = 0;
        if (*p == '_' || *p == '!') {
            static const char natstr[] = &quot;sSiIlL&quot;;

            if (strchr(natstr, type)) {
#ifdef NATINT_PACK
                natint = 1;
#endif
                p++;
            }
            else {
                rb_raise(rb_eArgError, &quot;'%c' allowed only after types %s&quot;, *p, natstr);
            }
        }
        if (p &gt;= pend)
            len = 1;
        else if (*p == '*') {
            star = 1;
            len = send - s;
            p++;
        }
        else if (ISDIGIT(*p)) {
            len = strtoul(p, (char**)&amp;p, 10);
        }
        else {
            len = (type != '@');
        }

        switch (type) {
          case '%':
            rb_raise(rb_eArgError, &quot;%% is not supported&quot;);
            break;

          case 'A':
            if (len &gt; send - s) len = send - s;
            {
                long end = len;
                char *t = s + len - 1;

                while (t &gt;= s) {
                    if (*t != ' ' &amp;&amp; *t != '\0') break;
                    t--; len--;
                }
                rb_ary_push(ary, infected_str_new(s, len, str));
                s += end;
            }
            break;

          case 'Z':
            {
                char *t = s;

                if (len &gt; send-s) len = send-s;
                while (t &lt; s+len &amp;&amp; *t) t++;
                rb_ary_push(ary, infected_str_new(s, t-s, str));
                if (t &lt; send) t++;
                s = star ? t : s+len;
            }
            break;

          case 'a':
            if (len &gt; send - s) len = send - s;
            rb_ary_push(ary, infected_str_new(s, len, str));
            s += len;
            break;

          case 'b':
            {
                VALUE bitstr;
                char *t;
                int bits;
                long i;

                if (p[-1] == '*' || len &gt; (send - s) * 8)
                    len = (send - s) * 8;
                bits = 0;
                rb_ary_push(ary, bitstr = rb_str_new(0, len));
                t = RSTRING(bitstr)-&gt;ptr;
                for (i=0; i&lt;len; i++) {
                    if (i &amp; 7) bits &gt;&gt;= 1;
                    else bits = *s++;
                    *t++ = (bits &amp; 1) ? '1' : '0';
                }
            }
            break;

          case 'B':
            {
                VALUE bitstr;
                char *t;
                int bits;
                long i;

                if (p[-1] == '*' || len &gt; (send - s) * 8)
                    len = (send - s) * 8;
                bits = 0;
                rb_ary_push(ary, bitstr = rb_str_new(0, len));
                t = RSTRING(bitstr)-&gt;ptr;
                for (i=0; i&lt;len; i++) {
                    if (i &amp; 7) bits &lt;&lt;= 1;
                    else bits = *s++;
                    *t++ = (bits &amp; 128) ? '1' : '0';
                }
            }
            break;

          case 'h':
            {
                VALUE bitstr;
                char *t;
                int bits;
                long i;

                if (p[-1] == '*' || len &gt; (send - s) * 2)
                    len = (send - s) * 2;
                bits = 0;
                rb_ary_push(ary, bitstr = rb_str_new(0, len));
                t = RSTRING(bitstr)-&gt;ptr;
                for (i=0; i&lt;len; i++) {
                    if (i &amp; 1)
                        bits &gt;&gt;= 4;
                    else
                        bits = *s++;
                    *t++ = hexdigits[bits &amp; 15];
                }
            }
            break;

          case 'H':
            {
                VALUE bitstr;
                char *t;
                int bits;
                long i;

                if (p[-1] == '*' || len &gt; (send - s) * 2)
                    len = (send - s) * 2;
                bits = 0;
                rb_ary_push(ary, bitstr = rb_str_new(0, len));
                t = RSTRING(bitstr)-&gt;ptr;
                for (i=0; i&lt;len; i++) {
                    if (i &amp; 1)
                        bits &lt;&lt;= 4;
                    else
                        bits = *s++;
                    *t++ = hexdigits[(bits &gt;&gt; 4) &amp; 15];
                }
            }
            break;

          case 'c':
            PACK_LENGTH_ADJUST(char,sizeof(char));
            while (len-- &gt; 0) {
                int c = *s++;
                if (c &gt; (char)127) c-=256;
                rb_ary_push(ary, INT2FIX(c));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'C':
            PACK_LENGTH_ADJUST(unsigned char,sizeof(unsigned char));
            while (len-- &gt; 0) {
                unsigned char c = *s++;
                rb_ary_push(ary, INT2FIX(c));
            }
            PACK_ITEM_ADJUST();
            break;

          case 's':
            PACK_LENGTH_ADJUST(short,2);
            while (len-- &gt; 0) {
                short tmp = 0;
                memcpy(OFF16(&amp;tmp), s, NATINT_LEN(short,2));
                EXTEND16(tmp);
                s += NATINT_LEN(short,2);
                rb_ary_push(ary, INT2FIX(tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'S':
            PACK_LENGTH_ADJUST(unsigned short,2);
            while (len-- &gt; 0) {
                unsigned short tmp = 0;
                memcpy(OFF16(&amp;tmp), s, NATINT_LEN(unsigned short,2));
                s += NATINT_LEN(unsigned short,2);
                rb_ary_push(ary, INT2FIX(tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'i':
            PACK_LENGTH_ADJUST(int,sizeof(int));
            while (len-- &gt; 0) {
                int tmp;
                memcpy(&amp;tmp, s, sizeof(int));
                s += sizeof(int);
                rb_ary_push(ary, INT2NUM(tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'I':
            PACK_LENGTH_ADJUST(unsigned int,sizeof(unsigned int));
            while (len-- &gt; 0) {
                unsigned int tmp;
                memcpy(&amp;tmp, s, sizeof(unsigned int));
                s += sizeof(unsigned int);
                rb_ary_push(ary, UINT2NUM(tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'l':
            PACK_LENGTH_ADJUST(long,4);
            while (len-- &gt; 0) {
                long tmp = 0;
                memcpy(OFF32(&amp;tmp), s, NATINT_LEN(long,4));
                EXTEND32(tmp);
                s += NATINT_LEN(long,4);
                rb_ary_push(ary, LONG2NUM(tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'L':
            PACK_LENGTH_ADJUST(unsigned long,4);
            while (len-- &gt; 0) {
                unsigned long tmp = 0;
                memcpy(OFF32(&amp;tmp), s, NATINT_LEN(unsigned long,4));
                s += NATINT_LEN(unsigned long,4);
                rb_ary_push(ary, ULONG2NUM(tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'q':
            PACK_LENGTH_ADJUST_SIZE(QUAD_SIZE);
            while (len-- &gt; 0) {
                char *tmp = (char*)s;
                s += QUAD_SIZE;
                rb_ary_push(ary, rb_quad_unpack(tmp, 1));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'Q':
            PACK_LENGTH_ADJUST_SIZE(QUAD_SIZE);
            while (len-- &gt; 0) {
                char *tmp = (char*)s;
                s += QUAD_SIZE;
                rb_ary_push(ary, rb_quad_unpack(tmp, 0));
            }
            break;

          case 'n':
            PACK_LENGTH_ADJUST(unsigned short,2);
            while (len-- &gt; 0) {
                unsigned short tmp = 0;
                memcpy(OFF16B(&amp;tmp), s, NATINT_LEN(unsigned short,2));
                s += NATINT_LEN(unsigned short,2);
                rb_ary_push(ary, UINT2NUM(ntohs(tmp)));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'N':
            PACK_LENGTH_ADJUST(unsigned long,4);
            while (len-- &gt; 0) {
                unsigned long tmp = 0;
                memcpy(OFF32B(&amp;tmp), s, NATINT_LEN(unsigned long,4));
                s += NATINT_LEN(unsigned long,4);
                rb_ary_push(ary, ULONG2NUM(ntohl(tmp)));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'v':
            PACK_LENGTH_ADJUST(unsigned short,2);
            while (len-- &gt; 0) {
                unsigned short tmp = 0;
                memcpy(OFF16(&amp;tmp), s, NATINT_LEN(unsigned short,2));
                s += NATINT_LEN(unsigned short,2);
                rb_ary_push(ary, UINT2NUM(vtohs(tmp)));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'V':
            PACK_LENGTH_ADJUST(unsigned long,4);
            while (len-- &gt; 0) {
                unsigned long tmp = 0;
                memcpy(OFF32(&amp;tmp), s, NATINT_LEN(long,4));
                s += NATINT_LEN(long,4);
                rb_ary_push(ary, ULONG2NUM(vtohl(tmp)));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'f':
          case 'F':
            PACK_LENGTH_ADJUST(float,sizeof(float));
            while (len-- &gt; 0) {
                float tmp;
                memcpy(&amp;tmp, s, sizeof(float));
                s += sizeof(float);
                rb_ary_push(ary, rb_float_new((double)tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'e':
            PACK_LENGTH_ADJUST(float,sizeof(float));
            while (len-- &gt; 0) {
                float tmp;
                FLOAT_CONVWITH(ftmp);

                memcpy(&amp;tmp, s, sizeof(float));
                s += sizeof(float);
                tmp = VTOHF(tmp,ftmp);
                rb_ary_push(ary, rb_float_new((double)tmp));
            }
            PACK_ITEM_ADJUST();
            break;
            
          case 'E':
            PACK_LENGTH_ADJUST(double,sizeof(double));
            while (len-- &gt; 0) {
                double tmp;
                DOUBLE_CONVWITH(dtmp);

                memcpy(&amp;tmp, s, sizeof(double));
                s += sizeof(double);
                tmp = VTOHD(tmp,dtmp);
                rb_ary_push(ary, rb_float_new(tmp));
            }
            PACK_ITEM_ADJUST();
            break;
            
          case 'D':
          case 'd':
            PACK_LENGTH_ADJUST(double,sizeof(double));
            while (len-- &gt; 0) {
                double tmp;
                memcpy(&amp;tmp, s, sizeof(double));
                s += sizeof(double);
                rb_ary_push(ary, rb_float_new(tmp));
            }
            PACK_ITEM_ADJUST();
            break;

          case 'g':
            PACK_LENGTH_ADJUST(float,sizeof(float));
            while (len-- &gt; 0) {
                float tmp;
                FLOAT_CONVWITH(ftmp;)

                memcpy(&amp;tmp, s, sizeof(float));
                s += sizeof(float);
                tmp = NTOHF(tmp,ftmp);
                rb_ary_push(ary, rb_float_new((double)tmp));
            }
            PACK_ITEM_ADJUST();
            break;
            
          case 'G':
            PACK_LENGTH_ADJUST(double,sizeof(double));
            while (len-- &gt; 0) {
                double tmp;
                DOUBLE_CONVWITH(dtmp);

                memcpy(&amp;tmp, s, sizeof(double));
                s += sizeof(double);
                tmp = NTOHD(tmp,dtmp);
                rb_ary_push(ary, rb_float_new(tmp));
            }
            PACK_ITEM_ADJUST();
            break;
            
          case 'U':
            if (len &gt; send - s) len = send - s;
            while (len &gt; 0 &amp;&amp; s &lt; send) {
                long alen = send - s;
                unsigned long l;

                l = utf8_to_uv(s, &amp;alen);
                s += alen; len--;
                rb_ary_push(ary, ULONG2NUM(l));
            }
            break;

          case 'u':
            {
                VALUE buf = infected_str_new(0, (send - s)*3/4, str);
                char *ptr = RSTRING(buf)-&gt;ptr;
                long total = 0;

                while (s &lt; send &amp;&amp; *s &gt; ' ' &amp;&amp; *s &lt; 'a') {
                    long a,b,c,d;
                    char hunk[4];

                    hunk[3] = '\0';
                    len = (*s++ - ' ') &amp; 077;
                    total += len;
                    if (total &gt; RSTRING(buf)-&gt;len) {
                        len -= total - RSTRING(buf)-&gt;len;
                        total = RSTRING(buf)-&gt;len;
                    }

                    while (len &gt; 0) {
                        long mlen = len &gt; 3 ? 3 : len;

                        if (s &lt; send &amp;&amp; *s &gt;= ' ')
                            a = (*s++ - ' ') &amp; 077;
                        else
                            a = 0;
                        if (s &lt; send &amp;&amp; *s &gt;= ' ')
                            b = (*s++ - ' ') &amp; 077;
                        else
                            b = 0;
                        if (s &lt; send &amp;&amp; *s &gt;= ' ')
                            c = (*s++ - ' ') &amp; 077;
                        else
                            c = 0;
                        if (s &lt; send &amp;&amp; *s &gt;= ' ')
                            d = (*s++ - ' ') &amp; 077;
                        else
                            d = 0;
                        hunk[0] = a &lt;&lt; 2 | b &gt;&gt; 4;
                        hunk[1] = b &lt;&lt; 4 | c &gt;&gt; 2;
                        hunk[2] = c &lt;&lt; 6 | d;
                        memcpy(ptr, hunk, mlen);
                        ptr += mlen;
                        len -= mlen;
                    }
                    if (*s == '\r') s++;
                    if (*s == '\n') s++;
                    else if (s &lt; send &amp;&amp; (s+1 == send || s[1] == '\n'))
                        s += 2;      /* possible checksum byte */
                }
                
                RSTRING(buf)-&gt;ptr[total] = '\0';
                RSTRING(buf)-&gt;len = total;
                rb_ary_push(ary, buf);
            }
            break;

          case 'm':
            {
                VALUE buf = infected_str_new(0, (send - s)*3/4, str);
                char *ptr = RSTRING(buf)-&gt;ptr;
                int a = -1,b = -1,c = 0,d;
                static int first = 1;
                static int b64_xtable[256];

                if (first) {
                    int i;
                    first = 0;

                    for (i = 0; i &lt; 256; i++) {
                        b64_xtable[i] = -1;
                    }
                    for (i = 0; i &lt; 64; i++) {
                        b64_xtable[(int)b64_table[i]] = i;
                    }
                }
                while (s &lt; send) {
                    a = b = c = d = -1;
                    while((a = b64_xtable[(int)(*(unsigned char*)s)]) == -1 &amp;&amp; s &lt; send) { s++; }
                    if( s &gt;= send ) break;
                    s++;
                    while((b = b64_xtable[(int)(*(unsigned char*)s)]) == -1 &amp;&amp; s &lt; send) { s++; }
                    if( s &gt;= send ) break;
                    s++;
                    while((c = b64_xtable[(int)(*(unsigned char*)s)]) == -1 &amp;&amp; s &lt; send) { if( *s == '=' ) break; s++; }
                    if( *s == '=' || s &gt;= send ) break;
                    s++;
                    while((d = b64_xtable[(int)(*(unsigned char*)s)]) == -1 &amp;&amp; s &lt; send) { if( *s == '=' ) break; s++; }
                    if( *s == '=' || s &gt;= send ) break;
                    s++;
                    *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
                    *ptr++ = b &lt;&lt; 4 | c &gt;&gt; 2;
                    *ptr++ = c &lt;&lt; 6 | d;
                }
                if (a != -1 &amp;&amp; b != -1) {
                    if (c == -1 &amp;&amp; *s == '=')
                        *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
                    else if (c != -1 &amp;&amp; *s == '=') {
                        *ptr++ = a &lt;&lt; 2 | b &gt;&gt; 4;
                        *ptr++ = b &lt;&lt; 4 | c &gt;&gt; 2;
                    }
                }
                *ptr = '\0';
                RSTRING(buf)-&gt;len = ptr - RSTRING(buf)-&gt;ptr;
                rb_ary_push(ary, buf);
            }
            break;

          case 'M':
            {
                VALUE buf = infected_str_new(0, send - s, str);
                char *ptr = RSTRING(buf)-&gt;ptr;
                int c1, c2;

                while (s &lt; send) {
                    if (*s == '=') {
                        if (++s == send) break;
                       if (s+1 &lt; send &amp;&amp; *s == '\r' &amp;&amp; *(s+1) == '\n')
                         s++;
                        if (*s != '\n') {
                            if ((c1 = hex2num(*s)) == -1) break;
                            if (++s == send) break;
                            if ((c2 = hex2num(*s)) == -1) break;
                            *ptr++ = c1 &lt;&lt; 4 | c2;
                        }
                    }
                    else {
                        *ptr++ = *s;
                    }
                    s++;
                }
                *ptr = '\0';
                RSTRING(buf)-&gt;len = ptr - RSTRING(buf)-&gt;ptr;
                rb_ary_push(ary, buf);
            }
            break;

          case '@':
            if (len &gt; RSTRING(str)-&gt;len)
                rb_raise(rb_eArgError, &quot;@ outside of string&quot;);
            s = RSTRING(str)-&gt;ptr + len;
            break;

          case 'X':
            if (len &gt; s - RSTRING(str)-&gt;ptr)
                rb_raise(rb_eArgError, &quot;X outside of string&quot;);
            s -= len;
            break;

          case 'x':
            if (len &gt; send - s)
                rb_raise(rb_eArgError, &quot;x outside of string&quot;);
            s += len;
            break;

          case 'P':
            if (sizeof(char *) &lt;= send - s) {
                VALUE tmp = Qnil;
                char *t;

                memcpy(&amp;t, s, sizeof(char *));
                s += sizeof(char *);

                if (t) {
                    VALUE a, *p, *pend;

                    if (!(a = rb_str_associated(str))) {
                        rb_raise(rb_eArgError, &quot;no associated pointer&quot;);
                    }
                    p = RARRAY(a)-&gt;ptr;
                    pend = p + RARRAY(a)-&gt;len;
                    while (p &lt; pend) {
                        if (TYPE(*p) == T_STRING &amp;&amp; RSTRING(*p)-&gt;ptr == t) {
                            if (len &lt; RSTRING(*p)-&gt;len) {
                                tmp = rb_tainted_str_new(t, len);
                                rb_str_associate(tmp, a);
                            }
                            else {
                                tmp = *p;
                            }
                            break;
                        }
                        p++;
                    }
                    if (p == pend) {
                        rb_raise(rb_eArgError, &quot;non associated pointer&quot;);
                    }
                }
                rb_ary_push(ary, tmp);
            }
            break;

          case 'p':
            if (len &gt; (send - s) / sizeof(char *))
                len = (send - s) / sizeof(char *);
            while (len-- &gt; 0) {
                if (send - s &lt; sizeof(char *))
                    break;
                else {
                    VALUE tmp = Qnil;
                    char *t;

                    memcpy(&amp;t, s, sizeof(char *));
                    s += sizeof(char *);

                    if (t) {
                        VALUE a, *p, *pend;

                        if (!(a = rb_str_associated(str))) {
                            rb_raise(rb_eArgError, &quot;no associated pointer&quot;);
                        }
                        p = RARRAY(a)-&gt;ptr;
                        pend = p + RARRAY(a)-&gt;len;
                        while (p &lt; pend) {
                            if (TYPE(*p) == T_STRING &amp;&amp; RSTRING(*p)-&gt;ptr == t) {
                                tmp = *p;
                                break;
                            }
                            p++;
                        }
                        if (p == pend) {
                            rb_raise(rb_eArgError, &quot;non associated pointer&quot;);
                        }
                    }
                    rb_ary_push(ary, tmp);
                }
            }
            break;

          case 'w':
            {
                unsigned long ul = 0;
                unsigned long ulmask = 0xfeUL &lt;&lt; ((sizeof(unsigned long) - 1) * 8);

                while (len &gt; 0 &amp;&amp; s &lt; send) {
                    ul &lt;&lt;= 7;
                    ul |= (*s &amp; 0x7f);
                    if (!(*s++ &amp; 0x80)) {
                        rb_ary_push(ary, ULONG2NUM(ul));
                        len--;
                        ul = 0;
                    }
                    else if (ul &amp; ulmask) {
                        VALUE big = rb_uint2big(ul);
                        VALUE big128 = rb_uint2big(128);
                        while (s &lt; send) {
                            big = rb_big_mul(big, big128);
                            big = rb_big_plus(big, rb_uint2big(*s &amp; 0x7f));
                            if (!(*s++ &amp; 0x80)) {
                                rb_ary_push(ary, big);
                                len--;
                                ul = 0;
                                break;
                            }
                        }
                    }
                }
            }
            break;

          default:
            break;
        }
    }

    return ary;
}
</pre>
  </div>
</div>
</div>
<div id="M000778" class="method">
  <div id="M000778_title" class="title">
    <b>str.upcase   => new_str<br />
</b>
  </div>
  <div class="description">
  <p>
Returns a copy of <em>str</em> with all lowercase letters replaced with
their uppercase counterparts. The operation is locale
insensitive&#8212;only characters ``a&#8217;&#8217; to ``z&#8217;&#8217;
are affected.
</p>
<pre>
   &quot;hEllO&quot;.upcase   #=&gt; &quot;HELLO&quot;
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000778_source')" id="l_M000778_source">show source</a> ]</p>
  <div id="M000778_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.upcase   =&gt; new_str
 *  
 *  Returns a copy of &lt;i&gt;str&lt;/i&gt; with all lowercase letters replaced with their
 *  uppercase counterparts. The operation is locale insensitive---only
 *  characters ``a'' to ``z'' are affected.
 *     
 *     &quot;hEllO&quot;.upcase   #=&gt; &quot;HELLO&quot;
 */

static VALUE
rb_str_upcase(str)
    VALUE str;
{
    str = rb_str_dup(str);
    rb_str_upcase_bang(str);
    return str;
}
</pre>
  </div>
</div>
</div>
<div id="M000782" class="method">
  <div id="M000782_title" class="title">
    <b>str.upcase!   => str or nil<br />
</b>
  </div>
  <div class="description">
  <p>
Upcases the contents of <em>str</em>, returning <tt>nil</tt> if no changes
were made.
</p>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000782_source')" id="l_M000782_source">show source</a> ]</p>
  <div id="M000782_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.upcase!   =&gt; str or nil
 *  
 *  Upcases the contents of &lt;i&gt;str&lt;/i&gt;, returning &lt;code&gt;nil&lt;/code&gt; if no changes
 *  were made.
 */

static VALUE
rb_str_upcase_bang(str)
    VALUE str;
{
    char *s, *send;
    int modify = 0;

    rb_str_modify(str);
    s = RSTRING(str)-&gt;ptr; send = s + RSTRING(str)-&gt;len;
    while (s &lt; send) {
        if (ismbchar(*s)) {
            s+=mbclen(*s) - 1;
        }
        else if (ISLOWER(*s)) {
            *s = toupper(*s);
            modify = 1;
        }
        s++;
    }

    if (modify) return str;
    return Qnil;
}
</pre>
  </div>
</div>
</div>
<div id="M000768" class="method">
  <div id="M000768_title" class="title">
    <b>str.upto(other_str, exclusive=false) {|s| block }   => str<br />
</b>
  </div>
  <div class="description">
  <p>
Iterates through successive values, starting at <em>str</em> and ending at
<em>other_str</em> inclusive, passing each value in turn to the block. The
<tt><a href="index.html?a=M000764&name=String#succ">String#succ</a></tt>
method is used to generate each value. If optional second argument
exclusive is omitted or is <tt>false</tt>, the last value will be included;
otherwise it will be excluded.
</p>
<pre>
   &quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, ' ' }
   for s in &quot;a8&quot;..&quot;b6&quot;
     print s, ' '
   end
</pre>
<p>
<em>produces:</em>
</p>
<pre>
   a8 a9 b0 b1 b2 b3 b4 b5 b6
   a8 a9 b0 b1 b2 b3 b4 b5 b6
</pre>
  </div>
<div class="sourcecode">
  <p class="source-link">[ <a href="javascript:toggleSource('M000768_source')" id="l_M000768_source">show source</a> ]</p>
  <div id="M000768_source" class="dyn-source">
<pre>
/*
 *  call-seq:
 *     str.upto(other_str, exclusive=false) {|s| block }   =&gt; str
 *  
 *  Iterates through successive values, starting at &lt;i&gt;str&lt;/i&gt; and
 *  ending at &lt;i&gt;other_str&lt;/i&gt; inclusive, passing each value in turn to
 *  the block. The &lt;code&gt;String#succ&lt;/code&gt; method is used to generate
 *  each value.  If optional second argument exclusive is omitted or is &lt;code&gt;false&lt;/code&gt;,
 *  the last value will be included; otherwise it will be excluded.
 *     
 *     &quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, ' ' }
 *     for s in &quot;a8&quot;..&quot;b6&quot;
 *       print s, ' '
 *     end
 *     
 *  &lt;em&gt;produces:&lt;/em&gt;
 *     
 *     a8 a9 b0 b1 b2 b3 b4 b5 b6
 *     a8 a9 b0 b1 b2 b3 b4 b5 b6
 */

static VALUE
rb_str_upto_m(argc, argv, beg)
    int argc;
    VALUE *argv;
    VALUE beg;
{
    VALUE end, exclusive;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;end, &amp;exclusive);

    return rb_str_upto(beg, end, RTEST(exclusive));
}
</pre>
  </div>
</div>
</div>
</div>

  </div>