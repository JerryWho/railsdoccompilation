  <div id="fileHeader">
    <h1>nokogiri.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/nokogiri.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:03:28 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># -*- coding: utf-8 -*-
# Modify the PATH on windows so that the external DLLs will get loaded.
ENV['PATH'] = [File.expand_path(
  File.join(File.dirname(__FILE__), &quot;..&quot;, &quot;ext&quot;, &quot;nokogiri&quot;)
), ENV['PATH']].compact.join(';') if RUBY_PLATFORM =~ /(mswin|mingw)/i

if ENV['NOKOGIRI_FFI'] || RUBY_PLATFORM =~ /java/
  gem 'ffi', '&gt;=0.4.0' unless RUBY_PLATFORM =~ /java/
  require 'ffi'
  require 'nokogiri/ffi/libxml'
else
  require 'nokogiri/nokogiri'
end

require 'nokogiri/version'
require 'nokogiri/version_warning'
require 'nokogiri/syntax_error'
require 'nokogiri/xml'
require 'nokogiri/xslt'
require 'nokogiri/html'
require 'nokogiri/decorators'
require 'nokogiri/css'
require 'nokogiri/html/builder'
require 'nokogiri/hpricot'

# Nokogiri parses and searches XML/HTML very quickly, and also has
# correctly implemented CSS3 selector support as well as XPath support.
#
# Parsing a document returns either a Nokogiri::XML::Document, or a
# Nokogiri::HTML::Document depending on the kind of document you parse.
#
# Here is an example:
#
#   require 'nokogiri'
#   require 'open-uri'
#
#   # Get a Nokogiri::HTML:Document for the page weâ€™re interested in...
#
#   doc = Nokogiri::HTML(open('http://www.google.com/search?q=tenderlove'))
#
#   # Do funky things with it using Nokogiri::XML::Node methods...
#
#   ####
#   # Search for nodes by css
#   doc.css('h3.r a.l').each do |link|
#     puts link.content
#   end
#
# See Nokogiri::XML::Node#css for more information about CSS searching.
# See Nokogiri::XML::Node#xpath for more information about XPath searching.
module Nokogiri
  class &lt;&lt; self
    ###
    # Parse an HTML or XML document.  +string+ contains the document.
    def parse string, url = nil, encoding = nil, options = nil
      doc =
        if string.respond_to?(:read) ||
          string =~ /^\s*&lt;[^Hh&gt;]*html/i # Probably html
          Nokogiri::HTML(
            string,
            url,
            encoding, options || XML::ParseOptions::DEFAULT_HTML
          )
        else
          Nokogiri::XML(string, url, encoding,
                        options || XML::ParseOptions::DEFAULT_XML)
        end
      yield doc if block_given?
      doc
    end

    ###
    # Create a new Nokogiri::XML::DocumentFragment
    def make input = nil, opts = {}, &amp;blk
      if input
        Nokogiri::HTML.fragment(input).children.first
      else
        Nokogiri(&amp;blk)
      end
    end

    ###
    # Parse a document and add the Slop decorator.  The Slop decorator
    # implements method_missing such that methods may be used instead of CSS
    # or XPath.  For example:
    #
    #   doc = Nokogiri::Slop(&lt;&lt;-eohtml)
    #     &lt;html&gt;
    #       &lt;body&gt;
    #         &lt;p&gt;first&lt;/p&gt;
    #         &lt;p&gt;second&lt;/p&gt;
    #       &lt;/body&gt;
    #     &lt;/html&gt;
    #   eohtml
    #   assert_equal('second', doc.html.body.p[1].text)
    #
    def Slop(*args, &amp;block)
      Nokogiri(*args, &amp;block).slop!
    end
  end
end

###
# Parser a document contained in +args+.  Nokogiri will try to guess what
# type of document you are attempting to parse.  For more information, see
# Nokogiri.parse
#
# To specify the type of document, use Nokogiri.XML or Nokogiri.HTML.
def Nokogiri(*args, &amp;block)
  if block_given?
    builder = Nokogiri::HTML::Builder.new(&amp;block)
    return builder.doc.root
  else
    Nokogiri.parse(*args)
  end
end
</pre>
    </div>