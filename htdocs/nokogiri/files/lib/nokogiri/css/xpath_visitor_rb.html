  <div id="fileHeader">
    <h1>xpath_visitor.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/nokogiri/css/xpath_visitor.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Dec 11 22:21:01 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Nokogiri
  module CSS
    class XPathVisitor # :nodoc:
      def visit_function node
        #  note that nth-child and nth-last-child are preprocessed in css/node.rb.
        msg = :&quot;visit_function_#{node.value.first.gsub(/[(]/, '')}&quot;
        return self.send(msg, node) if self.respond_to?(msg)

        case node.value.first
        when /^text\(/
          'child::text()'
        when /^self\(/
          &quot;self::#{node.value[1]}&quot;
        when /^(eq|nth|nth-of-type|nth-child)\(/
          if node.value[1].is_a?(Nokogiri::CSS::Node) and node.value[1].type == :AN_PLUS_B
            an_plus_b(node.value[1])
          else
            &quot;position() = &quot; + node.value[1]
          end
        when /^(first|first-of-type)\(/
          &quot;position() = 1&quot;
        when /^(last|last-of-type)\(/
          &quot;position() = last()&quot;
        when /^(nth-last-child|nth-last-of-type)\(/
          &quot;position() = last() - #{node.value[1]}&quot;
        when /^contains\(/
          &quot;contains(., #{node.value[1]})&quot;
        when /^gt\(/
          &quot;position() &gt; #{node.value[1]}&quot;
        when /^only-child\(/
          &quot;last() = 1&quot;
        when /^comment\(/
          &quot;comment()&quot;
        when /^has\(/
          node.value[1].accept(self)
        else
          args = ['.'] + node.value[1..-1]
          &quot;#{node.value.first}#{args.join(', ')})&quot;
        end
      end

      def visit_not node
        'not(' + node.value.first.accept(self) + ')'
      end

      def visit_preceding_selector node
        node.value.last.accept(self) +
          '[preceding-sibling::' +
          node.value.first.accept(self) +
          ']'
      end

      def visit_id node
        node.value.first =~ /^#(.*)$/
        &quot;@id = '#{$1}'&quot;
      end

      def visit_attribute_condition node
         attribute = if (node.value.first.type == :FUNCTION) or (node.value.first.value.first =~ /::/)
                       ''
                     else
                       '@'
                     end
        attribute += node.value.first.accept(self)

        # Support non-standard css
        attribute.gsub!(/^@@/, '@')

        return attribute unless node.value.length == 3

        value = node.value.last
        value = &quot;'#{value}'&quot; if value !~ /^['&quot;]/

        case node.value[1]
        when :equal
          attribute + &quot; = &quot; + &quot;#{value}&quot;
        when :not_equal
          attribute + &quot; != &quot; + &quot;#{value}&quot;
        when :substring_match
          &quot;contains(#{attribute}, #{value})&quot;
        when :prefix_match
          &quot;starts-with(#{attribute}, #{value})&quot;
        when :dash_match
          &quot;#{attribute} = #{value} or starts-with(#{attribute}, concat(#{value}, '-'))&quot;
        when :includes
          &quot;contains(concat(\&quot; \&quot;, #{attribute}, \&quot; \&quot;),concat(\&quot; \&quot;, #{value}, \&quot; \&quot;))&quot;
        when :suffix_match
          &quot;substring(#{attribute}, string-length(#{attribute}) - &quot; +
            &quot;string-length(#{value}) + 1, string-length(#{value})) = #{value}&quot;
        else
          attribute + &quot; #{node.value[1]} &quot; + &quot;#{value}&quot;
        end
      end

      def visit_pseudo_class node
        if node.value.first.is_a?(Nokogiri::CSS::Node) and node.value.first.type == :FUNCTION
          node.value.first.accept(self)
        else
          msg = :&quot;visit_pseudo_class_#{node.value.first.gsub(/[(]/, '')}&quot;
          return self.send(msg, node) if self.respond_to?(msg)

          case node.value.first
          when &quot;first&quot; then &quot;position() = 1&quot;
          when &quot;last&quot; then &quot;position() = last()&quot;
          when &quot;first-of-type&quot; then &quot;position() = 1&quot;
          when &quot;last-of-type&quot; then &quot;position() = last()&quot;
          when &quot;only-of-type&quot; then &quot;last() = 1&quot;
          when &quot;empty&quot; then &quot;not(node())&quot;
          when &quot;parent&quot; then &quot;node()&quot;
          when &quot;root&quot; then &quot;not(parent::*)&quot;
          else
            node.value.first + &quot;(.)&quot;
          end
        end
      end

      def visit_class_condition node
        &quot;contains(concat(' ', @class, ' '), ' #{node.value.first} ')&quot;
      end

      {
        'combinator'                =&gt; ' and ',
        'direct_adjacent_selector'  =&gt; &quot;/following-sibling::*[1]/self::&quot;,
        'descendant_selector'       =&gt; '//',
        'child_selector'            =&gt; '/',
      }.each do |k,v|
        class_eval %{
          def visit_#{k} node
            &quot;\#{node.value.first.accept(self)}#{v}\#{node.value.last.accept(self)}&quot;
          end
        }
      end

      def visit_conditional_selector node
        node.value.first.accept(self) + '[' +
        node.value.last.accept(self) + ']'
      end

      def visit_element_name node
        node.value.first
      end

      def accept node
        node.accept(self)
      end

    private
      def an_plus_b node
        raise ArgumentError, &quot;expected an+b node to contain 4 tokens, but is #{node.value.inspect}&quot; unless node.value.size == 4

        a = node.value[0].to_i
        b = node.value[3].to_i

        if (b == 0)
          return &quot;(position() mod #{a}) = 0&quot;
        else
          compare = (a &lt; 0) ? &quot;&lt;=&quot; : &quot;&gt;=&quot;
          return &quot;(position() #{compare} #{b}) and (((position()-#{b}) mod #{a.abs}) = 0)&quot;
        end
      end

    end
  end
end
</pre>
    </div>