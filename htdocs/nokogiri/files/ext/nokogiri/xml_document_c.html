  <div id="fileHeader">
    <h1>xml_document.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ext/nokogiri/xml_document.c</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:03:28 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#include &lt;xml_document.h&gt;

static int dealloc_node_i(xmlNodePtr key, xmlNodePtr node, xmlDocPtr doc)
{
  switch(node-&gt;type) {
  case XML_ATTRIBUTE_NODE:
    xmlFreePropList((xmlAttrPtr)node);
    break;
  default:
    if(node-&gt;parent == NULL) {
      xmlAddChild((xmlNodePtr)doc, node);
    }
  }
  return ST_CONTINUE;
}

static void dealloc(xmlDocPtr doc)
{
  NOKOGIRI_DEBUG_START(doc);

  st_table *node_hash = DOC_UNLINKED_NODE_HASH(doc);

  xmlDeregisterNodeFunc func = xmlDeregisterNodeDefault(NULL);

  st_foreach(node_hash, dealloc_node_i, (st_data_t)doc);
  st_free_table(node_hash);

  free(doc-&gt;_private);
  doc-&gt;_private = NULL;
  xmlFreeDoc(doc);

  xmlDeregisterNodeDefault(func);

  NOKOGIRI_DEBUG_END(doc);
}

/*
 * call-seq:
 *  url
 *
 * Get the url name for this document.
 */
static VALUE url(VALUE self)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  if(doc-&gt;URL)
    return NOKOGIRI_STR_NEW2(doc-&gt;URL, doc-&gt;encoding);

  return Qnil;
}

/*
 * call-seq:
 *  root=
 *
 * Set the root element on this document
 */
static VALUE set_root(VALUE self, VALUE root)
{
  xmlDocPtr doc;
  xmlNodePtr new_root;

  Data_Get_Struct(self, xmlDoc, doc);
  Data_Get_Struct(root, xmlNode, new_root);

  xmlNodePtr old_root = NULL;

  /* If the new root's document is not the same as the current document,
   * then we need to dup the node in to this document. */
  if(new_root-&gt;doc != doc) {
    old_root = xmlDocGetRootElement(doc);
    if (!(new_root = xmlDocCopyNode(new_root, doc, 1))) {
      rb_raise(rb_eRuntimeError, &quot;Could not reparent node (xmlDocCopyNode)&quot;);
    }
  }

  xmlDocSetRootElement(doc, new_root);
  if(old_root) NOKOGIRI_ROOT_NODE(old_root);
  return root;
}

/*
 * call-seq:
 *  root
 *
 * Get the root node for this document.
 */
static VALUE root(VALUE self)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  xmlNodePtr root = xmlDocGetRootElement(doc);

  if(!root) return Qnil;
  return Nokogiri_wrap_xml_node(Qnil, root) ;
}

/*
 * call-seq:
 *  encoding= encoding
 *
 * Set the encoding string for this Document
 */
static VALUE set_encoding(VALUE self, VALUE encoding)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  doc-&gt;encoding = xmlStrdup((xmlChar *)StringValuePtr(encoding));

  return encoding;
}

/*
 * call-seq:
 *  encoding
 *
 * Get the encoding for this Document
 */
static VALUE encoding(VALUE self)
{
  xmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  if(!doc-&gt;encoding) return Qnil;
  return NOKOGIRI_STR_NEW2(doc-&gt;encoding, doc-&gt;encoding);
}

/*
 * call-seq:
 *  read_io(io, url, encoding, options)
 *
 * Create a new document from an IO object
 */
static VALUE read_io( VALUE klass,
                      VALUE io,
                      VALUE url,
                      VALUE encoding,
                      VALUE options )
{
  const char * c_url    = (url == Qnil) ? NULL : StringValuePtr(url);
  const char * c_enc    = (encoding == Qnil) ? NULL : StringValuePtr(encoding);
  VALUE error_list      = rb_ary_new();

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

  xmlDocPtr doc = xmlReadIO(
      (xmlInputReadCallback)io_read_callback,
      (xmlInputCloseCallback)io_close_callback,
      (void *)io,
      c_url,
      c_enc,
      NUM2INT(options)
  );
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(doc == NULL) {
    xmlFreeDoc(doc);

    xmlErrorPtr error = xmlGetLastError();
    if(error)
      rb_funcall(rb_mKernel, rb_intern(&quot;raise&quot;), 1,
          Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error)
      );
    else
      rb_raise(rb_eRuntimeError, &quot;Could not parse document&quot;);

    return Qnil;
  }

  VALUE document = Nokogiri_wrap_xml_document(klass, doc);
  rb_funcall(document, rb_intern(&quot;errors=&quot;), 1, error_list);
  return document;
}

/*
 * call-seq:
 *  read_memory(string, url, encoding, options)
 *
 * Create a new document from a String
 */
static VALUE read_memory( VALUE klass,
                          VALUE string,
                          VALUE url,
                          VALUE encoding,
                          VALUE options )
{
  const char * c_buffer = StringValuePtr(string);
  const char * c_url    = (url == Qnil) ? NULL : StringValuePtr(url);
  const char * c_enc    = (encoding == Qnil) ? NULL : StringValuePtr(encoding);
  int len               = RSTRING_LEN(string);
  VALUE error_list      = rb_ary_new();

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);
  xmlDocPtr doc = xmlReadMemory(c_buffer, len, c_url, c_enc, NUM2INT(options));
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(doc == NULL) {
    xmlFreeDoc(doc);

    xmlErrorPtr error = xmlGetLastError();
    if(error)
      rb_funcall(rb_mKernel, rb_intern(&quot;raise&quot;), 1,
          Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error)
      );
    else
      rb_raise(rb_eRuntimeError, &quot;Could not parse document&quot;);

    return Qnil;
  }

  VALUE document = Nokogiri_wrap_xml_document(klass, doc);
  rb_funcall(document, rb_intern(&quot;errors=&quot;), 1, error_list);
  return document;
}

/*
 * call-seq:
 *  dup
 *
 * Copy this Document.  An optional depth may be passed in, but it defaults
 * to a deep copy.  0 is a shallow copy, 1 is a deep copy.
 */
static VALUE duplicate_node(int argc, VALUE *argv, VALUE self)
{
  VALUE level;

  if(rb_scan_args(argc, argv, &quot;01&quot;, &amp;level) == 0)
    level = INT2NUM(1);

  xmlDocPtr doc, dup;
  Data_Get_Struct(self, xmlDoc, doc);

  dup = xmlCopyDoc(doc, NUM2INT(level));
  if(dup == NULL) return Qnil;

  dup-&gt;type = doc-&gt;type;
  return Nokogiri_wrap_xml_document(RBASIC(self)-&gt;klass, dup);
}

/*
 * call-seq:
 *  new(version = default)
 *
 * Create a new document with +version+ (defaults to &quot;1.0&quot;)
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  VALUE version, rest, rb_doc ;

  rb_scan_args(argc, argv, &quot;0*&quot;, &amp;rest);
  version = rb_ary_entry(rest, 0);
  if (version == Qnil) {
    version = rb_str_new2(&quot;1.0&quot;);
  }

  xmlDocPtr doc = xmlNewDoc((xmlChar *)StringValuePtr(version));
  rb_doc = Nokogiri_wrap_xml_document(klass, doc);
  rb_funcall2(rb_doc, rb_intern(&quot;initialize&quot;), argc, argv);
  return rb_doc ;
}

VALUE cNokogiriXmlDocument ;
void init_xml_document()
{
  VALUE nokogiri  = rb_define_module(&quot;Nokogiri&quot;);
  VALUE xml       = rb_define_module_under(nokogiri, &quot;XML&quot;);
  VALUE node      = rb_define_class_under(xml, &quot;Node&quot;, rb_cObject);

  /*
   * Nokogiri::XML::Document wraps an xml document.
   */
  VALUE klass = rb_define_class_under(xml, &quot;Document&quot;, node);

  cNokogiriXmlDocument = klass;

  rb_define_singleton_method(klass, &quot;read_memory&quot;, read_memory, 4);
  rb_define_singleton_method(klass, &quot;read_io&quot;, read_io, 4);
  rb_define_singleton_method(klass, &quot;new&quot;, new, -1);

  rb_define_method(klass, &quot;root&quot;, root, 0);
  rb_define_method(klass, &quot;root=&quot;, set_root, 1);
  rb_define_method(klass, &quot;encoding&quot;, encoding, 0);
  rb_define_method(klass, &quot;encoding=&quot;, set_encoding, 1);
  rb_define_method(klass, &quot;dup&quot;, duplicate_node, -1);
  rb_define_method(klass, &quot;url&quot;, url, 0);
}


/* this takes klass as a param because it's used for HtmlDocument, too. */
VALUE Nokogiri_wrap_xml_document(VALUE klass, xmlDocPtr doc)
{
  nokogiriTuplePtr tuple = (nokogiriTuplePtr)malloc(sizeof(nokogiriTuple));

  VALUE rb_doc = Data_Wrap_Struct(
      klass ? klass : cNokogiriXmlDocument,
      0,
      dealloc,
      doc
  );

  VALUE cache = rb_ary_new();
  rb_iv_set(rb_doc, &quot;@decorators&quot;, Qnil);
  rb_iv_set(rb_doc, &quot;@node_cache&quot;, cache);
  rb_funcall(rb_doc, rb_intern(&quot;initialize&quot;), 0);

  tuple-&gt;doc = (void *)rb_doc;
  tuple-&gt;unlinkedNodes = st_init_numtable_with_size(128);
  tuple-&gt;node_cache = cache;
  doc-&gt;_private = tuple ;

  return rb_doc ;
}
</pre>
    </div>