  <div id="fileHeader">
    <h1>xml_reader.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ext/nokogiri/xml_reader.c</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:03:28 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#include &lt;xml_reader.h&gt;

static void dealloc(xmlTextReaderPtr reader)
{
  NOKOGIRI_DEBUG_START(reader);
  xmlFreeTextReader(reader);
  NOKOGIRI_DEBUG_END(reader);
}

static int has_attributes(xmlTextReaderPtr reader)
{
  /*
   *  this implementation of xmlTextReaderHasAttributes explicitly includes
   *  namespaces and properties, because some earlier versions ignore
   *  namespaces.
   */
  xmlNodePtr node ;
  node = xmlTextReaderCurrentNode(reader);
  if (node == NULL)
    return(0);

  if ((node-&gt;type == XML_ELEMENT_NODE) &amp;&amp;
      ((node-&gt;properties != NULL) || (node-&gt;nsDef != NULL)))
    return(1);
  return(0);
}

#define XMLNS_PREFIX &quot;xmlns&quot;
#define XMLNS_PREFIX_LEN 6 /* including either colon or \0 */
#define XMLNS_BUFFER_LEN 128
static void Nokogiri_xml_node_namespaces(xmlNodePtr node, VALUE attr_hash)
{
  xmlNsPtr ns;
  static char buffer[XMLNS_BUFFER_LEN] ;
  char *key ;
  size_t keylen ;

  if (node-&gt;type != XML_ELEMENT_NODE) return ;

  ns = node-&gt;nsDef;
  while (ns != NULL) {

    keylen = XMLNS_PREFIX_LEN + (ns-&gt;prefix ? (strlen((const char*)ns-&gt;prefix) + 1) : 0) ;
    if (keylen &gt; XMLNS_BUFFER_LEN) {
      key = (char*)malloc(keylen) ;
    } else {
      key = buffer ;
    }

    if (ns-&gt;prefix) {
      sprintf(key, &quot;%s:%s&quot;, XMLNS_PREFIX, ns-&gt;prefix);
    } else {
      sprintf(key, &quot;%s&quot;, XMLNS_PREFIX);
    }

    rb_hash_aset(attr_hash,
        NOKOGIRI_STR_NEW2(key, node-&gt;doc-&gt;encoding),
        (ns-&gt;href ? NOKOGIRI_STR_NEW2(ns-&gt;href, node-&gt;doc-&gt;encoding) : Qnil)
    );
    if (key != buffer) {
      free(key);
    }
    ns = ns-&gt;next ;
  }
}


/*
 * call-seq:
 *   default?
 *
 * Was an attribute generated from the default value in the DTD or schema?
 */
static VALUE default_eh(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  int eh = xmlTextReaderIsDefault(reader);
  if(eh == 0) return Qfalse;
  if(eh == 1) return Qtrue;

  return Qnil;
}

/*
 * call-seq:
 *   value?
 *
 * Does this node have a text value?
 */
static VALUE value_eh(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  int eh = xmlTextReaderHasValue(reader);
  if(eh == 0) return Qfalse;
  if(eh == 1) return Qtrue;

  return Qnil;
}

/*
 * call-seq:
 *   attributes?
 *
 * Does this node have attributes?
 */
static VALUE attributes_eh(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  int eh = has_attributes(reader);
  if(eh == 0) return Qfalse;
  if(eh == 1) return Qtrue;

  return Qnil;
}

/*
 * call-seq:
 *   namespaces
 *
 * Get a hash of namespaces for this Node
 */
static VALUE namespaces(VALUE self)
{
  xmlTextReaderPtr reader;
  VALUE attr ;

  Data_Get_Struct(self, xmlTextReader, reader);

  attr = rb_hash_new() ;

  if (! has_attributes(reader))
    return attr ;

  xmlNodePtr ptr = xmlTextReaderExpand(reader);
  if(ptr == NULL) return Qnil;

  Nokogiri_xml_node_namespaces(ptr, attr);

  return attr ;
}

/*
 * call-seq:
 *   attribute_nodes
 *
 * Get a list of attributes for this Node
 */
static VALUE attribute_nodes(VALUE self)
{
  xmlTextReaderPtr reader;
  VALUE attr ;

  Data_Get_Struct(self, xmlTextReader, reader);

  attr = rb_ary_new() ;

  if (! has_attributes(reader))
    return attr ;

  xmlNodePtr ptr = xmlTextReaderExpand(reader);
  if(ptr == NULL) return Qnil;

  VALUE enc = rb_iv_get(self, &quot;@encoding&quot;);

  if(enc != Qnil &amp;&amp; NULL == ptr-&gt;doc-&gt;encoding) {
    ptr-&gt;doc-&gt;encoding = calloc((size_t)RSTRING_LEN(enc), sizeof(char));
    strncpy(
      (char *)ptr-&gt;doc-&gt;encoding,
      StringValuePtr(enc),
      (size_t)RSTRING_LEN(enc)
    );
  }

  Nokogiri_xml_node_properties(ptr, attr);

  return attr ;
}

/*
 * call-seq:
 *   attribute_at(index)
 *
 * Get the value of attribute at +index+
 */
static VALUE attribute_at(VALUE self, VALUE index)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);

  if(index == Qnil) return Qnil;
  index = rb_funcall(index, rb_intern(&quot;to_i&quot;), 0);

  xmlChar * value = xmlTextReaderGetAttributeNo(
      reader,
      NUM2INT(index)
  );
  if(value == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  VALUE rb_value = NOKOGIRI_STR_NEW2(value,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
  xmlFree(value);
  return rb_value;
}

/*
 * call-seq:
 *   attribute(name)
 *
 * Get the value of attribute named +name+
 */
static VALUE reader_attribute(VALUE self, VALUE name)
{
  xmlTextReaderPtr reader;
  xmlChar *value ;
  Data_Get_Struct(self, xmlTextReader, reader);

  if(name == Qnil) return Qnil;
  name = StringValue(name) ;

  value = xmlTextReaderGetAttribute(reader, (xmlChar*)StringValuePtr(name));
  if(value == NULL) {
    /* this section is an attempt to workaround older versions of libxml that
       don't handle namespaces properly in all attribute-and-friends functions */
    xmlChar *prefix = NULL ;
    xmlChar *localname = xmlSplitQName2((xmlChar*)StringValuePtr(name), &amp;prefix);
    if (localname != NULL) {
      value = xmlTextReaderLookupNamespace(reader, localname);
      xmlFree(localname) ;
    } else {
      value = xmlTextReaderLookupNamespace(reader, prefix);
    }
    xmlFree(prefix);
  }
  if(value == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  VALUE rb_value = NOKOGIRI_STR_NEW2(value,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
  xmlFree(value);
  return rb_value;
}

/*
 * call-seq:
 *   attribute_count
 *
 * Get the number of attributes for the current node
 */
static VALUE attribute_count(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  int count = xmlTextReaderAttributeCount(reader);
  if(count == -1) return Qnil;

  return INT2NUM(count);
}

/*
 * call-seq:
 *   depth
 *
 * Get the depth of the node
 */
static VALUE depth(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  int depth = xmlTextReaderDepth(reader);
  if(depth == -1) return Qnil;

  return INT2NUM(depth);
}

/*
 * call-seq:
 *   xml_version
 *
 * Get the XML version of the document being read
 */
static VALUE xml_version(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  const char * version = (const char *)xmlTextReaderConstXmlVersion(reader);
  if(version == NULL) return Qnil;

  return NOKOGIRI_STR_NEW2(version, &quot;UTF-8&quot;);
}

/*
 * call-seq:
 *   lang
 *
 * Get the xml:lang scope within which the node resides.
 */
static VALUE lang(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  const char * lang = (const char *)xmlTextReaderConstXmlLang(reader);
  if(lang == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  return NOKOGIRI_STR_NEW2(lang,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
}

/*
 * call-seq:
 *   value
 *
 * Get the text value of the node if present
 */
static VALUE value(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  const char * value = (const char *)xmlTextReaderConstValue(reader);
  if(value == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  return NOKOGIRI_STR_NEW2(value,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
}

/*
 * call-seq:
 *   prefix
 *
 * Get the shorthand reference to the namespace associated with the node.
 */
static VALUE prefix(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  const char * prefix = (const char *)xmlTextReaderConstPrefix(reader);
  if(prefix == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  return NOKOGIRI_STR_NEW2(prefix,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
}

/*
 * call-seq:
 *   namespace_uri
 *
 * Get the URI defining the namespace associated with the node
 */
static VALUE namespace_uri(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  const char * uri = (const char *)xmlTextReaderConstNamespaceUri(reader);
  if(uri == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  return NOKOGIRI_STR_NEW2(uri,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
}

/*
 * call-seq:
 *   local_name
 *
 * Get the local name of the node
 */
static VALUE local_name(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  const char * name = (const char *)xmlTextReaderConstLocalName(reader);
  if(name == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  return NOKOGIRI_STR_NEW2(name,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
}

/*
 * call-seq:
 *   name
 *
 * Get the name of the node
 */
static VALUE name(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  const char * name = (const char *)xmlTextReaderConstName(reader);
  if(name == NULL) return Qnil;

  VALUE MAYBE_UNUSED(enc) = rb_iv_get(self, &quot;@encoding&quot;);
  return NOKOGIRI_STR_NEW2(name,
      RTEST(enc) ? StringValuePtr(enc) : NULL);
}

/*
 * call-seq:
 *   state
 *
 * Get the state of the reader
 */
static VALUE state(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);
  return INT2NUM(xmlTextReaderReadState(reader));
}

/*
 * call-seq:
 *   read
 *
 * Move the Reader forward through the XML document.
 */
static VALUE read_more(VALUE self)
{
  xmlTextReaderPtr reader;
  Data_Get_Struct(self, xmlTextReader, reader);

  VALUE error_list = rb_funcall(self, rb_intern(&quot;errors&quot;), 0);

  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);
  int ret = xmlTextReaderRead(reader);
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(ret == 1) return self;
  if(ret == 0) return Qnil;

  xmlErrorPtr error = xmlGetLastError();
  if(error)
    rb_funcall(rb_mKernel, rb_intern(&quot;raise&quot;), 1,
        Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error)
    );
  else
    rb_raise(rb_eRuntimeError, &quot;Error pulling: %d&quot;, ret);

  return Qnil;
}

/*
 * call-seq:
 *   from_memory(string, url = nil, encoding = nil, options = 0)
 *
 * Create a new reader that parses +string+
 */
static VALUE from_memory(int argc, VALUE *argv, VALUE klass)
{
  VALUE rb_buffer, rb_url, encoding, rb_options;

  const char * c_url      = NULL;
  const char * c_encoding = NULL;
  int c_options           = 0; 

  rb_scan_args(argc, argv, &quot;13&quot;, &amp;rb_buffer, &amp;rb_url, &amp;encoding, &amp;rb_options);

  if (!RTEST(rb_buffer)) rb_raise(rb_eArgError, &quot;string cannot be nil&quot;);
  if (RTEST(rb_url)) c_url = StringValuePtr(rb_url);
  if (RTEST(encoding)) c_encoding = StringValuePtr(encoding);
  if (RTEST(rb_options)) c_options = NUM2INT(rb_options);

  xmlTextReaderPtr reader = xmlReaderForMemory(
      StringValuePtr(rb_buffer),
      RSTRING_LEN(rb_buffer),
      c_url,
      c_encoding,
      c_options
  );

  if(reader == NULL) {
    xmlFreeTextReader(reader);
    rb_raise(rb_eRuntimeError, &quot;couldn't create a parser&quot;);
  }

  VALUE rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);
  rb_funcall(rb_reader, rb_intern(&quot;initialize&quot;), 3, rb_buffer, rb_url, encoding);

  return rb_reader;
}

/*
 * call-seq:
 *   from_io(io, url = nil, encoding = nil, options = 0)
 *
 * Create a new reader that parses +io+
 */
static VALUE from_io(int argc, VALUE *argv, VALUE klass)
{
  VALUE rb_io, rb_url, encoding, rb_options;

  const char * c_url      = NULL;
  const char * c_encoding = NULL;
  int c_options           = 0; 

  rb_scan_args(argc, argv, &quot;13&quot;, &amp;rb_io, &amp;rb_url, &amp;encoding, &amp;rb_options);

  if (!RTEST(rb_io)) rb_raise(rb_eArgError, &quot;io cannot be nil&quot;);
  if (RTEST(rb_url)) c_url = StringValuePtr(rb_url);
  if (RTEST(encoding)) c_encoding = StringValuePtr(encoding);
  if (RTEST(rb_options)) c_options = NUM2INT(rb_options);

  xmlTextReaderPtr reader = xmlReaderForIO(
      (xmlInputReadCallback)io_read_callback,
      (xmlInputCloseCallback)io_close_callback,
      (void *)rb_io,
      c_url,
      c_encoding,
      c_options
  );

  if(reader == NULL) {
    xmlFreeTextReader(reader);
    rb_raise(rb_eRuntimeError, &quot;couldn't create a parser&quot;);
  }

  VALUE rb_reader = Data_Wrap_Struct(klass, NULL, dealloc, reader);
  rb_funcall(rb_reader, rb_intern(&quot;initialize&quot;), 3, rb_io, rb_url, encoding);

  return rb_reader;
}

VALUE cNokogiriXmlReader;

void init_xml_reader()
{
  VALUE module = rb_define_module(&quot;Nokogiri&quot;);
  VALUE xml = rb_define_module_under(module, &quot;XML&quot;);

  /*
   * The Reader parser allows you to effectively pull parse an XML document.
   * Once instantiated, call Nokogiri::XML::Reader#each to iterate over each
   * node.  Note that you may only iterate over the document once!
   */
  VALUE klass = rb_define_class_under(xml, &quot;Reader&quot;, rb_cObject);

  cNokogiriXmlReader = klass;

  rb_define_singleton_method(klass, &quot;from_memory&quot;, from_memory, -1);
  rb_define_singleton_method(klass, &quot;from_io&quot;, from_io, -1);

  rb_define_method(klass, &quot;read&quot;, read_more, 0);
  rb_define_method(klass, &quot;state&quot;, state, 0);
  rb_define_method(klass, &quot;name&quot;, name, 0);
  rb_define_method(klass, &quot;local_name&quot;, local_name, 0);
  rb_define_method(klass, &quot;namespace_uri&quot;, namespace_uri, 0);
  rb_define_method(klass, &quot;prefix&quot;, prefix, 0);
  rb_define_method(klass, &quot;value&quot;, value, 0);
  rb_define_method(klass, &quot;lang&quot;, lang, 0);
  rb_define_method(klass, &quot;xml_version&quot;, xml_version, 0);
  rb_define_method(klass, &quot;depth&quot;, depth, 0);
  rb_define_method(klass, &quot;attribute_count&quot;, attribute_count, 0);
  rb_define_method(klass, &quot;attribute&quot;, reader_attribute, 1);
  rb_define_method(klass, &quot;namespaces&quot;, namespaces, 0);
  rb_define_method(klass, &quot;attribute_at&quot;, attribute_at, 1);
  rb_define_method(klass, &quot;attribute_nodes&quot;, attribute_nodes, 0);
  rb_define_method(klass, &quot;attributes?&quot;, attributes_eh, 0);
  rb_define_method(klass, &quot;value?&quot;, value_eh, 0);
  rb_define_method(klass, &quot;default?&quot;, default_eh, 0);
}
</pre>
    </div>