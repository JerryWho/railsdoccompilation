  <div id="fileHeader">
    <h1>xslt_stylesheet.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ext/nokogiri/xslt_stylesheet.c</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:03:28 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#include &lt;xslt_stylesheet.h&gt;

#include &lt;libxslt/xsltInternals.h&gt;
#include &lt;libxslt/xsltutils.h&gt;
#include &lt;libxslt/transform.h&gt;
#include &lt;libexslt/exslt.h&gt;

static void dealloc(xsltStylesheetPtr doc)
{
    NOKOGIRI_DEBUG_START(doc);
    xsltFreeStylesheet(doc); // commented out for now.
    NOKOGIRI_DEBUG_END(doc);
}

static void xslt_generic_error_handler(void * ctx, const char *msg, ...)
{
  char * message;

  va_list args;
  va_start(args, msg);
  vasprintf(&amp;message, msg, args);
  va_end(args);

  rb_raise(rb_eRuntimeError, message);
}

/*
 * call-seq:
 *   parse_stylesheet_doc(document)
 *
 * Parse a stylesheet from +document+.
 */
static VALUE parse_stylesheet_doc(VALUE klass, VALUE xmldocobj)
{
    xmlDocPtr xml ;
    xsltStylesheetPtr ss ;
    Data_Get_Struct(xmldocobj, xmlDoc, xml);
    exsltRegisterAll();

    xsltSetGenericErrorFunc(NULL, xslt_generic_error_handler);

    ss = xsltParseStylesheetDoc(xmlCopyDoc(xml, 1)); /* 1 =&gt; recursive */

    xsltSetGenericErrorFunc(NULL, NULL);

    return Data_Wrap_Struct(klass, NULL, dealloc, ss);
}


/*
 * call-seq:
 *   serialize(document)
 *
 * Serialize +document+ to an xml string.
 */
static VALUE serialize(VALUE self, VALUE xmlobj)
{
    xmlDocPtr xml ;
    xsltStylesheetPtr ss ;
    xmlChar* doc_ptr ;
    int doc_len ;
    VALUE rval ;

    Data_Get_Struct(xmlobj, xmlDoc, xml);
    Data_Get_Struct(self, xsltStylesheet, ss);
    xsltSaveResultToString(&amp;doc_ptr, &amp;doc_len, xml, ss);
    rval = NOKOGIRI_STR_NEW(doc_ptr, doc_len, xml-&gt;encoding);
    xmlFree(doc_ptr);
    return rval ;
}

/*
 *  call-seq:
 *    transform(document, params = [])
 *
 *  Apply an XSLT stylesheet to an XML::Document.
 *  +params+ is an array of strings used as XSLT parameters.
 *  returns Nokogiri::XML::Document
 *
 *  Example:
 * 
 *    doc   = Nokogiri::XML(File.read(ARGV[0]))
 *    xslt  = Nokogiri::XSLT(File.read(ARGV[1]))
 *    puts xslt.transform(doc, ['key', 'value'])
 *
 */
static VALUE transform(int argc, VALUE* argv, VALUE self)
{
    VALUE xmldoc, paramobj ;
    xmlDocPtr xml ;
    xmlDocPtr result ;
    xsltStylesheetPtr ss ;
    const char** params ;
    int param_len, j ;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;xmldoc, &amp;paramobj);
    if (paramobj == Qnil) { paramobj = rb_ary_new2(0) ; }

    Data_Get_Struct(xmldoc, xmlDoc, xml);
    Data_Get_Struct(self, xsltStylesheet, ss);

    param_len = NUM2INT(rb_funcall(paramobj, rb_intern(&quot;length&quot;), 0));
    params = calloc((size_t)param_len+1, sizeof(char*));
    for (j = 0 ; j &lt; param_len ; j++) {
      VALUE entry = rb_ary_entry(paramobj, j);
      const char * ptr = StringValuePtr(entry);
      params[j] = ptr;
    }
    params[param_len] = 0 ;

    result = xsltApplyStylesheet(ss, xml, params);
    free(params);

    if (!result) rb_raise(rb_eRuntimeError, &quot;could not perform xslt transform on document&quot;);

    return Nokogiri_wrap_xml_document(0, result) ;
}

VALUE cNokogiriXsltStylesheet ;
void init_xslt_stylesheet()
{
  VALUE nokogiri = rb_define_module(&quot;Nokogiri&quot;);
  VALUE xslt = rb_define_module_under(nokogiri, &quot;XSLT&quot;);
  VALUE klass = rb_define_class_under(xslt, &quot;Stylesheet&quot;, rb_cObject);

  cNokogiriXsltStylesheet = klass;
    
  rb_define_singleton_method(klass, &quot;parse_stylesheet_doc&quot;, parse_stylesheet_doc, 1);
  rb_define_method(klass, &quot;serialize&quot;, serialize, 1);
  rb_define_method(klass, &quot;transform&quot;, transform, -1);
}
</pre>
    </div>