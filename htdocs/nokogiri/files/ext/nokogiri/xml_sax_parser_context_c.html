  <div id="fileHeader">
    <h1>xml_sax_parser_context.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ext/nokogiri/xml_sax_parser_context.c</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Dec 11 22:20:49 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#include &lt;xml_sax_parser_context.h&gt;

VALUE cNokogiriXmlSaxParserContext ;

static void deallocate(xmlParserCtxtPtr ctxt)
{
  NOKOGIRI_DEBUG_START(handler);

  ctxt-&gt;sax = NULL;

  xmlFreeParserCtxt(ctxt);

  NOKOGIRI_DEBUG_END(handler);
}

/*
 * call-seq:
 *  parse_io(io, encoding)
 *
 * Parse +io+ object with +encoding+
 */
static VALUE parse_io(VALUE klass, VALUE io, VALUE encoding)
{
  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding); 

  xmlParserCtxtPtr ctxt = xmlCreateIOParserCtxt(
      NULL,
      NULL,
      (xmlInputReadCallback)io_read_callback,
      (xmlInputCloseCallback)io_close_callback,
      (void *)io,
      enc
  );

  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

/*
 * call-seq:
 *  parse_file(filename)
 *
 * Parse file given +filename+
 */
static VALUE parse_file(VALUE klass, VALUE filename)
{
  xmlParserCtxtPtr ctxt = xmlCreateFileParserCtxt(StringValuePtr(filename));
  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

/*
 * call-seq:
 *  parse_memory(data)
 *
 * Parse the XML stored in memory in +data+
 */
static VALUE parse_memory(VALUE klass, VALUE data)
{
  if(NIL_P(data)) rb_raise(rb_eArgError, &quot;data cannot be nil&quot;);
  if(!(int)RSTRING_LEN(data))
    rb_raise(rb_eRuntimeError, &quot;data cannot be empty&quot;);

  xmlParserCtxtPtr ctxt = xmlCreateMemoryParserCtxt(
      StringValuePtr(data),
      (int)RSTRING_LEN(data)
  );

  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}

/*
 * call-seq:
 *  parse_with(sax_handler)
 *
 * Use +sax_handler+ and parse the current document
 */
static VALUE parse_with(VALUE self, VALUE sax_handler)
{
  if(!rb_obj_is_kind_of(sax_handler, cNokogiriXmlSaxParser))
    rb_raise(rb_eArgError, &quot;argument must be a Nokogiri::XML::SAX::Parser&quot;);

  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  xmlSAXHandlerPtr sax;
  Data_Get_Struct(sax_handler, xmlSAXHandler, sax);

  // Free the sax handler since we'll assign our own
  if(ctxt-&gt;sax &amp;&amp; ctxt-&gt;sax != (xmlSAXHandlerPtr)&amp;xmlDefaultSAXHandler)
    xmlFree(ctxt-&gt;sax);

  ctxt-&gt;sax = sax;
  ctxt-&gt;userData = (void *)NOKOGIRI_SAX_TUPLE_NEW(ctxt, sax_handler);

  xmlParseDocument(ctxt);

  if(NULL != ctxt-&gt;myDoc) xmlFreeDoc(ctxt-&gt;myDoc);

  NOKOGIRI_SAX_TUPLE_DESTROY(ctxt-&gt;userData);

  return Qnil ;
}

/*
 * call-seq:
 *  replace_entities=(boolean)
 *
 * Should this parser replace entities?  &amp;amp; will get converted to '&amp;' if
 * set to true
 */
static VALUE set_replace_entities(VALUE self, VALUE value)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if(Qfalse == value)
    ctxt-&gt;replaceEntities = 0;
  else
    ctxt-&gt;replaceEntities = 1;

  return value;
}

/*
 * call-seq:
 *  replace_entities
 *
 * Should this parser replace entities?  &amp;amp; will get converted to '&amp;' if
 * set to true
 */
static VALUE get_replace_entities(VALUE self)
{
  xmlParserCtxtPtr ctxt;
  Data_Get_Struct(self, xmlParserCtxt, ctxt);

  if(0 == ctxt-&gt;replaceEntities)
    return Qfalse;
  else
    return Qtrue;
}

void init_xml_sax_parser_context()
{
  VALUE nokogiri  = rb_define_module(&quot;Nokogiri&quot;);
  VALUE xml       = rb_define_module_under(nokogiri, &quot;XML&quot;);
  VALUE sax       = rb_define_module_under(xml, &quot;SAX&quot;);
  VALUE klass     = rb_define_class_under(sax, &quot;ParserContext&quot;, rb_cObject);

  cNokogiriXmlSaxParserContext = klass;

  rb_define_singleton_method(klass, &quot;io&quot;, parse_io, 2);
  rb_define_singleton_method(klass, &quot;memory&quot;, parse_memory, 1);
  rb_define_singleton_method(klass, &quot;file&quot;, parse_file, 1);

  rb_define_method(klass, &quot;parse_with&quot;, parse_with, 1);
  rb_define_method(klass, &quot;replace_entities=&quot;, set_replace_entities, 1);
  rb_define_method(klass, &quot;replace_entities&quot;, get_replace_entities, 0);
}
</pre>
    </div>