  <div id="fileHeader">
    <h1>html_document.c</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>ext/nokogiri/html_document.c</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:03:28 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#include &lt;html_document.h&gt;

/*
 * call-seq:
 *  new
 *
 * Create a new document
 */
static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  VALUE uri, external_id, rest, rb_doc;

  rb_scan_args(argc, argv, &quot;0*&quot;, &amp;rest);
  uri         = rb_ary_entry(rest, 0);
  external_id = rb_ary_entry(rest, 1);

  htmlDocPtr doc = htmlNewDoc(
      RTEST(uri) ? (const xmlChar *)StringValuePtr(uri) : NULL,
      RTEST(external_id) ? (const xmlChar *)StringValuePtr(external_id) : NULL
  );
  rb_doc = Nokogiri_wrap_xml_document(klass, doc);
  rb_funcall2(rb_doc, rb_intern(&quot;initialize&quot;), argc, argv);
  return rb_doc ;
}

/*
 * call-seq:
 *  read_io(io, url, encoding, options)
 *
 * Read the HTML document from +io+ with given +url+, +encoding+,
 * and +options+.  See Nokogiri::HTML.parse
 */
static VALUE read_io( VALUE klass,
                      VALUE io,
                      VALUE url,
                      VALUE encoding,
                      VALUE options )
{
  const char * c_url    = (url == Qnil) ? NULL : StringValuePtr(url);
  const char * c_enc    = (encoding == Qnil) ? NULL : StringValuePtr(encoding);
  VALUE error_list      = rb_ary_new();

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

  htmlDocPtr doc = htmlReadIO(
      io_read_callback,
      io_close_callback,
      (void *)io,
      c_url,
      c_enc,
      NUM2INT(options)
  );
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(doc == NULL) {
    xmlFreeDoc(doc);

    xmlErrorPtr error = xmlGetLastError();
    if(error)
      rb_funcall(rb_mKernel, rb_intern(&quot;raise&quot;), 1,
          Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error)
      );
    else
      rb_raise(rb_eRuntimeError, &quot;Could not parse document&quot;);

    return Qnil;
  }

  VALUE document = Nokogiri_wrap_xml_document(klass, doc);
  rb_funcall(document, rb_intern(&quot;errors=&quot;), 1, error_list);
  return document;
}

/*
 * call-seq:
 *  read_memory(string, url, encoding, options)
 *
 * Read the HTML document contained in +string+ with given +url+, +encoding+,
 * and +options+.  See Nokogiri::HTML.parse
 */
static VALUE read_memory( VALUE klass,
                          VALUE string,
                          VALUE url,
                          VALUE encoding,
                          VALUE options )
{
  const char * c_buffer = StringValuePtr(string);
  const char * c_url    = (url == Qnil) ? NULL : StringValuePtr(url);
  const char * c_enc    = (encoding == Qnil) ? NULL : StringValuePtr(encoding);
  int len               = RSTRING_LEN(string);
  VALUE error_list      = rb_ary_new();

  xmlResetLastError();
  xmlSetStructuredErrorFunc((void *)error_list, Nokogiri_error_array_pusher);

  htmlDocPtr doc = htmlReadMemory(c_buffer, len, c_url, c_enc, NUM2INT(options));
  xmlSetStructuredErrorFunc(NULL, NULL);

  if(doc == NULL) {
    xmlFreeDoc(doc);

    xmlErrorPtr error = xmlGetLastError();
    if(error)
      rb_funcall(rb_mKernel, rb_intern(&quot;raise&quot;), 1,
          Nokogiri_wrap_xml_syntax_error((VALUE)NULL, error)
      );
    else
      rb_raise(rb_eRuntimeError, &quot;Could not parse document&quot;);

    return Qnil;
  }

  VALUE document = Nokogiri_wrap_xml_document(klass, doc);
  rb_funcall(document, rb_intern(&quot;errors=&quot;), 1, error_list);
  return document;
}

/*
 * call-seq:
 *  type
 *
 * The type for this document
 */
static VALUE type(VALUE self)
{
  htmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);
  return INT2NUM((int)doc-&gt;type);
}

/*
 * call-seq:
 *  meta_encoding=
 *
 * Set the meta tag encoding for this document.
 */
static VALUE set_meta_encoding(VALUE self, VALUE encoding)
{
  htmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  htmlSetMetaEncoding(doc, (const xmlChar *)StringValuePtr(encoding));

  return encoding;
}

/*
 * call-seq:
 *  meta_encoding
 *
 * Get the meta tag encoding for this document.
 */
static VALUE meta_encoding(VALUE self)
{
  htmlDocPtr doc;
  Data_Get_Struct(self, xmlDoc, doc);

  return NOKOGIRI_STR_NEW2(htmlGetMetaEncoding(doc), doc-&gt;encoding);
}

VALUE cNokogiriHtmlDocument ;
void init_html_document()
{
  VALUE nokogiri  = rb_define_module(&quot;Nokogiri&quot;);
  VALUE html      = rb_define_module_under(nokogiri, &quot;HTML&quot;);
  VALUE xml       = rb_define_module_under(nokogiri, &quot;XML&quot;);
  VALUE node      = rb_define_class_under(xml, &quot;Node&quot;, rb_cObject);
  VALUE xml_doc   = rb_define_class_under(xml, &quot;Document&quot;, node);
  VALUE klass     = rb_define_class_under(html, &quot;Document&quot;, xml_doc);

  cNokogiriHtmlDocument = klass;

  rb_define_singleton_method(klass, &quot;read_memory&quot;, read_memory, 4);
  rb_define_singleton_method(klass, &quot;read_io&quot;, read_io, 4);
  rb_define_singleton_method(klass, &quot;new&quot;, new, -1);

  rb_define_method(klass, &quot;type&quot;, type, 0);
  rb_define_method(klass, &quot;meta_encoding&quot;, meta_encoding, 0);
  rb_define_method(klass, &quot;meta_encoding=&quot;, set_meta_encoding, 1);
}
</pre>
    </div>