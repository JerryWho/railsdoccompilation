  <div id="fileHeader">
    <h1>test_node_reparenting.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>test/xml/test_node_reparenting.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 20:15:09 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require &quot;helper&quot;

module Nokogiri
  module XML
    class TestNodeReparenting &lt; Nokogiri::TestCase

      describe &quot;standard node reparenting behavior&quot; do
        # describe &quot;namespace handling during reparenting&quot; do
        #   describe &quot;given a Node&quot; do
        #     describe &quot;with a Namespace&quot; do
        #       it &quot;keeps the Namespace&quot;
        #     end
        #     describe &quot;given a parent Node with a default and a non-default Namespace&quot; do
        #       describe &quot;passed an Node without a namespace&quot; do
        #         it &quot;inserts an Node that inherits the default Namespace&quot;
        #       end
        #       describe &quot;passed a Node with a Namespace that matches the parent's non-default Namespace&quot; do
        #         it &quot;inserts a Node that inherits the matching parent Namespace&quot;
        #       end
        #     end
        #   end
        #   describe &quot;given a markup string&quot; do
        #     describe &quot;parsed relative to the document&quot; do
        #       describe &quot;with a Namespace&quot; do
        #         it &quot;keeps the Namespace&quot;
        #       end
        #       describe &quot;given a parent Node with a default and a non-default Namespace&quot; do
        #         describe &quot;passed an Node without a namespace&quot; do
        #           it &quot;inserts an Node that inherits the default Namespace&quot;
        #         end
        #         describe &quot;passed a Node with a Namespace that matches the parent's non-default Namespace&quot; do
        #           it &quot;inserts a Node that inherits the matching parent Namespace&quot;
        #         end
        #       end
        #     end
        #     describe &quot;parsed relative to a specific node&quot; do
        #       describe &quot;with a Namespace&quot; do
        #         it &quot;keeps the Namespace&quot;
        #       end
        #       describe &quot;given a parent Node with a default and a non-default Namespace&quot; do
        #         describe &quot;passed an Node without a namespace&quot; do
        #           it &quot;inserts an Node that inherits the default Namespace&quot;
        #         end
        #         describe &quot;passed a Node with a Namespace that matches the parent's non-default Namespace&quot; do
        #           it &quot;inserts a Node that inherits the matching parent Namespace&quot;
        #         end
        #       end
        #     end
        #   end
        # end

        {
          :add_child            =&gt; {:target =&gt; &quot;/root/a1&quot;,        :returns =&gt; :reparented, :children_tags =&gt; %w[text b1 b2]},
          :&lt;&lt;                   =&gt; {:target =&gt; &quot;/root/a1&quot;,        :returns =&gt; :reparented, :children_tags =&gt; %w[text b1 b2]},

          :replace              =&gt; {:target =&gt; &quot;/root/a1/node()&quot;, :returns =&gt; :reparented, :children_tags =&gt; %w[b1 b2]},
          :swap                 =&gt; {:target =&gt; &quot;/root/a1/node()&quot;, :returns =&gt; :self,       :children_tags =&gt; %w[b1 b2]},

          :inner_html=          =&gt; {:target =&gt; &quot;/root/a1&quot;,        :returns =&gt; :self,       :children_tags =&gt; %w[b1 b2]},

          :add_previous_sibling =&gt; {:target =&gt; &quot;/root/a1/text()&quot;, :returns =&gt; :reparented, :children_tags =&gt; %w[b1 b2 text]},
          :previous=            =&gt; {:target =&gt; &quot;/root/a1/text()&quot;, :returns =&gt; :reparented, :children_tags =&gt; %w[b1 b2 text]},
          :before               =&gt; {:target =&gt; &quot;/root/a1/text()&quot;, :returns =&gt; :self,       :children_tags =&gt; %w[b1 b2 text]},

          :add_next_sibling     =&gt; {:target =&gt; &quot;/root/a1/text()&quot;, :returns =&gt; :reparented, :children_tags =&gt; %w[text b1 b2]},
          :next=                =&gt; {:target =&gt; &quot;/root/a1/text()&quot;, :returns =&gt; :reparented, :children_tags =&gt; %w[text b1 b2]},
          :after                =&gt; {:target =&gt; &quot;/root/a1/text()&quot;, :returns =&gt; :self,       :children_tags =&gt; %w[text b1 b2]}
        }.each do |method, params|

          before do
            @doc  = Nokogiri::XML &quot;&lt;root&gt;&lt;a1&gt;First node&lt;/a1&gt;&lt;a2&gt;Second node&lt;/a2&gt;&lt;a3&gt;Third &lt;bx /&gt;node&lt;/a3&gt;&lt;/root&gt;&quot;
            @doc2 = @doc.dup
            @fragment_string = &quot;&lt;b1&gt;foo&lt;/b1&gt;&lt;b2&gt;bar&lt;/b2&gt;&quot;
            @fragment        = Nokogiri::XML::DocumentFragment.parse @fragment_string
            @node_set        = Nokogiri::XML(&quot;&lt;root&gt;&lt;b1&gt;foo&lt;/b1&gt;&lt;b2&gt;bar&lt;/b2&gt;&lt;/root&gt;&quot;).xpath(&quot;/root/node()&quot;)
          end

          describe &quot;##{method}&quot; do
            describe &quot;passed a Node&quot; do
              [:current, :another].each do |which|
                describe &quot;passed a Node in the #{which} document&quot; do
                  before do
                    @other_doc = which == :current ? @doc : @doc2
                    @other_node = @other_doc.at_xpath(&quot;/root/a2&quot;)
                  end

                  it &quot;unlinks the Node from its previous position&quot; do
                    @doc.at_xpath(params[:target]).send(method, @other_node)
                    @other_doc.at_xpath(&quot;/root/a2&quot;).must_be_nil
                  end

                  it &quot;inserts the Node in the proper position&quot; do
                    @doc.at_xpath(params[:target]).send(method, @other_node)
                    @doc.at_xpath(&quot;/root/a1/a2&quot;).wont_be_nil
                  end

                  it &quot;returns the expected value&quot; do
                    if params[:returns] == :self
                      sendee = @doc.at_xpath(params[:target])
                      sendee.send(method, @other_node).must_equal sendee
                    else
                      @doc.at_xpath(params[:target]).send(method, @other_node).must_equal @other_node
                    end
                  end
                end
              end
            end
            describe &quot;passed a markup string&quot; do
              it &quot;inserts the fragment roots in the proper position&quot; do
                @doc.at_xpath(params[:target]).send(method, @fragment_string)
                @doc.xpath(&quot;/root/a1/node()&quot;).collect {|n| n.name}.must_equal params[:children_tags]
              end
            end
            describe &quot;passed a fragment&quot; do
              it &quot;inserts the fragment roots in the proper position&quot; do
                @doc.at_xpath(params[:target]).send(method, @fragment)
                @doc.xpath(&quot;/root/a1/node()&quot;).collect {|n| n.name}.must_equal params[:children_tags]
              end
            end
            describe &quot;passed a document&quot; do
              it &quot;raises an exception&quot; do
                proc { @doc.at_xpath(&quot;/root/a1&quot;).send(method, @doc2) }.must_raise(ArgumentError)
              end
            end
            describe &quot;passed a non-Node&quot; do
              it &quot;raises an exception&quot; do
                proc { @doc.at_xpath(&quot;/root/a1&quot;).send(method, 42) }.must_raise(ArgumentError)
              end
            end
            describe &quot;passed a NodeSet&quot; do
              it &quot;inserts each member of the NodeSet in the proper order&quot; do
                @doc.at_xpath(params[:target]).send(method, @node_set)
                @doc.xpath(&quot;/root/a1/node()&quot;).collect {|n| n.name}.must_equal params[:children_tags]
              end
            end
          end

          describe &quot;text node merging&quot; do
            describe &quot;#add_child&quot; do
              it &quot;merges the Text node with adjacent Text nodes&quot; do
                @doc.at_xpath(&quot;/root/a1&quot;).add_child Nokogiri::XML::Text.new('hello', @doc)
                @doc.at_xpath(&quot;/root/a1/text()&quot;).content.must_equal &quot;First nodehello&quot;
              end
            end
            describe &quot;#replace&quot; do
              it &quot;merges the Text node with adjacent Text nodes&quot; do
                @doc.at_xpath(&quot;/root/a3/bx&quot;).replace Nokogiri::XML::Text.new('hello', @doc)
                @doc.at_xpath(&quot;/root/a3/text()&quot;).content.must_equal &quot;Third hellonode&quot;
              end
            end
          end
        end
      end

      describe &quot;ad hoc node reparenting behavior&quot; do
        before do
          @xml = Nokogiri::XML &quot;&lt;root&gt;&lt;a1&gt;First node&lt;/a1&gt;&lt;a2&gt;Second node&lt;/a2&gt;&lt;a3&gt;Third node&lt;/a3&gt;&lt;/root&gt;&quot;
          @html = Nokogiri::HTML(&lt;&lt;-eohtml)
            &lt;html&gt;
              &lt;head&gt;&lt;/head&gt;
              &lt;body&gt;
                &lt;div class='baz'&gt;&lt;a href=&quot;foo&quot; class=&quot;bar&quot;&gt;first&lt;/a&gt;&lt;/div&gt;
              &lt;/body&gt;
            &lt;/html&gt;
          eohtml
        end

        describe &quot;#add_child&quot; do
          describe &quot;given a new node with a namespace&quot; do
            it &quot;keeps the namespace&quot; do
              doc   = Nokogiri::XML::Document.new
              item  = Nokogiri::XML::Element.new('item', doc)
              doc.root = item

              entry = Nokogiri::XML::Element.new('entry', doc)
              entry.add_namespace('tlm', 'http://tenderlovemaking.com')
              assert_equal 'http://tenderlovemaking.com', entry.namespaces['xmlns:tlm']
              item.add_child(entry)
              assert_equal 'http://tenderlovemaking.com', entry.namespaces['xmlns:tlm']
            end
          end

          describe &quot;given a parent node with a default namespace&quot; do
            before do
              @doc = Nokogiri::XML(&lt;&lt;-eoxml)
                &lt;root xmlns=&quot;http://tenderlovemaking.com/&quot;&gt;
                  &lt;first&gt;
                  &lt;/first&gt;
                &lt;/root&gt;
              eoxml
            end

            it &quot;inserts a node that inherits the default namespace&quot; do
              assert node = @doc.at('//xmlns:first')
              child = Nokogiri::XML::Node.new('second', @doc)
              node.add_child(child)
              assert @doc.at('//xmlns:second')
            end
          end

          describe &quot;given a parent node with a non-default namespace&quot; do
            before do
              @doc = Nokogiri::XML(&lt;&lt;-eoxml)
                &lt;root xmlns=&quot;http://tenderlovemaking.com/&quot; xmlns:foo=&quot;http://flavorjon.es/&quot;&gt;
                  &lt;first&gt;
                  &lt;/first&gt;
                &lt;/root&gt;
              eoxml
            end

            describe &quot;and a child node with a namespace matching the parent's non-default namespace&quot; do
              it &quot;inserts a node that inherits the matching parent namespace&quot; do
                assert node = @doc.at('//xmlns:first')
                child = Nokogiri::XML::Node.new('second', @doc)

                ns = @doc.root.namespace_definitions.detect { |x| x.prefix == &quot;foo&quot; }
                child.namespace = ns

                node.add_child(child)
                assert @doc.at('//foo:second', &quot;foo&quot; =&gt; &quot;http://flavorjon.es/&quot;)
              end
            end
          end
        end

        describe &quot;#replace&quot; do
          describe &quot;when a document has a default namespace&quot; do
            before do
              @fruits = Nokogiri::XML(&lt;&lt;-eoxml)
                &lt;fruit xmlns=&quot;http://fruits.org&quot;&gt;
                  &lt;apple /&gt;
                &lt;/fruit&gt;
              eoxml
            end

            it &quot;inserts a node with default namespaces&quot; do
              apple = @fruits.css('apple').first

              orange = Nokogiri::XML::Node.new('orange', @fruits)
              apple.replace(orange)

              assert_equal orange, @fruits.css('orange').first
            end
          end
        end

        describe &quot;unlinking a node and then reparenting it&quot; do
          it &quot;not blow up&quot; do
            # see http://github.com/tenderlove/nokogiri/issues#issue/22
            10.times do
              STDOUT.putc &quot;.&quot;
              STDOUT.flush
              begin
                doc = Nokogiri::XML &lt;&lt;-EOHTML
                  &lt;root&gt;
                    &lt;a&gt;
                      &lt;b/&gt;
                      &lt;c/&gt;
                    &lt;/a&gt;
                  &lt;/root&gt;
                EOHTML

                root = doc.at(&quot;root&quot;)
                a = root.at(&quot;a&quot;)
                b = a.at(&quot;b&quot;)
                c = a.at(&quot;c&quot;)
                a.add_next_sibling(b.unlink)
                c.unlink
              end
              GC.start
            end
          end
        end

      end
    end
  end
end
</pre>
    </div>