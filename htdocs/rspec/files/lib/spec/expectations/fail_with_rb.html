  <div id="fileHeader">
    <h1>fail_with.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/expectations/fail_with.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:57:53 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Spec
  module Expectations
    class &lt;&lt; self
      attr_accessor :differ
      
      # raises a Spec::Expectations::ExpectationNotMetError with message
      #
      # When a differ has been assigned and fail_with is passed
      # &lt;code&gt;expected&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt;, passes them
      # to the differ to append a diff message to the failure message.
      def fail_with(message, expected=nil, target=nil) # :nodoc:
        if message.nil?
          raise ArgumentError, &quot;Failure message is nil. Does your matcher define the &quot; +
                               &quot;appropriate failure_message_for_* method to return a string?&quot;
        end
        if (Array === message) &amp; (message.length == 3)
          ::Spec.warn(&lt;&lt;-NOTICE

*****************************************************************
DEPRECATION WARNING: you are using deprecated behaviour that will
be removed from a future version of RSpec.

* Support for matchers that return arrays from failure message
methods is deprecated.
* Instead, the matcher should return a string, and expose methods
for the expected() and actual() values.
*****************************************************************
NOTICE
          )
          message, expected, target = message[0], message[1], message[2]
        end
        unless (differ.nil? || expected.nil? || target.nil?)
          if expected.is_a?(String)
            message &lt;&lt; &quot;\n\n Diff:&quot; &lt;&lt; self.differ.diff_as_string(target.to_s, expected)
          elsif expected.is_a?(Hash) &amp;&amp; target.is_a?(Hash)
            message &lt;&lt; &quot;\n\n Diff:&quot; &lt;&lt; self.differ.diff_as_hash(target, expected)
          elsif !target.is_a?(Proc)
            message &lt;&lt; &quot;\n\n Diff:&quot; &lt;&lt; self.differ.diff_as_object(target, expected)
          end
        end
        Kernel::raise(Spec::Expectations::ExpectationNotMetError.new(message))
      end
    end
  end
end</pre>
    </div>