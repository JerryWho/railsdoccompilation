  <div id="fileHeader">
    <h1>change.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/matchers/change.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:57:53 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Spec
  module Matchers
    
    #Based on patch from Wilson Bilkovich
    class Change #:nodoc:
      def initialize(receiver=nil, message=nil, &amp;block)
        @message = message || &quot;result&quot;
        @value_proc = block || lambda {receiver.__send__(message)}
        @to = @from = @minimum = @maximum = @amount = nil
      end
      
      def matches?(event_proc)
        raise_block_syntax_error if block_given?
        
        @before = evaluate_value_proc
        event_proc.call
        @after = evaluate_value_proc
        
        return (@to = false) if @from unless @from == @before
        return false if @to unless @to == @after
        return (@before + @amount == @after) if @amount
        return ((@after - @before) &gt;= @minimum) if @minimum
        return ((@after - @before) &lt;= @maximum) if @maximum        
        return @before != @after
      end
      
      def raise_block_syntax_error
        raise MatcherError.new(&lt;&lt;-MESSAGE
block passed to should or should_not change must use {} instead of do/end
MESSAGE
        )
      end
      
      def evaluate_value_proc
        @value_proc.call
      end
      
      def failure_message_for_should
        if @to
          &quot;#{@message} should have been changed to #{@to.inspect}, but is now #{@after.inspect}&quot;
        elsif @from
          &quot;#{@message} should have initially been #{@from.inspect}, but was #{@before.inspect}&quot;
        elsif @amount
          &quot;#{@message} should have been changed by #{@amount.inspect}, but was changed by #{actual_delta.inspect}&quot;
        elsif @minimum
          &quot;#{@message} should have been changed by at least #{@minimum.inspect}, but was changed by #{actual_delta.inspect}&quot;
        elsif @maximum
          &quot;#{@message} should have been changed by at most #{@maximum.inspect}, but was changed by #{actual_delta.inspect}&quot;
        else
          &quot;#{@message} should have changed, but is still #{@before.inspect}&quot;
        end
      end
      
      def actual_delta
        @after - @before
      end
      
      def failure_message_for_should_not
        &quot;#{@message} should not have changed, but did change from #{@before.inspect} to #{@after.inspect}&quot;
      end
      
      def by(amount)
        @amount = amount
        self
      end
      
      def by_at_least(minimum)
        @minimum = minimum
        self
      end
      
      def by_at_most(maximum)
        @maximum = maximum
        self
      end      
      
      def to(to)
        @to = to
        self
      end
      
      def from (from)
        @from = from
        self
      end
      
      def description
        &quot;change ##{@message}&quot;
      end
    end
    
    # :call-seq:
    #   should change(receiver, message, &amp;block)
    #   should change(receiver, message, &amp;block).by(value)
    #   should change(receiver, message, &amp;block).from(old).to(new)
    #   should_not change(receiver, message, &amp;block)
    #
    # Allows you to specify that a Proc will cause some value to change.
    #
    # == Examples
    #
    #   lambda {
    #     team.add_player(player) 
    #   }.should change(roster, :count)
    #
    #   lambda {
    #     team.add_player(player) 
    #   }.should change(roster, :count).by(1)
    #
    #   lambda {
    #     team.add_player(player) 
    #   }.should change(roster, :count).by_at_least(1)
    #
    #   lambda {
    #     team.add_player(player)
    #   }.should change(roster, :count).by_at_most(1)    
    #
    #   string = &quot;string&quot;
    #   lambda {
    #     string.reverse!
    #   }.should change { string }.from(&quot;string&quot;).to(&quot;gnirts&quot;)
    #
    #   lambda {
    #     person.happy_birthday
    #   }.should change(person, :birthday).from(32).to(33)
    #       
    #   lambda {
    #     employee.develop_great_new_social_networking_app
    #   }.should change(employee, :title).from(&quot;Mail Clerk&quot;).to(&quot;CEO&quot;)
    #
    # Evaluates &lt;tt&gt;receiver.message&lt;/tt&gt; or &lt;tt&gt;block&lt;/tt&gt; before and after
    # it evaluates the c object (generated by the lambdas in the examples
    # above).
    #
    # Then compares the values before and after the &lt;tt&gt;receiver.message&lt;/tt&gt;
    # and evaluates the difference compared to the expected difference.
    #
    # == WARNING
    # &lt;tt&gt;should_not change&lt;/tt&gt; only supports the form with no
    # subsequent calls to &lt;tt&gt;by&lt;/tt&gt;, &lt;tt&gt;by_at_least&lt;/tt&gt;,
    # &lt;tt&gt;by_at_most&lt;/tt&gt;, &lt;tt&gt;to&lt;/tt&gt; or &lt;tt&gt;from&lt;/tt&gt;.
    #
    # blocks passed to &lt;tt&gt;should&lt;/tt&gt; &lt;tt&gt;change&lt;/tt&gt; and &lt;tt&gt;should_not&lt;/tt&gt;
    # &lt;tt&gt;change&lt;/tt&gt; must use the &lt;tt&gt;{}&lt;/tt&gt; form (&lt;tt&gt;do/end&lt;/tt&gt; is not
    # supported).
    #
    def change(receiver=nil, message=nil, &amp;block)
      Matchers::Change.new(receiver, message, &amp;block)
    end
  end
end
</pre>
    </div>