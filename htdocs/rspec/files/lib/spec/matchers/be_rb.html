  <div id="fileHeader">
    <h1>be.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/matchers/be.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 20:07:22 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'spec/matchers/dsl'

Spec::Matchers.define :be_true do
  match do |actual|
    !!actual
  end
end

Spec::Matchers.define :be_false do
  match do |actual|
    !actual
  end
end

Spec::Matchers.define :be_nil do
  match do |actual|
    actual.nil?
  end

  failure_message_for_should do |actual|
    &quot;expected nil, got #{actual.inspect}&quot;
  end

  failure_message_for_should_not do
    &quot;expected not nil, got nil&quot;
  end
end

module Spec
  module Matchers

    class Be #:nodoc:
      include Spec::Matchers::Pretty
      
      def initialize(*args, &amp;block)
        @args = args
      end
      
      def matches?(actual)
        @actual = actual
        !!@actual
      end

      def failure_message_for_should
        &quot;expected #{@actual.inspect} to evaluate to true&quot;
      end
      
      def failure_message_for_should_not
        &quot;expected #{@actual.inspect} to evaluate to false&quot;
      end
      
      def description
        &quot;be&quot;
      end

      [:==, :&lt;, :&lt;=, :&gt;=, :&gt;, :===].each do |operator|
        define_method operator do |operand|
          BeComparedTo.new(operand, operator)
        end
      end

    private

      def args_to_s
        @args.empty? ? &quot;&quot; : parenthesize(inspected_args.join(', '))
      end
      
      def parenthesize(string)
        return &quot;(#{string})&quot;
      end
      
      def inspected_args
        @args.collect{|a| a.inspect}
      end
      
      def expected_to_sentence
        split_words(@expected)
      end
      
      def args_to_sentence
        to_sentence(@args)
      end
        
    end

    class BeComparedTo &lt; Be

      def initialize(operand, operator)
        @expected, @operator = operand, operator
        @args = []
      end

      def matches?(actual)
        @actual = actual
        @actual.__send__(@operator, @expected)
      end

      def failure_message_for_should
        &quot;expected #{@operator} #{@expected}, got #{@actual.inspect}&quot;
      end
      
      def failure_message_for_should_not
        message = &lt;&lt;-MESSAGE
'should_not be #{@operator} #{@expected}' not only FAILED,
it is a bit confusing.
          MESSAGE
          
        raise message &lt;&lt; ([:===,:==].include?(@operator) ?
          &quot;It might be more clearly expressed without the \&quot;be\&quot;?&quot; :
          &quot;It might be more clearly expressed in the positive?&quot;)
      end

      def description
        &quot;be #{@operator} #{expected_to_sentence}#{args_to_sentence}&quot;
      end

    end

    class BePredicate &lt; Be

      def initialize(*args, &amp;block)
        @expected = parse_expected(args.shift)
        @args = args
        @block = block
      end
      
      def matches?(actual)
        @actual = actual
        begin
          return @result = actual.__send__(predicate, *@args, &amp;@block)
        rescue NameError =&gt; predicate_missing_error
          &quot;this needs to be here or rcov will not count this branch even though it's executed in a code example&quot;
        end

        begin
          return @result = actual.__send__(present_tense_predicate, *@args, &amp;@block)
        rescue NameError
          raise predicate_missing_error
        end
      end
      
      def failure_message_for_should
        &quot;expected #{predicate}#{args_to_s} to return true, got #{@result.inspect}&quot;
      end
      
      def failure_message_for_should_not
        &quot;expected #{predicate}#{args_to_s} to return false, got #{@result.inspect}&quot;
      end

      def description
        &quot;#{prefix_to_sentence}#{expected_to_sentence}#{args_to_sentence}&quot;
      end

    private

      def predicate
        &quot;#{@expected}?&quot;.to_sym
      end
      
      def present_tense_predicate
        &quot;#{@expected}s?&quot;.to_sym
      end
      
      def parse_expected(expected)
        @prefix, expected = prefix_and_expected(expected)
        expected
      end

      def prefix_and_expected(symbol)
        symbol.to_s =~ /^(be_(an?_)?)(.*)/
        return $1, $3
      end

      def prefix_to_sentence
        split_words(@prefix)
      end

    end

    class BeSameAs &lt; Be
      
      def initialize(*args, &amp;block)
        @expected = args.shift
        @args = args
      end
      
      def matches?(actual)
        @actual = actual
        @actual.equal?(@expected)
      end

      def failure_message_for_should
        &quot;expected #{@expected}, got #{@actual.inspect}&quot;
      end
      
      def failure_message_for_should_not
        &quot;expected not #{@expected}, got #{@actual.inspect}&quot;
      end

      def description
        &quot;be #{expected_to_sentence}#{args_to_sentence}&quot;
      end

    end
 
    # :call-seq:
    #   should be_true
    #   should be_false
    #   should be_nil
    #   should be_[arbitrary_predicate](*args)
    #   should_not be_nil
    #   should_not be_[arbitrary_predicate](*args)
    #
    # Given true, false, or nil, will pass if actual value is
    # true, false or nil (respectively). Given no args means
    # the caller should satisfy an if condition (to be or not to be). 
    #
    # Predicates are any Ruby method that ends in a &quot;?&quot; and returns true or false.
    # Given be_ followed by arbitrary_predicate (without the &quot;?&quot;), RSpec will match
    # convert that into a query against the target object.
    #
    # The arbitrary_predicate feature will handle any predicate
    # prefixed with &quot;be_an_&quot; (e.g. be_an_instance_of), &quot;be_a_&quot; (e.g. be_a_kind_of)
    # or &quot;be_&quot; (e.g. be_empty), letting you choose the prefix that best suits the predicate.
    #
    # == Examples 
    #
    #   target.should be_true
    #   target.should be_false
    #   target.should be_nil
    #   target.should_not be_nil
    #
    #   collection.should be_empty #passes if target.empty?
    #   target.should_not be_empty #passes unless target.empty?
    #   target.should_not be_old_enough(16) #passes unless target.old_enough?(16)
    def be(*args)
      args.empty? ?
        Matchers::Be.new :
        Matchers::BeSameAs.new(*args)
    end

    # passes if target.kind_of?(klass)
    def be_a(klass)
      be_a_kind_of(klass)
    end
    
    alias_method :be_an, :be_a
  end
end
</pre>
    </div>