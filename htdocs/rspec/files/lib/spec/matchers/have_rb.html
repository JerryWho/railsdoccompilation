  <div id="fileHeader">
    <h1>have.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/matchers/have.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:06:25 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Spec
  module Matchers
    class Have #:nodoc:
      def initialize(expected, relativity=:exactly)
        @expected = (expected == :no ? 0 : expected)
        @relativity = relativity
        @actual = nil
      end
    
      def relativities
        @relativities ||= {
          :exactly =&gt; &quot;&quot;,
          :at_least =&gt; &quot;at least &quot;,
          :at_most =&gt; &quot;at most &quot;
        }
      end
    
      def matches?(collection_owner)
        if collection_owner.respond_to?(@collection_name)
          collection = collection_owner.__send__(@collection_name, *@args, &amp;@block)
        elsif (@plural_collection_name &amp;&amp; collection_owner.respond_to?(@plural_collection_name))
          collection = collection_owner.__send__(@plural_collection_name, *@args, &amp;@block)
        elsif (collection_owner.respond_to?(:length) || collection_owner.respond_to?(:size))
          collection = collection_owner
        else
          collection_owner.__send__(@collection_name, *@args, &amp;@block)
        end
        @actual = collection.size if collection.respond_to?(:size)
        @actual = collection.length if collection.respond_to?(:length)
        raise not_a_collection if @actual.nil?
        return @actual &gt;= @expected if @relativity == :at_least
        return @actual &lt;= @expected if @relativity == :at_most
        return @actual == @expected
      end
      
      def not_a_collection
        &quot;expected #{@collection_name} to be a collection but it does not respond to #length or #size&quot;
      end
    
      def failure_message_for_should
        &quot;expected #{relative_expectation} #{@collection_name}, got #{@actual}&quot;
      end

      def failure_message_for_should_not
        if @relativity == :exactly
          return &quot;expected target not to have #{@expected} #{@collection_name}, got #{@actual}&quot;
        elsif @relativity == :at_most
          return &lt;&lt;-EOF
Isn't life confusing enough?
Instead of having to figure out the meaning of this:
  should_not have_at_most(#{@expected}).#{@collection_name}
We recommend that you use this instead:
  should have_at_least(#{@expected + 1}).#{@collection_name}
EOF
        elsif @relativity == :at_least
          return &lt;&lt;-EOF
Isn't life confusing enough?
Instead of having to figure out the meaning of this:
  should_not have_at_least(#{@expected}).#{@collection_name}
We recommend that you use this instead:
  should have_at_most(#{@expected - 1}).#{@collection_name}
EOF
        end
      end
      
      def description
        &quot;have #{relative_expectation} #{@collection_name}&quot;
      end
      
      def respond_to?(sym)
        @expected.respond_to?(sym) || super
      end
    
      private
      
      def method_missing(sym, *args, &amp;block)
        @collection_name = sym
        if inflector = (defined?(ActiveSupport::Inflector) ? ActiveSupport::Inflector : (defined?(Inflector) ? Inflector : nil))
          @plural_collection_name = inflector.pluralize(sym.to_s)
        end
        @args = args
        @block = block
        self
      end
      
      def relative_expectation
        &quot;#{relativities[@relativity]}#{@expected}&quot;
      end
    end

    # :call-seq:
    #   should have(number).named_collection__or__sugar
    #   should_not have(number).named_collection__or__sugar
    #
    # Passes if receiver is a collection with the submitted
    # number of items OR if the receiver OWNS a collection
    # with the submitted number of items.
    #
    # If the receiver OWNS the collection, you must use the name
    # of the collection. So if a &lt;tt&gt;Team&lt;/tt&gt; instance has a
    # collection named &lt;tt&gt;#players&lt;/tt&gt;, you must use that name
    # to set the expectation.
    #
    # If the receiver IS the collection, you can use any name
    # you like for &lt;tt&gt;named_collection&lt;/tt&gt;. We'd recommend using
    # either &quot;elements&quot;, &quot;members&quot;, or &quot;items&quot; as these are all
    # standard ways of describing the things IN a collection.
    #
    # This also works for Strings, letting you set an expectation
    # about its length
    #
    # == Examples
    #
    #   # Passes if team.players.size == 11
    #   team.should have(11).players
    #
    #   # Passes if [1,2,3].length == 3
    #   [1,2,3].should have(3).items #&quot;items&quot; is pure sugar
    #
    #   # Passes if &quot;this string&quot;.length == 11
    #   &quot;this string&quot;.should have(11).characters #&quot;characters&quot; is pure sugar
    def have(n)
      Matchers::Have.new(n)
    end
    alias :have_exactly :have

    # :call-seq:
    #   should have_at_least(number).items
    #
    # Exactly like have() with &gt;=.
    #
    # == Warning
    #
    # +should_not+ +have_at_least+ is not supported
    def have_at_least(n)
      Matchers::Have.new(n, :at_least)
    end

    # :call-seq:
    #   should have_at_most(number).items
    #
    # Exactly like have() with &lt;=.
    #
    # == Warning
    #
    # +should_not+ +have_at_most+ is not supported
    def have_at_most(n)
      Matchers::Have.new(n, :at_most)
    end
  end
end
</pre>
    </div>