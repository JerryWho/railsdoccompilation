  <div id="fileHeader">
    <h1>raise_error.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/matchers/raise_error.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:57:53 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Spec
  module Matchers
    class RaiseError #:nodoc:
      def initialize(expected_error_or_message=Exception, expected_message=nil, &amp;block)
        @block = block
        @actual_error = nil
        case expected_error_or_message
        when String, Regexp
          @expected_error, @expected_message = Exception, expected_error_or_message
        else
          @expected_error, @expected_message = expected_error_or_message, expected_message
        end
      end

      def matches?(given_proc)
        @raised_expected_error = false
        @with_expected_message = false
        @eval_block = false
        @eval_block_passed = false
        begin
          given_proc.call
        rescue @expected_error =&gt; @actual_error
          @raised_expected_error = true
          @with_expected_message = verify_message
        rescue Exception =&gt; @actual_error
          # This clause should be empty, but rcov will not report it as covered
          # unless something (anything) is executed within the clause
          rcov_error_report = &quot;http://eigenclass.org/hiki.rb?rcov-0.8.0&quot;
        end

        unless negative_expectation?
          eval_block if @raised_expected_error &amp;&amp; @with_expected_message &amp;&amp; @block
        end
      ensure
        return (@raised_expected_error &amp; @with_expected_message) ? (@eval_block ? @eval_block_passed : true) : false
      end
      
      def eval_block
        @eval_block = true
        begin
          @block[@actual_error]
          @eval_block_passed = true
        rescue Exception =&gt; err
          @actual_error = err
        end
      end

      def verify_message
        case @expected_message
        when nil
          true
        when Regexp
          @expected_message =~ @actual_error.message
        else
          @expected_message == @actual_error.message
        end
      end
      
      def failure_message_for_should
        @eval_block ? @actual_error.message : &quot;expected #{expected_error}#{given_error}&quot;
      end

      def failure_message_for_should_not
        &quot;expected no #{expected_error}#{given_error}&quot;
      end
      
      def description
        &quot;raise #{expected_error}&quot;
      end
      
      private
        def expected_error
          case @expected_message
          when nil
            @expected_error
          when Regexp
            &quot;#{@expected_error} with message matching #{@expected_message.inspect}&quot;
          else
            &quot;#{@expected_error} with #{@expected_message.inspect}&quot;
          end
        end

        def given_error
          @actual_error.nil? ? &quot; but nothing was raised&quot; : &quot;, got #{@actual_error.inspect}&quot;
        end
        
        def negative_expectation?
          # YES - I'm a bad person... help me find a better way - ryand
          caller.first(3).find { |s| s =~ /should_not/ }
        end
    end
    
    # :call-seq:
    #   should raise_error()
    #   should raise_error(NamedError)
    #   should raise_error(NamedError, String)
    #   should raise_error(NamedError, Regexp)
    #   should raise_error() { |error| ... }
    #   should raise_error(NamedError) { |error| ... }
    #   should raise_error(NamedError, String) { |error| ... }
    #   should raise_error(NamedError, Regexp) { |error| ... }
    #   should_not raise_error()
    #   should_not raise_error(NamedError)
    #   should_not raise_error(NamedError, String)
    #   should_not raise_error(NamedError, Regexp)
    #
    # With no args, matches if any error is raised.
    # With a named error, matches only if that specific error is raised.
    # With a named error and messsage specified as a String, matches only if both match.
    # With a named error and messsage specified as a Regexp, matches only if both match.
    # Pass an optional block to perform extra verifications on the exception matched
    #
    # == Examples
    #
    #   lambda { do_something_risky }.should raise_error
    #   lambda { do_something_risky }.should raise_error(PoorRiskDecisionError)
    #   lambda { do_something_risky }.should raise_error(PoorRiskDecisionError) { |error| error.data.should == 42 }
    #   lambda { do_something_risky }.should raise_error(PoorRiskDecisionError, &quot;that was too risky&quot;)
    #   lambda { do_something_risky }.should raise_error(PoorRiskDecisionError, /oo ri/)
    #
    #   lambda { do_something_risky }.should_not raise_error
    #   lambda { do_something_risky }.should_not raise_error(PoorRiskDecisionError)
    #   lambda { do_something_risky }.should_not raise_error(PoorRiskDecisionError, &quot;that was too risky&quot;)
    #   lambda { do_something_risky }.should_not raise_error(PoorRiskDecisionError, /oo ri/)
    def raise_error(error=Exception, message=nil, &amp;block)
      Matchers::RaiseError.new(error, message, &amp;block)
    end
  end
end
</pre>
    </div>