  <div id="fileHeader">
    <h1>subject.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/example/subject.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:06:25 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Spec
  module Example
    module Subject
      module ExampleGroupMethods
        # Defines an explicit subject for an example group which can then be the
        # implicit receiver (through delegation) of calls to +should+.
        #
        # == Examples
        #
        #   describe CheckingAccount, &quot;with $50&quot; do
        #     subject { CheckingAccount.new(:amount =&gt; 50, :currency =&gt; :USD) }
        #     it { should have_a_balance_of(50, :USD) }
        #     it { should_not be_overdrawn }
        #   end
        #
        # See +ExampleMethods#should+ for more information about this approach.
        def subject(&amp;block)
          block.nil? ?
            explicit_subject || implicit_subject : @_explicit_subject_block = block
        end
        
        def explicit_subject
          if defined?(@_explicit_subject_block)
            @_explicit_subject_block
          elsif super_subject = superclass.instance_variable_get('@_explicit_subject_block')
            super_subject
          else
            nil
          end
        end
        
        def implicit_subject
          (described_class ? lambda {described_class.new} : lambda {description_args.first})
        end
      end
      
      module ExampleMethods
        # Returns the subject defined in ExampleGroupMethods#subject. The
        # subject block is only executed once per example, the result of which
        # is cached and returned by any subsequent calls to +subject+.
        #
        # If a class is passed to +describe+ and no subject is explicitly
        # declared in the example group, then +subject+ will return a new
        # instance of that class.
        #
        # == Examples
        #
        #   # explicit subject defined by the subject method
        #   describe Person do
        #     subject { Person.new(:birthdate =&gt; 19.years.ago) }
        #     it &quot;should be eligible to vote&quot; do
        #       subject.should be_eligible_to_vote
        #     end
        #   end
        #
        #   # implicit subject =&gt; { Person.new }
        #   describe Person do
        #     it &quot;should be eligible to vote&quot; do
        #       subject.should be_eligible_to_vote
        #     end
        #   end
        def subject
          @subject ||= instance_eval(&amp;self.class.subject)
        end

        # When +should+ is called with no explicit receiver, the call is
        # delegated to the object returned by +subject+. Combined with
        # an implicit subject (see +subject+), this supports very concise
        # expressions.
        #
        # == Examples
        #
        #   describe Person do
        #     it { should be_eligible_to_vote }
        #   end
        def should(matcher=nil)
          if matcher
            subject.should(matcher)
          else
            subject.should
          end
        end

        # Just like +should+, +should_not+ delegates to the subject (implicit or
        # explicit) of the example group.
        #
        # == Examples
        #
        #   describe Person do
        #     it { should_not be_eligible_to_vote }
        #   end
        def should_not(matcher=nil)
          if matcher
            subject.should_not(matcher)
          else
            subject.should_not
          end
        end
      end
    end
  end
end</pre>
    </div>