  <div id="fileHeader">
    <h1>option_parser.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/runner/option_parser.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 20:07:22 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'optparse'
require 'stringio'

module Spec
  module Runner
    class OptionParser &lt; ::OptionParser
      class &lt;&lt; self
        def parse(args, err, out)
          parser = new(err, out)
          parser.parse(args)
          parser.options
        end

        def spec_command?
          $0.split('/').last == 'spec'
        end
      end

      attr_reader :options

      OPTIONS = {
        :pattern =&gt; [&quot;-p&quot;, &quot;--pattern [PATTERN]&quot;,&quot;Limit files loaded to those matching this pattern. Defaults to '**/*_spec.rb'&quot;,
                                                 &quot;Separate multiple patterns with commas.&quot;,
                                                 &quot;Applies only to directories named on the command line (files&quot;,
                                                 &quot;named explicitly on the command line will be loaded regardless).&quot;],
        :diff =&gt;    [&quot;-D&quot;, &quot;--diff [FORMAT]&quot;,&quot;Show diff of objects that are expected to be equal when they are not&quot;,
                                             &quot;Builtin formats: unified|u|context|c&quot;,
                                             &quot;You can also specify a custom differ class&quot;,
                                             &quot;(in which case you should also specify --require)&quot;],
        :colour =&gt;  [&quot;-c&quot;, &quot;--colour&quot;, &quot;--color&quot;, &quot;Show coloured (red/green) output&quot;],
        :example =&gt; [&quot;-e&quot;, &quot;--example [NAME|FILE_NAME]&quot;,  &quot;Execute example(s) with matching name(s). If the argument is&quot;,
                                                          &quot;the path to an existing file (typically generated by a previous&quot;,
                                                          &quot;run using --format failing_examples:file.txt), then the examples&quot;,
                                                          &quot;on each line of that file will be executed. If the file is empty,&quot;,
                                                          &quot;all examples will be run (as if --example was not specified).&quot;,
                                                          &quot; &quot;,
                                                          &quot;If the argument is not an existing file, then it is treated as&quot;,
                                                          &quot;an example name directly, causing RSpec to run just the example&quot;,
                                                          &quot;matching that name&quot;],
        :specification =&gt; [&quot;-s&quot;, &quot;--specification [NAME]&quot;, &quot;DEPRECATED - use -e instead&quot;, &quot;(This will be removed when autotest works with -e)&quot;],
        :line =&gt; [&quot;-l&quot;, &quot;--line LINE_NUMBER&quot;, Integer, &quot;Execute example group or example at given line.&quot;,
                                                       &quot;(does not work for dynamically generated examples)&quot;],
        :format =&gt; [&quot;-f&quot;, &quot;--format FORMAT[:WHERE]&quot;,&quot;Specifies what format to use for output. Specify WHERE to tell&quot;,
                                                    &quot;the formatter where to write the output. All built-in formats&quot;,
                                                    &quot;expect WHERE to be a file name, and will write to $stdout if it's&quot;,
                                                    &quot;not specified. The --format option may be specified several times&quot;,
                                                    &quot;if you want several outputs&quot;,
                                                    &quot; &quot;,
                                                    &quot;Builtin formats:&quot;,
                                                    &quot;silent|l                 : No output&quot;,                                                    &quot;progress|p               : Text-based progress bar&quot;,
                                                    &quot;profile|o                : Text-based progress bar with profiling of 10 slowest examples&quot;,
                                                    &quot;specdoc|s                : Code example doc strings&quot;,
                                                    &quot;nested|n                 : Code example doc strings with nested groups indented&quot;,
                                                    &quot;html|h                   : A nice HTML report&quot;,
                                                    &quot;failing_examples|e       : Write all failing examples - input for --example&quot;,
                                                    &quot;failing_example_groups|g : Write all failing example groups - input for --example&quot;,
                                                    &quot; &quot;,
                                                    &quot;FORMAT can also be the name of a custom formatter class&quot;,
                                                    &quot;(in which case you should also specify --require to load it)&quot;],
        :require =&gt; [&quot;-r&quot;, &quot;--require FILE&quot;, &quot;Require FILE before running specs&quot;,
                                             &quot;Useful for loading custom formatters or other extensions.&quot;,
                                             &quot;If this option is used it must come before the others&quot;],
        :backtrace =&gt; [&quot;-b&quot;, &quot;--backtrace&quot;, &quot;Output full backtrace&quot;],
        :loadby =&gt; [&quot;-L&quot;, &quot;--loadby STRATEGY&quot;, &quot;Specify the strategy by which spec files should be loaded.&quot;,
                                               &quot;STRATEGY can currently only be 'mtime' (File modification time)&quot;,
                                               &quot;By default, spec files are loaded in alphabetical order if --loadby&quot;,
                                               &quot;is not specified.&quot;],
        :reverse =&gt; [&quot;-R&quot;, &quot;--reverse&quot;, &quot;Run examples in reverse order&quot;],
        :timeout =&gt; [&quot;-t&quot;, &quot;--timeout FLOAT&quot;, &quot;Interrupt and fail each example that doesn't complete in the&quot;,
                                              &quot;specified time&quot;],
        :heckle =&gt; [&quot;-H&quot;, &quot;--heckle CODE&quot;, &quot;If all examples pass, this will mutate the classes and methods&quot;,
                                           &quot;identified by CODE little by little and run all the examples again&quot;,
                                           &quot;for each mutation. The intent is that for each mutation, at least&quot;,
                                           &quot;one example *should* fail, and RSpec will tell you if this is not the&quot;,
                                           &quot;case. CODE should be either Some::Module, Some::Class or&quot;,
                                           &quot;Some::Fabulous#method}&quot;],
        :dry_run =&gt; [&quot;-d&quot;, &quot;--dry-run&quot;, &quot;Invokes formatters without executing the examples.&quot;],
        :options_file =&gt; [&quot;-O&quot;, &quot;--options PATH&quot;, &quot;Read options from a file&quot;],
        :generate_options =&gt; [&quot;-G&quot;, &quot;--generate-options PATH&quot;, &quot;Generate an options file for --options&quot;],
        :runner =&gt; [&quot;-U&quot;, &quot;--runner RUNNER&quot;, &quot;Use a custom Runner.&quot;],
        :debug =&gt; [&quot;-u&quot;, &quot;--debugger&quot;, &quot;Enable ruby-debugging.&quot;],
        :drb =&gt; [&quot;-X&quot;, &quot;--drb&quot;, &quot;Run examples via DRb. (For example against script/spec_server)&quot;],
        :drb_port =&gt; [&quot;--port PORT&quot;, &quot;Port for DRb server. (Ignored without --drb)&quot;],
        :version =&gt; [&quot;-v&quot;, &quot;--version&quot;, &quot;Show version&quot;],
        :help =&gt; [&quot;-h&quot;, &quot;--help&quot;, &quot;You're looking at it&quot;]
      }

      def initialize(err, out)
        super()
        @error_stream = err
        @out_stream = out
        @options = Options.new(@error_stream, @out_stream)

        @file_factory = File

        self.banner = &quot;Usage: spec (FILE(:LINE)?|DIRECTORY|GLOB)+ [options]&quot;
        self.separator &quot;&quot;
        on(*OPTIONS[:pattern])          {|pattern| @options.filename_pattern = pattern}
        on(*OPTIONS[:diff])             {|diff| @options.parse_diff(diff)}
        on(*OPTIONS[:colour])           {@options.colour = true}
        on(*OPTIONS[:example])          {|example| @options.parse_example(example)}
        on(*OPTIONS[:specification])    {|example| @options.parse_example(example)}
        on(*OPTIONS[:line])             {|line_number| @options.line_number = line_number.to_i}
        on(*OPTIONS[:format])           {|format| @options.parse_format(format)}
        on(*OPTIONS[:require])          {|requires| invoke_requires(requires)}
        on(*OPTIONS[:backtrace])        {@options.backtrace_tweaker = NoisyBacktraceTweaker.new}
        on(*OPTIONS[:loadby])           {|loadby| @options.loadby = loadby}
        on(*OPTIONS[:reverse])          {@options.reverse = true}
        on(*OPTIONS[:timeout])          {|timeout| @options.timeout = timeout.to_f}
        on(*OPTIONS[:heckle])           {|heckle| @options.load_heckle_runner(heckle)}
        on(*OPTIONS[:dry_run])          {@options.dry_run = true}
        on(*OPTIONS[:options_file])     {|options_file|}
        on(*OPTIONS[:generate_options]) {|options_file|}
        on(*OPTIONS[:runner])           {|runner|  @options.user_input_for_runner = runner}
        on(*OPTIONS[:debug])            {@options.debug = true}
        on(*OPTIONS[:drb])              {}
        on(*OPTIONS[:drb_port])         {|port| @options.drb_port = port}
        on(*OPTIONS[:version])          {parse_version}
        on(&quot;--autospec&quot;)                {@options.autospec = true}
        on_tail(*OPTIONS[:help])        {parse_help}
      end

      def order!(argv, &amp;blk)
        @argv = argv.dup
        @argv = (@argv.empty? &amp; self.class.spec_command?) ? ['--help'] : @argv

        # Parse options file first
        parse_file_options(:options_file, :parse_options_file)

        @options.argv = @argv.dup
        return if parse_file_options(:generate_options, :write_options_file)
        return if parse_drb

        super(@argv) do |file|
          if file =~ /^(.+):(\d+)$/
            file = $1
            @options.line_number = $2.to_i
          end

          @options.files &lt;&lt; file
          blk.call(file) if blk
        end

        @options
      end

    protected

      def invoke_requires(requires)
        requires.split(&quot;,&quot;).each do |file|
          require file
        end
      end

      def parse_file_options(option_name, action)
        # Remove the file option and the argument before handling the file
        options_file = nil
        options_list = OPTIONS[option_name][0..1]
        options_list[1].gsub!(&quot; PATH&quot;, &quot;&quot;)
        options_list.each do |option|
          if index = @argv.index(option)
            @argv.delete_at(index)
            options_file = @argv.delete_at(index)
          end
        end
        
        if options_file.nil? &amp;&amp;
           File.exist?('spec/spec.opts') &amp;&amp;
           !@argv.any?{|a| a =~ /^\-/ }
             options_file = 'spec/spec.opts'
        end

        if options_file
          send(action, options_file)
          return true
        else
          return false
        end
      end

      def parse_options_file(options_file)
        option_file_args = File.readlines(options_file).map {|l| l.chomp.split &quot; &quot;}.flatten
        @argv.push(*option_file_args)
      end

      def write_options_file(options_file)
        File.open(options_file, 'w') do |io|
          io.puts @argv.join(&quot;\n&quot;)
        end
        @out_stream.puts &quot;\nOptions written to #{options_file}. You can now use these options with:&quot;
        @out_stream.puts &quot;spec --options #{options_file}&quot;
        @options.examples_should_not_be_run
      end

      def parse_drb
        argv = @options.argv
        is_drb = false
        is_drb ||= argv.delete(OPTIONS[:drb][0])
        is_drb ||= argv.delete(OPTIONS[:drb][1])
        return false unless is_drb
        if DrbCommandLine.run(self.class.parse(argv, @error_stream, @out_stream))
          @options.examples_should_not_be_run
          true
        else
          @error_stream.puts &quot;Running specs locally:&quot;
          false
        end
      end

      def parse_version
        @out_stream.puts ::Spec::VERSION::SUMMARY
        exit if stdout?
      end

      def parse_help
        @out_stream.puts self
        exit if stdout?
      end

      def stdout?
        @out_stream == $stdout
      end
    end
  end
end
</pre>
    </div>