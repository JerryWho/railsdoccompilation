  <div id="fileHeader">
    <h1>default.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/runner/differs/default.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 25 20:07:22 +0200 2010</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'spec/runner/differs/load-diff-lcs'
require 'pp'

module Spec
  module Expectations
    module Differs
      unless defined?(Spec::Expectations::Differs::Default)
        class Default
          def initialize(options)
            @options = options
          end

          # This is snagged from diff/lcs/ldiff.rb (which is a commandline tool)
          def diff_as_string(data_new, data_old)
            data_old = data_old.split(/\n/).map! { |e| e.chomp }
            data_new = data_new.split(/\n/).map! { |e| e.chomp }
            output = &quot;&quot;
            diffs = Diff::LCS.diff(data_old, data_new)
            return output if diffs.empty?
            oldhunk = hunk = nil  
            file_length_difference = 0
            diffs.each do |piece|
              begin
                hunk = Diff::LCS::Hunk.new(data_old, data_new, piece, context_lines,
                                           file_length_difference)
                file_length_difference = hunk.file_length_difference      
                next unless oldhunk      
                # Hunks may overlap, which is why we need to be careful when our
                # diff includes lines of context. Otherwise, we might print
                # redundant lines.
                if (context_lines &gt; 0) and hunk.overlaps?(oldhunk)
                  hunk.unshift(oldhunk)
                else
                  output &lt;&lt; oldhunk.diff(format)
                end
              ensure
                oldhunk = hunk
                output &lt;&lt; &quot;\n&quot;
              end
            end  
            #Handle the last remaining hunk
            output &lt;&lt; oldhunk.diff(format) &lt;&lt; &quot;\n&quot;
          end  

          def diff_as_object(target,expected)
            diff_as_string(PP.pp(target,&quot;&quot;), PP.pp(expected,&quot;&quot;))
          end
          
          def diff_as_hash(target, expected)
            contains_hash = false
            contains_array = false
            
            extra_expected_keys = expected.keys - target.keys
            extra_target_keys = target.keys - expected.keys
            
            o = &quot;\n&quot;
            
            o &lt;&lt; &quot;Expected hash contains keys that target hash does not: &quot; &lt;&lt; extra_expected_keys.inspect &lt;&lt; &quot;\n&quot; if !extra_expected_keys.empty?
            o &lt;&lt; &quot;Target hash contains keys that expected hash does not: &quot; &lt;&lt; extra_target_keys.inspect &lt;&lt; &quot;\n&quot; if !extra_target_keys.empty?
            
            expected.delete_if do |key, value|
              contains_hash = true if value.is_a?(Hash)
              contains_array = true if value.is_a?(Array)
              target[key]  == value
            end
            
            expected.keys.sort { |a,b| a.to_s &lt;=&gt; b.to_s }.each do |key|
              o &lt;&lt; &quot;Expected the key #{key.inspect} to be #{expected[key].inspect}, but was #{target[key].inspect}\n&quot;
            end
            
            o &lt;&lt; &quot;\n&quot;

            if contains_hash || contains_array
              o &lt;&lt; diff_as_object(target, expected)
            else
              o
            end
          end

          protected
          def format
            @options.diff_format
          end

          def context_lines
            @options.context_lines
          end
        end

      end
    end
  end
end
</pre>
    </div>