  <div id="fileHeader">
    <h1>base_text_formatter.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/spec/runner/formatter/base_text_formatter.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:57:53 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'spec/runner/formatter/base_formatter'
require 'fileutils'

module Spec
  module Runner
    module Formatter
      # Baseclass for text-based formatters. Can in fact be used for
      # non-text based ones too - just ignore the +output+ constructor
      # argument.
      class BaseTextFormatter &lt; BaseFormatter
        attr_reader :output, :example_group
        # Creates a new instance that will write to +output+. If +output+ is a
        # String, output will be written to the File with that name, otherwise
        # +output+ is exected to be an IO (or an object that responds to #puts
        # and #write).
        def initialize(options, output)
          @options = options
          if String === output
            FileUtils.mkdir_p(File.dirname(output))
            @output = File.open(output, 'w')
          else
            @output = output
          end
          @pending_examples = []
        end

        def example_group_started(example_group_proxy)
          @example_group = example_group_proxy
        end
        
        def example_pending(example, message, deprecated_pending_location=nil)
          @pending_examples &lt;&lt; [&quot;#{@example_group.description} #{example.description}&quot;, message, example.location]
        end
        
        def dump_failure(counter, failure)
          @output.puts
          @output.puts &quot;#{counter.to_s})&quot;
          @output.puts colorize_failure(&quot;#{failure.header}\n#{failure.exception.message}&quot;, failure)
          @output.puts format_backtrace(failure.exception.backtrace)
          @output.flush
        end
        
        def colorize_failure(message, failure)
          failure.pending_fixed? ? blue(message) : red(message)
        end
        
        def colourise(message, failure)
          Spec::deprecate(&quot;BaseTextFormatter#colourise&quot;, &quot;colorize_failure&quot;)
          colorize_failure(message, failure)
        end
        
        def dump_summary(duration, example_count, failure_count, pending_count)
          return if dry_run?
          @output.puts
          @output.puts &quot;Finished in #{duration} seconds&quot;
          @output.puts

          summary = &quot;#{example_count} example#{'s' unless example_count == 1}, #{failure_count} failure#{'s' unless failure_count == 1}&quot;
          summary &lt;&lt; &quot;, #{pending_count} pending&quot; if pending_count &gt; 0  

          if failure_count == 0
            if pending_count &gt; 0
              @output.puts yellow(summary)
            else
              @output.puts green(summary)
            end
          else
            @output.puts red(summary)
          end
          @output.flush
        end

        def dump_pending
          unless @pending_examples.empty?
            @output.puts
            @output.puts &quot;Pending:&quot;
            @pending_examples.each do |pending_example|
              @output.puts &quot;\n#{pending_example[0]} (#{pending_example[1]})&quot;
              @output.puts &quot;#{pending_example[2]}\n&quot;
            end
          end
          @output.flush
        end
        
        def close
          @output.close  if (IO === @output) &amp; (@output != $stdout)
        end
        
        def format_backtrace(backtrace)
          return &quot;&quot; if backtrace.nil?
          backtrace.map { |line| backtrace_line(line) }.join(&quot;\n&quot;)
        end
      
      protected

        def colour?
          !!@options.colour
        end

        def dry_run?
          !!@options.dry_run
        end
        
        def autospec?
          !!@options.autospec || ENV.has_key?(&quot;AUTOTEST&quot;)
        end
        
        def backtrace_line(line)
          line.sub(/\A([^:]+:\d+)$/, '\\1:')
        end

        def colour(text, colour_code)
          return text if output_to_file?
          return text unless ENV['RSPEC_COLOR'] || (colour? &amp; (autospec? || output_to_tty?)) 
          &quot;#{colour_code}#{text}\e[0m&quot;
        end

        def output_to_file?
          File === @output
        end
        
        def output_to_tty?
          begin
            @output.tty?
          rescue NoMethodError
            false
          end
        end
        
        def green(text); colour(text, &quot;\e[32m&quot;); end
        def red(text); colour(text, &quot;\e[31m&quot;); end
        def yellow(text); colour(text, &quot;\e[33m&quot;); end
        def blue(text); colour(text, &quot;\e[34m&quot;); end
        
        def magenta(text)
          Spec::deprecate(&quot;BaseTextFormatter#magenta&quot;)
          red(text)
        end
      end
    end
  end
end
</pre>
    </div>