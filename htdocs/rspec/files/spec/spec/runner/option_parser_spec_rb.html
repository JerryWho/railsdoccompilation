  <div id="fileHeader">
    <h1>option_parser_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/runner/option_parser_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper.rb'
require File.dirname(__FILE__) + '/resources/custom_example_group_runner'

require 'fileutils'

describe &quot;OptionParser&quot; do
  before(:each) do
    @out = StringIO.new
    @err = StringIO.new
    @parser = Spec::Runner::OptionParser.new(@err, @out)
  end

  def parse(args)
    @parser.parse(args)
    @parser.options
  end
  
  it &quot;should leave the submitted argv alone&quot; do
    args = [&quot;--pattern&quot;, &quot;foo&quot;]
    @parser.order!(args)
    args.should == [&quot;--pattern&quot;, &quot;foo&quot;]
  end
  
  it &quot;should accept files to include&quot; do
    options = parse([&quot;--pattern&quot;, &quot;foo&quot;])
    options.filename_pattern.should == &quot;foo&quot;
  end
  
  it &quot;should accept dry run option&quot; do
    options = parse([&quot;--dry-run&quot;])
    options.dry_run.should be_true
  end
  
  it &quot;should eval and use custom formatter when none of the builtins&quot; do
    options = parse([&quot;--format&quot;, &quot;Custom::Formatter&quot;])
    options.formatters[0].class.should be(Custom::Formatter)
  end
  
  it &quot;should support formatters with relative and absolute paths, even on windows&quot; do
    options = parse([
      &quot;--format&quot;, &quot;Custom::Formatter:C:\\foo\\bar&quot;,
      &quot;--format&quot;, &quot;Custom::Formatter:foo/bar&quot;,
      &quot;--format&quot;, &quot;Custom::Formatter:foo\\bar&quot;,
      &quot;--format&quot;, &quot;Custom::Formatter:/foo/bar&quot;
    ])
    options.formatters[0].where.should eql(&quot;C:\\foo\\bar&quot;)
    options.formatters[1].where.should eql(&quot;foo/bar&quot;)
    options.formatters[2].where.should eql(&quot;foo\\bar&quot;)
    options.formatters[3].where.should eql(&quot;/foo/bar&quot;)
  end
  
  it &quot;should not be verbose by default&quot; do
    options = parse([])
    options.verbose.should be_nil
  end
  
  it &quot;should not use colour by default&quot; do
    options = parse([])
    options.colour.should == false
  end
  
  it &quot;should print help to stdout if no args and spec_comand?&quot; do
    Spec::Runner::OptionParser.stub!(:spec_command?).and_return(true)
    options = parse([])
    @out.rewind
    @out.read.should match(/Usage: spec \(FILE\|DIRECTORY\|GLOB\)\+ \[options\]/m)
  end
    
  it &quot;should not print help to stdout if no args and NOT spec_command?&quot; do
    Spec::Runner::OptionParser.stub!(:spec_command?).and_return(false)
    options = parse([])
    @out.rewind
    @out.read.should == &quot;&quot;
  end
  
  it &quot;should print help to stdout&quot; do
    options = parse([&quot;--help&quot;])
    @out.rewind
    @out.read.should match(/Usage: spec \(FILE\|DIRECTORY\|GLOB\)\+ \[options\]/m)
  end
  
  it &quot;should print instructions about how to require missing formatter&quot; do
    lambda do 
      options = parse([&quot;--format&quot;, &quot;Custom::MissingFormatter&quot;]) 
      options.formatters
    end.should raise_error(NameError)
    @err.string.should match(/Couldn't find formatter class Custom::MissingFormatter/n)
  end
  
  it &quot;should print version to stdout&quot; do
    options = parse([&quot;--version&quot;])
    @out.rewind
    @out.read.should match(/rspec \d+\.\d+\.\d+/n)
  end
  
  it &quot;should require file when require specified&quot; do
    lambda do
      parse([&quot;--require&quot;, &quot;whatever&quot;])
    end.should raise_error(LoadError)
  end
  
  it &quot;should support c option&quot; do
    options = parse([&quot;-c&quot;])
    options.colour.should be_true
  end
  
  it &quot;should support queens colour option&quot; do
    options = parse([&quot;--colour&quot;])
    options.colour.should be_true
  end
  
  it &quot;should support us color option&quot; do
    options = parse([&quot;--color&quot;])
    options.colour.should be_true
  end
  
  it &quot;should support single example with -e option&quot; do
    options = parse([&quot;-e&quot;, &quot;something or other&quot;])
    options.examples.should eql([&quot;something or other&quot;])
  end
  
  it &quot;should support single example with -s option (will be removed when autotest supports -e)&quot; do
    options = parse([&quot;-s&quot;, &quot;something or other&quot;])
    options.examples.should eql([&quot;something or other&quot;])
  end
  
  it &quot;should support single example with --example option&quot; do
    options = parse([&quot;--example&quot;, &quot;something or other&quot;])
    options.examples.should eql([&quot;something or other&quot;])
  end
  
  it &quot;should read several example names from file if --example is given an existing file name&quot; do
    options = parse([&quot;--example&quot;, File.dirname(__FILE__) + '/examples.txt'])
    options.examples.should eql([
      &quot;Sir, if you were my husband, I would poison your drink.&quot;, 
      &quot;Madam, if you were my wife, I would drink it.&quot;])
  end
  
  it &quot;should read no examples if given an empty file&quot; do
    options = parse([&quot;--example&quot;, File.dirname(__FILE__) + '/empty_file.txt'])
    options.examples.should eql([])
  end
  
  it &quot;should use html formatter when format is h&quot; do
    options = parse([&quot;--format&quot;, &quot;h&quot;])
    options.formatters[0].class.should equal(Spec::Runner::Formatter::HtmlFormatter)
  end
  
  it &quot;should use html story formatter when format is h&quot; do
    options = parse([&quot;--format&quot;, &quot;h&quot;])
    options.story_formatters[0].class.should equal(Spec::Runner::Formatter::Story::HtmlFormatter)
  end
  
  it &quot;should use html formatter when format is html&quot; do
    options = parse([&quot;--format&quot;, &quot;html&quot;])
    options.formatters[0].class.should equal(Spec::Runner::Formatter::HtmlFormatter)
  end
  
  it &quot;should use html story formatter when format is html&quot; do
    options = parse([&quot;--format&quot;, &quot;html&quot;])
    options.story_formatters[0].class.should equal(Spec::Runner::Formatter::Story::HtmlFormatter)
  end
  
  it &quot;should use html formatter with explicit output when format is html:test.html&quot; do
    FileUtils.rm 'test.html' if File.exist?('test.html')
    options = parse([&quot;--format&quot;, &quot;html:test.html&quot;])
    options.formatters # creates the file
    File.should be_exist('test.html')
    options.formatters[0].class.should equal(Spec::Runner::Formatter::HtmlFormatter)
    options.formatters[0].close
    FileUtils.rm 'test.html'
  end
  
  it &quot;should use noisy backtrace tweaker with b option&quot; do
    options = parse([&quot;-b&quot;])
    options.backtrace_tweaker.should be_instance_of(Spec::Runner::NoisyBacktraceTweaker)
  end
  
  it &quot;should use noisy backtrace tweaker with backtrace option&quot; do
    options = parse([&quot;--backtrace&quot;])
    options.backtrace_tweaker.should be_instance_of(Spec::Runner::NoisyBacktraceTweaker)
  end
  
  it &quot;should use quiet backtrace tweaker by default&quot; do
    options = parse([])
    options.backtrace_tweaker.should be_instance_of(Spec::Runner::QuietBacktraceTweaker)
  end
  
  it &quot;should use progress bar formatter by default&quot; do
    options = parse([])
    options.formatters[0].class.should equal(Spec::Runner::Formatter::ProgressBarFormatter)
  end
  
  it &quot;should use specdoc formatter when format is s&quot; do
    options = parse([&quot;--format&quot;, &quot;s&quot;])
    options.formatters[0].class.should equal(Spec::Runner::Formatter::SpecdocFormatter)
  end
  
  it &quot;should use specdoc formatter when format is specdoc&quot; do
    options = parse([&quot;--format&quot;, &quot;specdoc&quot;])
    options.formatters[0].class.should equal(Spec::Runner::Formatter::SpecdocFormatter)
  end

  it &quot;should use nested text formatter when format is s&quot; do
    options = parse([&quot;--format&quot;, &quot;n&quot;])
    options.formatters[0].class.should equal(Spec::Runner::Formatter::NestedTextFormatter)
  end

  it &quot;should use nested text formatter when format is nested&quot; do
    options = parse([&quot;--format&quot;, &quot;nested&quot;])
    options.formatters[0].class.should equal(Spec::Runner::Formatter::NestedTextFormatter)
  end
  
  it &quot;should support diff option when format is not specified&quot; do
    options = parse([&quot;--diff&quot;])
    options.diff_format.should == :unified
  end
  
  it &quot;should use unified diff format option when format is unified&quot; do
    options = parse([&quot;--diff&quot;, &quot;unified&quot;])
    options.diff_format.should == :unified
    options.differ_class.should equal(Spec::Expectations::Differs::Default)
  end
  
  it &quot;should use context diff format option when format is context&quot; do
    options = parse([&quot;--diff&quot;, &quot;context&quot;])
    options.diff_format.should == :context
    options.differ_class.should == Spec::Expectations::Differs::Default
  end
  
  it &quot;should use custom diff format option when format is a custom format&quot; do
    Spec::Expectations.differ.should_not be_instance_of(Custom::Differ)
  
    options = parse([&quot;--diff&quot;, &quot;Custom::Differ&quot;])
    options.parse_diff &quot;Custom::Differ&quot;
    options.diff_format.should == :custom
    options.differ_class.should == Custom::Differ
    Spec::Expectations.differ.should be_instance_of(Custom::Differ)
  end
  
  it &quot;should print instructions about how to fix missing differ&quot; do
    lambda { parse([&quot;--diff&quot;, &quot;Custom::MissingFormatter&quot;]) }.should raise_error(NameError)
    @err.string.should match(/Couldn't find differ class Custom::MissingFormatter/n)
  end
  
  describe &quot;when attempting a focussed spec&quot; do
    attr_reader :file, :dir
    before(:each) do
      @original_rspec_options = Spec::Runner.options
      @file = &quot;#{File.dirname(__FILE__)}/spec_parser/spec_parser_fixture.rb&quot;
      @dir = File.dirname(file)
    end
  
    after(:each) do
      Spec::Runner.use @original_rspec_options
    end
  
    def parse(args)
      options = super
      Spec::Runner.use options
      options.filename_pattern = &quot;*_fixture.rb&quot;
      options
    end
  
    it &quot;should support --line to identify spec&quot; do
      options = parse([file, &quot;--line&quot;, &quot;13&quot;])
      options.line_number.should == 13
      options.examples.should be_empty
      options.run_examples
      options.examples.should eql([&quot;d&quot;])
    end
  
    it &quot;should fail with error message if file is dir along with --line&quot; do
      options = parse([dir, &quot;--line&quot;, &quot;169&quot;])
      options.line_number.should == 169
      options.run_examples
      @err.string.should match(/You must specify one file, not a directory when using the --line option/n)
    end
  
    it &quot;should fail with error message if file does not exist along with --line&quot; do
      options = parse([&quot;some file&quot;, &quot;--line&quot;, &quot;169&quot;])
      proc do
        options.run_examples
      end.should raise_error
    end
  
    it &quot;should fail with error message if more than one files are specified along with --line&quot; do
      options = parse([file, file, &quot;--line&quot;, &quot;169&quot;])
      options.run_examples
      @err.string.should match(/Only one file can be specified when using the --line option/n)
    end
  
    it &quot;should fail with error message if --example and --line are used simultaneously&quot; do
      options = parse([file, &quot;--example&quot;, &quot;some example&quot;, &quot;--line&quot;, &quot;169&quot;])
      options.run_examples
      @err.string.should match(/You cannot use both --line and --example/n)
    end
  end
  
  if [/mswin/, /java/].detect{|p| p =~ RUBY_PLATFORM}
    it &quot;should barf when --heckle is specified (and platform is windows)&quot; do
      lambda do
        options = parse([&quot;--heckle&quot;, &quot;Spec&quot;])
      end.should raise_error(StandardError, &quot;Heckle not supported on Windows&quot;)
    end
  else
    it &quot;should heckle when --heckle is specified (and platform is not windows)&quot; do
      options = parse([&quot;--heckle&quot;, &quot;Spec&quot;])
      options.heckle_runner.should be_instance_of(Spec::Runner::HeckleRunner)
    end
  end
  
  it &quot;should read options from file when --options is specified&quot; do
    options = parse([&quot;--options&quot;, File.dirname(__FILE__) + &quot;/spec.opts&quot;])
    options.diff_format.should_not be_nil
    options.colour.should be_true
  end
  
  it &quot;should default the formatter to ProgressBarFormatter when using options file&quot; do
    options = parse([&quot;--options&quot;, File.dirname(__FILE__) + &quot;/spec.opts&quot;])
    options.formatters.first.should be_instance_of(::Spec::Runner::Formatter::ProgressBarFormatter)
  end

  it &quot;should run parse drb after parsing options&quot; do
    @parser.stub!(:parse_drb)
    @parser.should_receive(:parse_drb).with([&quot;--drb&quot;]).and_return(true)
    options = parse([&quot;--options&quot;, File.dirname(__FILE__) + &quot;/spec_drb.opts&quot;])    
  end

  it &quot;should read spaced and multi-line options from file when --options is specified&quot; do
    options = parse([&quot;--options&quot;, File.dirname(__FILE__) + &quot;/spec_spaced.opts&quot;])
    options.diff_format.should_not be_nil
    options.colour.should be_true
    options.formatters.first.should be_instance_of(::Spec::Runner::Formatter::SpecdocFormatter)
  end
   
  it &quot;should save config to file when --generate-options is specified&quot; do
    FileUtils.rm 'test.spec.opts' if File.exist?('test.spec.opts')
    options = parse([&quot;--colour&quot;, &quot;--generate-options&quot;, &quot;test.spec.opts&quot;, &quot;--diff&quot;])
    IO.read('test.spec.opts').should == &quot;--colour\n--diff\n&quot;
    FileUtils.rm 'test.spec.opts'
  end
  
  it &quot;should save config to file when -G is specified&quot; do
    FileUtils.rm 'test.spec.opts' if File.exist?('test.spec.opts')
    options = parse([&quot;--colour&quot;, &quot;-G&quot;, &quot;test.spec.opts&quot;, &quot;--diff&quot;])
    IO.read('test.spec.opts').should == &quot;--colour\n--diff\n&quot;
    FileUtils.rm 'test.spec.opts'
  end
  
  it &quot;when --drb is specified, calls DrbCommandLine all of the other ARGV arguments&quot; do
    options = Spec::Runner::OptionParser.parse([
      &quot;some/spec.rb&quot;, &quot;--diff&quot;, &quot;--colour&quot;
    ], @err, @out)
    Spec::Runner::DrbCommandLine.should_receive(:run).and_return do |options|
      options.argv.should == [&quot;some/spec.rb&quot;, &quot;--diff&quot;, &quot;--colour&quot;]
    end
    parse([&quot;some/spec.rb&quot;, &quot;--diff&quot;, &quot;--drb&quot;, &quot;--colour&quot;])
  end
  
  it &quot;should reverse spec order when --reverse is specified&quot; do
    options = parse([&quot;some/spec.rb&quot;, &quot;--reverse&quot;])
  end
  
  it &quot;should set an mtime comparator when --loadby mtime&quot; do
    options = parse([&quot;--loadby&quot;, 'mtime'])
    runner = Spec::Runner::ExampleGroupRunner.new(options)
    Spec::Runner::ExampleGroupRunner.should_receive(:new).
      with(options).
      and_return(runner)
    runner.should_receive(:load_files).with([&quot;most_recent_spec.rb&quot;, &quot;command_line_spec.rb&quot;])
  
    Dir.chdir(File.dirname(__FILE__)) do
      options.files &lt;&lt; 'command_line_spec.rb'
      options.files &lt;&lt; 'most_recent_spec.rb'
      FileUtils.touch &quot;most_recent_spec.rb&quot;
      options.run_examples
      FileUtils.rm &quot;most_recent_spec.rb&quot;
    end
  end
  
  it &quot;should use the standard runner by default&quot; do
    runner = ::Spec::Runner::ExampleGroupRunner.new(@parser.options)
    ::Spec::Runner::ExampleGroupRunner.should_receive(:new).
      with(@parser.options).
      and_return(runner)
    options = parse([])
    options.run_examples
  end
  
  it &quot;should use a custom runner when given&quot; do
    runner = Custom::ExampleGroupRunner.new(@parser.options, nil)
    Custom::ExampleGroupRunner.should_receive(:new).
      with(@parser.options, nil).
      and_return(runner)
    options = parse([&quot;--runner&quot;, &quot;Custom::ExampleGroupRunner&quot;])
    options.run_examples
  end
  
  it &quot;should use a custom runner with extra options&quot; do
    runner = Custom::ExampleGroupRunner.new(@parser.options, 'something')
    Custom::ExampleGroupRunner.should_receive(:new).
      with(@parser.options, 'something').
      and_return(runner)
    options = parse([&quot;--runner&quot;, &quot;Custom::ExampleGroupRunner:something&quot;])
    options.run_examples
  end
end
</pre>
    </div>