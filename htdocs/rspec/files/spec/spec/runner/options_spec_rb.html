  <div id="fileHeader">
    <h1>options_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/runner/options_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper'
require File.dirname(__FILE__) + '/resources/custom_example_group_runner'

module Spec
  module Runner
    describe Options do
      before(:each) do
        @err = StringIO.new('')
        @out = StringIO.new('')
        @options = Options.new(@err, @out)
      end

      after(:each) do
        Spec::Expectations.differ = nil
      end

      describe &quot;#examples&quot; do
        it &quot;should default to empty array&quot; do
          @options.examples.should == []
        end
      end
      
      describe &quot;#include_pattern&quot; do
        it &quot;should default to '**/*_spec.rb'&quot; do
          @options.filename_pattern.should == &quot;**/*_spec.rb&quot;
        end
      end
      
      describe &quot;#files_to_load&quot; do
        
        it &quot;should load files not following pattern if named explicitly&quot; do
          file = File.expand_path(File.dirname(__FILE__) + &quot;/resources/a_bar.rb&quot;)
          @options.files &lt;&lt; file
          @options.files_to_load.should include(file)
        end
        
        describe &quot;with default --pattern&quot; do
          it &quot;should load files named _spec.rb&quot; do
            dir = File.expand_path(File.dirname(__FILE__) + &quot;/resources/&quot;)
            @options.files &lt;&lt; dir
            @options.files_to_load.should == [&quot;#{dir}/a_spec.rb&quot;]
          end
        end
        
        describe &quot;with explicit pattern (single)&quot; do
          before(:each) do
            @options.filename_pattern = &quot;**/*_foo.rb&quot;
          end
        
          it &quot;should load files following pattern&quot; do
            file = File.expand_path(File.dirname(__FILE__) + &quot;/resources/a_foo.rb&quot;)
            @options.files &lt;&lt; file
            @options.files_to_load.should include(file)
          end
        
          it &quot;should load files in directories following pattern&quot; do
            dir = File.expand_path(File.dirname(__FILE__) + &quot;/resources&quot;)
            @options.files &lt;&lt; dir
            @options.files_to_load.should include(&quot;#{dir}/a_foo.rb&quot;)
          end
        
          it &quot;should not load files in directories not following pattern&quot; do
            dir = File.expand_path(File.dirname(__FILE__) + &quot;/resources&quot;)
            @options.files &lt;&lt; dir
            @options.files_to_load.should_not include(&quot;#{dir}/a_bar.rb&quot;)
          end
        end
        
        describe &quot;with explicit pattern (comma,separated,values)&quot; do
          
          before(:each) do
            @options.filename_pattern = &quot;**/*_foo.rb,**/*_bar.rb&quot;
          end

          it &quot;should support comma separated values&quot; do
            dir = File.expand_path(File.dirname(__FILE__) + &quot;/resources&quot;)
            @options.files &lt;&lt; dir
            @options.files_to_load.should include(&quot;#{dir}/a_foo.rb&quot;)
            @options.files_to_load.should include(&quot;#{dir}/a_bar.rb&quot;)
          end
        
          it &quot;should support comma separated values with spaces&quot; do
            dir = File.expand_path(File.dirname(__FILE__) + &quot;/resources&quot;)
            @options.files &lt;&lt; dir
            @options.files_to_load.should include(&quot;#{dir}/a_foo.rb&quot;)
            @options.files_to_load.should include(&quot;#{dir}/a_bar.rb&quot;)
          end
        
        end
      
      end

      describe &quot;#backtrace_tweaker&quot; do
        it &quot;should default to QuietBacktraceTweaker&quot; do
          @options.backtrace_tweaker.class.should == QuietBacktraceTweaker
        end
      end

      describe &quot;#dry_run&quot; do
        it &quot;should default to false&quot; do
          @options.dry_run.should == false
        end
      end

      describe &quot;#context_lines&quot; do
        it &quot;should default to 3&quot; do
          @options.context_lines.should == 3
        end
      end

      describe &quot;#parse_diff with nil&quot; do
        before(:each) do
          @options.parse_diff nil
        end

        it &quot;should make diff_format unified&quot; do
          @options.diff_format.should == :unified
        end

        it &quot;should set Spec::Expectations.differ to be a default differ&quot; do
          Spec::Expectations.differ.class.should ==
            ::Spec::Expectations::Differs::Default
        end
      end

      describe &quot;#parse_diff with 'unified'&quot; do
        before(:each) do
          @options.parse_diff 'unified'
        end

        it &quot;should make diff_format unified and uses default differ_class&quot; do
          @options.diff_format.should == :unified
          @options.differ_class.should equal(Spec::Expectations::Differs::Default)
        end

        it &quot;should set Spec::Expectations.differ to be a default differ&quot; do
          Spec::Expectations.differ.class.should ==
            ::Spec::Expectations::Differs::Default
        end
      end

      describe &quot;#parse_diff with 'context'&quot; do
        before(:each) do
          @options.parse_diff 'context'
        end

        it &quot;should make diff_format context and uses default differ_class&quot; do
          @options.diff_format.should == :context
          @options.differ_class.should == Spec::Expectations::Differs::Default
        end

        it &quot;should set Spec::Expectations.differ to be a default differ&quot; do
          Spec::Expectations.differ.class.should ==
            ::Spec::Expectations::Differs::Default
        end
      end

      describe &quot;#parse_diff with Custom::Differ&quot; do
        before(:each) do
          @options.parse_diff 'Custom::Differ'
        end

        it &quot;should use custom differ_class&quot; do
          @options.diff_format.should == :custom
          @options.differ_class.should == Custom::Differ
          Spec::Expectations.differ.should be_instance_of(Custom::Differ)
        end

        it &quot;should set Spec::Expectations.differ to be a default differ&quot; do
          Spec::Expectations.differ.class.should ==
            ::Custom::Differ
        end
      end

      describe &quot;#parse_diff with missing class name&quot; do
        it &quot;should raise error&quot; do
          lambda { @options.parse_diff &quot;Custom::MissingDiffer&quot; }.should raise_error(NameError)
          @err.string.should match(/Couldn't find differ class Custom::MissingDiffer/n)
        end
      end

      describe &quot;#parse_example&quot; do
        it &quot;with argument thats not a file path, sets argument as the example&quot; do
          example = &quot;something or other&quot;
          File.file?(example).should == false
          @options.parse_example example
          @options.examples.should eql([&quot;something or other&quot;])
        end

        it &quot;with argument that is a file path, sets examples to contents of the file&quot; do
          example = &quot;#{File.dirname(__FILE__)}/examples.txt&quot;
          File.should_receive(:file?).with(example).and_return(true)
          file = StringIO.new(&quot;Sir, if you were my husband, I would poison your drink.\nMadam, if you were my wife, I would drink it.&quot;)
          File.should_receive(:open).with(example).and_return(file)

          @options.parse_example example
          @options.examples.should eql([
            &quot;Sir, if you were my husband, I would poison your drink.&quot;,
              &quot;Madam, if you were my wife, I would drink it.&quot;
          ])
        end
      end

      describe &quot;#examples_should_not_be_run&quot; do
        it &quot;should cause #run_examples to return true and do nothing&quot; do
          @options.examples_should_not_be_run
          ExampleGroupRunner.should_not_receive(:new)

          @options.run_examples.should be_true
        end
      end

      describe &quot;#load_class&quot; do
        it &quot;should raise error when not class name&quot; do
          lambda do
            @options.__send__(:load_class, 'foo', 'fruit', '--food')
          end.should raise_error('&quot;foo&quot; is not a valid class name')
        end
      end

      describe &quot;#reporter&quot; do
        it &quot;returns a Reporter&quot; do
          @options.reporter.should be_instance_of(Reporter)
          @options.reporter.options.should === @options
        end
      end
      
      describe &quot;#number_of_examples&quot; do
        context &quot;when --example is parsed&quot; do
          it &quot;provides the number of examples parsed instead of the total number of examples collected&quot; do
            @example_group = Class.new(::Spec::Example::ExampleGroup).describe(&quot;Some Examples&quot;) do
              it &quot;uses this example_group 1&quot; do; end
              it &quot;uses this example_group 2&quot; do; end
              it &quot;uses this example_group 3&quot; do; end
            end
            @options.add_example_group @example_group
            @options.parse_example(&quot;an example&quot;)
            @options.number_of_examples.should == 1
          end
        end
      end

      describe &quot;#add_example_group affecting passed in example_group&quot; do
        it &quot;runs all examples when options.examples is empty&quot; do
          example_1_has_run = false
          example_2_has_run = false
          @example_group = Class.new(::Spec::Example::ExampleGroup).describe(&quot;Some Examples&quot;) do
            it &quot;runs 1&quot; do
              example_1_has_run = true
            end
            it &quot;runs 2&quot; do
              example_2_has_run = true
            end
          end

          @options.examples.clear

          @options.add_example_group @example_group
          @options.run_examples
          example_1_has_run.should be_true
          example_2_has_run.should be_true
        end

        it &quot;keeps all example_definitions when options.examples is empty&quot; do
          example_1_has_run = false
          example_2_has_run = false
          @example_group = Class.new(::Spec::Example::ExampleGroup).describe(&quot;Some Examples&quot;) do
            it &quot;runs 1&quot; do
              example_1_has_run = true
            end
            it &quot;runs 2&quot; do
              example_2_has_run = true
            end
          end

          @options.add_example_group @example_group
          @options.run_examples
          example_1_has_run.should be_true
          example_2_has_run.should be_true
        end
      end

      describe &quot;#add_example_group affecting example_group&quot; do
        it &quot;adds example_group when example_group has example_definitions and is not shared&quot; do
          @example_group = Class.new(::Spec::Example::ExampleGroup).describe(&quot;Some Examples&quot;) do
            it &quot;uses this example_group&quot; do
            end
          end

          @options.number_of_examples.should == 0
          @options.add_example_group @example_group
          @options.number_of_examples.should == 1
          @options.example_groups.length.should == 1
        end
      end

      describe &quot;#remove_example_group&quot; do
        it &quot;should remove the ExampleGroup from the list of ExampleGroups&quot; do
          @example_group = Class.new(::Spec::Example::ExampleGroup).describe(&quot;Some Examples&quot;) do
          end
          @options.add_example_group @example_group
          @options.example_groups.should include(@example_group)

          @options.remove_example_group @example_group
          @options.example_groups.should_not include(@example_group)
        end
      end

      describe &quot;#run_examples&quot; do
        describe &quot;when not given a custom runner&quot; do
          it &quot;should use the standard&quot; do
            runner = ::Spec::Runner::ExampleGroupRunner.new(@options)
            ::Spec::Runner::ExampleGroupRunner.should_receive(:new).
            with(@options).
            and_return(runner)
            @options.user_input_for_runner = nil

            @options.run_examples
          end
        end

        describe &quot;when given a custom runner&quot; do
          it &quot;should use the custom runner&quot; do
            runner = Custom::ExampleGroupRunner.new(@options, nil)
            Custom::ExampleGroupRunner.should_receive(:new).
            with(@options, nil).
            and_return(runner)
            @options.user_input_for_runner = &quot;Custom::ExampleGroupRunner&quot;

            @options.run_examples
          end

          it &quot;should use the custom runner with extra options&quot; do
            runner = Custom::ExampleGroupRunner.new(@options, 'something')
            Custom::ExampleGroupRunner.should_receive(:new).
            with(@options, 'something').
            and_return(runner)
            @options.user_input_for_runner = &quot;Custom::ExampleGroupRunner:something&quot;

            @options.run_examples
          end
        end

        describe &quot;when there are examples&quot; do
          before(:each) do
            @example_group = Class.new(::Spec::Example::ExampleGroup)
            @options.add_example_group @example_group
            @options.formatters &lt;&lt; Formatter::BaseTextFormatter.new(@options, @out)
          end

          it &quot;runs the Examples and outputs the result&quot; do
            @options.run_examples
            @out.string.should include(&quot;0 examples, 0 failures&quot;)
          end

          it &quot;sets #examples_run? to true&quot; do
            @options.examples_run?.should be_false
            @options.run_examples
            @options.examples_run?.should be_true
          end

          describe &quot;and the suite passes&quot; do
            before do
              @example_group.should_receive(:run).and_return(true)
            end

            it &quot;invokes after_suite_parts with true&quot; do
              success_result = nil
              @options.after_suite_parts &lt;&lt; lambda do |success|
                success_result = success
              end
              
              @options.run_examples
              success_result.should be_true
            end
          end

          describe &quot;and the suite fails&quot; do
            before do
              @example_group.should_receive(:run).and_return(false)
            end

            it &quot;invokes after_suite_parts with false&quot; do
              success_result = nil
              @options.after_suite_parts &lt;&lt; lambda do |success|
                success_result = success
              end

              @options.run_examples
              success_result.should be_false
            end
          end

          describe &quot;when using heckle runner&quot; do
            before(:each) do
              @heckle_runner_mock = mock(&quot;HeckleRunner&quot;)
              @options.heckle_runner = @heckle_runner_mock
            end
            
            it &quot;should heckle&quot; do
              @heckle_runner_mock.should_receive(:heckle_with)
              @options.run_examples
            end
            
            it &quot;shouldn't heckle recursively&quot; do
              heckled = false
              @heckle_runner_mock.should_receive(:heckle_with) {
                heckled.should == false
                heckled = true
                @options.run_examples
              }
              @options.run_examples
            end

            it &quot;shouldn't load spec files twice&quot; do
              example_runner = mock(&quot;ExampleGroupRunner&quot;)
              example_runner_inside_heckle = mock(&quot;ExampleGroupRunner inside Heckle&quot;)

              ExampleGroupRunner.should_receive(:new).twice.and_return(
                example_runner, example_runner_inside_heckle
              )

              example_runner.stub!(:run)
              example_runner.should_receive(:load_files)
              @heckle_runner_mock.stub!(:heckle_with).and_return { @options.run_examples }
              example_runner_inside_heckle.stub!(:run)
              example_runner_inside_heckle.should_not_receive(:load_files)

              @options.run_examples
            end
          end
        end

        describe &quot;when there are no examples&quot; do
          before(:each) do
            @options.formatters &lt;&lt; Formatter::BaseTextFormatter.new(@options, @out)
          end

          it &quot;does not run Examples and does not output a result&quot; do
            @options.run_examples
            @out.string.should_not include(&quot;examples&quot;)
            @out.string.should_not include(&quot;failures&quot;)
          end

          it &quot;sets #examples_run? to false&quot; do
            @options.examples_run?.should be_false
            @options.run_examples
            @options.examples_run?.should be_false
          end

          it &quot;invokes after_suite_parts with true&quot; do
            success_result = nil
            @options.after_suite_parts &lt;&lt; lambda do |success|
              success_result = success
            end

            @options.run_examples
            success_result.should be_true
          end
        end
      end
    end
  end
end
</pre>
    </div>