  <div id="fileHeader">
    <h1>stub_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/mocks/stub_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper.rb'

module Spec
  module Mocks
    describe &quot;A method stub&quot; do
      before(:each) do
        @class = Class.new do
          def self.existing_class_method
            :original_value
          end

          def existing_instance_method
            :original_value
          end
        end
        @instance = @class.new
        @stub = Object.new
      end

      it &quot;should return expected value when expected message is received&quot; do
        @instance.stub!(:msg).and_return(:return_value)
        @instance.msg.should equal(:return_value)
        @instance.rspec_verify
      end

      it &quot;should ignore when expected message is received&quot; do
        @instance.stub!(:msg)
        @instance.msg
        lambda do
          @instance.rspec_verify
        end.should_not raise_error
      end

      it &quot;should ignore when message is received with args&quot; do
        @instance.stub!(:msg)
        @instance.msg(:an_arg)
        lambda do
          @instance.rspec_verify
        end.should_not raise_error
      end

      it &quot;should ignore when expected message is not received&quot; do
        @instance.stub!(:msg)
        lambda do
          @instance.rspec_verify
        end.should_not raise_error
      end

      it &quot;should handle multiple stubbed methods&quot; do
        @instance.stub!(:msg1 =&gt; 1, :msg2 =&gt; 2)
        @instance.msg1.should == 1
        @instance.msg2.should == 2
      end
      
      it &quot;should clear itself when verified&quot; do
        @instance.stub!(:this_should_go).and_return(:blah)
        @instance.this_should_go.should == :blah
        @instance.rspec_verify
        lambda do
          @instance.this_should_go
        end.should raise_error(NameError)
      end

      it &quot;should return values in order to consecutive calls&quot; do
        return_values = [&quot;1&quot;,2,Object.new]
        @instance.stub!(:msg).and_return(return_values[0],return_values[1],return_values[2])
        @instance.msg.should == return_values[0]
        @instance.msg.should == return_values[1]
        @instance.msg.should == return_values[2]
      end

      it &quot;should keep returning last value in consecutive calls&quot; do
        return_values = [&quot;1&quot;,2,Object.new]
        @instance.stub!(:msg).and_return(return_values[0],return_values[1],return_values[2])
        @instance.msg.should == return_values[0]
        @instance.msg.should == return_values[1]
        @instance.msg.should == return_values[2]
        @instance.msg.should == return_values[2]
        @instance.msg.should == return_values[2]
      end

      it &quot;should revert to original instance method if there is one&quot; do
        @instance.existing_instance_method.should equal(:original_value)
        @instance.stub!(:existing_instance_method).and_return(:mock_value)
        @instance.existing_instance_method.should equal(:mock_value)
        @instance.rspec_verify
        @instance.existing_instance_method.should equal(:original_value)
      end
      
      it &quot;should revert to original class method if there is one&quot; do
        @class.existing_class_method.should equal(:original_value)
        @class.stub!(:existing_class_method).and_return(:mock_value)
        @class.existing_class_method.should equal(:mock_value)
        @class.rspec_verify
        @class.existing_class_method.should equal(:original_value)
      end

      it &quot;should yield a specified object&quot; do
        @instance.stub!(:method_that_yields).and_yield(:yielded_obj)
        current_value = :value_before
        @instance.method_that_yields {|val| current_value = val}
        current_value.should == :yielded_obj
        @instance.rspec_verify
      end

      it &quot;should yield multiple times with multiple calls to and_yield&quot; do
        @instance.stub!(:method_that_yields_multiple_times).and_yield(:yielded_value).
                                                       and_yield(:another_value)
        current_value = []
        @instance.method_that_yields_multiple_times {|val| current_value &lt;&lt; val}
        current_value.should == [:yielded_value, :another_value]
        @instance.rspec_verify
      end
      
      it &quot;should yield a specified object and return another specified object&quot; do
        yielded_obj = mock(&quot;my mock&quot;)
        yielded_obj.should_receive(:foo).with(:bar)
        @instance.stub!(:method_that_yields_and_returns).and_yield(yielded_obj).and_return(:baz)
        @instance.method_that_yields_and_returns { |o| o.foo :bar }.should == :baz
      end

      it &quot;should throw when told to&quot; do
        @mock.stub!(:something).and_throw(:up)
        lambda do
          @mock.something
        end.should throw_symbol(:up)
      end
      
      it &quot;should override a pre-existing stub&quot; do
        @stub.stub!(:existing_instance_method).and_return(:updated_stub_value)
        @stub.existing_instance_method.should == :updated_stub_value
      end
      
      it &quot;should limit &quot; do
        @stub.stub!(:foo).with(&quot;bar&quot;)
        @stub.should_receive(:foo).with(&quot;baz&quot;)
        @stub.foo(&quot;bar&quot;)
        @stub.foo(&quot;baz&quot;)
      end
    end
    
    describe &quot;A method stub with args&quot; do
      before(:each) do
        @stub = Object.new
        @stub.stub!(:foo).with(&quot;bar&quot;)
      end

      it &quot;should not complain if not called&quot; do
      end

      it &quot;should not complain if called with arg&quot; do
        @stub.foo(&quot;bar&quot;)
      end

      it &quot;should complain if called with no arg&quot; do
        lambda do
          @stub.foo
        end.should raise_error
      end

      it &quot;should complain if called with other arg&quot; do
        lambda do
          @stub.foo(&quot;other&quot;)
        end.should raise_error
      end

      it &quot;should not complain if also mocked w/ different args&quot; do
        @stub.should_receive(:foo).with(&quot;baz&quot;)
        @stub.foo(&quot;bar&quot;)
        @stub.foo(&quot;baz&quot;)
      end

      it &quot;should complain if also mocked w/ different args AND called w/ a 3rd set of args&quot; do
        @stub.should_receive(:foo).with(&quot;baz&quot;)
        @stub.foo(&quot;bar&quot;)
        @stub.foo(&quot;baz&quot;)
        lambda do
          @stub.foo(&quot;other&quot;)
        end.should raise_error
      end
      
      it &quot;should support options&quot; do
        @stub.stub!(:foo, :expected_from =&gt; &quot;bar&quot;)
      end
    end

  end
end
</pre>
    </div>