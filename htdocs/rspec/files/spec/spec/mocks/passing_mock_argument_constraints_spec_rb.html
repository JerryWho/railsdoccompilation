  <div id="fileHeader">
    <h1>passing_mock_argument_constraints_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/mocks/passing_mock_argument_constraints_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper.rb'

module Spec
  module Mocks
    describe &quot;mock argument constraints&quot;, :shared =&gt; true do
      before(:each) do
        @mock = Mock.new(&quot;test mock&quot;)
        Kernel.stub!(:warn)
      end
      
      after(:each) do
        @mock.rspec_verify
      end
    end
    
    describe Methods, &quot;handling argument constraints&quot; do
      it_should_behave_like &quot;mock argument constraints&quot;

      it &quot;should accept true as boolean()&quot; do
        @mock.should_receive(:random_call).with(boolean())
        @mock.random_call(true)
      end

      it &quot;should accept false as boolean()&quot; do
        @mock.should_receive(:random_call).with(boolean())
        @mock.random_call(false)
      end

      it &quot;should accept fixnum as an_instance_of(Numeric)&quot; do
        @mock.should_receive(:random_call).with(an_instance_of(Numeric))
        @mock.random_call(1)
      end

      it &quot;should accept float as an_instance_of(Numeric)&quot; do
        @mock.should_receive(:random_call).with(an_instance_of(Numeric))
        @mock.random_call(1.5)
      end

      it &quot;should accept string as anything()&quot; do
        @mock.should_receive(:random_call).with(&quot;a&quot;, anything(), &quot;c&quot;)
        @mock.random_call(&quot;a&quot;, &quot;whatever&quot;, &quot;c&quot;)
      end

      it &quot;should match duck type with one method&quot; do
        @mock.should_receive(:random_call).with(duck_type(:length))
        @mock.random_call([])
      end

      it &quot;should match duck type with two methods&quot; do
        @mock.should_receive(:random_call).with(duck_type(:abs, :div))
        @mock.random_call(1)
      end
      
      it &quot;should match no args against any_args()&quot; do
        @mock.should_receive(:random_call).with(any_args)
        @mock.random_call()
      end
      
      it &quot;should match one arg against any_args()&quot; do
        @mock.should_receive(:random_call).with(any_args)
        @mock.random_call(&quot;a string&quot;)
      end
      
      it &quot;should match no args against no_args()&quot; do
        @mock.should_receive(:random_call).with(no_args)
        @mock.random_call()
      end
      
      it &quot;should match hash with hash_including same hash&quot; do
        @mock.should_receive(:random_call).with(hash_including(:a =&gt; 1))
        @mock.random_call(:a =&gt; 1)
      end
        
    end

    describe Methods, &quot;handling block constraints&quot; do
      it_should_behave_like &quot;mock argument constraints&quot;
      
      it &quot;should match arguments against RSpec expectations&quot; do
        @mock.should_receive(:random_call).with {|arg1, arg2, arr, *rest|
          arg1.should == 5
          arg2.should have_at_least(3).characters
          arg2.should have_at_most(10).characters
          arr.map {|i| i * 2}.should == [2,4,6]
          rest.should == [:fee, &quot;fi&quot;, 4]
        }
        @mock.random_call 5, &quot;hello&quot;, [1,2,3], :fee, &quot;fi&quot;, 4
      end
    end
    
    describe Methods, &quot;handling non-constraint arguments&quot; do
      
      before(:each) do
        @mock = Mock.new(&quot;test mock&quot;)
      end
      
      it &quot;should match non special symbol (can be removed when deprecated symbols are removed)&quot; do
        @mock.should_receive(:random_call).with(:some_symbol)
        @mock.random_call(:some_symbol)
      end

      it &quot;should match string against regexp&quot; do
        @mock.should_receive(:random_call).with(/bcd/)
        @mock.random_call(&quot;abcde&quot;)
      end

      it &quot;should match regexp against regexp&quot; do
        @mock.should_receive(:random_call).with(/bcd/)
        @mock.random_call(/bcd/)
      end
      
      it &quot;should match against a hash submitted and received by value&quot; do
        @mock.should_receive(:random_call).with(:a =&gt; &quot;a&quot;, :b =&gt; &quot;b&quot;)
        @mock.random_call(:a =&gt; &quot;a&quot;, :b =&gt; &quot;b&quot;)
      end
      
      it &quot;should match against a hash submitted by reference and received by value&quot; do
        opts = {:a =&gt; &quot;a&quot;, :b =&gt; &quot;b&quot;}
        @mock.should_receive(:random_call).with(opts)
        @mock.random_call(:a =&gt; &quot;a&quot;, :b =&gt; &quot;b&quot;)
      end
      
      it &quot;should match against a hash submitted by value and received by reference&quot; do
        opts = {:a =&gt; &quot;a&quot;, :b =&gt; &quot;b&quot;}
        @mock.should_receive(:random_call).with(:a =&gt; &quot;a&quot;, :b =&gt; &quot;b&quot;)
        @mock.random_call(opts)
      end
    end
  end
end
</pre>
    </div>