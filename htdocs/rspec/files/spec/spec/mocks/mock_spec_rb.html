  <div id="fileHeader">
    <h1>mock_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/mocks/mock_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper'

module Spec
  module Mocks
    describe Mock do
      before(:each) do
        @mock = mock(&quot;test mock&quot;)
      end
      
      after(:each) do
        @mock.rspec_reset
      end
      
      it &quot;should report line number of expectation of unreceived message&quot; do
        expected_error_line = __LINE__; @mock.should_receive(:wont_happen).with(&quot;x&quot;, 3)
        begin
          @mock.rspec_verify
          violated
        rescue MockExpectationError =&gt; e
          # NOTE - this regexp ended w/ $, but jruby adds extra info at the end of the line
          e.backtrace[0].should match(/#{File.basename(__FILE__)}:#{expected_error_line}/)
        end
      end
      
      it &quot;should report line number of expectation of unreceived message after #should_receive after similar stub&quot; do
        @mock.stub!(:wont_happen)
        expected_error_line = __LINE__; @mock.should_receive(:wont_happen).with(&quot;x&quot;, 3)
        begin
          @mock.rspec_verify
          violated
        rescue MockExpectationError =&gt; e
          # NOTE - this regexp ended w/ $, but jruby adds extra info at the end of the line
          e.backtrace[0].should match(/#{File.basename(__FILE__)}:#{expected_error_line}/)
        end
      end
      
      it &quot;should pass when not receiving message specified as not to be received&quot; do
        @mock.should_not_receive(:not_expected)
        @mock.rspec_verify
      end
      
      it &quot;should pass when receiving message specified as not to be received with different args&quot; do
        @mock.should_not_receive(:message).with(&quot;unwanted text&quot;)
        @mock.should_receive(:message).with(&quot;other text&quot;)
        @mock.message &quot;other text&quot;
        @mock.rspec_verify
      end
      
      it &quot;should fail when receiving message specified as not to be received&quot; do
        @mock.should_not_receive(:not_expected)
        lambda {
          @mock.not_expected
          violated
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :not_expected with (no args) 0 times, but received it once&quot;)
      end
      
      it &quot;should fail when receiving message specified as not to be received with args&quot; do
        @mock.should_not_receive(:not_expected).with(&quot;unexpected text&quot;)
        lambda {
          @mock.not_expected(&quot;unexpected text&quot;)
          violated
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :not_expected with (\&quot;unexpected text\&quot;) 0 times, but received it once&quot;)
      end
      
      it &quot;should pass when receiving message specified as not to be received with wrong args&quot; do
        @mock.should_not_receive(:not_expected).with(&quot;unexpected text&quot;)
        @mock.not_expected &quot;really unexpected text&quot;
        @mock.rspec_verify
      end
      
      it &quot;should allow block to calculate return values&quot; do
        @mock.should_receive(:something).with(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).and_return { |a,b,c| c+b+a }
        @mock.something(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).should == &quot;cba&quot;
        @mock.rspec_verify
      end
      
      it &quot;should allow parameter as return value&quot; do
        @mock.should_receive(:something).with(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).and_return(&quot;booh&quot;)
        @mock.something(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).should == &quot;booh&quot;
        @mock.rspec_verify
      end
      
      it &quot;should return nil if no return value set&quot; do
        @mock.should_receive(:something).with(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
        @mock.something(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).should be_nil
        @mock.rspec_verify
      end
      
      it &quot;should raise exception if args don't match when method called&quot; do
        @mock.should_receive(:something).with(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;).and_return(&quot;booh&quot;)
        lambda {
          @mock.something(&quot;a&quot;,&quot;d&quot;,&quot;c&quot;)
          violated
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :something with (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;) but received it with (\&quot;a\&quot;, \&quot;d\&quot;, \&quot;c\&quot;)&quot;)
      end
           
      it &quot;should raise exception if args don't match when method called even when the method is stubbed&quot; do
        @mock.stub!(:something)
        @mock.should_receive(:something).with(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
        lambda {
          @mock.something(&quot;a&quot;,&quot;d&quot;,&quot;c&quot;)
          @mock.rspec_verify
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :something with (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;) but received it with (\&quot;a\&quot;, \&quot;d\&quot;, \&quot;c\&quot;)&quot;)
      end
           
      it &quot;should raise exception if args don't match when method called even when using null_object&quot; do
        @mock = mock(&quot;test mock&quot;, :null_object =&gt; true)
        @mock.should_receive(:something).with(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
        lambda {
          @mock.something(&quot;a&quot;,&quot;d&quot;,&quot;c&quot;)
          @mock.rspec_verify
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :something with (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;) but received it with (\&quot;a\&quot;, \&quot;d\&quot;, \&quot;c\&quot;)&quot;)
      end
           
      it &quot;should fail if unexpected method called&quot; do
        lambda {
          @mock.something(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
          violated
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' received unexpected message :something with (\&quot;a\&quot;, \&quot;b\&quot;, \&quot;c\&quot;)&quot;)
      end
        
      it &quot;should use block for expectation if provided&quot; do
        @mock.should_receive(:something) do | a, b |
          a.should == &quot;a&quot;
          b.should == &quot;b&quot;
          &quot;booh&quot;
        end
        @mock.something(&quot;a&quot;, &quot;b&quot;).should == &quot;booh&quot;
        @mock.rspec_verify
      end
        
      it &quot;should fail if expectation block fails&quot; do
        @mock.should_receive(:something) {| bool | bool.should be_true}
        lambda {
          @mock.something false
        }.should raise_error(MockExpectationError, /Mock 'test mock' received :something but passed block failed with: expected true, got false/)
      end
        
      it &quot;should fail right away when method defined as never is received&quot; do
        @mock.should_receive(:not_expected).never
        lambda {
          @mock.not_expected
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :not_expected with (no args) 0 times, but received it once&quot;)
      end
      
      it &quot;should eventually fail when method defined as never is received&quot; do
        @mock.should_receive(:not_expected).never
        lambda {
          @mock.not_expected
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :not_expected with (no args) 0 times, but received it once&quot;)
      end
    
      it &quot;should raise when told to&quot; do
        @mock.should_receive(:something).and_raise(RuntimeError)
        lambda do
          @mock.something
        end.should raise_error(RuntimeError)
      end
       
      it &quot;should raise passed an Exception instance&quot; do
        error = RuntimeError.new(&quot;error message&quot;)
        @mock.should_receive(:something).and_raise(error)
        lambda {
          @mock.something
        }.should raise_error(RuntimeError, &quot;error message&quot;)
      end
      
      it &quot;should raise RuntimeError with passed message&quot; do
        @mock.should_receive(:something).and_raise(&quot;error message&quot;)
        lambda {
          @mock.something
        }.should raise_error(RuntimeError, &quot;error message&quot;)
      end
       
      it &quot;should not raise when told to if args dont match&quot; do
        @mock.should_receive(:something).with(2).and_raise(RuntimeError)
        lambda {
          @mock.something 1
        }.should raise_error(MockExpectationError)
      end
       
      it &quot;should throw when told to&quot; do
        @mock.should_receive(:something).and_throw(:blech)
        lambda {
          @mock.something
        }.should throw_symbol(:blech)
      end
      
      it &quot;should raise when explicit return and block constrained&quot; do
        lambda {
          @mock.should_receive(:fruit) do |colour|
            :strawberry
          end.and_return :apple
        }.should raise_error(AmbiguousReturnError)
      end
      
      it &quot;should ignore args on any args&quot; do
        @mock.should_receive(:something).at_least(:once).with(any_args)
        @mock.something
        @mock.something 1
        @mock.something &quot;a&quot;, 2
        @mock.something [], {}, &quot;joe&quot;, 7
        @mock.rspec_verify
      end
      
      it &quot;should fail on no args if any args received&quot; do
        @mock.should_receive(:something).with(no_args())
        lambda {
          @mock.something 1
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :something with (no args) but received it with (1)&quot;)
      end
    
      it &quot;should fail when args are expected but none are received&quot; do
        @mock.should_receive(:something).with(1)
        lambda {
          @mock.something
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' expected :something with (1) but received it with (no args)&quot;)
      end
    
      it &quot;should return value from block by default&quot; do
        @mock.stub!(:method_that_yields).and_yield
        @mock.method_that_yields { :returned_obj }.should == :returned_obj
        @mock.rspec_verify
      end
    
      it &quot;should yield 0 args to blocks that take a variable number of arguments&quot; do
        @mock.should_receive(:yield_back).with(no_args()).once.and_yield
        a = nil
        @mock.yield_back {|*x| a = x}
        a.should == []
        @mock.rspec_verify
      end
      
      it &quot;should yield 0 args multiple times to blocks that take a variable number of arguments&quot; do
        @mock.should_receive(:yield_back).once.with(no_args()).once.and_yield.
                                                                    and_yield
        a = nil
        b = []
        @mock.yield_back {|*a| b &lt;&lt; a}
        b.should == [ [], [] ]
        @mock.rspec_verify
      end
      
      it &quot;should yield one arg to blocks that take a variable number of arguments&quot; do
        @mock.should_receive(:yield_back).with(no_args()).once.and_yield(99)
        a = nil
        @mock.yield_back {|*x| a = x}
        a.should == [99]
        @mock.rspec_verify
      end
      
      it &quot;should yield one arg 3 times consecutively to blocks that take a variable number of arguments&quot; do
        @mock.should_receive(:yield_back).once.with(no_args()).once.and_yield(99).
                                                                    and_yield(43).
                                                                    and_yield(&quot;something fruity&quot;)
        a = nil
        b = []
        @mock.yield_back {|*a| b &lt;&lt; a}
        b.should == [[99], [43], [&quot;something fruity&quot;]]
        @mock.rspec_verify
      end
      
      it &quot;should yield many args to blocks that take a variable number of arguments&quot; do
        @mock.should_receive(:yield_back).with(no_args()).once.and_yield(99, 27, &quot;go&quot;)
        a = nil
        @mock.yield_back {|*x| a = x}
        a.should == [99, 27, &quot;go&quot;]
        @mock.rspec_verify
      end
    
      it &quot;should yield many args 3 times consecutively to blocks that take a variable number of arguments&quot; do
        @mock.should_receive(:yield_back).once.with(no_args()).once.and_yield(99, :green, &quot;go&quot;).
                                                                    and_yield(&quot;wait&quot;, :amber).
                                                                    and_yield(&quot;stop&quot;, 12, :red)
        a = nil
        b = []
        @mock.yield_back {|*a| b &lt;&lt; a}
        b.should == [[99, :green, &quot;go&quot;], [&quot;wait&quot;, :amber], [&quot;stop&quot;, 12, :red]]
        @mock.rspec_verify
      end
      
      it &quot;should yield single value&quot; do
        @mock.should_receive(:yield_back).with(no_args()).once.and_yield(99)
        a = nil
        @mock.yield_back {|x| a = x}
        a.should == 99
        @mock.rspec_verify
      end
      
      it &quot;should yield single value 3 times consecutively&quot; do
        @mock.should_receive(:yield_back).once.with(no_args()).once.and_yield(99).
                                                                    and_yield(43).
                                                                    and_yield(&quot;something fruity&quot;)
        a = nil
        b = []
        @mock.yield_back {|a| b &lt;&lt; a}
        b.should == [99, 43, &quot;something fruity&quot;]
        @mock.rspec_verify
      end
      
      it &quot;should yield two values&quot; do
        @mock.should_receive(:yield_back).with(no_args()).once.and_yield('wha', 'zup')
        a, b = nil
        @mock.yield_back {|x,y| a=x; b=y}
        a.should == 'wha'
        b.should == 'zup'
        @mock.rspec_verify
      end
      
      it &quot;should yield two values 3 times consecutively&quot; do
        @mock.should_receive(:yield_back).once.with(no_args()).once.and_yield('wha', 'zup').
                                                                    and_yield('not', 'down').
                                                                    and_yield(14, 65)
        a, b = nil
        c = []
        @mock.yield_back {|a,b| c &lt;&lt; [a, b]}
        c.should == [['wha', 'zup'], ['not', 'down'], [14, 65]]
        @mock.rspec_verify
      end
      
      it &quot;should fail when calling yielding method with wrong arity&quot; do
        @mock.should_receive(:yield_back).with(no_args()).once.and_yield('wha', 'zup')
        lambda {
          @mock.yield_back {|a|}
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' yielded |\&quot;wha\&quot;, \&quot;zup\&quot;| to block with arity of 1&quot;)
      end
      
      it &quot;should fail when calling yielding method consecutively with wrong arity&quot; do
        @mock.should_receive(:yield_back).once.with(no_args()).once.and_yield('wha', 'zup').
                                                                    and_yield('down').
                                                                    and_yield(14, 65)
        lambda {
          a, b = nil
          c = []
          @mock.yield_back {|a,b| c &lt;&lt; [a, b]}
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' yielded |\&quot;down\&quot;| to block with arity of 2&quot;)
      end
      
      it &quot;should fail when calling yielding method without block&quot; do
        @mock.should_receive(:yield_back).with(no_args()).once.and_yield('wha', 'zup')
        lambda {
          @mock.yield_back
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' asked to yield |[\&quot;wha\&quot;, \&quot;zup\&quot;]| but no block was passed&quot;)
      end
      
      it &quot;should be able to mock send&quot; do
        @mock.should_receive(:send).with(any_args)
        @mock.send 'hi'
        @mock.rspec_verify
      end
      
      it &quot;should be able to raise from method calling yielding mock&quot; do
        @mock.should_receive(:yield_me).and_yield 44
        
        lambda {
          @mock.yield_me do |x|
            raise &quot;Bang&quot;
          end
        }.should raise_error(StandardError, &quot;Bang&quot;)
      
        @mock.rspec_verify
      end
      
      it &quot;should clear expectations after verify&quot; do
        @mock.should_receive(:foobar)
        @mock.foobar
        @mock.rspec_verify
        lambda {
          @mock.foobar
        }.should raise_error(MockExpectationError, &quot;Mock 'test mock' received unexpected message :foobar with (no args)&quot;)
      end
      
      it &quot;should restore objects to their original state on rspec_reset&quot; do
        mock = mock(&quot;this is a mock&quot;)
        mock.should_receive(:blah)
        mock.rspec_reset
        mock.rspec_verify #should throw if reset didn't work
      end
    
      it &quot;should work even after method_missing starts raising NameErrors instead of NoMethodErrors&quot; do
        # Object#method_missing throws either NameErrors or NoMethodErrors.
        #
        # On a fresh ruby program Object#method_missing: 
        #  * raises a NoMethodError when called directly
        #  * raises a NameError when called indirectly
        #
        # Once Object#method_missing has been called at least once (on any object)
        # it starts behaving differently: 
        #  * raises a NameError when called directly
        #  * raises a NameError when called indirectly
        #
        # There was a bug in Mock#method_missing that relied on the fact
        # that calling Object#method_missing directly raises a NoMethodError.
        # This example tests that the bug doesn't exist anymore.
        
        
        # Ensures that method_missing always raises NameErrors.
        a_method_that_doesnt_exist rescue
        
        
        @mock.should_receive(:foobar)
        @mock.foobar
        @mock.rspec_verify
                
        lambda { @mock.foobar }.should_not raise_error(NameError)
        lambda { @mock.foobar }.should raise_error(MockExpectationError)
      end
    
      it &quot;should temporarily replace a method stub on a mock&quot; do
        @mock.stub!(:msg).and_return(:stub_value)
        @mock.should_receive(:msg).with(:arg).and_return(:mock_value)
        @mock.msg(:arg).should equal(:mock_value)
        @mock.msg.should equal(:stub_value)
        @mock.msg.should equal(:stub_value)
        @mock.rspec_verify
      end

      it &quot;should not require a different signature to replace a method stub&quot; do
        @mock.stub!(:msg).and_return(:stub_value)
        @mock.should_receive(:msg).and_return(:mock_value)
        @mock.msg(:arg).should equal(:mock_value)
        @mock.msg.should equal(:stub_value)
        @mock.msg.should equal(:stub_value)
        @mock.rspec_verify
      end

      it &quot;should raise an error when a previously stubbed method has a negative expectation&quot; do
        @mock.stub!(:msg).and_return(:stub_value)
        @mock.should_not_receive(:msg).and_return(:mock_value)
        lambda {@mock.msg(:arg)}.should raise_error(MockExpectationError)
      end

      it &quot;should temporarily replace a method stub on a non-mock&quot; do
        non_mock = Object.new
        non_mock.stub!(:msg).and_return(:stub_value)
        non_mock.should_receive(:msg).with(:arg).and_return(:mock_value)
        non_mock.msg(:arg).should equal(:mock_value)
        non_mock.msg.should equal(:stub_value)
        non_mock.msg.should equal(:stub_value)
        non_mock.rspec_verify
      end

      it &quot;should return the stubbed value when no new value specified&quot; do
        @mock.stub!(:msg).and_return(:stub_value)
        @mock.should_receive(:msg)
        @mock.msg.should equal(:stub_value)
        @mock.rspec_verify
      end

      it &quot;should not mess with the stub's yielded values when also mocked&quot; do
        @mock.stub!(:yield_back).and_yield(:stub_value)
        @mock.should_receive(:yield_back).and_yield(:mock_value)
        @mock.yield_back{|v| v.should == :mock_value }
        @mock.yield_back{|v| v.should == :stub_value }
        @mock.rspec_verify
      end

      it &quot;should yield multiple values after a similar stub&quot; do
        File.stub!(:open).and_yield(:stub_value)
        File.should_receive(:open).and_yield(:first_call).and_yield(:second_call)
        yielded_args = []
        File.open {|v| yielded_args &lt;&lt; v }
        yielded_args.should == [:first_call, :second_call]
        File.open {|v| v.should == :stub_value }
        File.rspec_verify
      end

      it &quot;should assign stub return values&quot; do
        mock = Mock.new('name', :message =&gt; :response)
        mock.message.should == :response
      end
      
    end
    
    describe &quot;a mock message receiving a block&quot; do
      before(:each) do
        @mock = mock(&quot;mock&quot;)
        @calls = 0
      end
      
      def add_call
        @calls = @calls + 1
      end
      
      it &quot;should call the block after #should_receive&quot; do
        @mock.should_receive(:foo) { add_call }
    
        @mock.foo
    
        @calls.should == 1
      end
    
      it &quot;should call the block after #should_receive after a similar stub&quot; do
        @mock.stub!(:foo).and_return(:bar)
        @mock.should_receive(:foo) { add_call }
    
        @mock.foo
    
        @calls.should == 1
      end
    
      it &quot;should call the block after #once&quot; do
        @mock.should_receive(:foo).once { add_call }
    
        @mock.foo
    
        @calls.should == 1
      end
    
      it &quot;should call the block after #twice&quot; do
        @mock.should_receive(:foo).twice { add_call }
    
        @mock.foo
        @mock.foo
    
        @calls.should == 2
      end
    
      it &quot;should call the block after #times&quot; do
        @mock.should_receive(:foo).exactly(10).times { add_call }
        
        (1..10).each { @mock.foo }
    
        @calls.should == 10
      end
    
      it &quot;should call the block after #any_number_of_times&quot; do
        @mock.should_receive(:foo).any_number_of_times { add_call }
        
        (1..7).each { @mock.foo }
    
        @calls.should == 7
      end
    
      it &quot;should call the block after #ordered&quot; do
        @mock.should_receive(:foo).ordered { add_call }
        @mock.should_receive(:bar).ordered { add_call }
        
        @mock.foo
        @mock.bar
    
        @calls.should == 2
      end
    end
    
    describe 'string representation generated by #to_s' do
      it 'should not contain &lt; because that might lead to invalid HTML in some situations' do
        mock = mock(&quot;Dog&quot;)
        valid_html_str = &quot;#{mock}&quot;
        valid_html_str.should_not include('&lt;')
      end
    end
  end
end
</pre>
    </div>