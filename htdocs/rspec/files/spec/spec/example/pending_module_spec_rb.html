  <div id="fileHeader">
    <h1>pending_module_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/example/pending_module_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module Spec
  module Example
    describe Pending do
      
      it 'should raise an ExamplePendingError if no block is supplied' do
        lambda {
          pending &quot;TODO&quot;
        }.should raise_error(ExamplePendingError, /TODO/)
      end
      
      it 'should raise an ExamplePendingError if a supplied block fails as expected' do
        lambda {
          pending &quot;TODO&quot; do
            raise &quot;oops&quot;
          end
        }.should raise_error(ExamplePendingError, /TODO/)
      end
      
      it 'should raise an ExamplePendingError if a supplied block fails as expected with a mock' do
        lambda {
          pending &quot;TODO&quot; do
            m = mock('thing')
            m.should_receive(:foo)
            m.rspec_verify
          end
        }.should raise_error(ExamplePendingError, /TODO/)
      end
      
      it 'should raise a PendingExampleFixedError if a supplied block starts working' do
        lambda {
          pending &quot;TODO&quot; do
            # success!
          end
        }.should raise_error(PendingExampleFixedError, /TODO/)
      end
      
      it &quot;should have the correct file and line number for pending given with a block which fails&quot; do
        file = __FILE__
        line_number = __LINE__ + 2
        begin
          pending do
            raise
          end
        rescue =&gt; error
          error.pending_caller.should == &quot;#{file}:#{line_number}&quot;
        end
      end
      
      it &quot;should have the correct file and line number for pending given with no block&quot; do
        file = __FILE__
        line_number = __LINE__ + 2
        begin
          pending(&quot;TODO&quot;)
        rescue =&gt; error
          error.pending_caller.should == &quot;#{file}:#{line_number}&quot;
        end
      end
    end
    
    describe ExamplePendingError do
      it &quot;should have the caller (from two calls from initialization)&quot; do
        two_calls_ago = caller[0]
        ExamplePendingError.new(&quot;a message&quot;).pending_caller.should == two_calls_ago
      end
      
      it &quot;should keep the trace information from initialization&quot; do
        two_calls_ago = caller[0]
        obj = ExamplePendingError.new(&quot;a message&quot;)
        obj.pending_caller
        def another_caller(obj)
          obj.pending_caller
        end
        
        another_caller(obj).should == two_calls_ago
      end
      
      it &quot;should have the message provided&quot; do
        ExamplePendingError.new(&quot;a message&quot;).message.should == &quot;a message&quot;
      end

      it &quot;should use a 'ExamplePendingError' as it's default message&quot; do
        ExamplePendingError.new.message.should == &quot;Spec::Example::ExamplePendingError&quot;
      end
    end
    
    describe NotYetImplementedError do
      def rspec_root
        File.expand_path(__FILE__.gsub(&quot;/spec/spec/example/pending_module_spec.rb&quot;, &quot;/lib&quot;))
      end
      
      it &quot;should have the root rspec path&quot; do
        NotYetImplementedError::RSPEC_ROOT_LIB.should == rspec_root
      end
      
      it &quot;should always have the error 'Not Yet Implemented'&quot; do
        NotYetImplementedError.new([]).message.should == &quot;Not Yet Implemented&quot;
      end
      
      describe &quot;pending_caller&quot; do
        it &quot;should select an element out of the backtrace&quot; do
          error = NotYetImplementedError.new([&quot;foo/bar.rb:18&quot;])
          
          error.pending_caller.should == &quot;foo/bar.rb:18&quot;
        end
        
        it &quot;should actually report the element from the backtrace&quot; do
          error = NotYetImplementedError.new([&quot;bar.rb:18&quot;])
          
          error.pending_caller.should == &quot;bar.rb:18&quot;
        end
        
        it &quot;should not use an element with the rspec root path&quot; do
          error = NotYetImplementedError.new([&quot;#{rspec_root}:8&quot;])
          
          error.pending_caller.should be_nil
        end
        
        it &quot;should select the first line in the backtrace which isn't in the rspec root&quot; do
          error = NotYetImplementedError.new([
            &quot;#{rspec_root}/foo.rb:2&quot;,
            &quot;#{rspec_root}/foo/bar.rb:18&quot;,
            &quot;path1.rb:22&quot;,
            &quot;path2.rb:33&quot;
          ])
          
          error.pending_caller.should == &quot;path1.rb:22&quot;
        end
        
        it &quot;should cache the caller&quot; do
          backtrace = mock('backtrace')
          backtrace.should_receive(:detect).once
          
          error = NotYetImplementedError.new(backtrace)
          error.pending_caller.should == error.pending_caller
        end
      end
    end
  end
end
</pre>
    </div>