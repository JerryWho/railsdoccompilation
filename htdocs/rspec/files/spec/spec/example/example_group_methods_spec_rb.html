  <div id="fileHeader">
    <h1>example_group_methods_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/example/example_group_methods_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper'

module Spec
  module Example
    describe 'ExampleGroupMethods' do
      with_sandboxed_options do
        attr_reader :example_group, :result, :reporter
        before(:each) do
          # See http://rspec.lighthouseapp.com/projects/5645-rspec/tickets/525-arity-changed-on-partial-mocks#ticket-525-2
          method_with_three_args = lambda { |arg1, arg2, arg3| }
          options.formatters &lt;&lt; mock(&quot;formatter&quot;, :null_object =&gt; true, :example_pending =&gt; method_with_three_args)
          options.backtrace_tweaker = mock(&quot;backtrace_tweaker&quot;, :null_object =&gt; true)
          @reporter = FakeReporter.new(@options)
          options.reporter = reporter
          @example_group = Class.new(ExampleGroup) do
            describe(&quot;ExampleGroup&quot;)
            it &quot;does nothing&quot;
          end
        end
        
        after(:each) do
          ExampleGroup.reset
        end

        [&quot;describe&quot;,&quot;context&quot;].each do |method|
          describe &quot;##{method}&quot; do
            describe &quot;when creating an ExampleGroup&quot; do
              before(:each) do
                @parent_example_group = Class.new(ExampleGroup) do
                  example &quot;first example&quot; do; end
                end
                @child_example_group = @parent_example_group.__send__ method, &quot;Child&quot; do
                  example &quot;second example&quot; do; end
                end
              end

              it &quot;should create a subclass of the ExampleGroup when passed a block&quot; do
                @child_example_group.superclass.should == @parent_example_group
                options.example_groups.should include(@child_example_group)
              end

              it &quot;should not inherit examples&quot; do
                @child_example_group.should have(1).examples
              end
              
              it &quot;records the spec path&quot; do
                @child_example_group.spec_path.should =~ /#{__FILE__}:#{__LINE__ - 15}/
              end
            end

            describe &quot;when creating a SharedExampleGroup&quot; do
              before(:each) do
                @shared_example_group = @example_group.__send__ method, &quot;A Shared ExampleGroup&quot;, :shared =&gt; true do; end
              end

              after(:each) do
                SharedExampleGroup.instance_eval{@shared_example_groups}.delete @shared_example_group
              end

              it &quot;should create a SharedExampleGroup&quot; do
                @shared_example_group.should_not be_nil
                SharedExampleGroup.find(&quot;A Shared ExampleGroup&quot;).should == @shared_example_group
              end
            end

          end
        end
        
        [:specify, :it].each do |method|
          describe &quot;##{method.to_s}&quot; do
            it &quot;should should create an example&quot; do
              lambda {
                @example_group.__send__(method, &quot;&quot;)
              }.should change { @example_group.examples.length }.by(1)
            end
          end
        end
        
        [:xit, :xspecify].each do |method|
          describe &quot;##{method.to_s}&quot; do
            before(:each) do
              Kernel.stub!(:warn)
            end

            it &quot;should NOT create an example&quot; do
              lambda {
                @example_group.__send__(method,&quot;&quot;)
              }.should_not change(@example_group.examples, :length)
            end

            it &quot;should warn that the example is disabled&quot; do
              Kernel.should_receive(:warn).with(&quot;Example disabled: foo&quot;)
              @example_group.__send__(method,&quot;foo&quot;)
            end
          end
        end
        

        describe &quot;#examples&quot; do
          it &quot;should have Examples&quot; do
            example_group = Class.new(ExampleGroup) do
              it &quot;should exist&quot; do; end
            end
            example_group.examples.length.should == 1
            example_group.examples.first.description.should == &quot;should exist&quot;
          end

          it &quot;should not include methods that begin with test (only when TU interop is loaded)&quot; do
            example_group = Class.new(ExampleGroup) do
              def test_any_args(*args)
                true.should be_true
              end
              def test_something
                1.should == 1
              end
              def test
                raise &quot;This is not a real test&quot;
              end
              def testify
                raise &quot;This is not a real test&quot;
              end
              def should_something
                # forces the run
              end
            end
            example_group.examples.length.should == 1
            example_group.run(options).should be_true
          end

          it &quot;should include methods that begin with should and has an arity of 0 in suite&quot; do
            example_group = Class.new(ExampleGroup) do
              def shouldCamelCase
                true.should be_true
              end
              def should_any_args(*args)
                true.should be_true
              end
              def should_something
                1.should == 1
              end
              def should_not_something
                1.should_not == 2
              end
              def should
                raise &quot;This is not a real example&quot;
              end
              def should_not
                raise &quot;This is not a real example&quot;
              end
            end
            example_group.should have(4).examples
            descriptions = example_group.examples.collect {|example| example.description.to_s}
            descriptions.should include(
              &quot;shouldCamelCase&quot;,
              &quot;should_any_args&quot;,
              &quot;should_something&quot;,
              &quot;should_not_something&quot;)
            descriptions.should_not include(
              &quot;should&quot;,
              &quot;should_not&quot;
            )
          end

          it &quot;should not include methods that begin with test_ and has an arity &gt; 0 in suite&quot; do
            example_group = Class.new(ExampleGroup) do
              def test_invalid(foo)
                1.should == 1
              end
              def testInvalidCamelCase(foo)
                1.should == 1
              end
            end
            example_group.should have(:no).examples
          end

          it &quot;should not include methods that begin with should_ and has an arity &gt; 0 in suite&quot; do
            example_group = Class.new(ExampleGroup) do
              def should_invalid(foo)
                1.should == 2
              end
              def shouldInvalidCamelCase(foo)
                1.should == 3
              end
              def should_not_invalid(foo)
                1.should == 4
              end
              def should_valid
                1.should == 1
              end
            end
            example_group.should have(1).examples
            example_group.run(options).should be_true
          end

          it &quot;should run should_methods&quot; do
            example_group = Class.new(ExampleGroup) do
              def should_valid
                1.should == 2
              end
            end
            example_group.should have(1).examples
            example_group.run(options).should be_false
          end
        end

        describe &quot;#set_description&quot; do
          attr_reader :example_group
          before do
            class &lt;&lt; example_group
              public :set_description
            end
          end

          describe &quot;given a String&quot; do
            before(:each) do
              example_group.set_description(&quot;abc&quot;)
            end

            specify &quot;.description should return the String passed into .set_description&quot; do
              example_group.description.should == &quot;abc&quot;
            end

            specify &quot;.described_type should provide nil as its type&quot; do
              example_group.described_type.should be_nil
            end
          end

          describe &quot;given a Class&quot; do
            before(:each) do
              example_group.set_description(ExampleGroup)
            end

            specify &quot;.description should return a String representation of that type (fully qualified) as its name&quot; do
              example_group.description.should == &quot;Spec::Example::ExampleGroup&quot;
            end

            specify &quot;.described_type should return the passed in type&quot; do
              example_group.described_type.should == Spec::Example::ExampleGroup
            end
          end

          describe &quot;given a String and a Class&quot; do
            before(:each) do
              example_group.set_description(&quot;behaving&quot;, ExampleGroup)
            end

            specify &quot;.description should return String then space then Type&quot; do
              example_group.description.should == &quot;behaving Spec::Example::ExampleGroup&quot;
            end

            specify &quot;.described_type should return the passed in type&quot; do
              example_group.described_type.should == Spec::Example::ExampleGroup
            end
          end

          describe &quot;given a Class and a String (starting with an alpha char)&quot; do
            before(:each) do
              example_group.set_description(ExampleGroup, &quot;behaving&quot;)
            end

            specify &quot;.description should return the Type then space then String&quot; do
              example_group.description.should == &quot;Spec::Example::ExampleGroup behaving&quot;
            end
          end

          describe &quot;given a Class and a String (starting with a '.')&quot; do
            before(:each) do
              example_group.set_description(ExampleGroup, &quot;.behaving&quot;)
            end

            specify &quot;.description should return the Type then String&quot; do
              example_group.description.should == &quot;Spec::Example::ExampleGroup.behaving&quot;
            end
          end

          describe &quot;#set_description(Class, String starting with #)&quot; do
            before(:each) do
              example_group.set_description(ExampleGroup, &quot;#behaving&quot;)
            end

            specify &quot;should return the Class then String&quot; do
              example_group.description.should == &quot;Spec::Example::ExampleGroup#behaving&quot;
            end
          end

          describe &quot;#set_description(Class, String containing .)&quot; do
            before(:each) do
              example_group.set_description(ExampleGroup, &quot;calling a.b&quot;)
            end

            specify &quot;.description should return the Type then space then String&quot; do
              example_group.description.should == &quot;Spec::Example::ExampleGroup calling a.b&quot;
            end
          end

          describe &quot;#set_description(Class, String containing #)&quot; do
            before(:each) do
              example_group.set_description(ExampleGroup, &quot;is #1&quot;)
            end

            specify &quot;.description should return the Type then space then String&quot; do
              example_group.description.should == &quot;Spec::Example::ExampleGroup is #1&quot;
            end
          end

          describe &quot;#set_description(String, Type, String)&quot; do
            before(:each) do
              example_group.set_description(&quot;A&quot;, Hash, &quot;with one entry&quot;)
            end

            specify &quot;.description should return the first String then space then Type then second String&quot; do
              example_group.description.should == &quot;A Hash with one entry&quot;
            end
          end

          describe &quot;#set_description(Hash representing options)&quot; do
            before(:each) do
              example_group.set_description(:a =&gt; &quot;b&quot;, :spec_path =&gt; &quot;blah&quot;)
            end

            it &quot;.spec_path should expand the passed in :spec_path option passed into the constructor&quot; do
              example_group.spec_path.should == File.expand_path(&quot;blah&quot;)
            end

            it &quot;.description_options should return all the options passed in&quot; do
              example_group.description_options.should == {:a =&gt; &quot;b&quot;, :spec_path =&gt; &quot;blah&quot;}
            end

          end
        end

        describe &quot;#description&quot; do
          it &quot;should return the same description instance for each call&quot; do
            example_group.description.should eql(example_group.description)
          end

          it &quot;should not add a space when description_text begins with #&quot; do
            child_example_group = Class.new(example_group) do
              describe(&quot;#foobar&quot;, &quot;Does something&quot;)
            end
            child_example_group.description.should == &quot;ExampleGroup#foobar Does something&quot;
          end

          it &quot;should not add a space when description_text begins with .&quot; do
            child_example_group = Class.new(example_group) do
              describe(&quot;.foobar&quot;, &quot;Does something&quot;)
            end
            child_example_group.description.should == &quot;ExampleGroup.foobar Does something&quot;
          end
        
          it &quot;should return the class name if nil&quot; do
            example_group.set_description(nil)
            example_group.description.should =~ /Class:/
          end
        
          it &quot;should return the class name if nil&quot; do
            example_group.set_description(&quot;&quot;)
            example_group.description.should =~ /Class:/
          end
        end

        describe &quot;#description_parts&quot; do
          it &quot;should return an Array of the current class description args&quot; do
            example_group.description_parts.should == [example_group.description]
          end

          it &quot;should return an Array of the description args from each class in the hierarchy&quot; do
            parent_example_group = Class.new(ExampleGroup) do
              describe(&quot;Parent&quot;)
            end
            
            child_example_group = Class.new(parent_example_group)
            child_example_group.describe(&quot;Child&quot;, ExampleGroup)
            child_example_group.description.should_not be_empty

            grand_child_example_group = Class.new(child_example_group)
            grand_child_example_group.describe(&quot;GrandChild&quot;, ExampleGroup)
            grand_child_example_group.description.should_not be_empty

            grand_child_example_group.description_parts.should == [
              &quot;Parent&quot;,
              &quot;Child&quot;,
              Spec::Example::ExampleGroup,
              &quot;GrandChild&quot;,
              Spec::Example::ExampleGroup
            ]
          end
        end

        describe &quot;#described_type&quot; do
          it &quot;should return passed in type&quot; do
            child_example_group = Class.new(example_group) do
              describe Object
            end
            child_example_group.described_type.should == Object
          end

          it &quot;should return #described_type of superclass when no passed in type&quot; do
            parent_example_group = Class.new(ExampleGroup) do
              describe Object, &quot;#foobar&quot;
            end
            child_example_group = Class.new(parent_example_group) do
              describe &quot;not a type&quot;
            end
            child_example_group.described_type.should == Object
          end
        end

        describe &quot;#remove_after&quot; do
          it &quot;should unregister a given after(:each) block&quot; do
            after_all_ran = false
            proc = Proc.new { after_all_ran = true }

            example_group = Class.new(ExampleGroup) do
              specify(&quot;example&quot;) {}
              after(:each, &amp;proc)
            end

            example_group.run(options)
            after_all_ran.should be_true

            after_all_ran = false
            example_group.remove_after(:each, &amp;proc)
            example_group.run(options)
            after_all_ran.should be_false
          end
        end

        describe &quot;#include&quot; do
          it &quot;should have accessible class methods from included module&quot; do
            mod_method_called = false
            mod = Module.new do
              class_methods = Module.new do
                define_method :mod_method do
                  mod_method_called = true
                end
              end

              self.class.class_eval do
                define_method(:included) do |receiver|
                  receiver.extend class_methods
                end
              end
            end

            @example_group.__send__ :include, mod

            @example_group.mod_method
            mod_method_called.should be_true
          end
        end

        describe &quot;#number_of_examples&quot; do
          it &quot;should count number of examples&quot; do
            proc do
              @example_group.it(&quot;one&quot;) {}
              @example_group.it(&quot;two&quot;) {}
              @example_group.it(&quot;three&quot;) {}
              @example_group.it(&quot;four&quot;) {}
            end.should change {@example_group.number_of_examples}.by(4)
          end
        end

        describe &quot;#class_eval&quot; do
          it &quot;should allow constants to be defined&quot; do
            example_group = Class.new(ExampleGroup) do
              FOO = 1
              it &quot;should reference FOO&quot; do
                FOO.should == 1
              end
            end
            success = example_group.run(options)
            success.should be_true
            Object.const_defined?(:FOO).should == false
          end
        end

        describe '#register' do
          after(:each) do
            Spec::Runner.options.remove_example_group example_group
          end
          it &quot;should add ExampleGroup to set of ExampleGroups to be run&quot; do
            Spec::Runner.options.add_example_group example_group
            options.example_groups.should include(example_group)
          end
        end

        describe '#unregister' do
          before(:each) do
            Spec::Runner.options.add_example_group example_group
          end
          it &quot;should remove ExampleGroup from set of ExampleGroups to be run&quot; do
            Spec::Runner.options.remove_example_group example_group
            options.example_groups.should_not include(example_group)
          end
        end
      
        describe &quot;#run&quot; do
          describe &quot;given an example group with at least one example&quot; do
            it &quot;should call add_example_group&quot; do
              example_group = Class.new(ExampleGroup) do
                example(&quot;anything&quot;) {}
              end
              reporter.should_receive(:add_example_group)
              example_group.run(options)
            end
          end

          describe &quot;given an example group with no examples&quot; do
            it &quot;should NOT call add_example_group&quot; do
              example_group = Class.new(ExampleGroup) do end
              reporter.should_not_receive(:add_example_group)
              example_group.run(options)
            end
          end
        end

        describe &quot;#matcher_class=&quot; do 
          it &quot;should call new and matches? on the class used for matching examples&quot; do 
            example_group = Class.new(ExampleGroup) do
              it &quot;should do something&quot; do end
              def self.specified_examples
                [&quot;something&quot;]
              end
              def self.to_s
                &quot;TestMatcher&quot;
              end
            end

            matcher = mock(&quot;matcher&quot;)
            matcher.should_receive(:matches?).with([&quot;something&quot;]).any_number_of_times
          
            matcher_class = Class.new
            matcher_class.should_receive(:new).with(&quot;TestMatcher&quot;, &quot;should do something&quot;).and_return(matcher)

            begin 
              ExampleGroupMethods.matcher_class = matcher_class

              example_group.run(options)
            ensure 
              ExampleGroupMethods.matcher_class = ExampleMatcher
            end
          end
        end

        describe &quot;#options&quot; do
          it &quot;should expose the options hash&quot; do
            group = describe(&quot;group&quot;, :this =&gt; 'hash') {}
            group.options[:this].should == 'hash'
          end
        end

        describe &quot;#backtrace&quot; do        
          it &quot;returns the backtrace from where the example group was defined&quot; do
            example_group = Class.new(ExampleGroup).describe(&quot;foo&quot;) do
              example &quot;bar&quot; do; end
            end
            example_group.backtrace.join(&quot;\n&quot;).should include(&quot;#{__FILE__}:#{__LINE__-3}&quot;)
          end
        end

        describe &quot;#example_group_backtrace (deprecated)&quot; do        
          before(:each) do
            Kernel.stub!(:warn)
          end
          it &quot;sends a deprecation warning&quot; do
            example_group = Class.new(ExampleGroup) {}
            Kernel.should_receive(:warn).with(/#example_group_backtrace.*deprecated.*#backtrace instead/m)
            example_group.example_group_backtrace
          end

          it &quot;returns the backtrace from where the example group was defined&quot; do
            example_group = Class.new(ExampleGroup).describe(&quot;foo&quot;) do
              example &quot;bar&quot; do; end
            end
            example_group.example_group_backtrace.join(&quot;\n&quot;).should include(&quot;#{__FILE__}:#{__LINE__-3}&quot;)
          end
        end

      end
    end
  end
end</pre>
    </div>