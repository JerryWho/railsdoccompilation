  <div id="fileHeader">
    <h1>example_group_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/example/example_group_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper'

module Spec
  module Example
    class ExampleModuleScopingSpec &lt; ExampleGroup
      describe ExampleGroup, &quot;via a class definition&quot;

      module Foo
        module Bar
          def self.loaded?
            true
          end
        end
      end
      include Foo

      it &quot;should understand module scoping&quot; do
        Bar.should be_loaded
      end

      @@foo = 1

      it &quot;should allow class variables to be defined&quot; do
        @@foo.should == 1
      end
    end

    class ExampleClassVariablePollutionSpec &lt; ExampleGroup
      describe ExampleGroup, &quot;via a class definition without a class variable&quot;

      it &quot;should not retain class variables from other Example classes&quot; do
        proc do
          @@foo
        end.should raise_error
      end
    end

    describe ExampleGroup, &quot;#pending&quot; do
      it &quot;should raise a Pending error when its block fails&quot; do
        block_ran = false
        lambda {
          pending(&quot;something&quot;) do
            block_ran = true
            raise &quot;something wrong with my example&quot;
          end
        }.should raise_error(Spec::Example::ExamplePendingError, &quot;something&quot;)
        block_ran.should == true
      end

      it &quot;should raise Spec::Example::PendingExampleFixedError when its block does not fail&quot; do
        block_ran = false
        lambda {
          pending(&quot;something&quot;) do
            block_ran = true
          end
        }.should raise_error(Spec::Example::PendingExampleFixedError, &quot;Expected pending 'something' to fail. No Error was raised.&quot;)
        block_ran.should == true
      end
    end

    describe ExampleGroup, &quot;#run with failure in example&quot;, :shared =&gt; true do
      it &quot;should add an example failure to the TestResult&quot; do
        example_group.run(options).should be_false
      end
    end

    describe ExampleGroup, &quot;#run&quot; do
      with_sandboxed_options do
        attr_reader :example_group, :formatter, :reporter
        before :each do
          method_with_three_args = lambda { |arg1, arg2, arg3| }
          @formatter = mock(&quot;formatter&quot;, :null_object =&gt; true, :example_pending =&gt; method_with_three_args)
          options.formatters &lt;&lt; formatter
          options.backtrace_tweaker = mock(&quot;backtrace_tweaker&quot;, :null_object =&gt; true)
          @reporter = FakeReporter.new(options)
          options.reporter = reporter
          @example_group = Class.new(ExampleGroup) do
            describe(&quot;example&quot;)
            it &quot;does nothing&quot; do
            end
          end
          class &lt;&lt; example_group
            public :include
          end
        end

        after :each do
          ExampleGroup.reset
        end

        it &quot;should not run when there are no examples&quot; do
          example_group = Class.new(ExampleGroup) do
            describe(&quot;Foobar&quot;)
          end
          example_group.examples.should be_empty

          reporter = mock(&quot;Reporter&quot;)
          reporter.should_not_receive(:add_example_group)
          example_group.run(options)
        end
      
        describe &quot;when before_each fails&quot; do
          before(:each) do
            $example_ran = $after_each_ran = false
            @example_group = describe(&quot;Foobar&quot;) do
              before(:each) {raise}
              it &quot;should not be run&quot; do
                $example_ran = true
              end
              after(:each) do
                $after_each_ran = true
              end
            end
          end

          it &quot;should not run example block&quot; do
            example_group.run(options)
            $example_ran.should be_false
          end
        
          it &quot;should run after_each&quot; do
            example_group.run(options)
            $after_each_ran.should be_true
          end

          it &quot;should report failure location when in before_each&quot; do
            reporter.should_receive(:example_finished) do |example_group, error|
              error.message.should eql(&quot;in before_each&quot;)
            end
            example_group.run(options)
          end
        end

        describe ExampleGroup, &quot;#run on dry run&quot; do
          before do
            @options.dry_run = true
          end

          it &quot;should not run before(:all) or after(:all)&quot; do
            before_all_ran = false
            after_all_ran = false
            ExampleGroup.before(:all) { before_all_ran = true }
            ExampleGroup.after(:all) { after_all_ran = true }
            example_group.it(&quot;should&quot;) {}
            example_group.run(options)
            before_all_ran.should be_false
            after_all_ran.should be_false
          end

          it &quot;should not run example&quot; do
            example_ran = false
            example_group.it(&quot;should&quot;) {example_ran = true}
            example_group.run(options)
            example_ran.should be_false
          end
        end

        describe ExampleGroup, &quot;#run with specified examples&quot; do
          attr_reader :examples_that_were_run
          before do
            @examples_that_were_run = []
          end

          describe &quot;when specified_examples matches entire ExampleGroup&quot; do
            before do
              examples_that_were_run = @examples_that_were_run
              @example_group = Class.new(ExampleGroup) do
                describe(&quot;the ExampleGroup&quot;)
                it(&quot;should be run&quot;) do
                  examples_that_were_run &lt;&lt; 'should be run'
                end

                it(&quot;should also be run&quot;) do
                  examples_that_were_run &lt;&lt; 'should also be run'
                end
              end
              options.parse_example &quot;the ExampleGroup&quot;
            end

            it &quot;should not run the Examples in the ExampleGroup&quot; do
              example_group.run(options)
              examples_that_were_run.should == ['should be run', 'should also be run']
            end
          end

          describe ExampleGroup, &quot;#run when specified_examples matches only Example description&quot; do
            before do
              examples_that_were_run = @examples_that_were_run
              @example_group = Class.new(ExampleGroup) do
                describe(&quot;example&quot;)
                it(&quot;should be run&quot;) do
                  examples_that_were_run &lt;&lt; 'should be run'
                end
              end
              options.parse_example &quot;should be run&quot;
            end

            it &quot;should not run the example&quot; do
              example_group.run(options)
              examples_that_were_run.should == ['should be run']
            end
          end

          describe ExampleGroup, &quot;#run when specified_examples does not match an Example description&quot; do
            before do
              examples_that_were_run = @examples_that_were_run
              @example_group = Class.new(ExampleGroup) do
                describe(&quot;example&quot;)
                it(&quot;should be something else&quot;) do
                  examples_that_were_run &lt;&lt; 'should be something else'
                end
              end
              options.parse_example &quot;does not match anything&quot;
            end

            it &quot;should not run the example&quot; do
              example_group.run(options)
              examples_that_were_run.should == []
            end
          end

          describe ExampleGroup, &quot;#run when specified_examples matches an Example description&quot; do
            before do
              examples_that_were_run = @examples_that_were_run
              @example_group = Class.new(ExampleGroup) do
                describe(&quot;example&quot;)
                it(&quot;should be run&quot;) do
                  examples_that_were_run &lt;&lt; 'should be run'
                end
                it(&quot;should not be run&quot;) do
                  examples_that_were_run &lt;&lt; 'should not be run'
                end
              end
              options.parse_example &quot;should be run&quot;
            end

            it &quot;should run only the example, when there is only one&quot; do
              example_group.run(options)
              examples_that_were_run.should == [&quot;should be run&quot;]
            end

            it &quot;should run only the one example&quot; do
              example_group.run(options)
              examples_that_were_run.should == [&quot;should be run&quot;]          end
          end
        end

        describe ExampleGroup, &quot;#run with success&quot; do
          before do
            @special_example_group = Class.new(ExampleGroup)
            ExampleGroupFactory.register(:special, @special_example_group)
            @not_special_example_group = Class.new(ExampleGroup)
            ExampleGroupFactory.register(:not_special, @not_special_example_group)
          end

          after do
            ExampleGroupFactory.reset
          end

          it &quot;should send reporter add_example_group&quot; do
            example_group.run(options)
            reporter.example_groups.should == [example_group]
          end

          it &quot;should run example on run&quot; do
            example_ran = false
            example_group.it(&quot;should&quot;) {example_ran = true}
            example_group.run(options)
            example_ran.should be_true
          end

          it &quot;should run before(:all) block only once&quot; do
            before_all_run_count_run_count = 0
            example_group.before(:all) {before_all_run_count_run_count += 1}
            example_group.it(&quot;test&quot;) {true}
            example_group.it(&quot;test2&quot;) {true}
            example_group.run(options)
            before_all_run_count_run_count.should == 1
          end

          it &quot;should run after(:all) block only once&quot; do
            after_all_run_count = 0
            example_group.after(:all) {after_all_run_count += 1}
            example_group.it(&quot;test&quot;) {true}
            example_group.it(&quot;test2&quot;) {true}
            example_group.run(options)
            after_all_run_count.should == 1
            @reporter.rspec_verify
          end

          it &quot;after(:all) should have access to all instance variables defined in before(:all)&quot; do
            context_instance_value_in = &quot;Hello there&quot;
            context_instance_value_out = &quot;&quot;
            example_group.before(:all) { @instance_var = context_instance_value_in }
            example_group.after(:all) { context_instance_value_out = @instance_var }
            example_group.it(&quot;test&quot;) {true}
            example_group.run(options)
            context_instance_value_in.should == context_instance_value_out
          end

          it &quot;should copy instance variables from before(:all)'s execution context into spec's execution context&quot; do
            context_instance_value_in = &quot;Hello there&quot;
            context_instance_value_out = &quot;&quot;
            example_group.before(:all) { @instance_var = context_instance_value_in }
            example_group.it(&quot;test&quot;) {context_instance_value_out = @instance_var}
            example_group.run(options)
            context_instance_value_in.should == context_instance_value_out
          end

          it &quot;should not add global before callbacks for untargetted example_group&quot; do
            fiddle = []

            ExampleGroup.before(:all) { fiddle &lt;&lt; &quot;Example.before(:all)&quot; }
            ExampleGroup.prepend_before(:all) { fiddle &lt;&lt; &quot;Example.prepend_before(:all)&quot; }
            @special_example_group.before(:each) { fiddle &lt;&lt; &quot;Example.before(:each, :type =&gt; :special)&quot; }
            @special_example_group.prepend_before(:each) { fiddle &lt;&lt; &quot;Example.prepend_before(:each, :type =&gt; :special)&quot; }
            @special_example_group.before(:all) { fiddle &lt;&lt; &quot;Example.before(:all, :type =&gt; :special)&quot; }
            @special_example_group.prepend_before(:all) { fiddle &lt;&lt; &quot;Example.prepend_before(:all, :type =&gt; :special)&quot; }

            example_group = Class.new(ExampleGroup) do
              describe(&quot;I'm not special&quot;, :type =&gt; :not_special)
              it &quot;does nothing&quot;
            end
            example_group.run(options)
            fiddle.should == [
              'Example.prepend_before(:all)',
              'Example.before(:all)',
            ]
          end

          it &quot;should add global before callbacks for targetted example_groups&quot; do
            fiddle = []

            ExampleGroup.before(:all) { fiddle &lt;&lt; &quot;Example.before(:all)&quot; }
            ExampleGroup.prepend_before(:all) { fiddle &lt;&lt; &quot;Example.prepend_before(:all)&quot; }
            @special_example_group.before(:each) { fiddle &lt;&lt; &quot;special.before(:each, :type =&gt; :special)&quot; }
            @special_example_group.prepend_before(:each) { fiddle &lt;&lt; &quot;special.prepend_before(:each, :type =&gt; :special)&quot; }
            @special_example_group.before(:all) { fiddle &lt;&lt; &quot;special.before(:all, :type =&gt; :special)&quot; }
            @special_example_group.prepend_before(:all) { fiddle &lt;&lt; &quot;special.prepend_before(:all, :type =&gt; :special)&quot; }
            @special_example_group.append_before(:each) { fiddle &lt;&lt; &quot;special.append_before(:each, :type =&gt; :special)&quot; }

            example_group = Class.new(@special_example_group).describe(&quot;I'm a special example_group&quot;) {}
            example_group.it(&quot;test&quot;) {true}
            example_group.run(options)
            fiddle.should == [
              'Example.prepend_before(:all)',
              'Example.before(:all)',
              'special.prepend_before(:all, :type =&gt; :special)',
              'special.before(:all, :type =&gt; :special)',
              'special.prepend_before(:each, :type =&gt; :special)',
              'special.before(:each, :type =&gt; :special)',
              'special.append_before(:each, :type =&gt; :special)',
            ]
          end

          it &quot;should order before callbacks from global to local&quot; do
            fiddle = []
            ExampleGroup.prepend_before(:all) { fiddle &lt;&lt; &quot;Example.prepend_before(:all)&quot; }
            ExampleGroup.before(:all) { fiddle &lt;&lt; &quot;Example.before(:all)&quot; }
            example_group.prepend_before(:all) { fiddle &lt;&lt; &quot;prepend_before(:all)&quot; }
            example_group.before(:all) { fiddle &lt;&lt; &quot;before(:all)&quot; }
            example_group.prepend_before(:each) { fiddle &lt;&lt; &quot;prepend_before(:each)&quot; }
            example_group.before(:each) { fiddle &lt;&lt; &quot;before(:each)&quot; }
            example_group.run(options)
            fiddle.should == [
              'Example.prepend_before(:all)',
              'Example.before(:all)',
              'prepend_before(:all)',
              'before(:all)',
              'prepend_before(:each)',
              'before(:each)'
            ]
          end

          it &quot;should order after callbacks from local to global&quot; do
            fiddle = []
            example_group.after(:each) { fiddle &lt;&lt; &quot;after(:each)&quot; }
            example_group.append_after(:each) { fiddle &lt;&lt; &quot;append_after(:each)&quot; }
            example_group.after(:all) { fiddle &lt;&lt; &quot;after(:all)&quot; }
            example_group.append_after(:all) { fiddle &lt;&lt; &quot;append_after(:all)&quot; }
            ExampleGroup.after(:all) { fiddle &lt;&lt; &quot;Example.after(:all)&quot; }
            ExampleGroup.append_after(:all) { fiddle &lt;&lt; &quot;Example.append_after(:all)&quot; }
            example_group.run(options)
            fiddle.should == [
              'after(:each)',
              'append_after(:each)',
              'after(:all)',
              'append_after(:all)',
              'Example.after(:all)',
              'Example.append_after(:all)'
            ]
          end

          it &quot;should have accessible instance methods from included module&quot; do
            mod1_method_called = false
            mod1 = Module.new do
              define_method :mod1_method do
                mod1_method_called = true
              end
            end

            mod2_method_called = false
            mod2 = Module.new do
              define_method :mod2_method do
                mod2_method_called = true
              end
            end

            example_group.include mod1, mod2

            example_group.it(&quot;test&quot;) do
              mod1_method
              mod2_method
            end
            example_group.run(options)
            mod1_method_called.should be_true
            mod2_method_called.should be_true
          end

          it &quot;should include targetted modules included using configuration&quot; do
            mod1 = Module.new
            mod2 = Module.new
            mod3 = Module.new
            Spec::Runner.configuration.include(mod1, mod2)
            Spec::Runner.configuration.include(mod3, :type =&gt; :not_special)

            example_group = Class.new(@special_example_group).describe(&quot;I'm special&quot;, :type =&gt; :special) do
              it &quot;does nothing&quot;
            end
            example_group.run(options)

            example_group.included_modules.should include(mod1)
            example_group.included_modules.should include(mod2)
            example_group.included_modules.should_not include(mod3)
          end

          it &quot;should include any predicate_matchers included using configuration&quot; do
            $included_predicate_matcher_found = false
            Spec::Runner.configuration.predicate_matchers[:do_something] = :does_something?
            example_group = Class.new(ExampleGroup) do
              describe('example')
              it &quot;should respond to do_something&quot; do
                $included_predicate_matcher_found = respond_to?(:do_something)
              end
            end
            example_group.run(options)
            $included_predicate_matcher_found.should be(true)
          end

          it &quot;should use a mock framework set up in config&quot; do
            mod = Module.new do
              def self.included(mod)
                $included_module = mod
              end

              def teardown_mocks_for_rspec
                $torn_down = true
              end
            end

            begin
              $included_module = nil
              $torn_down = true
              Spec::Runner.configuration.mock_with mod

              example_group = Class.new(ExampleGroup) do
                describe('example')
                it &quot;does nothing&quot;
              end
              example_group.run(options)

              $included_module.should_not be_nil
              $torn_down.should == true
            ensure
              Spec::Runner.configuration.mock_with :rspec
            end
          end
        end

        describe ExampleGroup, &quot;#run with pending example that has a failing assertion&quot; do
          before do
            example_group.it(&quot;should be pending&quot;) do
              pending(&quot;Example fails&quot;) {false.should be_true}
            end
          end

          it &quot;should send example_pending to formatter&quot; do
            @formatter.should_receive(:example_pending).with(&quot;example&quot;, &quot;should be pending&quot;, &quot;Example fails&quot;)
            example_group.run(options)
          end
        end

        describe ExampleGroup, &quot;#run with pending example that does not have a failing assertion&quot; do
          it_should_behave_like &quot;Spec::Example::ExampleGroup#run with failure in example&quot;

          before do
            example_group.it(&quot;should be pending&quot;) do
              pending(&quot;Example passes&quot;) {true.should be_true}
            end
          end

          it &quot;should send example_pending to formatter&quot; do
            @formatter.should_receive(:example_pending).with(&quot;example&quot;, &quot;should be pending&quot;, &quot;Example passes&quot;)
            example_group.run(options)
          end
        end

        describe ExampleGroup, &quot;#run when before(:all) fails&quot; do
          it_should_behave_like &quot;Spec::Example::ExampleGroup#run with failure in example&quot;

          before do
            ExampleGroup.before(:all) { raise NonStandardError, &quot;before(:all) failure&quot; }
          end

          it &quot;should not run any example&quot; do
            spec_ran = false
            example_group.it(&quot;test&quot;) {spec_ran = true}
            example_group.run(options)
            spec_ran.should be_false
          end

          it &quot;should run ExampleGroup after(:all)&quot; do
            after_all_ran = false
            ExampleGroup.after(:all) { after_all_ran = true }
            example_group.run(options)
            after_all_ran.should be_true
          end

          it &quot;should run example_group after(:all)&quot; do
            after_all_ran = false
            example_group.after(:all) { after_all_ran = true }
            example_group.run(options)
            after_all_ran.should be_true
          end

          it &quot;should supply before(:all) as description&quot; do
            @reporter.should_receive(:failure) do |example, error|
              example.description.should eql(&quot;before(:all)&quot;)
              error.message.should eql(&quot;before(:all) failure&quot;)
            end

            example_group.it(&quot;test&quot;) {true}
            example_group.run(options)
          end
        end

        describe ExampleGroup, &quot;#run when before(:each) fails&quot; do
          it_should_behave_like &quot;Spec::Example::ExampleGroup#run with failure in example&quot;

          before do
            ExampleGroup.before(:each) { raise NonStandardError }
          end

          it &quot;should run after(:all)&quot; do
            after_all_ran = false
            ExampleGroup.after(:all) { after_all_ran = true }
            example_group.run(options)
            after_all_ran.should be_true
          end
        end

        describe ExampleGroup, &quot;#run when any example fails&quot; do
          it_should_behave_like &quot;Spec::Example::ExampleGroup#run with failure in example&quot;

          before do
            example_group.it(&quot;should&quot;) { raise NonStandardError }
          end

          it &quot;should run after(:all)&quot; do
            after_all_ran = false
            ExampleGroup.after(:all) { after_all_ran = true }
            example_group.run(options)
            after_all_ran.should be_true
          end
        end

        describe ExampleGroup, &quot;#run when first after(:each) block fails&quot; do
          it_should_behave_like &quot;Spec::Example::ExampleGroup#run with failure in example&quot;

          before do
            class &lt;&lt; example_group
              attr_accessor :first_after_ran, :second_after_ran
            end
            example_group.first_after_ran = false
            example_group.second_after_ran = false

            example_group.after(:each) do
              self.class.second_after_ran = true
            end
            example_group.after(:each) do
              self.class.first_after_ran = true
              raise &quot;first&quot;
            end
          end

          it &quot;should run second after(:each) block&quot; do
            reporter.should_receive(:example_finished) do |example, error|
              example.should equal(example)
              error.message.should eql(&quot;first&quot;)
            end
            example_group.run(options)
            example_group.first_after_ran.should be_true
            example_group.second_after_ran.should be_true
          end
        end

        describe ExampleGroup, &quot;#run when first before(:each) block fails&quot; do
          it_should_behave_like &quot;Spec::Example::ExampleGroup#run with failure in example&quot;

          before do
            class &lt;&lt; example_group
              attr_accessor :first_before_ran, :second_before_ran
            end
            example_group.first_before_ran = false
            example_group.second_before_ran = false

            example_group.before(:each) do
              self.class.first_before_ran = true
              raise &quot;first&quot;
            end
            example_group.before(:each) do
              self.class.second_before_ran = true
            end
          end

          it &quot;should not run second before(:each)&quot; do
            reporter.should_receive(:example_finished) do |name, error|
              error.message.should eql(&quot;first&quot;)
            end
            example_group.run(options)
            example_group.first_before_ran.should be_true
            example_group.second_before_ran.should be_false
          end
        end

        describe ExampleGroup, &quot;#run when failure in after(:all)&quot; do
          it_should_behave_like &quot;Spec::Example::ExampleGroup#run with failure in example&quot;

          before do
            ExampleGroup.after(:all) { raise NonStandardError, &quot;in after(:all)&quot; }
          end

          it &quot;should return false&quot; do
            example_group.run(options).should be_false
          end
        end
      end
    end

    class ExampleSubclass &lt; ExampleGroup
    end

    describe ExampleGroup, &quot;subclasses&quot; do
      after do
        ExampleGroupFactory.reset
      end

      it &quot;should have access to the described_type&quot; do
        example_group = Class.new(ExampleSubclass) do
          describe(Array)
        end
        example_group.__send__(:described_type).should == Array
      end

      it &quot;should concat descriptions when nested&quot; do
        example_group = Class.new(ExampleSubclass) do
          describe(Array)
          $nested_group = describe(&quot;when empty&quot;) do
          end
        end
        $nested_group.description.to_s.should == &quot;Array when empty&quot;
      end
    end
  end
end
</pre>
    </div>