  <div id="fileHeader">
    <h1>step_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/story/step_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/story_helper'

module Spec
  module Story
    describe Step, &quot;#matching&quot; do
      it &quot;should match a text string&quot; do
        step = Step.new(&quot;this text&quot;) {}
        step.matches?(&quot;this text&quot;).should be_true
      end
      
      it &quot;should match a text string that has additional line returns&quot; do
        step = Step.new(&quot;this text&quot;) {}
        step.matches?(&quot;this text\n\n&quot;).should be_true
      end
      
      it &quot;should not match a text string that does not start the same&quot; do
        step = Step.new(&quot;this text&quot;) {}
        step.matches?(&quot;Xthis text&quot;).should be_false
      end
      
      it &quot;should not match a text string that does not end the same&quot; do
        step = Step.new(&quot;this text&quot;) {}
        step.matches?(&quot;this textX&quot;).should be_false
      end
      
      it &quot;should match a text string with a param&quot; do
        step = Step.new(&quot;this $param text&quot;) {}
        step.matches?(&quot;this anything text&quot;).should be_true
      end
      
      it &quot;should not be greedy&quot; do
        step = Step.new(&quot;enter $value for $key&quot;) {}
        step.parse_args(&quot;enter 3 for keys for a piano&quot;).should == ['3','keys for a piano']
      end
      
      it &quot;should match a text string with 3 params&quot; do
        step = Step.new(&quot;1 $one 2 $two 3 $three 4&quot;) {}
        step.matches?(&quot;1 a 2 b 3 c 4&quot;).should be_true
      end

      it &quot;should match a text string with two params sharing a prefix&quot; do
        step = Step.new(&quot;I am cool $n times out of $n_total&quot;)
        step.matches?(&quot;I am cool 3 times out of 7&quot;).should be_true
      end
      
      it &quot;should match a text string with a param at the beginning&quot; do
        step = Step.new(&quot;$one 2 3&quot;) {}
        step.matches?(&quot;a 2 3&quot;).should be_true
      end
      
      it &quot;should match a text string with a param at the end&quot; do
        step = Step.new(&quot;1 2 $three&quot;) {}
        step.matches?(&quot;1 2 c&quot;).should be_true
      end

      it &quot;should match a text string with a dollar sign ($)&quot; do
        step = Step.new(&quot;show me the $$money&quot;) {}
        step.matches?(&quot;show me the $kwan&quot;).should be_true
      end

      it &quot;should match a string with an escaped dollar sign&quot; do
        step = Step.new(&quot;show me the \$money&quot;) {}
        step.matches?(&quot;show me the $kwan&quot;).should be_true
      end
      
      it &quot;should not match a different string&quot; do
        step = Step.new(&quot;this text&quot;) {}
        step.matches?(&quot;other text&quot;).should be_false
      end

      it &quot;should match a regexp&quot; do
        step = Step.new(/this text/) {}
        step.matches?(&quot;this text&quot;).should be_true
      end
      
      it &quot;should match a regexp with a match group&quot; do
        step = Step.new(/this (.*) text/) {}
        step.matches?(&quot;this anything text&quot;).should be_true
      end
      
      it &quot;should match a regexp with a named variable&quot; do
        step = Step.new(/this $variable text/) {}
        step.matches?(&quot;this anything text&quot;).should be_true
      end
      
      it &quot;should not match a non matching regexp&quot; do
        step = Step.new(/this (.*) text/) {}
        step.matches?(&quot;other anything text&quot;).should be_false
      end
      
      it &quot;should not match a non matching regexp with a named variable&quot; do
        step = Step.new(/this $variable text/) {}
        step.matches?(&quot;other anything text&quot;).should be_false
      end
      
      it &quot;should not get bogged down by parens in strings&quot; do
        step = Step.new(&quot;before () after&quot;) {}
        step.matches?(&quot;before () after&quot;).should be_true
      end
      
      it &quot;should not get bogged down by regular expression special characters in strings&quot; do
        step = Step.new(&quot;These characters should work ? ( ) [ ] { } ^ !&quot;) {}
        step.matches?(&quot;These characters should work ? ( ) [ ] { } ^ !&quot;).should be_true
      end
      
      it &quot;should match any option of an alteration&quot; do
        step = Step.new(/(he|she) is cool/) {}
        step.matches?(&quot;he is cool&quot;).should be_true
        step.matches?(&quot;she is cool&quot;).should be_true
      end
      
      it &quot;should match alteration as well as a variable&quot; do
        step = Step.new(/(he|she) is (.*)/) {}
        step.matches?(&quot;he is cool&quot;).should be_true
        step.parse_args(&quot;he is cool&quot;).should == ['he', 'cool']
      end
      
      it &quot;should match alteration as well as a named variable&quot; do
        step = Step.new(/(he|she) is $adjective/) {}
        step.matches?(&quot;he is cool&quot;).should be_true
        step.parse_args(&quot;he is cool&quot;).should == ['he', 'cool']
      end
      
      it &quot;should match alteration as well as a anonymous and named variable&quot; do
        step = Step.new(/(he|she) is (.*?) $adjective/) {}
        step.matches?(&quot;he is very cool&quot;).should be_true
        step.parse_args(&quot;he is very cool&quot;).should == ['he', 'very', 'cool']
      end

      it &quot;should match a regex with a dollar sign ($)&quot; do
        step = Step.new(/show me the \$\d+/) {}
        step.matches?(&quot;show me the $123&quot;).should be_true
      end

      it &quot;should match a regex with a dollar sign and named variable&quot; do
        step = Step.new(/show me the \$$money/) {}
        step.matches?(&quot;show me the $123&quot;).should be_true
      end
      
      it &quot;should match a multiline regex&quot; do
        step = Step.new(/.*should have text.$text/) {}
        step.matches?(&lt;&lt;TEXT).should be_true
          should have text
          this is the text
          and so is this
TEXT
      end
      
      it &quot;should match the beginning of the string, not the line&quot; do
        step = Step.new(/should have text/) {}
        step.matches?(&lt;&lt;TEXT).should be_false
whatever
should have text
TEXT
      end

      it &quot;should match the end of the string, not the line&quot; do
        step = Step.new(/should have text/) {}
        step.matches?(&lt;&lt;TEXT).should be_false
should have text
whatever
TEXT
      end
    end
    
    describe Step, &quot;#parse_args&quot; do
      it &quot;should return an empty array for a text string with no parameters&quot; do
        step = Step.new(&quot;this text&quot;) {}
        step.parse_args(&quot;this text&quot;).should == []
      end
      
      it &quot;should return an empty array for a text string with additional line returns and no parameters&quot; do
        step = Step.new(&quot;this text&quot;) {}
        step.parse_args(&quot;this text\n\n&quot;).should == []
      end
    end
    
    describe Step do
      it &quot;should be pending with no block&quot; do
        step = Step.new(&quot;foo&quot;)
        lambda {
          step.perform(Object.new)
        }.should raise_error(Spec::Example::ExamplePendingError, &quot;Not Yet Implemented&quot;)
      end
      
      it &quot;should perform itself on an object&quot; do
        # given
        $instance = nil
        step = Step.new 'step' do
          $instance = self
        end
        instance = Object.new
        
        # when
        step.perform(instance, &quot;step&quot;)
        
        # then
        $instance.should == instance
      end
      
      it &quot;should perform itself with one parameter with match expression&quot; do
        # given
        $result = nil
        step = Step.new 'an account with $count dollars' do |count|
          $result = count
        end
        instance = Object.new
        
        # when
        args = step.parse_args(&quot;an account with 3 dollars&quot;)
        step.perform(instance, *args)
        
        # then
        $result.should == &quot;3&quot;
      end
      
      it &quot;should perform itself with one parameter without a match expression&quot; do
        # given
        $result = nil
        step = Step.new 'an account with a balance of' do |amount|
          $result = amount
        end
        instance = Object.new
        
        # when
        step.perform(instance, 20)
        
        # then
        $result.should == 20
      end
      
      it &quot;should perform itself with 2 parameters&quot; do
        # given
        $account_type = nil
        $amount = nil
        step = Step.new 'a $account_type account with $amount dollars' do |account_type, amount|
          $account_type = account_type
          $amount = amount
        end
        instance = Object.new
        
        # when
        args = step.parse_args(&quot;a savings account with 3 dollars&quot;)
        step.perform(instance, *args)
        
        # then
        $account_type.should == &quot;savings&quot;
        $amount.should == &quot;3&quot;
      end

      it &quot;should perform itself when defined with a regexp with 2 parameters&quot; do
        # given
        $pronoun = nil
        $adjective = nil
        step = Step.new /(he|she) is (.*)/ do |pronoun, adjective|
          $pronoun = pronoun
          $adjective = adjective
        end
        instance = Object.new
        
        # when
        args = step.parse_args(&quot;he is cool&quot;)
        step.perform(instance, *args)
        
        # then
        $pronoun.should == &quot;he&quot;
        $adjective.should == &quot;cool&quot;
      end

    end
  end
end
</pre>
    </div>