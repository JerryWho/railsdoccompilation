  <div id="fileHeader">
    <h1>be_spec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>spec/spec/matchers/be_spec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Dec 29 13:11:11 +0100 2008</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/../../spec_helper.rb'

describe &quot;should be_predicate&quot; do  
  it &quot;should pass when actual returns true for :predicate?&quot; do
    actual = stub(&quot;actual&quot;, :happy? =&gt; true)
    actual.should be_happy
  end

  it &quot;should pass when actual returns true for :predicates? (present tense)&quot; do
    actual = stub(&quot;actual&quot;, :exists? =&gt; true, :exist? =&gt; true)
    actual.should be_exist
  end

  it &quot;should fail when actual returns false for :predicate?&quot; do
    actual = stub(&quot;actual&quot;, :happy? =&gt; false)
    lambda {
      actual.should be_happy
    }.should fail_with(&quot;expected happy? to return true, got false&quot;)
  end
  
  it &quot;should fail when actual does not respond to :predicate?&quot; do
    lambda {
      Object.new.should be_happy
    }.should raise_error(NameError, /happy\?/)
  end
  
  it &quot;should fail on error other than NameError&quot; do
    actual = stub(&quot;actual&quot;)
    actual.should_receive(:foo?).and_raise(&quot;aaaah&quot;)
    lambda {
      actual.should be_foo
    }.should raise_error(/aaaah/)
  end
  
  it &quot;should fail on error other than NameError (with the present tense predicate)&quot; do
    actual = Object.new
    actual.should_receive(:foos?).and_raise(&quot;aaaah&quot;)
    lambda {
      actual.should be_foo
    }.should raise_error(/aaaah/)
  end
end

describe &quot;should_not be_predicate&quot; do
  it &quot;should pass when actual returns false for :sym?&quot; do
    actual = stub(&quot;actual&quot;, :happy? =&gt; false)
    actual.should_not be_happy
  end
  
  it &quot;should fail when actual returns true for :sym?&quot; do
    actual = stub(&quot;actual&quot;, :happy? =&gt; true)
    lambda {
      actual.should_not be_happy
    }.should fail_with(&quot;expected happy? to return false, got true&quot;)
  end

  it &quot;should fail when actual does not respond to :sym?&quot; do
    lambda {
      Object.new.should_not be_happy
    }.should raise_error(NameError)
  end
end

describe &quot;should be_predicate(*args)&quot; do
  it &quot;should pass when actual returns true for :predicate?(*args)&quot; do
    actual = mock(&quot;actual&quot;)
    actual.should_receive(:older_than?).with(3).and_return(true)
    actual.should be_older_than(3)
  end

  it &quot;should fail when actual returns false for :predicate?(*args)&quot; do
    actual = mock(&quot;actual&quot;)
    actual.should_receive(:older_than?).with(3).and_return(false)
    lambda {
      actual.should be_older_than(3)
    }.should fail_with(&quot;expected older_than?(3) to return true, got false&quot;)
  end
  
  it &quot;should fail when actual does not respond to :predicate?&quot; do
    lambda {
      Object.new.should be_older_than(3)
    }.should raise_error(NameError)
  end
end

describe &quot;should_not be_predicate(*args)&quot; do
  it &quot;should pass when actual returns false for :predicate?(*args)&quot; do
    actual = mock(&quot;actual&quot;)
    actual.should_receive(:older_than?).with(3).and_return(false)
    actual.should_not be_older_than(3)
  end
  
  it &quot;should fail when actual returns true for :predicate?(*args)&quot; do
    actual = mock(&quot;actual&quot;)
    actual.should_receive(:older_than?).with(3).and_return(true)
    lambda {
      actual.should_not be_older_than(3)
    }.should fail_with(&quot;expected older_than?(3) to return false, got true&quot;)
  end

  it &quot;should fail when actual does not respond to :predicate?&quot; do
    lambda {
      Object.new.should_not be_older_than(3)
    }.should raise_error(NameError)
  end
end

describe &quot;should be_true&quot; do
  it &quot;should pass when actual equal(true)&quot; do
    true.should be_true
  end

  it &quot;should fail when actual equal(false)&quot; do
    lambda {
      false.should be_true
    }.should fail_with(&quot;expected true, got false&quot;)
  end
end

describe &quot;should be_false&quot; do
  it &quot;should pass when actual equal(false)&quot; do
    false.should be_false
  end

  it &quot;should fail when actual equal(true)&quot; do
    lambda {
      true.should be_false
    }.should fail_with(&quot;expected false, got true&quot;)
  end
end

describe &quot;should be_nil&quot; do
  it &quot;should pass when actual is nil&quot; do
    nil.should be_nil
  end

  it &quot;should fail when actual is not nil&quot; do
    lambda {
      :not_nil.should be_nil
    }.should fail_with(&quot;expected nil? to return true, got false&quot;)
  end
end

describe &quot;should_not be_nil&quot; do
  it &quot;should pass when actual is not nil&quot; do
    :not_nil.should_not be_nil
  end

  it &quot;should fail when actual is nil&quot; do
    lambda {
      nil.should_not be_nil
    }.should fail_with(&quot;expected nil? to return false, got true&quot;)
  end
end

describe &quot;should be &lt;&quot; do
  it &quot;should pass when &lt; operator returns true&quot; do
    3.should be &lt; 4
  end

  it &quot;should fail when &lt; operator returns false&quot; do
    lambda { 3.should be &lt; 3 }.should fail_with(&quot;expected &lt; 3, got 3&quot;)
  end
end

describe &quot;should be &lt;=&quot; do
  it &quot;should pass when &lt;= operator returns true&quot; do
    3.should be &lt;= 4
    4.should be &lt;= 4
  end

  it &quot;should fail when &lt;= operator returns false&quot; do
    lambda { 3.should be &lt;= 2 }.should fail_with(&quot;expected &lt;= 2, got 3&quot;)
  end
end

describe &quot;should be &gt;=&quot; do
  it &quot;should pass when &gt;= operator returns true&quot; do
    4.should be &gt;= 4
    5.should be &gt;= 4
  end

  it &quot;should fail when &gt;= operator returns false&quot; do
    lambda { 3.should be &gt;= 4 }.should fail_with(&quot;expected &gt;= 4, got 3&quot;)
  end
end

describe &quot;should be &gt;&quot; do
  it &quot;should pass when &gt; operator returns true&quot; do
    5.should be &gt; 4
  end

  it &quot;should fail when &gt; operator returns false&quot; do
    lambda { 3.should be &gt; 4 }.should fail_with(&quot;expected &gt; 4, got 3&quot;)
  end
end

describe &quot;should be ==&quot; do
  it &quot;should pass when == operator returns true&quot; do
    5.should be == 5
  end

  it &quot;should fail when == operator returns false&quot; do
    lambda { 3.should be == 4 }.should fail_with(&quot;expected == 4, got 3&quot;)
  end
end

describe &quot;should be ===&quot; do
  it &quot;should pass when === operator returns true&quot; do
    Hash.should be === Hash.new
  end

  it &quot;should fail when === operator returns false&quot; do
    lambda { Hash.should be === &quot;not a hash&quot; }.should fail_with(%[expected === not a hash, got Hash])
  end
end

describe &quot;should_not with operators&quot; do
  it &quot;should coach user to stop using operators with should_not&quot; do
    lambda {
      5.should_not be &lt; 6
    }.should raise_error(/not only FAILED,\nit reads really poorly./m)
  end
end

describe &quot;should be&quot; do
  it &quot;should pass if actual is true or a set value&quot; do
    true.should be
    1.should be
  end

  it &quot;should fail if actual is false&quot; do
    lambda {false.should be}.should fail_with(&quot;expected true, got false&quot;)
  end

  it &quot;should fail if actual is nil&quot; do
    lambda {nil.should be}.should fail_with(&quot;expected true, got nil&quot;)
  end
end

describe &quot;should be(value)&quot; do
  it &quot;should pass if actual.equal?(value)&quot; do
    5.should be(5)
  end
  it &quot;should fail if !actual.equal?(value)&quot; do
    lambda { 5.should be(6) }.should fail_with(&quot;expected 6, got 5&quot;)
  end
end

describe &quot;'should be' with operator&quot; do
  it &quot;should include 'be' in the description&quot; do
    (be &gt; 6).description.should =~ /be &gt; 6/
    (be &gt;= 6).description.should =~ /be &gt;= 6/
    (be &lt;= 6).description.should =~ /be &lt;= 6/
    (be &lt; 6).description.should =~ /be &lt; 6/
  end
end


describe &quot;arbitrary predicate with DelegateClass&quot; do
  it &quot;should access methods defined in the delegating class (LH[#48])&quot; do
    pending(%{
      Looks like DelegateClass is delegating #should to the
      delegate. Not sure how to fix this one. Or if we even should.&quot;
    })
    require 'delegate'
    class ArrayDelegate &lt; DelegateClass(Array)
      def initialize(array)
        @internal_array = array
        super(@internal_array)
      end

      def large?
        @internal_array.size &gt;= 5
      end
    end

    delegate = ArrayDelegate.new([1,2,3,4,5,6])
    delegate.should be_large
  end
end
</pre>
    </div>