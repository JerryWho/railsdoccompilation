  <div id="fileHeader">
    <h1>haml.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/haml.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:21:07 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>dir = File.dirname(__FILE__)
$LOAD_PATH.unshift dir unless $LOAD_PATH.include?(dir)

require 'haml/version'

# = Haml (XHTML Abstraction Markup Language)
#
# Haml is a markup language
# that's used to cleanly and simply describe the XHTML of any web document,
# without the use of inline code.
# Haml functions as a replacement
# for inline page templating systems such as PHP, ERB, and ASP.
# However, Haml avoids the need for explicitly coding XHTML into the template,
# because it is actually an abstract description of the XHTML,
# with some code to generate dynamic content.
#
# == Features
#
# * Whitespace active
# * Well-formatted markup
# * DRY
# * Follows CSS conventions
# * Integrates Ruby code
# * Implements Rails templates with the .haml extension
#
# == Using Haml
#
# Haml can be used in three ways:
# as a plugin for Ruby on Rails,
# as a standalone Ruby module,
# and as a command-line tool.
# The first step for all of these is to install the Haml gem:
#
#   gem install haml
#
# To enable it as a Rails plugin,
# then run
#
#   haml --rails path/to/rails/app
#
# Once it's installed, all view files with the &quot;.html.haml&quot; extension
# will be compiled using Haml.
#
# To run Haml from the command line, just use
#
#   haml input.haml output.html
#
# Use &lt;tt&gt;haml --help&lt;/tt&gt; for full documentation.
#
# You can access instance variables in Haml templates
# the same way you do in ERb templates.
# Helper methods are also available in Haml templates.
# For example (this example uses Rails, but the principle for Merb is the same):
#
#   # file: app/controllers/movies_controller.rb
#
#   class MoviesController &lt; ApplicationController
#     def index
#       @title = &quot;Teen Wolf&quot;
#     end
#   end
#
#   -# file: app/views/movies/index.haml
#
#   #content
#    .title
#      %h1= @title
#      = link_to 'Home', home_url
#
# may be compiled to:
#
#   &lt;div id='content'&gt;
#     &lt;div class='title'&gt;
#       &lt;h1&gt;Teen Wolf&lt;/h1&gt;
#       &lt;a href='/'&gt;Home&lt;/a&gt;
#     &lt;/div&gt;
#   &lt;/div&gt;
#
# === Ruby Module
#
# Haml can also be used completely separately from Rails and ActionView.
# To do this, install the gem with RubyGems:
#
#   gem install haml
#
# You can then use it by including the &quot;haml&quot; gem in Ruby code,
# and using Haml::Engine like so:
#
#   engine = Haml::Engine.new(&quot;%p Haml code!&quot;)
#   engine.render #=&gt; &quot;&lt;p&gt;Haml code!&lt;/p&gt;\n&quot;
#
# == Characters with meaning to Haml
#
# Various characters, when placed at a certain point in a line,
# instruct Haml to render different types of things.
#
# === XHTML Tags
#
# These characters render XHTML tags.
#
# ==== %
#
#
# The percent character is placed at the beginning of a line.
# It's followed immediately by the name of an element,
# then optionally by modifiers (see below), a space,
# and text to be rendered inside the element.
# It creates an element in the form of &lt;tt&gt;&lt;element&gt;&lt;/element&gt;&lt;/tt&gt;.
# For example:
#
#   %one
#     %two
#       %three Hey there
#
# is compiled to:
#
#   &lt;one&gt;
#     &lt;two&gt;
#       &lt;three&gt;Hey there&lt;/three&gt;
#     &lt;/two&gt;
#   &lt;/one&gt;
#
# Any string is a valid element name;
# Haml will automatically generate opening and closing tags for any element.
#
# ==== {}
#
# Brackets represent a Ruby hash
# that is used for specifying the attributes of an element.
# It is literally evaluated as a Ruby hash,
# so logic will work in it and local variables may be used.
# Quote characters within the attribute
# will be replaced by appropriate escape sequences.
# The hash is placed after the tag is defined.
# For example:
#
#   %head{ :name =&gt; &quot;doc_head&quot; }
#     %script{ 'type' =&gt; &quot;text/&quot; + &quot;javascript&quot;,
#              :src   =&gt; &quot;javascripts/script_#{2 + 7}&quot; }
#
# is compiled to:
#
#   &lt;head name='doc_head'&gt;
#     &lt;script src='javascripts/script_9' type='text/javascript'&gt;
#     &lt;/script&gt;
#   &lt;/head&gt;
#
# ===== Attribute Methods
#
# A Ruby method call that returns a hash
# can be substituted for the hash contents.
# For example, Haml::Helpers defines the following method:
#
#   def html_attrs(lang = 'en-US')
#     {:xmlns =&gt; &quot;http://www.w3.org/1999/xhtml&quot;, 'xml:lang' =&gt; lang, :lang =&gt; lang}
#   end
#
# This can then be used in Haml, like so:
#
#   %html{html_attrs('fr-fr')}
#
# This is compiled to:
#
#   &lt;html lang='fr-fr' xml:lang='fr-fr' xmlns='http://www.w3.org/1999/xhtml'&gt;
#   &lt;/html&gt;
#
# You can use as many such attribute methods as you want
# by separating them with commas,
# like a Ruby argument list.
# All the hashes will me merged together, from left to right.
# For example, if you defined
#
#   def hash1
#     {:bread =&gt; 'white', :filling =&gt; 'peanut butter and jelly'}
#   end
#
#   def hash2
#     {:bread =&gt; 'whole wheat'}
#   end
#
# then
#
#   %sandwich{hash1, hash2, :delicious =&gt; true}/
#
# would compile to:
#
#   &lt;sandwich bread='whole wheat' delicious='true' filling='peanut butter and jelly' /&gt;
#
# Note that the Haml attributes list has the same syntax as a Ruby method call.
# This means that any attribute methods must come before the hash literal.
#
# ===== Boolean Attributes
#
# Some attributes, such as &quot;checked&quot; for &lt;tt&gt;input&lt;/tt&gt; tags or &quot;selected&quot; for &lt;tt&gt;option&lt;/tt&gt; tags,
# are &quot;boolean&quot; in the sense that their values don't matter -
# it only matters whether or not they're present.
# In HTML (but not XHTML), these attributes can be written as
#
#   &lt;input selected&gt;
#
# To do this in Haml, just assign a Ruby true value to the attribute:
#
#   %input{:selected =&gt; true}
#
# In XHTML, the only valid value for these attributes is the name of the attribute.
# Thus this will render in XHTML as
#
#   &lt;input selected='selected'&gt;
#
# To set these attributes to false, simply assign them to a Ruby false value.
# In both XHTML and HTML
#
#   %input{:selected =&gt; false}
#
# will just render as
#
#   &lt;input&gt;
#
# ==== []
#
# Square brackets follow a tag definition and contain a Ruby object
# that is used to set the class and id of that tag.
# The class is set to the object's class
# (transformed to use underlines rather than camel case)
# and the id is set to the object's class, followed by its id.
# Because the id of an object is normally an obscure implementation detail,
# this is most useful for elements that represent instances of Models.
# Additionally, the second argument (if present) will be used as a prefix for
# both the id and class attributes.
# For example:
#
#   # file: app/controllers/users_controller.rb
#
#   def show
#     @user = CrazyUser.find(15)
#   end
#
#   -# file: app/views/users/show.haml
#
#   %div[@user, :greeting]
#     %bar[290]/
#     Hello!
#
# is compiled to:
#
#   &lt;div class='greeting_crazy_user' id='greeting_crazy_user_15'&gt;
#     &lt;bar class='fixnum' id='fixnum_581' /&gt;
#     Hello!
#   &lt;/div&gt;
#
# ==== /
#
# The forward slash character, when placed at the end of a tag definition,
# causes the tag to be self-closed.
# For example:
#
#   %br/
#   %meta{'http-equiv' =&gt; 'Content-Type', :content =&gt; 'text/html'}/
#
# is compiled to:
#
#   &lt;br /&gt;
#   &lt;meta http-equiv='Content-Type' content='text/html' /&gt;
#
# Some tags are automatically closed, as long as they have no content.
# +meta+, +img+, +link+, +script+, +br+, and +hr+ tags are closed by default.
# This list can be customized by setting the &lt;tt&gt;:autoclose&lt;/tt&gt; option (see below).
# For example:
#
#   %br
#   %meta{'http-equiv' =&gt; 'Content-Type', :content =&gt; 'text/html'}
#
# is also compiled to:
#
#   &lt;br /&gt;
#   &lt;meta http-equiv='Content-Type' content='text/html' /&gt;
#
# ==== . and #
#
# The period and pound sign are borrowed from CSS.
# They are used as shortcuts to specify the &lt;tt&gt;class&lt;/tt&gt;
# and &lt;tt&gt;id&lt;/tt&gt; attributes of an element, respectively.
# Multiple class names can be specified in a similar way to CSS,
# by chaining the class names together with periods.
# They are placed immediately after the tag and before an attributes hash.
# For example:
#
#   %div#things
#     %span#rice Chicken Fried
#     %p.beans{ :food =&gt; 'true' } The magical fruit
#     %h1.class.otherclass#id La La La
#
# is compiled to:
#
#   &lt;div id='things'&gt;
#     &lt;span id='rice'&gt;Chicken Fried&lt;/span&gt;
#     &lt;p class='beans' food='true'&gt;The magical fruit&lt;/p&gt;
#     &lt;h1 class='class otherclass' id='id'&gt;La La La&lt;/h1&gt;
#   &lt;/div&gt;
#
# And,
#
#   #content
#     .articles
#       .article.title
#         Doogie Howser Comes Out
#       .article.date
#         2006-11-05
#       .article.entry
#         Neil Patrick Harris would like to dispel any rumors that he is straight
#
# is compiled to:
#
#   &lt;div id='content'&gt;
#     &lt;div class='articles'&gt;
#       &lt;div class='article title'&gt;Doogie Howser Comes Out&lt;/div&gt;
#       &lt;div class='article date'&gt;2006-11-05&lt;/div&gt;
#       &lt;div class='article entry'&gt;
#         Neil Patrick Harris would like to dispel any rumors that he is straight
#       &lt;/div&gt;
#     &lt;/div&gt;
#   &lt;/div&gt;
#
# ==== Implicit Div Elements
#
# Because the div element is used so often, it is the default element.
# If you only define a class and/or id using the &lt;tt&gt;.&lt;/tt&gt; or &lt;tt&gt;#&lt;/tt&gt; syntax,
# a div element is automatically used.
# For example:
#
#   #collection
#     .item
#       .description What a cool item!
#
# is the same as:
#
#   %div{:id =&gt; collection}
#     %div{:class =&gt; 'item'}
#       %div{:class =&gt; 'description'} What a cool item!
#
# and is compiled to:
#
#   &lt;div id='collection'&gt;
#     &lt;div class='item'&gt;
#       &lt;div class='description'&gt;What a cool item!&lt;/div&gt;
#     &lt;/div&gt;
#   &lt;/div&gt;
#
# ==== &gt; and &lt;
#
# &lt;tt&gt;&gt;&lt;/tt&gt; and &lt;tt&gt;&lt;&lt;/tt&gt; give you more control over the whitespace near a tag.
# &lt;tt&gt;&gt;&lt;/tt&gt; will remove all whitespace surrounding a tag,
# while &lt;tt&gt;&lt;&lt;/tt&gt; will remove all whitespace immediately within a tag.
# You can think of them as alligators eating the whitespace:
# &lt;tt&gt;&gt;&lt;/tt&gt; faces out of the tag and eats the whitespace on the outside,
# and &lt;tt&gt;&lt;&lt;/tt&gt; faces into the tag and eats the whitespace on the inside.
# They're placed at the end of a tag definition,
# after class, id, and attribute declarations
# but before &lt;tt&gt;/&lt;/tt&gt; or &lt;tt&gt;=&lt;/tt&gt;.
# For example:
#
#   %blockquote&lt;
#     %div
#       Foo!
#
# is compiled to:
#
#   &lt;blockquote&gt;&lt;div&gt;
#     Foo!
#   &lt;/div&gt;&lt;/blockquote&gt;
#
# And:
#
#   %img
#   %img&gt;
#   %img
#
# is compiled to:
#
#   &lt;img /&gt;&lt;img /&gt;&lt;img /&gt;
#
# And:
#
#  %p&lt;= &quot;Foo\nBar&quot;
#
# is compiled to:
#
#  &lt;p&gt;Foo
#  Bar&lt;/p&gt;
#
# And finally:
#
#   %img
#   %pre&gt;&lt;
#     foo
#     bar
#   %img
#
# is compiled to:
#
#   &lt;img /&gt;&lt;pre&gt;foo
#   bar&lt;/pre&gt;&lt;img /&gt;
#
# ==== =
#
# &lt;tt&gt;=&lt;/tt&gt; is placed at the end of a tag definition,
# after class, id, and attribute declarations.
# It's just a shortcut for inserting Ruby code into an element.
# It works the same as &lt;tt&gt;=&lt;/tt&gt; without a tag:
# it inserts the result of the Ruby code into the template.
# However, if the result is short enough,
# it is displayed entirely on one line.
# For example:
#
#   %p= &quot;hello&quot;
#
# is not quite the same as:
#
#   %p
#     = &quot;hello&quot;
#
# It's compiled to:
#
#   &lt;p&gt;hello&lt;/p&gt;
#
# ==== ~
#
# ~ works just like =, except that it runs Haml::Helpers#find_and_preserve on its input.
# For example,
#
#   ~ &quot;Foo\n&lt;pre&gt;Bar\nBaz&lt;/pre&gt;&quot;
#
# is the same as:
#
#   = find_and_preserve(&quot;Foo\n&lt;pre&gt;Bar\nBaz&lt;/pre&gt;&quot;)
#
# and is compiled to:
#
#   Foo
#   &lt;pre&gt;Bar&amp;#x000A;Baz&lt;/pre&gt;
#
# See also Whitespace Preservation, below.
#
# === XHTML Helpers
#
# ==== No Special Character
#
# If no special character appears at the beginning of a line,
# the line is rendered as plain text.
# For example:
#
#   %gee
#     %whiz
#       Wow this is cool!
#
# is compiled to:
#
#   &lt;gee&gt;
#     &lt;whiz&gt;
#       Wow this is cool!
#     &lt;/whiz&gt;
#   &lt;/gee&gt;
#
# ==== !!!
#
# When describing XHTML documents with Haml,
# you can have a document type or XML prolog generated automatically
# by including the characters &lt;tt&gt;!!!&lt;/tt&gt;.
# For example:
#
#   !!! XML
#   !!!
#   %html
#     %head
#       %title Myspace
#     %body
#       %h1 I am the international space station
#       %p Sign my guestbook
#
# is compiled to:
#
#   &lt;?xml version='1.0' encoding='utf-8' ?&gt;
#   &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
#   &lt;html&gt;
#     &lt;head&gt;
#       &lt;title&gt;Myspace&lt;/title&gt;
#     &lt;/head&gt;
#     &lt;body&gt;
#       &lt;h1&gt;I am the international space station&lt;/h1&gt;
#       &lt;p&gt;Sign my guestbook&lt;/p&gt;
#     &lt;/body&gt;
#   &lt;/html&gt;
#
# You can also specify the version and type of XHTML after the &lt;tt&gt;!!!&lt;/tt&gt;.
# XHTML 1.0 Strict, Transitional, and Frameset and XHTML 1.1 are supported.
# The default version is 1.0 and the default type is Transitional.
# For example:
#
#   !!! 1.1
#
# is compiled to:
#
#   &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;
#
# and
#
#   !!! Strict
#
# is compiled to:
#
#   &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
#
# while 
#
#   !!! Basic
#
# is compiled to:
#
#   &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML Basic 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd&quot;&gt; 
#
# and
#   
#   !!! Mobile
#
# is compiled to: 
#
#   &lt;!DOCTYPE html PUBLIC &quot;-//WAPFORUM//DTD XHTML Mobile 1.2//EN&quot; &quot;http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd&quot;&gt;
#
# If you're not using the UTF-8 character set for your document,
# you can specify which encoding should appear
# in the XML prolog in a similar way.
# For example:
#
#   !!! XML iso-8859-1
#
# is compiled to:
#
#   &lt;?xml version='1.0' encoding='iso-8859-1' ?&gt;
#
# ==== /
#
# The forward slash character, when placed at the beginning of a line,
# wraps all text after it in an HTML comment.
# For example:
#
#   %peanutbutterjelly
#     / This is the peanutbutterjelly element
#     I like sandwiches!
#
# is compiled to:
#
#   &lt;peanutbutterjelly&gt;
#     &lt;!-- This is the peanutbutterjelly element --&gt;
#     I like sandwiches!
#   &lt;/peanutbutterjelly&gt;
#
# The forward slash can also wrap indented sections of code. For example:
#
#   /
#     %p This doesn't render...
#     %div
#       %h1 Because it's commented out!
#
# is compiled to:
#
#   &lt;!--
#     &lt;p&gt;This doesn't render...&lt;/p&gt;
#     &lt;div&gt;
#       &lt;h1&gt;Because it's commented out!&lt;/h1&gt;
#     &lt;/div&gt;
#   --&gt;
#
# You can also use Internet Explorer conditional comments
# (about)[http://www.quirksmode.org/css/condcom.html]
# by enclosing the condition in square brackets after the &lt;tt&gt;/&lt;/tt&gt;.
# For example:
#
#   /[if IE]
#     %a{ :href =&gt; 'http://www.mozilla.com/en-US/firefox/' }
#       %h1 Get Firefox
#
# is compiled to:
#
#   &lt;!--[if IE]&gt;
#     &lt;a href='http://www.mozilla.com/en-US/firefox/'&gt;
#       &lt;h1&gt;Get Firefox&lt;/h1&gt;
#     &lt;/a&gt;
#   &lt;![endif]--&gt;
#
# ==== \ 
#
# The backslash character escapes the first character of a line,
# allowing use of otherwise interpreted characters as plain text.
# For example:
#
#   %title
#     = @title
#     \- MySite
#
# is compiled to:
#
#   &lt;title&gt;
#     MyPage
#     - MySite
#   &lt;/title&gt;
#
# ==== |
#
# The pipe character designates a multiline string.
# It's placed at the end of a line
# and means that all following lines that end with &lt;tt&gt;|&lt;/tt&gt;
# will be evaluated as though they were on the same line.
# For example:
#
#   %whoo
#     %hoo I think this might get |
#       pretty long so I should |
#       probably make it |
#       multiline so it doesn't |
#       look awful. |
#     %p This is short.
#
# is compiled to:
#
#   &lt;whoo&gt;
#     &lt;hoo&gt;
#       I think this might get pretty long so I should probably make it multiline so it doesn't look awful.
#     &lt;/hoo&gt;
#     &lt;p&gt;This is short&lt;/p&gt;
#   &lt;/whoo&gt;
#
# ==== :
#
# The colon character designates a filter.
# This allows you to pass an indented block of text as input
# to another filtering program and add the result to the output of Haml.
# The syntax is simply a colon followed by the name of the filter.
# For example,
#
#   %p
#     :markdown
#       Textile
#       =======
#
#       Hello, *World*
#
# is compiled to
#
#   &lt;p&gt;
#     &lt;h1&gt;Textile&lt;/h1&gt;
#
#     &lt;p&gt;Hello, &lt;em&gt;World&lt;/em&gt;&lt;/p&gt;
#   &lt;/p&gt;
#
# Filters can have Ruby code interpolated, like with ==.
# For example,
#
#   - flavor = &quot;raspberry&quot;
#   #content
#     :textile
#       I *really* prefer _#{h flavor}_ jam.
#
# is compiled to
#
#   &lt;div id='content'&gt;
#     &lt;p&gt;I &lt;strong&gt;really&lt;/strong&gt; prefer &lt;em&gt;raspberry&lt;/em&gt; jam.&lt;/p&gt;
#   &lt;/div&gt;
#
# Haml has the following filters defined:
#
# [plain]      Does not parse the filtered text.
#              This is useful for large blocks of text without HTML tags,
#              when you don't want lines starting with &lt;tt&gt;.&lt;/tt&gt; or &lt;tt&gt;-&lt;/tt&gt;
#              to be parsed.
#
# [javascript] Surrounds the filtered text with &lt;script&gt; and CDATA tags.
#              Useful for including inline Javascript.
#
# [escaped]    Works the same as plain, but HTML-escapes the text
#              before placing it in the document.
#
# [ruby]       Parses the filtered text with the normal Ruby interpreter.
#              All output sent to &lt;tt&gt;$stdout&lt;/tt&gt;, like with +puts+,
#              is output into the Haml document.
#              Not available if the &lt;tt&gt;suppress_eval&lt;/tt&gt; option is set to true.
#              The Ruby code is evaluated in the same context as the Haml template.
#
# [preserve]   Inserts the filtered text into the template with whitespace preserved.
#              &lt;tt&gt;preserve&lt;/tt&gt;d blocks of text aren't indented,
#              and newlines are replaced with the HTML escape code for newlines,
#              to preserve nice-looking output.
#              See also Whitespace Preservation, below.
#
# [erb]        Parses the filtered text with ERB, like an RHTML template.
#              Not available if the &lt;tt&gt;suppress_eval&lt;/tt&gt; option is set to true.
#              Embedded Ruby code is evaluated in the same context as the Haml template.
#
# [sass]       Parses the filtered text with Sass to produce CSS output.
#
# [textile]    Parses the filtered text with Textile (http://www.textism.com/tools/textile).
#              Only works if RedCloth is installed.
#
# [markdown]   Parses the filtered text with Markdown (http://daringfireball.net/projects/markdown).
#              Only works if RDiscount, RPeg-Markdown, Maruku, or BlueCloth are installed.
#
# [maruku]     Parses the filtered text with Maruku, which has some non-standard extensions to Markdown.
#
# You can also define your own filters (see Haml::Filters).
#
# === Ruby evaluators
#
# ==== =
#
# The equals character is followed by Ruby code,
# which is evaluated and the output inserted into the document as plain text.
# For example:
#
#   %p
#     = ['hi', 'there', 'reader!'].join &quot; &quot;
#     = &quot;yo&quot;
#
# is compiled to:
#
#   &lt;p&gt;
#     hi there reader!
#     yo
#   &lt;/p&gt;
#
# If the &lt;tt&gt;:escape_html&lt;/tt&gt; option is set, &lt;tt&gt;=&lt;/tt&gt; will sanitize any
# HTML-sensitive characters generated by the script. For example:
#
#   = '&lt;script&gt;alert(&quot;I\'m evil!&quot;);&lt;/script&gt;'
#
# would be compiled to
#
#   &amp;lt;script&amp;gt;alert(&amp;quot;I'm evil!&amp;quot;);&amp;lt;/script&amp;gt;
#
# ==== -
#
# The hyphen character makes the text following it into &quot;silent script&quot;:
# Ruby script that is evaluated, but not output.
#
# &lt;b&gt;It is not recommended that you use this widely;
# almost all processing code and logic should be restricted
# to the Controller, the Helper, or partials.&lt;/b&gt;
#
# For example:
#
#   - foo = &quot;hello&quot;
#   - foo &lt;&lt; &quot; there&quot;
#   - foo &lt;&lt; &quot; you!&quot;
#   %p= foo
#
# is compiled to:
#
#   &lt;p&gt;
#     hello there you!
#   &lt;/p&gt;
#
# ==== ==
#
# Two equals characters interpolates Ruby code into plain text,
# similarly to Ruby string interpolation.
# For example,
#
#   %p== This is #{h quality} cake!
#
# is the same as
#
#   %p= &quot;This is #{h quality} cake!&quot;
#
# and might compile to
#
#   &lt;p&gt;This is scrumptious cake!&lt;/p&gt;
#
# Backslashes can be used to escape &quot;#{&quot; strings,
# but they don't act as escapes anywhere else in the string.
# For example:
#
#   %p
#     == \\ Look at \\#{h word} lack of backslash: \#{foo}
#
# might compile to
#
#  &lt;p&gt;
#    \\ Look at \yon lack of backslash: #{foo}
#  &lt;/p&gt;
#
# ==== &amp;=
#
# An ampersand followed by one or two equals characters
# evaluates Ruby code just like the equals without the ampersand,
# but sanitizes any HTML-sensitive characters in the result of the code.
# For example:
#
#   &amp;= &quot;I like cheese &amp; crackers&quot;
#
# compiles to
#
#   I like cheese &amp;amp; crackers
#
# If the &lt;tt&gt;:escape_html&lt;/tt&gt; option is set,
# &amp;= behaves identically to =.
#
# ==== !=
#
# An exclamation mark followed by one or two equals characters
# evaluates Ruby code just like the equals would,
# but never sanitizes the HTML.
#
# By default, the single equals doesn't sanitize HTML either.
# However, if the &lt;tt&gt;:escape_html&lt;/tt&gt; option is set, = will sanitize the HTML, but != still won't.
# For example, if &lt;tt&gt;:escape_html&lt;/tt&gt; is set:
#
#   = &quot;I feel &lt;strong&gt;!&quot;
#   != &quot;I feel &lt;strong&gt;!&quot;
#
# compiles to
#
#   I feel &amp;lt;strong&amp;gt;!
#   I feel &lt;strong&gt;!
#
# ===== Blocks
#
# Ruby blocks, like XHTML tags, don't need to be explicitly closed in Haml.
# Rather, they're automatically closed, based on indentation.
# A block begins whenever the indentation is increased
# after a silent script command.
# It ends when the indentation decreases
# (as long as it's not an +else+ clause or something similar).
# For example:
#
#   - (42...47).each do |i|
#     %p= i
#   %p See, I can count!
#
# is compiled to:
#
#   &lt;p&gt;
#     42
#   &lt;/p&gt;
#   &lt;p&gt;
#     43
#   &lt;/p&gt;
#   &lt;p&gt;
#     44
#   &lt;/p&gt;
#   &lt;p&gt;
#     45
#   &lt;/p&gt;
#   &lt;p&gt;
#     46
#   &lt;/p&gt;
#
# Another example:
#
#   %p
#     - case 2
#     - when 1
#       = &quot;1!&quot;
#     - when 2
#       = &quot;2?&quot;
#     - when 3
#       = &quot;3.&quot;
#
# is compiled to:
#
#   &lt;p&gt;
#     2?
#   &lt;/p&gt;
#
# ==== -#
#
# The hyphen followed immediately by the pound sign
# signifies a silent comment.
# Any text following this isn't rendered in the resulting document
# at all.
#
# For example:
#
#   %p foo
#   -# This is a comment
#   %p bar
#
# is compiled to:
#
#   &lt;p&gt;foo&lt;/p&gt;
#   &lt;p&gt;bar&lt;/p&gt;
#
# You can also nest text beneath a silent comment.
# None of this text will be rendered.
# For example:
#
#   %p foo
#   -#
#     This won't be displayed
#       Nor will this
#   %p bar
#
# is compiled to:
#
#   &lt;p&gt;foo&lt;/p&gt;
#   &lt;p&gt;bar&lt;/p&gt;
#
# == Other Useful Things
#
# === Whitespace Preservation
#
# Sometimes you don't want Haml to indent all your text.
# For example, tags like +pre+ and +textarea+ are whitespace-sensitive;
# indenting the text makes them render wrong.
#
# Haml deals with this by &quot;preserving&quot; newlines before they're put into the document --
# converting them to the XHTML whitespace escape code, &lt;tt&gt;&amp;#x000A;&lt;/tt&gt;.
# Then Haml won't try to re-format the indentation.
#
# Literal +textarea+ and +pre+ tags automatically preserve their content.
# Dynamically can't be caught automatically,
# and so should be passed through Haml::Helpers#find_and_preserve or the &lt;tt&gt;~&lt;/tt&gt; command,
# which has the same effect (see above).
#
# Blocks of literal text can be preserved using the :preserve filter (see above).
#
# === Helpers
#
# Haml offers a bunch of helpers that are useful
# for doing stuff like preserving whitespace,
# creating nicely indented output for user-defined helpers,
# and other useful things.
# The helpers are all documented in the Haml::Helpers and Haml::Helpers::ActionViewExtensions modules.
#
# === Haml Options
#
# Options can be set by setting the &lt;tt&gt;Haml::Template.options&lt;/tt&gt; hash
# in &lt;tt&gt;environment.rb&lt;/tt&gt; in Rails...
#
#   Haml::Template.options[:format] = :html5
#
# ...or by setting the &lt;tt&gt;Merb::Plugin.config[:haml]&lt;/tt&gt; hash in &lt;tt&gt;init.rb&lt;/tt&gt; in Merb...
#
#   Merb::Plugin.config[:haml][:format] = :html5
# 
# ...or by passing an options hash to Haml::Engine.new.
# Available options are:
#
# [&lt;tt&gt;:format&lt;/tt&gt;]        Determines the output format. The default is :xhtml.
#                           Other options are :html4 and :html5, which are
#                           identical to :xhtml except there are no self-closing tags,
#                           XML prolog is ignored and correct DOCTYPEs are generated.
#
# [&lt;tt&gt;:escape_html&lt;/tt&gt;]   Sets whether or not to escape HTML-sensitive characters in script.
#                           If this is true, = behaves like &amp;=;
#                           otherwise, it behaves like !=.
#                           Note that if this is set, != should be used for yielding to subtemplates
#                           and rendering partials.
#                           Defaults to false.
#
# [&lt;tt&gt;:suppress_eval&lt;/tt&gt;] Whether or not attribute hashes and Ruby scripts
#                           designated by &lt;tt&gt;=&lt;/tt&gt; or &lt;tt&gt;~&lt;/tt&gt; should be
#                           evaluated. If this is true, said scripts are
#                           rendered as empty strings. Defaults to false.
#
# [&lt;tt&gt;:attr_wrapper&lt;/tt&gt;]  The character that should wrap element attributes.
#                           This defaults to &lt;tt&gt;'&lt;/tt&gt; (an apostrophe). Characters
#                           of this type within the attributes will be escaped
#                           (e.g. by replacing them with &lt;tt&gt;&amp;apos;&lt;/tt&gt;) if
#                           the character is an apostrophe or a quotation mark.
#
# [&lt;tt&gt;:filename&lt;/tt&gt;]      The name of the Haml file being parsed.
#                           This is only used as information when exceptions are raised.
#                           This is automatically assigned when working through ActionView,
#                           so it's really only useful for the user to assign
#                           when dealing with Haml programatically.
#
# [&lt;tt&gt;:line&lt;/tt&gt;]          The line offset of the Haml template being parsed.
#                           This is useful for inline templates,
#                           similar to the last argument to Kernel#eval.
#
# [&lt;tt&gt;:autoclose&lt;/tt&gt;]     A list of tag names that should be automatically self-closed
#                           if they have no content.
#                           Defaults to &lt;tt&gt;['meta', 'img', 'link', 'br', 'hr', 'input', 'area', 'param', 'col', 'base']&lt;/tt&gt;.
#
# [&lt;tt&gt;:preserve&lt;/tt&gt;]      A list of tag names that should automatically have their newlines preserved
#                           using the Haml::Helpers#preserve helper.
#                           This means that any content given on the same line as the tag will be preserved.
#                           For example:
#
#                             %textarea= &quot;Foo\nBar&quot;
#
#                           compiles to:
#
#                             &lt;textarea&gt;Foo&amp;&amp;#x000A;Bar&lt;/textarea&gt;
#
#                           Defaults to &lt;tt&gt;['textarea', 'pre']&lt;/tt&gt;.
#
#                           See also Whitespace Preservation, above.
#
module Haml

  extend Haml::Version

  # A string representing the version of Haml.
  # A more fine-grained representation is available from Haml.version.
  VERSION = version[:string] unless defined?(Haml::VERSION)

  # This method is called by init.rb,
  # which is run by Rails on startup.
  # We use it rather than putting stuff straight into init.rb
  # so we can change the initialization behavior
  # without modifying the file itself.
  def self.init_rails(binding)
    # No &amp;method here for Rails 2.1 compatibility
    %w[haml/template sass sass/plugin].each {|f| require f}
  end
end

require 'haml/util'
require 'haml/engine'
</pre>
    </div>