  <div id="fileHeader">
    <h1>exec.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/haml/exec.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 19:41:22 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'optparse'
require 'fileutils'

module Haml
  # This module handles the various Haml executables (`haml`, `sass`, `css2sass`, etc).
  module Exec
    # An abstract class that encapsulates the executable code for all three executables.
    class Generic
      # @param args [Array&lt;String&gt;] The command-line arguments
      def initialize(args)
        @args = args
        @options = {}
      end

      # Parses the command-line arguments and runs the executable.
      # Calls `Kernel#exit` at the end, so it never returns.
      def parse!
        begin
          @opts = OptionParser.new(&amp;method(:set_opts))
          @opts.parse!(@args)

          process_result

          @options
        rescue Exception =&gt; e
          raise e if @options[:trace] || e.is_a?(SystemExit)

          $stderr.puts e.message
          exit 1
        end
        exit 0
      end

      # @return [String] A description of the executable
      def to_s
        @opts.to_s
      end

      protected

      # Finds the line of the source template
      # on which an exception was raised.
      #
      # @param exception [Exception] The exception
      # @return [String] The line number
      def get_line(exception)
        # SyntaxErrors have weird line reporting
        # when there's trailing whitespace,
        # which there is for Haml documents.
        return exception.message.scan(/:(\d+)/).first.first if exception.is_a?(::SyntaxError)
        exception.backtrace[0].scan(/:(\d+)/).first.first
      end

      # Tells optparse how to parse the arguments
      # available for all executables.
      #
      # This is meant to be overridden by subclasses
      # so they can add their own options.
      #
      # @param opts [OptionParser]
      def set_opts(opts)
        opts.on('-s', '--stdin', :NONE, 'Read input from standard input instead of an input file') do
          @options[:input] = $stdin
        end

        opts.on('--trace', :NONE, 'Show a full traceback on error') do
          @options[:trace] = true
        end

        opts.on_tail(&quot;-?&quot;, &quot;-h&quot;, &quot;--help&quot;, &quot;Show this message&quot;) do
          puts opts
          exit
        end

        opts.on_tail(&quot;-v&quot;, &quot;--version&quot;, &quot;Print version&quot;) do
          puts(&quot;Haml/Sass #{::Haml.version[:string]}&quot;)
          exit
        end
      end

      # Processes the options set by the command-line arguments.
      # In particular, sets `@options[:input]` and `@options[:output]`
      # to appropriate IO streams.
      #
      # This is meant to be overridden by subclasses
      # so they can run their respective programs.
      def process_result
        input, output = @options[:input], @options[:output]
        input_file, output_file = if input
                                    [nil, open_file(@args[0], 'w')]
                                  else
                                    @options[:filename] = @args[0]
                                    [open_file(@args[0]), open_file(@args[1], 'w')]
                                  end

        input  ||= input_file
        output ||= output_file
        input  ||= $stdin
        output ||= $stdout

        @options[:input], @options[:output] = input, output
      end

      private

      def open_file(filename, flag = 'r')
        return if filename.nil?
        File.open(filename, flag)
      end
    end

    # An abstrac class that encapsulates the code
    # specific to the `haml` and `sass` executables.
    class HamlSass &lt; Generic
      # @param args [Array&lt;String&gt;] The command-line arguments
      def initialize(args)
        super
        @options[:for_engine] = {}
      end

      protected

      # Tells optparse how to parse the arguments
      # available for the `haml` and `sass` executables.
      #
      # This is meant to be overridden by subclasses
      # so they can add their own options.
      #
      # @param opts [OptionParser]
      def set_opts(opts)
        opts.banner = &lt;&lt;END
Usage: #{@name.downcase} [options] [INPUT] [OUTPUT]

Description:
  Uses the #{@name} engine to parse the specified template
  and outputs the result to the specified file.

Options:
END

        opts.on('--rails RAILS_DIR', &quot;Install Haml and Sass from the Gem to a Rails project&quot;) do |dir|
          original_dir = dir

          dir = File.join(dir, 'vendor', 'plugins')

          unless File.exists?(dir)
            puts &quot;Directory #{dir} doesn't exist&quot;
            exit
          end

          dir = File.join(dir, 'haml')

          if File.exists?(dir)
            print &quot;Directory #{dir} already exists, overwrite [y/N]? &quot;
            exit if gets !~ /y/i
            FileUtils.rm_rf(dir)
          end

          begin
            Dir.mkdir(dir)
          rescue SystemCallError
            puts &quot;Cannot create #{dir}&quot;
            exit
          end

          File.open(File.join(dir, 'init.rb'), 'w') do |file|
            file &lt;&lt; File.read(File.dirname(__FILE__) + &quot;/../../init.rb&quot;)
          end

          puts &quot;Haml plugin added to #{original_dir}&quot;
          exit
        end

        opts.on('-c', '--check', &quot;Just check syntax, don't evaluate.&quot;) do
          require 'stringio'
          @options[:check_syntax] = true
          @options[:output] = StringIO.new
        end

        super
      end

      # Processes the options set by the command-line arguments.
      # In particular, sets `@options[:for_engine][:filename]` to the input filename
      # and requires the appropriate file.
      #
      # This is meant to be overridden by subclasses
      # so they can run their respective programs.
      def process_result
        super
        @options[:for_engine][:filename] = @options[:filename] if @options[:filename]
        require File.dirname(__FILE__) + &quot;/../#{@name.downcase}&quot;
      end
    end

    # The `sass` executable.
    class Sass &lt; HamlSass
      # @param args [Array&lt;String&gt;] The command-line arguments
      def initialize(args)
        super
        @name = &quot;Sass&quot;
        @options[:for_engine][:load_paths] = ['.'] + (ENV['SASSPATH'] || '').split(File::PATH_SEPARATOR)
      end

      protected

      # Tells optparse how to parse the arguments.
      #
      # @param opts [OptionParser]
      def set_opts(opts)
        super

        opts.on('-t', '--style NAME',
                'Output style. Can be nested (default), compact, compressed, or expanded.') do |name|
          @options[:for_engine][:style] = name.to_sym
        end
        opts.on('-l', '--line-comments',
                'Line Comments. Emit comments in the generated CSS indicating the corresponding sass line.') do
          @options[:for_engine][:line_comments] = true
        end
        opts.on('-i', '--interactive',
                'Run an interactive SassScript shell.') do
          @options[:interactive] = true
        end
        opts.on('-I', '--load-path PATH', 'Add a sass import path.') do |path|
          @options[:for_engine][:load_paths] &lt;&lt; path
        end
        opts.on('--cache-location', 'The path to put cached Sass files. Defaults to .sass-cache.') do |loc|
          @options[:for_engine][:cache_location] = path
        end
        opts.on('-C', '--no-cache', &quot;Don't cache to sassc files.&quot;) do
          @options[:for_engine][:cache] = false
        end
      end

      # Processes the options set by the command-line arguments,
      # and runs the Sass compiler appropriately.
      def process_result
        if @options[:interactive]
          require 'sass'
          require 'sass/repl'
          ::Sass::Repl.new(@options).run
          return
        end

        super
        input = @options[:input]
        output = @options[:output]

        tree =
          if input.is_a?(File) &amp;&amp; !@options[:check_syntax]
            ::Sass::Files.tree_for(input.path, @options[:for_engine])
          else
            # We don't need to do any special handling of @options[:check_syntax] here,
            # because the Sass syntax checking happens alongside evaluation
            # and evaluation doesn't actually evaluate any code anyway.
            ::Sass::Engine.new(input.read(), @options[:for_engine]).to_tree
          end

        input.close() if input.is_a?(File)

        output.write(tree.render)
        output.close() if output.is_a? File
      rescue ::Sass::SyntaxError =&gt; e
        raise e if @options[:trace]
        raise &quot;Syntax error on line #{get_line e}: #{e.message}&quot;
      end
    end

    # The `haml` executable.
    class Haml &lt; HamlSass
      # @param args [Array&lt;String&gt;] The command-line arguments
      def initialize(args)
        super
        @name = &quot;Haml&quot;
        @options[:requires] = []
        @options[:load_paths] = []
      end

      # Tells optparse how to parse the arguments.
      #
      # @param opts [OptionParser]
      def set_opts(opts)
        super

        opts.on('-t', '--style NAME',
                'Output style. Can be indented (default) or ugly.') do |name|
          @options[:for_engine][:ugly] = true if name.to_sym == :ugly
        end

        opts.on('-f', '--format NAME',
                'Output format. Can be xhtml (default), html4, or html5.') do |name|
          @options[:for_engine][:format] = name.to_sym
        end

        opts.on('-e', '--escape-html',
                'Escape HTML characters (like ampersands and angle brackets) by default.') do
          @options[:for_engine][:escape_html] = true
        end

        opts.on('-r', '--require FILE', &quot;Same as 'ruby -r'.&quot;) do |file|
          @options[:requires] &lt;&lt; file
        end

        opts.on('-I', '--load-path PATH', &quot;Same as 'ruby -I'.&quot;) do |path|
          @options[:load_paths] &lt;&lt; path
        end

        opts.on('--debug', &quot;Print out the precompiled Ruby source.&quot;) do
          @options[:debug] = true
        end
      end

      # Processes the options set by the command-line arguments,
      # and runs the Haml compiler appropriately.
      def process_result
        super
        input = @options[:input]
        output = @options[:output]

        template = input.read()
        input.close() if input.is_a? File

        begin
          engine = ::Haml::Engine.new(template, @options[:for_engine])
          if @options[:check_syntax]
            puts &quot;Syntax OK&quot;
            return
          end

          @options[:load_paths].each {|p| $LOAD_PATH &lt;&lt; p}
          @options[:requires].each {|f| require f}

          if @options[:debug]
            puts engine.precompiled
            puts '=' * 100
          end

          result = engine.to_html
        rescue Exception =&gt; e
          raise e if @options[:trace]

          case e
          when ::Haml::SyntaxError; raise &quot;Syntax error on line #{get_line e}: #{e.message}&quot;
          when ::Haml::Error;       raise &quot;Haml error on line #{get_line e}: #{e.message}&quot;
          else raise &quot;Exception on line #{get_line e}: #{e.message}\n  Use --trace for backtrace.&quot;
          end
        end

        output.write(result)
        output.close() if output.is_a? File
      end
    end

    # The `html2haml` executable.
    class HTML2Haml &lt; Generic
      # @param args [Array&lt;String&gt;] The command-line arguments
      def initialize(args)
        super

        @module_opts = {}

        begin
          require 'haml/html'
        rescue LoadError =&gt; err
          dep = err.message.scan(/^no such file to load -- (.*)/)[0]
          raise err if @options[:trace] || dep.nil? || dep.empty?
          $stderr.puts &quot;Required dependency #{dep} not found!\n  Use --trace for backtrace.&quot;
          exit 1
        end
      end

      # Tells optparse how to parse the arguments.
      #
      # @param opts [OptionParser]
      def set_opts(opts)
        opts.banner = &lt;&lt;END
Usage: html2haml [options] [INPUT] [OUTPUT]

Description: Transforms an HTML file into corresponding Haml code.

Options:
END

        opts.on('-r', '--rhtml', 'Parse RHTML tags.') do
          @module_opts[:rhtml] = true
        end

        opts.on('--no-rhtml', &quot;Don't parse RHTML tags.&quot;) do
          @options[:no_rhtml] = true
        end

        opts.on('-x', '--xhtml', 'Parse the input using the more strict XHTML parser.') do
          @module_opts[:xhtml] = true
        end

        super
      end

      # Processes the options set by the command-line arguments,
      # and runs the HTML compiler appropriately.
      def process_result
        super

        input = @options[:input]
        output = @options[:output]

        @module_opts[:rhtml] ||= input.respond_to?(:path) &amp;&amp; input.path =~ /\.(rhtml|erb)$/
        @module_opts[:rhtml] &amp;&amp;= @options[:no_rhtml] != false

        output.write(::Haml::HTML.new(input, @module_opts).render)
      end
    end

    # The `css2sass` executable.
    class CSS2Sass &lt; Generic
      # @param args [Array&lt;String&gt;] The command-line arguments
      def initialize(args)
        super

        @module_opts = {}

        require 'sass/css'
      end

      # Tells optparse how to parse the arguments.
      #
      # @param opts [OptionParser]
      def set_opts(opts)
        opts.banner = &lt;&lt;END
Usage: css2sass [options] [INPUT] [OUTPUT]

Description: Transforms a CSS file into corresponding Sass code.

Options:
END

        opts.on('--old', 'Output the old-style &quot;:prop val&quot; property syntax') do
          @module_opts[:old] = true
        end

        opts.on_tail('-a', '--alternate', 'Ignored') {}

        super
      end

      # Processes the options set by the command-line arguments,
      # and runs the CSS compiler appropriately.
      def process_result
        super

        input = @options[:input]
        output = @options[:output]

        output.write(::Sass::CSS.new(input, @module_opts).render)
      end
    end
  end
end
</pre>
    </div>