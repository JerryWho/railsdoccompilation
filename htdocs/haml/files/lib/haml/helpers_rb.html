  <div id="fileHeader">
    <h1>helpers.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/haml/helpers.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:21:07 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'haml/helpers/action_view_mods'
require 'haml/helpers/action_view_extensions'

module Haml
  # This module contains various helpful methods to make it easier to do
  # various tasks. Haml::Helpers is automatically included in the context
  # that a Haml template is parsed in, so all these methods are at your
  # disposal from within the template.
  module Helpers
    self.extend self

    @@action_view_defined = defined?(ActionView)
    @@force_no_action_view = false

    # Returns whether or not ActionView is installed on the system.
    def self.action_view?
      @@action_view_defined
    end

    # Note: this does *not* need to be called
    # when using Haml helpers normally
    # in Rails.
    #
    # Initializes the current object
    # as though it were in the same context
    # as a normal ActionView rendering
    # using Haml.
    # This is useful if you want to use the helpers in a context
    # other than the normal setup with ActionView.
    # For example:
    #
    #   context = Object.new
    #   class &lt;&lt; context
    #     include Haml::Helpers
    #   end
    #   context.init_haml_helpers
    #   context.haml_tag :p, &quot;Stuff&quot;
    #
    def init_haml_helpers
      @haml_buffer = Haml::Buffer.new(@haml_buffer, Haml::Engine.new('').send(:options_for_buffer))
      nil
    end

    # call-seq:
    #   non_haml { ... }
    #
    # Runs a block of code in a non-Haml context
    # (i.e. #is_haml? will return false).
    #
    # This is mainly useful for rendering sub-templates such as partials in a non-Haml language,
    # particularly where helpers may behave differently when run from Haml.
    #
    # Note that this is automatically applied to Rails partials.
    def non_haml
      was_active = @haml_buffer.active?
      @haml_buffer.active = false
      yield
    ensure
      @haml_buffer.active = was_active
    end

    # call-seq:
    #   find_and_preserve(input, tags = haml_buffer.options[:preserve])
    #   find_and_preserve {...}
    #
    # Uses preserve to convert any newlines inside whitespace-sensitive tags
    # into the HTML entities for endlines.
    # @tags@ is an array of tags to preserve.
    # It defaults to the value of the &lt;tt&gt;:preserve&lt;/tt&gt; option.
    def find_and_preserve(input = '', tags = haml_buffer.options[:preserve], &amp;block)
      return find_and_preserve(capture_haml(&amp;block)) if block

      input = input.to_s
      input.gsub(/&lt;(#{tags.map(&amp;Regexp.method(:escape)).join('|')})([^&gt;]*)&gt;(.*?)(&lt;\/\1&gt;)/im) do
        &quot;&lt;#{$1}#{$2}&gt;#{preserve($3)}&lt;/#{$1}&gt;&quot;
      end
    end

    # call-seq:
    #   preserve(input)
    #   preserve {...}
    #
    # Takes any string, finds all the endlines and converts them to
    # HTML entities for endlines so they'll render correctly in
    # whitespace-sensitive tags without screwing up the indentation.
    def preserve(input = '', &amp;block)
      return preserve(capture_haml(&amp;block)) if block

      input.chomp(&quot;\n&quot;).gsub(/\n/, '&amp;#x000A;').gsub(/\r/, '')
    end

    alias_method :flatten, :preserve

    # Takes an Enumerable object and a block
    # and iterates over the object,
    # yielding each element to a Haml block
    # and putting the result into &lt;tt&gt;&lt;li&gt;&lt;/tt&gt; elements.
    # This creates a list of the results of the block.
    # For example:
    #
    #   = list_of([['hello'], ['yall']]) do |i|
    #     = i[0]
    #
    # Produces:
    #
    #   &lt;li&gt;hello&lt;/li&gt;
    #   &lt;li&gt;yall&lt;/li&gt;
    #
    # And
    #
    #   = list_of({:title =&gt; 'All the stuff', :description =&gt; 'A book about all the stuff.'}) do |key, val|
    #     %h3= key.humanize
    #     %p= val
    #
    # Produces:
    #
    #   &lt;li&gt;
    #     &lt;h3&gt;Title&lt;/h3&gt;
    #     &lt;p&gt;All the stuff&lt;/p&gt;
    #   &lt;/li&gt;
    #   &lt;li&gt;
    #     &lt;h3&gt;Description&lt;/h3&gt;
    #     &lt;p&gt;A book about all the stuff.&lt;/p&gt;
    #   &lt;/li&gt;
    #
    def list_of(array, &amp;block) # :yields: item
      to_return = array.collect do |i|
        result = capture_haml(i, &amp;block)

        if result.count(&quot;\n&quot;) &gt; 1
          result.gsub!(&quot;\n&quot;, &quot;\n  &quot;)
          result = &quot;\n  #{result.strip}\n&quot;
        else
          result.strip!
        end

        &quot;&lt;li&gt;#{result}&lt;/li&gt;&quot;
      end
      to_return.join(&quot;\n&quot;)
    end

    # Returns a hash containing default assignments for the xmlns and xml:lang
    # attributes of the &lt;tt&gt;html&lt;/tt&gt; HTML element.
    # It also takes an optional argument for the value of xml:lang and lang,
    # which defaults to 'en-US'.
    # For example,
    #
    #   %html{html_attrs}
    #
    # becomes
    #
    #   &lt;html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en-US' lang='en-US'&gt;
    #
    def html_attrs(lang = 'en-US')
      {:xmlns =&gt; &quot;http://www.w3.org/1999/xhtml&quot;, 'xml:lang' =&gt; lang, :lang =&gt; lang}
    end

    # Increments the number of tabs the buffer automatically adds
    # to the lines of the template.
    # For example:
    #
    #   %h1 foo
    #   - tab_up
    #   %p bar
    #   - tab_down
    #   %strong baz
    #
    # Produces:
    #
    #   &lt;h1&gt;foo&lt;/h1&gt;
    #     &lt;p&gt;bar&lt;/p&gt;
    #   &lt;strong&gt;baz&lt;/strong&gt;
    #
    def tab_up(i = 1)
      haml_buffer.tabulation += i
    end

    # Decrements the number of tabs the buffer automatically adds
    # to the lines of the template.
    #
    # See also tab_up.
    def tab_down(i = 1)
      haml_buffer.tabulation -= i
    end

    # Surrounds the given block of Haml code with the given characters,
    # with no whitespace in between.
    # For example:
    #
    #   = surround '(', ')' do
    #     %a{:href =&gt; &quot;food&quot;} chicken
    #
    # Produces:
    #
    #   (&lt;a href='food'&gt;chicken&lt;/a&gt;)
    #
    # and
    #
    #   = surround '*' do
    #     %strong angry
    #
    # Produces:
    #
    #   *&lt;strong&gt;angry&lt;/strong&gt;*
    #
    def surround(front, back = nil, &amp;block)
      back ||= front
      output = capture_haml(&amp;block)

      &quot;#{front}#{output.chomp}#{back}\n&quot;
    end

    # Prepends the given character to the beginning of the Haml block,
    # with no whitespace between.
    # For example:
    #
    #   = precede '*' do
    #     %span.small Not really
    #
    # Produces:
    #
    #   *&lt;span class='small'&gt;Not really&lt;/span&gt;
    #
    def precede(char, &amp;block)
      &quot;#{char}#{capture_haml(&amp;block).chomp}\n&quot;
    end

    # Appends the given character to the end of the Haml block,
    # with no whitespace between.
    # For example:
    #
    #   click
    #   = succeed '.' do
    #     %a{:href=&gt;&quot;thing&quot;} here
    #
    # Produces:
    #
    #   click
    #   &lt;a href='thing'&gt;here&lt;/a&gt;.
    #
    def succeed(char, &amp;block)
      &quot;#{capture_haml(&amp;block).chomp}#{char}\n&quot;
    end

    # Captures the result of the given block of Haml code,
    # gets rid of the excess indentation,
    # and returns it as a string.
    # For example, after the following,
    #
    #   .foo
    #     - foo = capture_haml(13) do |a|
    #       %p= a
    #
    # the local variable &lt;tt&gt;foo&lt;/tt&gt; would be assigned to &quot;&lt;p&gt;13&lt;/p&gt;\n&quot;.
    #
    def capture_haml(*args, &amp;block)
      buffer = eval('_hamlout', block.binding) rescue haml_buffer
      with_haml_buffer(buffer) do
        position = haml_buffer.buffer.length

        block.call(*args)

        captured = haml_buffer.buffer.slice!(position..-1).split(/^/)

        min_tabs = nil
        captured.each do |line|
          tabs = line.index(/[^ ]/) || line.length
          min_tabs ||= tabs
          min_tabs = min_tabs &gt; tabs ? tabs : min_tabs
        end

        captured.map do |line|
          line[min_tabs..-1]
        end.join
      end
    end

    def puts(*args) # :nodoc:
      warn &lt;&lt;END
DEPRECATION WARNING:
The Haml #puts helper is deprecated and will be removed in version 2.4.
Use the #haml_concat helper instead.
END
      haml_concat *args
    end

    # Outputs text directly to the Haml buffer, with the proper tabulation
    def haml_concat(text = &quot;&quot;)
      haml_buffer.buffer &lt;&lt; haml_indent &lt;&lt; text.to_s &lt;&lt; &quot;\n&quot;
      nil
    end

    # Returns the string that should be used to indent the current line
    def haml_indent
      '  ' * haml_buffer.tabulation
    end

    #
    # call-seq:
    #   haml_tag(name, *flags, attributes = {}) {...}
    #   haml_tag(name, text, *flags, attributes = {}) {...}
    #
    # Creates an HTML tag with the given name and optionally text and attributes.
    # Can take a block that will be executed
    # between when the opening and closing tags are output.
    # If the block is a Haml block or outputs text using haml_concat,
    # the text will be properly indented.
    #
    # &lt;tt&gt;flags&lt;/tt&gt; is a list of symbol flags
    # like those that can be put at the end of a Haml tag
    # (&lt;tt&gt;:/&lt;/tt&gt;, &lt;tt&gt;:&lt;&lt;/tt&gt;, and &lt;tt&gt;:&gt;&lt;/tt&gt;).
    # Currently, only &lt;tt&gt;:/&lt;/tt&gt; and &lt;tt&gt;:&lt;&lt;/tt&gt; are supported.
    #
    # For example,
    #
    #   haml_tag :table do
    #     haml_tag :tr do
    #       haml_tag :td, {:class =&gt; 'cell'} do
    #         haml_tag :strong, &quot;strong!&quot;
    #         haml_concat &quot;data&quot;
    #       end
    #       haml_tag :td do
    #         haml_concat &quot;more_data&quot;
    #       end
    #     end
    #   end
    #
    # outputs
    #
    #   &lt;table&gt;
    #     &lt;tr&gt;
    #       &lt;td class='cell'&gt;
    #         &lt;strong&gt;
    #           strong!
    #         &lt;/strong&gt;
    #         data
    #       &lt;/td&gt;
    #       &lt;td&gt;
    #         more_data
    #       &lt;/td&gt;
    #     &lt;/tr&gt;
    #   &lt;/table&gt;
    #
    def haml_tag(name, *rest, &amp;block)
      name = name.to_s
      text = rest.shift.to_s unless [Symbol, Hash, NilClass].any? {|t| rest.first.is_a? t}
      flags = []
      flags &lt;&lt; rest.shift while rest.first.is_a? Symbol
      attributes = Haml::Precompiler.build_attributes(haml_buffer.html?,
                                                      haml_buffer.options[:attr_wrapper],
                                                      rest.shift || {})

      if text.nil? &amp;&amp; block.nil? &amp;&amp; (haml_buffer.options[:autoclose].include?(name) || flags.include?(:/))
        haml_concat &quot;&lt;#{name}#{attributes} /&gt;&quot;
        return nil
      end

      if flags.include?(:/)
        raise Error.new(&quot;Self-closing tags can't have content.&quot;) if text
        raise Error.new(&quot;Illegal nesting: nesting within a self-closing tag is illegal.&quot;) if block
      end

      tag = &quot;&lt;#{name}#{attributes}&gt;&quot;
      if block.nil?
        tag &lt;&lt; text.to_s &lt;&lt; &quot;&lt;/#{name}&gt;&quot;
        haml_concat tag
        return
      end

      if text
        raise Error.new(&quot;Illegal nesting: content can't be both given to haml_tag :#{name} and nested within it.&quot;)
      end

      if flags.include?(:&lt;)
        tag &lt;&lt; capture_haml(&amp;block).strip &lt;&lt; &quot;&lt;/#{name}&gt;&quot;
        haml_concat tag
        return
      end

      haml_concat tag
      tab_up
      block.call
      tab_down
      haml_concat &quot;&lt;/#{name}&gt;&quot;
      nil
    end

    # Characters that need to be escaped to HTML entities from user input
    HTML_ESCAPE = { '&amp;'=&gt;'&amp;amp;', '&lt;'=&gt;'&amp;lt;', '&gt;'=&gt;'&amp;gt;', '&quot;'=&gt;'&amp;quot;', &quot;'&quot;=&gt;'&amp;#039;', }

    # Returns a copy of &lt;tt&gt;text&lt;/tt&gt; with ampersands, angle brackets and quotes
    # escaped into HTML entities.
    def html_escape(text)
      text.to_s.gsub(/[\&quot;&gt;&lt;&amp;]/) { |s| HTML_ESCAPE[s] }
    end

    # Escapes HTML entities in &lt;tt&gt;text&lt;/tt&gt;, but without escaping an ampersand
    # that is already part of an escaped entity.
    def escape_once(text)
      text.to_s.gsub(/[\&quot;&gt;&lt;]|&amp;(?!([a-zA-Z]+|(#\d+));)/) { |s| HTML_ESCAPE[s] }
    end

    # Returns whether or not the current template is a Haml template.
    #
    # This function, unlike other Haml::Helpers functions,
    # also works in other ActionView templates,
    # where it will always return false.
    def is_haml?
      !@haml_buffer.nil? &amp;&amp; @haml_buffer.active?
    end

    # Returns whether or not +block+ is defined directly in a Haml template.
    def block_is_haml?(block)
      eval('_hamlout', block.binding)
      true
    rescue
      false
    end

    private

    # call-seq:
    #   with_haml_buffer(buffer) {...}
    #
    # Runs the block with the given buffer as the currently active buffer.
    def with_haml_buffer(buffer)
      @haml_buffer, old_buffer = buffer, @haml_buffer
      old_buffer.active, was_active = false, old_buffer.active? if old_buffer
      @haml_buffer.active = true
      yield
    ensure
      @haml_buffer.active = false
      old_buffer.active = was_active if old_buffer
      @haml_buffer = old_buffer
    end

    # Gets a reference to the current Haml::Buffer object.
    def haml_buffer
      @haml_buffer
    end

    # Gives a proc the same local &quot;_hamlout&quot; and &quot;_erbout&quot; variables
    # that the current template has.
    def haml_bind_proc(&amp;proc)
      _hamlout = haml_buffer
      _erbout = _hamlout.buffer
      proc { |*args| proc.call(*args) }
    end

    include ActionViewExtensions if self.const_defined? &quot;ActionViewExtensions&quot;
  end
end

class Object
  # Haml overrides various ActionView helpers,
  # which call an #is_haml? method
  # to determine whether or not the current context object
  # is a proper Haml context.
  # Because ActionView helpers may be included in non-ActionView::Base classes,
  # it's a good idea to define is_haml? for all objects.
  def is_haml?
    false
  end
end

</pre>
    </div>