  <div id="fileHeader">
    <h1>constant.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/sass/constant.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:21:07 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'sass/constant/operation'
require 'sass/constant/literal'

module Sass
  module Constant # :nodoc:
    # The character that begins a constant.
    CONSTANT_CHAR   = ?!

    # Whitespace characters
    WHITESPACE = [?\ , ?\t, ?\n, ?\r]

    # The character used to escape values
    ESCAPE_CHAR = ?\\

    # The character used to open and close strings
    STRING_CHAR = ?&quot;

    # A mapping of syntactically-significant characters
    # to parsed symbols
    SYMBOLS = {
      ?( =&gt; :open,
      ?) =&gt; :close,
      ?+ =&gt; :plus,
      ?- =&gt; :minus,
      ?* =&gt; :times,
      ?/ =&gt; :div,
      ?% =&gt; :mod,
      CONSTANT_CHAR =&gt; :const,
      STRING_CHAR =&gt; :str,
      ESCAPE_CHAR =&gt; :esc
    }

    # The regular expression used to parse constants
    MATCH = /^#{Regexp.escape(CONSTANT_CHAR.chr)}([^\s#{(SYMBOLS.keys + [ ?= ]).map {|c| Regexp.escape(&quot;#{c.chr}&quot;) }.join}]+)\s*((?:\|\|)?=)\s*(.+)/

    # First-order operations
    FIRST_ORDER = [:times, :div, :mod]

    # Second-order operations
    SECOND_ORDER = [:plus, :minus]

    class &lt;&lt; self
      include Haml::Util

      def parse(value, constants, line)
        begin
          operationalize(parenthesize(tokenize(value)), constants).to_s
        rescue Sass::SyntaxError =&gt; e
          if e.message == &quot;Constant arithmetic error&quot;
            e.instance_eval do
              @message += &quot;: #{value.dump}.&quot;
            end
          end
          e.sass_line = line
          raise e
        end
      end

      private

      def tokenize(value)
        escaped = false
        is_string = false
        beginning_of_token = true
        str = ''
        to_return = []

        reset_str = Proc.new do
          to_return &lt;&lt; str unless str.empty?
          ''
        end

        each_char(value) do |byte|
          unless escaped
            if byte == ESCAPE_CHAR
              escaped = true
              next
            end

            last = to_return[-1]

            # Do we need to open or close a string literal?
            if byte == STRING_CHAR
              is_string = !is_string

              # Adjacent strings should be concatenated
              if is_string &amp;&amp; last &amp;&amp; (!last.is_a?(Symbol) || last == :close)
                to_return &lt;&lt; :concat
              end

              str = reset_str.call
              next
            end

            unless is_string

              # Are we looking at whitespace?
              if WHITESPACE.include?(byte)
                str = reset_str.call
                next
              end

              symbol = SYMBOLS[byte]

              # Adjacent values without an operator should be concatenated
              if (symbol.nil? || symbol == :open || symbol == :const) &amp;&amp;
                  last &amp;&amp; (!last.is_a?(Symbol) || last == :close)
                to_return &lt;&lt; :concat
              end

              # String then open with no whitespace means funcall
              if symbol == :open &amp;&amp; !str.empty?
                str = reset_str.call
                to_return &lt;&lt; :funcall
              end

              # Time for a unary minus!
              if beginning_of_token &amp;&amp; symbol == :minus
                beginning_of_token = true
                to_return &lt;&lt; :neg
                next
              end

              # Are we looking at an operator?
              if symbol &amp;&amp; (symbol != :mod || str.empty?)
                str = reset_str.call
                beginning_of_token = symbol != :close
                to_return &lt;&lt; symbol
                next
              end
            end
          end

          escaped = false
          beginning_of_token = false
          str &lt;&lt; byte.chr
        end

        if is_string
          raise Sass::SyntaxError.new(&quot;Unterminated string: #{value.dump}.&quot;)
        end
        str = reset_str.call
        to_return
      end

      def parenthesize(value, return_after_expr = false)
        to_return = []

        while (token = value.shift) &amp;&amp; token != :close
          case token
          when :open
            to_return &lt;&lt; parenthesize(value)
          when :neg
            # This is never actually reached, but we'll leave it in just in case.
            raise Sass::SyntaxError.new(&quot;Unterminated unary minus.&quot;) if value.first.nil?
            to_return &lt;&lt; [:neg, parenthesize(value, true)]
          when :const
            raise Sass::SyntaxError.new(&quot;Unterminated constant.&quot;) if value.first.nil?
            raise Sass::SyntaxError.new(&quot;Invalid constant.&quot;) unless value.first.is_a?(::String)

            to_return &lt;&lt; [:const, value.first]
            value.shift
          else
            to_return &lt;&lt; token
          end

          return to_return.first if return_after_expr
        end
        return to_return
      end

      #--
      # TODO: Don't pass around original value;
      #       have Constant.parse automatically add it to exception.
      #++
      def operationalize(value, constants)
        value = [value] unless value.is_a?(Array)
        case value.length
        when 0
          Sass::Constant::Nil.new
        when 1
          value = value[0]
          if value.is_a? Array
            operationalize(value, constants)
          elsif value.is_a? Operation
            value
          else
            Literal.parse(value)
          end
        when 2
          if value[0] == :neg
            Operation.new(Sass::Constant::Number.new('0'), operationalize(value[1], constants), :minus)
          elsif value[0] == :const
            Literal.parse(get_constant(value[1], constants))
          else
            raise SyntaxError.new(&quot;Constant arithmetic error&quot;)
          end
        when 3
          Operation.new(operationalize(value[0], constants), operationalize(value[2], constants), value[1])
        else
          if SECOND_ORDER.include?(value[1]) &amp;&amp; FIRST_ORDER.include?(value[3])
            operationalize([value[0], value[1], operationalize(value[2..4], constants), *value[5..-1]], constants)
          else
            operationalize([operationalize(value[0..2], constants), *value[3..-1]], constants)
          end
        end
      end

      def get_constant(value, constants)
        to_return = constants[value]
        raise SyntaxError.new(&quot;Undefined constant: \&quot;!#{value}\&quot;.&quot;) unless to_return
        to_return
      end
    end
  end
end
</pre>
    </div>