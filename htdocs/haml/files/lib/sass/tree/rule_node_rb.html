  <div id="fileHeader">
    <h1>rule_node.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>lib/sass/tree/rule_node.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Mar 28 20:21:07 +0100 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'sass/tree/node'
require 'sass/tree/attr_node'

module Sass::Tree
  class RuleNode &lt; ValueNode
    # The character used to include the parent selector
    PARENT = '&amp;'

    alias_method :rule, :value
    alias_method :rule=, :value=

    def ==(other)
      self.class == other.class &amp;&amp; rules == other.rules &amp;&amp; super
    end

    def rules
      Array(rule)
    end

    def add_rules(node)
      self.rule = rules
      self.rule += node.rules
    end

    def continued?
      rule[-1] == ?,
    end

    def to_s(tabs, super_rules = nil)
      attributes = []
      sub_rules = []

      rule_split = /\s*,\s*/
      rule_separator = @style == :compressed ? ',' : ', '
      line_separator = [:nested, :expanded].include?(@style) ? &quot;,\n&quot; : rule_separator
      rule_indent = '  ' * (tabs - 1)
      total_rule = if super_rules
        super_rules.split(&quot;,\n&quot;).map do |super_line|
          super_line.strip.split(rule_split).map do |super_rule|
            self.rules.map do |line|
              rule_indent + line.gsub(/,$/, '').split(rule_split).map do |rule|
                if rule.include?(PARENT)
                  rule.gsub(PARENT, super_rule)
                else
                  &quot;#{super_rule} #{rule}&quot;
                end
              end.join(rule_separator)
            end.join(line_separator)
          end.join(rule_separator)
        end.join(line_separator)
      elsif self.rules.any? { |r| r.include?(PARENT) }
        raise Sass::SyntaxError.new(&quot;Base-level rules cannot contain the parent-selector-referencing character '#{PARENT}'.&quot;, line)
      else
        per_rule_indent, total_indent = [:nested, :expanded].include?(@style) ? [rule_indent, ''] : ['', rule_indent]
        total_indent + self.rules.map do |r|
          per_rule_indent + r.gsub(/,$/, '').gsub(rule_split, rule_separator).rstrip
        end.join(line_separator)
      end

      children.each do |child|
        if child.is_a? RuleNode
          sub_rules &lt;&lt; child
        else
          attributes &lt;&lt; child
        end
      end

      to_return = ''
      if !attributes.empty?
        old_spaces = '  ' * (tabs - 1)
        spaces = '  ' * tabs
        if @style == :compact
          attributes = attributes.map { |a| a.to_s(1) }.join(' ')
          to_return &lt;&lt; &quot;#{total_rule} { #{attributes} }\n&quot;
        elsif @style == :compressed
          attributes = attributes.map { |a| a.to_s(1) }.join(';')
          to_return &lt;&lt; &quot;#{total_rule}{#{attributes}}&quot;
        else
          attributes = attributes.map { |a| a.to_s(tabs + 1) }.join(&quot;\n&quot;)
          end_attrs = (@style == :expanded ? &quot;\n&quot; + old_spaces : ' ')
          to_return &lt;&lt; &quot;#{total_rule} {\n#{attributes}#{end_attrs}}\n&quot;
        end
      end

      tabs += 1 unless attributes.empty? || @style != :nested
      sub_rules.each do |sub|
        to_return &lt;&lt; sub.to_s(tabs, total_rule)
      end

      to_return
    end
  end
end
</pre>
    </div>