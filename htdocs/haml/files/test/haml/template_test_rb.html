  <div id="fileHeader">
    <h1>template_test.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>test/haml/template_test.rb</td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Oct 12 14:57:00 +0200 2009</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#!/usr/bin/env ruby
require File.dirname(__FILE__) + '/../test_helper'
require 'haml/template'
require 'sass/plugin'
require File.dirname(__FILE__) + '/mocks/article'

require 'action_pack/version'

module Haml::Filters::Test
  include Haml::Filters::Base

  def render(text)
    &quot;TESTING HAHAHAHA!&quot;
  end
end

module Haml::Helpers
  def test_partial(name, locals = {})
    Haml::Engine.new(File.read(File.join(TemplateTest::TEMPLATE_PATH, &quot;_#{name}.haml&quot;))).render(self, locals)
  end
end

class Egocentic
  def method_missing(*args)
    self
  end
end

class DummyController
  attr_accessor :logger
  def initialize
    @logger = Egocentic.new
  end
    
  def self.controller_path
    ''
  end

  def controller_path
    ''
  end
end

class TemplateTest &lt; Test::Unit::TestCase
  TEMPLATE_PATH = File.join(File.dirname(__FILE__), &quot;templates&quot;)
  TEMPLATES = %w{         very_basic        standard    helpers
    whitespace_handling   original_engine   list        helpful
    silent_script         tag_parsing       just_stuff  partials
    filters               nuke_outer_whitespace         nuke_inner_whitespace
    render_layout }
  # partial layouts were introduced in 2.0.0
  TEMPLATES &lt;&lt; 'partial_layout' unless ActionPack::VERSION::MAJOR &lt; 2

  def setup
    @base = create_base

    # filters template uses :sass
    Sass::Plugin.options.update(:line_comments =&gt; true, :style =&gt; :compact)
  end

  def create_base
    vars = { 'article' =&gt; Article.new, 'foo' =&gt; 'value one' }
    
    unless Haml::Util.has?(:instance_method, ActionView::Base, :finder)
      base = ActionView::Base.new(TEMPLATE_PATH, vars)
    else
      # Rails 2.1.0
      base = ActionView::Base.new([], vars)
      base.finder.append_view_path(TEMPLATE_PATH)
    end
    
    if Haml::Util.has?(:private_method, base, :evaluate_assigns)
      base.send(:evaluate_assigns)
    else
      # Rails 2.2
      base.send(:_evaluate_assigns_and_ivars)
    end

    # This is used by form_for.
    # It's usually provided by ActionController::Base.
    def base.protect_against_forgery?; false; end

    base.controller = DummyController.new
    base
  end

  def render(text)
    Haml::Engine.new(text).to_html(@base)
  end

  def load_result(name)
    @result = ''
    File.new(File.dirname(__FILE__) + &quot;/results/#{name}.xhtml&quot;).each_line { |l| @result += l }
    @result
  end

  def assert_renders_correctly(name, &amp;render_method)
    if ActionPack::VERSION::MAJOR &lt; 2 ||
        (ActionPack::VERSION::MAJOR == 2 &amp;&amp; ActionPack::VERSION::MINOR &lt; 2)
      render_method ||= proc { |name| @base.render(name) }
    else
      render_method ||= proc { |name| @base.render(:file =&gt; name) }
    end

    load_result(name).split(&quot;\n&quot;).zip(render_method[name].split(&quot;\n&quot;)).each_with_index do |pair, line|
      message = &quot;template: #{name}\nline:     #{line}&quot;
      assert_equal(pair.first, pair.last, message)
    end
  rescue ActionView::TemplateError =&gt; e
    if e.message =~ /Can't run [\w:]+ filter; required (one of|file) ((?:'\w+'(?: or )?)+)(, but none were found| not found)/
      puts &quot;\nCouldn't require #{$2}; skipping a test.&quot;
    else
      raise e
    end
  end

  def test_empty_render_should_remain_empty
    assert_equal('', render(''))
  end

  TEMPLATES.each do |template|
    define_method &quot;test_template_should_render_correctly [template: #{template}] &quot; do
      assert_renders_correctly template
    end
  end

  def test_templates_should_render_correctly_with_render_proc
    assert_renders_correctly(&quot;standard&quot;) do |name|
      engine = Haml::Engine.new(File.read(File.dirname(__FILE__) + &quot;/templates/#{name}.haml&quot;))
      engine.render_proc(@base).call
    end
  end
  
  def test_templates_should_render_correctly_with_def_method
    assert_renders_correctly(&quot;standard&quot;) do |name|
      engine = Haml::Engine.new(File.read(File.dirname(__FILE__) + &quot;/templates/#{name}.haml&quot;))
      engine.def_method(@base, &quot;render_standard&quot;)
      @base.render_standard
    end
  end

  def test_action_view_templates_render_correctly
    proc = lambda do
      @base.content_for(:layout) {'Lorem ipsum dolor sit amet'}
      assert_renders_correctly 'content_for_layout'
    end

    if @base.respond_to?(:with_output_buffer)
      @base.with_output_buffer(&quot;&quot;, &amp;proc)
    else
      proc.call
    end
  end

  def test_instance_variables_should_work_inside_templates
    @base.instance_variable_set(&quot;@content_for_layout&quot;, 'something')
    assert_equal(&quot;&lt;p&gt;something&lt;/p&gt;&quot;, render(&quot;%p= @content_for_layout&quot;).chomp)

    @base.instance_eval(&quot;@author = 'Hampton Catlin'&quot;)
    assert_equal(&quot;&lt;div class='author'&gt;Hampton Catlin&lt;/div&gt;&quot;, render(&quot;.author= @author&quot;).chomp)

    @base.instance_eval(&quot;@author = 'Hampton'&quot;)
    assert_equal(&quot;Hampton&quot;, render(&quot;= @author&quot;).chomp)

    @base.instance_eval(&quot;@author = 'Catlin'&quot;)
    assert_equal(&quot;Catlin&quot;, render(&quot;= @author&quot;).chomp)
  end

  def test_instance_variables_should_work_inside_attributes
    @base.instance_eval(&quot;@author = 'hcatlin'&quot;)
    assert_equal(&quot;&lt;p class='hcatlin'&gt;foo&lt;/p&gt;&quot;, render(&quot;%p{:class =&gt; @author} foo&quot;).chomp)
  end

  def test_template_renders_should_eval
    assert_equal(&quot;2\n&quot;, render(&quot;= 1+1&quot;))
  end

  def test_haml_options
    Haml::Template.options = { :suppress_eval =&gt; true }
    assert_equal({ :suppress_eval =&gt; true }, Haml::Template.options)
    old_base, @base = @base, create_base
    assert_renders_correctly(&quot;eval_suppressed&quot;)
    @base = old_base
    Haml::Template.options = {}
  end

  def test_exceptions_should_work_correctly
    begin
      render(&quot;- raise 'oops!'&quot;)
    rescue Exception =&gt; e
      assert_equal(&quot;oops!&quot;, e.message)
      assert_match(/^\(haml\):1/, e.backtrace[0])
    else
      assert false
    end

    template = &lt;&lt;END
%p
  %h1 Hello!
  = &quot;lots of lines&quot;
  = &quot;even more!&quot;
  - raise 'oh no!'
  %p
    this is after the exception
    %strong yes it is!
ho ho ho.
END

    begin
      render(template.chomp)
    rescue Exception =&gt; e
      assert_match(/^\(haml\):5/, e.backtrace[0])
    else
      assert false
    end
  end  
end
</pre>
    </div>